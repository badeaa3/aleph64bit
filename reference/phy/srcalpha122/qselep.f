      SUBROUTINE QSELEP(SLOUT,XBANK,ICLEP,IERR)
CKEY QSELEP/INTERNAL
C-----------------------------------------------------------------------
C! Lepton selection for Heavy Flavour (QSELEP algorithm)
C     QSELEP from LEPTAG written by Mark Parsons , 1st version in June 1
C                extracted from LEPTAG by   I.Ten Have            July 1
C                 &             HEVLEP from P.Perret
C     Adapted to ALPHA by M-N Minard                            10-Nov-1
C
C This subroutine implements the lepton selection definition given in
C Aleph-note ALEPH 92-101 "Lepton and jet definitions for the lepton pap
C (D. Abbaneo et al). It finds all high momentum e+,e-,mu+, and mu- part
C in an event and calculates their inclusive and exclusive Pt. It create
C bank PDLT for Lepton id and PLJT for recording the jet used in that
C analysis.
C
C Monte carlo truth available is calculated and stored in PMLT bank
C
C Inputs:
C -------
C           INTEGER SLOUT    = Unit number on which debug and QSELEP err
C                              information is to be written.
C           LOGICAL XBANK    = Controls whether the PDLT bank will be
C                              produced and filled
C Outputs:
C --------
C           INTEGER ICLEP    = The number of leptons found in the event
C
C           INTEGER IERR     = Error return code from the lepton finder
C
C     IERR = 0     ! No error occurred
C     IERR < 0     ! An error occurred while processing the event.
C
C     IERR = -1    ! Too few good tracks.
C     IERR = -2    ! LEP energy too low or too high.
C     IERR = -3    ! Less than 10% of LEP energy visible.
C     IERR = -4    ! While trying to find the charge of a lepton
C                  ! ALPHA returned the "incorrect" charge.
C     IERR = -5    ! The BOS space booked for leptons and the number
C                  ! of leptons written out differ.
C     IERR = -6    ! BOS was unable to book the space requested.
C     IERR = -7    ! There were less than 2 jets in this event.
C     IERR = -8    ! Lepton to jet search failed.
C     IERR = -9    ! Lepton Pt calculation failed.
C     IERR = -10   ! Event has bad HV or DAQ status.
C     IERR = -11   ! Event has either no tracks or no energy flow object
C     IERR = -12   ! Unable to calculate the year corresponding to this
C     IERR = -13   ! QTRUTH returned an undocumented value.
C
C-----------------------------------------------------------------------
      IMPLICIT NONE
C ALPHA Version 122 - Implicit declaration include file : 12 April 1996
      INTEGER LCOLS, LROWS, KROW, KNEXT, ITABL,LFRWRD, LFRROW
      REAL RTABL
      INTEGER ID, NRBOS, L
      REAL ATG
      REAL QQPI,QQE,QQ2PI,QQPIH,QQRADP,QQC,QQH,QQHC,QQIRP,QELEP,QMFLD
      REAL QMFLDC,QTIME,QTIMEI,QTIMEL,QTIMES,QTIMET,QDHEEC,QDHEEL
      REAL QDHEPF,QDHETH,QDHEPH,QDHEEF,QDHEET,QDHET1,QDHEP1,QDHET2
      REAL QDHEP2,QDHEE1,QDHEE2,QDHEE3,QKEVRN,QKEVWT,QVXNOM,QVYNOM
      REAL QVZNOM,QVXNSG,QVYNSG,QVZNSG,QINLUM,QRINLN,QRINLU,QDBOFS
      REAL QEECWI,QVXBOM,QVYBOM,QSILUM,QRSLLU,QRSLBK,QRSLEW,QVTXBP
      REAL QVTEBP,QVTSBP,QSQT,QF,QP,QX,QY,QZ,QE,QM,QCH,QCT,QDB
      REAL QZB,QDBS2,QZBS2,QBC2,QSIG,QSMAT,QSIGX,QSIGY,QSIGZ,QSIGEE
      REAL QSIGE,QSIGPP,QSIGP,QSIGMM,QSIGM,QMCHIF,QPH,QPT,QRDFL,QVX,QVY
      REAL QVZ,QVEM,QVCHIF,QVDIF2,QVDIF3,QMSQ2,QMSQ3,QMSQ4,QM2,QM3,QM4
      REAL QDMSQ,QBETA,QGAMMA,QDOT3,QDOT4,QCOSA,QPPAR,QPPER,QCMASS
      REAL QCCHAR,QCLIFE,QCWIDT,QFRFIR,QFRFTL,QFRFP0,QFRFD0,QFRFZ0
      REAL QFRFAL,QFRFEM,QFRFC2,QFRIPE,QFRIPM,QFRIPI,QFRIPK,QFRIPP
      REAL QFRINK,QTEXTM,QTEXTL,QTEXAD,QEIDRI,QEIDEC,QEIDEI,QHMAED
      REAL QHMACS,QMCADH,QMCADC,QMCAAM,QMCAAC,QMUISR,QMUIDM,QPECER
      REAL QPECE1,QPECE2,QPECTH,QPECPH,QPECEC,QPEPT1,QPEPP1,QPEPT3
      REAL QPEPP3,QPHCER,QPHCTH,QPHCPH,QPHCEC,QEFOWE,QEGPR1,QEGPR2
      REAL QEGPF4,QEGPDM,QPGPR1,QPGPR2,QPGPF4,QPGPDM,QPGPST,QPGPQ1
      REAL QPGPQ2,QPGPM1,QPGPM2,QPGPMA,QPGPER,QPGPTR,QPGPPR,QYV0VX
      REAL QYV0VY,QYV0VZ,QYV0X1,QYV0X2,QYV0C2,QYV0DM,QYV0S1,QYV0S2
      REAL QDECA2,QDECAN,QMASV0,QMCHI2,QMDIFF,QPCHAR,QPLIFE,QPMASS
      REAL QPWIDT,QKBLOK,QPGAEF,QPGAGC,QPGAZS,QPGAPL,QPGAPH
      REAL QLEPPI,QLEPPE
      INTEGER KI, KI1,KI2
      INTEGER KCQDET,KCQFPA,KCQPAR,KCQVEC,KCQVRT,KHE,KHMU,KHPI,KHK,KHP
      INTEGER KHPHOT,KHNHAD,KMONTE,KRECO,KLOCKM,KSOVT,KSCHT,KSIST,KSAST
      INTEGER KSEHT,KSV0T,KSDCT,KSEFT,KSNET,KSGAT,KSJET,KSMCT,KSREV
      INTEGER KSMCV,KUNDEF,KFOVT,KLOVT,KNOVT,KFCHT,KLCHT,KNCHT,KFIST
      INTEGER KLIST,KNIST,KFAST,KLAST,KNAST,KFEHT,KLEHT,KNEHT,KFV0T
      INTEGER KLV0T,KNV0T,KFDCT,KLDCT,KNDCT,KFEFT,KLEFT,KNEFT,KFNET
      INTEGER KLNET,KNNET,KFGAT,KLGAT,KNGAT,KFJET,KLJET,KNJET,KFMCT
      INTEGER KLMCT,KNMCT,KFREV,KLREV,KNREV,KFMCV,KLMCV,KNMCV,KLUST
      INTEGER KLUSV,KFFRT,KLFRT,KFFRV,KLFRV,KNRET,KNCOT,KFFRD,KBIT
      INTEGER KCLACO,KCLAFR,KCLARM,KDEBUG,KEVT,KEXP,KFFILL,KFEOUT
      INTEGER KJOPTN,KLEOUT,KLROUT,KLOCK0,KLOCK1,KLOCK2,KMATIX,KMQFPA
      INTEGER KNEFIL,KNEOUT,KNEVT,KNPAST,KNQDET,KNQFPA,KNQLIN,KNQMTX
      INTEGER KNQPAR,KNQPST,KNREIN,KNREOU,KOQDET,KOQFPA,KOQLIN,KOQMTL
      INTEGER KOQMTS,KOQPAR,KOQPBT,KOQPLI,KOQTRA,KOQVEC,KOQVRT,KQPAR
      INTEGER KQVEC,KQVRT,KQWRK,KQZER,KRUN,KSTATU,KTDROP,KUCARD,KUCONS
      INTEGER KUHIST,KUINPU,KUOUTP,KUPRNT,KUPTER,KDEBU1,KDEBU2,KNWRLM
      INTEGER KEFOPT,KUEDIN,KUEDOU,KURTOX,KUCAR2,KNHDRN,KNBHAB,KSBHAB
      INTEGER KRSLLQ,KRSLNB,INDATA,KRINNE,KRINNF,KRINDC,KRINDQ,KRINNZ
      INTEGER KRINNB,KRINBM,KRINFR,KRINLR,KRINLF,KEVERT,KEVEDA,KEVETI
      INTEGER KEVEMI,KEVETY,KEVEES,KDHEFP,KDHENP,KDHENM,KKEVNT,KKEVNV
      INTEGER KKEVID,KDHENX,KDHENV,KDHENJ,KREVDS,KXTET1,KXTET2,KXTEL2
      INTEGER KXTCGC,KXTCLL,KXTCBN,KXTCCL,KXTCHV,KXTCEN,KCLASW,KERBOM
      INTEGER KBPSTA,KLOCUS,KFRET,KLRET,KFCOT,KLCOT,NAAFID,NAAJOB
      INTEGER NAASEV,NABCNT,NABHIT,NABOMB,NABOME,NABOMP,NABOMR,NABPTR
      INTEGER NADCAL,NADCRL,NADECO,NADEID,NADENF,NADEVT,NADEWI,NADFMC
      INTEGER NADFOT,NADGAM,NADHCO,NADHEA,NADHRL,NADJET,NADMID,NADMJT
      INTEGER NADMUO,NADNEU,NADPOB,NADRES,NADTBP,NADTMC,NADTRA,NADVER
      INTEGER NADVMC,NAECRQ,NAECTE,NAEGID,NAEGPC,NAEIDT,NAEJET,NAERRF
      INTEGER NAETDI,NAETKC,NAEVEH,NAEWHE,NAFICL,NAFKIN,NAFPOI,NAFPOL
      INTEGER NAFRFT,NAFRID,NAFRTL,NAFSTR,NAFTCL,NAFTCM,NAFTOC,NAFTTM
      INTEGER NAFVCL,NAFVER,NAFZFR,NAHCCV,NAHCTE,NAHINF,NAHMAD,NAHPDI
      INTEGER NAHROA,NAHSDA,NAHTUB,NAIASL,NAIPJT,NAIRJT,NAITCO,NAITMA
      INTEGER NAIXTR,NAIZBD,NAJBER,NAJEST,NAJSUM,NAKEVH,NAKINE,NAKJOB
      INTEGER NAKLIN,NAKPOL,NAKRUN,NALIDT,NALOLE,NALUPA,NAMCAD,NAMHIT
      INTEGER NAMTHR,NAMUDG,NAMUEX,NAOSTS,NAPART,NAPASL,NAPCHY,NAPCOB
      INTEGER NAPCOI,NAPCPA,NAPCQA,NAPCRL,NAPECO,NAPEHY,NAPEID,NAPEMH
      INTEGER NAPEPT,NAPEST,NAPEWI,NAPFER,NAPFHR,NAPFRF,NAPFRT,NAPHCO
      INTEGER NAPHER,NAPHHY,NAPHMH,NAPHST,NAPIDI,NAPITM,NAPLID,NAPLPD
      INTEGER NAPLSD,NAPMSK,NAPNEU,NAPPDS,NAPPOB,NAPPRL,NAPRTM,NAPSCO
      INTEGER NAPSPO,NAPSTR,NAPT2X,NAPTBC,NAPTCO,NAPTEX,NAPTMA,NAPTML
      INTEGER NAPTNC,NAPTST,NAPVCO,NAPYER,NAPYFR,NAPYNE,NAQDET,NAQFPA
      INTEGER NAQLIN,NAQMTL,NAQMTS,NAQPAR,NAQPBT,NAQPLI,NAQTRA,NAQVEC
      INTEGER NAQVRT,NAQWRK,NAQZER,NAREVH,NARHAH,NARTLO,NARTLS,NARUNH
      INTEGER NARUNR,NASFTR,NATEXS,NATGMA,NATMTL,NATPCO,NAVCOM,NAVCPL
      INTEGER NAVDCO,NAVDHT,NAVDXY,NAVDZT,NAVERT,NAVFHL,NAVFLG,NAVFPH
      INTEGER NAVHLS,NAVPLH,NAX1AD,NAX1SC,NAX1TI,NAX2DF,NAX3EC,NAX3EW
      INTEGER NAX3HC,NAX3IT,NAX3L2,NAX3LU,NAX3TM,NAX3TO,NAX3TP,NAX3X3
      INTEGER NAXTBN,NAXTBP,NAXTCN,NAXTEB,NAXTOP,NAXTRB,NAYV0V,NAZPFR
      INTEGER NANBIP,NAPGAC,NAPMSC,NAPTHR,NAPDLT,NAPMLT,NAPLJT
      INTEGER NAEFOL,NAMUID,NAPGID,NAPGPC,JQVEQX,JQVEQY,JQVEQZ,JQVEQE
      INTEGER JQVEQM,JQVEQP,JQVECH,JQVETN,JQVESC,JQVEKS,JQVECL,JQVEPA
      INTEGER JQVEQD,JQVENP,JQVESP,JQVEOV,JQVEEV,JQVEND,JQVEDL,JQVENO
      INTEGER JQVEOL,JQVENM,JQVEML,JQVEBM,JQVELK,JQVEDB,JQVEZB,JQVESD
      INTEGER JQVESZ,JQVECB,JQVEEM,JQVECF,JQVEEW,JQVEUS,JQVRVX,JQVRVY
      INTEGER JQVRVZ,JQVRVN,JQVRTY,JQVRIP,JQVRND,JQVRDL,JQVRAY,JQVRAF
      INTEGER JQVREM,JQVRCF,JQVRET,JQDEAF,JQDEAL,JQDENT,JQDEAT,JQDELT
      INTEGER JQDEAE,JQDEAH,JQDEAM,JQDECF,JQDEEC,JQDEHC,JQDEET,JQDEFI
      INTEGER JQDENF,JQDEFL,JQDENE,JQDEEL,JQDENH,JQDEHL,JQDELH,JQDEEF
      INTEGER JQDEPC,JQDEEG,JQDEMU,JQDEDX,JQDEPG,JQPAGN,JQPANA,JQPACO
      INTEGER JQPAMA,JQPACH,JQPALT,JQPAWI,JQPAAN
      INTEGER KJQDET,KCH,KTN,KMC
      INTEGER KBMASK,KCALFL,KCHGD,KCLASS,KDAU,KECAL,KENDV,KFOLLO,KHCAL
      INTEGER KLUNDS,KNCHGD,KNECAL,KNHCAL,KNMOTH,KMOTH,KMTCH,KNDAU
      INTEGER KNMTCH,KORIV,KSAME,KSMTCH,KSTABC,KTPCOD,KRDFL,KVN,KVTYPE
      INTEGER KVINCP,KVNDAU,KVYV0V,KVFVER,KVDAU,KI3,KI4,KFRFDF,KFRFNO
      INTEGER KFRTNV,KFRTNI,KFRTNE,KFRTNT,KFRTNR,KFRIBP,KFRIDZ,KFRIBC
      INTEGER KFRIDC,KFRIQF,KNTEX,KTEXSI,KTEXNS,KEIDIF,KEIDIP,KHMANF
      INTEGER KHMANE,KHMANL,KHMAMH,KHMAIG,KHMAND,KHMAIE,KHMAIT,KHMAIF
      INTEGER KMCANH,KMUIIF,KMUIST,KMUITN,KPECKD,KPECCC,KPECRB,KPECPC
      INTEGER KPHCKD,KPHCCC,KPHCRB,KPHCPC,KEFOTY,KEFOLE,KEFOLT,KEFOLH
      INTEGER KEFOLC,KEFOLJ,KPCQNA,KEGPST,KEGPQU,KEGPPE,KPGPQU,KPGPPE
      INTEGER KYV0K1,KYV0K2,KYV0IC,KSCNEW,KSCOLD,KFPADR,KGLUND,KMCCOD
      INTEGER KCANTI,KCDIR,KCDIRA,KCHT,KIDSAV,KPANTI,KPART,KPDIR,KPDIRA
      INTEGER KTLOR,KTLOR1,KVFITA,KVFITC,KVFITM,KVFITN,KVFITV,KVFTMC
      INTEGER KTLORX,KVGOOD,KVNEW,KVSAVA,KVSAVC,KVSAVE,KPARTX,KPCCOMP
      INTEGER KPGAPN,KPGAFA,KPGAPE,KLEPPA,KLEPJT,KLEPFL,KLEPPO,KLEPCH
      INTEGER KPGAST,KLEPVP,KLEPSP,KLEPLE,KLEPME,KLEPKT,JQDEPD,JQDEPM
      INTEGER KLFJET,KLLJET,KLNJET,KLJTNO
C-------------------- /QCDE/ --- COMMONs, DIMENSIONs, etc. ------------
C Start of QCDESH ----------------------- Description in QDATA ---------
      PARAMETER (KCQDET=34, KCQFPA=8, KCQPAR=10, KCQVEC=73, KCQVRT=30,
     & KHE=1, KHMU=2, KHPI=3, KHK=4, KHP=5, KHPHOT=1, KHNHAD=2,
     & KMONTE=-2, KRECO=-1, KLOCKM=14, KSOVT=1, KSCHT=2, KSIST=3,
     & KSAST=4, KSEHT=5, KSV0T=6, KSDCT=7, KSEFT=8, KSNET=9, KSGAT=10,
     & KSJET=11, KSMCT=12, KSREV=13,
     & KSMCV=14, KUNDEF=-12344321, QQPI=3.141593, QQE=2.718282,
     & QQ2PI=QQPI*2., QQPIH=QQPI/2., QQRADP=180./QQPI, QQC=2.997925E10,
     & QQH=6.582173E-25, QQHC=QQH*QQC, QQIRP=.00029979)
      CHARACTER CQDATE*8, CQDWRK*80, CQFHIS*80, CQFOUT*80, CQFWRK*80,
     & CQHTIT*80, CQSEC*3, CQTIME*8, CQUNPK*30, CQVERS*6, CQRLST*800,
     & CQELST*800
      COMMON /QCDEC/ CQDATE, CQDWRK, CQFHIS, CQFOUT, CQFWRK, CQHTIT,
     & CQSEC(14), CQTIME, CQUNPK, CQVERS, CQRLST, CQELST
      COMMON /QCDE/ QELEP, QMFLD ,QMFLDC, QTIME, QTIMEI, QTIMEL,
     & QTIMES, QTIMET, QDHEEC, QDHEEL, QDHEPF, QDHETH, QDHEPH, QDHEEF,
     & QDHEET, QDHET1, QDHEP1, QDHET2, QDHEP2, QDHEE1, QDHEE2, QDHEE3,
     & QKEVRN, QKEVWT, QVXNOM, QVYNOM, QVZNOM, QVXNSG, QVYNSG, QVZNSG,
     & QINLUM, QRINLN, QRINLU, QDBOFS, QEECWI(36), QVXBOM, QVYBOM,
     & QSILUM, QRSLLU, QRSLBK, QRSLEW , QVTXBP(3), QVTEBP(3), QVTSBP(3)
      COMMON /QCDE/  KFOVT, KLOVT, KNOVT, KFCHT, KLCHT, KNCHT, KFIST,
     & KLIST, KNIST, KFAST, KLAST, KNAST, KFEHT, KLEHT, KNEHT, KFV0T,
     & KLV0T, KNV0T, KFDCT, KLDCT, KNDCT, KFEFT, KLEFT, KNEFT, KFNET,
     & KLNET, KNNET, KFGAT, KLGAT, KNGAT, KFJET, KLJET, KNJET, KFMCT,
     & KLMCT, KNMCT, KFREV, KLREV, KNREV, KFMCV, KLMCV, KNMCV, KLUST,
     & KLUSV, KFFRT, KLFRT, KFFRV, KLFRV, KNRET, KNCOT, KFFRD,
     & KLFJET,KLLJET,KLNJET
      COMMON /QCDE/ KBIT(32), KCLACO(KCQFPA), KCLAFR(KCQFPA), KCLARM
     & (KCQFPA), KDEBUG, KEVT, KEXP, KFFILL, KFEOUT, KJOPTN(2,2),
     & KLEOUT, KLROUT, KLOCK0(KLOCKM,2), KLOCK1(KLOCKM,2), KLOCK2(
     & KLOCKM,2), KMATIX(6,6), KMQFPA, KNEFIL, KNEOUT, KNEVT, KNPAST,
     & KNQDET, KNQFPA, KNQLIN, KNQMTX, KNQPAR, KNQPST, KNREIN, KNREOU,
     & KOQDET, KOQFPA, KOQLIN, KOQMTL, KOQMTS, KOQPAR, KOQPBT, KOQPLI,
     & KOQTRA, KOQVEC, KOQVRT, KQPAR, KQVEC, KQVRT, KQWRK, KQZER, KRUN,
     & KSTATU, KTDROP, KUCARD, KUCONS, KUHIST, KUINPU, KUOUTP, KUPRNT,
     & KUPTER, KDEBU1, KDEBU2, KNWRLM, KEFOPT, KUEDIN, KUEDOU, KURTOX,
     & KUCAR2, KNHDRN, KNBHAB, KSBHAB, KRSLLQ, KRSLNB
      COMMON /QCDE/ INDATA
      COMMON /QCDE/ KRINNE, KRINNF, KRINDC, KRINDQ, KRINNZ, KRINNB,
     & KRINBM, KRINFR, KRINLR, KRINLF
      COMMON /QCDE/ KEVERT, KEVEDA, KEVETI, KEVEMI(4), KEVETY, KEVEES,
     & KDHEFP, KDHENP, KDHENM, KKEVNT, KKEVNV, KKEVID, KDHENX, KDHENV,
     & KDHENJ, KREVDS, KXTET1, KXTET2, KXTEL2, KXTCGC, KXTCLL, KXTCBN,
     & KXTCCL, KXTCHV, KXTCEN, KCLASW, KERBOM, KBPSTA
      DIMENSION KLOCUS(3,14)
      EQUIVALENCE (KLOCUS(1,1),KFOVT), (KFOVT,KFRET), (KLIST,KLRET),
     & (KFIST,KFCOT), (KLAST,KLCOT)
      COMMON /QCDE/ XCOPYJ, XFLIAC, XHISTO, XLREV(2), XLREV2(2), XMCEV,
     & XMINI, XSYNTX, XWREVT, XWRRUN, XFILMC, XFILCH, XFILV0, XFILCO,
     & XFILEF, XFILPC, XFILGA, XFILJE,
     & XPRHIS, XFILL, XVITC, XVTPC, XVECAL, XVLCAL, XVTPCD,
     & XVSATR, XVHCAL, XHVTRG, XSREC, XWMINI, XIOKLU, XIOKSI, XFRF2,
     & XNSEQ, XVDOK, XFRF0, XFMUID, XFILEM, XWNANO, XROKSI, XGETBP,
     & XJTHRU
      LOGICAL XCOPYJ, XFLIAC, XHISTO, XLREV, XLREV2, XMCEV, XMINI,
     & XSYNTX, XWREVT, XWRRUN, XFILMC, XFILCH, XFILV0, XFILCO, XFILEF,
     & XFILPC, XPRHIS, XFILL, XVITC, XVTPC, XVECAL, XVLCAL, XVTPCD,
     & XVSATR, XVHCAL, XHVTRG, XSREC, XWMINI, XIOKLU, XFRF2, XFILJE,
     & XNSEQ, XFILGA, XVDOK, XFRF0, XFMUID, XFILEM, XWNANO, XIOKSI,
     & XROKSI, XGETBP, XJTHRU
C-------------------- /NANCOM/ --- NanoDst steering -------------------
C! XNANO   .TRUE. if input is a NanoDst (in NANO or EPIO format, dependi
C!                   XNANOR)
C!
      LOGICAL XNANO
      COMMON /NANCOM/XNANO
C--------------------- end of NANCOM ----------------------------------
      INTEGER LMHLEN, LMHCOL, LMHROW
      PARAMETER (LMHLEN=2, LMHCOL=1, LMHROW=2)
      INTEGER IW
      REAL RW(10000)
      COMMON /BCS/ IW(10000)
      EQUIVALENCE (RW(1),IW(1))
C------------------ /QCNAMI/ --- name indices -------------------------
      COMMON /QCNAMI/ NAAFID,NAAJOB,NAASEV,NABCNT,NABHIT,NABOMB,
     1 NABOME,NABOMP,NABOMR,NABPTR,NADCAL,NADCRL,NADECO,NADEID,NADENF,
     2 NADEVT,NADEWI,NADFMC,NADFOT,NADGAM,NADHCO,NADHEA,NADHRL,NADJET,
     3 NADMID,NADMJT,NADMUO,NADNEU,NADPOB,NADRES,NADTBP,NADTMC,NADTRA,
     4 NADVER,NADVMC,NAECRQ,NAECTE,NAEGID,NAEGPC,NAEIDT,NAEJET,NAERRF,
     5 NAETDI,NAETKC,NAEVEH,NAEWHE,NAFICL,NAFKIN,NAFPOI,NAFPOL,NAFRFT,
     6 NAFRID,NAFRTL,NAFSTR,NAFTCL,NAFTCM,NAFTOC,NAFTTM,NAFVCL,NAFVER,
     7 NAFZFR,NAHCCV,NAHCTE,NAHINF,NAHMAD,NAHPDI,NAHROA,NAHSDA,NAHTUB,
     8 NAIASL,NAIPJT,NAIRJT,NAITCO,NAITMA,NAIXTR,NAIZBD,NAJBER,NAJEST,
     9 NAJSUM,NAKEVH,NAKINE,NAKJOB,NAKLIN,NAKPOL,NAKRUN,NALIDT,NALOLE,
     A NALUPA,NAMCAD,NAMHIT,NAMTHR,NAMUDG,NAMUEX,NAOSTS,NAPART,NAPASL,
     B NAPCHY,NAPCOB,NAPCOI,NAPCPA,NAPCQA,NAPCRL,NAPECO,NAPEHY,NAPEID,
     C NAPEMH,NAPEPT,NAPEST,NAPEWI,NAPFER,NAPFHR,NAPFRF,NAPFRT,NAPHCO,
     D NAPHER,NAPHHY,NAPHMH,NAPHST,NAPIDI,NAPITM,NAPLID,NAPLPD,NAPLSD,
     E NAPMSK,NAPNEU,NAPPDS,NAPPOB,NAPPRL,NAPRTM,NAPSCO,NAPSPO,NAPSTR,
     F NAPT2X,NAPTBC,NAPTCO,NAPTEX,NAPTMA,NAPTML,NAPTNC,NAPTST,NAPVCO,
     G NAPYER,NAPYFR,NAPYNE,NAQDET,NAQFPA,NAQLIN,NAQMTL,NAQMTS,NAQPAR,
     H NAQPBT,NAQPLI,NAQTRA,NAQVEC,NAQVRT,NAQWRK,NAQZER,NAREVH,NARHAH,
     I NARTLO,NARTLS,NARUNH,NARUNR,NASFTR,NATEXS,NATGMA,NATMTL,NATPCO,
     J NAVCOM,NAVCPL,NAVDCO,NAVDHT,NAVDXY,NAVDZT,NAVERT,NAVFHL,NAVFLG,
     K NAVFPH,NAVHLS,NAVPLH,NAX1AD,NAX1SC,NAX1TI,NAX2DF,NAX3EC,NAX3EW,
     L NAX3HC,NAX3IT,NAX3L2,NAX3LU,NAX3TM,NAX3TO,NAX3TP,NAX3X3,NAXTBN,
     M NAXTBP,NAXTCN,NAXTEB,NAXTOP,NAXTRB,NAYV0V,NAZPFR,NAEFOL,NAMUID,
     N NAPGID,NAPGPC,NAPGAC,NAPMSC,NAPTHR,NANBIP,NAPDLT,NAPMLT,NAPLJT
C--------------------- end of QCNAMI ----------------------------------
C------------------ /QQQQJJ/ --- HAC parameters for ALPHA banks -------
      PARAMETER (JQVEQX= 1,JQVEQY= 2,JQVEQZ= 3,JQVEQE= 4,JQVEQM= 5,
     & JQVEQP= 6,JQVECH= 7,JQVETN= 8,JQVESC= 9,JQVEKS=10,JQVECL=11,
     & JQVEPA=12,JQVEQD=13,JQVENP=14,JQVESP=15,JQVEOV=16,JQVEEV=17,
     & JQVEND=18,JQVEDL=19,JQVENO=20,JQVEOL=21,JQVENM=22,JQVEML=23,
     & JQVEBM=24,JQVELK=38,JQVEDB=39,JQVEZB=40,JQVESD=41,JQVESZ=42,
     & JQVECB=43,JQVEEM=44,JQVECF=54,JQVEEW=55,JQVEUS=56)
      PARAMETER ( JQVRVX=1,JQVRVY=2,JQVRVZ=3,JQVRVN=4,JQVRTY=5,
     1   JQVRIP=6,JQVRND=7,JQVRDL=8,JQVRAY=9,JQVRAF=10,JQVREM=11,
     2   JQVRCF=17,JQVRET=18)
      PARAMETER ( JQDEAF= 1,JQDEAL= 2,JQDENT= 3,JQDEAT= 4,JQDELT= 8,
     &  JQDEAE= 9,JQDEAH=10,JQDEAM=11,JQDECF=12,JQDEEC=13,JQDEHC=14,
     &  JQDEET=15,JQDEFI=16,JQDENF=17,JQDEFL=18,JQDENE=19,JQDEEL=20,
     &  JQDENH=21,JQDEHL=22,JQDELH=23,JQDEEF=24,JQDEPC=25,JQDEEG=26,
     &  JQDEMU=27,JQDEDX=28,JQDEPG=29,JQDEPD=30,JQDEPM=31)
      PARAMETER ( JQPAGN=1, JQPANA=2, JQPACO=5, JQPAMA=6, JQPACH=7,
     & JQPALT=8,JQPAWI=9,JQPAAN=10)
C--------------------- end of QCDESH ----------------------------------
      EXTERNAL CQPART, CQTPN, XCEQAN, XLUMOK, XPEQAN, XPEQOR, XPEQU,
     & XVDEOK, LLUMOK, SLUMOK
      CHARACTER * 12 CQPART, CQTPN
      LOGICAL XCAL, XCEQAN, XCEQOR, XCEQU, XECAL, XEID, XFRF, XHCAL,
     & XHMA, XLOCK, XLOCKN, XMC, XLUMOK, XMCA, XPEO, XPHO, XPEQAN,
     & XPEQOR, XPEQU, XSAME, XSIG, XTEX, XPEC, XPEP, XPHC, XYV0,
     & XFRIQF, XEFO, XPCQ, XEGP, XMUI, XVDEOK, XPGP, LLUMOK, SLUMOK,
     & XPGAC, XLEPTG, XLEPTH
      REAL PI, TWOPI, PIBY2, PIBY3, PIBY4, PIBY6, PIBY8, PIBY12
      REAL RADEG, DEGRA
      REAL CLGHT, ALDEDX
      INTEGER NBITW, NBYTW, LCHAR
      PARAMETER (PI=3.141592653589)
      PARAMETER (RADEG=180./PI, DEGRA=PI/180.)
      PARAMETER (TWOPI = 2.*PI , PIBY2 = PI/2., PIBY4 = PI/4.)
      PARAMETER (PIBY6 = PI/6. , PIBY8 = PI/8.)
      PARAMETER (PIBY12= PI/12., PIBY3 = PI/3.)
      PARAMETER (CLGHT = 29.9792458, ALDEDX = 0.000307)
      PARAMETER (NBITW = 32 , NBYTW = NBITW/8 , LCHAR = 4)
      INTEGER JEFOPX,JEFOPY,JEFOPZ,JEFOEW,JEFOWE,JEFOTY,JEFOLE,JEFOLT,
     +          JEFOLH,JEFOLC,JEFOLJ,LEFOLA
      PARAMETER(JEFOPX=1,JEFOPY=2,JEFOPZ=3,JEFOEW=4,JEFOWE=5,JEFOTY=6,
     +          JEFOLE=7,JEFOLT=8,JEFOLH=9,JEFOLC=10,JEFOLJ=11,
     +          LEFOLA=11)
      INTEGER JEGPPX,JEGPPY,JEGPPZ,JEGPR1,JEGPR2,JEGPF4,JEGPDM,JEGPST,
     +          JEGPQU,JEGPPE,LEGPCA
      PARAMETER(JEGPPX=1,JEGPPY=2,JEGPPZ=3,JEGPR1=4,JEGPR2=5,JEGPF4=6,
     +          JEGPDM=7,JEGPST=8,JEGPQU=9,JEGPPE=10,LEGPCA=10)
      INTEGER JEIDIF,JEIDR1,JEIDR2,JEIDR3,JEIDR4,JEIDR5,JEIDR6,JEIDR7,
     +          JEIDEC,JEIDIP,JEIDE1,JEIDE2,JEIDE3,JEIDFR,JEIDPE,LEIDTA
      PARAMETER(JEIDIF=1,JEIDR1=2,JEIDR2=3,JEIDR3=4,JEIDR4=5,JEIDR5=6,
     +          JEIDR6=7,JEIDR7=8,JEIDEC=9,JEIDIP=10,JEIDE1=11,
     +          JEIDE2=12,JEIDE3=13,JEIDFR=14,JEIDPE=15,LEIDTA=15)
      INTEGER JFRFIR,JFRFTL,JFRFP0,JFRFD0,JFRFZ0,JFRFAL,JFRFEM,JFRFC2,
     +          JFRFDF,JFRFNO,LFRFTA
      PARAMETER(JFRFIR=1,JFRFTL=2,JFRFP0=3,JFRFD0=4,JFRFZ0=5,JFRFAL=6,
     +          JFRFEM=7,JFRFC2=28,JFRFDF=29,JFRFNO=30,LFRFTA=30)
      INTEGER JFRIBP,JFRIDZ,JFRIBC,JFRIDC,JFRIPE,JFRIPM,JFRIPI,JFRIPK,
     +          JFRIPP,JFRINK,JFRIQF,LFRIDA
      PARAMETER(JFRIBP=1,JFRIDZ=2,JFRIBC=3,JFRIDC=4,JFRIPE=5,JFRIPM=6,
     +          JFRIPI=7,JFRIPK=8,JFRIPP=9,JFRINK=10,JFRIQF=11,
     +          LFRIDA=11)
      INTEGER JFRTIV,JFRTNV,JFRTII,JFRTNI,JFRTNE,JFRTIT,JFRTNT,JFRTNR,
     +          LFRTLA
      PARAMETER(JFRTIV=1,JFRTNV=2,JFRTII=3,JFRTNI=4,JFRTNE=5,JFRTIT=6,
     +          JFRTNT=7,JFRTNR=8,LFRTLA=8)
      INTEGER JHMANF,JHMANE,JHMANL,JHMAMH,JHMAIG,JHMAED,JHMACS,JHMAND,
     +          JHMAIE,JHMAIT,JHMAIF,JHMATN,LHMADA
      PARAMETER(JHMANF=1,JHMANE=2,JHMANL=3,JHMAMH=4,JHMAIG=5,JHMAED=6,
     +          JHMACS=7,JHMAND=8,JHMAIE=9,JHMAIT=10,JHMAIF=11,
     +          JHMATN=12,LHMADA=12)
      INTEGER JMCANH,JMCADH,JMCADC,JMCAAM,JMCAAC,JMCATN,LMCADA
      PARAMETER(JMCANH=1,JMCADH=3,JMCADC=5,JMCAAM=7,JMCAAC=8,JMCATN=9,
     +          LMCADA=9)
      INTEGER JMUIIF,JMUISR,JMUIDM,JMUIST,JMUITN,LMUIDA
      PARAMETER(JMUIIF=1,JMUISR=2,JMUIDM=3,JMUIST=4,JMUITN=5,LMUIDA=5)
      INTEGER JPCQNA,JPCQPX,JPCQPY,JPCQPZ,JPCQEN,LPCQAA
      PARAMETER(JPCQNA=1,JPCQPX=2,JPCQPY=3,JPCQPZ=4,JPCQEN=5,LPCQAA=5)
      INTEGER JPDLPA,JPDLJT,JPDLPI,JPDLPE,JPDLVP,JPDLFR,LPDLTA
      PARAMETER (JPDLPA=1,JPDLJT=2,JPDLPI=3,JPDLPE=4,JPDLVP=5,
     &           JPDLFR=6,LPDLTA=6)
      INTEGER JPECER,JPECE1,JPECE2,JPECTH,JPECPH,JPECEC,JPECKD,JPECCC,
     +          JPECRB,JPECPC,LPECOA
      PARAMETER(JPECER=1,JPECE1=2,JPECE2=3,JPECTH=4,JPECPH=5,JPECEC=6,
     +          JPECKD=7,JPECCC=8,JPECRB=9,JPECPC=10,LPECOA=10)
      INTEGER JPEPT1,JPEPP1,JPEPT3,JPEPP3,LPEPTA
      PARAMETER(JPEPT1=1,JPEPP1=2,JPEPT3=3,JPEPP3=4,LPEPTA=4)
      INTEGER JPGAEC,JPGATC,JPGAPC,JPGAR1,JPGAR2,JPGAF4,JPGADM,JPGAST,
     +          JPGAQU,JPGAQ1,JPGAQ2,JPGAM1,JPGAM2,JPGAMA,JPGAER,JPGATR,
     +          JPGAPR,JPGAEF,JPGAGC,JPGAZS,JPGAPL,JPGAPH,JPGAPN,JPGAFA,
     +          JPGAPE,LPGACA
      PARAMETER(JPGAEC=1,JPGATC=2,JPGAPC=3,JPGAR1=4,JPGAR2=5,JPGAF4=6,
     +          JPGADM=7,JPGAST=8,JPGAQU=9,JPGAQ1=10,JPGAQ2=11,
     +          JPGAM1=12,JPGAM2=13,JPGAMA=14,JPGAER=15,JPGATR=16,
     +          JPGAPR=17,JPGAEF=18,JPGAGC=19,JPGAZS=20,JPGAPL=21,
     +          JPGAPH=22,JPGAPN=23,JPGAFA=24,JPGAPE=25,LPGACA=25)
      INTEGER JPGPEC,JPGPTC,JPGPPC,JPGPR1,JPGPR2,JPGPF4,JPGPDM,JPGPST,
     +          JPGPQU,JPGPQ1,JPGPQ2,JPGPM1,JPGPM2,JPGPMA,JPGPER,JPGPTR,
     +          JPGPPR,JPGPPE,LPGPCA
      PARAMETER(JPGPEC=1,JPGPTC=2,JPGPPC=3,JPGPR1=4,JPGPR2=5,JPGPF4=6,
     +          JPGPDM=7,JPGPST=8,JPGPQU=9,JPGPQ1=10,JPGPQ2=11,
     +          JPGPM1=12,JPGPM2=13,JPGPMA=14,JPGPER=15,JPGPTR=16,
     +          JPGPPR=17,JPGPPE=18,LPGPCA=18)
      INTEGER JPHCER,JPHCTH,JPHCPH,JPHCEC,JPHCKD,JPHCCC,JPHCRB,JPHCNF,
     +          JPHCPC,LPHCOA
      PARAMETER(JPHCER=1,JPHCTH=2,JPHCPH=3,JPHCEC=4,JPHCKD=5,JPHCCC=6,
     +          JPHCRB=7,JPHCNF=8,JPHCPC=9,LPHCOA=9)
      INTEGER JPMLFL,JPMLPO,JPMLCH,JPMLSP,JPMLLE,JPMLME,JPMLKT,JPMLFR,
     +          LPMLTA
      PARAMETER (JPMLFL=1,JPMLPO=2,JPMLCH=3,JPMLSP=4,JPMLLE=5,
     &           JPMLME=6,JPMLKT=7,JPMLFR=8,LPMLTA=8)
      INTEGER JTEXSI,JTEXTM,JTEXTL,JTEXNS,JTEXAD,JTEXTN,JTEXSF,LTEXSA
      PARAMETER(JTEXSI=1,JTEXTM=2,JTEXTL=3,JTEXNS=4,JTEXAD=5,JTEXTN=6,
     +          LTEXSA=6)
      INTEGER JYV0K1,JYV0K2,JYV0VX,JYV0VY,JYV0VZ,JYV0VM,JYV0PX,JYV0PY,
     +          JYV0PZ,JYV0PM,JYV0X1,JYV0X2,JYV0XM,JYV0C2,JYV0IC,JYV0P1,
     +          JYV0P2,JYV0EP,JYV0DM,JYV0S1,JYV0S2,LYV0VA
      PARAMETER(JYV0K1=1,JYV0K2=2,JYV0VX=3,JYV0VY=4,JYV0VZ=5,JYV0VM=6,
     +          JYV0PX=12,JYV0PY=13,JYV0PZ=14,JYV0PM=15,JYV0X1=21,
     +          JYV0X2=22,JYV0XM=23,JYV0C2=26,JYV0IC=27,JYV0P1=28,
     +          JYV0P2=31,JYV0EP=34,JYV0DM=55,JYV0S1=56,JYV0S2=57,
     +          LYV0VA=57)
C--------------------- end of QCDE ------------------------------------
C  HAC parameter
      INTEGER NLENG , IGARB, KPDLT, KPMLT, JPDLT , JPMLT ,ICLEP
      INTEGER JPLJPX,JPLJPY,JPLJPZ,JPLJPE,JPLJNO,LPLJTA
      PARAMETER (JPLJPX=1,JPLJPY=2,JPLJPZ=3,JPLJPE=4,JPLJNO=5,LPLJTA=5)
C
C Subroutine parameters and function prototypes
C
C--
C-- Cut variable prototypes
C--
      COMMON/HADSEL/MINGDT,MINVIS,MINHIT,D0CUT,Z0CUT,MCOSTH
      INTEGER MINGDT,MINHIT
      REAL MINVIS,D0CUT,Z0CUT,MCOSTH
C--
      COMMON/EPTSEL/TPCEP,D0MXEP,Z0MXEP,CSTHEP,PEPMIN,PTEPMN
      INTEGER TPCEP
      REAL D0MXEP,Z0MXEP,CSTHEP,PEPMIN,PTEPMN
C--
      COMMON/EPSEL/R2CUT,R3CUT,MINWIR,R5CUT
      INTEGER MINWIR
      REAL R2CUT(2),R3CUT(2),R5CUT(2)
C--
      COMMON/MUTSEL/TPCMU,D0MXMU,Z0MXMU,CSTHMU,PMUMIN,PTMUMN
      INTEGER TPCMU
      REAL D0MXMU,Z0MXMU,CSTHMU,PMUMIN,PTMUMN
C--
      COMMON/MUSEL/NQMUID,QMACC
      INTEGER NQMUID,QMACC(20)
C--
      COMMON/CONDAL/DXYCUT,DZCUT,MXINV,RWCONV
      REAL DXYCUT,DZCUT,MXINV
      INTEGER RWCONV
C--
      COMMON/JETSEL/NTRJET,MINJET,ENTRJT,SYCUT,RWPTS
      REAL ENTRJT , SYCUT
      INTEGER NTRJET,MINJET,IERJET,RWPTS
C--
      REAL YCUT
      INTEGER NJETS
      CHARACTER*8 JNAM
C--
      COMMON /LTPRIV/ LASTRN,NLPTEV,LTFRST,YEARID,LTFWCD
      INTEGER LASTRN,NLPTEV,YEARID,LTFWCD
      LOGICAL LTFRST
C--
      INTEGER NAMIND,NBANK,NLINK,NATR,NDROP
      REAL DUMMY
      LOGICAL BADTRK,CHTSIM,XBANK
      INTEGER SLOUT,NLEP,IERR
C
C Variables
C
      INTEGER IDPMLT,NWPMLT,IDX,ITK,NGOOD,NLEPT,NPOSI,NELEC,NMUPL,
     @        NMUMI,NCONV,NBOTH,IEREL,NS,IERDEX,NC1,NC2,
     @        IERQPA,IRUN,IBE,IBT,IM1,IM2,NEXP,NFIR,N10,N03,ISHAD,
     @        IDF,IMCF,IERMU,SIZE,
     @        IDJET,LSJET,JETID,II,NJET,ETK,NTRACK,I,
     @        CPYEAR,CPIDL,SIDX,
     @        IMCFL,IFLAV,IMCT,JMBEST,IPAR,
     @        IPOP,ICHAIN,ISPLIT,LEPID,IBMES,IQUAL
      REAL    ETOT,R2,R3,RI,TL,RIEXP,SIGMA,R5,DXY,DZ0,DZ2,DTH,RMA,
     @        ZMA,XMA,P(3),XMULT,RAPP,ANG,SUDNT,EXPFIR,
     @        PLEPT(3),PJET(4),VINP,COSTHE,SINTHE,PTINC,PTEXCL,
     @        DIN1,DIN2,EJET,WEIGHT
C
C     QSELEP counters
C
      COMMON /LPTPUB/ LEPCNT
      INTEGER NCNT
      PARAMETER(NCNT = 25)
      INTEGER LEPCNT(NCNT)
      INTEGER KPLJT,JPLJT,IJET
      INTEGER LTNCHR,LTQLPR,LTECHR,LTACHR,LTBOSC,LTBOSS,LTNJET,LTJTAS,
     @        LTPTFL,LTHVDQ,LTHAD ,LTNLEP,LTYLEP,LTCONV,LTELMU,LTNEMI,
     @        LTNEPL,LTNMMI,LTNMPL,LTNCNV,LTCALL,LTNEFO,LTGTYF,LTCPDF,
     @        LTBRFL
C
      PARAMETER(LTNCHR= 1,LTQLPR= 2,LTECHR= 3,LTACHR= 4,LTBOSC= 5,
     @          LTBOSS= 6,LTNJET= 7,LTJTAS= 8,LTPTFL= 9,LTHVDQ=10,
     @          LTHAD =11,LTNLEP=12,LTYLEP=13,LTCONV=14,LTELMU=15,
     @          LTNEMI=16,LTNEPL=17,LTNMMI=18,LTNMPL=19,LTNCNV=20,
     @          LTCALL=21,LTNEFO=22,LTGTYF=23,LTCPDF=24,LTBRFL=25)
      REAL QLPEAK
      PARAMETER ( QLPEAK = 91.2 )
C
C-------------------- /QMACRO/ --- statement functions ----------------
C - # of words/row in bank with index ID
      LCOLS(ID) = IW(ID+LMHCOL)
C - # of rows in bank with index ID
      LROWS(ID) = IW(ID+LMHROW)
C - index of next row in the bank with index ID
      KNEXT(ID) = ID + LMHLEN + IW(ID+1)*IW(ID+2)
C - index of row # NRBOS in the bank with index ID
      KROW(ID,NRBOS) = ID + LMHLEN + IW(ID+1)*(NRBOS-1)
C - # of free words in the bank with index ID
      LFRWRD(ID) = ID + IW(ID) - KNEXT(ID)
C - # of free rows in the bank with index ID
      LFRROW(ID) = LFRWRD(ID) / LCOLS(ID)
C - Lth integer element of the NRBOSth row of the bank with index ID
      ITABL(ID,NRBOS,L) = IW(ID+LMHLEN+(NRBOS-1)*IW(ID+1)+L)
C - Lth real element of the NRBOSth row of the bank with index ID
      RTABL(ID,NRBOS,L) = RW(ID+LMHLEN+(NRBOS-1)*IW(ID+1)+L)
C-------------------- /QCFUNC/ --- statement functions for ALPHA banks
      KJQDET(KI)=IW(KOQVEC+KI*KCQVEC+JQVEQD)
      QSQT(QF)=SIGN(SQRT(ABS(QF)),QF)
      QP(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQP)
      QX(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQX)
      QY(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQY)
      QZ(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQZ)
      QE(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQE)
      QM(KI)=RW(KOQVEC+KI*KCQVEC+JQVEQM)
      QCH(KI)=RW(KOQVEC+KI*KCQVEC+JQVECH)
      KCH(KI)=NINT (QCH(KI))
      QCT(KI)=QZ(KI)/QP(KI)
      QDB(KI)=RW(KOQVEC+KI*KCQVEC+JQVEDB)
      QZB(KI)=RW(KOQVEC+KI*KCQVEC+JQVEZB)
      QDBS2(KI)=RW(KOQVEC+KI*KCQVEC+JQVESD)
      QZBS2(KI)=RW(KOQVEC+KI*KCQVEC+JQVESZ)
      QBC2(KI)=RW(KOQVEC+KI*KCQVEC+JQVECB)
      QSIG(KI,KI1,KI2)=RW(KOQVEC+KI*KCQVEC+KMATIX(KI1,KI2)+JQVEEM)
      XSIG(KI)=RW(KOQVEC+KI*KCQVEC+JQVEEM).GE.0.
      QSMAT(KI,KI1)=RW(KOQVEC+KI*KCQVEC+KI1+JQVEEM)
      QSIGX(KI)=QSQT(QSMAT(KI,0))
      QSIGY(KI)=QSQT(QSMAT(KI,2))
      QSIGZ(KI)=QSQT(QSMAT(KI,5))
      QSIGEE(KI)=RW(KOQVEC+KI*KCQVEC+JQVEEM+9)
      QSIGE(KI)=QSQT(QSIGEE(KI))
      QSIGPP(KI)=(QX(KI)**2*QSMAT(KI,0)+QY(KI)**2*QSMAT(KI,2)+
     & QZ(KI)**2*QSMAT(KI,5)+2.*(QX(KI)*(QY(KI)*QSMAT(KI,1)+
     & QZ(KI)*QSMAT(KI,3))+QY(KI)*QZ(KI)*QSMAT(KI,4)))/QP(KI)**2
      QSIGP(KI)=QSQT(QSIGPP(KI))
      QSIGMM(KI)=QM(KI)*(QE(KI)**2*QSMAT(KI,9)+QX(KI)**2*QSMAT(KI,0)+
     & QY(KI)**2*QSMAT(KI,2)+QZ(KI)**2*QSMAT(KI,5)+2.*(QX(KI)*(QY(KI)*
     & QSMAT(KI,1)+QZ(KI)*QSMAT(KI,3))+QY(KI)*QZ(KI)*QSMAT(KI,4)-
     & QE(KI)*(QX(KI)*QSMAT(KI,6)+QY(KI)*QSMAT(KI,7)+
     & QZ(KI)*QSMAT(KI,8))))/AMAX1(QM(KI)**3,1.E-16)
      QSIGM(KI)=QSQT(QSIGMM(KI))
      QMCHIF(KI)=RW(KOQVEC+KI*KCQVEC+JQVECF)
      QPH(KI)=ATG(QY(KI),QX(KI))
      QPT(KI)=SQRT(QX(KI)**2+QY(KI)**2)
      KTN(KI)=IW(KOQVEC+KI*KCQVEC+JQVETN)
      KMC(KI)=KCLARM(IW(KOQVEC+KI*KCQVEC+JQVECL))
      KBMASK(KI,KI1)=IW(KOQVEC+KI*KCQVEC+KI1+JQVEBM-1)
      KCALFL(KI)=IW(KJQDET(KI)+JQDECF)
      KCHGD(KI,KI1)=IW(KOQLIN+KI1+IW(KJQDET(KI)+JQDEFL))
      KCLASS(KI)=KCLACO(IW(KOQVEC+KI*KCQVEC+JQVECL))
      KDAU(KI,KI1)=IW(KOQLIN+KI1+IW(KOQVEC+KI*KCQVEC+JQVEDL))
      KECAL(KI,KI1)=IW(KOQLIN+KI1+IW(KJQDET(KI)+JQDEEL))
      KENDV(KI)=IW(KOQVEC+KI*KCQVEC+JQVEEV)
      KFOLLO(KI)=IW(KOQVEC+KI*KCQVEC+JQVENP)
C
      KHCAL(KI,KI1)=IW(KOQLIN+KI1+IW(KJQDET(KI)+JQDEHL))
      KLUNDS(KI)=IW(KOQVEC+KI*KCQVEC+JQVEKS)
      KNCHGD(KI)=IW(KJQDET(KI)+JQDENF)
      KNECAL(KI)=IW(KJQDET(KI)+JQDENE)
      KNHCAL(KI)=IW(KJQDET(KI)+JQDENH)
      KNMOTH(KI)=IW(KOQVEC+KI*KCQVEC+JQVENO)
      KMOTH(KI,KI1)=IW(KOQLIN+KI1+IW(KOQVEC+KI*KCQVEC+JQVEOL))
      KMTCH(KI,KI1)=IW(KOQMTL+KI1+IW(KOQVEC+KI*KCQVEC+JQVEML))
      KNDAU(KI)=IW(KOQVEC+KI*KCQVEC+JQVEND)
      KNMTCH(KI)=IW(KOQVEC+KI*KCQVEC+JQVENM)
      KORIV(KI)=IW(KOQVEC+KI*KCQVEC+JQVEOV)
      KSAME(KI)=IW(KOQVEC+KI*KCQVEC+JQVESP)
      KSMTCH(KI,KI1)=IW(KOQMTS+KI1+IW(KOQVEC+KI*KCQVEC+JQVEML))
      KSTABC(KI)=IW(KOQVEC+KI*KCQVEC+JQVESC)
      KTPCOD(KI)=IW(KOQVEC+KI*KCQVEC+JQVEPA)
      XLOCKN(KI,KI1)=IAND(KBMASK(KI,KI1),KLOCK0(KI1,KMC(KI))).NE.0
      XLOCK(KI)=IW(KOQVEC+KI*KCQVEC+JQVELK).NE.0.OR.XLOCKN(KI,1).OR.
     & XLOCKN(KI,2).OR.XLOCKN(KI,3).OR.XLOCKN(KI,4).OR.
     & XLOCKN(KI,5).OR.XLOCKN(KI,6).OR.XLOCKN(KI,7).OR.
     & XLOCKN(KI,8).OR.XLOCKN(KI,9).OR.XLOCKN(KI,10).OR.
     & XLOCKN(KI,11).OR.XLOCKN(KI,12).OR.XLOCKN(KI,13).OR.
     & XLOCKN(KI,14)
      XMC(KI)=KCLARM(IW(KOQVEC+KI*KCQVEC+JQVECL)).NE.1
      QRDFL(KI,KI1)=RW(KOQVEC+KI*KCQVEC+JQVEUS+KI1-1)
      KRDFL(KI,KI1)=IW(KOQVEC+KI*KCQVEC+JQVEUS+KI1-1)
      XCAL(KI)=IW(KJQDET(KI)+JQDECF).NE.0
      XECAL(KI)=IABS(IW(KJQDET(KI)+JQDECF)).EQ.1
      XHCAL(KI)=IABS(IW(KJQDET(KI)+JQDECF)).EQ.2
C
      QVX(KI)=RW(KOQVRT+KI*KCQVRT+JQVRVX)
      QVY(KI)=RW(KOQVRT+KI*KCQVRT+JQVRVY)
      QVZ(KI)=RW(KOQVRT+KI*KCQVRT+JQVRVZ)
      KVN(KI)=IW(KOQVRT+KI*KCQVRT+JQVRVN)
      KVTYPE(KI)=IW(KOQVRT+KI*KCQVRT+JQVRTY)
      KVINCP(KI)=IW(KOQVRT+KI*KCQVRT+JQVRIP)
      KVNDAU(KI)=IW(KOQVRT+KI*KCQVRT+JQVRND)
      KVYV0V(KI)=IW(KOQVRT+KI*KCQVRT+JQVRAY)
      KVFVER(KI)=IW(KOQVRT+KI*KCQVRT+JQVRAF)
      KVDAU(KI,KI1)=IW(KOQLIN+KI1+IW(KOQVRT+KI*KCQVRT+JQVRDL))
      QVEM(KI,KI1,KI2)=RW(KOQVRT+KI*KCQVRT+KMATIX(KI1,KI2)+JQVREM)
      QVCHIF(KI)=RW(KOQVRT+KI*KCQVRT+JQVRCF)
      QVDIF2(KI1,KI2)=SQRT((QVX(KI1)-QVX(KI2))**2+(QVY(KI1)-
     &QVY(KI2))**2)
      QVDIF3(KI1,KI2)=SQRT((QVX(KI1)-QVX(KI2))**2+(QVY(KI1)-
     &QVY(KI2))**2+ (QVZ(KI1)-QVZ(KI2))**2)
C
      QMSQ2(KI1,KI2)=(QE(KI1)+QE(KI2))**2-(QX(KI1)+QX(KI2))**2-
     & (QY(KI1)+QY(KI2))**2-(QZ(KI1)+QZ(KI2))**2
      QMSQ3(KI1,KI2,KI3)=(QE(KI1)+QE(KI2)+QE(KI3))**2-
     & (QX(KI1)+QX(KI2)+QX(KI3))**2-(QY(KI1)+QY(KI2)+QY(KI3))**2-
     & (QZ(KI1)+QZ(KI2)+QZ(KI3))**2
      QMSQ4(KI1,KI2,KI3,KI4)=(QE(KI1)+QE(KI2)+QE(KI3)+QE(KI4))**2-
     & (QX(KI1)+QX(KI2)+QX(KI3)+QX(KI4))**2-(QY(KI1)+QY(KI2)+
     & QY(KI3)+QY(KI4))**2-(QZ(KI1)+QZ(KI2)+QZ(KI3)+QZ(KI4))**2
      QM2(KI1,KI2)=QSQT(QMSQ2(KI1,KI2))
      QM3(KI1,KI2,KI3)=QSQT(QMSQ3(KI1,KI2,KI3))
      QM4(KI1,KI2,KI3,KI4)=QSQT(QMSQ4(KI1,KI2,KI3,KI4))
      QDMSQ(KI1,KI2)=(QE(KI1)-QE(KI2))**2-(QX(KI1)-QX(KI2))**2-
     & (QY(KI1)-QY(KI2))**2-(QZ(KI1)-QZ(KI2))**2
      QBETA(KI)=QP(KI)/QE(KI)
      QGAMMA(KI)=1./SQRT((1.-QBETA(KI))*(1.+QBETA(KI)))
      QDOT3(KI1,KI2)=QX(KI1)*QX(KI2)+QY(KI1)*QY(KI2)+QZ(KI1)*QZ(KI2)
      QDOT4(KI1,KI2)=QE(KI1)*QE(KI2)-QDOT3(KI1,KI2)
      QCOSA(KI1,KI2)=QDOT3(KI1,KI2)/(QP(KI1)*QP(KI2))
      QPPAR(KI1,KI2)=QDOT3(KI1,KI2)/QP(KI2)
      QPPER(KI1,KI2)=SQRT((QY(KI1)*QZ(KI2)-QZ(KI1)*QY(KI2))**2+
     & (QZ(KI1)*QX(KI2)-QX(KI1)*QZ(KI2))**2+
     & (QX(KI1)*QY(KI2)-QY(KI1)*QX(KI2))**2)/QP(KI2)
      XSAME(KI1,KI2)=IAND(KBMASK(KI1,1),KBMASK(KI2,1)).NE.0.OR.
     & IAND(KBMASK(KI1,2),KBMASK(KI2,2)).NE.0.OR.
     & IAND(KBMASK(KI1,3),KBMASK(KI2,3)).NE.0.OR.
     & IAND(KBMASK(KI1,4),KBMASK(KI2,4)).NE.0.OR.
     & IAND(KBMASK(KI1,5),KBMASK(KI2,5)).NE.0.OR.
     & IAND(KBMASK(KI1,6),KBMASK(KI2,6)).NE.0.OR.
     & IAND(KBMASK(KI1,7),KBMASK(KI2,7)).NE.0.OR.
     & IAND(KBMASK(KI1,8),KBMASK(KI2,8)).NE.0.OR.
     & IAND(KBMASK(KI1,9),KBMASK(KI2,9)).NE.0.OR.
     & IAND(KBMASK(KI1,10),KBMASK(KI2,10)).NE.0
C
      QCMASS(KI)=RW(KOQPAR+KI*KCQPAR+JQPAMA)
      QCCHAR(KI)=RW(KOQPAR+KI*KCQPAR+JQPACH)
      QCLIFE(KI)=RW(KOQPAR+KI*KCQPAR+JQPALT)
      QCWIDT(KI)=RW(KOQPAR+KI*KCQPAR+JQPAWI)
      XCEQOR(KI,KI1)=KTPCOD(KI).EQ.KI1.OR.
     & KTPCOD(KI).EQ.IW(KOQPAR+KI1*KCQPAR+JQPAAN)
      XCEQU(KI,KI1)=KTPCOD(KI).EQ.KI1
C    QCFDET
      XFRF(KI)=IW(KJQDET(KI)+JQDEAF).NE.KQZER
      QFRFIR(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFIR)
      QFRFTL(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFTL)
      QFRFP0(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFP0)
      QFRFD0(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFD0)
      QFRFZ0(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFZ0)
      QFRFAL(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFAL)
      QFRFEM(KI,KI1,KI2)=RW(IW(KJQDET(KI)+JQDEAF)+
     & KMATIX(KI1,KI2)+JFRFEM)
      QFRFC2(KI)=RW(IW(KJQDET(KI)+JQDEAF)+JFRFC2)
      KFRFDF(KI)=IW(IW(KJQDET(KI)+JQDEAF)+JFRFDF)
      KFRFNO(KI)=IW(IW(KJQDET(KI)+JQDEAF)+JFRFNO)
C
      KFRTNV(KI)=IW(IW(KJQDET(KI)+JQDEAL)+JFRTNV)
      KFRTNI(KI)=IW(IW(KJQDET(KI)+JQDEAL)+JFRTNI)
      KFRTNE(KI)=IW(IW(KJQDET(KI)+JQDEAL)+JFRTNE)
      KFRTNT(KI)=IW(IW(KJQDET(KI)+JQDEAL)+JFRTNT)
      KFRTNR(KI)=IW(IW(KJQDET(KI)+JQDEAL)+JFRTNR)
C
      KFRIBP(KI)=IW(IW(KJQDET(KI)+JQDEFI)+JFRIBP)
      KFRIDZ(KI)=IW(IW(KJQDET(KI)+JQDEFI)+JFRIDZ)
      KFRIBC(KI)=IW(IW(KJQDET(KI)+JQDEFI)+JFRIBC)
      KFRIDC(KI)=IW(IW(KJQDET(KI)+JQDEFI)+JFRIDC)
      QFRIPE(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRIPE)
      QFRIPM(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRIPM)
      QFRIPI(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRIPI)
      QFRIPK(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRIPK)
      QFRIPP(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRIPP)
      QFRINK(KI)=RW(IW(KJQDET(KI)+JQDEFI)+JFRINK)
      KFRIQF(KI)=IW(IW(KJQDET(KI)+JQDEFI)+JFRIQF)
      XFRIQF(KI)=KFRIQF(KI).EQ.1.OR.KFRIQF(KI).EQ.3
C
      KNTEX(KI)=IW(KJQDET(KI)+JQDENT)
      XTEX(KI)=IW(KJQDET(KI)+JQDENT).NE.0
      KTEXSI(KI,KI1)=IW(IW(KJQDET(KI)+KI1+JQDENT)+JTEXSI)
      QTEXTM(KI,KI1)=RW(IW(KJQDET(KI)+KI1+JQDENT)+JTEXTM)
      QTEXTL(KI,KI1)=RW(IW(KJQDET(KI)+KI1+JQDENT)+JTEXTL)
      KTEXNS(KI,KI1)=IW(IW(KJQDET(KI)+KI1+JQDENT)+JTEXNS)
      QTEXAD(KI,KI1)=RW(IW(KJQDET(KI)+KI1+JQDENT)+JTEXAD)
C
      XEID(KI)=IW(KJQDET(KI)+JQDEAE).NE.KQZER
      KEIDIF(KI)=IW(IW(KJQDET(KI)+JQDEAE)+JEIDIF)
      QEIDRI(KI,KI1)=RW(IW(KJQDET(KI)+JQDEAE)+KI1+JEIDR1-1)
      QEIDEC(KI)=RW(IW(KJQDET(KI)+JQDEAE)+JEIDEC)
      KEIDIP(KI)=IW(IW(KJQDET(KI)+JQDEAE)+JEIDIP)
      QEIDEI(KI,KI1)=RW(IW(KJQDET(KI)+JQDEAE)+KI1+JEIDE1-1)
C
      XHMA(KI)=IW(KJQDET(KI)+JQDEAH).NE.KQZER
      KHMANF(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMANF)
      KHMANE(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMANE)
      KHMANL(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMANL)
      KHMAMH(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAMH)
      KHMAIG(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAIG)
      QHMAED(KI)=RW(IW(KJQDET(KI)+JQDEAH)+JHMAED)
      QHMACS(KI)=RW(IW(KJQDET(KI)+JQDEAH)+JHMACS)
      KHMAND(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAND)
      KHMAIE(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAIE)
      KHMAIT(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAIT)
      KHMAIF(KI)=IW(IW(KJQDET(KI)+JQDEAH)+JHMAIF)
C
      XMCA(KI)=IW(KJQDET(KI)+JQDEAM).NE.KQZER
      KMCANH(KI,KI1)=IW(IW(KJQDET(KI)+JQDEAM)+KI1+JMCANH-1)
      QMCADH(KI,KI1)=RW(IW(KJQDET(KI)+JQDEAM)+KI1+JMCADH-1)
      QMCADC(KI,KI1)=RW(IW(KJQDET(KI)+JQDEAM)+KI1+JMCADC-1)
      QMCAAM(KI)=RW(IW(KJQDET(KI)+JQDEAM)+JMCAAM)
      QMCAAC(KI)=RW(IW(KJQDET(KI)+JQDEAM)+JMCAAC)
C
      XMUI(KI)=IW(KJQDET(KI)+JQDEMU).NE.KQZER
      KMUIIF(KI)=IW(IW(KJQDET(KI)+JQDEMU)+JMUIIF)
      QMUISR(KI)=RW(IW(KJQDET(KI)+JQDEMU)+JMUISR)
      QMUIDM(KI)=RW(IW(KJQDET(KI)+JQDEMU)+JMUIDM)
      KMUIST(KI)=IW(IW(KJQDET(KI)+JQDEMU)+JMUIST)
      KMUITN(KI)=IW(IW(KJQDET(KI)+JQDEMU)+JMUITN)
C
      XPEC(KI)=IW(KJQDET(KI)+JQDEEC).NE.KQZER
      QPECER(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECER)
      QPECE1(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECE1)
      QPECE2(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECE2)
      QPECTH(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECTH)
      QPECPH(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECPH)
      QPECEC(KI)=RW(IW(KJQDET(KI)+JQDEEC)+JPECEC)
      KPECKD(KI)=IW(IW(KJQDET(KI)+JQDEEC)+JPECKD)
      KPECCC(KI)=IW(IW(KJQDET(KI)+JQDEEC)+JPECCC)
      KPECRB(KI)=IW(IW(KJQDET(KI)+JQDEEC)+JPECRB)
      KPECPC(KI)=IW(IW(KJQDET(KI)+JQDEEC)+JPECPC)
C
      XPEP(KI)=IW(KJQDET(KI)+JQDEET).NE.KQZER
      QPEPT1(KI)=RW(IW(KJQDET(KI)+JQDEET)+JPEPT1)
      QPEPP1(KI)=RW(IW(KJQDET(KI)+JQDEET)+JPEPP1)
      QPEPT3(KI)=RW(IW(KJQDET(KI)+JQDEET)+JPEPT3)
      QPEPP3(KI)=RW(IW(KJQDET(KI)+JQDEET)+JPEPP3)
C
      XPHC(KI)=IW(KJQDET(KI)+JQDEHC).NE.KQZER
      QPHCER(KI)=RW(IW(KJQDET(KI)+JQDEHC)+JPHCER)
      QPHCTH(KI)=RW(IW(KJQDET(KI)+JQDEHC)+JPHCTH)
      QPHCPH(KI)=RW(IW(KJQDET(KI)+JQDEHC)+JPHCPH)
      QPHCEC(KI)=RW(IW(KJQDET(KI)+JQDEHC)+JPHCEC)
      KPHCKD(KI)=IW(IW(KJQDET(KI)+JQDEHC)+JPHCKD)
      KPHCCC(KI)=IW(IW(KJQDET(KI)+JQDEHC)+JPHCCC)
      KPHCRB(KI)=IW(IW(KJQDET(KI)+JQDEHC)+JPHCRB)
      KPHCPC(KI)=IW(IW(KJQDET(KI)+JQDEHC)+JPHCPC)
C
      XEFO(KI)=IW(KJQDET(KI)+JQDEEF).NE.KQZER
      QEFOWE(KI)=RW(IW(KJQDET(KI)+JQDEEF)+JEFOWE)
      KEFOTY(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOTY)
      KEFOLE(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOLE)
      KEFOLT(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOLT)
      KEFOLH(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOLH)
      KEFOLC(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOLC)
      KEFOLJ(KI)=IW(IW(KJQDET(KI)+JQDEEF)+JEFOLJ)
C
      XPCQ(KI)=IW(KJQDET(KI)+JQDEPC).NE.KQZER
      KPCQNA(KI)=IW(IW(KJQDET(KI)+JQDEPC)+JPCQNA)
C
      XEGP(KI)=IW(KJQDET(KI)+JQDEEG).NE.KQZER
      QEGPR1(KI)=RW(IW(KJQDET(KI)+JQDEEG)+JEGPR1)
      QEGPR2(KI)=RW(IW(KJQDET(KI)+JQDEEG)+JEGPR2)
      QEGPF4(KI)=RW(IW(KJQDET(KI)+JQDEEG)+JEGPF4)
      QEGPDM(KI)=RW(IW(KJQDET(KI)+JQDEEG)+JEGPDM)
      KEGPST(KI)=IW(IW(KJQDET(KI)+JQDEEG)+JEGPST)
      KEGPQU(KI)=IW(IW(KJQDET(KI)+JQDEEG)+JEGPQU)
      KEGPPE(KI)=IW(IW(KJQDET(KI)+JQDEEG)+JEGPPE)
C
      XPGP(KI)=IW(KJQDET(KI)+JQDEPG).NE.KQZER.AND.IW(NAPGPC).GT.0
      QPGPR1(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPR1)
      QPGPR2(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPR2)
      QPGPF4(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPF4)
      QPGPDM(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPDM)
      QPGPST(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPST)
      QPGPQ1(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPQ1)
      QPGPQ2(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPQ2)
      QPGPM1(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPM1)
      QPGPM2(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPM2)
      QPGPMA(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPMA)
      QPGPER(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPER)
      QPGPTR(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPTR)
      QPGPPR(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGPPR)
      KPGPQU(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGPQU)
      KPGPPE(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGPPE)
      XPGAC(KI)=IW(KJQDET(KI)+JQDEPG).NE.KQZER.AND.IW(NAPGAC).GT.0
      KPGAST(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGAST)
      QPGAEF(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGAEF)
      QPGAGC(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGAGC)
      QPGAZS(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGAZS)
      QPGAPL(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGAPL)
      QPGAPH(KI)=RW(IW(KJQDET(KI)+JQDEPG)+JPGAPH)
      KPGAPN(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGAPN)
      KPGAFA(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGAFA)
      KPGAPE(KI)=IW(IW(KJQDET(KI)+JQDEPG)+JPGAPE)
C
C
      XYV0(KI)=KVYV0V(KENDV(KI)).NE.0
      KYV0K1(KI)=IW(KVYV0V(KENDV(KI))+JYV0K1)
      KYV0K2(KI)=IW(KVYV0V(KENDV(KI))+JYV0K2)
      QYV0VX(KI)=RW(KVYV0V(KENDV(KI))+JYV0VX)
      QYV0VY(KI)=RW(KVYV0V(KENDV(KI))+JYV0VY)
      QYV0VZ(KI)=RW(KVYV0V(KENDV(KI))+JYV0VZ)
      QYV0X1(KI)=RW(KVYV0V(KENDV(KI))+JYV0X1)
      QYV0X2(KI)=RW(KVYV0V(KENDV(KI))+JYV0X2)
      QYV0C2(KI)=RW(KVYV0V(KENDV(KI))+JYV0C2)
      KYV0IC(KI)=IW(KVYV0V(KENDV(KI))+JYV0IC)
      QYV0DM(KI)=RW(KVYV0V(KENDV(KI))+JYV0DM)
      QYV0S1(KI)=RW(KVYV0V(KENDV(KI))+JYV0S1)
      QYV0S2(KI)=RW(KVYV0V(KENDV(KI))+JYV0S2)
C
      XLEPTG(KI)=IW(KJQDET(KI)+JQDEPD).NE.KQZER
      KLEPPA(KI)=IW(IW(KJQDET(KI)+JQDEPD)+JPDLPA)
      KLEPJT(KI)=IW(IW(KJQDET(KI)+JQDEPD)+JPDLJT)+KLFJET-1
      QLEPPI(KI)=RW(IW(KJQDET(KI)+JQDEPD)+JPDLPI)
      QLEPPE(KI)=RW(IW(KJQDET(KI)+JQDEPD)+JPDLPE)
      KLEPVP(KI)=IW(IW(KJQDET(KI)+JQDEPD)+JPDLVP)
C
      XLEPTH(KI)=IW(KJQDET(KI)+JQDEPM).NE.KQZER
      KLEPFL(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLFL)
      KLEPPO(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLPO)
      KLEPCH(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLCH)
      KLEPSP(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLSP)
      KLEPLE(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLLE)
      KLEPME(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLME)
      KLEPKT(KI)=IW(IW(KJQDET(KI)+JQDEPM)+JPMLKT)
C---------------------  end of QMACRO ---------------------------------
C-----------------------------------------------------------------------
C If this is the first call to QSELEP then initialize the bank format an
C write out the welcome message. Also work what type and year of data th
C is.
C
      IF (IW(NAMIND('QLID')).EQ.0) GO TO 9999
      IF (LTFRST) THEN
        LASTRN = KRUN
        CALL GTYEAR
        WRITE(SLOUT,1000)
        IF (LTFWCD.EQ.0) WRITE(SLOUT,1007)
        IF (LTFWCD.EQ.1) WRITE(SLOUT,1008)
        IF (LTFWCD.EQ.2) WRITE(SLOUT,1009)
        IF (XMCEV) THEN
          WRITE(SLOUT,1010) YEARID
        ELSE
          WRITE(SLOUT,1011) YEARID
        ENDIF
        WRITE(SLOUT,1000)
        CALL BKFMT('PDLT','2I,(2I,2F,2I)')
        CALL BKFMT('PMLT','2I,(8I)')
        CALL BKFMT('PLJT','2I,(4F,I)')
        LTFRST = .FALSE.
      ENDIF
      LEPCNT(LTCALL) = LEPCNT(LTCALL)+1
C
C Check to see that the run number hasn't changed. If it has then write
C out a warning if the last run contained no good events. Also calculate
C the year we are running on.
C
      IF (LASTRN.NE.KRUN) THEN
        IF (NLPTEV.EQ.0) THEN
          WRITE(SLOUT,*) 'WARNING-> QSELEP found no good leptons in ',
     @                   'the previous run (',LASTRN,')'
        ENDIF
        NLPTEV = 0
        LASTRN = KRUN
        CALL GTYEAR
      ENDIF
      IF (YEARID.EQ.0) GOTO 912
C
C Occasionally BOS will not drop the PMLT bank created during the previo
C event. This is checked for here and if a spurious PMLT bank is found i
C is dropped before proceeding.
C
      KPDLT  = NDROP('PDLT',0)
      KPMLT  = NDROP('PMLT',0)
      KPLJT  = NDROP('PLJT',0)
C
C Check to see we have at least the minimum number of charged tracks and
C more then zero energy flow objects to study. This is basically a crash
C protection against strange input.
C
      ICLEP = 0
      IERR = 0
      IF (KNCHT.LE.0.OR.KNEFT.LE.0) GOTO 911
C
C Zero all Alpha locks and user flags.
C
      CALL QLZER(KRECO)
      DO 100 ITK = KFCHT,KLCHT
        CALL QLUTRK(ITK)
        DO 100 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  100 CONTINUE
      DO 105 ITK = KFEFT,KLEFT
        CALL QLUTRK(ITK)
        DO 105 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  105 CONTINUE
C
C The following Alpha user flags are used:
C
C        Flag        Value        Comment
C        ----        -----        -------
C          8            n         CHT -> EFT track pointer (CHT only)
C         10            1         Genuine electron
C         10            2         Genuine positron
C         10            3         Conversion / pair e+ or e-
C         10           -1         Fake electron
C         10           -2         Fake positron
C         12            n         EFT -> JET track pointer (EFT only)
C         15            1         Genuine mu+
C         15            2         Genuine mu-
C         15           -1         Fake mu+
C         15           -2         Fake mu-
C         16          13,14       IDF code from QMUIDO if mu+ or mu-
C
C Check that the HCAL, ECAL, ITC, DEDX high voltage bits are set and tha
C this event does not contain a DAQ error. Have to do extra test to see
C this is Monte Carlo as the HV info is not available for MC data.
C
      IF (.NOT.XMCEV) THEN
        IF (.NOT.(XVHCAL.AND.XVECAL.AND.XVTPCD.AND.XVITC)) GOTO 910
      ENDIF
      IF (KEVEES.NE.1) GOTO 910
C
C Test each charged track to see if it passes basic track cuts.
C If it does then increment the number of good tracks counter and add it
C energy to the ETOT variable. Then cut on the final values. The bad tra
C are not locked at this point. They are locked seperately for the
C electron/positron and muon routines as the cuts to define what is/is n
C a good track are different.
C
      NGOOD = 0
      ETOT = 0.0
      DO 110 ITK=KFCHT,KLCHT
        IF (.NOT.BADTRK(ITK,MCOSTH,MINHIT,D0CUT,Z0CUT)) THEN
          NGOOD = NGOOD+1
          ETOT = ETOT+QE(ITK)
        ENDIF
  110 CONTINUE
C
C Enough good tracks and energy to continue?
C
      IF (NGOOD.LT.MINGDT) GOTO 901
      IF (QELEP.LT.80.0.OR.QELEP.GT.300.0) GOTO 902
      IF (ETOT.LT.MINVIS*QELEP) GOTO 903
      LEPCNT(LTHAD) = LEPCNT(LTHAD)+1
C-----------------------------------------------------------------------
C--   Do jetfinding
C--
      CALL QJOPTR('EF',' ')
      JNAM = 'ENJETS  '
      YCUT =  SYCUT*(QLPEAK**2/QELEP**2)
      CALL QJMMCL(NJETS,JNAM,KRECO,YCUT,QELEP)
      IF (NJETS.LT.2) GO TO 907
C-----------------------------------------------------------------------
C Loop over all charged tracks locking any track which fails to satisfy
C the basic track cuts for consideration as an electron or positron.
C
      NLEPT = 0
      NPOSI = 0
      NELEC = 0
      NMUPL = 0
      NMUMI = 0
      NCONV = 0
      NBOTH = 0
      NGOOD = 0
      DO 120 ITK = KFCHT,KLCHT
        IF (BADTRK(ITK,CSTHEP,TPCEP,D0MXEP,Z0MXEP)) THEN
          CALL QLTRK(ITK)
        ELSE
          NGOOD = NGOOD+1
        ENDIF
  120 CONTINUE
C
C-------------------------Start of electron/positron loop---------------
C
      DO 200 ITK=KFCHT,KLCHT
        IF (XLOCK(ITK)) GOTO 200
C
C Cut on the minimum momentum of the track.
C
        IF (QP(ITK).LT.PEPMIN) GOTO 200
C
C Calculate the R2, R3 estimators.
C
        IF (XEID(ITK)) THEN
          R2 = QEIDRI(ITK,2)
          R3 = QEIDRI(ITK,3)
        ELSE
          GOTO 200
        ENDIF
C
C The R5 dE/dx estimator is a bit more complicated.
C Call DEDXM if old Monte-Carlo
C
        NS = 0
        R5 = -998.
        IF(.NOT.CHTSIM(DUMMY)) THEN
        CALL QDEDXM(ITK,1,QPMASS('e+'),QCH(ITK),
     @              RI,NS,TL,RIEXP,SIGMA,IERDEX)
        ELSE
        CALL QDEDX(ITK,1,QPMASS('e+'),QCH(ITK),
     @              RI,NS,TL,RIEXP,SIGMA,IERDEX)
        ENDIF
        IF (IERDEX.NE.0) GO TO 199
        R5 = (RI - RIEXP)/SIGMA
 199    CONTINUE
C
C Apply the R3 cut.
C
        IF (R3.LE.R3CUT(1).OR.R3.GE.R3CUT(2)) GOTO 200
C
C Apply the R2 cut.
C
        IF (R2.LE.R2CUT(1).OR.R2.GE.R2CUT(2)) GOTO 200
C
C Apply the R5 cut.
C
        IF (NS.LT.MINWIR.OR.R5.LE.R5CUT(1).OR.R5.GE.R5CUT(2)) GOTO 200
C
C Electron/positron candidate has passed R2, R3, and R5 cuts so flag it
C user flag 16.
C
        IF (KCH(ITK).EQ.-1) THEN
          CALL QSTFLI(ITK,10,1)
          NLEPT = NLEPT+1
          NELEC = NELEC+1
        ELSE IF (KCH(ITK).EQ.1) THEN
          CALL QSTFLI(ITK,10,2)
          NLEPT = NLEPT+1
          NPOSI = NPOSI+1
        ELSE
          GOTO 904
        ENDIF
C
C At this point we want to remove any pairs and Dalitz decays.
C We search for pairs using QPAIRF. Each track is compared with the curr
C track to see if they are really a pair from a photon conversion.
C Don't want to compare the track with itself or compare like sign
C tracks as these can obviously never come from a photon conversion.
C
        DO 240 IDX = KFCHT,KLCHT
          IF (ITK.EQ.IDX.OR.(QCH(IDX)*QCH(ITK).GE.0.)) GOTO 240
          CALL QPAIRF(ITK,IDX,DXY,DZ0,DZ2,DTH,RMA,ZMA,XMA,
     @                NC1,DIN1,NC2,DIN2,P,IERQPA)
          IF (IERQPA.NE.0) GOTO 240
          IF (ABS(DXY).GE.DXYCUT) GOTO 240
          IF (ABS(DZ2).GE.DZCUT) GOTO 240
          IF (XMA.GE.MXINV) GOTO 240
C
C If we get to here then we've found a conversion. Flag it and adjust co
C
          IF (KRDFL(ITK,10).EQ.1) NELEC = NELEC-1
          IF (KRDFL(ITK,10).EQ.2) NPOSI = NPOSI-1
          NCONV = NCONV+1
          LEPCNT(LTNCNV) = LEPCNT(LTNCNV)+1
          IF(KRDFL(ITK,10).EQ.1) CALL QSTFLI(ITK,10,3)
          IF(KRDFL(ITK,10).EQ.2) CALL QSTFLI(ITK,10,4)
          IF( RWCONV.GT.0) GO TO 240
          NLEPT = NLEPT-1
          GOTO 200
  240   CONTINUE
C
C Succesfully processed that track - now the next.
C
  200 CONTINUE
C-------------------------End of electron/positron loop-----------------
C
C Reset all the track locks here and then call BADTRK with the muon trac
C cuts. Visible energy and number of good track cuts are not repeated as
C are assumed to have been passed the first time BADTRK was called for t
C electrons and positrons.
C
      NGOOD = 0
      DO 300 ITK=KFCHT,KLCHT
        CALL QLUTRK(ITK)
  300 CONTINUE
      DO 310 ITK=KFCHT,KLCHT
        IF (BADTRK(ITK,MCOSTH,MINHIT,D0CUT,Z0CUT)) THEN
           CALL QLTRK(ITK)
        ELSE
          IF (BADTRK(ITK,CSTHMU,TPCMU,D0MXMU,Z0MXMU)) THEN
            CALL QLTRK(ITK)
           ELSE
             NGOOD = NGOOD+1
           ENDIF
         ENDIF
  310 CONTINUE
C
C-------------------------Start of mu+/mu- loop-------------------------
C
      DO 400 ITK=KFCHT,KLCHT
        IF (XLOCK(ITK)) GOTO 400
C
C First do a cut on the minimum track momentum for consideration as a mu
C
        IF (QP(ITK).LT.PMUMIN) GOTO 400
C
C Selecting muons is easy with QMUIDO 8.0. Just call it and store muon
C if IDF=13 or 14. Corresponding to 1 or 2 muon chamber hits + high puri
C heavy flavour cuts.
C
        CALL QMUIDO(ITK,IRUN,IBE,IBT,IM1,IM2,NEXP,NFIR,N10,N03,
     @              XMULT,RAPP,ANG,ISHAD,SUDNT,IDF,IMCF,IERMU)
        IF (IERMU.NE.0) GOTO 400
C
C To enable booking of histograms if NEXP=0 then we set EXPFIR to 999.0.
C This has NO effect on the muons we actually select.
C
        IF (NEXP.NE.0) THEN
          EXPFIR = FLOAT(NFIR)/FLOAT(NEXP)
        ELSE
          EXPFIR = 999.0
        ENDIF
        IF (IDF.EQ.13.OR.IDF.EQ.14) THEN
C
C Flag what we've found as being either a mu+ or mu- in the user flags.
C
          IF (KCH(ITK).EQ.-1) THEN
            CALL QSTFLI(ITK,15,2)
            CALL QSTFLI(ITK,16,IDF)
            NLEPT = NLEPT+1
            NMUMI = NMUMI+1
          ELSE IF (KCH(ITK).EQ.1) THEN
            CALL QSTFLI(ITK,15,1)
            CALL QSTFLI(ITK,16,IDF)
            NLEPT = NLEPT+1
            NMUPL = NMUPL+1
          ELSE
            GOTO 904
          ENDIF
C
C Test here to see if the muon we have just selected was already
C flagged as a genuine electron or conversion. If it was we clear the
C electron flag as it is much more likely to actually be a muon. We
C modify the counters and increment NBOTH to reflect this strange occure
C
          IF (KRDFL(ITK,10).EQ.1) THEN
            NELEC = NELEC-1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
            NBOTH = NBOTH+1
            LEPCNT(LTELMU) = LEPCNT(LTELMU)+1
          ENDIF
          IF (KRDFL(ITK,10).EQ.2) THEN
            NPOSI = NPOSI-1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
            NBOTH = NBOTH+1
            LEPCNT(LTELMU) = LEPCNT(LTELMU)+1
          ENDIF
          IF (KRDFL(ITK,10).EQ.3) THEN
            NCONV = NCONV-1
            CALL QSTFLI(ITK,10,0)
            NBOTH = NBOTH+1
            LEPCNT(LTCONV) = LEPCNT(LTCONV)+1
          ENDIF
        ENDIF
C
C Succesfully processed that track - now the next.
C
  400 CONTINUE
C
C-------------------------End of mu+/mu- loop---------------------------
C
C If we get to here then everything has worked ok. We either have or do
C have leptons. If we don't then just exit at this point with IERR set t
C If we have found (a) useful lepton(s) then create the PDLT bank and ad
C to the 'E' list ready for writing out. If no writing out takes places
C will have no adverse effect.
C
      IF (NLEPT.EQ.0) THEN
        LEPCNT(LTNLEP) = LEPCNT(LTNLEP)+1
        IERR = 0
        GOTO 900
      ENDIF
C
C Check that we have at least 2 jets. If not then exit with an error.
C
      NJET = 0
      IDJET = KPDIR(JNAM,KRECO)
      LSJET = IDJET
  520 IF (IDJET.NE.0) THEN
        NJET = NJET+1
        IDJET = KFOLLO(IDJET)
        GOTO 520
      ENDIF
      IF ( XBANK ) THEN
      NLENG = LPLJTA*NJET +LMHLEN
      KPLJT = NDROP('PLJT',0)
      CALL AUBOS('PLJT',0,NLENG,KPLJT,IGARB)
      IF ( IGARB.EQ.2) THEN
        WRITE(SLOUT,*) 'Not enough space to load PLJT bank ',KRUN,KEVT
        GO TO 906
      ENDIF
      IW(KPLJT+LMHROW) = NJET
      IW(KPLJT+LMHCOL) = LPLJTA
      IDJET = LSJET
      IJET = 0
  525 IF (IDJET.NE.0) THEN
        IJET = IJET+1
        JPLJT = KROW(KPLJT,IJET)
        RW(JPLJT+JPLJPX) = QX(IDJET)
        RW(JPLJT+JPLJPY) = QY(IDJET)
        RW(JPLJT+JPLJPZ) = QZ(IDJET)
        RW(JPLJT+JPLJPE) = QE(IDJET)
        IW(JPLJT+JPLJNO) = 0
        IDJET = KFOLLO(IDJET)
        GOTO 525
      ENDIF
      ENDIF
      IERJET =0
      IF (NJET.LT.MINJET) THEN
        IERJET = 40
      ENDIF
C
C Fill user flag 12 of each energy flow object with the jet that the
C object belongs to. Any object not matched is flagged zero.
C
      DO 570 ITK = KFEFT,KLEFT
        IDJET = KPDIR(JNAM,KRECO)
  580   IF (IDJET.NE.0) THEN
          IF (XSAME(ITK,IDJET)) THEN
            JPLJT = KROW(KPLJT,1-IDJET+LSJET)
            IW(JPLJT+JPLJNO) = IW(JPLJT+JPLJNO)+1
            CALL QSTFLI(ITK,12,IDJET)
            GOTO 570
          ENDIF
          IDJET = KFOLLO(IDJET)
          GOTO 580
        ENDIF
  570 CONTINUE
C
C Fill user flag 8 of each charged track with the id number of its
C corresponding energy flow object. Any object not matched will be flagg
C zero.
C
      DO 585 ITK = KFCHT,KLCHT
        DO 586 IDX = KFEFT,KLEFT
          IF (XSAME(ITK,IDX)) THEN
            IF (KRDFL(ITK,8).NE.0) THEN
              CALL QSTFLI(ITK,8,-IDX)
            ELSE
              CALL QSTFLI(ITK,8,IDX)
            ENDIF
          ENDIF
  586   CONTINUE
  585 CONTINUE
C
C For each good lepton check to see that the jet it belongs to passes tw
C cuts: Firstly that there are enough objects in the jet and secondly th
C the lepton doesn't contribute more than a certain percentage of the
C total energy of the jet. If the lepton fails these cuts then it is del
C from the list of good leptons.
C
C If the lepton to energy flow object to jet association is found to hav
C failed QSELEP returns with an error.
C
      DO 590 ITK = KFCHT,KLCHT
        IF (KRDFL(ITK,10).EQ.1.OR.KRDFL(ITK,10).EQ.2.OR.
     @    ((KRDFL(ITK,10).EQ.3.OR.KRDFL(ITK,10).EQ.4).AND.RWCONV.GT.0).
     @    OR.KRDFL(ITK,15).EQ.1.OR.KRDFL(ITK,15).EQ.2) THEN
              IF (KRDFL(ITK,8).LE.0) THEN
                CALL QSTFLI(ITK,8,-1000)
                GO TO 590
              ENDIF
          IDJET = KRDFL(KRDFL(ITK,8),12)
          IF (IDJET.EQ.0) THEN
             CALL QSTFLI(ITK,8,-2000)
             GO TO 590
          ENDIF
          NTRACK = 0
          DO 610 IDX = KFEFT,KLEFT
            IF (KRDFL(IDX,12).EQ.IDJET) NTRACK = NTRACK+1
  610     CONTINUE
          EJET = QP(ITK) / QE(IDJET)
          IF (NTRACK.GE.NTRJET.AND.EJET.LT.ENTRJT) GO TO 590
          CALL  QSTFLI(ITK,8,-3000)
C         GO TO 590
        ENDIF
  590 CONTINUE
C
C Check again to see if we have any good leptons left. Have to
C do this because the jet cuts above may have removed all of our good
C leptons.
C
      IF (NLEPT.EQ.0) THEN
        LEPCNT(LTNLEP) = LEPCNT(LTNLEP)+1
        IERR = 0
        GOTO 900
      ENDIF
C-------------------   Filling of bank PDLT  ---------------------------
C Reserve enough room for the bank. This is the bank size * the number o
C leptons + 2 for the bank size + number of rows information. After this
C point if an error occurs the PDLT bank is always dropped before leavin
C QSELEP.
C
      IF ( XBANK ) THEN
      NLENG = NLEPT*LPDLTA + LMHLEN
      CALL AUBOS('PDLT',0,NLENG,KPDLT,IGARB)
      IF ( IGARB.EQ.2) THEN
        WRITE(SLOUT,*) 'Not enough space to load PDLT bank ',KRUN,KEVT
        GO TO 906
      ENDIF
C
C Fill the first 2 words of PDLT so that the PDLT bank obeys the aleph
C bank standard. The first word corresponds to the number of words
C per lepton. The second corresponds to the number of leptons.
C
      IW(KPDLT+LMHCOL) = LPDLTA
      IW(KPDLT+LMHROW) = NLEPT
      IF( XMCEV ) THEN
      NLENG = NLEPT*LPMLTA + LMHLEN
      CALL AUBOS('PMLT',0,NLENG,KPMLT,IGARB)
      IF ( IGARB.EQ.2) THEN
        WRITE(SLOUT,*) 'Not enough space to load PDLT bank ',KRUN,KEVT
        GO TO 906
      ENDIF
      IW(KPMLT+LMHCOL) = LPMLTA
      IW(KPMLT+LMHROW) = NLEPT
      ENDIF
      ENDIF
C
C Now loop through all the charged tracks reading the user flags and
C creating lepton banks for those that have flags set
C
C Initialisation
C
      IDX = 0
      CALL VZERO(PJET,4)
      CALL VZERO(PLEPT,3)
C
C Start the main writeout loop
C
      DO 500 ITK=KFCHT,KLCHT
        PTINC = 0
        PTEXCL = 0
C
C Check to see if this track is flagged as a good lepton.
C or a conversion to be kept
C
        IF (KRDFL(ITK,10).EQ.1.OR.KRDFL(ITK,10).EQ.2.OR.
     @  ((KRDFL(ITK,10).EQ.3.OR.KRDFL(ITK,10).EQ.4).AND.RWCONV.GT.0).
     @    OR.KRDFL(ITK,15).EQ.1.OR.KRDFL(ITK,15).EQ.2) THEN
C
C Find the energy flow track which corresponds to our lepton.
C
          ETK = KRDFL(ITK,8)
C
C Generate an error if we can't associate our lepton with an energy flow
C track.
C
          PTINC = 0
          PTEXCL = 0
          IF (ETK.LE.0) THEN
            IERJET = 10
            GO TO 501
          ENDIF
C
C Find which jet this lepton belongs to.
C
          JETID = KRDFL(ETK,12)
C
C Check that we've associated this correctly if not generate an error.
C
          IF (JETID.EQ.0) THEN
            IERJET =20
            GOTO 501
          ENDIF
C
C Get the details about the lepton candidate
C
          PLEPT(1) = QX(ETK)
          PLEPT(2) = QY(ETK)
          PLEPT(3) = QZ(ETK)
C
C Go to the jet and pick up the jet four-vector.
C
          PJET(1) = QX(JETID)
          PJET(2) = QY(JETID)
          PJET(3) = QZ(JETID)
          PJET(4) = QE(JETID)
C
C Calculate the inclusive Pt (easy ain't it?). Note that the charged
C track and not the enflw object is used in this calculation.
C
          PTINC = QPPER(ITK,JETID)
C
C Calculate the exclusive Pt by subtracting the lepton momentum
C from the jet.
C
C The recipe is as follows:
C
C        o First subtract the lepton energy flow object from the jet.
C        o Next calculate theta using the jet and the lepton track.
C        o Then calculate the exclusive Pt using the lepton track moment
C
          DO II = 1,3
            PJET(II) = PJET(II) - PLEPT(II)
          ENDDO
C
C Calculate the pt using the charged track exiting if an error occurs.
C
          PLEPT(1) = QX(ITK)
          PLEPT(2) = QY(ITK)
          PLEPT(3) = QZ(ITK)
C
          PJET(4) = SQRT(PJET(1)**2+PJET(2)**2+PJET(3)**2)
          VINP=PLEPT(1)*PJET(1)+PLEPT(2)*PJET(2)+PLEPT(3)*PJET(3)
          IF (PJET(4).EQ.0..OR.QP(ITK).EQ.0.) THEN
            IERJET = 20
            GO TO 501
          ENDIF
          COSTHE = VINP/(PJET(4)*QP(ITK))
          SINTHE = 1 - COSTHE**2
          IF (SINTHE.GE.0) THEN
            SINTHE = SQRT(SINTHE)
          ELSE
            IERJET = 30
            GO TO 501
          ENDIF
          PTEXCL = QP(ITK)*SINTHE
          IF((KRDFL(ITK,10).EQ.1.OR.KRDFL(ITK,10).EQ.2.OR.
     @  ((KRDFL(ITK,10).EQ.3.OR.KRDFL(ITK,10).EQ.4).AND.RWCONV.GT.0))
     @   .AND.PTEXCL.LT.PTEPMN) THEN
            IERJET = 50
          ENDIF
          IF((KRDFL(ITK,15).EQ.1.OR.KRDFL(ITK,15).EQ.2).AND.PTEXCL.LT
     @    .PTMUMN) THEN
            IERJET = 50
          ENDIF
C
C-   Now fill PDLT bank
C
  501     CONTINUE
          IF ( RWPTS.GT.0.OR.IERJET.EQ.0) GO TO 502
  600     IF (KRDFL(ITK,10).EQ.1) THEN
            NELEC = NELEC-1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
          ENDIF
          IF (KRDFL(ITK,10).EQ.2) THEN
            NPOSI = NPOSI -1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
          ENDIF
          IF (KRDFL(ITK,10).EQ.3) THEN
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
          ENDIF
          IF (KRDFL(ITK,10).EQ.4) THEN
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,10,0)
          ENDIF
          IF (KRDFL(ITK,15).EQ.1) THEN
            NMUPL = NMUPL-1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,15,0)
            CALL QSTFLI(ITK,16,0)
          ENDIF
          IF (KRDFL(ITK,15).EQ.2) THEN
            NMUMI = NMUMI-1
            NLEPT = NLEPT-1
            CALL QSTFLI(ITK,15,0)
            CALL QSTFLI(ITK,16,0)
          ENDIF
          GO TO 500
 502      CONTINUE
          IF ( XBANK ) THEN
          ICLEP = ICLEP + 1
C
C Word 5.
          JPDLT = KROW(KPDLT,ICLEP)
          IW(JPDLT+JPDLFR)  = KTN(ITK) ! Julia track number
C
C Word 1.
C
C For the electrons/positrons the particle code is multiplied by 10* the
C track's quality flag returned by KEIDIF.
C KEIDIF = 0 - good
C        = 1 - estimation done in crack region
C        = 2 - estimation done in overlap region
C To remove this information just do a mod 10 on the stored word....
C
          IEREL = 0
          IQUAL = 0
          IF (KRDFL(ITK,10).EQ.1) THEN
            IF (XEID(ITK)) IEREL = ABS(KEIDIF(ITK))
            IQUAL  = INT(3+10*IEREL)! Electron
            LEPCNT(LTNEMI) = LEPCNT(LTNEMI)+1
          ENDIF
          IF (KRDFL(ITK,10).EQ.2) THEN
            IF (XEID(ITK)) IEREL = ABS(KEIDIF(ITK))
            IQUAL  = INT(2+10*IEREL)! POSITR ON
            LEPCNT(LTNEPL) = LEPCNT(LTNEPL)+1
          ENDIF
          IF (KRDFL(ITK,10).EQ.3) THEN
            IF (XEID(ITK)) IEREL = ABS(KEIDIF(ITK))
            IQUAL  = INT(103+10*IEREL)! Electron
            LEPCNT(LTNEMI) = LEPCNT(LTNEMI)+1
          ENDIF
          IF (KRDFL(ITK,10).EQ.4) THEN
            IF (XEID(ITK)) IEREL = ABS(KEIDIF(ITK))
            IQUAL  = INT(102+10*IEREL)! Positron
            LEPCNT(LTNEPL) = LEPCNT(LTNEPL)+1
          ENDIF
          IF (KRDFL(ITK,15).EQ.1) THEN
            IF (KRDFL(ITK,16).EQ.14)
     @      IQUAL = 5              ! Mu+
            IF (KRDFL(ITK,16).EQ.13)
     @      IQUAL = 15             ! Mu+
            LEPCNT(LTNMPL) = LEPCNT(LTNMPL)+1
          ENDIF
          IF (KRDFL(ITK,15).EQ.2) THEN
            IF (KRDFL(ITK,16).EQ.14)
     @      IQUAL = 6              ! Mu-
            IF (KRDFL(ITK,16).EQ.13)
     @      IQUAL = 16             ! Mu-
            LEPCNT(LTNMMI) = LEPCNT(LTNMMI)+1
          ENDIF
          IW(JPDLT+JPDLPA) = IQUAL
C
C Word 2.
C
          IF ( JETID.EQ.0) THEN
            IW(JPDLT+JPDLJT) = 0
          ELSE
            IW(JPDLT+JPDLJT)  =  LSJET - JETID + 1      ! Jet number
          ENDIF
          IF ( IERJET.NE.0 ) THEN
            IW(JPDLT+JPDLVP) = IERJET
          ELSE
            IW(JPDLT+JPDLVP) = 0
          ENDIF
C
C Word 3.
C
          RW(JPDLT+JPDLPI)  =     PTINC               ! PT INCLUSIVE
C
C Word 4.
C
          RW(JPDLT+JPDLPE)  =     PTEXCL            ! PT EXCLUSIVE
C---------------  Call QTRUTH and fill bank PMLT  ----------------------
C If Monte Carlo truth exists then call QTRUTH to evaluate the Monte Car
C history information of the lepton, fill PMLT bank
C
C Input = track number. Output = parent quark and decay type.
C
          IF (.NOT.XMCEV) GO TO 500
          JPMLT = KROW(KPMLT,ICLEP)
          IMCFL = 0
          IFLAV = 0
          IPAR = 0
          IF (XMCEV) THEN
            CALL QTRUTH(ITK,IFLAV,IPOP,ICHAIN,ISPLIT,LEPID,IBMES)
            IF(IFLAV.GT.5.OR.IFLAV.LT.0) THEN
              IERR = -13
              GO TO 913
            ENDIF
C
C Input = lepton track number. Output = # of the associated MC track
C
            IMCT = JMBEST(ITK)
C  Find the parent of the lepton
  555       IF (IMCT.GT.0) THEN
              IPAR = KMOTH(IMCT,1)
              IF (KTPCOD(IMCT).EQ.KTPCOD(IPAR))THEN
                IMCT = IPAR
                GOTO 555
              ENDIF
            ENDIF
          ENDIF
C
C Fill the PMLT bank word by word.
C
C
C Word 8.
          IW(JPMLT+JPMLFR) = KTN(ITK) ! JULIA TRACK NUMBER
C
C Word 1.
C
          IW(JPMLT+JPMLFL) = IFLAV ! PRIMARY QUARK  FLAG
C
C Word 2.
C
          IW(JPMLT+JPMLPO)  = IPOP ! IPOP
C
C Word 3.
C
          IW(JPMLT+JPMLCH)  = ICHAIN ! ICHAIN
C
C Word 4.
C
          IW(JPMLT+JPMLSP)  = ISPLIT  ! ISPLIT
C
C Word 5.
C
          IW(JPMLT+JPMLLE) = LEPID !  LEPID
C
C Word 6.
C
          IW(JPMLT+JPMLME) = IBMES ! IBMES
C
C Word 7
C
          IW(JPMLT+JPMLKT) = IMCT - KFMCT + 1
        ENDIF
      ENDIF
  500 CONTINUE

C
C   Fill number of leptons
C
      IF ( XBANK) THEN
      IW(KPDLT+LMHROW) = ICLEP
      IF(XMCEV) THEN
      IW(KPMLT+LMHROW) = ICLEP
      ENDIF
      CALL AUBPRS('PDLTPMLT')
      ENDIF
C
C Zero all locks and user  flags as per the calling convention.
C
      CALL QLZER(KRECO)
      DO 510 ITK = KFCHT,KLCHT
        CALL QLUTRK(ITK)
        DO 510 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  510 CONTINUE
      DO 530 ITK = KFEFT,KLEFT
        CALL QLUTRK(ITK)
        DO 530 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  530 CONTINUE
C
C Add the  bank to the E list so it is written out then return.
C
      LEPCNT(LTYLEP) = LEPCNT(LTYLEP)+1
      NLPTEV = NLPTEV+1
      IERR = NLEPT
      CALL BLIST(IW,'E+','PMLT')
      CALL BLIST(IW,'E+','PDLT')
      CALL BLIST(IW,'E+','PLJT')
      GO TO 9999
C---------------  Error handling ---------------------------------------
C Here - grouped together - are all the error returns. Individual
C comments describe what they actually mean. All negative values of
C IERR are actual errors. Zero return means no problem but no leptons
C found. Positive values indicate no problems and N leptons found.
C
  901 CONTINUE            !      'ERROR - too few good tracks'
      LEPCNT(LTNCHR) = LEPCNT(LTNCHR)+1
      IERR = -1           ! Too few good tracks.
      GOTO 900            !
  902 CONTINUE            !      'ERROR - LEP energy wrong'
      LEPCNT(LTQLPR) = LEPCNT(LTQLPR)+1
      IERR = -2           ! LEP energy too low or too high.
      GOTO 900            !
  903 CONTINUE            !      'ERROR - Less than 10% Ecm available'
      LEPCNT(LTECHR) = LEPCNT(LTECHR)+1
      IERR = -3           ! Less than 10% of LEP energy visible.
      GOTO 900            !
  904 CONTINUE            !      'ERROR - Alpha charge error'
      LEPCNT(LTACHR) = LEPCNT(LTACHR)+1
      IERR = -4           ! While trying to find the charge of a lepton
      GOTO 900            ! Alpha has returned a value other than -1 or
C 905 CONTINUE            !      'ERROR - BOS space corruption'
C     LEPCNT(LTBOSC) = LEPCNT(LTBOSC)+1
C     IERR = -5           ! The BOS space booked for leptons and the num
C     GOTO 900            ! stored do not match - this should NEVER happ
  906 CONTINUE            !      'ERROR - BOS unable to reserve space'
      LEPCNT(LTBOSS) = LEPCNT(LTBOSS)+1
      IERR = -6           ! BOS was unable to book the space requested.
      GOTO 900            !
  907 CONTINUE            !      'ERROR - Less than 2 jets found'
      LEPCNT(LTNJET) = LEPCNT(LTNJET)+1
      IERR = -7           ! There were less than 2 jets in this event.
      GOTO 900            !
C 908 CONTINUE            !      'ERROR - Lepton to jet assoc. failed'
C     LEPCNT(LTJTAS) = LEPCNT(LTJTAS)+1
C     IERR = -8           ! Couldn't find the jet to which the lepton be
C     GOTO 900            !
C 909 CONTINUE            !      'ERROR - Lepton Pt calc failed'
C     LEPCNT(LTPTFL) = LEPCNT(LTPTFL)+1
C     IERR = -9           ! While trying to calculate the lepton Pt a
C     GOTO 900            ! floating point exception would have occured.
  910 CONTINUE            !      'ERROR - Bad HV or DAQ status'
      LEPCNT(LTHVDQ) = LEPCNT(LTHVDQ)+1
      IERR = -10          ! This event either had bad HV or bad DAQ stat
      GOTO 900            !
  911 CONTINUE            !      'ERROR - No energy flow objects'
      LEPCNT(LTNEFO) = LEPCNT(LTNEFO)+1
      IERR = -11          ! The event was found to have zero tracks or
      GOTO 900            ! zero energy flow objects.
  912 CONTINUE            !      'ERROR - Unable to calculate the year'
      LEPCNT(LTGTYF) = LEPCNT(LTGTYF)+1
      IERR = -12          ! GTYEAR has been unable to associate a year
      GOTO 900            ! with this run.
  913 CONTINUE            !      'ERROR - Bad return code from QTRUTH'
      LEPCNT(LTBRFL) = LEPCNT(LTBRFL)+1
      IERR = -13          ! QTRUTH returned a value outside its document
      GOTO 900            ! return value ranges.
C
C Zero all locks and user flags as per the calling convention...
C
  900 CONTINUE                !  'Zeroing all locks and user flags'
      IF(KNCHT.GT.0.OR.KNEFT.GT.0) THEN
      CALL QLZER(KRECO)
      IF(KNCHT.GT.0) THEN
      DO 540 ITK = KFCHT,KLCHT
        CALL QLUTRK(ITK)
        DO 540 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  540 CONTINUE
      ENDIF
      IF(KNEFT.GT.0) THEN
      DO 550 ITK = KFEFT,KLEFT
        CALL QLUTRK(ITK)
        DO 550 IDX = 1,18
          CALL QSTFLI(ITK,IDX,0)
  550 CONTINUE
      ENDIF
      ENDIF
C
C ...and return.
C
 9999 CONTINUE
      RETURN
C-----------------------------------------------------------------------
C Format statements.
C
 1000 FORMAT(1X,'+--------------------------------------------+')
 1001 FORMAT(1X,'| Welcome to QSELEP Version 1.0              |')
 1002 FORMAT(1X,'| -----------------------------              |')
 1003 FORMAT(1X,'|                                            |')
 1004 FORMAT(1X,'|                                            |')
 1005 FORMAT(1X,'|                                            |')
 1006 FORMAT(1X,'|                                            |')
 1007 FORMAT(1X,'| Weights will not be filled.                |')
 1008 FORMAT(1X,'| Weight filling selected (Altarelli model). |')
 1009 FORMAT(1X,'| Weight filling selected (ISGW model).      |')
 1010 FORMAT(1X,'| You are using ',I4,' monte carlo data.       |')
 1011 FORMAT(1X,'| You are using ',I4,' real data.              |')
C
      END
