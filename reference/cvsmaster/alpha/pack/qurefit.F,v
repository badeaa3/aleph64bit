head	1.5;
access;
symbols
	alpha126_22:1.5
	alpha122_22:1.5
	alpha126_21:1.5
	alpha126_20:1.5
	alpha126_19:1.5
	alpha126_18:1.5
	alpha126_17:1.5
	alpha126_16:1.5
	alpha126_15:1.5
	alpha126_14:1.5
	alpha126_13:1.5
	alpha126_12:1.5
	alpha126_11:1.5
	alpha126_10:1.5
	alpha126_09:1.5
	alpha126_08:1.5
	alpha126_07:1.5
	alpha126_06:1.5
	alpha126_05:1.5
	alpha126_04:1.5
	alpha126_03:1.5
	alpha126_02:1.5
	alpha126_1:1.5
	alpha125_17:1.4
	alpha125_16:1.3
	alpha125_15:1.2
	alpha125_14:1.2
	alpha125_13:1.2
	alpha125_12:1.1
	alpha125_11:1.1
	alpha125_10:1.1
	alpha125_09:1.1
	alpha125_08:1.1
	alpha125_07:1.1;
locks; strict;
comment	@c @;


1.5
date	2000.11.21.08.46.59;	author boucrot;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.08.16.08.02;	author boucrot;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.07.07.26.43;	author boucrot;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.30.06.54.15;	author boucrot;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.26.07.41.44;	author boucrot;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@      SUBROUTINE QUREFIT
CKEY INIT /USER
C-----------------------------------------------------------------------
C! user refit of tracks
C called from QMEVNT before QFILL
C-----------------------------------------------------------------------
#ifndef DOC
      LOGICAL REFIT, CORRVD, UNITC, UNANY
      CHARACTER*16 PRGBK
      CHARACTER*80 LSTUN
      LOGICAL FIRST
      INTEGER NAREFT, NAUNPK
      SAVE FIRST, NAREFT
      INTEGER VDYEAR
      DATA FIRST /.TRUE./
#include "reftjj.h"
#include "rhahjj.h"
#include "qcde.h"
#include "qmacro.h"
C------------------------------------------------------------------------
      IF(FIRST)THEN
        FIRST = .FALSE.
        NARHAH = NAMIND('RHAH')
        NAREFT = NAMIND('REFT')
        NAUNPK = NAMIND('UNPK')
        KREFT = IW(NAREFT)
        IF(KREFT .NE. 0)THEN
          NDATA = IW(KREFT)
          IF(NDATA .LT. LREFTA)THEN
            CALL QMTERM(' qurefit --> Wrong REFT data card, exiting')
          ENDIF
        ENDIF
      ENDIF
C
C Defaults
C Refit if :
C   - Real data
C   - Lep2 (VDYEAR = 95)
C 
      IF(IW(NAMIND('AJOB')).EQ.0
     >     .AND. VDYEAR().EQ.95)THEN
        REFIT = .TRUE.
        CORRVD = .TRUE.
      ELSE
        REFIT = .FALSE.
        CORRVD = .FALSE.
      ENDIF
C
C Look at REFT bank
C
      KREFT = IW(NAREFT)
      IF(KREFT .NE. 0)THEN
        JVD = IW(KREFT+JREFVC)
        IRFT = IW(KREFT+JREFRF)
        IF(IRFT .EQ. 0)THEN
           REFIT = .FALSE.
        ELSE
           REFIT = .TRUE.
           IF(JVD .NE. 0)CORRVD = .TRUE.
        ENDIF
      ENDIF
      IF (REFIT) THEN
C
C One can only refit POTs or DSTs:
C Make sure that we are not reading a MINI
C this test must be skipped if one is writing a MINI
C
       if (.not.xwmini) then
         KRHAH = IW(NARHAH)
         NRHAH = LROWS(KRHAH)
         DO IRHAH=1,NRHAH
           CALL ALSTIN(IW(KROW(KRHAH,IRHAH)+JRHAPN),2,PRGBK)       
           IF(PRGBK(1:5) .EQ. 'MINI')REFIT = .FALSE.
         ENDDO
       endif
      ENDIF
      IF (REFIT) THEN
C 
C Correct Vdet coordinates if requested
C 
        IF(CORRVD)CALL VDFIXZ          
C
        CALL VTRKEX(QMFLD,IERR)
C Refit tracks
        CALL QFREFIT
      ENDIF
      RETURN
      END
#endif
@


1.4
log
@*** empty log message ***
@
text
@a8 1
      INTEGER JVERS
d20 1
a20 1
C
a36 1
C   - Jul > 312
d39 3
a41 4
C
      JVERS = IQVERP('JULIA') 
      IF(JVERS.GT.312 .AND. IW(NAMIND('AJOB')).EQ.0
     >                  .AND. VDYEAR().EQ.95)THEN
d62 1
a62 1
      IF(REFIT)THEN
d64 12
a75 8
C One can only refit POts, make sure that we are not on a MINI
C
        KRHAH = IW(NARHAH)
        NRHAH = LROWS(KRHAH)
        DO IRHAH=1,NRHAH
          CALL ALSTIN(IW(KROW(KRHAH,IRHAH)+JRHAPN),2,PRGBK)       
          IF(PRGBK(1:5) .EQ. 'MINI')REFIT = .FALSE.
        ENDDO
d77 1
a77 22
      IF(REFIT)THEN
C
C Look if there was an UNPK data card which requests for ITC,
C in which case we do not want to do it twice (program bombs if we do !0
C
        UNITC = .TRUE.
        UNANY = .TRUE.
        NDATA = IW(KUNPK)
        IF(INDEX(CQUNPK,'IT') .NE. 0)UNITC = .FALSE.          
        IF(INDEX(CQUNPK,'AL') .NE. 0)UNANY = .FALSE.          
C
C Unpack necessary banks
C
        IER = 0
        IF(UNANY)THEN
          IF(UNITC)THEN
            CALL AUNPCK('E','VD IT TP FI SO', IER)
          ELSE
            CALL AUNPCK('E','VD TP FI SO', IER)
          ENDIF
        ENDIF
        IF(IER .LE. 1)THEN
d81 1
a81 1
          IF(CORRVD)CALL VDFIXZ          
d83 1
a83 1
          CALL VTRKEX(QMFLD,IERR)
d85 1
a85 2
          CALL QFREFIT
        ENDIF
a89 9









@


1.3
log
@*** empty log message ***
@
text
@d8 1
a8 1
      LOGICAL REFIT, CORRVD
d11 1
d13 2
d19 2
a20 2
#include "bcs.h"
#include "bmacro.h"
d26 1
d67 1
a67 1
C One can only refit POts, make sure that we are on one
d73 1
a73 6
C
C The JULIA line comes always last for a POT file
C
          IF(PRGBK(1:5) .EQ. 'JULIA')THEN
            IF(IRHAH .NE. NRHAH)REFIT = .FALSE.
          ENDIF
d78 9
d89 8
a96 1
        CALL AUNPCK('E','VD IT TP FI SO', IER)
d111 2
@


1.2
log
@*** empty log message ***
@
text
@d12 1
d33 4
d39 2
a40 1
      IF(JVERS .GT. 312)THEN
d78 5
d86 1
a86 1
        IF(CORRVD)CALL VDFIXZ          
d88 1
a88 1
        CALL VTRKEX(QMFLD,IERR)
d90 2
a91 1
        CALL QFREFIT
@


1.1
log
@*** empty log message ***
@
text
@d8 73
a80 2
#include "qcde.h"
C-----------------------------------------------------------------------
d84 7
@

