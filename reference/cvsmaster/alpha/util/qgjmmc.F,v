head	1.1;
branch	1.1.1;
access;
symbols
	alpha126_22:1.1.1.1
	alpha126_21:1.1.1.1
	alpha126_20:1.1.1.1
	alpha126_19:1.1.1.1
	alpha126_18:1.1.1.1
	alpha126_17:1.1.1.1
	alpha126_16:1.1.1.1
	alpha126_15:1.1.1.1
	alpha126_14:1.1.1.1
	alpha126_13:1.1.1.1
	alpha126_12:1.1.1.1
	alpha126_11:1.1.1.1
	alpha126_10:1.1.1.1
	alpha126_09:1.1.1.1
	alpha126_08:1.1.1.1
	alpha126_07:1.1.1.1
	alpha126_06:1.1.1.1
	alpha126_05:1.1.1.1
	alpha126_04:1.1.1.1
	alpha126_03:1.1.1.1
	alpha126_02:1.1.1.1
	alpha126_1:1.1.1.1
	alpha125_17:1.1.1.1
	alpha125_16:1.1.1.1
	alpha125_15:1.1.1.1
	alpha125_14:1.1.1.1
	alpha125_13:1.1.1.1
	alpha125_12:1.1.1.1
	alpha125_11:1.1.1.1
	alpha125_10:1.1.1.1
	alpha125_09:1.1.1.1
	alpha125_08:1.1.1.1
	alpha125_07:1.1.1.1
	alpha125_06:1.1.1.1
	alpha125_05:1.1.1.1
	alpha125_04:1.1.1.1
	alpha125_03:1.1.1.1
	alpha125_02:1.1.1.1
	alpha125_01:1.1.1.1
	alpha124_19:1.1.1.1
	alpha125:1.1.1.1
	alpha124_18:1.1.1.1
	alpha124_17:1.1.1.1
	alpha124_16:1.1.1.1
	alpha124_15:1.1.1.1
	alpha124_14:1.1.1.1
	alpha124_13:1.1.1.1
	alpha124_12:1.1.1.1
	alpha124_11:1.1.1.1
	alpha124_10:1.1.1.1
	alpha124_09:1.1.1.1
	alpha124_08:1.1.1.1
	alpha124_07:1.1.1.1
	alpha124_7:1.1.1.1
	alpha124_06:1.1.1.1
	alpha124_05:1.1.1.1
	alpha124_04:1.1.1.1
	alpha124_03:1.1.1.1
	alpha124_02:1.1.1.1
	alpha124_01:1.1.1.1
	alpha124:1.1.1.1
	alpha123_12:1.1.1.1
	alpha123_11:1.1.1.1
	alpha123_10:1.1.1.1
	alpha123_9:1.1.1.1
	alpha123_8:1.1.1.1
	alpha123_7:1.1.1.1
	alpha123_6:1.1.1.1
	alpha123_5:1.1.1.1
	alpha123_4:1.1.1.1
	alpha123_3:1.1.1.1
	alpha123_2:1.1.1.1
	alpha123:1.1.1.1
	alpha122_48:1.1.1.1
	alpha122_47:1.1.1.1
	alpha122_46:1.1.1.1
	alpha122_45:1.1.1.1
	alpha122_44:1.1.1.1
	alpha122_43:1.1.1.1
	alpha122_42:1.1.1.1
	alpha122_41:1.1.1.1
	alpha122_40:1.1.1.1
	alpha122_39:1.1.1.1
	alpha122_38:1.1.1.1
	alpha122_37:1.1.1.1
	alpha122_36:1.1.1.1
	alpha122_35:1.1.1.1
	alpha122_34:1.1.1.1
	alpha122_33:1.1.1.1
	alpha122_32:1.1.1.1
	alpha122_31:1.1.1.1
	alpha122_30:1.1.1.1
	alpha122_29:1.1.1.1
	alpha122_28:1.1.1.1
	alpha122_27:1.1.1.1
	alpha122_26:1.1.1.1
	alpha122_25:1.1.1.1
	alpha122_24:1.1.1.1
	alpha122_23:1.1.1.1
	alpha122_22:1.1.1.1
	alpha122_21:1.1.1.1
	alpha122_20:1.1.1.1
	alpha122_19:1.1.1.1
	alpha122_18:1.1.1.1
	alpha122_17:1.1.1.1
	alpha122_16:1.1.1.1
	alpha122_15:1.1.1.1
	alpha122_14:1.1.1.1
	alpha122_13:1.1.1.1
	alpha122_12:1.1.1.1
	alpha122_11:1.1.1.1
	alpha122_10:1.1.1.1
	alpha122_9:1.1.1.1
	alpha122_8:1.1.1.1
	alpha122_6:1.1.1.1
	alpha122_5:1.1.1.1
	alpha122:1.1.1.1
	alpha212:1.1.1.1
	ALPHA212:1.1.1;
locks; strict;
comment	@c @;


1.1
date	96.03.14.12.42.12;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.14.12.42.13;	author flr;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@      SUBROUTINE QGJMMC( NJETS, CNAM, ICLASS, YCUT, EVIS, SCHEME, VERSN)
C----------------------------------------------------------------------
CKEY ALPHA JETS /INTERNAL
C
C   Author   : C. Bowdery     18-APR-1991 based on QJMMCL by P. Perez
C   Modified : C. Bowdery     28-APR-1991 add VERSN argument
C   Modified : C. Bowdery     18-OCT-1991 new name
C   Modified : C. Bowdery     24-OCT-1991 work bank index corrected
C   Modified : C. Bowdery     24-OCT-1991 remove call to SJMMCL
C   Modified : C. Bowdery      9-JUN-1994 allow 'JADE  ' and 'DURHAM'
C
C   Description
C   ===========
C!   Set up and call FJMMCL jet finding routine.
C!   Generalised version of QJMMCL with SCHEME and VERSN argument.
C
C  Input   : CNAM            name of jet particles to be created
C            ICLASS          KRECO or KMONTE
C            YCUT            YCUT value ( (M/EVIS)**2 )
C            EVIS            visible energy
C                            (if EVIS=0., it is computed from the
C                             input particle energies)
C            SCHEME          CHAR*2, combination scheme 'E ', 'E0', 'P '
C            VERSN           CHAR*6, 'NORMAL' aka 'JADE  ' or
C                                    'BETTER' aka 'DURHAM'
C
C  Output  : NJETS           number of jets found or error code if -ve
C
C======================================================================
#ifndef DOC
#include "qctbuf.h"
C
      REAL       RW
C
      INTEGER    K, LEN, LENTM, LENTP
C
      CHARACTER  CNAM*(*), SCHEME*2, VERSN*6
C
      COMMON / BCS / RW(1)
C
C-----------------------------------------------------------------------
      CALL CLTOU(VERSN)
      IF (INDEX(VERSN,'JADE').GT.0) THEN
        VERSN = 'NORMAL'
      ELSEIF (INDEX(VERSN,'DURHAM').GT.0) THEN
        VERSN = 'BETTER'
      ENDIF
C
C                           Set up /QCTBUF/ common
C
      CALL QJSETU( ICLASS )
C
C                           Protect FJMMCL against a zero length array
C
      IF( KTBI .LE. 0 ) THEN
        KTBO = -1
        GOTO 200
      ENDIF
C
C                           LENTM is the length in words of MASMAT array
C                           LENTP is the length in words of PP array
C
      K     = 0
      LENTM = KTBI*KTBI
      LENTP = KTBI*5
      LEN   = LENTM + LENTP
C
      CALL WBANK( RW, K, LEN, *100 )
C
C                           RW(K+1) is to be used as two REAL*4 arrays
C                                                   known as
C                                                MASMAT      PP
C
        CALL FJMMCL( YCUT, EVIS,  SCHEME, VERSN, RW(K+1), RW(K+1+LENTM),
     &               KTBI, QTBIX, QTBIY,  QTBIZ, QTBIE, KTBOMX,
     &               KTBO, QTBOX, QTBOY,  QTBOZ, QTBOE, KTBOF   )
C
        CALL WDROP( RW, K )
        GOTO 200
C
C                           Insufficient BOS storage
C
  100   KTBO = -99
        CALL QWMESE('_QGJMMC_ Insufficient BOS space for jet finding')
C
  200 NJETS = KTBO
      IF( CNAM .NE. ' ' )  THEN
        IDR = 0
        DO  1  IJET = NJETS, 1, -1
          CALL QJSAVE( CNAM, IJET, ICLASS, IDR, 0, 1 )
          IDR = 1
    1   CONTINUE
      ENDIF
C
      END
#endif
@


1.1.1.1
log
@import alpha122 from alws
@
text
@@
