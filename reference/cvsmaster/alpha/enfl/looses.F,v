head	1.1;
branch	1.1.1;
access;
symbols
	alpha126_22:1.1.1.1
	alpha126_21:1.1.1.1
	alpha126_20:1.1.1.1
	alpha126_19:1.1.1.1
	alpha126_18:1.1.1.1
	alpha126_17:1.1.1.1
	alpha126_16:1.1.1.1
	alpha126_15:1.1.1.1
	alpha126_14:1.1.1.1
	alpha126_13:1.1.1.1
	alpha126_12:1.1.1.1
	alpha126_11:1.1.1.1
	alpha126_10:1.1.1.1
	alpha126_09:1.1.1.1
	alpha126_08:1.1.1.1
	alpha126_07:1.1.1.1
	alpha126_06:1.1.1.1
	alpha126_05:1.1.1.1
	alpha126_04:1.1.1.1
	alpha126_03:1.1.1.1
	alpha126_02:1.1.1.1
	alpha126_1:1.1.1.1
	alpha125_17:1.1.1.1
	alpha125_16:1.1.1.1
	alpha125_15:1.1.1.1
	alpha125_14:1.1.1.1
	alpha125_13:1.1.1.1
	alpha125_12:1.1.1.1
	alpha125_11:1.1.1.1
	alpha125_10:1.1.1.1
	alpha125_09:1.1.1.1
	alpha125_08:1.1.1.1
	alpha125_07:1.1.1.1
	alpha125_06:1.1.1.1
	alpha125_05:1.1.1.1
	alpha125_04:1.1.1.1
	alpha125_03:1.1.1.1
	alpha125_02:1.1.1.1
	alpha125_01:1.1.1.1
	alpha124_19:1.1.1.1
	alpha125:1.1.1.1
	alpha124_18:1.1.1.1
	alpha124_17:1.1.1.1
	alpha124_16:1.1.1.1
	alpha124_15:1.1.1.1
	alpha124_14:1.1.1.1
	alpha124_13:1.1.1.1
	alpha124_12:1.1.1.1
	alpha124_11:1.1.1.1
	alpha124_10:1.1.1.1
	alpha124_09:1.1.1.1
	alpha124_08:1.1.1.1
	alpha124_07:1.1.1.1
	alpha124_7:1.1.1.1
	alpha124_06:1.1.1.1
	alpha124_05:1.1.1.1
	alpha124_04:1.1.1.1
	alpha124_03:1.1.1.1
	alpha124_02:1.1.1.1
	alpha124_01:1.1.1.1
	alpha124:1.1.1.1
	alpha123_12:1.1.1.1
	alpha123_11:1.1.1.1
	alpha123_10:1.1.1.1
	alpha123_9:1.1.1.1
	alpha123_8:1.1.1.1
	alpha123_7:1.1.1.1
	alpha123_6:1.1.1.1
	alpha123_5:1.1.1.1
	alpha123_4:1.1.1.1
	alpha123_3:1.1.1.1
	alpha123_2:1.1.1.1
	alpha123:1.1.1.1
	alpha122_48:1.1.1.1
	alpha122_47:1.1.1.1
	alpha122_46:1.1.1.1
	alpha122_45:1.1.1.1
	alpha122_44:1.1.1.1
	alpha122_43:1.1.1.1
	alpha122_42:1.1.1.1
	alpha122_41:1.1.1.1
	alpha122_40:1.1.1.1
	alpha122_39:1.1.1.1
	alpha122_38:1.1.1.1
	alpha122_37:1.1.1.1
	alpha122_36:1.1.1.1
	alpha122_35:1.1.1.1
	alpha122_34:1.1.1.1
	alpha122_33:1.1.1.1
	alpha122_32:1.1.1.1
	alpha122_31:1.1.1.1
	alpha122_30:1.1.1.1
	alpha122_29:1.1.1.1
	alpha122_28:1.1.1.1
	alpha122_27:1.1.1.1
	alpha122_26:1.1.1.1
	alpha122_25:1.1.1.1
	alpha122_24:1.1.1.1
	alpha122_23:1.1.1.1
	alpha122_22:1.1.1.1
	alpha122_21:1.1.1.1
	alpha122_20:1.1.1.1
	alpha122_19:1.1.1.1
	alpha122_18:1.1.1.1
	alpha122_17:1.1.1.1
	alpha122_16:1.1.1.1
	alpha122_15:1.1.1.1
	alpha122_14:1.1.1.1
	alpha122_13:1.1.1.1
	alpha122_12:1.1.1.1
	alpha122_11:1.1.1.1
	alpha122_10:1.1.1.1
	alpha122_9:1.1.1.1
	alpha122_8:1.1.1.1
	alpha122_6:1.1.1.1
	alpha122_5:1.1.1.1
	alpha122:1.1.1.1
	alpha212:1.1.1.1
	ALPHA212:1.1.1;
locks; strict;
comment	@c @;


1.1
date	96.03.14.12.42.30;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.14.12.42.31;	author flr;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@      SUBROUTINE LOOSES(ROUTIN,NCUT)
C----------------------------------------------------------------
C! Event counter
C
C  Francois Le Diberder -- 1985
C  Rewritten in Fortran 77 . Patrick Janot -- 18 Apr 1990
C----------------------------------------------------------------
#ifndef DOC
#include "bcs.h"
      PARAMETER ( maxrou = 50 , maxcut = 20 )
      CHARACTER*8 routin, rprint, subrou(maxrou)
      PARAMETER ( rprint = 'summary ')
      DIMENSION icheck(maxrou,maxcut)
      LOGICAL first
      DATA nrout/0/, first/.TRUE./
C----------------------------------------------------------------
      IF ( first ) THEN
        CALL vzero(icheck(1,1),maxrou*maxcut)
        first = .FALSE.
      ENDIF
C
C  Last call : cut summary
C
      IF ( routin .EQ. rprint ) THEN
C
        IF ( nrout .NE. 0) THEN
          WRITE (IW(6),2000)
          WRITE (IW(6),2001) ( subrou(irout),
     .                  ( icheck(irout,j),j=1,20), irout = 1 , nrout )
        ELSE
        ENDIF
C
C  Identifies the subroutine :
C
      ELSEIF ( ncut .GT. 0 .AND. ncut .LE. maxcut ) THEN
C
        krout = 0
        IF     ( nrout .LE. maxrou ) THEN
          DO 1 irout = 1 , nrout
            krout = irout
            IF ( routin .EQ. subrou(irout) ) GOTO 2
    1     CONTINUE
          nrout = nrout + 1
          IF ( nrout .GT. maxrou ) RETURN
          krout = nrout
          subrou(krout) = routin
        ELSE
          RETURN
        ENDIF
    2   CONTINUE
C
C  Update counters  :
C
        icheck(krout,ncut) = icheck(krout,ncut) + 1
C
      ENDIF
C
      RETURN
C---------------------------------------------------------------------
 2000 FORMAT(1x,'***** From LOOSES ***** : Cuts effects'/)
 2001 FORMAT(1x,'Subroutine: ',a8/
     * 1X,' !  1:',I6,' !  2:',I6,' !  3:',I6,' !  4:',I6,' !  5:',I6/
     * 1X,' !  6:',I6,' !  7:',I6,' !  8:',I6,' !  9:',I6,' ! 10:',I6/
     * 1X,' ! 11:',I6,' ! 12:',I6,' ! 13:',I6,' ! 14:',I6,' ! 15:',I6/
     * 1X,' ! 16:',I6,' ! 17:',I6,' ! 18:',I6,' ! 19:',I6,' ! 20:',I6)
      END
#endif
@


1.1.1.1
log
@import alpha122 from alws
@
text
@@
