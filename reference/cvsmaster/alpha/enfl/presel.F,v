head	1.2;
access;
symbols
	alpha126_22:1.2
	alpha126_21:1.2
	alpha126_20:1.2
	alpha126_19:1.2
	alpha126_18:1.2
	alpha126_17:1.2
	alpha126_16:1.2
	alpha126_15:1.2
	alpha126_14:1.2
	alpha126_13:1.2
	alpha126_12:1.2
	alpha126_11:1.2
	alpha126_10:1.2
	alpha126_09:1.2
	alpha126_08:1.2
	alpha126_07:1.2
	alpha126_06:1.2
	alpha126_05:1.2
	alpha126_04:1.2
	alpha126_03:1.2
	alpha126_02:1.2
	alpha126_1:1.2
	alpha125_17:1.2
	alpha125_16:1.2
	alpha125_15:1.2
	alpha125_14:1.2
	alpha125_13:1.2
	alpha125_12:1.2
	alpha125_11:1.2
	alpha125_10:1.2
	alpha125_09:1.2
	alpha125_08:1.2
	alpha125_07:1.2
	alpha125_06:1.2
	alpha125_05:1.2
	alpha125_04:1.2
	alpha125_03:1.2
	alpha125_02:1.2
	alpha125_01:1.2
	alpha124_19:1.2
	alpha125:1.2
	alpha124_18:1.2
	alpha124_17:1.2
	alpha124_16:1.2
	alpha124_15:1.2
	alpha124_14:1.2
	alpha124_13:1.2
	alpha124_12:1.2
	alpha124_11:1.2
	alpha124_10:1.2
	alpha124_09:1.2
	alpha124_08:1.2
	alpha124_07:1.2
	alpha124_7:1.2
	alpha124_06:1.2
	alpha124_05:1.2
	alpha124_04:1.2
	alpha124_03:1.2
	alpha124_02:1.2
	alpha124_01:1.2
	alpha124:1.2
	alpha123_12:1.2
	alpha123_11:1.2
	alpha123_10:1.2
	alpha123_9:1.2
	alpha123_8:1.2
	alpha123_7:1.2
	alpha123_6:1.2
	alpha123_5:1.2
	alpha123_4:1.2
	alpha123_3:1.2
	alpha123_2:1.2
	alpha123:1.2
	alpha122_48:1.2
	alpha122_47:1.2
	alpha122_46:1.2
	alpha122_45:1.2
	alpha122_44:1.2
	alpha122_43:1.2
	alpha122_42:1.2
	alpha122_41:1.2
	alpha122_40:1.2
	alpha122_39:1.2
	alpha122_38:1.2
	alpha122_37:1.2
	alpha122_36:1.2
	alpha122_35:1.2
	alpha122_34:1.2
	alpha122_33:1.2
	alpha122_32:1.2
	alpha122_31:1.2
	alpha122_30:1.2
	alpha122_29:1.2
	alpha122_28:1.2
	alpha122_27:1.2
	alpha122_26:1.2
	alpha122_25:1.2
	alpha122_24:1.2
	alpha122_23:1.2
	alpha122_22:1.2
	alpha122_21:1.2
	alpha122_20:1.2
	alpha122_19:1.2
	alpha122_18:1.2
	alpha122_17:1.2
	alpha122_16:1.2
	alpha122_15:1.2
	alpha122_14:1.2
	alpha122_13:1.2
	alpha122_12:1.2
	alpha122_11:1.2
	alpha122_10:1.2
	alpha122_9:1.2
	alpha122_8:1.2
	alpha122_6:1.2
	alpha122_5:1.2
	alpha122:1.1.1.1
	alpha212:1.1.1.1
	ALPHA212:1.1.1;
locks; strict;
comment	@c @;


1.2
date	96.06.27.10.49.36;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	96.03.14.12.42.31;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.14.12.42.32;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@alpha122_5 taken from alws
@
text
@      SUBROUTINE PRESEL(KEEP)
C-----------------------------------------------------------------------
C! Preselection (charged particles)
C
C  Patrick Janot -- 18 Apr 1990
C-----------------------------------------------------------------------
#ifndef DOC
#include "parcut.h"
#include "parabank.h"
#include "intval.h"
#include "qcde.h"
#include "qmacro.h"
C-----------------------------------------------------------------------
      ifrf0 = 0
      nafrf0 = namind('FRF0')
      IF ( nafrf0 .GT. 0 ) ifrf0 = IW(nafrf0)
C
      ifrf2 = nlink('FRFT',2)
C
      gdmult = 0.
      chatot = 0.
      chapo  = 0.
      chane  = 0.
      chene  = 0.
      nresca = 0
      CALL vzero(resfac(1),mxtrk)
      CALL vzero(itkres(1),mxtrk)
C-- Loop on charged particles
      DO 1 ich = kfcht , klcht
C -- More than 4 TPC points
        IF ( kfrtnt(ich) .LT. n0 ) CALL qltrk(ich)
C -- Don't count these bad tracks...
        IF ( xlock(ich) ) GOTO 1
C -- Set the momentum according to ECAL and TPC if energetic electron
        IF ( keidip(ich) .EQ. 1 .AND. keidif(ich) .EQ. 0 ) THEN
          IF ( qp(ich) .GT. 15. ) THEN
            pich = AMIN1(qp(ich),qelep/2.)
            eich = AMIN1(qeidec(ich),qelep/2.)
            sigmapt = pich**2*SQRT(1.-qct(ich)**2)
            IF ( ifrf2 .GT. 0 .AND. ifrf0 .LE. 0 ) THEN
              sigmapt = 6.0E-4 * sigmapt
            ELSE
              sigmapt = 1.0E-3 * sigmapt
            ENDIF
            sigmaec = .17*SQRT(eich) + .02*eich
            sigmatt = SQRT(sigmapt**2+sigmaec**2)
            sigmann = ABS(eich-pich)/sigmatt
            IF ( sigmann .LT. 3. ) THEN
              factor = (sigmapt**2*eich + sigmaec**2*pich)
     .               / (sigmapt**2      + sigmaec**2     )
              factor = factor/qp(ich)
              IF ( idbg .GE. 10 ) THEN
                WRITE (IW(6),*) 'Track ',ich,' rescaled by ',factor
                WRITE (IW(6),*) 'p,sigmap : ',qp(ich),sigmapt
                WRITE (IW(6),*) 'e,sigmae : ',qeidec(ich),sigmaec
                WRITE (IW(6),*) '# sigmas : ',sigmann
                WRITE (IW(6),*) '--------------------'
              ENDIF
              CALL qvscal(ich,factor)
              nresca = nresca + 1
              itkres(nresca) = ich
              resfac(nresca) = factor
            ENDIF
          ENDIF
        ENDIF
C -- Good tracks only - More stringent d0 for high momenta
C -- Also 1 ITC point -- or electron -- if high momentum
        IF ( ABS(qzb(ich)) .LT. z0 .AND. ABS(qdb(ich)) .LT. d0 .AND.
     .     ( qp(ich) .LE. 15. .OR. kfrtni(ich) .GE. 1 .OR.
     .       kfrtnt(ich) .GE. 8 .OR. keidip(ich) .EQ. 1 ) ) THEN
C -- Add up  ...
          CALL charad(ich)
          chene = chene + qe(ich)
        ELSE
          ichsam = ksame(ich)
   10     IF ( ichsam .EQ. ich ) GOTO 20
          IF ( ichsam .GE. kfdct .AND. ichsam .LE. kldct ) GOTO 1
          ichsam = ksame(ichsam)
          GOTO 10
   20     CALL qltrk(ich)
        ENDIF
    1 CONTINUE
C
C -- Preselection cuts
C
      keep = 0
      IF ( idbg .GE. 1 ) CALL looses('PRESEL  ',1)
C
      IF ( gdmult  .LT.  ntrack .OR.
     .     gdmult  .GT.  mtrack ) GOTO 999
      IF ( idbg .GE. 1 ) CALL looses('PRESEL  ',2)
C
      IF ( chene .LT. echmin )    GOTO 999
      IF ( idbg .GE. 1 ) CALL looses('PRESEL  ',3)
C
      IF ( chene .GT. echmax ) THEN
        WRITE(IW(6),*) ' Run/Event : ',krun,kevt
        WRITE(IW(6),*) ' ENFLW Warning: Charged energy = ',chene,' GeV'
      ENDIF
      IF ( idbg .GE. 1 ) CALL looses('PRESEL  ',4)
C
      keep = 1
C
 999  RETURN
      END
#endif
@


1.1
log
@Initial revision
@
text
@d96 4
a99 1
      IF ( chene .GT. echmax ) GOTO 999
@


1.1.1.1
log
@import alpha122 from alws
@
text
@@
