head	1.1;
branch	1.1.1;
access;
symbols
	alpha126_22:1.1.1.1
	alpha126_21:1.1.1.1
	alpha126_20:1.1.1.1
	alpha126_19:1.1.1.1
	alpha126_18:1.1.1.1
	alpha126_17:1.1.1.1
	alpha126_16:1.1.1.1
	alpha126_15:1.1.1.1
	alpha126_14:1.1.1.1
	alpha126_13:1.1.1.1
	alpha126_12:1.1.1.1
	alpha126_11:1.1.1.1
	alpha126_10:1.1.1.1
	alpha126_09:1.1.1.1
	alpha126_08:1.1.1.1
	alpha126_07:1.1.1.1
	alpha126_06:1.1.1.1
	alpha126_05:1.1.1.1
	alpha126_04:1.1.1.1
	alpha126_03:1.1.1.1
	alpha126_02:1.1.1.1
	alpha126_1:1.1.1.1
	alpha125_17:1.1.1.1
	alpha125_16:1.1.1.1
	alpha125_15:1.1.1.1
	alpha125_14:1.1.1.1
	alpha125_13:1.1.1.1
	alpha125_12:1.1.1.1
	alpha125_11:1.1.1.1
	alpha125_10:1.1.1.1
	alpha125_09:1.1.1.1
	alpha125_08:1.1.1.1
	alpha125_07:1.1.1.1
	alpha125_06:1.1.1.1
	alpha125_05:1.1.1.1
	alpha125_04:1.1.1.1
	alpha125_03:1.1.1.1
	alpha125_02:1.1.1.1
	alpha125_01:1.1.1.1
	alpha124_19:1.1.1.1
	alpha125:1.1.1.1
	alpha124_18:1.1.1.1
	alpha124_17:1.1.1.1
	alpha124_16:1.1.1.1
	alpha124_15:1.1.1.1
	alpha124_14:1.1.1.1
	alpha124_13:1.1.1.1
	alpha124_12:1.1.1.1
	alpha124_11:1.1.1.1
	alpha124_10:1.1.1.1
	alpha124_09:1.1.1.1
	alpha124_08:1.1.1.1
	alpha124_07:1.1.1.1
	alpha124_7:1.1.1.1
	alpha124_06:1.1.1.1
	alpha124_05:1.1.1.1
	alpha124_04:1.1.1.1
	alpha124_03:1.1.1.1
	alpha124_02:1.1.1.1
	alpha124_01:1.1.1.1
	alpha124:1.1.1.1
	alpha123_12:1.1.1.1
	alpha123_11:1.1.1.1
	alpha123_10:1.1.1.1
	alpha123_9:1.1.1.1
	alpha123_8:1.1.1.1
	alpha123_7:1.1.1.1
	alpha123_6:1.1.1.1
	alpha123_5:1.1.1.1
	alpha123_4:1.1.1.1
	alpha123_3:1.1.1.1
	alpha123_2:1.1.1.1
	alpha123:1.1.1.1
	alpha122_48:1.1.1.1
	alpha122_47:1.1.1.1
	alpha122_46:1.1.1.1
	alpha122_45:1.1.1.1
	alpha122_44:1.1.1.1
	alpha122_43:1.1.1.1
	alpha122_42:1.1.1.1
	alpha122_41:1.1.1.1
	alpha122_40:1.1.1.1
	alpha122_39:1.1.1.1
	alpha122_38:1.1.1.1
	alpha122_37:1.1.1.1
	alpha122_36:1.1.1.1
	alpha122_35:1.1.1.1
	alpha122_34:1.1.1.1
	alpha122_33:1.1.1.1
	alpha122_32:1.1.1.1
	alpha122_31:1.1.1.1
	alpha122_30:1.1.1.1
	alpha122_29:1.1.1.1
	alpha122_28:1.1.1.1
	alpha122_27:1.1.1.1
	alpha122_26:1.1.1.1
	alpha122_25:1.1.1.1
	alpha122_24:1.1.1.1
	alpha122_23:1.1.1.1
	alpha122_22:1.1.1.1
	alpha122_21:1.1.1.1
	alpha122_20:1.1.1.1
	alpha122_19:1.1.1.1
	alpha122_18:1.1.1.1
	alpha122_17:1.1.1.1
	alpha122_16:1.1.1.1
	alpha122_15:1.1.1.1
	alpha122_14:1.1.1.1
	alpha122_13:1.1.1.1
	alpha122_12:1.1.1.1
	alpha122_11:1.1.1.1
	alpha122_10:1.1.1.1
	alpha122_9:1.1.1.1
	alpha122_8:1.1.1.1
	alpha122_6:1.1.1.1
	alpha122_5:1.1.1.1
	alpha122:1.1.1.1
	alpha212:1.1.1.1
	ALPHA212:1.1.1;
locks; strict;
comment	@c @;


1.1
date	96.03.14.12.42.34;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.03.14.12.42.35;	author flr;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@      SUBROUTINE BTAGEV (NTRACK,NJET,JJET,JHEMI,PTRACK,NEGPROB,
     >                   PROBJET,PROBHEMI,PROBEVT)
CKEY   QIPBTAG / INTERNAL
C-----------------------------------------------------------------------
C! Probability for a jet to come from a b-quark
C  Called from QIPBTAG
C  SUBROUTINE BTAGEV
C  =================
C     PURPOSE :
C             calculate the probability of a jet to have the origine
C             in a B-Quark from the probabilities of the tracks
C
C     INPUT :
C             NTRACK               Number of good tracks
C             NJET                 Number of good jets
C             PTRACK(1:ntrack)     array with track-probabilities
C             JJET(1:ntrack)       Assignment of tracks to jets
C             JHEMI(1:ntrack)      Assignment of tracks to hemispheres
C             NEGPROB              Flag whether to use negative tracks
C
C     OUTPUT :
C             PROBJET(1:njet)      probability for each jet
C             PROBHEMI(1:2)        probability for hemispheres
C             PROBEVT              probability for event
C
C     CALLS   : VZERO
C                                      D. Brown,  M.Frank 13/1/92
C          revisions
C             D. BROWN 19-1-92       Add JJET,JHEMI,PWIND,PCUT  as arguments
C                      11-2-92       Protect factorials
C             M. FRANK 23-3-92       Protect exponentials
C             D. Brown 14-10-92      Protect agains underflows
C             D. Rousseau 7-5-93     Implement negative track probabilities
C             I. Tomalin  17-1-96    Protect against PROBEVT = 0 etc.
C-----------------------------------------------------------------------
#ifndef DOC
      IMPLICIT NONE
      SAVE       FIRST,LOGFAC
C  I/O variables
      INTEGER    NTRACK
      INTEGER    JJET(*),JHEMI(*)
      REAL       PROBEVT,PROBHEMI(2),PROBJET(*),PTRACK(*)
C--   local variables :
#include "maxtrk.h"
      INTEGER    MAXFAC
      PARAMETER ( MAXFAC = MAXTRK )
      INTEGER    IJET,ITRK,IHEMI,IFAC
      INTEGER    NTRK,NJET
      INTEGER    NTRK_HEMI(2)
      INTEGER    NTRK_JET(MAXJET)
      REAL*8     SUMEVT,SUMHEMI(2),SUMJET(MAXJET)
      REAL*8     LOGFAC(0:MAXFAC),LOGINVLOG,PROB,LOGPROB
      REAL*8     MINLOG
      LOGICAL    FIRST,NEGPROB,GOOD
      DATA       FIRST /.TRUE./,MINLOG/-50.0D0/
C-----------------------------------------------------------------------
C-- First time, setup factorial array.  We take the LOG of the factorials
C  to avoid overflow problems
C
      IF ( FIRST ) THEN
        FIRST = .FALSE.
        LOGFAC(0) = 0D0
        DO IFAC=1,MAXFAC
          LOGFAC(IFAC) = LOGFAC(IFAC-1) + LOG(FLOAT(IFAC))
        END DO
      END IF
C
C  Initialize variables
C
      NTRK=0
      CALL VZERO(NTRK_JET,NJET)
      CALL VZERO(NTRK_HEMI,2)
      SUMEVT = 0D0
      DO IHEMI=1,2
        SUMHEMI(IHEMI) = 0D0
      END DO
      DO IJET=1,NJET
        SUMJET(IJET) = 0D0
      END DO
C
C  Now compute probability products
C
      DO ITRK=1,MIN(NTRACK,MAXTRK)
C
C  Compute the sum of the log of the probability for all tracks.
C
        GOOD = NEGPROB .OR. PTRACK(ITRK).GT.0E0
        IF(NEGPROB)THEN
          IF ( PTRACK(ITRK).GT.0E0 ) THEN
            LOGPROB          = LOG(PTRACK(ITRK)/2.)
          ELSE
            LOGPROB          = LOG(1.+PTRACK(ITRK)/2.)
          END IF
        ELSE
          IF ( PTRACK(ITRK).GT.0E0 ) THEN
            LOGPROB          = LOG(PTRACK(ITRK))
          END IF
        END IF
        IF(GOOD)THEN
          IJET             = JJET(ITRK)
          IHEMI            = JHEMI(ITRK)
          SUMEVT           = SUMEVT + LOGPROB
          SUMHEMI(IHEMI)   = SUMHEMI(IHEMI) + LOGPROB
          SUMJET(IJET)     = SUMJET(IJET) + LOGPROB
          NTRK             = NTRK + 1
          NTRK_HEMI(IHEMI) = NTRK_HEMI(IHEMI) + 1
          NTRK_JET(IJET)   = NTRK_JET(IJET) + 1
        END IF
      END DO
C
C  Normalize the probability product for the number of measurements made.
C  The normalization factor comes from interpreting the OVERALL probability
C  to be less than or equal to the observed value.  The trick here of looking
C  at the log of all the components and then taking the exponential avoids
C  floating overflows in cases where the number of tracks becomes very
C  large.
C
C  Events
C
      IF (SUMEVT.LT.0D0) THEN
        IF ( (NTRK-1) .GE. 1 ) THEN
            LOGINVLOG = LOG(-SUMEVT)
        END IF
        PROB    = 1D0
        DO ITRK = 1 , NTRK-1
          PROB  = PROB + EXP(ITRK*LOGINVLOG - LOGFAC(ITRK))
        END DO
        LOGPROB = LOG(PROB)
        PROBEVT = MIN(EXP(MAX(LOGPROB+SUMEVT,MINLOG)),1D0)
      ELSE
C Protection.
        PROBEVT = 1.0
      END IF
C
C  Hemispheres
C
      DO IHEMI=1,2
        IF (SUMHEMI(IHEMI).LT.0D0) THEN
          IF ( (NTRK_HEMI(IHEMI)-1) .GE. 1 ) THEN
              LOGINVLOG = LOG(-SUMHEMI(IHEMI))
          END IF
          PROB    = 1D0
          DO ITRK = 1,NTRK_HEMI(IHEMI) - 1
            PROB  = PROB + EXP(ITRK*LOGINVLOG - LOGFAC(ITRK))
          END DO
          LOGPROB = LOG(PROB)
          PROBHEMI(IHEMI) = MIN(EXP(MAX(LOGPROB+SUMHEMI(IHEMI),
     &         MINLOG)),1D0)
        ELSE
C Protection.
          PROBHEMI(IHEMI) = 1.0
        END IF
      END DO
C
C  Jets
C
      DO IJET=1,NJET
        IF (SUMJET(IJET).LT.0D0) THEN
          IF ( (NTRK_JET(IJET)-1) .GE. 1 ) THEN
              LOGINVLOG = LOG(-SUMJET(IJET))
          END IF
          PROB    = 1D0
          DO ITRK = 1,NTRK_JET(IJET)-1
            PROB  = PROB + EXP( ITRK*LOGINVLOG - LOGFAC(ITRK) )
          END DO
          LOGPROB = LOG(PROB)
          PROBJET(IJET) = MIN(EXP(MAX(LOGPROB+SUMJET(IJET),MINLOG)),1D0)
        ELSE
C Protection.
          PROBJET(IJET) = 1.0
        END IF
      END DO
C  done
      RETURN
      END
#endif
@


1.1.1.1
log
@import alpha122 from alws
@
text
@@
