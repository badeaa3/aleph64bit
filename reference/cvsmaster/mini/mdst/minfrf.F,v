head	1.1;
branch	1.1.1;
access;
symbols
	mini202_9:1.1.1.1
	mini202_8:1.1.1.1
	mini202_7:1.1.1.1
	mini202_6:1.1.1.1
	mini202_5:1.1.1.1
	mini202_4:1.1.1.1
	mini202_2:1.1.1.1
	mini202_1:1.1.1.1
	mini202:1.1.1.1
	mini201_1:1.1.1.1
	mini104_1:1.1.1.1
	mini103_1:1.1.1.1
	mini102_7:1.1.1.1
	mini102_5:1.1.1.1
	mini102_4:1.1.1.1
	mini102_3:1.1.1.1
	mini102_2:1.1.1.1
	mini102_1:1.1.1.1
	mini102:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.1
date	96.08.15.11.09.40;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.15.11.09.41;	author flr;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@      SUBROUTINE MINFRF
C
CKEY MDST /USER
C-----------------------------------------------------------------------
C! Fill FRFT bank from DTRA.
C
C     Author: Stephen Haywood      03-Apr-90
C-----------------------------------------------------------------------
#ifndef DOC
C
#include "bcs.h"
#include "alcons.h"
#include "dtrajj.h"
#include "frftjj.h"
      PARAMETER (CFACT=CLGHT/100000.)
#include "minfac.h"
      COMMON / SCALMO / ISCP93,SCPF93
C
      LOGICAL FIRST,NOEM,NEWEM
      DIMENSION CMPK(15),INDXE(5),INDXA(10)
      SAVE INDXE,INDXA,C1,HC2,UNDFL,FIRST,NOEM
      DATA INDXE / 1,  3,    6,      10,            15 /
      DATA INDXA /   2,  4,5,  7,8,9,   11,12,13,14    /
      DATA C1,HC2, UNDFL / 0.1,2500., -20. /
      DATA FIRST,NOEM / .TRUE.,.TRUE. /
      DATA EPSIL  / 0.000001 /
C
#include "bmacro.h"
C
C++   Statement function used to ensure minimum entry for track errors.
C++   Zero errors must be avoided when the error matrix is inverted.
C++   Likewise, correlation coefficients of +1 or -1 give singularities.
C
      ETABL(ID,NRBOS,L) = AMAX1(FLOAT(ITABL(ID,NRBOS,L)),0.5)
      CTABL(ID,NRBOS,L) = AMIN1(AMAX1(FLOAT(ITABL(ID,NRBOS,L)),-99.5),
     &  99.5)
C
C++  Determine whether should fill error-matrix.
C
      IF(FIRST) THEN
         IF(NLINK('NOEM',0).GT.0) THEN
            NOEM = .TRUE.
         ELSE
            NOEM = .FALSE.
         ENDIF
         FIRST = .FALSE.
      ENDIF
C
C++   Determine the bank number (not from DTRA/100).
C
      KDTRA = IW(NAMIND('DTRA'))
      NR = IW(KDTRA-2)
      IF (NR.EQ.3) NR = 0
C
C++   Pick up links.
C
      KDTRA = NLINK('DTRA',100)
      IF (KDTRA.LE.0) THEN
         CALL MINUPD('DTRA')
         KDTRA = NLINK('DTRA',100)
         IF (KDTRA.LE.0) RETURN
      ENDIF
C
C++   Determine whether we have the old or new style error matrix.
C
      IF(MINGTV(DUM).GE.61) THEN
         NEWEM = .TRUE.
      ELSE
         NEWEM = .FALSE.
      ENDIF
C
C++   Create FRFT bank.
C
      NFRFT = LROWS(KDTRA)
      IF(NFRFT.LE.0) RETURN
      LEN = LMHLEN + LFRFTA * NFRFT
      CALL AUBOS('FRFT',NR,LEN, KFRFT,IGARB)
      CALL BLIST(IW,'S+','FRFT')
      IF(IGARB.GE.2) THEN
         RETURN
      ELSE IF(IGARB.NE.0) THEN
         KDTRA = NLINK('DTRA',100)
      ENDIF
      IW(KFRFT+LMHCOL) = LFRFTA
      IW(KFRFT+LMHROW) = NFRFT
C
C++   Get the magnetic field - use ALEPHLIB routine.
C++   The -ve sign corresponds to the definition of 1/R.
C++   To obtain momenta, this is multiplied by speed of light.
C
      BFACT = - ALFIEL(DUMMY) * CFACT
      IF(BFACT.EQ.0.) BFACT = - 15. * CFACT
C
C++   Fill FRFT bank.
C
      DO 100 I=1,NFRFT
         P = FLOAT(ITABL(KDTRA,I,JDTRP0)) / EFACTM
         IF (ABS(P).LT.EPSIL)  P = EPSIL
         THETA = FLOAT(ITABL(KDTRA,I,JDTRTH)) / AFACTM
         SECL = 1. / SIN(THETA)
         TANL = TAN( PIBY2-THETA )
         RHO = BFACT * SECL / (FLOAT(ITABL(KDTRA,I,JDTRCH)) * P)
C Scale track curvature for 1993 MINIs written with wrong BFIELD :
         IF (ISCP93.EQ.1) RHO = RHO/SCPF93
         RW(KROW(KFRFT,I)+JFRFIR) = RHO
         RW(KROW(KFRFT,I)+JFRFTL) = TANL
         RW(KROW(KFRFT,I)+JFRFP0) = FLOAT(ITABL(KDTRA,I,JDTRPH))/AFACTM
         RW(KROW(KFRFT,I)+JFRFD0) = FLOAT(ITABL(KDTRA,I,JDTRD0))/DFACTM
         RW(KROW(KFRFT,I)+JFRFZ0) = FLOAT(ITABL(KDTRA,I,JDTRZ0))/DFACTM
C
C++      Old form of error matrix.
C
         IF(.NOT.NEWEM .AND. .NOT.NOEM) THEN
         SQR = ( ETABL(KDTRA,I,JDTRER+0)/EFACTM /P )**2
     &       - ( ETABL(KDTRA,I,JDTRER+1)/AFACTM *TANL )**2
         IF(SQR.LT.0.) SQR = 0.
         EM00 = SQR * RHO**2
         EM02 = ( SECL**2*ETABL(KDTRA,I,JDTRER+1)/AFACTM )**2
         EM05 = ( ETABL(KDTRA,I,JDTRER+2)/AFACTM )**2
         EM09 = ( ETABL(KDTRA,I,JDTRER+3)/DFACTM )**2
         EM14 = ( ETABL(KDTRA,I,JDTRER+4)/DFACTM )**2
         EM03 = CTABL(KDTRA,I,JDTREA+0)/100. * SQRT(EM00 * EM05)
         EM06 = CTABL(KDTRA,I,JDTREA+1)/100. * SQRT(EM00 * EM09)
         EM08 = CTABL(KDTRA,I,JDTREA+2)/100. * SQRT(EM05 * EM09)
         EM11 = CTABL(KDTRA,I,JDTREA+3)/100. * SQRT(EM02 * EM14)
         RW(KROW(KFRFT,I)+JFRFEM+ 0) = EM00
         RW(KROW(KFRFT,I)+JFRFEM+ 2) = EM02
         RW(KROW(KFRFT,I)+JFRFEM+ 5) = EM05
         RW(KROW(KFRFT,I)+JFRFEM+ 9) = EM09
         RW(KROW(KFRFT,I)+JFRFEM+14) = EM14
         RW(KROW(KFRFT,I)+JFRFEM+ 3) = EM03
         RW(KROW(KFRFT,I)+JFRFEM+ 6) = EM06
         RW(KROW(KFRFT,I)+JFRFEM+ 8) = EM08
         RW(KROW(KFRFT,I)+JFRFEM+11) = EM11
         ENDIF
C
C++      New form of error matrix.
C
         IF(NEWEM .AND. .NOT.NOEM) THEN
            DO J=1,5
               IEVAL = ITABL(KDTRA,I,JDTRER+J-1)
               ARG = AMIN1(AMAX1(FLOAT(IEVAL)*C1,-40.),+40.)
               CMPK(INDXE(J)) = EXP(ARG)
            ENDDO
            DO J=1,10
               IANGL = ITABL(KDTRA,I,JDTREA+J-1)
               CMPK(INDXA(J)) = (FLOAT(IANGL)-HC2) / HC2
            ENDDO
            KADDR = KROW(KFRFT,I) + JFRFEM
            CALL FUPKCM(CMPK,RW(KADDR))
         ENDIF
C
C++      Fill the chi-squared.
C++      We have the Chisq/DoF, so we have to estimate DoF.
C++      This may be wrong, but when Chisq/DoF is reobtained, it will
C++      be correct.
C++      The recipe used is to assume that TPC and Vdet contribute 2
C++      per hit to DoF, while ITC only contributes 1.
C++      There are 5 constraints, except for ITC only, when there are 3.
C++      This may differ slightly from actual DoF from Kalmen Filter.
C
         IH = ITABL(KDTRA,I,JDTRHO)
         IF (NR.EQ.2) THEN
            NMVD = MINHIT(IH,1)
         ELSE
            NMVD = 0
         ENDIF
         NITC = MINHIT(IH,2)
         NTPC = MINHIT(IH,3)
         NCONS = 5
         IF(NMVD+NTPC.EQ.0) NCONS = 3
         NDEG = 2*NMVD + NITC + 2*NTPC - NCONS
         CHIN = FLOAT(ITABL(KDTRA,I,JDTRTF)) / 10.
         RW(KROW(KFRFT,I)+JFRFC2) = FLOAT(NDEG) * CHIN
         IW(KROW(KFRFT,I)+JFRFDF) = NDEG
  100 CONTINUE
C
      RETURN
      END
#endif
@


1.1.1.1
log
@1st release of mini under cvs
@
text
@@
