head	1.2;
access;
symbols
	look25:1.2
	look24:1.2
	look23:1.2
	look22:1.2
	look21:1.2
	look20:1.2
	v15:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.2
date	96.04.18.09.05.41;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.09.15.50.23;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.09.15.50.24;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@change VAX to DEC.AND..NOT.UNIX ==> version 20

 Modified Files:
 	lkevt.h lkfil.h lklast.h lkunpk.h version.h
 Removed Files:
	lookend.h
@
text
@      SUBROUTINE LKGTEVT(FSEQ,LIST,ULIST,NRUN,NEVT,IER )
C----------------------------------------------------------------------
C - F.Ranjard - 911015
CKEY LOOK READ EVENT / USER
C
C!  read selected event from sequential or direct access file
C   Only event records are returned, all others  are skipped.
C
C   Inputs    :
C               FSEQ     .TRUE. when runs are in increasing order
C               LIST     list of bank names
C               ULIST    character string to steer unpacking
C                        Definition see in AUNPCK.
C               NRUN     run number   ( =0 means ignore run number   )
C               NEVT     event number ( =0 means ignore event number )
C                        ( NRUN=NEVT=0 means read next event, or read
C                          next slow control record if class 25 is on)
C
C   Outputs   : IER = 1  event record found
C                   = 0  event NOT found
C                   = 5  EOF
C
C   Calls:      ABRREC,BDROP,BGARB
C   Entry points:
C               LKGTEVR (ITYP)
C               returns in ITYP the ABRREC return code
C----------------------------------------------------------------------
#ifndef DOC
#include "bcs.h"
#include "lkfil.h"
      SAVE IABRREC
      LOGICAL FSEQ, BTEST
      CHARACTER*(*) LIST,ULIST
      LOGICAL FIRST
      DATA FIRST/.TRUE./
C----------------------------------------------------------------------

      IF(FIRST) THEN
        FIRST=.FALSE.
        NASEVT=NAMIND('SEVT')
        NASRUN=NAMIND('SRUN')
      ENDIF

      IER=0

C                      SELECT EVENT
C                     WITH RUN AND EVENT #

      IF(NEVT.NE.0) THEN
        IF(IW(NASRUN).NE.0) CALL BDROP(IW,'SRUN')
        KSEVT=IW(NASEVT)
        IF(KSEVT.LE.0) KSEVT=NBANK('SEVT',0,2)
        IW(KSEVT+1)=NRUN
        IW(KSEVT+2)=NEVT
        LASRUN = NRUN
        LASEVT = NEVT
      ENDIF
C                SELECT RUN ONLY
      IF(NEVT.EQ.0.AND.NRUN.NE.0) THEN
        IF(IW(NASEVT).NE.0) CALL BDROP(IW,'SEVT')
        KSRUN=IW(NASRUN)
        IF(KSRUN.LE.0) KSRUN=NBANK('SRUN',0,1)
        IW(KSRUN+1)=NRUN
        LASRUN = NRUN
        LASEVT = 999999
      ENDIF
C                NO SELECTION, READ NEXT EVENT
      IF(NEVT.EQ.0.AND.NRUN.EQ.0) THEN
        IF(IW(NASEVT).NE.0) CALL BDROP(IW,'SEVT')
        IF(IW(NASRUN).NE.0) CALL BDROP(IW,'SRUN')
        LASRUN = 999999
        LASEVT = 999999
      ENDIF
      IF (.NOT.FSEQ) LASRUN = 999999
      CALL ABSMAX (LASRUN,LASEVT)
C
  1   CALL ABRREC (LIST,ULIST,IRET)
      IABRREC = IRET
C                accept event records only
      IF(IRET.GE.4) GOTO 999
      IF(IRET.EQ.2) THEN
C      run record : it has been put on C-list by ABRREC
C                   look forward to the event required if any
         GOTO 1
      ELSEIF(IRET.EQ.3) THEN
C      unknown record: skip it if an event is required
        IF (NEVT.GT.0 .OR. NRUN.GT.0) GOTO 1
      ELSEIF(IRET.EQ.1) THEN
C      event record: skip it if slow control is required
C      and NO EDIR.
        IF (LINSEL.EQ.0 .AND. NEVT.EQ.0 .AND. NRUN.EQ.0) THEN
           CALL ABGTRCL (MASKR)
           IF (BTEST(MASKR,24)) GOTO 1
        ENDIF
      ENDIF
C
      CALL BDROP (IW,'SRUNSEVT')
      RETURN
  999 IER= IRET
      CALL BDROP (IW,'SRUNSEVT')
      RETURN
C
C ------------------------------------------------------------
C
      ENTRY LKGTEVR (ITYP)
      ITYP = IABRREC
C
      END
#endif
@


1.1
log
@Initial revision
@
text
@a0 1
*DK lkgtevt
d24 3
d31 1
d78 1
d102 6
@


1.1.1.1
log
@import look 15
@
text
@@
