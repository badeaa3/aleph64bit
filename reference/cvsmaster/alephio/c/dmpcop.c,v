head	1.2;
access;
symbols
	alio83:1.2
	alio82:1.2
	alio81:1.2
	alio80:1.2
	alio74:1.2
	alio73:1.2
	alio72:1.2
	alio71:1.2
	alio70:1.2
	alio68:1.2
	alio69:1.2
	alio67:1.2
	alio66:1.2
	alio65:1.2
	alio64:1.2
	alio63:1.2
	alio62:1.2
	alio61:1.2
	alio60:1.2
	c212:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	96.05.03.14.41.53;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	96.04.23.09.53.52;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.04.23.09.53.53;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@replace flag ${VENDOR} with ALEPH_${VENDOR}
Modified Files:
 	ainqui.F algtenv.F aopen.F aopenw.F aoperd.F aoptap.F astage.F
 	awrtap.F
 	cmpbu3.c cmpbu4.c cmpbu5.c dmpbl3.c dmpbl4.c dmpbl5.c dmpcop.c
 	extzv.c insv.c
@
text
@#if defined(ALEPH_DEC) && defined(MACRO)
        .TITLE  DMPCOP
        .IDENT  /1.0/
        .PSECT  COPY
;-----------------------------------------------------------------------
;       SUBROUTINE DMPCOP(A,B,NCOL,NROW)
;C!     Copies NROW values from array A into B
;CKEY PRESS DMPCOP /INTERNAL
;       AUTHOR:   D.Harvatis   MAY 1989
;
;       A(1) is copied into B(1)
;       A(2) into B(1+NCOL)
;       ...................
;       A(n) into B(1+(n-1)*NCOL)
;-----------------------------------------------------------------------
#ifndef DOC
        .ENTRY  DMPCOP,^M<IV,R2,R3,R4>
        MOVL    B^4(AP), R3             ; R3 contains address of A array
        MOVL    B^8(AP), R4             ; R4 contains address of B array
        MOVL    @@B^12(AP), R1           ; store NCOL in R1
        MOVL    @@B^16(AP), R0           ; store NROW in R0
        CLRL    R2                      ; R2 = 0
LOOPC:  MOVL    (R3)+, (R4)[R2]         ; B(R2)=A(i) , i=i+1
        ADDL2   R1, R2                  ; R2=R2+NCOL
        DECL    R0                      ; decrease R0
        BNEQ    LOOPC                   ; if R0<>0 continue
        RET
        .END
#endif
#endif
#if defined(ALEPH_C)

/* DMPCOP(A,B,NCOL,NROW) */

#include "cfromf.h"

#define WORDLENGTH 32

FORT_CALL(dmpcop) (a,b,nc,nr)

int a[];
int b[];
int *nr;
int *nc;

{

   int ib;
   int ia;
   int nrow;

         ib = 0;
         ia = 0;
         nrow = *nr;
loopc:   b[ib] = a[ia++];
         ib = ib + *nc;
         nrow--;
         if (nrow == 0) return;
         goto loopc;

}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#if defined(DEC) && defined(MACRO)
d31 1
a31 1
#if defined(C)
@


1.1.1.1
log
@import alephio/c
@
text
@@
