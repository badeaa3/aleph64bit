head	1.1;
access;
symbols
	alio83:1.1
	alio82:1.1
	alio81:1.1
	alio80:1.1
	alio74:1.1
	alio73:1.1
	alio72:1.1
	alio71:1.1
	alio70:1.1
	alio68:1.1
	alio69:1.1
	alio67:1.1
	alio66:1.1
	alio65:1.1
	alio64:1.1
	alio63:1.1
	alio62:1.1
	alio61:1.1
	alio60:1.1;
locks; strict;
comment	@c @;


1.1
date	96.04.23.09.59.19;	author flr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@move alph, dbas, a part of alef and a part of c to alephio
Modified Files:
 	version.h
 Added Files:
 	adbrow.F adbrpn.F adbrun.F adbswp.F adbver.F agetdb.F agtfil.F
	albos.F aldawr.F aldtyp.F aleveh.F alfind.F alfmt.F algtbk.F
 	algtdb.F algtlu.F algtro.F algtyp.F alinst.F alk7fil.F
 	alk7fru.F alk7op.F alk7tru.F alredb.F alrune.F alrunh.F
 	alrunr.F alseed.F alstho.F alstin.F alstri.F altabl.F alvsn.F
 	aopdbs.F aublis.F aubos.F aubprs.F bkcari.F bkinca.F bkrhab.F
 	bkrhal.F bkrhaw.F bktobk.F cafiht.F chahol.F dafrds.F gtdbas.F
 	gtstup.F igtfmt.F jhocha.F julrec.F junial.F junidb.F
 	kbytrec.F loctab.F nameru.F ubpack.F uclean.F uindxs.F usbos.F
 	usgtdb.F utcblk.F utccop.F utcofo.F utwocl.F utwoex.F
Removed Files:
	noibm.F
@
text
@      INTEGER FUNCTION ALGTBK (NAME,NR,NEW,JCOL,MXROW,LNAMEA,IROW)
C --------------------------------------------------------------
C! create/ get a bank
C - F.Ranjard - 900517
CKEY ALEF GET BANK DA
C
C - Input:    NAME   / A4    = bank name
C             NR     / INTE  = bank number
C             NEW    / INTE  = row address
C             JCOL   / INTE  = col. number to be considered
C             MXROW  / INTE  = max. number of rows
C             LNAMEA / INTE  = number of columns
C
C - Output:   ALGTBK / INTE  = NAME BOS index
C                              =0 means not enough space
C                              <0 means a garbage collection occurded
C             IROW   / INTE  = row # for the known NEW
C                              0 means NEW does not exist
C                              <0 NEW should go in the middle
C
C ----------------------------------------------------------------
#ifndef DOC
      CHARACTER*(*) NAME
#include "bcs.h"
#include "bmacro.h"
C ----------------------------------------------------------------
C
C - 1st entry
C
      NNAME = NAMIND(NAME)
      LDBAS = JUNIDB(0)
      IGARB = 0
C
C - get NAME bank
C
      JNAME = IW(NNAME)
      IF (JNAME.EQ.0) THEN
C     get NAME from the data base if any
         NRUN = NDANR (LDBAS,NAME,'LE',NR)
         IF (NRUN.NE.0) THEN
            JNAME = MDARD (IW,LDBAS,NAME,NRUN)
            IF (JNAME.EQ.0) THEN
               IGARB=1
               CALL BGARB(IW)
               JNAME = MDARD (IW,LDBAS,NAME,NRUN)
               IF (JNAME.EQ.0) GOTO 60
            ENDIF
         ENDIF
      ENDIF
C
C - is it a new row or an update
C
      ISORT = 0
      IF (JNAME.GT.0) THEN
         LC = LCOLS(JNAME)
         LR = LROWS(JNAME)
         IROW = LOCTAB (IW(JNAME+LMHLEN+1),LC,LR,JCOL,NEW)
         IF (IROW.GT.0) GOTO 60
         IF (IROW.NE.-LROWS(JNAME))ISORT = 1
      ENDIF
C
C - If more than MXROW rows THEN start a new bank
C
      IF (JNAME.GT.0) THEN
         IF (LROWS(JNAME).GE.MXROW) JNAME = 0
      ENDIF
C
C - create the NAME bank or increase the bank length if necessary
C
      IF (JNAME.GT.0) THEN
         NRUN = IW(JNAME-2)
         IF (LFRROW(JNAME).GE.1) GOTO 50
      ELSE
         NRUN = NR
      ENDIF
      CALL AUBOS (NAME,NRUN,MXROW*LNAMEA+LMHLEN,JNAME,IGARB)
      IF (JNAME.EQ.0) GOTO 60
      IW(JNAME+LMHCOL)=LNAMEA
 50   IROW = LROWS(JNAME)+1
      IW(JNAME+LMHROW) = IROW
C
C - if a sorting is necessary then return IROW=-IROW
C
      IF (ISORT.EQ.1) IROW = -IROW
C
C - end
C
 60   CONTINUE
      ALGTBK = JNAME
      IF (IGARB.EQ.1) ALGTBK = -JNAME
      END
#endif
@
