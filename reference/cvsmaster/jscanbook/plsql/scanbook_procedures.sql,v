head	1.27;
access;
symbols
	V0060:1.27
	V0059:1.27
	V0058:1.26
	V0057:1.26
	V0056:1.25
	V0055:1.24
	V0054:1.23
	V0053:1.22
	V0052:1.22
	V0051:1.22
	V0050:1.21
	V0049:1.20
	V0048:1.19
	V0047:1.19
	V0046:1.18
	V0045:1.17
	V0044:1.17
	V0043:1.16
	V0042:1.14
	V0041:1.14
	V0040:1.13
	V0039:1.13
	V0038:1.13
	V0037:1.13
	V0036:1.13
	V0035:1.13
	V0034:1.12
	V0033:1.11
	V0032:1.11
	V0031:1.11
	V0030:1.10
	V0029:1.10
	V0028:1.9
	V0027:1.7
	V0026:1.5
	V0025:1.4
	V0024:1.4
	V0023:1.3
	V0022:1.2
	V0021:1.2
	V0020:1.2
	V0019:1.2
	V0018:1.2
	V0017:1.2
	V0016:1.2
	V0015:1.2
	V0014:1.1.1.1
	V0013:1.1.1.1
	V0000:1.1.1.1
	V0001:1.1.1.1
	v1:1.1.1.1
	jacotf:1.1.1;
locks; strict;
comment	@# @;


1.27
date	2001.12.19.11.20.27;	author jacotf;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.07.07.55.28;	author jacotf;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.05.07.56.55;	author jacotf;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.21.11.58.44;	author jacotf;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.18.09.39.48;	author jacotf;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.06.08.55.25;	author jacotf;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.24.10.22.28;	author jacotf;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.19.12.45.18;	author jacotf;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.01.16.10.31;	author jacotf;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.10.19.39.17;	author jacotf;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.09.08.15.36;	author jacotf;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.07.16.36.27;	author jacotf;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.07.15.54.59;	author jacotf;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.07.14.36.20;	author jacotf;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.11.10.54.28;	author jacotf;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.01.11.25.37;	author jacotf;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.05.08.20.06;	author jacotf;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.15.12.47.20;	author jacotf;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.05.15.10.02;	author jacotf;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.05.14.16.55;	author jacotf;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.17.08.06.38;	author jacotf;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.06.11.40.06;	author jacotf;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.05.13.09.31;	author jacotf;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.04.07.35.16;	author jacotf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.29.07.17.32;	author jacotf;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.22.16.36.52;	author jacotf;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.01.10.29.58;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.03.01.10.29.58;	author flr;	state Exp;
branches;
next	;


desc
@@


1.27
log
@correction in write_Mc_CartInfo
@
text
@SET ARRAYSIZE 1;

CREATE or REPLACE PACKAGE scanbook_procedures 
IS

   TYPE Int_Tab IS
      TABLE of NUMBER NOT NULL
      INDEX BY BINARY_INTEGER;

   TYPE Char_Tab IS
      TABLE of VARCHAR2(100) NOT NULL
      INDEX BY BINARY_INTEGER;

   TYPE args IS
      RECORD (

/*
|| JAVA Communication parameters
*/        
         procname      VARCHAR2(50) ,
         kingal_conds  VARCHAR2(300),
         kinlist       VARCHAR2(300),
         mcyear        VARCHAR2(100), 
         mcdatasets    VARCHAR2(300),
         specpar       VARCHAR2(100),
         institute     VARCHAR2(100),
         KinMass       VARCHAR2(100),
         wantwhat      VARCHAR2(300),
         data_type     VARCHAR2(100), 
         typedat       VARCHAR2(100),
         energy_lep    VARCHAR2(100),
         datayear      VARCHAR2(100),
         runorfill     VARCHAR2(500),
         runorcart     VARCHAR2(500),
         runquality    VARCHAR2(300),
         PhysGroups    VARCHAR2(300),
         selby         VARCHAR2(100),
         menutype      VARCHAR2(300),
         page_number   VARCHAR2(2)  , 
         processings   VARCHAR2(300),
         filisorted    VARCHAR2(10) ,
         OutputType    VARCHAR2(100),
         ediryesno     VARCHAR2(10) ,
         user_name     VARCHAR2(100),
         hardware      VARCHAR2(100),
         os_name       VARCHAR2(100),
         ip_address    VARCHAR2(100),
         navigator     VARCHAR2(100),
         stat_by       VARCHAR2(100),
         ProgVers      VARCHAR2(100),
         aledir        VARCHAR2(100),
         header        INTEGER      ,

/*
|| Internal parameters
*/
         opt_arg         VARCHAR2(100),
         firstenergy_cut VARCHAR2(100),
         lastenergy_cut  VARCHAR2(100)
      );

   TYPE run_values IS
      RECORD (
         LepFill    INTEGER      ,
         WDate      INTEGER      ,
         ExEnergy   NUMBER(10,3) ,
         EVnumb     INTEGER      ,
         NumZ0      INTEGER      ,
         NumBh      INTEGER      ,
         LUmin      NUMBER(10,3) ,
         VdetLumi   NUMBER(10,3) ,
         Runsel     VARCHAR2(32) 
      );

   TYPE Runs_table IS
      TABLE of run_values
      INDEX BY BINARY_INTEGER;


   TYPE fill_values IS
      RECORD (
         LepFill    INTEGER      ,
         WDate      INTEGER      ,
         ExEnergy   NUMBER(10,3) ,
         NZ0Hadr    INTEGER      ,
         LUmin      NUMBER(10,3) ,
         VdetLumi   NUMBER(10,3) ,
         Runs       VARCHAR2(600)         
      );

   TYPE Fills_table IS
      TABLE of fill_values
      INDEX BY BINARY_INTEGER;


   TYPE lepenergy_values IS
      RECORD (
         RoundedEnergy INTEGER      ,
         GoodRuns      INTEGER      ,
         Nbhabha       INTEGER      ,
         Lumi          NUMBER(10,3) ,
         Nhadr         INTEGER      ,
         VdetLumi      NUMBER(10,3)       
      );

   TYPE Lepenergy_table IS
      TABLE of lepenergy_values
      INDEX BY BINARY_INTEGER;


   TYPE tape_values IS
      RECORD (
         Tape       VARCHAR2(20)  ,
         Nature     VARCHAR2(10)  ,
         Proc_date  INTEGER       ,
         Location   VARCHAR2(10)  ,
         First_run  INTEGER       ,
         Last_run   INTEGER       ,
         Nb_run     INTEGER       ,
         Start_run  INTEGER       ,
         Nevts      INTEGER       ,
         ExEnergy   NUMBER(10,3)  ,
         Runs       VARCHAR2(1500),
         Details    VARCHAR2(100) ,
         Program    VARCHAR2(100) ,
         GalVersion INTEGER       ,
         JulVersion INTEGER       ,
         MinVersion INTEGER       ,
         ProcLevel  VARCHAR2(10)  ,
         CopyFlag   INTEGER       ,
         SizeMbytes INTEGER       ,          
         Nclass16   INTEGER       ,
         Kin_code   INTEGER      
      );

   TYPE Tapes_table IS
      TABLE of tape_values
      INDEX BY BINARY_INTEGER;


   TYPE tape_runs_values IS
      RECORD (
         RunNb      INTEGER      ,
         ExEnergy   NUMBER(10,3) ,
         Nclass16   INTEGER                  
      );

   TYPE Tapes_Runs_table IS
      TABLE of tape_runs_values
      INDEX BY BINARY_INTEGER;


   Global_web_output VARCHAR2(50) := NULL;

 
   PROCEDURE write_kinagain_fili
      (KinKWord IN VARCHAR2, 
       Kinagain_KWord IN VARCHAR2);


   PROCEDURE COLONEL
      (  procname       IN VARCHAR2,
         kingal_conds   IN VARCHAR2 := NULL,
         kinlist        IN VARCHAR2 := NULL,
         mcyear         IN VARCHAR2 := NULL,
         mcdatasets     IN VARCHAR2 := NULL,
         specpar        IN VARCHAR2 := NULL,
         institute      IN VARCHAR2 := NULL,
         KinMass        IN VARCHAR2 := NULL,
         wantwhat       IN VARCHAR2 := NULL,
         data_type      IN VARCHAR2 := NULL,
         typedat        IN VARCHAR2 := NULL,
         energy_lep     IN VARCHAR2 := NULL,
         datayear       IN VARCHAR2 := NULL,
         runorfill      IN VARCHAR2 := NULL,
         runorcart      IN VARCHAR2 := NULL,
         runquality     IN VARCHAR2 := NULL,
         PhysGroups     IN VARCHAR2 := NULL,
         selby          IN VARCHAR2 := NULL,
         menutype       IN VARCHAR2 := NULL,
         page_number    IN VARCHAR2 := NULL,
         processings    IN VARCHAR2 := NULL,
         filisorted     IN VARCHAR2 := NULL,
         OutputType     IN VARCHAR2 := NULL,
         ediryesno      IN VARCHAR2 := NULL,
         user_name      IN VARCHAR2 := NULL,
         hardware       IN VARCHAR2 := NULL,
         os_name        IN VARCHAR2 := NULL,
         ip_address     IN VARCHAR2 := NULL,
         navigator      IN VARCHAR2 := NULL,
         stat_by        IN VARCHAR2 := NULL,
         web_output     IN VARCHAR2 := NULL,
         ProgVers       IN VARCHAR2 := ' ',
         aledir         IN VARCHAR2 := NULL,
         header         IN VARCHAR2 := NULL
      );


   PROCEDURE my_test;
   
  
END scanbook_procedures;
/
show errors


CREATE or REPLACE PACKAGE BODY scanbook_procedures 
/*
|| !!!! If one wants to debug a procedure !!!!
|| Before you can use dbms_output do:
||    set serveroutput on; 
|| The default buffer size can be too small - Increase the size of the STUPID buffer doing:
||    DBMS_OUTPUT.ENABLE (1000000);
||
|| To increase the linesize for the output (default=80 characters) do:
||    set linesize 132;
||
*/
IS

PROCEDURE print_string
IS
BEGIN
   dbms_output.put_line('');
   htp.print('');
END;

 
PROCEDURE print_string 
  (value in VARCHAR2)
IS
BEGIN
   dbms_output.put(value);
   htp.prn(value);

END;


PROCEDURE print_string 
   (value in INTEGER)
IS
BEGIN
   print_string(to_char(value));
END;


PROCEDURE print_string 
   (value in INTEGER, format in VARCHAR2)
IS
BEGIN
   print_string(SUBSTR(to_char(value,format),2));
END;


PROCEDURE print_string 
   (value in INTEGER, format in VARCHAR2, spaces in INTEGER)
IS
BEGIN
   FOR i IN 1 .. spaces
   LOOP
      print_string(' ');
   END LOOP;
   print_string(value,format);
END;


PROCEDURE print_string 
   (value in VARCHAR2, spaces in INTEGER)
IS
BEGIN
   FOR i IN 1 .. spaces
   LOOP
      print_string(' ');
   END LOOP;
   print_string(value);
END;


PROCEDURE print_header
   (head IN INTEGER, flag IN VARCHAR2)
IS
BEGIN
   IF Global_web_output IS NULL
   THEN
      IF head is NULL
      THEN
         print_string('  ');
      ELSE   
         print_string(to_char(head, 'S9'));
         print_string(flag);
      END IF;
   END IF;
END;


PROCEDURE write_datime
   (type_gen IN VARCHAR2,
    head IN INTEGER
    )
/*
|| Print the date on output
*/
IS
   date VARCHAR2(50);
   time VARCHAR2(50);
   date_time VARCHAR2(60);

BEGIN
 
   date := to_char(SYSDATE,'FMDay DD-MONTH-YYYY');
   time := to_char(SYSDATE,'HH24:MI');
   date_time := date || ' at ' || time;
   
   print_header(head,' ');
   print_string('*');
   print_string;
   print_header(head,' ');
   print_string('* ' || type_gen || ' generated on ' || date_time);
   print_string;
   print_header(head,' ');
   print_string('*');
   print_string;

END write_datime; 


FUNCTION give_default
   (Param_select IN VARCHAR2)
/*
|| Find in table MENUDEFAULTS the default value
|| for the given parameter
*/
   RETURN VARCHAR2 
IS
   Param_default MENUDEFAULTS.ParamValue%TYPE;
BEGIN 
   SELECT ParamValue 
   INTO Param_default
   FROM MENUDEFAULTS
   WHERE ParamName like Param_select;

RETURN Param_default;

END;

 
FUNCTION give_othermenus_default
   (a_in IN args)
/*
|| Find in table OTHERMENUS the default value
|| for the given parameter
*/
   RETURN VARCHAR2 
IS
   Param_default OTHERMENUS.UserOption%TYPE;
BEGIN 
   
   SELECT UserOption
   INTO Param_default
   FROM OTHERMENUS
   WHERE Menu like a_in.menutype
     AND TypeData like a_in.typedat
     AND PageNumb like a_in.page_number
     AND Default_flag like '*'
   ;

RETURN Param_default;

END; 


FUNCTION give_action
    (menu_name IN VARCHAR2,
     option_name IN VARCHAR2)
/*
|| Give an action depending on a selected menu
|| and a selected option
*/
   RETURN VARCHAR2
IS
   action_is OTHERMENUS.Action%TYPE;
BEGIN
      SELECT Action
      INTO action_is 
      FROM OTHERMENUS
      WHERE Menu like menu_name
        AND UserOption like option_name
      ;

RETURN action_is;

END;   


FUNCTION give_Cart_label
    (tape_id IN VARCHAR2)
/*
|| From a tape ID give the tape label
*/
   RETURN VARCHAR2
IS
   cart_label VARCHAR2(10);
BEGIN
   SELECT TapeLabel
   INTO cart_label
   FROM CARTDES
   WHERE TapeId like tape_id
   ;

   cart_label := '.' || cart_label;
 
RETURN cart_label;

END;   


FUNCTION give_Cart_ID
    (tape_id IN VARCHAR2)
/*
|| From a TapeID give the ID
*/
   RETURN INTEGER
IS
   cart_ID INTEGER;
BEGIN
   SELECT ID
   INTO cart_ID
   FROM CARTDES
   WHERE TapeId like tape_id
   ;

RETURN cart_ID;

END;   


PROCEDURE give_selyear
    (sel_by IN VARCHAR2,
     sel_number IN INTEGER,
     year_is OUT VARCHAR2)
/*
|| From a selected Run or Fill give the corresponding year
*/
IS
BEGIN 
DECLARE
   CURSOR runby_cur IS
      SELECT Year, LepCategory
      FROM RUNBYYEAR
      WHERE (  
              (sel_by = ' ' AND sel_number between FirstRun and LastRun)
         OR
              (sel_by = 'RUN(s)' AND sel_number between FirstRun and LastRun)
         OR
              (sel_by = 'FILL(s)' AND sel_number between FirstFill and LastFill)
      ) 
      ;

BEGIN
   FOR a_rec IN runby_cur
   LOOP
      IF a_rec.Year = 1995
      THEN
         year_is := to_char(a_rec.Year) || ' /' || a_rec.LepCategory;
      ELSE  
         year_is := to_char(a_rec.Year);
      END IF;
   END LOOP;
   
END;   
END give_selyear;


FUNCTION convert_institute
   (institute_name IN VARCHAR2)
/* 
|| From an institute name, find the institute number
*/
   RETURN VARCHAR2 
IS
   institute_number HOMEDESC.IHomeLab%TYPE;
BEGIN 
   SELECT IHomelab
   INTO institute_number  
   FROM HOMEDESC 
   WHERE HomeName like institute_name;

RETURN institute_number;
END; 


FUNCTION extract_kincode
   (kin_list IN VARCHAR2)
/*
|| MonteCarlo Data
|| From a given kinbyyear line extract the kingal code
*/ 
   RETURN VARCHAR2 
IS
   begin_kinbyyear_info VARCHAR2(300);
   kingal_code VARCHAR2(4);

BEGIN
   IF kin_list IS NULL
   THEN
      kingal_code := '%';
   ELSE
    
/* Trim the kin_list to suppress the first space(s) */
      begin_kinbyyear_info := LTRIM(kin_list);

/* Extract the KInCode */
      kingal_code := SUBSTR(begin_kinbyyear_info,1,4);

   END IF;

RETURN kingal_code;
END; 


FUNCTION convert_lepenergy
   (lep_energy in VARCHAR2)
/*
|| If necessary, modify the lep energy value to be able to use it in some "SELECT"
*/ 
   RETURN VARCHAR2 
IS
BEGIN
   IF INSTR(lep_energy,'ANY') != 0
   THEN
      RETURN '%';
   ELSIF INSTR(lep_energy,'ALL LEP2') != 0
   THEN
      RETURN 'LEP2';
   ELSIF INSTR(lep_energy,'ALL LEP1.5') != 0
   THEN
      RETURN 'LEP1.5';
   ELSIF INSTR(lep_energy,'->') != 0
   THEN
      RETURN 'ANNE_CUT';
   ELSE
      RETURN LTRIM(lep_energy);
   END IF;

END; 


FUNCTION convert_special_particles
   (spec_par in VARCHAR2)
/*
|| If necessary modify the "special_particles" to be able to use it in some "SELECT"
*/ 
   RETURN VARCHAR2 
IS
BEGIN
   IF INSTR(spec_par,'ANY') != 0
   THEN
      RETURN '%';
   ELSE
      RETURN spec_par;
   END IF;

END; 


FUNCTION convert_year
   (my_year in VARCHAR2)
/*
|| If year is 1995 must do a a conversion.
*/ 
   RETURN INTEGER 
IS
   year_is VARCHAR2(20);
   loc_lepcat INTEGER;

BEGIN
   year_is := my_year;
   loc_lepcat := INSTR(my_year, '/') + 1;
   IF loc_lepcat > 1                                   /* Year is 1995 */
   THEN 
      year_is := SUBSTR(my_year,1,4);
   END IF;
   RETURN to_number(year_is);

END; 


FUNCTION give_lepcategory
   (year_is in VARCHAR2)
/*
|| Give the LepCategory for a selected year  
*/ 
   RETURN VARCHAR2 
IS
   loc_lepcat INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE;   

BEGIN
   loc_lepcat := INSTR(year_is, '/') + 1;
   IF loc_lepcat > 1                                   /* Year is 1995 */
   THEN 
      lep_category := SUBSTR(year_is,loc_lepcat,LENGTH(year_is));
   ELSE
      lep_category := '%';
   END IF;

   RETURN lep_category;

END; 


FUNCTION give_tape
   (tape_id in VARCHAR2,
    tape_numb in INTEGER,
    file_numb in INTEGER)
/*
|| Give the complete Tape name and File.
*/ 
   RETURN VARCHAR2 
IS
   tape_number VARCHAR2(10);
   nzeros INTEGER;
   tape_name_file VARCHAR2(20);

BEGIN
   tape_number := to_char(tape_numb);
   nzeros := 4 - LENGTH(tape_number); 
   FOR i IN 1 .. nzeros          
   LOOP
      tape_number := '0' || tape_number;
   END LOOP;

   tape_name_file := tape_id || tape_number || '_' || to_char(file_numb);

   RETURN tape_name_file;

END; 


PROCEDURE split_string
   (string_in IN VARCHAR2,
    first OUT VARCHAR2,
    reste OUT VARCHAR2)
/*
|| Split a string and fill a list
|| Called by extract_from_process_line (Real Data)
||        by mc_data_found (MonteCarlo Data)
*/ 
IS
   my_string VARCHAR2(300);
   loc_space INTEGER;

BEGIN
   
   my_string := LTRIM(string_in);                  /* Suppress the first space(s) */
   my_string := REPLACE(my_string,' to ',' ');     /* for processing level line */
   loc_space := INSTR(my_string,' ');
   IF loc_space = 0                                /* End of string */ 
   THEN
      first := my_string;
      reste := '  ';
   ELSE
      first := SUBSTR(my_string,1,loc_space - 1);
      reste := SUBSTR(my_string,loc_space,LENGTH(string_in));
   END IF;

END split_string;


PROCEDURE extract_from_runorfill
   (runfill_in IN VARCHAR2,
    firstsel OUT INTEGER,
    lastsel OUT INTEGER,
    sel_flag OUT VARCHAR2,
    runfill_out OUT VARCHAR2)
/*
|| Real Data
|| From the Run(s) or FILL(s) selection entered by the User 
|| fill a list of runs or fills.
|| Parameter runorfill can be:
||  1) If selection done by Year
||        NULL 
||  2) If selection done by RUN(s)                   - 
||        'btw firstrun lastrun'    - user's selection was: firstrun/lastrun or firstrun
||        'or  run1 run2 runn'      - user's selection was: run1, run2, ....runn
||  2) If selection done by FILL(s)                   - 
||        'btw firstfill lastfill'  - user's selection was: firstrun/lastrun or firstrun
||        'or  fill1 fill2 filln'   - user's selection was: fill1, fill2, ....filln
|| If the run (or fill) number has less than 5 figures insert 0s at the beginning
||   (ex: Fill 40 -> 00040) to obtain a string of 5 characters.  
*/ 
IS
   loc INTEGER;

BEGIN

   sel_flag := SUBSTR(runfill_in,1,3);       
   IF sel_flag = 'btw'
   THEN   
      loc := 5;
      firstsel := to_number(SUBSTR(runfill_in,loc,5));
     
      loc := loc + 6;
      lastsel  := to_number(SUBSTR(runfill_in,loc,5));      
   END IF;

/* The to_char used in the SELECT (declare cursor) adds a blank. 
|| To avoid problems insert a blank at the beginning and at the end of
|| the runfill_out string
*/
   IF sel_flag = 'or '
   THEN
      runfill_out := ' ' || SUBSTR(runfill_in,5,LENGTH(runfill_in)) || ' ';
   END IF;

END extract_from_runorfill;


FUNCTION extract_from_processline
   (processline IN VARCHAR2,
    type_of_data IN VARCHAR2)
/*
|| For Real Data or MonteCarlo Data
|| From a given processing level line extract some values which will
|| be used to write the FILI and SRUN cards and store them in a list
*/ 
   RETURN Char_Tab
IS
   LocalList Char_Tab;
   EmptyList Char_Tab;
 
   str VARCHAR2(300);
   first_word VARCHAR2(100);
   reste VARCHAR2(300);
   nstr INTEGER;

BEGIN

   LocalList := EmptyList;
      
   str := processline; 

   IF type_of_data = 'Real DATA'
   THEN
      nstr := 6;
   ELSIF type_of_data = 'MC DATA'
   THEN
      nstr := 3;
   END IF;

   IF processline IS NULL
   THEN
      FOR i IN 1 .. nstr          
      LOOP
         LocalList(i) := '%';
      END LOOP;
      RETURN LocalList;
   END IF;

   FOR i IN 1 .. nstr
   LOOP
      split_string(str,first_word,reste);
      LocalList(i) := first_word;
      str := reste;
   END LOOP;
   RETURN LocalList;

END; 


PROCEDURE extract_from_runbyyear
   (year_in IN VARCHAR2,
    first_run OUT INTEGER,
    last_run OUT INTEGER)
/*
|| Real Data
|| From the year selected retrieve the the first and last run
|| from RUNBYYEAR table.
*/ 
IS
   loc INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE := give_lepcategory(year_in);   
   year_is RUNBYYEAR.Year%TYPE := convert_year(year_in);

BEGIN
DECLARE
   CURSOR runby_cur
   IS
   SELECT *
   FROM RUNBYYEAR
   WHERE   Year = year_is
      AND  LepCategory like lep_category
   ;

BEGIN
   FOR a_rec IN runby_cur
   LOOP
      first_run := a_rec.FirstRun;
      last_run  := a_rec.LastRun;
   END LOOP;

END;
END extract_from_runbyyear;


FUNCTION wrunsel_exist
   (year_in IN VARCHAR2)
/*
|| For Real Data
|| Check if for the selected year there are some runs in table WRUNSEL 
*/
   RETURN INTEGER
IS
   nrec INTEGER;

BEGIN
DECLARE

   CURSOR wsel_cur  
   IS
      SELECT ws.RunNb 
      FROM WRUNSEL ws, RUNBYYEAR rb
      WHERE rb.Year like year_in
      AND ws.RunNb between rb.FirstRun AND rb.LastRun 
   ;

BEGIN

   nrec := 0;

   FOR a_rec IN wsel_cur
   LOOP
      nrec := nrec + 1;  
   END LOOP;

END;
  
RETURN nrec;

END;


FUNCTION if_WWPhysics
   (a_in IN args)
/*
|| Real Data
|| For the selected year find if the WW mask from table 
|| RUNBYYEAR is defined.
*/ 
   RETURN VARCHAR2 
IS
   loc_lepcat INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE := NULL;   
   year_is ENERGYLEP.Year%TYPE := convert_year(a_in.datayear);
   wmask_is RUNBYYEAR.WrunselPatt%TYPE;
   apply_wmask VARCHAR2(10) := 'No ';

BEGIN
 
   IF a_in.typedat != 'Real DATA' OR to_number(a_in.page_number) != 2 
   THEN
      RETURN apply_wmask;
   ELSE
      BEGIN
         loc_lepcat := INSTR(a_in.datayear, '/') + 1;
         IF loc_lepcat > 1                                          /* Year is 1995 */
         THEN 
            lep_category := SUBSTR(a_in.datayear,loc_lepcat,LENGTH(a_in.datayear));
         END IF;

         SELECT WrunselPatt
         INTO wmask_is  
         FROM RUNBYYEAR 
         WHERE year = year_is
         AND LepCategory like NVL(lep_category,'%');

         IF SUBSTR(wmask_is,1,3) = 'Yes'       
         THEN
            apply_wmask := 'Yes';   
         END IF;
      END; 
   END IF;

   RETURN apply_wmask;

END;


FUNCTION extract_Wmask
   (a_in IN args)
/*
|| Real Data
|| For the selected year retrieve the WW mask from table RUNBYYEAR. 
*/ 
   RETURN VARCHAR2 
IS
   loc INTEGER;
   loc_lepcat INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE := NULL;   
   year_is ENERGYLEP.Year%TYPE := convert_year(a_in.datayear);
   if_mask VARCHAR2(10);
   wmask_is RUNBYYEAR.WrunselPatt%TYPE;
   wmask_out RUNBYYEAR.WrunselPatt%TYPE;

BEGIN
 
   IF a_in.typedat != 'Real DATA' OR to_number(a_in.page_number) != 2 
   THEN
      wmask_out := 'Ignore';
   ELSE
      BEGIN
         loc_lepcat := INSTR(a_in.datayear, '/') + 1;
         IF loc_lepcat > 1                                          /* Year is 1995 */
         THEN 
            lep_category := SUBSTR(a_in.datayear,loc_lepcat,LENGTH(a_in.datayear));
         END IF;

         SELECT WrunselPatt
         INTO wmask_is  
         FROM RUNBYYEAR 
         WHERE year = year_is
         AND LepCategory like NVL(lep_category,'%');

         if_mask := SUBSTR(wmask_is,1,3);       
         IF if_mask = 'Yes'
         THEN   
            loc := 5;
            wmask_out := SUBSTR(wmask_is,loc,LENGTH(wmask_is));
         ELSE  
            wmask_out := 'Ignore';
         END IF;
      END; 
   END IF;

   RETURN wmask_out;

END;


FUNCTION sprint_physgroups
    (phys_groups IN VARCHAR2)
/*
|| For Real Data
|| From a given phys_groups returns the Phys. Tools Combinations
*/
   RETURN VARCHAR2
IS
   nrec INTEGER;
   rqword VARCHAR2(10);
   istart INTEGER;
   not_and VARCHAR2(10);
   len_phys INTEGER;
   jbit VARCHAR2(10);
   phys_string VARCHAR2(300);

BEGIN
DECLARE

   CURSOR rq_cur (bit_in NUMBER) 
   IS
      SELECT DISTINCT RunqualKeyword
      FROM RUNQUALS
      WHERE
         NumBitpattern = bit_in
      ;
      rq_rec rq_cur%ROWTYPE;

BEGIN

   len_phys := LENGTH(phys_groups);
   not_and := '';
   istart := 0;

   FOR jj IN 4 .. len_phys
   LOOP
      jbit := SUBSTR(phys_groups,jj,1);
      IF jbit = 'F' OR jbit = 'T'
      THEN
         OPEN rq_cur(jj);
         LOOP
            FETCH rq_cur INTO rq_rec;
            EXIT WHEN rq_cur%NOTFOUND;
            IF istart = 0 
            THEN 
               IF jbit = 'F'
               THEN
                  not_and := 'NOT.';
               END IF; 
            ELSE
               IF jbit = 'T'
               THEN
                  not_and := '.AND.';
               ELSIF jbit = 'F'
               THEN
                  not_and := '.AND.NOT.';
               END IF;
            END IF;
            phys_string := phys_string || not_and || rq_rec.RunqualKeyword;
            istart := 1;
         END LOOP;
         CLOSE rq_cur;
      END IF;
   END LOOP;

END;
  
RETURN phys_string;

END;


PROCEDURE give_year_list
    (a_in IN args,
     ind_in IN INTEGER,
     year_default IN VARCHAR2)
/*
|| Real Data and Monte Carlo
|| Prepare the Data years and MC years menu
*/ 
IS
   head INTEGER;
   flag VARCHAR2(10) := ' ';
   for_1995 VARCHAR2(15);
   loc_lepcat INTEGER;
   lepcat RUNBYYEAR.LepCategory%TYPE := NULL;
   year_is RUNBYYEAR.Year%TYPE;

BEGIN

   loc_lepcat := INSTR(year_default, '/') + 1;          /* Year 1995 */
   IF loc_lepcat > 1
   THEN
      year_is := to_number(SUBSTR(year_default,1,4));
      lepcat := SUBSTR(year_default,7,LENGTH(year_default));
   ELSE
      year_is := to_number(year_default);
   END IF;

DECLARE
   CURSOR a_cur IS
      SELECT * FROM RUNBYYEAR 
      ORDER by Year
      ;

BEGIN

   head := a_in.header + ind_in;

   FOR a_rec IN a_cur
   LOOP
      IF a_rec.Year = year_is  
      THEN
         flag := '*';
         IF a_rec.Year = 1995 AND a_rec.LepCategory != lepcat
         THEN
            flag := ' ';
         END IF;
      ELSE 
         flag := ' ';
      END IF;
      
      print_header(head,flag);

      IF a_rec.Year = 1995
      THEN
         for_1995 := a_rec.Year || ' /' || a_rec.LepCategory;
         print_string(for_1995);
      ELSE
         print_string(a_rec.Year, '9999');
      END IF;
      print_string;
   END LOOP;

END;
END give_year_list;


PROCEDURE give_LepEnergyList
   (arg_in IN args,
    LocalList OUT Char_Tab)
/*
|| For Real Data
|| From a given year fill a list of all available Lep energies
|| Will be used to write the FILI and SRUN cards if sorted by Lep energy
|| If parameter filisorted = 'No' Fix the first list element to %
*/
 
IS
   loc_lepcat INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE := NULL;   
   year_is ENERGYLEP.Year%TYPE := convert_year(arg_in.datayear);
   MaxEnergyLEP1  INTEGER := to_number(give_default('MaxEnergyLEP1'));   
   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   
   nrec INTEGER;

   first_cut INTEGER;
   last_cut  INTEGER;

BEGIN   

   loc_lepcat := INSTR(arg_in.datayear, '/') + 1;
   IF loc_lepcat > 1                                          /* Year is 1995 */
   THEN 
      lep_category := SUBSTR(arg_in.datayear,loc_lepcat,LENGTH(arg_in.datayear));
   END IF;

DECLARE
   CURSOR e_cur IS
      SELECT RoundedEnergy 
      FROM ENERGYLEP
         WHERE Year = year_is
           AND LepCategory like NVL(lep_category,'%')
      ORDER by RoundedEnergy
      ;

BEGIN   

/* 
|| If "sorted by lep energy" selected 
||   - If 'ANY' selected :
||     the list will contain ALL existing Lep energies 
||     for the selected year 
|| 
||   - If 'ALL LEP2' selected 
||     the list will contain ALL existing Lep energies > MaxEnergyLEP15 
||     for the selected year 
||
||   - If 'ALL LEP1.5' selected (year = 1995 and year 1997)
||     the list will contain MaxEnergyLEP1 <= ALL existing Lep energies <= MaxEnergyLEP15 
||     for the selected year 
||
||   - If 'ANNE_CUT' selected (year >= 2000) 
||     the list will contain the Lep energies corresponding to 
||     the cut selected 
*/
   nrec := 0;

   IF arg_in.energy_lep = 'ANNE_CUT'
   THEN
      first_cut := to_number(arg_in.firstenergy_cut);
      last_cut := to_number(arg_in.lastenergy_cut);
   END IF;

   IF arg_in.filisorted = 'Yes'
   THEN
      FOR a_rec IN e_cur
      LOOP
         IF arg_in.energy_lep = 'LEP2'
         THEN
            IF a_rec.RoundedEnergy >= MaxEnergyLEP15
            THEN 
               nrec := nrec + 1;
               LocalList(nrec) := to_char(a_rec.RoundedEnergy); 
            END IF;
         ELSIF arg_in.energy_lep = 'LEP1.5'
         THEN
            IF a_rec.RoundedEnergy BETWEEN MaxEnergyLEP1 AND MaxEnergyLEP15
            THEN 
               nrec := nrec + 1;
               LocalList(nrec) := to_char(a_rec.RoundedEnergy); 
            END IF;
         ELSIF arg_in.energy_lep = 'ANNE_CUT'
         THEN
            IF a_rec.RoundedEnergy >= first_cut AND a_rec.RoundedEnergy <= last_cut
            THEN
               nrec := nrec + 1;
               LocalList(nrec) := to_char(a_rec.RoundedEnergy); 
            END IF;
         ELSE
            nrec := nrec + 1;
            LocalList(nrec) := to_char(a_rec.RoundedEnergy); 
         END IF;
      END LOOP;

/*
|| If NO "sorted by lep energy" selected 
|| The list will contain 1 element :
||    '%' if 'ANY' was selected
||    'LEP2' if 'ALL LEP2' was selected
||    'LEP1.5' if 'ALL LEP1.5' was selected
||    'ANNE_CUT' if an energy cut was selected
||    The energy selected by the user if one energy selected 
*/
   ELSIF arg_in.energy_lep = 'ANY'
   THEN
      LocalList(1) := '%';
   ELSE
      LocalList(1) := arg_in.energy_lep;
   END IF;
END;
END give_LepEnergyList; 


PROCEDURE give_RunQList
   (year_in IN INTEGER,
    LocalList OUT Char_Tab)
/*
|| For Real Data
|| Store the requested year Run quality information in a list
*/
 
IS
   nrec INTEGER;
BEGIN
DECLARE

   CURSOR rq_cur IS
      SELECT NumBitpattern, RunqualKeyword, ExplainRunqual
      FROM RUNQUALS
         WHERE Year = year_in
      ORDER by NumBitpattern
      ;

BEGIN   

      nrec := 0;
      FOR a_rec IN rq_cur
      LOOP
         nrec := nrec + 1;
         LocalList(a_rec.NumBitpattern) := a_rec.RunqualKeyword || ' ' || 
                                           a_rec.ExplainRunqual;
      END LOOP;

END;
END give_RunQList; 


FUNCTION fill_physgroups
   (a_in IN args)
/*
|| Returns the PhysGroups modified according to the runquality selected 
|| For PERF bits 0 -> 2 are : FFT
|| For MAYB bits 0 -> 2 are : FTF
*/ 
   RETURN VARCHAR2 
IS
   wmask_is RUNBYYEAR.WrunselPatt%TYPE;
   phys_groups VARCHAR2(50);

BEGIN
 
   IF a_in.runquality = 'PERF or MAYB' 
   THEN
      RETURN 'F__%';
   ELSIF a_in.runquality = 'All runs'
   THEN
      RETURN '%';                           
   ELSIF a_in.runquality = 'Only PERF'
   THEN
      RETURN 'FFT_%';                         
   ELSIF a_in.runquality = 'Phys. Groups' 
   THEN
      RETURN a_in.PhysGroups; 
   ELSIF a_in.runquality = 'WW Physics'
   THEN
      wmask_is := extract_Wmask(a_in);
      IF wmask_is != 'Ignore'
      THEN
         phys_groups := wmask_is;
         RETURN phys_groups;
      ELSE
         RETURN a_in.PhysGroups;       
      END IF;
   ELSE
      RETURN '%';
   END IF;
    
END; 


FUNCTION give_kinkeyword
   (kin_conds IN VARCHAR2,
    kin_code IN VARCHAR2,
    year IN INTEGER,
    institute IN INTEGER)
/*
|| From a given kincomments line and some user's 
|| selections, find the unical corresponding KingalKeyWord
*/ 
   RETURN VARCHAR2 
IS
   kin_keyword MCKEYSTAT.KingalKeyWord%TYPE;
   explain_keyword MCKEYSTAT.ExplainKeyword%TYPE;
   loc_explain INTEGER;
   lg_kinconds INTEGER;

BEGIN

   IF kin_conds IS NULL
   THEN
      kin_keyword := '%';
   ELSE
      BEGIN
/* Extract the Kingal explain_keyword */
         loc_explain := INSTR(kin_conds,':');
         lg_kinconds := LENGTH(kin_conds);
         explain_keyword := SUBSTR(kin_conds,loc_explain+2,lg_kinconds);

         SELECT KingalKeyWord
         INTO kin_keyword
         FROM MCKEYSTAT
         WHERE KInCode like kin_code
           AND GeometryYear = year
           AND IHomelab = institute
           AND ExplainKeyword like explain_keyword;

--      EXCEPTION
--         WHEN NO_DATA_FOUND THEN    
--         kin_keyword := NULL;
      END; 
   END IF;

   RETURN kin_keyword;
END; 


PROCEDURE give_explainkeyword
   (kin_code IN VARCHAR2,
    kin_keyword IN VARCHAR2,
    year_in IN INTEGER,
    institute IN INTEGER,
    explain_keyword OUT VARCHAR2)
/*
|| Give the ExplainKeyword 
|| Only available for years >= 1996
|| In the future it will be available for all LEP2
*/ 
IS
BEGIN	
   explain_keyword := 'not defined';

DECLARE

   CURSOR expl_cur IS
   SELECT ExplainKeyword
   FROM MCKEYSTAT
   WHERE KInCode like kin_code
     AND GeometryYear = year_in
     AND IHomelab = institute
     AND KingalKeyWord like kin_keyword
  ;

BEGIN
   FOR a_rec IN expl_cur
   LOOP
      explain_keyword := a_rec.ExplainKeyword;
   END LOOP;

END; 
END give_explainkeyword;


PROCEDURE give_runbyyear
   (a_in IN args)
/*
|| For Real Data
|| Page 1 of the scanbook user interface
|| Returns :
||  - The list of Runs and Fills for each available Data year
||  - The list of available Data years
||  - The list of available Montecarlo years
*/
IS
   head INTEGER;
   flag VARCHAR2(10) := ' ';
   for_1995 VARCHAR2(15);
   nb_blanks INTEGER;
   year_default MENUDEFAULTS.ParamValue%TYPE;

BEGIN
DECLARE
   CURSOR a_cur IS
      SELECT * FROM RUNBYYEAR 
      ORDER by Year
      ;
BEGIN
   FOR a_rec IN a_cur
   LOOP
      print_header(a_in.header,flag);

      IF a_rec.Year = 1995
      THEN
         nb_blanks := 9 - LENGTH(a_rec.LepCategory);
         print_string(a_rec.LepCategory);
         FOR i IN 1 .. nb_blanks
         LOOP
            print_string(' ');
         END LOOP;
         print_string(a_rec.Year, '99999');
      ELSE
         print_string(a_rec.Year, '99999',9);
      END IF;
      
      print_string(a_rec.FirstRun, '9999999999',1);
      print_string(a_rec.LastRun,  '9999999999');
      print_string(a_rec.FirstFill,'9999999999',1);
      print_string(a_rec.LastFill, '9999999999',2);
      print_string;
   END LOOP;

/* 
|| Data Years - Mc Years 
|| i=1  Data Years - Default from 'DataYear' or "runorfill" selected year
|| i=2  Mc Years   - Default from 'Mcyear' 
||                   set at end of first loop
*/

   year_default := give_default('DataYear');

   IF a_in.datayear IS NOT NULL
   THEN
      year_default := a_in.datayear;
   END IF;

   FOR i IN 1 .. 2
   LOOP
      give_year_list(a_in,i,year_default);
      year_default := give_default('McYear');  
   END LOOP;

EXCEPTION
  when others then
    htp.print('Unknown error, please contact ...');

END;
END give_runbyyear;


PROCEDURE give_institutes
   (a_in IN args)
/*
|| Page 1 of the scanbook user interface
|| Returns the list of Institutes' names
*/
IS
   flag VARCHAR2(10) := ' ';
   inst_default MENUDEFAULTS.ParamValue%TYPE;
BEGIN
DECLARE
   CURSOR inst_cur IS
      SELECT HomeName from HOMEDESC
      ORDER by IHomelab
      ;
BEGIN
   inst_default := give_default('Institute');
 
   FOR a_rec IN inst_cur
   LOOP
      IF a_rec.HomeName = inst_default  
      THEN
         flag := '*';
      ELSE 
         flag := ' ';
      END IF;

      print_header(a_in.header,flag);
      print_string(a_rec.HomeName);
      print_string;
   END LOOP;

EXCEPTION
  when others then
    htp.print('Unknown error, please contact ...');
END;

END give_institutes;


PROCEDURE fill_other_menus
   (a_in IN args)
/*
|| Page 1, Page 2 of the scanbook user interface
|| Page 10 (statistics)
|| Prepare datatypes' buttons and selections' menu 
*/
IS
   flag VARCHAR2(10) := '  ';
   use_wmask VARCHAR2(10);
   year_is RUNBYYEAR.Year%TYPE;

BEGIN
   use_wmask := if_WWPhysics(a_in);

DECLARE
   CURSOR dtype_cur IS
      SELECT * 
      FROM OTHERMENUS
      WHERE TypeData like a_in.typedat
        AND Menu like a_in.menutype
        AND PageNumb like a_in.page_number
         AND (UserOption not like 'WW Physics' 
              OR use_wmask like 'Yes'
              ) 
             
      ;
BEGIN
   FOR a_rec IN dtype_cur
   LOOP
      IF a_in.header IS NOT NULL
      THEN
         print_string(to_char(a_in.header, 'S9'));
      ELSE
         print_string(flag);
      END IF;
      print_string(a_rec.Default_flag);
      IF a_rec.Action = ' ' OR a_rec.PageNumb = 10
      THEN      
          print_string(a_rec.UserOption);
      ELSE
          print_string(a_rec.UserOption || '^' || a_rec.Action);
      END IF;
      print_string;
   END LOOP;
EXCEPTION
  when others then
    htp.print('Unknown error, please contact ...');
END;

END fill_other_menus;


PROCEDURE kinbyyear
   (a_in IN args)
/*
|| MonteCarlo Data
|| Page 1 of the scanbook user interface
|| For a selected year returns a list of existing Kingal codes 
*/
IS
   flag VARCHAR2(10) := ' ';
   year_is MCSTAT.GeometryYear%TYPE := convert_year(a_in.mcyear);
   institute_number MCSTAT.IHomeLab%TYPE := convert_institute(a_in.institute);
   lep_category MCLEPENERGY.LepCategory%TYPE := give_lepcategory(a_in.mcyear);   

BEGIN

DECLARE
   CURSOR kin_cur IS
      SELECT KinCode, KinName, NumbPot, NumbMini
      FROM MCSTAT 
      WHERE  GeometryYear = year_is
         AND IHomelab = institute_number
         AND (GeometryYear != 1995 
              OR LepCategory like lep_category
              ) 
      ORDER by KinCode
      ;
BEGIN
    FOR a_rec IN kin_cur
    LOOP
       print_header(a_in.header,flag);
       print_string(a_rec.KinCode, '999999');
       print_string(a_rec.KinName, 12); 
       print_string(a_rec.NumbPot, '999999', 6);
       print_string(a_rec.NumbMini, '999999', 9);
       print_string;  
    END LOOP;

EXCEPTION
  when others then
    htp.print('Unknown error, please contact ...');
END;
END kinbyyear;


PROCEDURE give_particles_masses
   (a_in IN args)

/*
|| Monte Carlo data
|| Page 2 of the scanbook user interface
|| Returns the list of available particles' masses for a selected generator
*/
IS
   flag VARCHAR2(10) := ' ';
   institute_number MCKEYSTAT.IHomelab%TYPE := convert_institute(a_in.institute);
   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   year_is MCKEYSTAT.GeometryYear%TYPE := convert_year(a_in.mcyear);
   nrec INTEGER;

BEGIN
DECLARE

   CURSOR pm_cur IS
      SELECT distinct ParticleMass 
      FROM MCKEYSTAT
         WHERE KinCode like kin_code
           AND GeometryYear = year_is
           AND Ihomelab = institute_number
      ORDER by ParticleMass
      ;
BEGIN   
   nrec := 0;
   FOR a_rec IN pm_cur
   LOOP
      nrec := nrec + 1;
      print_header(a_in.header,flag);
      IF a_rec.ParticleMass = 0
      THEN
         print_string('Unknown');
      ELSE
         print_string(a_rec.ParticleMass, '999999');
      END IF;
      print_string;
   END LOOP;

/* 
|| If there is more than 1 Particle mass 
|| add 'ANY' in the menu and put it as default */
   IF nrec > 1
   THEN
      print_header(a_in.header,'*   ANY');
      print_string;
   END IF;

EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;
END give_particles_masses;


PROCEDURE kincomments
   (a_in IN args) 
/*
|| For MonteCarlo Data
|| Page 1 of the scanbook user interface
|| For a selected year, institute and kingal code, 
|| returns the description of the various productions
|| Not defined for years < 1996
*/
IS

   institute_number MCKEYSTAT.IHomelab%TYPE := convert_institute(a_in.institute);
   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   year_is MCKEYSTAT.GeometryYear%TYPE := convert_year(a_in.mcyear);
   nrec INTEGER;
   mass_is VARCHAR2(10);
   head INTEGER;
   flag VARCHAR2(10) := ' ';

   local_args args := a_in;

BEGIN

   mass_is := LTRIM(a_in.KinMass);
   IF a_in.KinMass is NULL OR INSTR(a_in.KinMass,'ANY') != 0
   THEN
      mass_is := '%';
   END IF;

DECLARE
   CURSOR kin_cur IS
   SELECT NumbPot, NumbMini, ExplainKeyword   
   FROM MCKEYSTAT 
      WHERE GeometryYear = year_is
        AND KinCode like kin_code
        AND IHomelab = institute_number
        AND ParticleMass like mass_is
     ;
BEGIN
   nrec := 0;
   head := 0;

   FOR a_rec IN kin_cur
   LOOP
      nrec := nrec + 1;
      print_header(head,flag);
      print_string(a_rec.NumbPot, '9999');
      print_string(a_rec.NumbMini, '9999', 2);
      print_string(': ' || a_rec.ExplainKeyword, 2);
      print_string;
   END LOOP; 
   
   IF nrec > 0 AND a_in.opt_arg = 'KinCode' 
   THEN
      local_args.header := head + 1;
      give_particles_masses(local_args);
   END IF;

EXCEPTION
  when others then
     htp.print('Unknown error, please contact ...');
END;
END kincomments;


PROCEDURE give_mclepenergy
   (a_in IN args)

/*
|| Monte Carlo data
|| Page 2 of the scanbook user interface
|| Returns the list of available Mcarlo Lep Energy for a selected year
*/
IS
   flag VARCHAR2(10) := ' ';
   loc_lepcat INTEGER;
   lep_category MCLEPENERGY.LepCategory%TYPE := NULL;   
   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   year_is MCLEPENERGY.GeometryYear%TYPE := convert_year(a_in.mcyear);
   nrec INTEGER;

BEGIN

   loc_lepcat := INSTR(a_in.mcyear, '/') + 1;
   IF loc_lepcat > 1                                          /* Year is 1995 */
   THEN 
      lep_category := SUBSTR(a_in.mcyear,loc_lepcat,LENGTH(a_in.mcyear));
   END IF;

DECLARE
   CURSOR e_cur IS
      SELECT RoundedEnergy 
      FROM MCLEPENERGY
         WHERE GeometryYear = year_is
           AND KinCode like kin_code
           AND LepCategory like NVL(lep_category,'%')
      ORDER by RoundedEnergy
      ;
BEGIN   
   nrec := 0;
   FOR a_rec IN e_cur
   LOOP
      nrec := nrec + 1;
      print_header(a_in.header,flag);
      print_string(a_rec.RoundedEnergy, '999999');
      print_string;
   END LOOP;
   
/* 
|| If there is more than 1 Lep energy 
|| add 'ANY' in the menu and put it as default */
   IF nrec > 1
   THEN
      print_header(a_in.header,'*   ANY');
      print_string;
   END IF;

EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;
END give_mclepenergy;


FUNCTION mcdata_found
   (a_in IN args)
/*
|| Monte Carlo data
|| Before designing page 2 of the scanbook user interface
|| check if data exist for the selections done
*/
   RETURN INTEGER
IS
   kinList Char_Tab;
   EmptyList Char_Tab;

   str VARCHAR2(300);
   first_word VARCHAR2(100);
   reste VARCHAR2(300);
   nstr INTEGER := 4;
   found INTEGER := 1;

BEGIN

   KinList := EmptyList;

/* Verify if datasets exist for the data_type selected by the user */
   str := a_in.kinlist;

   FOR i IN 1 .. nstr
   LOOP
      split_string(str,first_word,reste);
      KinList(i) := first_word;
      str := reste;
   END LOOP;

   IF (a_in.data_type = 'POT' AND kinList(3) = 0)  OR
      (a_in.data_type = 'MINI' AND kinList(4) = 0)
   THEN
      found := 0;
      print_string('-1 ** There are no ' || a_in.data_type || ' data for year ' ||
                      a_in.mcyear || ' kincode ' || kinList(1) || ' **'); 
      print_string;
   END IF;

   RETURN(found);

END mcdata_found;


PROCEDURE give_special_particles
    (a_in IN args)
/*
|| Monte Carlo data
|| Page 2 of the scanbook user interface
|| Returns the list of Special Particles according to some
|| selections done on Page 1 and Page 2
*/
IS
   flag VARCHAR2(10) := ' '; 
   institute_number MCSETS.IHomelab%TYPE := convert_institute(a_in.institute);
   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   year_is MCSETS.GeometryYear%TYPE := convert_year(a_in.mcyear);
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   lep_category MCLEPENERGY.LepCategory%TYPE := give_lepcategory(a_in.mcyear);
   nrec INTEGER;
   
BEGIN
DECLARE
   CURSOR sp_cur IS
      SELECT distinct mcp.ParticleName
      FROM MCPARTICLES mcp, MCSETS mc, MCLEPENERGY mclep
         WHERE mc.GeometryYear = year_is
           AND mc.KinCode like kin_code
           AND mc.Datatype like a_in.data_type
           AND mc.RoundedEnergy like lep_energy
           AND mc.IHomelab = institute_number
           AND mc.ParticleCode =  mcp.ParticleCode
           AND (mc.GeometryYear != 1995 
                OR (mc.GeometryYear = mclep.GeometryYear
                    AND mclep.LepCategory like lep_category) 
               )
      ;
BEGIN   
   nrec := 0;
   FOR a_rec IN sp_cur
   LOOP 
      nrec := nrec + 1;
      print_header(a_in.header,flag);
      print_string(a_rec.ParticleName);
      print_string;
   END LOOP;

/* 
|| If there is more than 1 special particle type 
|| add 'ANY' to the menu and put it as default
*/
   IF nrec > 1
   THEN	
      print_header(a_in.header,'*ANY');
      print_string;
   END IF;

EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;
END give_special_particles; 


PROCEDURE give_mcdatasets
   (a_in IN args)
/*
|| Monte Carlo data
|| Page 2 of the scanbook user interface
|| Returns the list of available Montecarlo Data according to some
|| selections done on Page 1 and Page 2
*/
IS
   flag VARCHAR2(10) := ' ';
   institute_number MCSETS.IHomelab%TYPE := convert_institute(a_in.institute);
   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   year_is  MCSETS.GeometryYear%TYPE := convert_year(a_in.mcyear);
   lep_energy VARCHAR2(10);
   lep_category MCLEPENERGY.LepCategory%TYPE := give_lepcategory(a_in.mcyear);   
   spec_par VARCHAR2(20) := convert_special_particles(a_in.specpar);
   mass_is VARCHAR2(10);
   kin_keyword MCSETS.KingalKeyWord%TYPE;
   nrec INTEGER;

BEGIN
   lep_energy := convert_lepenergy(a_in.energy_lep);
   kin_keyword := give_kinkeyword(a_in.kingal_conds,kin_code,year_is, 
                               institute_number);
   mass_is := LTRIM(a_in.KinMass);

DECLARE
      CURSOR mcdat_cur IS
      SELECT Datatype, GalephVersion, JuliaVersion, MiniVersion, count(*) nb_data
      FROM MCSETS msets
      WHERE  msets.GeometryYear = year_is
         AND msets.Datatype like a_in.data_type
         AND msets.RoundedEnergy like lep_energy
         AND msets.IHomelab = institute_number
         AND msets.KinCode like kin_code
         AND msets.KingalKeyWord like kin_keyword
         AND msets.ParticleMass like mass_is 
         AND EXISTS (
            SELECT * from MCPARTICLES mcp, MCLEPENERGY mclep
              WHERE msets.ParticleCode = mcp.ParticleCode
                AND mcp.ParticleName like spec_par
                AND (msets.GeometryYear != 1995 
                    OR (msets.GeometryYear = mclep.GeometryYear
                        AND mclep.LepCategory like lep_category) 
                    )
            ) 
      GROUP BY Datatype, GalephVersion, JuliaVersion, MiniVersion
      ;
BEGIN   
   nrec := 0;
   FOR a_rec IN mcdat_cur
   LOOP
      nrec := nrec + 1;
      print_header(a_in.header,flag);
      print_string(a_rec.GalephVersion , '999' , 3);
      print_string(a_rec.JuliaVersion  , '999' , 4);
      print_string(a_rec.MiniVersion   , '999' , 3);
      print_string(a_rec.nb_data, '999999' ,6);
      print_string;
   END LOOP;

EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;

END give_mcdatasets; 


PROCEDURE giveSpecMcDat
   (a_in IN args)
/*
|| Monte Carlo data
|| Page 2 of the scanbook user interface
|| Call the procedures to obtain the list of Special Particles 
|| and the list of datasets
|| according to some selections done on Page 1 and Page 2
*/
IS
   local_args args := a_in;

BEGIN

/* Execute the procedure give_special_particles */
   give_special_particles(a_in);

/* Execute the procedure give_mcdatasets */
   local_args.header := local_args.header + 1;
   give_mcdatasets(local_args);

END giveSpecMcDat; 


PROCEDURE give_processing_level
    (a_in IN args)
/*
|| Real Data
|| Page 2 of the scanbook user interface
|| This procedure is not executed if the data_type selected is 'RAW' or 'DRAW'
|| Returns the list of available datasets according to the
|| selections done on Page 1 and Page 2
*/

IS

   local_args args := a_in;

   RunFill VARCHAR2(500);

   sel_flag VARCHAR2(10);
   first_sel INTEGER;
   last_sel INTEGER;
   first_run INTEGER;
   last_run INTEGER;
   flag VARCHAR2(10) := ' ';
   nblanks INTEGER;

   institute_number DATASETS.IHomelab%TYPE := convert_institute(a_in.institute);
   phys_groups VARCHAR2(50):= fill_physgroups(a_in); 
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   year_is DATASETS.RawYear%TYPE := convert_year(a_in.datayear);
   MaxEnergyLEP1  INTEGER := to_number(give_default('MaxEnergyLEP1'));   
   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   
   first_cut INTEGER;
   last_cut  INTEGER;

BEGIN

/* Extract the run(s) or fill(s) selections */ 
   extract_from_runorfill(a_in.runorfill,first_sel,last_sel,sel_flag,RunFill);

/* For the selected year find the FirstRun and LastRun */ 
   extract_from_runbyyear(a_in.datayear,first_run,last_run);

/* A cut on lep energy has been selected */
   IF lep_energy = 'ANNE_CUT'
   THEN 
      first_cut := to_number(a_in.firstenergy_cut);
      last_cut  := to_number(a_in.lastenergy_cut);
   END IF;

DECLARE

   CURSOR yearunfill_cur IS
      SELECT dsets.ProcessLevel, MIN(dsets.Date_Proc) mindat, MAX(dsets.Date_Proc) maxdat, 
         dsets.JuliaVersion, dsets.MiniVersion, count(*) nb_data, 
         MIN(to_number(TRANSLATE(dsets.Complete_Proc,'TF','12'))) minproc  
      FROM DATASETS dsets
      WHERE 
            dsets.Ihomelab = institute_number 
        AND dsets.Datatype like a_in.data_type
        AND (a_in.selby != 'YEAR' OR dsets.RawYear = year_is)
        AND EXISTS 
           (select * from RUNSETS rsets, RUNCOND rcond 
              WHERE
                 rsets.DatasetsID = dsets.ID
                 AND (   
                      a_in.selby = 'YEAR'
                      OR 
                      (a_in.selby = 'RUN(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.Run between first_sel and last_sel)
                              OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.Run,'00000')) > 0)
                              )

                      )
                      OR 
                      (a_in.selby = 'FILL(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.LepFill between first_sel and last_sel)
                                OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.LepFill,'00000')) > 0)
                              )    
                      )  
                 )
                 AND rcond.RunNumb = rsets.Run
                 AND (
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy >= MaxEnergyLEP15)
                       OR 
                       (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut)
                       OR
                       (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15)
                       OR 
                       (rcond.RoundedEnergy like lep_energy)
                     ) 
                 AND rcond.RunSelection like phys_groups
                 AND (dsets.Rawyear != 1995 
                      OR rsets.Run between first_run AND last_run)
                 AND (a_in.runquality NOT like 'WW Physics'
                      OR rcond.RunNumb NOT IN
                         (SELECT bad.RunNb FROM WRUNSEL bad)
                 )
           )
      GROUP BY dsets.ProcessLevel, dsets.JuliaVersion, dsets.MiniVersion
   ; 

BEGIN

   FOR a_rec IN yearunfill_cur
    LOOP
       print_header(a_in.header,flag);
       print_string(a_rec.ProcessLevel,3);
       nblanks := 10 - LENGTH(a_rec.ProcessLevel);
       print_string(a_rec.nb_data, '99999', nblanks);
       print_string(a_rec.mindat, '99999999', 6);
       print_string (' to ');
       print_string(a_rec.maxdat, '99999999');
       print_string(a_rec.JuliaVersion, '999', 3);
       print_string(a_rec.MiniVersion, '999', 4);
       print_string(REPLACE(REPLACE(to_char(a_rec.minproc),'1','Yes'),'2','No '), 5);
       print_string; 

    END LOOP;

END;
END give_processing_level;


PROCEDURE give_WWBadRuns
   (a_in IN args)

/*
|| Real data
|| Returns the list of  WW bad runs defined by B.Bloch
|| The SYNONYM WWbad has been defined as bbloch.WBADRUNS      on DEVDB
||                                    as prod_bbloch.WBADRUNS on CERNDB1
*/
IS

   flag VARCHAR2(10) := ' ';
   nrec INTEGER;
   Luminosity NUMBER(10,3);

BEGIN

   print_header(0, '-');
   print_string(' FirstRun LastRun  Energy   Luminosity    Comments ');
   print_string;

DECLARE

   CURSOR bd_cur IS
      SELECT wbad.FirstRun, wbad.LastRun, wbad.RoundedEnergy, wbad.Commentaire, SUM(rcond.LUmin) sumlumi 
      FROM WWbad wbad, RUNCOND rcond
      WHERE 
            rcond.RunNumb between wbad.FirstRun AND wbad.LastRun
      GROUP by wbad.FirstRun, wbad.LastRun, wbad.RoundedEnergy, wbad.Commentaire
      ORDER BY wbad.RoundedEnergy, wbad.FirstRun 
      ;

BEGIN
   
   nrec := 0;
   FOR a_rec IN bd_cur
   LOOP
      nrec := nrec + 1;
      print_header(0,flag);
      print_string(a_rec.FirstRun, '999999', 2);
      print_string(a_rec.LastRun , '999999', 2);
      print_string(a_rec.RoundedEnergy, '999999',3);

      Luminosity := a_rec.sumlumi;
      print_string(Luminosity,'999999D999',2);

      print_string(a_rec.Commentaire,5);
      print_string;
   END LOOP;

EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;
END give_WWBadRuns;


PROCEDURE changed_lepenergy
   (a_in IN args)
IS

   local_args args := a_in;

BEGIN
   IF a_in.typedat = 'MC DATA'                                   
   THEN
      local_args.header := 0;
      local_args.specpar := 'ANY';
      giveSpecMcDat (local_args);
   END IF;

   IF a_in.typedat = 'Real DATA' 
   THEN
      local_args.header := 2;
      give_processing_level(local_args);
   END IF; 
                                 
END changed_lepenergy;


PROCEDURE give_datalepenergy
   (a_in IN args)
/*
|| Real Data
|| Page 2 of the scanbook user interface
|| For a given year, returns the list of available Data Lep Energies
|| For year 1997 there is a mixture of lep 1.5 and lep2
|| For years >= 2000 there can be some energy cuts defined in table
|| ENERGYCUTS
*/
IS

   flag VARCHAR2(10) := ' ';
   loc_lepcat INTEGER;
   lep_category ENERGYLEP.LepCategory%TYPE := NULL;   
   year_is ENERGYLEP.Year%TYPE := convert_year(a_in.datayear);
   nrec INTEGER;
   nfound INTEGER;
   Nsrun_per_line MENUDEFAULTS.ParamValue%TYPE := give_default('NbSRUN_per_line');   

   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   
   max_energy ENERGYLEP.RoundedEnergy%TYPE := 0;
   min_energy ENERGYLEP.RoundedEnergy%TYPE := 0;
   energy_cut1  ENERGYLEP.RoundedEnergy%TYPE;
   energy_cut2  ENERGYLEP.RoundedEnergy%TYPE;
   
BEGIN
   loc_lepcat := INSTR(a_in.datayear, '/') + 1;
   IF loc_lepcat > 1                             /* Year is 1995 */
   THEN 
      lep_category := SUBSTR(a_in.datayear,loc_lepcat,LENGTH(a_in.datayear));
   END IF;

DECLARE
   CURSOR energy_cur IS
      SELECT RoundedEnergy 
      FROM ENERGYLEP
         WHERE Year = year_is
           AND LepCategory like NVL(lep_category,'%')
      ORDER by RoundedEnergy
      ;
      energy_rec energy_cur%ROWTYPE;

   CURSOR cut_cur IS
      SELECT eng.cut1,eng.cut2 
      FROM ENERGYCUTS eng
         WHERE eng.DataYear like a_in.datayear
      ORDER by eng.cut2
      ;
      cut_rec cut_cur%ROWTYPE;

BEGIN   

   OPEN energy_cur;
   LOOP
      FETCH energy_cur INTO energy_rec;
      EXIT WHEN energy_cur%NOTFOUND;
   END LOOP;
   nfound := energy_cur%ROWCOUNT;
   CLOSE energy_cur;
 
/* 
|| Loop on all energies found for the selected year
|| Store the minimum and the maximum energies
|| Write the energies buttons
*/
   nrec := 0;
   OPEN energy_cur;
   LOOP
      FETCH energy_cur INTO energy_rec;
      EXIT WHEN energy_cur%NOTFOUND;
      nrec := nrec + 1;
      IF min_energy = 0 AND energy_rec.RoundedEnergy > MaxEnergyLEP15
      THEN
         min_energy := energy_rec.RoundedEnergy;
      END IF;
      IF nrec = nfound
      THEN
         max_energy := energy_rec.RoundedEnergy;
      END IF;
      print_header(a_in.header,flag);
      print_string(energy_rec.RoundedEnergy, '99999999');
      print_string;
   END LOOP;

   IF nfound > 1                     /* More than 1 lep energy found */   
   THEN
      IF year_is >= 2000
      THEN                           /* Write the energy cuts buttons */
         nrec := 0;                  
         OPEN cut_cur;
         LOOP
            FETCH cut_cur INTO cut_rec;
            EXIT WHEN cut_cur%NOTFOUND;
            nrec := nrec + 1;
            IF cut_rec.cut1 = 'MinEnergy'
            THEN
               energy_cut1 := min_energy;
            ELSE
               energy_cut1 := to_number(cut_rec.cut1);
            END IF;
            IF cut_rec.cut2 = 'MaxEnergy'
            THEN 
               energy_cut2 := max_energy;
            ELSE
               energy_cut2 := to_number(cut_rec.cut2);
            END IF;
            print_header(a_in.header,flag);
            print_string(energy_cut1, '999999');
            print_string('->');
            print_string(energy_cut2, '999999');
            print_string;
         END LOOP;
         CLOSE cut_cur;
      END IF;
/*
|| Write special buttons 
*/
      IF year_is = 1995 AND lep_category = 'LEP 1.5'              
      THEN
         print_header(a_in.header,'*ALL LEP1.5');
      ELSIF year_is >= 1996
      THEN 
         print_header(a_in.header,'      ANY');
         print_string;
         IF year_is = 1997 
         THEN 
            print_header(a_in.header,' ALL LEP1.5');
            print_string;
         END IF;
         print_header(a_in.header,'*ALL LEP2');
      ELSE
         print_header(a_in.header,'*     ANY');
      END IF;
      print_string;

   END IF;
   CLOSE energy_cur;
   
EXCEPTION
  WHEN others THEN
     htp.print('Unknown error, please contact ...');
END;
END give_datalepenergy;


PROCEDURE write_fili_srun
   (a_in IN args)
/*
|| Real Data
|| For Type of Data 'MINI', 'POT', 'DST', 'DPOT'
|| Page 3 of the scanbook user interface
|| Procedure executed by write_fili_srun_cards
|| Returns the list of FILI and SRUN cards according to the
|| selections done on Page 1 and Page 2
|| NB: Don't call the procedure extract_from_runbyyear  
||     because the select uses the processing line 
||     selected by the user. 
*/
IS
   local_args args := a_in;

   ProcessList Char_Tab;
   LepEnergyList Char_Tab;
   DsetsList Int_Tab;
   NbdsetsList Int_Tab;
   SRUNList Int_Tab;
   EmptyList Int_Tab;
   Empty2List Char_Tab;

   Phys_string VARCHAR2(300);

   sel_flag VARCHAR2(10);
   first_sel INTEGER;
   last_sel INTEGER;
   RunFill VARCHAR2(500);
   first_run INTEGER;
   last_run INTEGER;

   flag VARCHAR2(10) := ' ';

   fili_name VARCHAR2(4)    := 'FILI';
   edir_ft VARCHAR2(6)      := '.edir';
   bos_type VARCHAR2(4)     := 'EDIR';
   before_type VARCHAR2(10);
   fili_line VARCHAR2(500);

   cart_name VARCHAR2(17)   := 'ALDATA|EPIO|CART ';
   cart_label VARCHAR2(10);
   tape_file VARCHAR2(20);
   TapeNameFile VARCHAR2(20);
   size_file VARCHAR2(10);
   begin_line VARCHAR2(5);
   exclam VARCHAR2(10);
   
   nrec INTEGER;
   ntot_rec INTEGER;
   istart INTEGER;
   istop INTEGER;
   current_run INTEGER;
   lumin_tot NUMBER;

   lep_energy_gev VARCHAR2(10);
   lep_energy_reste VARCHAR2(10);
   lep_energy_print VARCHAR2(50);
   lep_energy_flag VARCHAR2(50) := '';

   first_date INTEGER;
   last_date  INTEGER;
   nb_run     INTEGER;
   nblanks    INTEGER;

   institute_number DATASETS.IHomelab%TYPE := convert_institute(a_in.institute);
   phys_groups VARCHAR2(50):= fill_physgroups(a_in); 
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   year_is DATASETS.RawYear%TYPE := convert_year(a_in.datayear);
   Nsrun_per_line MENUDEFAULTS.ParamValue%TYPE := give_default('NbSRUN_per_line');   
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   
   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   
   aledir_dir MENUDEFAULTS.ParamValue%TYPE;   

   first_cut INTEGER;
   last_cut  INTEGER;

BEGIN

   DsetsList := EmptyList;   
   SRUNList := EmptyList;
   LepEnergyList := Empty2List;

/* 
|| From the physgroups selections fill a string for print out
*/
   IF a_in.runquality = 'Phys. Groups' OR a_in.runquality = 'WW Physics'
   THEN 
      Phys_string := sprint_physgroups(phys_groups);
   END IF;

/* From the processing line selected fill the ProcessList list */ 
   ProcessList := extract_from_processline(a_in.processings,a_in.typedat);

   first_date := to_number(ProcessList(3));
   last_date  := to_number(ProcessList(4));

/* Extract the run(s) or fill(s) selections */ 
   extract_from_runorfill(a_in.runorfill,first_sel,last_sel,sel_flag,RunFill);

/* For the selected year find the FirstRun and LastRun */ 
   extract_from_runbyyear(a_in.datayear,first_run,last_run);

/* A cut on lep energy has been selected */
   IF lep_energy = 'ANNE_CUT'
   THEN 
      first_cut := to_number(a_in.firstenergy_cut);
      last_cut  := to_number(a_in.lastenergy_cut);
   END IF;

/*
|| If a single Lep Energy was selected by the user, set the argument filisorted to 'No '
*/
   local_args.energy_lep := lep_energy;

   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2' AND local_args.energy_lep != 'ANNE_CUT'
                                AND local_args.energy_lep != 'LEP1.5'
   THEN
      local_args.filisorted := 'No ';
   END IF;

/* Fill the Lep energies List  */
   give_LepEnergyList(local_args,LepEnergyList);

/* Fix the EDIR files directory to write the FILI cards */
   aledir_dir := a_in.aledir;
   IF a_in.aledir IS NULL OR LOWER(a_in.aledir) = 'default' 
   THEN
      aledir_dir := give_default('ALEDIR');
   END IF;        
   
   IF SUBSTR(aledir_dir,LENGTH(aledir_dir),1) != '/'
   THEN
      aledir_dir := aledir_dir || '/';
   END IF;

DECLARE

   CURSOR fili_cur (lepenergy_in VARCHAR2) 
   IS
      SELECT dsets.TapeId, dsets.TapeNumb, dsets.FileNumb, dsets.Details, dsets.FirstRun, 
             dsets.ExistEdir, dsets.SizeMbytes, dsets.ID
      FROM DATASETS dsets
      WHERE 
            dsets.Ihomelab = institute_number 
        AND (a_in.institute != 'CERN' OR dsets.CopyFlag = 0) 
        AND dsets.Datatype like a_in.data_type
        AND dsets.ProcessLevel like ProcessList(1)
        AND dsets.Date_Proc between first_date and last_date
        AND dsets.JuliaVersion like ProcessList(5)
        AND dsets.MiniVersion like ProcessList(6)
        AND (a_in.selby != 'YEAR' OR dsets.RawYear = year_is)
        AND EXISTS 
           (select * from RUNSETS rsets, RUNCOND rcond
              WHERE
                 rsets.DatasetsID = dsets.ID
                 AND (   
                      a_in.selby = 'YEAR' 
                      OR 
                      (a_in.selby = 'RUN(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.Run between first_sel and last_sel)
                              OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.Run,'00000')) > 0)
                              )
                      ) 
                      OR 
                      (a_in.selby = 'FILL(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.LepFill between first_sel and last_sel)
                                OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.LepFill,'00000')) > 0)
                              )    
                      )  
                 )
                 AND rcond.RunNumb = rsets.Run
                 AND (
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP15 AND lepenergy_in = 'LEP2')
                       OR 
                       (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut AND lepenergy_in = 'ANNE_CUT')
                       OR
                       (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15 AND lepenergy_in = 'LEP1.5')
                       OR
                       (rcond.RoundedEnergy like lepenergy_in)
                     ) 
                 AND rcond.RunSelection like phys_groups
                 AND (dsets.Rawyear != 1995 
                      OR rsets.Run between first_run AND last_run)
                 AND (a_in.runquality NOT like 'WW Physics'
                      OR rcond.RunNumb NOT IN
                         (SELECT bad.RunNb FROM WRUNSEL bad)
                 )
           )
      ORDER by dsets.FirstRun 
      ; 
      fili_rec fili_cur%ROWTYPE;


   CURSOR srun_cur (lepenergy_in VARCHAR2,id_in NUMBER)
   IS
      SELECT rsets.Run, rcond.LUmin
      FROM RUNSETS rsets, RUNCOND rcond
      WHERE 
         rsets.DatasetsID = id_in
         AND (   
             a_in.selby = 'YEAR' 
            OR 
            (a_in.selby = 'RUN(s)' 
                AND (
                      (sel_flag = 'btw' AND    
                         rsets.Run between first_sel and last_sel)
                    OR
                      (sel_flag = 'or ' AND
                         INSTR(RunFill,to_char(rsets.Run,'00000')) > 0)
                    )
            )    
            OR 
            (a_in.selby = 'FILL(s)' 
                AND (
                      (sel_flag = 'btw' AND    
                         rsets.LepFill between first_sel and last_sel)
                      OR
                      (sel_flag = 'or ' AND
                         INSTR(RunFill,to_char(rsets.LepFill,'00000')) > 0)
                    )    
            )  
      )
                 AND rcond.RunNumb = rsets.Run
                 AND (
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP15 AND lepenergy_in = 'LEP2')
                       OR 
                       (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut AND lepenergy_in = 'ANNE_CUT')
                       OR
                       (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15 AND lepenergy_in = 'LEP1.5')
                       OR 
                       (rcond.RoundedEnergy like lepenergy_in)
                     ) 
                 AND rcond.RunSelection like phys_groups
                 AND (a_in.runquality NOT like 'WW Physics'
                      OR rcond.RunNumb NOT IN
                         (SELECT bad.RunNb FROM WRUNSEL bad)
                 )
      ; 
      srun_rec srun_cur%ROWTYPE;

BEGIN
   
/* Date of FILI and SRUN cards creation */
   local_args.header := 2;
   write_datime('CARDS',local_args.header);
 
/* 
|| Write the FILI cards.
|| The format depends of the existence of the edir file
|| For 'DPOT' there are no edir files
|| Do a loop on the lep energies  
|| If the argument filisorted is set to 'Yes' write the lep energy 
|| at the end of the fili cards.
*/

   local_args.header := 0;
   ntot_rec := 0;
   lep_energy_flag := '';
 
   FOR jj IN 1 .. LepEnergyList.COUNT
   LOOP
      nrec := 0;
      OPEN fili_cur(LepEnergyList(jj));
      LOOP
         FETCH fili_cur INTO fili_rec;
         EXIT WHEN fili_cur%NOTFOUND;
         nrec := nrec + 1;
         ntot_rec := ntot_rec + 1;

         TapeNameFile := give_tape(fili_rec.TapeId,fili_rec.TapeNumb,fili_rec.FileNumb); 

         IF local_args.filisorted = 'Yes' AND nrec = 1 
         THEN
            print_string(to_char(local_args.header, 'S9'));
            lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
            lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                                LENGTH(LepEnergyList(jj)));
            lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
            lep_energy_flag := '^' || lep_energy_print;   
  
            print_string(' *** ==  For LEP energy = ' || 
                         lep_energy_print || ' GEV === ***' || lep_energy_flag);
            print_string;
         END IF;
         
/*
|| Check if Access with Edir was selected
|| If yes, for Tapeid like 'AM' or 'AB' suppress the '_1' in the TapeNameFile  
|| NB: For 'DPOT' there are no edir files
*/

         DsetsList(ntot_rec) := fili_rec.ID;

         IF a_in.data_type != 'DPOT' AND a_in.ediryesno = 'Yes' AND fili_rec.ExistEdir = 'T'
         THEN
            before_type := '| ';
            tape_file := LOWER(TapeNameFile);

            IF fili_rec.TapeId = 'AM' OR fili_rec.TapeId = 'AB'
            THEN
               tape_file := REPLACE(tape_file,'_1','');
               nblanks :=  9 - LENGTH(tape_file);
            ELSE
               nblanks := 11 - LENGTH(tape_file);
            END IF;

            FOR jk IN 1 .. nblanks
            LOOP
               before_type := ' ' || before_type;
            END LOOP;

            fili_line := fili_name || ' ''' || aledir_dir || 
                         tape_file || edir_ft || before_type || 
                         bos_type || '''  ! ' || fili_rec.Details || lep_energy_flag;
         ELSE
            tape_file := TapeNameFile;
            tape_file := REPLACE(tape_file,'_','.');

            size_file := '-s ' || to_char(fili_rec.SizeMbytes);
            nblanks := 11 - LENGTH(TapeNameFile);

            FOR jk IN 1 .. nblanks
            LOOP
               size_file := ' ' || size_file;
            END LOOP;

            cart_label := give_Cart_label(fili_rec.TapeId);

            exclam := '  ! ';
            IF fili_rec.SizeMbytes < 100
            THEN
               exclam := ' ' || exclam;
            END IF;
            fili_line := fili_name || ' ''' || cart_name ||
                         tape_file || cart_label || size_file || '''' ||
                         exclam || fili_rec.Details || lep_energy_flag;
         END IF;

         print_header(local_args.header,flag);
         print_string(SUBSTR(fili_line,1,LENGTH(fili_line)));
         print_string;      
      END LOOP;
      CLOSE fili_cur;
      NbdsetsList(jj) := nrec;

   END LOOP;

/* 
|| Write the SRUN cards.
|| Print the Phys. Groups or the WW Physics selection 
|| Do a loop on the lep energies 
|| If the argument filisorted is set to 'Yes' write the lep energy 
|| at the end of the srun cards.
|| Write a card NSEQ for alpha program.
*/
   local_args.header := local_args.header + 1;
   
   IF LENGTH(Phys_string) != 0
   THEN
      print_header(local_args.header,flag); 
      print_string('*');
      print_string;

      print_header(local_args.header,flag); 
      IF a_in.runquality = 'WW Physics'
      THEN
         print_string('***** Runs accepted by Phys. Tools Combinations (WW Physics) : ');
      ELSE
         print_string('***** Runs accepted by Phys. Tools Combinations : ');
      END IF;
      IF LENGTH(Phys_string) < 60
      THEN        
         print_string(Phys_string);
      ELSE
         print_string;
         print_header(local_args.header,flag); 
         print_string('*');
         print_string(Phys_string,5);
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      print_string('*');
      print_string;
   END IF;

   IF a_in.runquality = 'WW Physics'
   THEN
      IF wrunsel_exist(year_is) != 0
      THEN
         print_header(local_args.header,flag); 
         print_string('*');
         print_string;

         print_header(local_args.header,flag); 
         print_string('* Some Runs may have been excluded. To see their list you can: ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     See -> http://alephwww.cern.ch/~sical/Wlumi ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     Or from scanbook page 2 -> WW Physics -> WW bad runs -> View ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*');
         print_string;
      END IF;
   END IF;

   istart := 1;
   nb_run := 0;

   FOR jj IN 1 .. LepEnergyList.COUNT
   LOOP
      begin_line := 'SRUN ';

      lep_energy_flag := '';
      IF local_args.filisorted = 'Yes'
      THEN  
         lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
         lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
         lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
         lep_energy_flag := '^' || lep_energy_print;
      END IF;
   
      IF NbdsetsList(jj) != 0
      THEN 
         istop := istart + (NbdsetsList(jj)-1);
         FOR i IN istart .. istop
         LOOP
            OPEN srun_cur(LepEnergyList(jj),DsetsList(i));
            LOOP
               FETCH srun_cur INTO srun_rec;
               EXIT WHEN srun_cur%NOTFOUND;
               SRUNList(srun_rec.Run) := srun_rec.LUmin;
            END LOOP;
            CLOSE srun_cur;
         END LOOP;

/* Extract the runs in ascending order */
         lumin_tot := 0.;
         WHILE SRUNList.EXISTS(SRUNList.FIRST)
         LOOP
            current_run := SRUNList.FIRST;
            lumin_tot := lumin_tot + SRUNList(current_run);
            SRUNList.DELETE(current_run);
            IF nb_run = Nsrun_per_line 
            THEN
               print_string(lep_energy_flag);
               print_string;
               nb_run := 0;
            END IF;
            IF nb_run = 0
            THEN
               print_header(local_args.header,flag);
               print_string(begin_line);        
               begin_line := '     ';
            END IF;

            print_string(current_run,'99999',1);
            nb_run := nb_run + 1;

         END LOOP;

         IF nb_run != 0
         THEN
            print_string(lep_energy_flag);
            print_string;
         END IF;

/* Total luminosity for the "SRUN" runs selected */
         print_header(local_args.header,flag); 

         IF local_args.filisorted = 'Yes'
         THEN 
            print_string('***** Total Luminosity for above runs ' || 'at ' || 
                          lep_energy_print || ' GEV :   ' || to_char(lumin_tot) || 
                          ' nb**-1   ****' || lep_energy_flag);
         ELSE
            print_string('***** Total Luminosity for above runs ' || 
                          to_char(lumin_tot) || ' nb**-1   ****');
         END IF;
         print_string;
         istart := istop + 1;
         nb_run := 0;
         SRUNList := EmptyList;
      END IF;     

   END LOOP;

/*
|| Write the card NSEQ
*/
   print_header(local_args.header,flag); 
   print_string('*');
   print_string;

   print_header(local_args.header,flag); 
   print_string('* !!! Please DO NOT REMOVE the following card !!!');
   print_string;

   print_header(local_args.header,flag);
   print_string('NSEQ');
   print_string;
 
END;
END write_fili_srun;


PROCEDURE write_raw_fili_srun
   (a_in IN args)
/*
|| Real Data - For Type of Data 'RAW' or 'DRAW'
|| Page 3 of the scanbook user interface
|| Returns the list of FILI and SRUN cards according to the
|| selections done on Page 1 and Page 2
*/
IS
   local_args args := a_in;

   LepEnergyList Char_Tab;
   DsetsList Int_Tab;
   NbdsetsList Int_Tab;
   SRUNList Int_Tab;

   Phys_string VARCHAR2(300);

   EmptyList  Int_Tab;
   Empty2List Char_Tab;

   sel_flag  VARCHAR2(10);
   first_sel INTEGER;
   last_sel  INTEGER;
   RunFill   VARCHAR2(500);
   first_run INTEGER;
   last_run  INTEGER;

   flag VARCHAR2(10) := ' ';

   fili_name  VARCHAR2(4)    := 'FILI';
   fili_line  VARCHAR2(500);
   type_name  VARCHAR2(30)   := '.NAT | NATI | CART ';
   cart_name  VARCHAR2(30)   := 'ALDATA|EPIO|CART ';
   type_pr    VARCHAR2(30);
   cart_label VARCHAR2(10);
   tape_file  VARCHAR2(20);
   TapeNameFile VARCHAR2(20);
   run_fili     VARCHAR2(30);
   size_file    VARCHAR2(10);
   exclam       VARCHAR2(10);
   begin_line   VARCHAR2(5);
   details DATASETS.Details%TYPE;
   
   lep_energy_gev   VARCHAR2(10);
   lep_energy_reste VARCHAR2(10);
   lep_energy_print VARCHAR2(50);
   lep_energy_flag  VARCHAR2(50) := '';

   nrec     INTEGER;
   ntot_rec INTEGER;
   istart   INTEGER;
   istop    INTEGER;
   nzeros   INTEGER;

   current_run INTEGER;
   lumin_tot   NUMBER;

   first_date INTEGER;
   last_date  INTEGER;
   nb_run     INTEGER;
   nblanks    INTEGER;
   
   institute_number DATASETS.IHomelab%TYPE := convert_institute(a_in.institute);
   phys_groups VARCHAR2(50):= fill_physgroups(a_in); 
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   year_is DATASETS.RawYear%TYPE := convert_year(a_in.datayear);
   Nsrun_per_line MENUDEFAULTS.ParamValue%TYPE := give_default('NbSRUN_per_line');   
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   
   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   
 
   first_cut INTEGER;
   last_cut  INTEGER;
   
BEGIN
   
   DsetsList := EmptyList;   
   SRUNList := EmptyList;
   LepEnergyList := Empty2List;

/* 
|| From the physgroups selections fill a string for print out
*/
   IF a_in.runquality = 'Phys. Groups' OR a_in.runquality = 'WW Physics'
   THEN 
      Phys_string := sprint_physgroups(phys_groups);
   END IF;

/* Extract the run(s) or fill(s) selections */ 
   extract_from_runorfill(a_in.runorfill,first_sel,last_sel,sel_flag,RunFill);

/* For the selected year find the FirstRun and LastRun */ 
   extract_from_runbyyear(a_in.datayear,first_run,last_run);

/* A cut on lep energy has been selected */
   IF lep_energy = 'ANNE_CUT'
   THEN 
      first_cut := to_number(a_in.firstenergy_cut);
      last_cut  := to_number(a_in.lastenergy_cut);
   END IF;

/*
|| If a Lep Energy was selected by the user, set the argument filisorted to 'No '
|| Then, fill the Lep energies List
*/
   local_args.energy_lep := lep_energy;
   
   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2' AND local_args.energy_lep != 'ANNE_CUT'
                                AND local_args.energy_lep != 'LEP1.5'
   THEN
      local_args.filisorted := 'No ';
   END IF;

   give_LepEnergyList(local_args,LepEnergyList);

DECLARE

   CURSOR fili_cur (lepenergy_in VARCHAR2) 
   IS
      SELECT dsets.TapeId, dsets.TapeNumb, dsets.FileNumb, dsets.Details, dsets.FirstRun, 
             dsets.SizeMbytes, dsets.ID  
      FROM DATASETS dsets
      WHERE 
            dsets.Ihomelab = institute_number 
        AND (a_in.institute != 'CERN' OR dsets.CopyFlag = 0) 
        AND dsets.Datatype like a_in.data_type
        AND (a_in.selby != 'YEAR' OR dsets.RawYear = year_is)
        AND EXISTS 
           (select * from RUNSETS rsets, RUNCOND rcond 
              WHERE
                 rsets.DatasetsID = dsets.ID
                 AND (   
                      a_in.selby = 'YEAR' 
                      OR 
                      (a_in.selby = 'RUN(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.Run between first_sel and last_sel)
                              OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.Run,'00000')) > 0)
                              )
                      ) 
                      OR 
                      (a_in.selby = 'FILL(s)' 
                          AND (
                                (sel_flag = 'btw' AND    
                                   rsets.LepFill between first_sel and last_sel)
                                OR
                                (sel_flag = 'or ' AND
                                   INSTR(RunFill,to_char(rsets.LepFill,'00000')) > 0)
                              )    
                      )  
                 )
                 AND rcond.RunNumb = rsets.Run
                 AND (
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1 AND lepenergy_in = 'LEP2')
                       OR 
                       (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut AND lepenergy_in = 'ANNE_CUT')
                       OR
                       (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15 AND lepenergy_in = 'LEP1.5')
                       OR 
                       (rcond.RoundedEnergy like lepenergy_in)
                     ) 
                 AND rcond.RunSelection like phys_groups
                 AND (dsets.Rawyear != 1995 
                      OR rsets.Run between first_run AND last_run)
                 AND (a_in.runquality NOT like 'WW Physics'
                      OR rcond.RunNumb NOT IN
                         (SELECT bad.RunNb FROM WRUNSEL bad)
                 )
           )
      ORDER by dsets.FirstRun 
      ; 
      fili_rec fili_cur%ROWTYPE;


   CURSOR srun_cur (lepenergy_in VARCHAR2,id_in NUMBER)
   IS
      SELECT rsets.Run, rcond.LUmin
      FROM RUNSETS rsets, RUNCOND rcond
      WHERE 
         rsets.DatasetsID = id_in
         AND (   
             a_in.selby = 'YEAR' 
            OR 
            (a_in.selby = 'RUN(s)' 
                AND (
                      (sel_flag = 'btw' AND    
                         rsets.Run between first_sel and last_sel)
                    OR
                      (sel_flag = 'or ' AND
                         INSTR(RunFill,to_char(rsets.Run,'00000')) > 0)
                    )
            )    
            OR 
            (a_in.selby = 'FILL(s)' 
                AND (
                      (sel_flag = 'btw' AND    
                         rsets.LepFill between first_sel and last_sel)
                      OR
                      (sel_flag = 'or ' AND
                         INSTR(RunFill,to_char(rsets.LepFill,'00000')) > 0)
                    )    
            )
          )  
          AND rcond.RunNumb = rsets.Run
          AND (
               (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1 AND lepenergy_in = 'LEP2')
               OR 
               (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut AND lepenergy_in = 'ANNE_CUT')
               OR
               (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15 AND lepenergy_in = 'LEP1.5')
               OR 
               (rcond.RoundedEnergy like lepenergy_in)
          ) 
          AND rcond.RunSelection like phys_groups
            AND (a_in.runquality NOT like 'WW Physics'
               OR rcond.RunNumb NOT IN
                  (SELECT bad.RunNb FROM WRUNSEL bad)
          )
      ; 
      srun_rec srun_cur%ROWTYPE;

BEGIN
   
/* Date of FILI and SRUN cards creation */
   local_args.header := 2;
   write_datime('CARDS',local_args.header);

/* 
|| Write the FILI cards.
|| Do a loop on the lep energies  
|| If the argument filisorted is set to 'Yes' write the lep energy 
|| at the end of the fili cards.
*/

   local_args.header := 0;
   ntot_rec := 0;
   lep_energy_flag := '';

   FOR jj IN 1 .. LepEnergyList.COUNT
   LOOP
      nrec := 0;
      OPEN fili_cur(LepEnergyList(jj));
      LOOP
         FETCH fili_cur INTO fili_rec;
         EXIT WHEN fili_cur%NOTFOUND;
         nrec := nrec + 1;
         ntot_rec := ntot_rec + 1;
         
         TapeNameFile := give_tape(fili_rec.TapeId,fili_rec.TapeNumb,fili_rec.FileNumb); 
 
         IF local_args.filisorted = 'Yes' AND nrec = 1 
         THEN
            print_string(to_char(local_args.header, 'S9'));
            lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
            lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
            lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
            lep_energy_flag := '^' || lep_energy_print;   
  
            print_string(' *** ==  For LEP energy = ' || 
                          lep_energy_print || ' GEV === ***' || lep_energy_flag);
            print_string;
         END IF;

         DsetsList(ntot_rec) := fili_rec.ID;

         tape_file := TapeNameFile;
         tape_file := REPLACE(tape_file,'_','.');

         run_fili := to_char(fili_rec.FirstRun);
         nzeros := 7 - LENGTH(run_fili); 
         FOR kk IN 1 .. nzeros          
         LOOP
            run_fili := '0' || run_fili;
         END LOOP;
         run_fili := 'R' || run_fili;

         size_file := '-s ' || to_char(fili_rec.SizeMbytes);
         nblanks := 11 - LENGTH(TapeNameFile);
         FOR jk IN 1 .. nblanks
         LOOP
            size_file := ' ' || size_file;
         END LOOP;

         cart_label := give_Cart_label(fili_rec.TapeId);

         type_pr := type_name;
         details := '';
         exclam := '';

         IF a_in.data_type = 'DRAW' OR fili_rec.TapeId = 'R0' OR fili_rec.TapeId = 'ZD' 
         THEN
            run_fili := ''; 
            type_pr := cart_name;
            details :=  fili_rec.Details;

            exclam := '! ';
            nblanks := 4 - LENGTH(to_char(fili_rec.SizeMbytes));
            FOR jk IN 1 .. nblanks
            LOOP
               exclam := ' ' || exclam;
            END LOOP;

         END IF;
     
         fili_line := fili_name || ' ''' || run_fili || type_pr ||
                      tape_file || cart_label || size_file || '''' || 
                      exclam || details || lep_energy_flag;
         
         print_header(local_args.header,flag);
         print_string(SUBSTR(fili_line,1,LENGTH(fili_line)));
         print_string;      
      END LOOP;
      CLOSE fili_cur;
      NbdsetsList(jj) := nrec;
   END LOOP;

/* 
|| Write the SRUN cards. 
|| Print the Phys. Groups or the WW Physics selection 
|| Do a loop on the lep energies 
|| If the argument filisorted is set to 'Yes' write the lep energy 
|| at the end of the srun cards.
*/
   local_args.header := local_args.header + 1;

   IF LENGTH(Phys_string) != 0
   THEN
      print_header(local_args.header,flag); 
      print_string('*');
      print_string;

      print_header(local_args.header,flag); 
      IF a_in.runquality = 'WW Physics'
      THEN
         print_string('***** Runs accepted by Phys. Tools Combinations (WW Physics) : ');
      ELSE
         print_string('***** Runs accepted by Phys. Tools Combinations : ');
      END IF;
      IF LENGTH(Phys_string) < 60
      THEN        
         print_string(Phys_string);
      ELSE
         print_string;
         print_header(local_args.header,flag); 
         print_string('*');
         print_string(Phys_string,5);
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      print_string('*');
      print_string;
   END IF;

   IF a_in.runquality = 'WW Physics'
   THEN
      IF wrunsel_exist(year_is) != 0
      THEN
         print_header(local_args.header,flag); 
         print_string('*');
         print_string;

         print_header(local_args.header,flag); 
         print_string('* Some Runs may have been excluded. To see their list you can: ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     See -> http://alephwww.cern.ch/~sical/Wlumi ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     Or from scanbook page 2 -> WW Physics -> WW bad runs -> View ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*');
         print_string;
      END IF;
   END IF;

   istart := 1;
   nb_run := 0;

   FOR jj IN 1 .. LepEnergyList.COUNT
   LOOP
      begin_line := 'SRUN ';

      lep_energy_flag := '';
      IF local_args.filisorted = 'Yes'
      THEN  
         lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
         lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
         lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
         lep_energy_flag := '^' || lep_energy_print;
      END IF;
   
      IF NbdsetsList(jj) != 0
      THEN 
         istop := istart + (NbdsetsList(jj)-1);
         FOR i IN istart .. istop
         LOOP
            OPEN srun_cur(LepEnergyList(jj),DsetsList(i));
            LOOP
               FETCH srun_cur INTO srun_rec;
               EXIT WHEN srun_cur%NOTFOUND;
               SRUNList(srun_rec.Run) := srun_rec.LUmin;
            END LOOP;
            CLOSE srun_cur;
         END LOOP;

/* Extract the runs in ascending order */
         lumin_tot := 0.;
         WHILE SRUNList.EXISTS(SRUNList.FIRST)
         LOOP
            current_run := SRUNList.FIRST;
            lumin_tot := lumin_tot + SRUNList(current_run);
            SRUNList.DELETE(current_run);
            IF nb_run = Nsrun_per_line 
            THEN
               print_string(lep_energy_flag);
               print_string;
               nb_run := 0;
            END IF;
            IF nb_run = 0
            THEN
               print_header(local_args.header,flag);
               print_string(begin_line);        
               begin_line := '     ';
            END IF;

            print_string(current_run,'99999',1);
            nb_run := nb_run + 1;

         END LOOP;

         IF nb_run != 0
         THEN
            print_string(lep_energy_flag);
            print_string;
         END IF;

/* Total luminosity for the "SRUN" runs selected */
         print_header(local_args.header,flag); 

         IF local_args.filisorted = 'Yes'
         THEN 
            print_string('***** Total Luminosity for above runs ' || 'at ' || 
                          lep_energy_print || ' GEV :   ' || to_char(lumin_tot) || 
                          ' nb**-1   ****' || lep_energy_flag);
         ELSE
            print_string('***** Total Luminosity for above runs ' || 
                          to_char(lumin_tot) || ' nb**-1   ****');
         END IF;
         print_string;
         istart := istop + 1;
         nb_run := 0;
         SRUNList := EmptyList;
      END IF;     

   END LOOP;

/*
|| Write the card NSEQ
*/
   print_header(local_args.header,flag); 
   print_string('*');
   print_string;

   print_header(local_args.header,flag); 
   print_string('* !!! Please DO NOT REMOVE the following card !!!');
   print_string;

   print_header(local_args.header,flag);
   print_string('NSEQ');
   print_string;
 
END;
END write_raw_fili_srun;


PROCEDURE send_message
    (head IN INTEGER,
     menu_name IN VARCHAR2,
     option_name IN VARCHAR2)
/*
|| Real Data
|| Send a string to a menu
*/
IS
   flag VARCHAR2(10) := ' ';
BEGIN                
DECLARE
   CURSOR act_cur IS
      SELECT Action from OTHERMENUS
      WHERE Menu like menu_name
        AND UserOption like option_name
      ;
BEGIN
   FOR a_rec IN act_cur
   LOOP 
      print_header(head,flag);
      print_string(a_rec.Action);
      print_string;
   END LOOP;

END;   
END send_message;


PROCEDURE write_srun_RunsInfo
   (a_in IN args)
/*
|| Real Data
|| Page 3 of the scanbook user interface
|| Returns the list of SRUN cards according to the
|| selections done on Page 1 and Page 2
|| and a detailed output.
|| NB: Don't call the procedure extract_from_runbyyear  
||     because the select uses the table RUNBYYEAR
||     Just retrieve the lep category.
*/
IS
   local_args args := a_in;
   
   all_runs Runs_table; 
   all_fills Fills_table; 
   all_lepenergy Lepenergy_table;

   LepEnergyList Char_Tab;
   SRUNList Int_Tab;
   runQ Char_Tab;
   RunQList Char_Tab;

   Phys_string VARCHAR2(300);

   EmptyList Int_Tab;
   Empty2List Char_Tab;

   sel_flag  VARCHAR2(10);
   first_sel INTEGER;
   last_sel  INTEGER;
   RunFill   VARCHAR2(600);

   flag VARCHAR2(10) := ' ';

   begin_line   VARCHAR2(5);
   current_run  INTEGER;
   current_fill INTEGER;
   current_lepenergy INTEGER;
  
   lep_energy_gev VARCHAR2(10);
   lep_energy_reste VARCHAR2(10);
   lep_energy_print VARCHAR2(50);

   nb_run INTEGER;
   lumin_tot NUMBER;

   tot_NZ0Hadr   INTEGER := 0;            
   Run_per_fill  VARCHAR2(600) := ' ';
   Lumi_per_fill NUMBER(10,3);
   VdetLumi_per_fill NUMBER(10,3);
   vlum VARCHAR2(20);

   tot_GoodRuns INTEGER := 0;
   tot_Nbhabha  INTEGER := 0;
   tot_Lumi     NUMBER(10,3);
   tot_Nhadr    INTEGER := 0;
   tot_VdetLumi NUMBER(10,3);

   current_rq INTEGER;
   nb_runq    INTEGER;
   nwd        INTEGER;
   nblanks    INTEGER;
   phys_sel   VARCHAR2(60);
   istart     INTEGER;
   nwrite     INTEGER;
   runs_title VARCHAR2(200);

   rq_key  RUNQUALS.RunqualKeyword%TYPE;
   rq_desc RUNQUALS.ExplainRunqual%TYPE;
   run_sel RUNCOND.RunSelection%TYPE;

   phys_groups VARCHAR2(50):= fill_physgroups(a_in); 
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   lep_category ENERGYLEP.LepCategory%TYPE := give_lepcategory(a_in.datayear);   
   year_is RUNBYYEAR.Year%TYPE := convert_year(a_in.datayear);
   Nsrun_per_line MENUDEFAULTS.ParamValue%TYPE := give_default('NbSRUN_per_line'); 
   Nrun_per_fill MENUDEFAULTS.ParamValue%TYPE := give_default('NbRUN_per_fill'); 
   MaxEnergyLEP1  INTEGER := to_number(give_default('MaxEnergyLEP1'));   
   MaxEnergyLEP15 INTEGER := to_number(give_default('MaxEnergyLEP15'));   

   first_cut INTEGER;
   last_cut  INTEGER;

BEGIN

   SRUNList := EmptyList;
   LepEnergyList := Empty2List;
   RunQList := Empty2List;

/* 
|| Define the name of the luminosity (just for print)
*/
   vlum := 'VdetLumi';
   IF year_is < 1996     
   THEN 
      vlum := ' ';
   ELSIF year_is >= 2000
   THEN
      vlum := 'Miniramp';
   END IF;

/* 
|| From the physgroups selections fill a string for print out
*/
   IF a_in.runquality = 'Phys. Groups' OR a_in.runquality = 'WW Physics'
   THEN 
      Phys_string := sprint_physgroups(phys_groups);
   END IF;

/* Extract the run(s) or fill(s) selections */ 
   extract_from_runorfill(a_in.runorfill,first_sel,last_sel,sel_flag,RunFill);

/* A cut on lep energy has been selected */
   IF lep_energy = 'ANNE_CUT'
   THEN 
      first_cut := to_number(a_in.firstenergy_cut);
      last_cut  := to_number(a_in.lastenergy_cut);
   END IF;

/*
|| If a Lep Energy was selected by the user, set the argument filisorted to 'No '
|| Then, fill the Lep energies List
*/
   local_args.energy_lep := lep_energy;
   
   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2' AND local_args.energy_lep != 'ANNE_CUT'
                                AND local_args.energy_lep != 'LEP1.5'
   THEN
      local_args.filisorted := 'No ';
   END IF;

   give_LepEnergyList(local_args,LepEnergyList);

/* 3 first bits of the Run_quality */
   runQ(1) := 'DUCK';
   runQ(2) := 'MAYB';
   runQ(3) := 'PERF';

/* List of Run quality bits for the selected year */
   give_RunQList(year_is,RunQList);

DECLARE
   CURSOR srun_cur (lepenergy_in VARCHAR2)
   IS
      SELECT *
      FROM RUNCOND rcond
      WHERE 
              rcond.RunSelection like phys_groups
          AND (
               (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1 AND lepenergy_in = 'LEP2')
               OR 
               (lep_energy = 'ANNE_CUT' AND rcond.RoundedEnergy between first_cut AND last_cut AND lepenergy_in = 'ANNE_CUT')
               OR
               (lep_energy = 'LEP1.5' AND rcond.RoundedEnergy between MaxEnergyLEP1 AND MaxEnergyLEP15 AND lepenergy_in = 'LEP1.5')
               OR 
               (rcond.RoundedEnergy like lepenergy_in)
          ) 
            AND (a_in.runquality NOT like 'WW Physics'
              OR rcond.RunNumb NOT IN
              (SELECT bad.RunNb FROM WRUNSEL bad)
          )
          AND EXISTS 
             (select * from RUNBYYEAR runby
                 WHERE
                    (a_in.selby = 'YEAR'
                        AND (
                              runby.Year = year_is AND
                              runby.LepCategory like lep_category AND
                              rcond.RunNumb between runby.FirstRun and runby.LastRun)
                    )
                    OR 
                    (a_in.selby = 'RUN(s)' 
                        AND (
                              (sel_flag = 'btw' AND    
                                 rcond.RunNumb between first_sel and last_sel)
                            OR
                              (sel_flag = 'or ' AND
                                 INSTR(RunFill,to_char(rcond.RunNumb,'00000')) > 0)
                            )
                    )    
                    OR 
                    (a_in.selby = 'FILL(s)' 
                        AND (
                              (sel_flag = 'btw' AND    
                                 rcond.LepFill between first_sel and last_sel)
                            OR
                              (sel_flag = 'or ' AND
                                 INSTR(RunFill,to_char(rcond.LepFill,'00000')) > 0)
                            )    
                    )
             )
        ; 
        srun_rec srun_cur%ROWTYPE;

BEGIN

/* Date of SRUN cards creation */
   local_args.header := 2;
   write_datime('CARDS',local_args.header);

/*
|| Write the SRUN cards and fill the table all_runs for the output. 
|| Print the Phys. Groups or the WW Physics selection 
|| Do a loop on the lep energies 
|| If the argument filisorted is set to 'Yes' write the lep energy 
|| at the end of the srun cards.
*/
   local_args.header := 1;
   
   IF LENGTH(Phys_string) != 0
   THEN
      print_header(local_args.header,flag); 
      print_string('*');
      print_string;

      print_header(local_args.header,flag); 
      IF a_in.runquality = 'WW Physics'
      THEN
         print_string('***** Runs accepted by Phys. Tools Combinations (WW Physics) : ');
      ELSE
         print_string('***** Runs accepted by Phys. Tools Combinations : ');
      END IF;
      IF LENGTH(Phys_string) < 60
      THEN        
         print_string(Phys_string);
      ELSE
         print_string;
         print_header(local_args.header,flag); 
         print_string('*');
         print_string(Phys_string,5);
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      print_string('*');
      print_string;
   END IF;

   IF a_in.runquality = 'WW Physics'
   THEN
      IF wrunsel_exist(year_is) != 0
      THEN
         print_header(local_args.header,flag); 
         print_string('*');
         print_string;

         print_header(local_args.header,flag); 
         print_string('* Some Runs may have been excluded. To see their list you can: ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     See -> http://alephwww.cern.ch/~sical/Wlumi ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*     Or from scanbook page 2 -> WW Physics -> WW bad runs -> View ');
         print_string;

         print_header(local_args.header,flag); 
         print_string('*');
         print_string;
      END IF;
   END IF;

   nb_run := 0;

   FOR jj IN 1 .. LepEnergyList.COUNT
   LOOP
      begin_line := 'SRUN ';

      IF local_args.filisorted = 'Yes'
      THEN  
         lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
         lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
         lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
      END IF;
   
      OPEN srun_cur(LepEnergyList(jj));
      LOOP
         FETCH srun_cur INTO srun_rec;
         EXIT WHEN srun_cur%NOTFOUND;
         SRUNList(srun_rec.RunNumb) := srun_rec.LUmin;

         all_runs(srun_rec.RunNumb).LepFill  := srun_rec.LepFill;
         all_runs(srun_rec.RunNumb).WDate    := srun_rec.WritDate;
         all_runs(srun_rec.RunNumb).ExEnergy := srun_rec.ExactEnergy/1000;
         all_runs(srun_rec.RunNumb).EVnumb   := srun_rec.EVnumb;
         all_runs(srun_rec.RunNumb).NumZ0    := srun_rec.NumZ0;
         all_runs(srun_rec.RunNumb).NumBh    := srun_rec.NumBh;
         all_runs(srun_rec.RunNumb).LUmin    := srun_rec.LUmin;
         all_runs(srun_rec.RunNumb).VdetLumi := srun_rec.VdetLumi;
         all_runs(srun_rec.RunNumb).Runsel   := srun_rec.RunSelection;

/*
|| For year 2000 don't give the list by fill
*/
         IF year_is < 2000
         THEN 
            IF all_fills.EXISTS(srun_rec.LepFill)
            THEN
               tot_NZ0Hadr := tot_NZ0Hadr + srun_rec.NumZ0;
               all_fills(srun_rec.LepFill).NZ0Hadr := tot_NZ0Hadr;

               Run_per_fill := Run_per_fill || to_char(srun_rec.RunNumb,'99999');
               all_fills(srun_rec.LepFill).Runs := Run_per_fill;        

               Lumi_per_fill := Lumi_per_fill + srun_rec.LUmin;
               all_fills(srun_rec.LepFill).LUmin := Lumi_per_fill;        

               VdetLumi_per_fill := VdetLumi_per_fill + srun_rec.VdetLumi;
               all_fills(srun_rec.LepFill).VdetLumi := VdetLumi_per_fill;        
            ELSE
               all_fills(srun_rec.LepFill).LepFill := srun_rec.LepFill;
               all_fills(srun_rec.LepFill).WDate := srun_rec.WritDate;

               tot_NZ0Hadr := srun_rec.NumZ0;
               all_fills(srun_rec.LepFill).NZ0Hadr := tot_NZ0Hadr;

               all_fills(srun_rec.LepFill).ExEnergy := srun_rec.ExactEnergy/1000;

               Lumi_per_fill := srun_rec.LUmin;
               all_fills(srun_rec.LepFill).LUmin := Lumi_per_fill;        

               VdetLumi_per_fill := srun_rec.VdetLumi;
               all_fills(srun_rec.LepFill).VdetLumi := VdetLumi_per_fill;        

               Run_per_fill := to_char(srun_rec.RunNumb,'99999'); 
               all_fills(srun_rec.LepFill).Runs := Run_per_fill;
            END IF;

            IF all_fills(srun_rec.LepFill).NZ0Hadr < 0
            THEN
               all_fills(srun_rec.LepFill).NZ0Hadr := 0;
            END IF;
         END IF;

         IF all_lepenergy.EXISTS(srun_rec.RoundedEnergy)
         THEN
            tot_GoodRuns := all_lepenergy(srun_rec.RoundedEnergy).GoodRuns + 1;
            all_lepenergy(srun_rec.RoundedEnergy).GoodRuns := tot_GoodRuns;

            tot_Nbhabha := all_lepenergy(srun_rec.RoundedEnergy).Nbhabha + srun_rec.NumBh;
            all_lepenergy(srun_rec.RoundedEnergy).Nbhabha := tot_Nbhabha;

            tot_Lumi := all_lepenergy(srun_rec.RoundedEnergy).Lumi + srun_rec.Lumin;
            all_lepenergy(srun_rec.RoundedEnergy).Lumi := tot_Lumi;

            tot_Nhadr := all_lepenergy(srun_rec.RoundedEnergy).Nhadr + srun_rec.NumZ0;
            all_lepenergy(srun_rec.RoundedEnergy).Nhadr := tot_Nhadr;

            tot_VdetLumi := all_lepenergy(srun_rec.RoundedEnergy).VdetLumi + srun_rec.VdetLumi;
            all_lepenergy(srun_rec.RoundedEnergy).VdetLumi := tot_VdetLumi;
         ELSE
            all_lepenergy(srun_rec.RoundedEnergy).RoundedEnergy := srun_rec.RoundedEnergy;
            all_lepenergy(srun_rec.RoundedEnergy).GoodRuns := 1;
            all_lepenergy(srun_rec.RoundedEnergy).Nbhabha := srun_rec.NumBh;
            all_lepenergy(srun_rec.RoundedEnergy).Lumi := srun_rec.Lumin;
            all_lepenergy(srun_rec.RoundedEnergy).Nhadr := srun_rec.NumZ0;
            all_lepenergy(srun_rec.RoundedEnergy).VdetLumi := srun_rec.VdetLumi;
         END IF;
      END LOOP;
      CLOSE srun_cur;


/* Extract the runs in ascending order and write the SRUN cards */
      lumin_tot := 0.;
      WHILE SRUNList.EXISTS(SRUNList.FIRST)
      LOOP
         current_run := SRUNList.FIRST;
         lumin_tot := lumin_tot + SRUNList(current_run);
         SRUNList.DELETE(current_run);
         IF nb_run = Nsrun_per_line 
         THEN
            print_string;
            nb_run := 0;
         END IF;
         IF nb_run = 0
         THEN
            print_header(local_args.header,flag);
            print_string(begin_line);        
            begin_line := '     ';
         END IF;

         print_string(current_run,'99999',1);
         nb_run := nb_run + 1;

      END LOOP;

      IF nb_run != 0
      THEN
         print_string;
      END IF;

/* Total luminosity for the "SRUN" runs selected */
      print_header(local_args.header,flag); 

      IF local_args.filisorted = 'Yes'
      THEN
         print_string('***** Total Luminosity for above runs ' || 'at ' || 
                       lep_energy_print || ' GEV :   ' || to_char(lumin_tot) || 
                       ' nb**-1   ****');
      ELSE
         print_string('***** Total Luminosity for above runs ' || 
                       to_char(lumin_tot) || ' nb**-1   ****');
      END IF;

      print_string;
      nb_run := 0;
      SRUNList := EmptyList;

   END LOOP;

/*
|| Write the card NSEQ
*/
   print_header(local_args.header,flag); 
   print_string('*');
   print_string;

   print_header(local_args.header,flag); 
   print_string('* !!! Please DO NOT REMOVE the following card !!!');
   print_string;

   print_header(local_args.header,flag);
   print_string('NSEQ');
   print_string;

/* Write the output */
   local_args.header := 3;

   FOR ii IN 1 ..2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   runs_title := '    *********** Printout of RUNs informations according to ' ||
                'the selections done by the user ***********'; 
   print_string(runs_title);
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

/* Print List by Run */
   print_header(local_args.header,flag); 
   print_string('               ====> In the TABLE below : <====');
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;
   
   print_header(local_args.header,flag); 
   print_string(' For < Status of Physics Tools Selection > item :');
   print_string;

   nb_runq := 0;
   current_rq := RunQList.FIRST;
   LOOP
      EXIT when current_rq is NULL;

      nwd := LENGTH(RunQList(current_rq));
      rq_key := SUBSTR(RunQList(current_rq),1,2);
      rq_desc := SUBSTR(RunQList(current_rq),4,nwd-3);

      IF nb_runq = 3
      THEN
         print_string;
         nb_runq := 0;
      END IF;

      IF nb_runq = 0
      THEN
         print_header(local_args.header,flag);
         print_string(rq_key, 5);
         print_string(' : ');
         print_string(rq_desc, 2);
         nblanks := 25 - LENGTH(rq_desc);
      ELSE
         print_string(rq_key, nblanks);
         print_string(' : ');
         print_string(rq_desc, 2);
         nblanks := 25 - LENGTH(rq_desc);
      END IF;

      nb_runq := nb_runq + 1;
      current_rq := RunQList.NEXT(current_rq);

   END LOOP;
   IF nb_runq != 0
   THEN
      print_string;
   END IF;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
   print_string;

   print_header(local_args.header,flag); 

   IF vlum = ' '
   THEN
      print_string('  Run  LepFill  Date    Exact     Number of Events    ' ||
                  'Lumi         Status   of                ');
   ELSE
      print_string('  Run  LepFill  Date    Exact     Number of Events    ' ||
                   'Lumi   ' || vlum || '    Status   of                ');
   END IF;
   print_string;

   print_header(local_args.header,flag); 

   IF vlum = ' '
   THEN
      print_string('               yymmdd   Energy   Total  Hadr  Bhab ' ||
                   '  nb**-1    RunQ   Physics Tools Selections');
   ELSE
   print_string('               yymmdd   Energy   Total  Hadr  Bhab ' ||
                   '  nb**-1   nb**-1    RunQ   Physics Tools Selections');
   END IF;
   print_string;  

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
   print_string;

   current_run := all_runs.FIRST;
   LOOP
      EXIT when current_run is NULL;

      print_header(local_args.header,flag); 
      print_string(current_run,'99999',1);
      print_string(all_runs(current_run).LepFill,'99999',1);
      print_string(all_runs(current_run).WDate,'99999999',2);
      print_string(all_runs(current_run).ExEnergy,'999D999',1);
      print_string(all_runs(current_run).EVnumb,'999999',2);
      print_string(all_runs(current_run).NumZ0,'9999',2);
      print_string(all_runs(current_run).NumBh,'9999',2);
      print_string(all_runs(current_run).LUmin,'999D999',2);
      IF vlum != ' '
      THEN
         print_string(all_runs(current_run).VdetLUmi,'999D999',2);
      END IF;

      run_sel := all_runs(current_run).Runsel;
     
/* Loop on the 3 first bits of the run_quality */
      FOR iq IN 1 .. 3
      LOOP
          IF SUBSTR(run_sel,iq,1) = 'T'
          THEN
             print_string(runQ(iq), 4);
             EXIT;
          END IF;
      END LOOP;

/* Print the Physics Tools Selections */
      phys_sel := ' ';
      current_rq := RunQList.FIRST;
      LOOP
         EXIT when current_rq is NULL;
         IF SUBSTR(run_sel,current_rq,1) = 'T'
         THEN
            phys_sel := phys_sel || SUBSTR(RunQList(current_rq),1,2) || ' ';
         ELSE
            phys_sel := phys_sel || '   ';
         END IF;
         current_rq := RunQList.NEXT(current_rq);
      END LOOP;

      print_string(phys_sel,2);
      print_string;
         
      current_run := all_runs.NEXT(current_run);

   END LOOP;

/* Print List by Fill 
|| For year 2000 don't give the list by fill
*/
   IF year_is < 2000
   THEN 
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
      print_string;

      print_header(local_args.header,flag); 
      IF vlum = ' '
      THEN
         print_string('  Fill   Date      Exact    NZ0         Lumi      List of runs for this Fill ');
      ELSE
         print_string('  Fill   Date      Exact    NZ0         Lumi      '|| vlum || '    List of runs for this Fill ');
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      IF vlum = ' '
      THEN
         print_string('         yymmdd    Energy   Hadr        nb**-1' );
      ELSE
         print_string('         yymmdd    Energy   Hadr        nb**-1     nb**-1' );
      END IF;
      print_string;  

      print_header(local_args.header,flag); 
      print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
      print_string;

      current_fill := all_fills.FIRST;
      nb_run := 0;
      LOOP
         EXIT when current_fill is NULL;
         nb_run := LENGTH(all_fills(current_fill).Runs) / 6;
         print_header(local_args.header,flag); 
         print_string(current_fill,'99999',1);
         print_string(all_fills(current_fill).Wdate,'99999999',2);
         print_string(all_fills(current_fill).ExEnergy,'999D999',2);
         print_string(all_fills(current_fill).NZ0Hadr,'99999',2);
         print_string(all_fills(current_fill).LUmin,'999999D999',3);
      
         IF vlum != ' '
         THEN
            print_string(all_fills(current_fill).VdetLumi,'999999D999',2);
         END IF;

         nwrite := 0;
         FOR nr IN 1 .. nb_run
         LOOP
            istart := nr * 6 - 5;
            IF nwrite = Nrun_per_fill 
            THEN
               print_string;
               nwrite := 0;
            END IF;
            IF nwrite = 0 
            THEN
               IF istart = 1                       
               THEN
                  print_string(SUBSTR(all_fills(current_fill).Runs,istart,6), 4);
                  nwrite := nwrite + 1;
               ELSE
                  print_header(local_args.header,flag);
                  IF vlum = ' '
                  THEN
                     print_string(' ',45);
                  ELSE
                     print_string(' ',60);
                  END IF;
                  print_string(SUBSTR(all_fills(current_fill).Runs,istart,6));
                  nwrite := nwrite + 1;
               END IF;
            ELSE
               print_string(SUBSTR(all_fills(current_fill).Runs,istart,6));
               nwrite := nwrite + 1;
            END IF;
         END LOOP;
      
         IF nwrite != 0
         THEN
            print_string;
         END IF;

         current_fill := all_fills.NEXT(current_fill);

      END LOOP;
   END IF;

   FOR ii IN 1 ..2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   print_string('    *********** Total Statistics by Lep Energy ***********');
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
   print_string;

   print_header(local_args.header,flag); 
   IF vlum = ' '
   THEN
      print_string('  Nominal LEP     Number of     Number of       Luminosity       Number of  ');
   ELSE
      print_string('  Nominal LEP     Number of     Number of       Luminosity       Number of           ' || vlum );
   END IF;
   print_string;

   print_header(local_args.header,flag); 
   IF vlum = ' '
   THEN
      print_string('  energy (Gev)    Good Runs      Bhabhas         nb**-1        e+ e- -> Hadrons    ');
   ELSE 
      print_string('  energy (Gev)    Good Runs      Bhabhas         nb**-1        e+ e- -> Hadrons       nb**-1 ');
   END IF;
   print_string;  

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------' ||
                '-------------------------------------------------------');
   print_string;

   current_lepenergy := all_lepenergy.FIRST;
   LOOP
      EXIT when current_lepenergy is NULL;

      print_header(local_args.header,flag); 

      lep_energy_gev := SUBSTR(to_char(current_lepenergy),1,LENGTH(to_char(current_lepenergy))-3);
      lep_energy_reste := SUBSTR(to_char(current_lepenergy),LENGTH(to_char(current_lepenergy))-2,
                          LENGTH(to_char(current_lepenergy)));
      lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
  
      nblanks := 11  - LENGTH(lep_energy_print);
      print_string(lep_energy_print,nblanks);

      print_string(all_lepenergy(current_lepenergy).GoodRuns, '99999999',5);
      print_string(all_lepenergy(current_lepenergy).Nbhabha, '999999999',6);

      print_string(all_lepenergy(current_lepenergy).Lumi,'999999D999',7);

      print_string(all_lepenergy(current_lepenergy).Nhadr, '999999999',7);

      IF vlum != ' '
      THEN
         print_string(all_lepenergy(current_lepenergy).VdetLumi,'999999D999',12);
      END IF;

      print_string;
      current_lepenergy := all_lepenergy.NEXT(current_lepenergy);

   END LOOP;

END;
END write_srun_RunsInfo;


PROCEDURE write_Data_CartInfo
   (a_in IN args,
    tape_id IN VARCHAR2,
    tape_num IN INTEGER,
    tape_file IN INTEGER)
/*
|| Real Data
|| Page 3 of the scanbook user interface
|| Writes an output file containing informations on
|| a cartridge selected by the user on page 1
*/
IS
   local_args args := a_in;

   all_tapes Tapes_table;
   all_runs  Tapes_Runs_table;

   tape_and_file INTEGER;
   tape_is VARCHAR2(20);
   nrec INTEGER;
   current_tape INTEGER;
   current_run INTEGER;
   tot_Evt INTEGER := 0;
   Run_per_tape VARCHAR2(1500) := ' ';
   nb_run INTEGER;
   istart INTEGER;
   nwrite INTEGER;
   flag VARCHAR2(10) := ' ';
   nblanks INTEGER;
   tot_class16 INTEGER := 0;
   start_run INTEGER;
   nrun_per_tape INTEGER;
   if_file VARCHAR2(50);
   tape_title VARCHAR2(200);

   ifirst    INTEGER;
   ilast     INTEGER;
   nrun_file INTEGER;
   start_run_file INTEGER;

   Maxrun_per_tape MENUDEFAULTS.ParamValue%TYPE := give_default('NbRUN_per_tape'); 

BEGIN
DECLARE

   CURSOR tapes_cur
   IS
      SELECT dsets.ID, dsets.TapeId, dsets.TapeNumb, dsets.FileNumb, dsets.TMSLocation,
             dsets.Details, dsets.Datatype, dsets.FirstRun, dsets.LastRun, dsets.Date_Proc, 
             dsets.JuliaVersion, dsets.MiniVersion, dsets.CopyFlag, dsets.SizeMbytes,
             dsets.ProcessLevel,
             rcond.RunNumb, rcond.ExactEnergy, rcond.EVnumb, rcond.NumZ0 
      FROM DATASETS dsets, RUNCOND rcond, RUNSETS rsets
      WHERE 
           dsets.TapeId like tape_id
        AND dsets.TapeNumb = tape_num
        AND (tape_file = 0 OR dsets.FileNumb = tape_file)
        AND rsets.DatasetsID = dsets.ID
        AND rcond.RunNumb = rsets.Run
        ORDER by dsets.TapeId,dsets.TapeNumb,dsets.FileNumb
      ; 
      tapes_rec tapes_cur%ROWTYPE;

BEGIN

/* Date of OUTPUT creation */
   local_args.header := 2;
   write_datime('OUTPUT',local_args.header);

/*
|| For each TapeNameFile fill the tables all_tapes and all_runs
*/
   start_run := 0;
   nrun_per_tape := 1;
   nrec := 0;
   OPEN tapes_cur;
   LOOP
      FETCH tapes_cur INTO tapes_rec;
      EXIT WHEN tapes_cur%NOTFOUND;
      nrec := nrec + 1;

      tape_and_file := tapes_rec.TapeNumb * 1000 + tapes_rec.FileNumb;
      tape_is := give_tape(tapes_rec.TapeId,tapes_rec.TapeNumb,tapes_rec.FileNumb); 

      IF all_tapes.EXISTS(tape_and_file)
      THEN      
         tot_evt := tot_evt + tapes_rec.EVnumb;
         all_tapes(tape_and_file).Nevts := tot_evt;

         tot_class16 := tot_class16 + tapes_rec.NumZ0;
         all_tapes(tape_and_file).Nclass16 := tot_class16;

         Run_per_tape := Run_per_tape || to_char(tapes_rec.RunNumb,'99999');
         all_tapes(tape_and_file).Runs := Run_per_tape;
 
         nrun_per_tape := nrun_per_tape + 1;
         all_tapes(tape_and_file).Nb_run := nrun_per_tape;

         all_runs(nrec).RunNb := tapes_rec.RunNumb;
         all_runs(nrec).ExEnergy := tapes_rec.ExactEnergy/1000;
         all_runs(nrec).Nclass16 := tapes_rec.NumZ0;

      ELSE
         tot_evt := tapes_rec.EVnumb;
         all_tapes(tape_and_file).Nevts := tot_evt;

         tot_class16 := tapes_rec.NumZ0;
         all_tapes(tape_and_file).Nclass16 := tot_class16;

         Run_per_tape := to_char(tapes_rec.RunNumb,'99999');
         all_tapes(tape_and_file).Runs := Run_per_tape;
         
         all_tapes(tape_and_file).Tape := tape_is; 
         all_tapes(tape_and_file).Nature := tapes_rec.Datatype; 
         all_tapes(tape_and_file).Proc_date := tapes_rec.Date_Proc; 
         all_tapes(tape_and_file).Location := tapes_rec.TMSLocation; 
         all_tapes(tape_and_file).First_run := tapes_rec.FirstRun; 
         all_tapes(tape_and_file).Last_run := tapes_rec.LastRun;
         all_tapes(tape_and_file).ExEnergy := tapes_rec.ExactEnergy/1000;
         all_tapes(tape_and_file).Details := tapes_rec.Details;
         all_tapes(tape_and_file).JulVersion :=  tapes_rec.JuliaVersion;
         all_tapes(tape_and_file).MinVersion :=  tapes_rec.MiniVersion;
         all_tapes(tape_and_file).ProcLevel :=  tapes_rec.ProcessLevel;
         all_tapes(tape_and_file).CopyFlag := tapes_rec.CopyFlag;
         all_tapes(tape_and_file).SizeMbytes := tapes_rec.SizeMbytes;
         all_tapes(tape_and_file).Nb_run := nrun_per_tape;

         all_tapes(tape_and_file).Program := give_default(tapes_rec.Datatype); 
         all_runs(nrec).RunNb := tapes_rec.RunNumb;
         all_runs(nrec).ExEnergy := tapes_rec.ExactEnergy/1000;
         all_runs(nrec).Nclass16 := tapes_rec.NumZ0;

         start_run := start_run + nrun_per_tape; 
         all_tapes(tape_and_file).Start_run := start_run;
         all_tapes(tape_and_file).Nb_run := nrun_per_tape;
         nrun_per_tape := 1;

      END IF;

   END LOOP;
   CLOSE tapes_cur;

/* Write the output */
   local_args.header := local_args.header + 1;

/* Print List by Tape file */
   FOR ii IN 1 .. 2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   print_string('                  *********** Printout of Informations');

   if_file := ' ';
   IF tape_file != 0
   THEN
      if_file := '.' || to_char(tape_file);
   END IF;
   tape_title := ' for TAPE ' || tape_id || to_char(tape_num) || if_file || 
                 ' *********** ';

   print_string(tape_title);
   print_string;

   FOR ii IN 1 .. 2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------------' ||
                '------------------------------------------------------------------');
   print_string;

   print_header(local_args.header,flag); 
   print_string('    Tape      Nature   Date    Location     1st     Last    Nevts    Lep Energy  ' ||
                '          Comments ');
   print_string;
   print_header(local_args.header,flag); 
   print_string('                      yymmdd                Run     Run               Gev ');
   print_string;  

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------------' ||
                '------------------------------------------------------------------');
   print_string;

   current_tape := all_tapes.FIRST;
   nb_run := 0;
   LOOP
      EXIT when current_tape IS NULL;

      nb_run := LENGTH(all_tapes(current_tape).Runs) / 6;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Tape,2);

      nblanks := 13 - LENGTH(all_tapes(current_tape).Tape);
      print_string(all_tapes(current_tape).Nature,nblanks);

      print_string(all_tapes(current_tape).Proc_date,'99999999',3);
      print_string(all_tapes(current_tape).Location,3);
      print_string(all_tapes(current_tape).First_run,'99999',7);
      print_string(all_tapes(current_tape).Last_run,'99999',3);
      print_string(all_tapes(current_tape).Nevts,'9999999',3);
      print_string(all_tapes(current_tape).ExEnergy,'999D999',4);

      nwrite := 0;
      FOR nr IN 1 .. nb_run
      LOOP
         istart := nr * 6 - 5;
         IF nwrite = Maxrun_per_tape 
         THEN
            print_string;
            nwrite := 0;
         END IF;
         IF nwrite = 0 
         THEN
            IF istart = 1                       
            THEN
               print_string('    RUNS');
               print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
               nwrite := nwrite + 1;
            ELSE
               print_header(local_args.header,flag);
               print_string(' ',84);
               print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
               nwrite := nwrite + 1;
            END IF;
         ELSE
            print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
            nwrite := nwrite + 1;
         END IF;
      END LOOP;
      
      IF nwrite != 0
      THEN
         print_string;
      END IF;

      current_tape := all_tapes.NEXT(current_tape);

   END LOOP;

/* Print details on Runs by Tape and file */
   FOR ii IN 1 .. 3
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   print_string('                  *************** Detailed printout ***************');
   print_string;

/* Loop again on tape files and print details for Runs which reside on selected files */
   current_tape := all_tapes.FIRST;
   nb_run := 0;
   LOOP
      EXIT when current_tape IS NULL;
      IF tape_file = 0
      THEN
         nb_run := LENGTH(all_tapes(current_tape).Runs) / 6;
         
         FOR ii IN 1 .. 3
         LOOP
            print_header(local_args.header,flag); 
            print_string(' ');
            print_string;
         END LOOP;

         print_header(local_args.header,flag); 
         print_string('-------------------------------------------------------------' ||
                      '------------------------------------------------------------------');
         print_string;

         print_header(local_args.header,flag); 
         print_string('    Tape      Nature   Date    Location     1st     Last    Nevts    Lep Energy  ' ||
                      '          Comments ');
         print_string;
         print_header(local_args.header,flag); 
         print_string('                      yymmdd                Run     Run               Gev ');
         print_string;  

         print_header(local_args.header,flag); 
         print_string('-------------------------------------------------------------' ||
                      '------------------------------------------------------------------');
         print_string;

         print_header(local_args.header,flag); 
         print_string(all_tapes(current_tape).Tape,2);

         nblanks := 13 - LENGTH(all_tapes(current_tape).Tape);
         print_string(all_tapes(current_tape).Nature,nblanks);

         print_string(all_tapes(current_tape).Proc_date,'99999999',3);
         print_string(all_tapes(current_tape).Location,3);
         print_string(all_tapes(current_tape).First_run,'99999',7);
         print_string(all_tapes(current_tape).Last_run,'99999',3);
         print_string(all_tapes(current_tape).Nevts,'9999999',3);
         print_string(all_tapes(current_tape).ExEnergy,'999D999',4);

         nwrite := 0;
         FOR nr IN 1 .. nb_run
         LOOP
            istart := nr * 6 - 5;
            IF nwrite = Maxrun_per_tape 
            THEN
               print_string;
               nwrite := 0;
            END IF;
            IF nwrite = 0 
            THEN
               IF istart = 1                       
               THEN
                  print_string('    RUNS');
                  print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
                  nwrite := nwrite + 1;
               ELSE
                  print_header(local_args.header,flag);
                  print_string(' ',84);
                  print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
                  nwrite := nwrite + 1;
               END IF;
            ELSE
               print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
               nwrite := nwrite + 1;
            END IF;
         END LOOP;
      
         IF nwrite != 0
         THEN
            print_string;
         END IF;
      END IF;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string('Real Data  Production:');
      print_string;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Details);
      print_string;

      IF INSTR(all_tapes(current_tape).Nature,'RAW') = 0
      THEN 
         print_header(local_args.header,flag); 
         print_string('Date : ');
         print_string(all_tapes(current_tape).Proc_Date);
         print_string;

         print_header(local_args.header,flag); 
         print_string(all_tapes(current_tape).Program);

         IF INSTR(all_tapes(current_tape).Program, 'MINI') != 0
         THEN
            print_string(all_tapes(current_tape).MinVersion,'999',2);
         ELSE
            print_string(all_tapes(current_tape).JulVersion,'999',2);
         END IF;
         print_string;

         print_header(local_args.header,flag); 
         print_string('Processing Level : ');
         print_string(all_tapes(current_tape).ProcLevel);
         print_string;
      END IF;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' >> The present tape :  ');
      print_string(all_tapes(current_tape).Tape);
      IF (all_tapes(current_tape).CopyFlag) = 0
      THEN
         print_string(' is a MASTER DATASET ');
      ELSE    
         print_string(' is a COPY DATASET ');
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' *** Debug of runs content for this dataset ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string('   Run        Lep Energy      Nb of CLASS 16' );
      print_string;
      
      start_run_file := all_tapes(current_tape).Start_run;
      nrun_file := all_tapes(current_tape).Nb_run;
      ilast := start_run_file + nrun_file -1;

      current_run := all_runs.FIRST;
      LOOP
         EXIT when current_run IS NULL;
         ifirst := current_run;
         IF ifirst >= start_run_file AND ifirst <= ilast
         THEN
            print_header(local_args.header,flag); 
            print_string(all_runs(current_run).RunNb,'99999',2);
            print_string(all_runs(current_run).ExEnergy,'999D999',10);
            print_string(all_runs(current_run).Nclass16,'99999',10);
            print_string;
         END IF;
         current_run := all_runs.NEXT(current_run);

      END LOOP;

      print_header(local_args.header,flag); 
      print_string(' Total length of information : ');
      print_string(all_tapes(current_tape).SizeMbytes,'9999');
      print_string(' Mbytes');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' Total number of CLASS 16 : ');
      print_string(all_tapes(current_tape).Nclass16,'99999');
      print_string;

      current_tape := all_tapes.NEXT(current_tape);

   END LOOP;

END;
END write_Data_CartInfo;


PROCEDURE write_Mc_CartInfo
   (a_in IN args,
    tape_id IN VARCHAR2,
    tape_num IN INTEGER,
    tape_file IN INTEGER)
/*
|| Monte Carlo Data
|| Page 3 of the scanbook user interface
|| Writes an output file containing informations on
|| a cartridge selected by the user on page 1
*/
IS
   local_args args := a_in;

   all_tapes Tapes_table;

   ProgList Int_Tab;

   tape_and_file INTEGER;
   tape_is VARCHAR2(20);
   nrec INTEGER;
   current_tape INTEGER;

   flag VARCHAR2(10) := ' ';
   if_file VARCHAR2(50);
   tape_title VARCHAR2(200);
   nblanks INTEGER;
   details VARCHAR2(50);

   nstr INTEGER;
   str VARCHAR2(300);
   first_word VARCHAR2(100);
   reste VARCHAR2(300);

BEGIN
DECLARE
   
   CURSOR tapes_cur
   IS
      SELECT * 
      FROM MCSETS msets 
      WHERE 
            msets.TapeId like tape_id
        AND msets.TapeNumb = tape_num
        AND (tape_file = 0 OR msets.FileNumb = tape_file)
        ORDER by msets.TapeId,msets.TapeNumb,msets.FileNumb
      ; 
      tapes_rec tapes_cur%ROWTYPE;

BEGIN

/* Date of OUTPUT creation */
   local_args.header := 2;
   write_datime('OUTPUT',local_args.header);

/*
|| For each TapeNameFile fill the table all_tapes
*/
   nrec := 0;
   OPEN tapes_cur;
   LOOP
      FETCH tapes_cur INTO tapes_rec;
      EXIT WHEN tapes_cur%NOTFOUND;
      nrec := nrec + 1;

      tape_and_file := tapes_rec.TapeNumb * 1000 + tapes_rec.FileNumb;
      tape_is := give_tape(tapes_rec.TapeId,tapes_rec.TapeNumb,tapes_rec.FileNumb); 

      all_tapes(tape_and_file).Tape := tape_is; 
      all_tapes(tape_and_file).Nature := tapes_rec.Datatype; 
      all_tapes(tape_and_file).Proc_date := tapes_rec.Date_Proc;  
      all_tapes(tape_and_file).Location := tapes_rec.TMSLocation; 
      all_tapes(tape_and_file).Kin_code := tapes_rec.KinCode; 
      all_tapes(tape_and_file).ExEnergy := tapes_rec.ExactEnergy/1000;
      all_tapes(tape_and_file).Details := tapes_rec.Details;

      all_tapes(tape_and_file).Program := give_default(tapes_rec.Datatype); 
      all_tapes(tape_and_file).GalVersion :=  tapes_rec.GalephVersion;
      all_tapes(tape_and_file).JulVersion :=  tapes_rec.JuliaVersion;
      all_tapes(tape_and_file).MinVersion :=  tapes_rec.MiniVersion;
      all_tapes(tape_and_file).CopyFlag := tapes_rec.CopyFlag;

      IF tapes_rec.Datatype != 'KINGAL'
      THEN
         all_tapes(tape_and_file).Program := 'GALEPH_Version: ' || 'JULIA_Version: '; 
         IF tapes_rec.Datatype = 'MINI'
         THEN
            all_tapes(tape_and_file).Program := all_tapes(tape_and_file).Program || 'MINI_Version:'; 
         END IF;
      END IF;

   END LOOP;
   CLOSE tapes_cur;

/* Write the output */
   local_args.header := local_args.header + 1;

/* Print List by Tape file */
   FOR ii IN 1 .. 3
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;

   print_header(local_args.header,flag); 
   print_string('                  *********** Printout of Informations');

   if_file := ' ';
   IF tape_file != 0
   THEN
      if_file := '.' || to_char(tape_file);
   END IF;
   tape_title := ' for TAPE ' || tape_id || to_char(tape_num) || if_file || 
                 ' *********** ';

   print_string(tape_title);
   print_string;

   FOR ii IN 1 .. 2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------------' ||
                '--------------------------------------------------------------');
   print_string;

   print_header(local_args.header,flag); 
   print_string('    Tape      Nature    Date    Location   KinCode     Lep Energy  ' ||
                '              Comments ');
   print_string;
   print_header(local_args.header,flag); 
   print_string('                       yymmdd                           Gev ');
   print_string;  

   print_header(local_args.header,flag); 
   print_string('-------------------------------------------------------------' ||
                '--------------------------------------------------------------');
   print_string;

   current_tape := all_tapes.FIRST;
   LOOP
      EXIT when current_tape IS NULL;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Tape,2);

      nblanks := 13 - LENGTH(all_tapes(current_tape).Tape);
      print_string(all_tapes(current_tape).Nature,nblanks);

      print_string(all_tapes(current_tape).Proc_date,'99999999',3); 

      print_string(all_tapes(current_tape).Location,4);
      print_string(all_tapes(current_tape).Kin_code,'99999',6);
      print_string(all_tapes(current_tape).ExEnergy,'999D999',7);

      details := SUBSTR(all_tapes(current_tape).Details,1,40) || ' ......';
      print_string(details,5);
      print_string;

      current_tape := all_tapes.NEXT(current_tape);

   END LOOP;

/* Print details on Runs by Tape and file */
   FOR ii IN 1 .. 3
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;

   print_header(local_args.header,flag); 
   print_string('                  *************** Detailed printout ***************');
   print_string;

/* Loop again on tape files and print details for Runs which reside on selected files */
   current_tape := all_tapes.FIRST;
   LOOP
      EXIT when current_tape IS NULL;
      IF tape_file = 0
      THEN
         print_header(local_args.header,flag); 
         print_string(' ');
         print_string;
   

         print_header(local_args.header,flag); 
         print_string('-------------------------------------------------------------' ||
                      '--------------------------------------------------------------');
         print_string;

         print_header(local_args.header,flag); 
         print_string('    Tape      Nature    Date    Location   KinCode     Lep Energy  ' ||
                      '              Comments ');
         print_string;
         print_header(local_args.header,flag); 
         print_string('                      yymmdd                           Gev ');
         print_string;  

         print_header(local_args.header,flag); 
         print_string('-------------------------------------------------------------' ||
                      '--------------------------------------------------------------');

         print_string;
         print_header(local_args.header,flag); 
         print_string(all_tapes(current_tape).Tape,2);

         nblanks := 13 - LENGTH(all_tapes(current_tape).Tape);
         print_string(all_tapes(current_tape).Nature,nblanks);

         print_string(all_tapes(current_tape).Proc_date,'99999999',3); 
         print_string(all_tapes(current_tape).Location,4);
         print_string(all_tapes(current_tape).Kin_code,'99999',6);
         print_string(all_tapes(current_tape).ExEnergy,'999D999',7);

         details := SUBSTR(all_tapes(current_tape).Details,1,40) || ' ......';
         print_string(details,5);
         print_string;

      END IF;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      
      print_string('MCarlo Data  Production:');
      print_string;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Details);
      print_string;

      print_header(local_args.header,flag); 
      print_string('Date : ');
      print_string(all_tapes(current_tape).Proc_Date); 
      print_string;
      
      ProgList(1) := all_tapes(current_tape).GalVersion; 
      ProgList(2) := all_tapes(current_tape).JulVersion; 
      ProgList(3) := all_tapes(current_tape).MinVersion;
 
      IF all_tapes(current_tape).Nature != 'KINGAL'
      THEN
         nstr := 2;
         IF all_tapes(current_tape).Nature = 'MINI'
         THEN
            nstr := 3;
         END IF;

         str := all_tapes(current_tape).Program;
         FOR i IN 1 .. nstr
         LOOP
            split_string(str,first_word,reste);
            print_header(local_args.header,flag); 
            print_string(first_word);
            nblanks := 17 - LENGTH(first_word);
            print_string(ProgList(i),'999',nblanks);
            print_string; 
            str := reste;
         END LOOP;
      END IF;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' >> The present tape :  ');
      print_string(all_tapes(current_tape).Tape);
      IF (all_tapes(current_tape).CopyFlag) = 0
      THEN
         print_string(' is a MASTER DATASET ');
      ELSE    
         print_string(' is a COPY DATASET ');
      END IF;
      print_string;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;


      current_tape := all_tapes.NEXT(current_tape);

   END LOOP;

END;
END write_Mc_CartInfo;


PROCEDURE write_RunInfo
   (a_in IN args,
    sel_run IN INTEGER)
/*
|| Real Data
|| Page 3 of the scanbook user interface
|| Writes an output file containing informations on
|| a Run selected by the user on page 1
*/
IS
   local_args args := a_in;

   runQ Char_Tab;
   RunQList Char_Tab;

   TapesList Char_Tab;
 
   tape_id DATASETS.TapeID%TYPE;
   tape_num DATASETS.TapeNumb%TYPE;
   tape_file DATASETS.FileNumb%TYPE;

   tape_and_file INTEGER;
   tape_is VARCHAR2(20);

   all_tapes Tapes_table;
   all_runs Tapes_Runs_table;
  
   flag VARCHAR2(10) := ' ';

   run_title VARCHAR2(200);
   current_run INTEGER;
   current_tape INTEGER;
   current_rq INTEGER;
   nb_runq INTEGER;
   nwd INTEGER;
   nblanks INTEGER;
   phys_sel VARCHAR2(60);
   nrec INTEGER;
   
   nrun_per_tape INTEGER;
   Run_per_tape VARCHAR2(1500);

   nrun_file INTEGER;
   start_run_file INTEGER;
   istart INTEGER;
   start_run INTEGER;
   ifirst INTEGER;
   ilast INTEGER;
   
   tot_Evt INTEGER := 0;
   tot_class16 INTEGER := 0;
   Exact_Energy NUMBER(10,3);
   Luminosity   NUMBER(10,3);

   nb_run INTEGER;
   nwrite INTEGER;
   rq_key RUNQUALS.RunqualKeyword%TYPE;
   rq_desc RUNQUALS.ExplainRunqual%TYPE;
   run_sel RUNCOND.RunSelection%TYPE;
   cart_ID CARTDES.ID%TYPE;

   Maxrun_per_tape MENUDEFAULTS.ParamValue%TYPE := give_default('NbRUN_per_tape'); 
   
   year_is RUNBYYEAR.Year%TYPE := convert_year(a_in.datayear);

BEGIN
  
/* 3 first bits of the Run quality */
   runQ(1) := 'DUCK';
   runQ(2) := 'MAYB';
   runQ(3) := 'PERF';

/* List of Run quality bits for the selected year */
   give_RunQList(year_is,RunQList);

DECLARE

   CURSOR run_cur IS
      SELECT * 
      FROM RUNCOND rcond
      WHERE
         rcond.RunNumb = sel_run
      ;
   run_rec run_cur%ROWTYPE;

   CURSOR tp_cur
    IS
       SELECT dsets.ID, dsets.TapeId, dsets.TapeNumb, dsets.FileNumb
       FROM DATASETS dsets, RUNSETS rsets
       WHERE 
             rsets.Run = sel_run
         AND rsets.DatasetsID = dsets.ID
         AND (dsets.CopyFlag = 0)
         ORDER by dsets.TapeId,dsets.TapeNumb,dsets.FileNumb
       ; 
       tp_rec tp_cur%ROWTYPE;


   CURSOR tapes_cur(tape_id IN VARCHAR2, tape_num IN NUMBER, tape_file IN NUMBER)
   IS
      SELECT dsets.ID, dsets.TapeId, dsets.TapeNumb, dsets.FileNumb, dsets.TMSLocation,
             dsets.Details, dsets.Datatype, dsets.FirstRun, dsets.LastRun, dsets.Date_Proc, 
             dsets.JuliaVersion, dsets.MiniVersion, dsets.CopyFlag, dsets.SizeMbytes,
             dsets.ProcessLevel,
             rcond.RunNumb, rcond.ExactEnergy, rcond.EVnumb, rcond.NumZ0 
      FROM DATASETS dsets, RUNCOND rcond, RUNSETS rsets
      WHERE 
           dsets.TapeId like tape_id
        AND dsets.TapeNumb = tape_num
        AND dsets.FileNumb = tape_file
        AND rsets.DatasetsID = dsets.ID
        AND rcond.RunNumb = rsets.Run
        ORDER by dsets.TapeId,dsets.TapeNumb,dsets.FileNumb
      ; 
      tapes_rec tapes_cur%ROWTYPE;

BEGIN

/* Date of OUTPUT creation */
   local_args.header := 2;
   write_datime('OUTPUT',local_args.header);

/* Print on OUTPUT the run quality definitions for the concerning year */
   local_args.header := 3;

   FOR ii IN 1 ..2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   run_title := ' for RUN ' || to_char(sel_run) || ' *********** ';

   print_header(local_args.header,flag); 
   print_string('            *********** Printout of RUN Informations');
   print_string(run_title);
   print_string;

   FOR ii IN 1 ..2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   print_string(' ====> In the TABLE below : <====');
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;
   
   print_header(local_args.header,flag); 
   print_string(' For < Status of Physics Tools Selection > item :');
   print_string;

   nb_runq := 0;
   current_rq := RunQList.FIRST;
   LOOP
      EXIT when current_rq is NULL;

      nwd := LENGTH(RunQList(current_rq));
      rq_key := SUBSTR(RunQList(current_rq),1,2);
      rq_desc := SUBSTR(RunQList(current_rq),4,nwd-3);

      IF nb_runq = 3
      THEN
         print_string;
         nb_runq := 0;
      END IF;

      IF nb_runq = 0
      THEN
         print_header(local_args.header,flag);
         print_string(rq_key, 5);
         print_string(' : ');
         print_string(rq_desc, 2);
         nblanks := 25 - LENGTH(rq_desc);
      ELSE
         print_string(rq_key, nblanks);
         print_string(' : ');
         print_string(rq_desc, 2);
         nblanks := 25 - LENGTH(rq_desc);
      END IF;

      nb_runq := nb_runq + 1;
      current_rq := RunQList.NEXT(current_rq);

   END LOOP;
   IF nb_runq != 0
   THEN
      print_string;
   END IF;

/* Print informtions on selected RUN conditions */
   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

   print_header(local_args.header,flag); 
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
   print_string;

   print_header(local_args.header,flag); 
   print_string('  Run  LepFill  Date    Exact     Number of Events    ' ||
                  'Lumi         Status   of                ');
   print_string;
   print_header(local_args.header,flag); 
   print_string('               yymmdd   Energy   Total  Hadr  Bhab ' ||
                  '  nb**-1      RunQ   Physics Tools Selections');
   print_string;  

   print_header(local_args.header,flag); 
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
   print_string;

   FOR a_rec IN run_cur
   LOOP
      print_header(local_args.header,flag); 
      print_string(a_rec.RunNumb,'99999',1);
      print_string(a_rec.LepFill,'99999',1);
      print_string(a_rec.WritDate,'99999999',2);

      Exact_Energy := a_rec.ExactEnergy/1000;
      print_string(Exact_Energy,'999D999',1);

      print_string(a_rec.EVnumb,'999999',2);
      print_string(a_rec.NumZ0,'9999',2);
      print_string(a_rec.NumBh,'9999',2);

      Luminosity := a_rec.LUmin;
      print_string(Luminosity,'999D999',2);

      run_sel := a_rec.RunSelection;
     
/* Loop on the 3 first bits of the run_quality */
      FOR iq IN 1 .. 3
      LOOP
          IF SUBSTR(run_sel,iq,1) = 'T'
          THEN
             print_string(runQ(iq), 6);
             EXIT;
          END IF;
      END LOOP;

/* Print the Physics Tools Selections */
      phys_sel := ' ';
      current_rq := RunQList.FIRST;
      LOOP
         EXIT when current_rq is NULL;
         IF SUBSTR(run_sel,current_rq,1) = 'T'
         THEN
            phys_sel := phys_sel || SUBSTR(RunQList(current_rq),1,2) || ' ';
         ELSE
            phys_sel := phys_sel || '   ';
         END IF;
         current_rq := RunQList.NEXT(current_rq);
      END LOOP;

      print_string(phys_sel,2);
      print_string;
         
   END LOOP;
   
/* 
|| Loop on cursor tapes_cur
|| Fill the list of tapes on which the RUN selected exists
*/
   nrec := 0;
   OPEN tp_cur;
   LOOP
      FETCH tp_cur INTO tp_rec;
      EXIT WHEN tp_cur%NOTFOUND;      
      nrec := nrec + 1;
      tape_is := give_tape(tp_rec.TapeId,tp_rec.TapeNumb,tp_rec.FileNumb);
      TapesList(nrec) := tape_is;
   END LOOP;
   CLOSE tp_cur;

/* 
|| Loop on TapesList - Open the cursor run_tapes_cur
|| For each TapeNameFile fill the tables all_tapes and all_runs
*/

   FOR jj IN 1 .. TapesList.COUNT
   LOOP
      tape_id := SUBSTR(TapesList(jj),1,2);
      tape_num := to_number(SUBSTR(TapesList(jj),3,4));
      tape_file := to_number(SUBSTR(TapesList(jj),8,LENGTH(TapesList(jj))));

      start_run := 0;
      nrun_per_tape := 1;
      nrec := 0;
      OPEN tapes_cur(tape_id, tape_num, tape_file);
      LOOP
         FETCH tapes_cur INTO tapes_rec;
         EXIT WHEN tapes_cur%NOTFOUND;      
         nrec := nrec + 1;

         cart_ID := give_Cart_ID(tapes_rec.TapeId);
         tape_and_file := cart_ID * 10000000 + tapes_rec.TapeNumb * 1000 + tapes_rec.FileNumb;

         IF all_tapes.EXISTS(tape_and_file)
         THEN      

            tot_evt := tot_evt + tapes_rec.EVnumb;
            all_tapes(tape_and_file).Nevts := tot_evt;

            tot_class16 := tot_class16 + tapes_rec.NumZ0;
            all_tapes(tape_and_file).Nclass16 := tot_class16;

            Run_per_tape := Run_per_tape || to_char(tapes_rec.RunNumb,'99999');
            all_tapes(tape_and_file).Runs := Run_per_tape;

            nrun_per_tape := nrun_per_tape + 1;
            all_tapes(tape_and_file).Nb_run := nrun_per_tape;

            all_runs(nrec).RunNb := tapes_rec.RunNumb;
            all_runs(nrec).ExEnergy := tapes_rec.ExactEnergy/1000;
            all_runs(nrec).Nclass16 := tapes_rec.NumZ0;

         ELSE

            tot_evt := tapes_rec.EVnumb;
            all_tapes(tape_and_file).Nevts := tot_evt;

            tot_class16 := tapes_rec.NumZ0;
            all_tapes(tape_and_file).Nclass16 := tot_class16;

            Run_per_tape := to_char(tapes_rec.RunNumb,'99999');
            all_tapes(tape_and_file).Runs := Run_per_tape;
         
            tape_is := give_tape(tapes_rec.TapeId,tapes_rec.TapeNumb,tapes_rec.FileNumb); 
            all_tapes(tape_and_file).Tape := tape_is;
 
            all_tapes(tape_and_file).Nature := tapes_rec.Datatype; 
            all_tapes(tape_and_file).Proc_date := tapes_rec.Date_Proc; 
            all_tapes(tape_and_file).Location := tapes_rec.TMSLocation; 
            all_tapes(tape_and_file).First_run := tapes_rec.FirstRun; 
            all_tapes(tape_and_file).Last_run := tapes_rec.LastRun;
            all_tapes(tape_and_file).ExEnergy := tapes_rec.ExactEnergy/1000;
            all_tapes(tape_and_file).Details := tapes_rec.Details;
            all_tapes(tape_and_file).JulVersion :=  tapes_rec.JuliaVersion;
            all_tapes(tape_and_file).MinVersion :=  tapes_rec.MiniVersion;
            all_tapes(tape_and_file).ProcLevel :=  tapes_rec.ProcessLevel;
            all_tapes(tape_and_file).CopyFlag := tapes_rec.CopyFlag;
            all_tapes(tape_and_file).SizeMbytes := tapes_rec.SizeMbytes;
            all_tapes(tape_and_file).Nb_run := nrun_per_tape;

            all_tapes(tape_and_file).Program := give_default(tapes_rec.Datatype); 
            all_runs(nrec).RunNb := tapes_rec.RunNumb;
            all_runs(nrec).ExEnergy := tapes_rec.ExactEnergy/1000;
            all_runs(nrec).Nclass16 := tapes_rec.NumZ0;

            start_run := start_run + nrun_per_tape; 
            all_tapes(tape_and_file).Start_run := start_run;
            all_tapes(tape_and_file).Nb_run := nrun_per_tape;
            nrun_per_tape := 1;

         END IF;
      END LOOP;
      CLOSE tapes_cur;

   END LOOP;


/* 
|| For each tape containing information about the RUN selected print some informations 
*/
   FOR ii IN 1 .. 3
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;

   print_header(local_args.header,flag); 
   print_string('         ******** Tapes/Cartridges on which the RUN '|| sel_run || ' appears ********');
   print_string;

   current_tape := all_tapes.FIRST;
   nb_run := 0;
   LOOP
      EXIT when current_tape IS NULL;

      nb_run := LENGTH(all_tapes(current_tape).Runs) / 6;

      FOR ii IN 1 .. 2
      LOOP
         print_header(local_args.header,flag); 
         print_string(' ');
         print_string;
      END LOOP;

      print_header(local_args.header,flag); 
      print_string('-------------------------------------------------------------' ||
                   '------------------------------------------------------------------');
      print_string;

      print_header(local_args.header,flag); 
      print_string('    Tape      Nature    Date    Location     1st     Last    Nevts    Lep Energy  ' ||
                   '          Comments ');
      print_string;
      print_header(local_args.header,flag); 
      print_string('                       yymmdd                Run     Run               Gev ');
      print_string;  

      print_header(local_args.header,flag); 
      print_string('-------------------------------------------------------------' ||
                      '------------------------------------------------------------------');
      print_string;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Tape,2);

      nblanks := 13 - LENGTH(all_tapes(current_tape).Tape);
      print_string(all_tapes(current_tape).Nature,nblanks);

      nblanks := 7 - LENGTH(all_tapes(current_tape).Nature);
      print_string(all_tapes(current_tape).Proc_date,'99999999',nblanks);

      print_string(all_tapes(current_tape).Location,4);

      nblanks := 8 - LENGTH(all_tapes(current_tape).Location);
      print_string(all_tapes(current_tape).First_run,'99999',6);
      print_string(all_tapes(current_tape).Last_run,'99999',4);
      print_string(all_tapes(current_tape).Nevts,'9999999',2);
      print_string(all_tapes(current_tape).ExEnergy,'999D999',4);

      nwrite := 0;
      FOR nr IN 1 .. nb_run
      LOOP
         istart := nr * 6 - 5;
         IF nwrite = Maxrun_per_tape 
         THEN
            print_string;
            nwrite := 0;
         END IF;
         IF nwrite = 0 
         THEN
            IF istart = 1                       
            THEN
               print_string('    RUNS');
               print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
               nwrite := nwrite + 1;
            ELSE
               print_header(local_args.header,flag);
               print_string(' ',84);
               print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
               nwrite := nwrite + 1;
            END IF;
         ELSE
            print_string(SUBSTR(all_tapes(current_tape).Runs,istart,6));
            nwrite := nwrite + 1;
         END IF;
      END LOOP;
      
      IF nwrite != 0
      THEN
         print_string;
      END IF;

/* Print some details concerning the current tape */
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string('Real Data  Production:');
      print_string;

      print_header(local_args.header,flag); 
      print_string(all_tapes(current_tape).Details);
      print_string;

      IF INSTR(all_tapes(current_tape).Nature,'RAW') = 0
      THEN 
         print_header(local_args.header,flag); 
         print_string('Date : ');
         print_string(all_tapes(current_tape).Proc_Date);
         print_string;

         print_header(local_args.header,flag); 
         print_string(all_tapes(current_tape).Program);

         IF INSTR(all_tapes(current_tape).Program, 'MINI') != 0
         THEN
            print_string(all_tapes(current_tape).MinVersion,'999',2);
         ELSE
            print_string(all_tapes(current_tape).JulVersion,'999',2);
         END IF;
         print_string;

         print_header(local_args.header,flag); 
         print_string('Processing Level : ');
         print_string(all_tapes(current_tape).ProcLevel);
         print_string;
      END IF;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' >> The present tape :  ');
      print_string(all_tapes(current_tape).Tape);
      IF (all_tapes(current_tape).CopyFlag) = 0
      THEN
         print_string(' is a MASTER DATASET ');
      ELSE    
         print_string(' is a COPY DATASET ');
      END IF;
      print_string;

/* Print Runs content for the current tape */
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' *** Debug of runs content for this dataset ');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;

      print_header(local_args.header,flag); 
      print_string('   Run        Lep Energy      Nb of CLASS 16' );
      print_string;
      
      start_run_file := all_tapes(current_tape).Start_run;
      nrun_file := all_tapes(current_tape).Nb_run;
      ilast := start_run_file + nrun_file -1;

      current_run := all_runs.FIRST;
      LOOP
         EXIT when current_run IS NULL;
         ifirst := current_run;
         IF ifirst >= start_run_file AND ifirst <= ilast
         THEN
            print_header(local_args.header,flag); 
            print_string(all_runs(current_run).RunNb,'99999',2);
            print_string(all_runs(current_run).ExEnergy,'999D999',10);
            print_string(all_runs(current_run).Nclass16,'99999',10);
            print_string;
         END IF;
         current_run := all_runs.NEXT(current_run);

      END LOOP;

      print_header(local_args.header,flag); 
      print_string(' Total length of information : ');
      print_string(all_tapes(current_tape).SizeMbytes,'9999');
      print_string(' Mbytes');
      print_string;

      print_header(local_args.header,flag); 
      print_string(' Total number of CLASS 16 : ');
      print_string(all_tapes(current_tape).Nclass16,'99999');
      print_string;

      current_tape := all_tapes.NEXT(current_tape);

   END LOOP;

END;   
END write_RunInfo; 


PROCEDURE write_RunorCart
   (a_in IN args)
/*
|| Real Data
|| Page 1 of the scanbook user interface
|| Check the validity of a Run or a Tape selected by the user
*/
IS
   local_args args := a_in;

   tape_sel VARCHAR2(20);
   tape_file DATASETS.FileNumb%TYPE := 0;
   tape_ident DATASETS.TapeId%TYPE;
   tape_num DATASETS.TapeNumb%TYPE;
   ipoint INTEGER;

   run_sel RUNSETS.Run%TYPE;
   ttype VARCHAR2(10);

BEGIN

   IF SUBSTR(a_in.runorcart,1,3) = 'RUN'                                   
   THEN
      run_sel := to_number(SUBSTR(a_in.runorcart,5));
      DECLARE
         CURSOR run_cur
         IS
            SELECT Run 
            FROM RUNSETS
            WHERE 
               Run = run_sel
            ; 
            run_rec run_cur%ROWTYPE;

      BEGIN
/*
|| Check if the run entered by the user is valid
*/
         OPEN run_cur;
         LOOP
            FETCH run_cur INTO run_rec;
            EXIT WHEN run_cur%NOTFOUND;
         END LOOP;
 
         IF run_cur%ROWCOUNT = 0 
         THEN 
            print_string('-1   **** Run ' || run_sel || ' NOT found ****');
            print_string;
         ELSE
/*
|| Execute the corresponding procedure 
*/
            write_RunInfo(local_args,run_sel);
         END IF;
         CLOSE run_cur;

      END;
   END IF;

   IF SUBSTR(a_in.runorcart,1,3) = 'CRT' 
   THEN
      tape_sel := UPPER(SUBSTR(a_in.runorcart,5));
      tape_ident := SUBSTR(tape_sel,1,2);
      ipoint := INSTR(tape_sel,'.');

      IF ipoint != 0                                              /* a file was selected */ 
      THEN
         IF ipoint = LENGTH(tape_sel)
         THEN
            print_string('-1   **** Invalid tape ' || tape_sel || ' ****');
            print_string;
            RETURN;
         END IF;
         tape_num := to_number(SUBSTR(tape_sel,3,ipoint-3));
         tape_file := to_number(SUBSTR(tape_sel,ipoint+1));

      ELSE                                
         tape_num := to_number(SUBSTR(tape_sel,3));
      END IF;

      DECLARE

         CURSOR crtdes_cur
         IS
            SELECT * 
            FROM CARTDES
            WHERE 
                   TapeId like tape_ident
               AND tape_num between FirstNum and LastNum 
            ; 
            crtdes_rec crtdes_cur%ROWTYPE;

         CURSOR crtdat_cur
         IS
            SELECT TapeId, TapeNumb, FileNumb
            FROM DATASETS
            WHERE 
                   TapeId like tape_ident
               AND TapeNumb = tape_num
               AND (ipoint = 0 OR FileNumb = tape_file)
            ;  
            crtdat_rec crtdat_cur%ROWTYPE;

         CURSOR crtmc_cur
         IS
            SELECT TapeId, TapeNumb, FileNumb
            FROM MCSETS
            WHERE 
                   TapeId like tape_ident
               AND TapeNumb = tape_num
               AND (ipoint = 0 OR FileNumb = tape_file)
            ; 
            crtmc_rec crtmc_cur%ROWTYPE;

      BEGIN
/*
|| Check if the tape entered by the user is valid
*/

         OPEN crtdes_cur;
         LOOP
            FETCH crtdes_cur INTO crtdes_rec;
            EXIT WHEN crtdes_cur%NOTFOUND;
         END LOOP;
 
         IF crtdes_cur%ROWCOUNT = 0 
         THEN 
            print_string('-1   **** Invalid tape ' || tape_sel || ' ****');
            print_string;
            RETURN;
/*
|| Check if the tape is a Real DATA tape   
*/
         ELSE
     
            CLOSE crtdes_cur;
       
            OPEN crtdat_cur;
            LOOP
               FETCH crtdat_cur INTO crtdat_rec;
               EXIT WHEN crtdat_cur%NOTFOUND;
            END LOOP;
 
            IF crtdat_cur%ROWCOUNT != 0 
            THEN 
               write_Data_CartInfo(local_args,tape_ident,tape_num,tape_file);
               CLOSE crtdat_cur;
            ELSE
/*
|| Check if the tape is a MCarlo tape  
*/
               OPEN crtmc_cur;
               LOOP
                  FETCH crtmc_cur INTO crtmc_rec;
                  EXIT WHEN crtmc_cur%NOTFOUND;
               END LOOP;
 
               IF crtmc_cur%ROWCOUNT = 0 
               THEN 
                  print_string('-1   **** Tape ' || tape_sel || ' NOT found ****');
                  print_string;
                  RETURN;
               ELSE
                  write_Mc_CartInfo(local_args,tape_ident,tape_num,tape_file);
                  CLOSE crtmc_cur;
               END IF;
            END IF;
         END IF;
      END;
   END IF;

END write_RunorCart;


PROCEDURE write_mc_fili
   (a_in IN args)
/*
|| 
|| MonteCarlo Data
|| Page 3 of the scanbook user interface
|| Returns the list of FILI cards according to the
|| selections done on Page 1 and Page 2
*/
IS
   local_args args := a_in;
   DsetsList Int_Tab;
   EmptyList Int_Tab;

   ProcessList Char_Tab;

   flag VARCHAR2(10) := ' ';

   fili_name    VARCHAR2(4)  := 'FILI';
   edir_ft      VARCHAR2(6)  := '.edir';
   bos_type     VARCHAR2(4)  := 'EDIR';
   before_type  VARCHAR2(10);
   fili_line    VARCHAR2(500);
   comment_line VARCHAR2(500);

   cart_name    VARCHAR2(17) := 'ALDATA|EPIO|CART ';
   cart_label   VARCHAR2(10);
   tape_file    VARCHAR2(20);
   TapeNameFile VARCHAR2(20);
   size_file    VARCHAR2(10);
   exclam       VARCHAR2(10);
   
   nrec INTEGER;
   nblanks INTEGER;

   kin_code VARCHAR2(4) := extract_kincode(a_in.kinlist);
   institute_number MCSETS.IHomelab%TYPE := convert_institute(a_in.institute);
   lep_energy VARCHAR2(10) := convert_lepenergy(a_in.energy_lep);
   year_is MCSETS.GeometryYear%TYPE := convert_year(a_in.mcyear);
   spec_par VARCHAR2(20) := convert_special_particles(a_in.specpar);
   lep_category MCLEPENERGY.LepCategory%TYPE := give_lepcategory(a_in.mcyear);   
   aledir_dir MENUDEFAULTS.ParamValue%TYPE;   

   kin_keyword MCSETS.KingalKeyWord%TYPE;
   mass_is VARCHAR2(10);

   explain_keyword MCKEYSTAT.ExplainKeyWord%TYPE;
   last_kinkeyword MCSETS.KingalKeyWord%TYPE;

BEGIN

   DsetsList := EmptyList;

   IF a_in.mcdatasets IS NOT NULL
   THEN
      ProcessList := extract_from_processline(a_in.mcdatasets,a_in.typedat);
   ELSE
      ProcessList(1) := '%';
      ProcessList(2) := '%';
      ProcessList(3) := '%';
   END IF;

/* For LEP1 kin_keyword is :  'None' */
   kin_keyword := give_kinkeyword(a_in.kingal_conds,kin_code,year_is, 
                               institute_number);

   mass_is := LTRIM(a_in.KinMass);

/* Fix the EDIR files directory to write the FILI cards */
   aledir_dir := a_in.aledir;
   IF a_in.aledir IS NULL OR LOWER(a_in.aledir) = 'default' 
   THEN
      aledir_dir := give_default('ALEDIR');
   END IF;
        
   IF SUBSTR(aledir_dir,LENGTH(aledir_dir),1) != '/'
   THEN
      aledir_dir := aledir_dir || '/';
   END IF;

DECLARE

   CURSOR mc_fili_cur IS
      SELECT msets.TapeId, msets.TapeNumb, msets.FileNumb, msets.Details, 
             msets.ExistEdir, msets.SizeMbytes, msets.Nevents, msets.KingalKeyWord
      FROM MCSETS msets
      WHERE 
            msets.GeometryYear = year_is
        AND msets.Ihomelab = institute_number 
        AND (a_in.institute != 'CERN' OR msets.CopyFlag = 0) 
        AND msets.Datatype like a_in.data_type
        AND msets.KinCode like kin_code
        AND msets.KingalKeyWord like kin_keyword
        AND msets.RoundedEnergy like lep_energy
        AND msets.GalephVersion like ProcessList(1)
        AND msets.JuliaVersion like ProcessList(2)
        AND msets.MiniVersion like ProcessList(3)
        AND msets.ParticleMass like mass_is 
        AND EXISTS (
            SELECT * from MCPARTICLES mcp, MCLEPENERGY mclep
              WHERE msets.ParticleCode = mcp.ParticleCode
                AND mcp.ParticleName like spec_par
                AND (msets.GeometryYear != 1995 
                    OR (msets.GeometryYear = mclep.GeometryYear
                        AND mclep.LepCategory like lep_category) 
                    )
        )
        ORDER by msets.TapeId, msets.TapeNumb, msets.FileNumb
      ; 

BEGIN
   
/* Date of FILI cards creation */
   local_args.header := 2;
   write_datime('CARDS',local_args.header);

/* 
|| Write the FILI cards.
|| The format depends of the existence of the edir file
*/
   
   local_args.header := 0;
   nrec := 0;
   FOR a_rec IN mc_fili_cur
   LOOP
      nrec := nrec + 1;
      IF nrec = 1
      THEN
         last_kinkeyword := a_rec.KingalKeyWord;
      END IF;

      TapeNameFile := give_tape(a_rec.TapeId,a_rec.TapeNumb,a_rec.FileNumb); 

/* 
|| Check if Access with Edir was selected 
|| If yes, for Tapeid like 'AM' or 'AB' suppress the '_1' in the TapeNameFile  
*/

      IF a_in.ediryesno = 'Yes' AND a_rec.ExistEdir = 'T'
      THEN
         before_type := '| ';
         tape_file := LOWER(TapeNamefile);

         IF a_rec.TapeId = 'AM' OR a_rec.TapeId = 'AB'
         THEN
            tape_file := REPLACE(tape_file,'_1','');
            nblanks :=  9 - LENGTH(tape_file);
         ELSE
            nblanks := 11 - LENGTH(tape_file);
         END IF;

         FOR jk IN 1 .. nblanks
         LOOP
            before_type := ' ' || before_type;
         END LOOP;

         fili_line := fili_name || ' ''' || aledir_dir || 
                      tape_file || edir_ft || before_type || bos_type || 
                      '''  ! ' || a_rec.Details || '#' || to_char(a_rec.Nevents);
      ELSE
         tape_file := TapeNamefile;
         tape_file := REPLACE(tape_file,'_','.');

         size_file := '-s ' || to_char(a_rec.SizeMbytes);
         nblanks := 11 - LENGTH(TapeNameFile);

         FOR jk IN 1 .. nblanks
         LOOP
            size_file := ' ' || size_file;
         END LOOP;

         cart_label := give_Cart_label(a_rec.TapeId);

         exclam := '  ! ';
         IF a_rec.SizeMbytes < 100
         THEN
            exclam := ' ' || exclam;
         END IF;

         fili_line := fili_name || ' ''' || cart_name ||
                      tape_file || cart_label || size_file ||
                      '''' || exclam || a_rec.Details || '#' || to_char(a_rec.Nevents);
      END IF;

      IF a_rec.KingalKeyWord != last_kinkeyword 
      THEN 
         give_explainkeyword(kin_code,last_kinkeyword,year_is,institute_number,explain_keyword);
         comment_line := '****==> Explanation of keyword ' || last_kinkeyword ||
                         ' in the above comment : ' || explain_keyword ;
         print_header(local_args.header,flag);
         print_string(SUBSTR(comment_line,1,LENGTH(comment_line)));
         print_string;
         last_kinkeyword := a_rec.KingalKeyWord;
      END IF;

      print_header(local_args.header,flag);
      print_string(SUBSTR(fili_line,1,LENGTH(fili_line)));
      print_string;

   END LOOP;

   IF last_kinkeyword != 'None'
   THEN
      give_explainkeyword(kin_code,last_kinkeyword,year_is,institute_number,explain_keyword);
      comment_line := '****==> Explanation of keyword ' || last_kinkeyword ||
                         ' in the above comment : ' || explain_keyword ;
      print_header(local_args.header,flag);
      print_string(SUBSTR(comment_line,1,LENGTH(comment_line)));
      print_string;
   END IF;

END;
END write_mc_fili;


PROCEDURE write_fili_srun_cards
   (a_in IN args)
/*
|| Real Data and MonteCarlo Data
|| Page 3 of the scanbook user interface
|| Executed by the scanbook Java program
|| Will execute a procedure according to the type of data selected.
||   - For Mcarlo the list of FILI cards 
||   - For Real Data the list of FILI and SRUN cards
||     according to selections done on Page 1 and Page 2
*/
IS
BEGIN
   IF a_in.typedat = 'Real DATA'    
   THEN
      IF INSTR(a_in.data_type,'RAW') != 0 
      THEN
         write_raw_fili_srun(a_in);
      ELSE
         write_fili_srun(a_in);
      END IF;
   END IF;

   IF a_in.typedat = 'MC DATA'    
   THEN
      write_mc_fili(a_in);
   END IF;

END write_fili_srun_cards;


PROCEDURE give_goodbad
   (a_in IN args)
/*
|| Real Data
|| Page 2 of the scanbook user interface
|| If RunQuality selected is "Phys. Groups", returns the list of Run quality bits
|| ordered by increasing bit number  
*/
IS

   flag VARCHAR2(10) := ' '; 
   loc_lepcat INTEGER;
   year_is RUNQUALS.Year%TYPE := convert_year(a_in.datayear);

BEGIN
DECLARE
   CURSOR rq_cur IS
      SELECT ExplainRunqual, NumBitPattern
      FROM RUNQUALS
         WHERE Year = year_is
      ORDER by NumBitpattern
      ;
BEGIN
   FOR a_rec IN rq_cur
   LOOP 
      print_header(a_in.header,flag);
      print_string(a_rec.NumBitPattern, '99');
      print_string(a_rec.ExplainRunqual,1);
      print_string;
   END LOOP;
END;

END give_goodbad;

 
PROCEDURE write_GlobalStat
   (a_in IN args)
/*
|| Real Data and MCarlo Data
|| Page 3 of the scanbook user interface
|| Writes an output file containing informations on
|| all cartridges which belong to a selected Institute
*/
IS
   local_args args := a_in;

   YearList Int_Tab;
   MCYearList Int_Tab;
   EmptyList Int_Tab;

   flag VARCHAR2(10) := ' ';
   nrec INTEGER;
   nblanks INTEGER;
   tot_data INTEGER;
    
   size_data NUMBER(10,3);

   last_year INTEGER;
   stat_title VARCHAR2(200);
   year_title VARCHAR2(200);

   institute_number DATASTAT.IHomelab%TYPE := convert_institute(a_in.institute);

BEGIN

   YearList := EmptyList;
   MCYearList := EmptyList;

DECLARE
   CURSOR year_cur
   IS
      SELECT distinct Year 
      FROM DATASTAT  
      ORDER BY Year
      ;
   year_rec year_cur%ROWTYPE;

   CURSOR mcyear_cur
   IS
      SELECT distinct GeometryYear 
      FROM MCSTAT  
      ORDER BY GeometryYear
      ;
   mcyear_rec mcyear_cur%ROWTYPE;

   CURSOR dstat_cur (year_in IN NUMBER)
   IS 
      SELECT dstat.ProcessLevel, 
             dstat.NumbRaw, dstat.NumbPot, dstat.NumbDst, dstat.NumbMini, 
             dstat.MbytesRaw, dstat.MbytesPot, 
             dstat.MbytesDst, dstat.MbytesMini
      FROM DATASTAT dstat
      WHERE
            dstat.Year = year_in 
        AND dstat.Ihomelab = institute_number
      ORDER BY dstat.ProcessLevel
      ;
   dstat_rec dstat_cur%ROWTYPE;


   CURSOR mstat_cur (year_in IN NUMBER)
   IS 
      SELECT mstat.KinCode, mstat.KinName, 
             mstat.NumbPot, mstat.NumbMini, mstat.MbytesPot, mstat.MbytesMini
      FROM MCSTAT mstat
      WHERE
            mstat.GeometryYear = year_in 
        AND mstat.Ihomelab = institute_number
      ORDER BY mstat.KinCode
      ;
   mstat_rec mstat_cur%ROWTYPE;

BEGIN

/* Date of OUTPUT creation */
   local_args.header := 2;
   write_datime('OUTPUT',local_args.header);

/* Write the OUTPUT */
   local_args.header := 3;

/*  Printout of Real Datasets  */
/*
|| Loop on cursor year_cur
|| Fill the list of all years found
*/
   nrec := 0;
   OPEN year_cur;
   LOOP
      FETCH year_cur INTO year_rec;
      EXIT WHEN year_cur%NOTFOUND;
      nrec := nrec + 1;      
      YearList(nrec) := year_rec.Year;
   END LOOP;
   CLOSE year_cur;

   FOR ii IN 1 ..2
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
   END LOOP;   

   print_header(local_args.header,flag); 
   stat_title := '    *********** Printout of Real Datasets for Homelab = ' ||
                 a_in.institute || ' ***********';
   print_string(stat_title);
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

   print_header(local_args.header,flag); 
   print_string(' NB: The Size of the Datasets is in Gbytes ');
   print_string;

/* 
|| Loop on cursor dstat_cur
|| For each Year print the statistics by ProcessLevel and type of Dataset
*/
   last_year := 0;
   FOR jj IN 1 .. YearList.COUNT
   LOOP
      OPEN dstat_cur(YearList(jj));
      LOOP
         FETCH dstat_cur INTO dstat_rec;
         EXIT WHEN dstat_cur%NOTFOUND;      
         nrec := nrec + 1;
         IF YearList(jj) != last_year
         THEN
            year_title := ' ======> Number of Datasets for Year : ' || 
                          to_char(YearList(jj));

            FOR ii IN 1 ..2
            LOOP
               print_header(local_args.header,flag); 
               print_string(' ');
               print_string;
            END LOOP;   

            print_header(local_args.header,flag); 
            print_string(year_title);
            print_string;

            print_header(local_args.header,flag); 
            print_string('  Processing      TOT     RAW     DST     POT    MINI    SizeRAW    ' ||
                         'SizePOT    SizeDST    SizeMINI');
            print_string;
         END IF;

         last_year := YearList(jj);

         print_header(local_args.header,flag); 
         print_string(dstat_rec.ProcessLevel,4);

         nblanks := 11 - LENGTH(dstat_rec.ProcessLevel);
         tot_data := dstat_rec.NumbRaw + dstat_rec.NumbPot + dstat_rec.NumbDst + 
                     dstat_rec.NumbMini;
         print_string(tot_data,'999999',nblanks);

         print_string(dstat_rec.NumbRaw,'999999',2);
         print_string(dstat_rec.NumbPot,'999999',2);
         print_string(dstat_rec.NumbDst,'999999',2);
         print_string(dstat_rec.NumbMini,'999999',2);

         size_data := dstat_rec.MbytesRaw/1000;
         print_string(size_data,'9999999D999');

         size_data := dstat_rec.MbytesPot/1000;
         print_string(size_data,'9999999D999');

         size_data := dstat_rec.MbytesDst/1000;
         print_string(size_data,'9999999D999');

         size_data := dstat_rec.MbytesMini/1000;
         print_string(size_data,'9999999D999');

         print_string;

      END LOOP;
      CLOSE dstat_cur;

   END LOOP;

/* Printout of Montecarlo Datasets */
/*
|| Loop on cursor mcyear_cur
|| Fill the list of all years found
*/
   nrec := 0;
   OPEN mcyear_cur;
   LOOP
      FETCH mcyear_cur INTO mcyear_rec;
      EXIT WHEN mcyear_cur%NOTFOUND;
      nrec := nrec + 1;      
      MCYearList(nrec) := mcyear_rec.GeometryYear;
   END LOOP;
   CLOSE mcyear_cur;

   FOR ii IN 1 ..4
   LOOP
      print_header(local_args.header,flag); 
      print_string(' ');
      print_string;
  END LOOP;   

   print_header(local_args.header,flag); 
   stat_title := '    *********** Printout of MCarlo Datasets for Homelab = ' ||
                 a_in.institute || ' ***********';
   print_string(stat_title);
   print_string;

   print_header(local_args.header,flag); 
   print_string(' ');
   print_string;

   print_header(local_args.header,flag); 
   print_string(' NB: The Size of the Datasets is in Gbytes ');
   print_string;

/* 
|| Loop on cursor mstat_cur
|| For each Year print the statistics by ProcessLevel and type of Dataset
*/
   last_year := 0;
   FOR jj IN 1 .. MCYearList.COUNT
   LOOP
      OPEN mstat_cur(MCYearList(jj));
      LOOP
         FETCH mstat_cur INTO mstat_rec;
         EXIT WHEN mstat_cur%NOTFOUND;      
         nrec := nrec + 1;
         IF MCYearList(jj) != last_year
         THEN
            year_title := ' ======> Year of Geometry is : ' || to_char(MCYearList(jj));

            FOR ii IN 1 ..2
            LOOP
               print_header(local_args.header,flag); 
               print_string(' ');
               print_string;
            END LOOP;   

            print_header(local_args.header,flag); 
            print_string(year_title);
            print_string;

            print_header(local_args.header,flag); 
            print_string('  KINGAL Generator      TOT     POT     MINI     SizePOT     SizeMINI');
            print_string;
         END IF;

         last_year := MCYearList(jj);
         
         print_header(local_args.header,flag); 
         print_string(mstat_rec.KinCode,'999999');
         print_string(mstat_rec.KinName,4);

         nblanks := 11 - LENGTH(mstat_rec.KinName);
         tot_data := mstat_rec.NumbPot + mstat_rec.NumbMini;
         print_string(tot_data,'999999',nblanks);

         print_string(mstat_rec.NumbPot,'999999',2);
         print_string(mstat_rec.NumbMini,'999999',3);

         size_data := mstat_rec.MbytesPot/1000;
         print_string(size_data,'9999999D999',1);

         size_data := mstat_rec.MbytesMini/1000;
         print_string(size_data,'9999999D999',1);

         print_string;

      END LOOP;
      CLOSE mstat_cur;

   END LOOP;

END;   
END write_GlobalStat; 


FUNCTION if_scanbook_expert
   (username_in IN VARCHAR2)
/*
|| Check if the scanbook user is a scanbook expert
*/
   RETURN INTEGER
IS
   nrec INTEGER;

BEGIN
DECLARE

   CURSOR exp_cur 
   IS
      SELECT UserName FROM SCANBOOKEXPERTS
      WHERE UserName like LOWER(username_in)
   ;

BEGIN

   nrec := 0;
   FOR a_rec IN exp_cur
   LOOP
      nrec := nrec + 1;
   END LOOP;

   IF nrec = 0
   THEN
      RETURN 1;
   ELSE
      RETURN 0;
   END IF;

END;

END;


PROCEDURE Update_UsersStats
   (a_in IN args)
/*
|| Update the SCANBOOKUSERS table
|| If the scanbook user is a scanbook expert ignore him. 
*/
IS
   local_args args := a_in;

   nrec INTEGER;
   today DATE;

BEGIN

   IF if_scanbook_expert(a_in.user_name) = 0
   THEN
      RETURN;
   END IF;

   IF local_args.user_name IS NULL 
   THEN
      local_args.user_name := 'Unknown';
   END IF;
  
   IF LENGTH(LTRIM(local_args.user_name)) = 0
   THEN 
      local_args.user_name := 'Unknown';
   END IF;

DECLARE

   CURSOR usr_cur
   IS
      SELECT count(*) nb_users
      FROM SCANBOOKUSERS
      WHERE
        UserName like local_args.user_name
      ;
   usr_rec usr_cur%ROWTYPE;

BEGIN
   OPEN usr_cur;
   FETCH usr_cur INTO usr_rec;
   CLOSE usr_cur;

   today := SYSDATE;

   nrec := usr_rec.nb_users;

   IF nrec = 0
   THEN
      INSERT INTO SCANBOOKUSERS 
      VALUES (local_args.user_name, today, today, 1);
   ELSE
      UPDATE SCANBOOKUSERS
      SET NbUsages = NbUsages + 1, LastUsage = today
      WHERE
         UserName=local_args.user_name
      ; 
   END IF;

   INSERT INTO SCANBOOKSESSIONS 
   VALUES (local_args.user_name, local_args.procname, local_args.os_name, 
           local_args.navigator, local_args.hardware, local_args.ip_address);

   COMMIT;

END;

END Update_UsersStats;


PROCEDURE give_stats_buttons
/*
|| Design statistics buttons 
*/
IS
   local_args args;

BEGIN

   local_args.header := 0;
   local_args.page_number := '10';
   local_args.menutype := 'Statistics';
   local_args.typedat := '%'; 
   fill_other_menus(local_args);

END give_stats_buttons;


PROCEDURE give_statistics
   (a_in IN args)
/*
|| Give statistics on the scanbook usages 
*/
IS
   head INTEGER;
   flag VARCHAR2(10) := ' ';
   stattype VARCHAR2(100);

   TYPE statcur_type IS 
      REF CURSOR;

   TYPE cheese_values IS
      RECORD (
         stat_type  VARCHAR2(100),
         nbtimes    INTEGER      
      );

   cheese_curvar statcur_type;
   cheese_rec cheese_values;

BEGIN
   IF give_action('Statistics',a_in.stat_by) = 'US'  
   THEN
     OPEN cheese_curvar FOR
      SELECT UserName stat_type, NbUsages nbtimes
      FROM SCANBOOKUSERS
      ORDER by nbtimes
    ;

   ELSIF give_action('Statistics',a_in.stat_by) = 'IP'  
   THEN
      OPEN cheese_curvar FOR
      SELECT IP_address stat_type, count(*) nbtimes 
      FROM SCANBOOKSESSIONS
      GROUP BY IP_address 
      ORDER by nbtimes
      ;

   ELSIF give_action('Statistics',a_in.stat_by) = 'NAV'  
   THEN
      OPEN cheese_curvar FOR
      SELECT Navigator stat_type, count(*) nbtimes 
      FROM SCANBOOKSESSIONS
      GROUP BY Navigator 
      ORDER by nbtimes
      ;

   ELSIF give_action('Statistics',a_in.stat_by) = 'OS'  
   THEN
      OPEN cheese_curvar FOR
      SELECT OS_Name stat_type, count(*) nbtimes 
      FROM SCANBOOKSESSIONS
      GROUP BY OS_Name 
      ORDER by nbtimes
      ;

   ELSIF give_action('Statistics',a_in.stat_by) = 'HARD'  
   THEN
      OPEN cheese_curvar FOR
      SELECT Hardware stat_type, count(*) nbtimes 
      FROM SCANBOOKSESSIONS
      GROUP BY Hardware 
      ORDER by nbtimes
      ;

   END IF;

   LOOP
      FETCH cheese_curvar INTO cheese_rec;
      EXIT WHEN cheese_curvar%NOTFOUND;
      head := 0;      
      print_header(head,flag); 
      stattype := cheese_rec.stat_type;
      IF stattype IS NULL
      THEN
         stattype := 'Unknown';
      END IF;
      print_string(stattype);
      print_string;

      head := 1;
      print_header(head,flag); 
      print_string(cheese_rec.nbtimes,'9999999999',2);
      print_string;

   END LOOP;
   CLOSE cheese_curvar;
         
END give_statistics;


PROCEDURE give_aledir
/*
|| Give the default value of variable $ALEDIR 
*/
IS
   head INTEGER;
   flag VARCHAR2(10) := ' ';
   aledir_dir MENUDEFAULTS.ParamValue%TYPE;
    
BEGIN

   aledir_dir := give_default('ALEDIR');

   head := 0;
   print_header(head,flag); 
   print_string(aledir_dir);
   print_string;

END;


PROCEDURE init
   (a_in IN args)
/*
|| Page 1 of the scanbook user interface
|| Menus and buttons initialization
*/
IS
   local_args args;
 
BEGIN

   Update_UsersStats(a_in);

   local_args.header := 0;
   give_runbyyear(local_args);                           

   local_args.header := 4;
   give_institutes(local_args);                          

   local_args.header := 5;
   local_args.page_number := '1';
   local_args.menutype := 'TypeofData';
   local_args.typedat := give_default('Type_Data'); 
   fill_other_menus(local_args);

   IF local_args.typedat = 'Real DATA'
   THEN
      local_args.header := local_args.header + 1;                   
      local_args.page_number := '1';
      local_args.menutype := 'WhatyouWant';
      fill_other_menus(local_args);
   END IF;

   local_args.header := 3;                   
   local_args.mcyear := give_default('McYear');
   local_args.institute := give_default('Institute');    
   kinbyyear(local_args);

END init;


PROCEDURE init2
   (a_in IN args)
/*
|| Page 2 of the scanbook user interface
|| Menus and buttons initialization
*/
IS
   local_args args := a_in;

   year_is DATASETS.RawYear%TYPE;
   lep_category ENERGYLEP.LepCategory%TYPE;   

   energylep_default VARCHAR2(10) := 'ANY';
   specpar_default VARCHAR2(20)  := 'ANY';
   menu VARCHAR2(20);
   found INTEGER;

BEGIN

   local_args.header := 3;
   local_args.page_number := '2';
   local_args.menutype := 'WhatyouWant';
   local_args.typedat := 'All DATA'; 
   fill_other_menus(local_args);
  
   local_args.header := 7;                              /* Page 1 menu - Real Data years'list */
   give_year_list(local_args,1,a_in.datayear);
   
   IF a_in.typedat = 'Real DATA'                        /* Real Data */
   THEN
      year_is := convert_year(a_in.datayear);
      lep_category := give_lepcategory(a_in.datayear);   

      local_args.header := 4; 
      local_args.page_number := '2';
      local_args.menutype := 'RunQuality';
      local_args.typedat := a_in.typedat; 
      fill_other_menus(local_args);

      local_args.header := 0;

      give_datalepenergy(local_args);

/* If 'RAW' or 'DRAW' is selected don't execute give_processing_level */

      local_args.header := 5;
      IF INSTR(a_in.data_type,'RAW') = 0
      THEN
         IF year_is = 1995 AND lep_category = 'LEP 1.5'              
         THEN
            energylep_default := 'LEP1.5';
         ELSIF year_is >= 1996
         THEN 
            energylep_default := 'LEP2';
         END IF;

         local_args.page_number := '2';
         local_args.menutype := 'RunQuality';
         local_args.runquality := give_othermenus_default(local_args);
         local_args.energy_lep := energylep_default;

         give_processing_level(local_args);

      END IF;

      local_args.header := local_args.header + 1;
      give_goodbad(local_args);
      
/* Inform the Java program that page 2 is different */ 
      IF give_action('WhatyouWant',a_in.wantwhat) = 'RunsInfo'  
      THEN
         menu := 'WhatyouWant';
         send_message(7,menu,a_in.wantwhat);
      END IF; 
       
   ELSE                                                        /* Monte Carlo Data */

/* Check if some data exist for the user's selections */
      found := mcdata_found(local_args);
      IF found = 0
      THEN
         RETURN;
      END IF; 

      local_args.header := 0;
      give_mclepenergy(local_args);
    
      local_args.header := 1;
      local_args.energy_lep := energylep_default;
      local_args.specpar := specpar_default;

      giveSpecMcDat(local_args);

   END IF;

END init2;


PROCEDURE write_kinagain_fili
   (KinKWord IN VARCHAR2,
    Kinagain_KWord IN VARCHAR2)
/*
|| 
|| MonteCarlo Data
|| Procedure executed by the automatic Mcarlo production tool
|| to be able to do a Kin again production 
|| Give the FILI cards according to the Kingal Keyword and the Kinagain 
|| Keyword given as arguments.
*/
IS
   ErrorFlag     INTEGER := 0;
   Error_message VARCHAR2(100);

   RunsList     Int_Tab;
   Empty2List   Int_Tab;

   FiliList     Char_Tab;
   EmptyList    Char_Tab;
   loc_output   INTEGER := 0;

   fili_name    VARCHAR2(4)  := 'FILI';
   fili_line    VARCHAR2(500);

   cart_name    VARCHAR2(17) := 'ALDATA|EPIO|CART ';
   cart_label   VARCHAR2(10);
   tape_file    VARCHAR2(20);
   TapeNameFile VARCHAR2(20);
   size_file    VARCHAR2(10);
   exclam       VARCHAR2(10);
   
   nrec INTEGER;
   nblanks INTEGER;

   aledir_dir  MENUDEFAULTS.ParamValue%TYPE;

BEGIN

   RunsList := Empty2List;
   FiliList := EmptyList;

DECLARE

   CURSOR run_cur 
   IS
      SELECT RunNumb 
      FROM MCSETS
      WHERE Datatype = 'KINGAL'
        AND KingalKeyWord = Kinagain_KWord
      ORDER by RunNumb
      ;

   CURSOR mc_fili_cur 
   IS 
      SELECT RunNumb, TapeId, TapeNumb, FileNumb, Details, 
             SizeMbytes, Nevents, KingalKeyWord
      FROM MCSETS 
        WHERE Datatype = 'KINGAL'
          AND KingalKeyWord = KinKWord
        ORDER by TapeId, TapeNumb, FileNumb
        ;

BEGIN
/*
|| Fill the list of existing Runs for the Kinagain Keyword 
|| parameter 
*/ 
   FOR a_rec IN run_cur
   LOOP
      RunsList(a_rec.RunNumb) := a_rec.RunNumb;
   END LOOP;

/* 
|| For all runs NOT already processed in kinagain (RunsList)
|| Write the FILI cards.
|| NB: There are no edir files for the KINGAL
*/
   nrec := 0;

   FOR a_rec IN mc_fili_cur
   LOOP
      IF RunsList.EXISTS(a_rec.RunNumb)   
      THEN
         NULL;
      ELSE

         nrec := nrec + 1;
         TapeNameFile := give_tape(a_rec.TapeId,a_rec.TapeNumb,a_rec.FileNumb); 

         tape_file := TapeNamefile;
         tape_file := REPLACE(tape_file,'_','.');

         size_file := '-s ' || to_char(a_rec.SizeMbytes);
         nblanks := 11 - LENGTH(TapeNameFile);

         FOR jk IN 1 .. nblanks
         LOOP
            size_file := ' ' || size_file;
         END LOOP;

         cart_label := give_Cart_label(a_rec.TapeId);

         exclam := '  ! ';
         IF a_rec.SizeMbytes < 100
         THEN
            exclam := ' ' || exclam;
         END IF;

         fili_line := fili_name || ' ''' || cart_name ||
                      tape_file || cart_label || size_file ||
                      '''' || exclam || a_rec.Details || '#' || to_char(a_rec.Nevents);
     
         loc_output := loc_output + 1;
         FiliList(loc_output) := '^' || to_char(a_rec.RunNumb) || fili_line;
      
      END IF;
   END LOOP;

   IF nrec = 0
   THEN
      ErrorFlag := -999;
      Error_message := '^' || 'For KingalKeyWord='|| KinKWord || ' No runs found to be kinagained with KinagainKeyWord=' || Kinagain_KWord; 
   END IF;

--   dbms_output.put_line('Error flag = ' || to_char(ErrorFlag));
   htp.prn(ErrorFlag);

   IF ErrorFlag != 0
   THEN
--      dbms_output.put_line('Error_message = ' || Error_message);
      htp.prn(Error_message);
   ELSE
      dbms_output.put_line('Nb of fili = ' || to_char(FiliList.COUNT));

      FOR jj IN 1 .. FiliList.COUNT
      LOOP
--         dbms_output.put_line(FiliList(jj));
         htp.prn(FiliList(jj));
      END LOOP;
   END IF;

   htp.print;
END;
END write_kinagain_fili;


PROCEDURE COLONEL
   (  procname      IN VARCHAR2,
      kingal_conds  IN VARCHAR2 := NULL,
      kinlist       IN VARCHAR2 := NULL,
      mcyear        IN VARCHAR2 := NULL,
      mcdatasets    IN VARCHAR2 := NULL,
      specpar       IN VARCHAR2 := NULL,
      institute     IN VARCHAR2 := NULL,
      KinMass       IN VARCHAR2 := NULL,
      wantwhat      IN VARCHAR2 := NULL,
      data_type     IN VARCHAR2 := NULL,
      typedat       IN VARCHAR2 := NULL,
      energy_lep    IN VARCHAR2 := NULL,
      datayear      IN VARCHAR2 := NULL,
      runorfill     IN VARCHAR2 := NULL,
      runorcart     IN VARCHAR2 := NULL,
      runquality    IN VARCHAR2 := NULL,
      PhysGroups    IN VARCHAR2 := NULL,
      selby         IN VARCHAR2 := NULL,
      menutype      IN VARCHAR2 := NULL,
      page_number   IN VARCHAR2 := NULL,
      processings   IN VARCHAR2 := NULL,
      filisorted    IN VARCHAR2 := NULL,
      OutputType    IN VARCHAR2 := NULL,
      ediryesno     IN VARCHAR2 := NULL,
      user_name     IN VARCHAR2 := NULL,
      hardware      IN VARCHAR2 := NULL,
      os_name       IN VARCHAR2 := NULL,
      ip_address    IN VARCHAR2 := NULL,
      navigator     IN VARCHAR2 := NULL,
      stat_by       IN VARCHAR2 := NULL,
      web_output    IN VARCHAR2 := NULL,
      ProgVers      IN VARCHAR2 := ' ',
      aledir        IN VARCHAR2 := NULL,
      header        IN VARCHAR2 := NULL
   )
/*
|| This procedure executes the other procedures according to
|| the value of the argument procname.
*/

IS
   arguments args;

   action_is OTHERMENUS.Action%TYPE; 
   first_sel INTEGER;
   sel_run INTEGER;
   year_is MENUDEFAULTS.ParamValue%TYPE;
   select_is VARCHAR2(10);

   OfficProg VARCHAR2(100);
   Official_progvers VARCHAR2(100);
   loc_sep INTEGER;
   update_date VARCHAR2(100);

   iok INTEGER;
   status VARCHAR2(100);

   loc_arrow INTEGER;

BEGIN

   arguments.procname      := procname;
   arguments.kingal_conds  := kingal_conds;
   arguments.kinlist       := kinlist;
   arguments.mcyear        := mcyear;      
   arguments.mcdatasets    := mcdatasets;      
   arguments.specpar       := specpar;      
   arguments.institute     := institute;   
   arguments.KinMass       := KinMass;
   arguments.wantwhat      := wantwhat;     
   arguments.data_type     := data_type;
   arguments.typedat       := typedat;      
   arguments.energy_lep    := energy_lep;   
   arguments.datayear      := datayear;      
   arguments.runorfill     := runorfill;     
   arguments.runorcart     := runorcart;     
   arguments.runquality    := runquality;     
   arguments.PhysGroups    := PhysGroups;   
   arguments.selby         := selby;
   arguments.menutype      := menutype;
   arguments.page_number   := page_number;
   arguments.processings   := processings;
   arguments.filisorted    := filisorted;
   arguments.OutputType    := OutputType;
   arguments.ediryesno     := ediryesno;

   arguments.user_name     := user_name;
   arguments.hardware      := hardware;
   arguments.os_name       := os_name;
   arguments.ip_address    := ip_address;
   arguments.navigator     := navigator;

   arguments.ProgVers      := ProgVers;

   arguments.aledir        := aledir;

   arguments.stat_by       := stat_by;


   arguments.header := NULL;
   IF header IS NOT NULL
   THEN
      arguments.header := to_number(header);
   END IF;

/*
|| If web_output parameter is not NULL 
|| Change the default MIME header that the PL/SQL Agent returns
|| Compare the Java and Oracle programs versions - If there are
|| different print a warning.  
*/ 

   Global_web_output := web_output;
   IF Global_web_output IS NOT NULL
   THEN
      owa_util.mime_header('text/plain',TRUE);

      OfficProg := LTRIM(scanbook_version.give_ProgramsVersion);
      loc_sep := INSTR(OfficProg, '|');
      Official_progvers := SUBSTR(OfficProg,1,loc_sep-2);
      update_date := SUBSTR(OfficProg,loc_sep+2,LENGTH(OfficProg));

      IF ProgVers != Official_progvers
      THEN    
         print_string('*');
         print_string;
         print_string('*        !!!!!  WARNING  !!!!! ');
         print_string('*');
         print_string;
         print_string('*  **** Incompatible program Versions  ****');
         print_string;
         print_string('*');
         print_string;
         print_string('*  Java:          ' || ProgVers);
         print_string;
         print_string('*  Oracle PL/SQL: ' || Official_progvers);
         print_string;
         print_string('*');
         print_string;
         print_string('*  Please upgrade your scanbook client');
         print_string;
         print_string('*');
         print_string;
         print_string('*  Version ' || Official_progvers || ' has been released on ' || 
                    update_date);
         print_string;
         print_string('*');
         print_string;
         print_string('* ------------------------------------------------------------' ||
                        '------------------------------------------------------------');
         print_string;
      END IF;
   END IF;   

/* 
|| If action is 'Calib'  
|| change the datatype 'POT' into 'DPOT'
||                     'RAW' into 'DRAW'
*/
   IF data_type IS NOT NULL 
   THEN
      action_is := give_action('WhatyouWant',arguments.wantwhat);
      IF action_is = 'Calib'
      THEN
         arguments.data_type := 'D' || data_type;
      END IF;
   END IF;

/* 
|| If action is 'RunorCart'  
|| From the Run selected find the corresponding datayear and set it
*/
   IF typedat = 'Real DATA' AND arguments.wantwhat IS NOT NULL
   THEN
      action_is := give_action('WhatyouWant',arguments.wantwhat);
      IF action_is = 'RunorCart'
      THEN
         select_is := SUBSTR(arguments.runorcart,1,3);
         IF SUBSTR(arguments.runorcart,1,3) = 'RUN'
         THEN
            sel_run := to_number(SUBSTR(arguments.runorcart,5,LENGTH(arguments.runorcart)));
            give_selyear(' ',sel_run,year_is);
            arguments.datayear := year_is;
         END IF;
      END IF;
   END IF;

/* 
|| If selection done by Runs or by Fills (Real Data)
|| Extract the first run or fill in the runorfill parameter
|| Then find the corresponding datayear and set it
*/
   IF typedat = 'Real DATA' AND arguments.wantwhat IS NOT NULL
   THEN
      action_is := give_action('WhatyouWant',arguments.wantwhat);
      IF action_is != 'RunorCart'
      THEN
         IF selby = 'RUN(s)' or selby = 'FILL(s)'
         THEN
            first_sel := to_number(SUBSTR(arguments.runorfill,5,5));
            give_selyear(arguments.selby,first_sel,year_is);
            arguments.datayear := year_is;
         END IF;
      END IF;
   END IF;

/* 
|| Set the parameter arguments.opt_arg to : 
||     'KinCode' if the parameter KinMass is NULL 
||     'KinMass' if the parameter KinMass is NOT NULL 
|| Modify the parameter arguments.KinMass depending of
||      a_in.KinMass parameter
*/
   IF KinMass IS NULL
   THEN 
      arguments.opt_arg := 'KinCode'; 
   ELSE
      arguments.opt_arg := 'KinMass';
   END IF;
  
   IF KinMass IS NULL OR INSTR(KinMass,'ANY') != 0
   THEN
      arguments.KinMass := '%';
   END IF;
   IF INSTR(KinMass,'Unknown') != 0 
   THEN
      arguments.KinMass := '0';
   END IF;

/*
|| For Real Data - If cut on lepenergy selected
|| Set the parameters arguments.firstenergy_cut and arguments.lastenergy_cut
*/
   IF typedat = 'Real DATA'
   THEN 
      loc_arrow := INSTR(arguments.energy_lep,'->'); 
      arguments.firstenergy_cut := SUBSTR(arguments.energy_lep,1,loc_arrow-1);
      arguments.lastenergy_cut  := SUBSTR(arguments.energy_lep,loc_arrow+2,LENGTH(arguments.energy_lep));
   END IF;

   IF LENGTH(runorfill) > 500
   THEN
      dbms_output.put_line(' Argument runorfill > 500 ');
   END IF;   


   IF procname = 'init'
   THEN
      init(arguments);
   END IF;
   IF procname = 'init2'
   THEN
      init2(arguments);
   END IF;
   IF procname = 'give_runbyyear'
   THEN 
      give_runbyyear(arguments);
   END IF;
   IF procname = 'give_institutes'
   THEN 
      give_institutes(arguments);
   END IF;
   IF procname = 'give_datalepenergy'
   THEN 
      give_datalepenergy(arguments);
   END IF;
   IF procname = 'kinbyyear'
   THEN 
      kinbyyear(arguments);
   END IF;
   IF procname = 'kincomments' 
   THEN 
      kincomments(arguments);
   END IF;
   IF procname = 'fill_other_menus' 
   THEN 
      fill_other_menus(arguments);
   END IF;
   IF procname = 'changed_lepenergy'
   THEN 
      changed_lepenergy(arguments);
   END IF;
   IF procname = 'give_mclepenergy' 
   THEN 
      give_mclepenergy(arguments);
   END IF;
   IF procname = 'giveSpecMcDat' 
   THEN 
      giveSpecMcDat(arguments);
   END IF;
   IF procname = 'give_special_particles' 
   THEN 
      give_special_particles(arguments);
   END IF;
   IF procname = 'give_mcdatasets' 
   THEN 
      give_mcdatasets(arguments);
   END IF;
   IF procname = 'give_goodbad' 
   THEN 
      give_goodbad(arguments);
   END IF;
   IF procname = 'give_processing_level' 
   THEN 
     give_processing_level(arguments);
   END IF;
   IF procname = 'write_fili_srun_cards' 
   THEN 
      write_fili_srun_cards(arguments);
   END IF;
   IF procname = 'write_mc_fili' 
   THEN 
      write_mc_fili(arguments);
   END IF;
   IF procname = 'write_srun_RunsInfo'  
   THEN 
      write_srun_RunsInfo(arguments);
   END IF;
   IF procname = 'write_RunorCart'  
   THEN 
      write_RunorCart(arguments);
   END IF;
   IF procname = 'write_GlobalStat'
   THEN  
      write_GlobalStat(arguments);
   END IF;
   IF procname = 'give_stats_buttons'
   THEN  
      give_stats_buttons;
   END IF;
   IF procname = 'give_statistics'
   THEN  
      give_statistics(arguments);
   END IF;
   IF procname = 'give_particles_masses'
   THEN  
      give_particles_masses(arguments);
   END IF;
   IF procname = 'give_WWBadRuns'
   THEN  
      give_WWBadRuns(arguments);
   END IF;
   IF procname = 'give_aledir'
   THEN  
      give_aledir;
   END IF;

/* End of procedure COLONEL */
   IF web_output IS NULL
   THEN
      print_string('-9 **** END ****');
   END IF;

END COLONEL;


PROCEDURE my_test
/*
|| Can be useful to debug
*/
IS
BEGIN
DBMS_OUTPUT.ENABLE (1000000);
--dbms_output.put_line(' Enter in my_test ');
----------
--COLONEL(
--procname=>'give_particles_masses'
--,user_name=>'jacotf'
--,os_name=>'Digital UNIX'
--,navigator=>''
--,hardware=>'alpha'
--,ip_address=>'137.138.214.203'
--,McYear=>'1998'
--,kinlist=>'5035            KRLW02        1488            295'
--,institute=>'CERN'
--);
----------
/* Keep some examples */
------dbms_output.put_line('   ---- Enter in my_test ---- ');

------dbms_output.put_line('   ---- Enter in procedure X - blabla = ' || blabla);

------dbms_output.put_line('   ---- Enter in procedure X - nrec = ' || to_char(nrec));

------print_string('-2   Enter in procedure X');
------print_string;

------print_string('-2   ---- Enter in procedure X - blabla = ' || blabla);
------print_string;

------print_string('-2   ---- Enter in procedure X - nrec = ' || to_char(nrec));
------print_string;

END my_test;

END scanbook_procedures;
/
show errors

-- Recompile package general_procedures
-- alter package general_procedures compile ;

@


1.26
log
@Modifs in write_kinagain_fili
@
text
@d4633 1
a4633 2
      all_tapes(tape_and_file).Program := 'GALEPH_Version: ' || 'JULIA_Version: '; 
      IF tapes_rec.Datatype = 'MINI'
d4635 5
a4639 1
         all_tapes(tape_and_file).Program := all_tapes(tape_and_file).Program || 'MINI_Version:'; 
d4799 1
a4799 2
      nstr := 2;
      IF all_tapes(current_tape).Nature = 'MINI'
d4801 17
a4817 1
         nstr := 3;
a4818 12

      str := all_tapes(current_tape).Program;
      FOR i IN 1 .. nstr
      LOOP
         split_string(str,first_word,reste);
         print_header(local_args.header,flag); 
         print_string(first_word);
         nblanks := 17 - LENGTH(first_word);
         print_string(ProgList(i),'999',nblanks);
         print_string; 
         str := reste;
      END LOOP;
@


1.25
log
@LEP1.5 introduced in menu button lep energy
@
text
@d6555 3
d6579 1
d6583 19
a6601 15
   CURSOR mc_fili_cur IS
      SELECT msets.RunNumb, msets.TapeId, msets.TapeNumb, msets.FileNumb, msets.Details, 
             msets.ExistEdir, msets.SizeMbytes, msets.Nevents, msets.KingalKeyWord
      FROM MCSETS msets
      WHERE 
            msets.Datatype like 'KINGAL'
        AND msets.KingalKeyWord like KinKWord
        AND (msets.RunNumb NOT IN (
               SELECT ms.RunNumb 
               FROM MCSETS ms 
               WHERE ms.KingalKeyWord like Kinagain_KWord
               )
        )
        ORDER by msets.TapeId, msets.TapeNumb, msets.FileNumb
      ; 
d6604 9
d6614 1
d6616 1
a6616 1
|| There are no edir files for the KINGAL
d6619 1
d6622 4
a6625 2
      nrec := nrec + 1;
      TapeNameFile := give_tape(a_rec.TapeId,a_rec.TapeNumb,a_rec.FileNumb); 
d6627 2
a6628 2
      tape_file := TapeNamefile;
      tape_file := REPLACE(tape_file,'_','.');
d6630 2
a6631 2
      size_file := '-s ' || to_char(a_rec.SizeMbytes);
      nblanks := 11 - LENGTH(TapeNameFile);
d6633 23
a6655 11
      FOR jk IN 1 .. nblanks
      LOOP
         size_file := ' ' || size_file;
      END LOOP;

      cart_label := give_Cart_label(a_rec.TapeId);

      exclam := '  ! ';
      IF a_rec.SizeMbytes < 100
      THEN
         exclam := ' ' || exclam;
a6656 8

      fili_line := fili_name || ' ''' || cart_name ||
                   tape_file || cart_label || size_file ||
                   '''' || exclam || a_rec.Details || '#' || to_char(a_rec.Nevents);
     
      loc_output := loc_output + 1;
      FiliList(loc_output) := '^' || to_char(a_rec.RunNumb) || fili_line;

d6665 1
a6665 1
   dbms_output.put_line('Error flag = ' || to_char(ErrorFlag));
d6670 1
a6670 1
      dbms_output.put_line('Error_message = ' || Error_message);
d6677 1
a6677 1
         dbms_output.put_line(FiliList(jj));
@


1.24
log
@Bugs in write_RunInfo and write_Data_CartInfo
@
text
@d535 3
d1092 2
a1093 1
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   
d1124 2
a1125 2
||   - If 'ALL LEP2' selected
||     the list will contain ALL existing Lep energies > MaxEnergyLEP1 
d1128 5
a1132 1
||   - If 'ANNE_CUT' 
d1150 8
a1157 1
            IF a_rec.RoundedEnergy > MaxEnergyLEP1
d1180 1
a1873 1

d1974 2
a1975 2
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   

d2035 1
a2035 1
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1)
d2038 2
d2162 1
d2176 1
a2176 1
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   
d2182 1
a2182 1
BEGIN   
d2184 1
a2184 1
   IF loc_lepcat > 1                                          /* Year is 1995 */
d2218 1
a2218 1
|| Loop all energies found for the selected year
d2228 1
a2228 1
      IF min_energy = 0 AND energy_rec.RoundedEnergy > MaxEnergyLEP1
d2274 1
a2274 1
      IF year_is = 1995 AND lep_category = 'LEP 1.5' OR year_is >= 1996             
d2276 10
d2374 1
d2381 1
d2419 1
d2484 1
a2484 1
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1 AND lepenergy_in = 'LEP2')
d2488 2
d2536 1
a2536 1
                       (lep_energy = 'LEP2' AND rcond.RoundedEnergy > MaxEnergyLEP1 AND lepenergy_in = 'LEP2')
d2539 2
d2894 1
d2933 1
d2984 2
d3036 2
d3418 2
a3419 1
   MaxEnergyLEP1 INTEGER := to_number(give_default('MaxEnergyLEP1'));   
d3467 1
d3493 2
d6469 1
a6469 1

d6490 7
a6496 4
         IF year_is = 1995 AND lep_category = 'LEP 1.5' OR year_is >= 1996             
      THEN
         energylep_default := 'LEP2';
      END IF;
@


1.23
log
@New procedure + modifs display Mcarlo status
@
text
@d113 20
a132 20
         Tape       VARCHAR2(20) ,
         Nature     VARCHAR2(10) ,
         Proc_date  INTEGER      ,
         Location   VARCHAR2(10) ,
         First_run  INTEGER      ,
         Last_run   INTEGER      ,
         Nb_run     INTEGER      ,
         Start_run  INTEGER      ,
         Nevts      INTEGER      ,
         ExEnergy   NUMBER(10,3) ,
         Runs       VARCHAR2(400),
         Details    VARCHAR2(100),
         Program    VARCHAR2(100),
         GalVersion INTEGER      ,
         JulVersion INTEGER      ,
         MinVersion INTEGER      ,
         ProcLevel  VARCHAR2(10) ,
         CopyFlag   INTEGER      ,
         SizeMbytes INTEGER      ,          
         Nclass16   INTEGER      ,
d4081 1
a4081 1
   Run_per_tape VARCHAR2(400) := ' ';
d4837 1
a4837 1
   Run_per_tape VARCHAR2(400);
d4863 1
a4863 1

d5064 1
a5064 1

d5075 1
a5075 1
      tape_is := give_tape(tp_rec.TapeId,tp_rec.TapeNumb,tp_rec.FileNumb); 
d5084 1
d5101 1
a5101 1
         tape_and_file := cart_ID * 100000000 + tapes_rec.TapeNumb * 1000 + tapes_rec.FileNumb;
d5105 1
d5114 1
a5114 1
 
d5123 1
d5134 2
a5135 1
            all_tapes(tape_and_file).Tape := tape_is; 
d5163 1
a5394 1

a6526 1
   DBMS_OUTPUT.ENABLE(1000000);
a6528 3

   dbms_output.put_line('KinKWord = ' || KinKWord); 
   dbms_output.put_line('Kinagain_KWord = ' || Kinagain_KWord); 
@


1.22
log
@Correction for Raw ZD tapes
@
text
@d57 3
a59 3
         opt_arg        VARCHAR2(100),
         firstenergy_cut  VARCHAR2(100),
         lastenergy_cut VARCHAR2(100)
d156 5
d162 34
a195 34
      (  procname      IN VARCHAR2,
         kingal_conds  IN VARCHAR2 := NULL,
         kinlist       IN VARCHAR2 := NULL,
         mcyear        IN VARCHAR2 := NULL,
         mcdatasets    IN VARCHAR2 := NULL,
         specpar       IN VARCHAR2 := NULL,
         institute     IN VARCHAR2 := NULL,
         KinMass       IN VARCHAR2 := NULL,
         wantwhat      IN VARCHAR2 := NULL,
         data_type     IN VARCHAR2 := NULL,
         typedat       IN VARCHAR2 := NULL,
         energy_lep    IN VARCHAR2 := NULL,
         datayear      IN VARCHAR2 := NULL,
         runorfill     IN VARCHAR2 := NULL,
         runorcart     IN VARCHAR2 := NULL,
         runquality    IN VARCHAR2 := NULL,
         PhysGroups    IN VARCHAR2 := NULL,
         selby         IN VARCHAR2 := NULL,
         menutype      IN VARCHAR2 := NULL,
         page_number   IN VARCHAR2 := NULL,
         processings   IN VARCHAR2 := NULL,
         filisorted    IN VARCHAR2 := NULL,
         OutputType    IN VARCHAR2 := NULL,
         ediryesno     IN VARCHAR2 := NULL,
         user_name     IN VARCHAR2 := NULL,
         hardware      IN VARCHAR2 := NULL,
         os_name       IN VARCHAR2 := NULL,
         ip_address    IN VARCHAR2 := NULL,
         navigator     IN VARCHAR2 := NULL,
         stat_by       IN VARCHAR2 := NULL,
         web_output    IN VARCHAR2 := NULL,
         ProgVers      IN VARCHAR2 := ' ',
         aledir        IN VARCHAR2 := NULL,
         header        IN VARCHAR2 := NULL
d198 1
d1854 1
a1854 1
   kin_keyword VARCHAR2(12);
a2334 1
   date_time  VARCHAR2(60);
a2847 1
   date_time  VARCHAR2(60);
a3357 2
   date_time  VARCHAR2(60);

a5556 2
   loc INTEGER;

a5571 1
   begin_line   VARCHAR2(5);
a5572 3
   first_date INTEGER;
   last_date INTEGER;
   date_time VARCHAR2(60);
d5584 1
a5584 1
   kin_keyword VARCHAR2(12);
d6487 127
d6726 1
a6857 1
--      EXIT;
a7015 31































@


1.21
log
@bug in init2
@
text
@d2848 1
a2848 1

d2858 1
a2858 1

d2860 1
a2860 1

d3030 1
a3030 1

d3032 1
a3032 1

d3073 1
a3073 1
         IF a_in.data_type = 'DRAW' OR fili_rec.TapeId = 'R0'
@


1.20
log
@Suppress convert_lep_energy procedure
@
text
@d6405 5
a6409 1
   energylep_default VARCHAR2(6) := 'ANY';
d6427 3
d6441 1
a6442 1

d6445 5
d6454 1
d6456 1
@


1.19
log
@Bug in write_Mc_CartInfo
@
text
@a538 30
PROCEDURE convert_lep_energy
   (arg_in IN args,
    lep_energy OUT VARCHAR2)
/*
|| If necessary, modify the lep energy value to be able to use it in some "SELECT"
|| If lep_energy = 'ANNE_CUT' extract the first and the last energy selected
*/ 
IS
   local_args args := arg_in;

BEGIN

   IF INSTR(arg_in.energy_lep,'ANY') != 0
   THEN
      lep_energy := '%';
   ELSIF INSTR(arg_in.energy_lep,'ALL LEP2') != 0
   THEN
      lep_energy := 'LEP2';
   ELSIF INSTR(arg_in.energy_lep,'->') != 0
   THEN
      lep_energy := 'ANNE_CUT';
      local_args.firstenergy_cut := SUBSTR(lep_energy,1,INSTR(lep_energy,'->')-1);
      local_args.lastenergy_cut  := SUBSTR(INSTR(lep_energy,'->')+1,LENGTH(lep_energy));
   ELSE
      lep_energy := LTRIM(arg_in.energy_lep);
   END IF;

END; 


@


1.18
log
@bug in give_datalepenergy
@
text
@d4558 1
a4558 1
   if_file INTEGER;
a4568 1

d4570 1
a4570 1

a4635 1

d5529 3
a5531 1
            
d5541 1
d5548 1
a5548 1
                  FETCH crtmc_cur INTO crtdat_rec;
d5558 2
a5559 1
               write_Mc_CartInfo(local_args,tape_ident,tape_num,tape_file);
a5561 1
            CLOSE crtdat_cur;
d5564 1
a5564 2

   END IF; 
@


1.17
log
@last quote was missing in some fili cards
@
text
@a2188 1

d2275 1
a2289 1
   CLOSE cut_cur;
a5835 1

d6460 1
@


1.16
log
@Anne cuts added
@
text
@d2637 1
a2637 1
                         tape_file || cart_label || size_file ||
@


1.15
log
@add set arraysize 1
@
text
@d2 1
d57 3
a59 1
         opt_arg       VARCHAR2(100)
d211 1
d529 3
d539 30
d600 1
a600 1
   IF loc_lepcat > 1                                          /* Year is 1995 */
d621 1
a621 1
   IF loc_lepcat > 1                                          /* Year is 1995 */
d1116 3
d1147 4
d1154 6
d1171 7
d1189 1
d1282 1
a1282 1
    year_in IN INTEGER,
d1311 1
a1311 1
           AND GeometryYear = year_in
d1328 1
a1328 1
    year IN INTEGER,
d1346 1
a1346 1
     AND GeometryYear = year
d1985 3
d1996 7
d2046 2
d2168 3
a2170 1
|| Returns the list of available Data Lep Energy
d2179 2
d2182 6
d2197 1
a2197 1
   CURSOR e_cur IS
d2204 10
d2216 13
d2230 1
a2230 1
   FOR a_rec IN e_cur
d2232 2
d2235 8
d2244 1
a2244 1
      print_string(a_rec.RoundedEnergy, '99999999');
d2248 1
a2248 1
   IF nrec > 1                     /* More than 1 lep energy found */   
d2250 30
a2285 1
      
d2289 2
d2374 2
a2377 1

d2401 8
d2410 1
a2410 2
|| If a Lep Energy was selected by the user, set the argument filisorted to 'No '
|| Then, fill the Lep energies List
d2414 1
a2414 1
   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2'
d2419 1
d2481 2
d2531 2
d2887 3
d2910 7
d2923 1
a2923 1
   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2'
d2973 2
d3023 2
d3408 3
d3440 7
d3453 1
a3453 1
   IF local_args.energy_lep != '%' AND local_args.energy_lep != 'LEP2'
d3478 2
d4317 1
a4317 1
               print_string(' ',83);
d6566 2
d6694 1
a6713 1

d6737 10
a6746 1

@


1.14
log
@replace variable year to compile on oracle 8
@
text
@d1 1
@


1.13
log
@write_raw_fili_srun - raws in format epio
@
text
@d550 1
a550 1
   (year in VARCHAR2)
d560 2
a561 2
   year_is := year;
   loc_lepcat := INSTR(year, '/') + 1;
d564 1
a564 1
      year_is := SUBSTR(year,1,4);
d572 1
a572 1
   (year in VARCHAR2)
d582 1
a582 1
   loc_lepcat := INSTR(year, '/') + 1;
d585 1
a585 1
      lep_category := SUBSTR(year,loc_lepcat,LENGTH(year));
d1223 1
a1223 1
    year IN INTEGER,
d1252 1
a1252 1
           AND GeometryYear = year
@


1.12
log
@write_fili_srun + write_mc_fili
@
text
@d2691 2
a2692 1
   cart_name  VARCHAR2(17)   := 'ALDATA|EPIO|CART ';
d2700 1
a2700 1
   details DATASETS.Details%TYPE := '';
a2920 1

d2928 5
a2932 1
         IF a_in.data_type = 'DRAW' 
d2935 1
a2935 1
            type_name := 'ALDATA|EPIO|CART ';
d2938 4
a2941 3
            exclam := '  ! ';
            IF fili_rec.SizeMbytes < 100
            THEN
d2943 1
a2943 1
            END IF;
d2946 2
a2947 2

         fili_line := fili_name || ' ''' || run_fili || type_name ||
@


1.11
log
@nevents printed for mcarlo + all lep2 default
@
text
@d1266 36
d1892 1
a1892 1
 
d2432 2
a2433 1
|| For 'DPOT' there are no edir files
d2441 9
a2449 1
            nblanks := 11 - LENGTH(TapeNameFile);
d2457 1
a2457 1
                         LOWER(TapeNameFile) || edir_ft || before_type || 
d5401 6
a5406 5
   fili_name   VARCHAR2(4)  := 'FILI';
   edir_ft     VARCHAR2(6)  := '.edir';
   bos_type    VARCHAR2(4)  := 'EDIR';
   before_type VARCHAR2(10);
   fili_line   VARCHAR2(500);
d5433 3
d5449 1
d5452 1
d5471 1
a5471 1
             msets.ExistEdir, msets.SizeMbytes, msets.Nevents
d5513 5
d5520 5
a5524 1
/* Check if Access with Edir was selected */
d5528 9
a5536 1
         nblanks := 11 - LENGTH(TapeNameFile);
d5544 1
a5544 1
                      LOWER(TapeNameFile) || edir_ft || before_type || bos_type || 
d5571 5
d5577 1
a5577 1
         print_string(SUBSTR(fili_line,1,LENGTH(fili_line)));
d5579 7
d5587 10
@


1.10
log
@NSEQ card + print_header + no by/fill for year 2000
@
text
@d2102 6
a2107 4
         print_header(a_in.header,flag);
         print_string('ALL LEP2');
         print_string;
      END IF; 
a2108 2
      print_header(a_in.header,'*     ANY');
      print_string;
d2179 1
d2181 3
a2183 3
   last_date INTEGER;
   date_time VARCHAR2(60);
   nb_run INTEGER;
d2403 8
a2410 5
            before_type := ' | ';
            IF LENGTH(TapeNameFile) = 8
            THEN 
               before_type := '  | ';
            END IF;
d2418 7
a2424 5
            size_file := ' -s ' || to_char(fili_rec.SizeMbytes);
            IF LENGTH(TapeNameFile) = 8
            THEN 
               size_file := ' ' || size_file ;
            END IF;
d2631 1
a2631 1
   EmptyList Int_Tab;
d2634 1
a2634 1
   sel_flag VARCHAR2(10);
d2636 2
a2637 2
   last_sel INTEGER;
   RunFill VARCHAR2(500);
d2639 1
a2639 1
   last_run INTEGER;
d2643 4
a2646 4
   fili_name VARCHAR2(4)    := 'FILI';
   fili_line VARCHAR2(500);
   type_name VARCHAR2(30)   := '.NAT | NATI | CART ';
   cart_name VARCHAR2(17)   := 'ALDATA|EPIO|CART ';
d2648 1
a2648 1
   tape_file VARCHAR2(20);
d2650 4
a2653 3
   run_fili VARCHAR2(30);
   size_file VARCHAR2(10);
   exclam VARCHAR2(10);
a2654 1
   begin_line VARCHAR2(5);
d2656 1
a2656 1
   lep_energy_gev VARCHAR2(10);
d2659 1
a2659 1
   lep_energy_flag VARCHAR2(50) := '';
d2661 1
a2661 1
   nrec INTEGER;
d2663 4
a2666 3
   istart INTEGER;
   istop INTEGER;
   nzeros INTEGER;
d2668 1
a2668 1
   lumin_tot NUMBER;
d2670 1
d2672 3
a2674 3
   last_date INTEGER;
   date_time VARCHAR2(60);
   nb_run INTEGER;
d2873 2
a2874 1
         size_file := ' -s ' || to_char(fili_rec.SizeMbytes);
d2876 4
a2879 4
         IF LENGTH(TapeNameFile) = 8
         THEN 
            size_file := ' ' || size_file ;
         END IF;
d3888 2
a3889 2
   ifirst INTEGER;
   ilast INTEGER;
d4083 1
a4083 1
               print_string(' ',84);
d5356 3
a5358 3
   fili_name VARCHAR2(4)    := 'FILI';
   edir_ft VARCHAR2(6)      := '.edir';
   bos_type VARCHAR2(4)     := 'EDIR';
d5360 1
a5360 1
   fili_line VARCHAR2(500);
d5362 3
a5364 3
   cart_name VARCHAR2(17)   := 'ALDATA|EPIO|CART ';
   cart_label VARCHAR2(10);
   tape_file VARCHAR2(20);
d5366 3
a5368 3
   size_file VARCHAR2(10);
   exclam VARCHAR2(10);
   begin_line VARCHAR2(5);
d5374 1
d5420 1
a5420 1
             msets.ExistEdir, msets.SizeMbytes
d5467 11
a5477 8
         before_type := ' | ';
         IF LENGTH(TapeNameFile) = 8
         THEN 
             before_type := '  | ';
         END IF;
            fili_line := fili_name || ' ''' || aledir_dir || 
                         LOWER(TapeNameFile) || edir_ft || before_type || bos_type || 
                         '''  ! ' || a_rec.Details;
d5482 7
a5488 5
         size_file := ' -s ' || to_char(a_rec.SizeMbytes);
         IF LENGTH(TapeNameFile) = 8
         THEN 
            size_file := ' ' || size_file ;
         END IF;
d5500 1
a5500 1
                         '''' || exclam || a_rec.Details;
d5504 1
a5504 1
         print_string(SUBSTR(fili_line,1,132));
@


1.9
log
@little bug in lep_energy_flag stuff
@
text
@d84 1
a84 1
         Runs       VARCHAR2(400)         
d269 1
a269 1
   (value in INTEGER)
d274 1
a274 1
      IF value is NULL
d278 2
a279 17
         print_string(to_char(value, 'S9'));
      END IF;
   END IF;
END;


PROCEDURE print_flag
   (value in VARCHAR2)
IS
BEGIN
   IF Global_web_output IS NULL
   THEN
      IF value is NULL
      THEN
         print_string(' ');
      ELSE   
         print_string(value);
d303 1
a303 2
   print_header(head);
   print_flag(' ');
d306 1
a306 2
   print_header(head);
   print_flag(' ');
d309 1
a309 2
   print_header(head);
   print_flag(' ');
d1005 1
a1005 1
   flag CHAR := ' ';
d1045 1
a1045 2
      print_header(head);
      print_flag(flag);
d1278 1
a1278 1
   flag CHAR := ' ';
d1292 1
a1292 2
      print_header(a_in.header);
      print_flag(flag);
d1349 1
a1349 1
   flag CHAR := ' ';
d1369 1
a1369 2
      print_header(a_in.header);
      print_flag(flag);
d1390 1
a1390 1
   flag CHAR(2) := '  ';
d1414 1
a1414 1
         print_header(a_in.header);
d1416 1
a1416 1
         print_flag(flag);
d1443 1
a1443 1
   flag CHAR := ' ';
d1464 1
a1464 2
       print_header(a_in.header);
       print_flag(flag);
d1488 1
a1488 1
   flag CHAR := ' ';
d1510 1
a1510 2
      print_header(a_in.header);
      print_flag(flag);
d1525 1
a1525 2
      print_header(a_in.header);
      print_string('*   ANY');
d1553 1
a1553 1
   flag CHAR := ' ';
d1581 1
a1581 2
      print_header(head);
      print_flag(flag);
d1610 1
a1610 1
   flag CHAR := ' ';
d1639 1
a1639 2
      print_header(a_in.header);
      print_flag(flag);
d1649 1
a1649 2
      print_header(a_in.header);
      print_string('*   ANY');
d1715 1
a1715 1
   flag CHAR := ' '; 
d1744 1
a1744 2
      print_header(a_in.header);
      print_flag(flag);
d1755 1
a1755 2
      print_header(a_in.header);
      print_string('*ANY');
d1775 1
a1775 1
   flag CHAR := ' ';
d1820 1
a1820 2
      print_header(a_in.header);
      print_flag(flag);
d1881 1
a1881 1
   flag CHAR := ' ';
d1958 1
a1958 2
       print_header(a_in.header);
       print_flag(flag);
d1987 1
a1987 1
   flag CHAR := ' ';
d1993 1
a1993 2
   print_header(0);
   print_flag('-');
d2014 1
a2014 2
      print_header(0);
      print_flag(flag);
d2065 1
a2065 1
   flag CHAR := ' ';
d2093 1
a2093 2
      print_header(a_in.header);
      print_flag(flag);
d2102 1
a2102 2
         print_header(a_in.header);
         print_flag(flag);
d2107 1
a2107 2
      print_header(a_in.header);
      print_string('*     ANY');
d2151 1
a2151 1
   flag CHAR := ' ';
d2381 1
a2381 1
            print_header(local_args.header);
d2432 1
a2432 2
         print_header(local_args.header);
         print_flag(flag); 
d2447 1
d2453 1
a2453 2
      print_header(local_args.header); 
      print_flag(flag);
d2457 1
a2457 2
      print_header(local_args.header); 
      print_flag(flag);
d2469 1
a2469 2
         print_header(local_args.header); 
         print_flag(flag);
d2475 1
a2475 2
      print_header(local_args.header); 
      print_flag(flag);
d2484 1
a2484 2
         print_header(local_args.header); 
         print_flag(flag);
d2488 1
a2488 2
         print_header(local_args.header); 
         print_flag(flag);
d2492 1
a2492 2
         print_header(local_args.header); 
         print_flag(flag);
d2496 1
a2496 2
         print_header(local_args.header); 
         print_flag(flag);
d2500 1
a2500 2
         print_header(local_args.header); 
         print_flag(flag);
d2552 1
a2552 2
               print_header(local_args.header);
               print_flag(flag);
d2569 1
a2569 2
         print_header(local_args.header); 
         print_flag(flag);
d2588 15
d2635 1
a2635 1
   flag CHAR := ' ';
d2840 1
a2840 1
            print_header(local_args.header);
d2892 1
a2892 2
         print_header(local_args.header);
         print_flag(flag); 
d2911 1
a2911 2
      print_header(local_args.header); 
      print_flag(flag);
d2915 1
a2915 2
      print_header(local_args.header); 
      print_flag(flag);
d2927 1
a2927 2
         print_header(local_args.header); 
         print_flag(flag);
d2933 1
a2933 2
      print_header(local_args.header); 
      print_flag(flag);
d2942 1
a2942 2
         print_header(local_args.header); 
         print_flag(flag);
d2946 1
a2946 2
         print_header(local_args.header); 
         print_flag(flag);
d2950 1
a2950 2
         print_header(local_args.header); 
         print_flag(flag);
d2954 1
a2954 2
         print_header(local_args.header); 
         print_flag(flag);
d2958 1
a2958 2
         print_header(local_args.header); 
         print_flag(flag);
d3010 1
a3010 2
               print_header(local_args.header);
               print_flag(flag);
d3027 1
a3027 2
         print_header(local_args.header); 
         print_flag(flag);
d3046 15
d3074 1
a3074 1
   flag CHAR := ' ';
d3085 1
a3085 2
      print_header(head);
      print_flag(flag);
d3126 1
a3126 1
   RunFill   VARCHAR2(500);
d3128 1
a3128 1
   flag CHAR := ' ';
d3143 1
a3143 1
   Run_per_fill  VARCHAR2(255) := ' ';
d3286 2
a3287 2
--|| If the argument filisorted is set to 'Yes' write the lep energy 
--|| at the end of the srun cards.
d3293 1
a3293 2
      print_header(local_args.header); 
      print_flag(flag);
d3297 1
a3297 2
      print_header(local_args.header); 
      print_flag(flag);
d3309 1
a3309 2
         print_header(local_args.header); 
         print_flag(flag);
d3315 1
a3315 2
      print_header(local_args.header); 
      print_flag(flag);
d3324 1
a3324 2
         print_header(local_args.header); 
         print_flag(flag);
d3328 1
a3328 2
         print_header(local_args.header); 
         print_flag(flag);
d3332 1
a3332 2
         print_header(local_args.header); 
         print_flag(flag);
d3336 1
a3336 2
         print_header(local_args.header); 
         print_flag(flag);
d3340 1
a3340 2
         print_header(local_args.header); 
         print_flag(flag);
a3359 1

d3376 9
a3384 4
         IF all_fills.EXISTS(srun_rec.LepFill)
         THEN
            tot_NZ0Hadr := tot_NZ0Hadr + srun_rec.NumZ0;
            all_fills(srun_rec.LepFill).NZ0Hadr := tot_NZ0Hadr;
d3386 2
a3387 2
            Run_per_fill := Run_per_fill || to_char(srun_rec.RunNumb,'99999'); 
            all_fills(srun_rec.LepFill).Runs := Run_per_fill;        
d3389 2
a3390 2
            Lumi_per_fill := Lumi_per_fill + srun_rec.LUmin;
            all_fills(srun_rec.LepFill).LUmin := Lumi_per_fill;        
d3392 5
a3396 5
            VdetLumi_per_fill := VdetLumi_per_fill + srun_rec.VdetLumi;
            all_fills(srun_rec.LepFill).VdetLumi := VdetLumi_per_fill;        
         ELSE
            all_fills(srun_rec.LepFill).LepFill := srun_rec.LepFill;
            all_fills(srun_rec.LepFill).WDate := srun_rec.WritDate;
d3398 2
a3399 2
            tot_NZ0Hadr := srun_rec.NumZ0;
            all_fills(srun_rec.LepFill).NZ0Hadr := tot_NZ0Hadr;
d3401 1
a3401 1
            all_fills(srun_rec.LepFill).ExEnergy := srun_rec.ExactEnergy/1000;
d3403 2
a3404 2
            Lumi_per_fill := srun_rec.LUmin;
            all_fills(srun_rec.LepFill).LUmin := Lumi_per_fill;        
d3406 2
a3407 2
            VdetLumi_per_fill := srun_rec.VdetLumi;
            all_fills(srun_rec.LepFill).VdetLumi := VdetLumi_per_fill;        
d3409 3
a3411 3
            Run_per_fill := to_char(srun_rec.RunNumb,'99999'); 
            all_fills(srun_rec.LepFill).Runs := Run_per_fill;
         END IF;
d3413 4
a3416 3
         IF all_fills(srun_rec.LepFill).NZ0Hadr < 0
         THEN
            all_fills(srun_rec.LepFill).NZ0Hadr := 0;
a3418 1

a3442 1

d3461 1
a3461 2
            print_header(local_args.header);
            print_flag(flag);
d3477 1
a3477 2
      print_header(local_args.header); 
      print_flag(flag);
d3495 15
d3515 1
a3515 2
      print_header(local_args.header); 
      print_flag(flag);
d3520 1
a3520 2
   print_header(local_args.header); 
   print_flag(flag);
d3526 1
a3526 2
   print_header(local_args.header); 
   print_flag(flag);
d3530 2
a3531 3
/* Print List by Runs */
   print_header(local_args.header); 
   print_flag(flag);
d3535 1
a3535 2
   print_header(local_args.header); 
   print_flag(flag);
d3539 1
a3539 2
   print_header(local_args.header); 
   print_flag(flag);
d3560 1
a3560 2
         print_header(local_args.header);
         print_flag(flag);
d3581 1
a3581 2
   print_header(local_args.header); 
   print_flag(flag);
d3585 1
a3585 2
   print_header(local_args.header); 
   print_flag(flag);
d3590 1
a3590 2
   print_header(local_args.header); 
   print_flag(flag);
d3602 1
a3602 2
   print_header(local_args.header); 
   print_flag(flag);
d3614 1
a3614 2
   print_header(local_args.header); 
   print_flag(flag);
d3623 1
a3623 2
      print_header(local_args.header); 
      print_flag(flag);
d3670 8
a3677 5
/* Print List by Fills */
   print_header(local_args.header); 
   print_flag(flag);
   print_string(' ');
   print_string;
d3679 2
a3680 3
   print_header(local_args.header); 
   print_flag(flag);
   print_string('-------------------------------------------------------' ||
d3682 1
a3682 1
   print_string;
d3684 8
a3691 9
   print_header(local_args.header); 
   print_flag(flag);
   IF vlum = ' '
   THEN
      print_string('  Fill   Date      Exact    NZ0     Lumi       List of runs for this Fill ');
   ELSE
      print_string('  Fill   Date      Exact    NZ0     Lumi    '|| vlum || '    List of runs for this Fill ');
   END IF;
   print_string;
d3693 8
a3700 9
   print_header(local_args.header); 
   print_flag(flag);
   IF vlum = ' '
   THEN
      print_string('         yymmdd    Energy   Hadr    nb**-1' );
   ELSE
      print_string('         yymmdd    Energy   Hadr    nb**-1   nb**-1' );
   END IF;
   print_string;  
d3702 2
a3703 3
   print_header(local_args.header); 
   print_flag(flag);
   print_string('-------------------------------------------------------' ||
d3705 1
a3705 1
   print_string;
d3707 11
a3717 12
   current_fill := all_fills.FIRST;
   nb_run := 0;
   LOOP
      EXIT when current_fill is NULL;
      nb_run := LENGTH(all_fills(current_fill).Runs) / 6;
      print_header(local_args.header); 
      print_flag(flag);
      print_string(current_fill,'99999',1);
      print_string(all_fills(current_fill).Wdate,'99999999',2);
      print_string(all_fills(current_fill).ExEnergy,'999D999',2);
      print_string(all_fills(current_fill).NZ0Hadr,'99999',2);
      print_string(all_fills(current_fill).LUmin,'999D999',3);
d3719 1
a3719 10
      IF vlum != ' '
      THEN
         print_string(all_fills(current_fill).VdetLumi,'999D999',2);
      END IF;

      nwrite := 0;
      FOR nr IN 1 .. nb_run
      LOOP
         istart := nr * 6 - 5;
         IF nwrite = Nrun_per_fill 
d3721 1
a3721 2
            print_string;
            nwrite := 0;
d3723 11
a3733 3
         IF nwrite = 0 
         THEN
            IF istart = 1                       
d3735 1
a3735 6
               print_string(SUBSTR(all_fills(current_fill).Runs,istart,6), 4);
               nwrite := nwrite + 1;
            ELSE
               print_header(local_args.header);
               print_flag(flag);
               IF vlum = ' '
d3737 2
a3738 1
                  print_string(' ',45);
d3740 9
a3748 1
                  print_string(' ',54);
d3750 1
d3754 5
a3758 3
         ELSE
            print_string(SUBSTR(all_fills(current_fill).Runs,istart,6));
            nwrite := nwrite + 1;
a3759 6
      END LOOP;
      
      IF nwrite != 0
      THEN
         print_string;
      END IF;
d3761 1
a3761 1
      current_fill := all_fills.NEXT(current_fill);
d3763 2
a3764 1
   END LOOP;
d3768 1
a3768 2
      print_header(local_args.header); 
      print_flag(flag);
d3773 1
a3773 2
   print_header(local_args.header); 
   print_flag(flag);
d3777 1
a3777 2
   print_header(local_args.header); 
   print_flag(flag);
d3781 1
a3781 2
   print_header(local_args.header); 
   print_flag(flag);
d3786 1
a3786 2
   print_header(local_args.header); 
   print_flag(flag);
d3795 1
a3795 2
   print_header(local_args.header); 
   print_flag(flag);
d3804 1
a3804 2
   print_header(local_args.header); 
   print_flag(flag);
d3813 1
a3813 2
      print_header(local_args.header); 
      print_flag(flag);
d3871 1
a3871 1
   flag CHAR := ' ';
d3992 1
a3992 2
      print_header(local_args.header); 
      print_flag(flag);
d3997 1
a3997 2
   print_header(local_args.header); 
   print_flag(flag);
d4013 1
a4013 2
      print_header(local_args.header); 
      print_flag(flag);
d4018 1
a4018 2
   print_header(local_args.header); 
   print_flag(flag);
d4023 1
a4023 2
   print_header(local_args.header); 
   print_flag(flag);
d4027 1
a4027 2
   print_header(local_args.header); 
   print_flag(flag);
d4031 1
a4031 2
   print_header(local_args.header); 
   print_flag(flag);
d4043 1
a4043 2
      print_header(local_args.header); 
      print_flag(flag);
d4073 1
a4073 2
               print_header(local_args.header);
               print_flag(flag);
d4096 1
a4096 2
      print_header(local_args.header); 
      print_flag(flag);
d4101 1
a4101 2
   print_header(local_args.header); 
   print_flag(flag);
d4116 1
a4116 2
            print_header(local_args.header); 
            print_flag(flag);
d4121 1
a4121 2
         print_header(local_args.header); 
         print_flag(flag);
d4126 1
a4126 2
         print_header(local_args.header); 
         print_flag(flag);
d4130 1
a4130 2
         print_header(local_args.header); 
         print_flag(flag);
d4134 1
a4134 2
         print_header(local_args.header); 
         print_flag(flag);
d4139 1
a4139 2
         print_header(local_args.header); 
         print_flag(flag);
d4169 1
a4169 2
                  print_header(local_args.header);
                  print_flag(flag);
d4186 1
a4186 2
      print_header(local_args.header); 
      print_flag(flag);
d4190 1
a4190 2
      print_header(local_args.header); 
      print_flag(flag);
d4194 1
a4194 2
      print_header(local_args.header); 
      print_flag(flag);
d4200 1
a4200 2
         print_header(local_args.header); 
         print_flag(flag);
d4205 1
a4205 2
         print_header(local_args.header); 
         print_flag(flag);
d4216 1
a4216 2
         print_header(local_args.header); 
         print_flag(flag);
d4222 1
a4222 2
      print_header(local_args.header); 
      print_flag(flag);
d4226 1
a4226 2
      print_header(local_args.header); 
      print_flag(flag);
d4237 1
a4237 2
      print_header(local_args.header); 
      print_flag(flag);
d4241 1
a4241 2
      print_header(local_args.header); 
      print_flag(flag);
d4245 1
a4245 2
      print_header(local_args.header); 
      print_flag(flag);
d4249 1
a4249 2
      print_header(local_args.header); 
      print_flag(flag);
d4263 1
a4263 2
            print_header(local_args.header); 
            print_flag(flag);
d4273 1
a4273 2
      print_header(local_args.header); 
      print_flag(flag);
d4279 1
a4279 2
      print_header(local_args.header); 
      print_flag(flag);
d4315 1
a4315 1
   flag CHAR := ' ';
d4390 1
a4390 2
      print_header(local_args.header); 
      print_flag(flag);
d4396 1
a4396 2
   print_header(local_args.header); 
   print_flag(flag);
d4412 1
a4412 2
      print_header(local_args.header); 
      print_flag(flag);
d4417 1
a4417 2
   print_header(local_args.header); 
   print_flag(flag);
d4422 1
a4422 2
   print_header(local_args.header); 
   print_flag(flag);
d4426 1
a4426 2
   print_header(local_args.header); 
   print_flag(flag);
d4430 1
a4430 2
   print_header(local_args.header); 
   print_flag(flag);
d4439 1
a4439 2
      print_header(local_args.header); 
      print_flag(flag);
d4462 1
a4462 2
      print_header(local_args.header); 
      print_flag(flag);
d4467 1
a4467 2
   print_header(local_args.header); 
   print_flag(flag);
d4477 1
a4477 2
         print_header(local_args.header); 
         print_flag(flag);
d4482 1
a4482 2
         print_header(local_args.header); 
         print_flag(flag);
d4487 1
a4487 2
         print_header(local_args.header); 
         print_flag(flag);
d4491 1
a4491 2
         print_header(local_args.header); 
         print_flag(flag);
d4495 1
a4495 2
         print_header(local_args.header); 
         print_flag(flag);
d4500 1
a4500 2
         print_header(local_args.header); 
         print_flag(flag);
d4517 1
a4517 2
      print_header(local_args.header); 
      print_flag(flag);
d4521 1
a4521 2
      print_header(local_args.header); 
      print_flag(flag);
d4526 1
a4526 2
      print_header(local_args.header); 
      print_flag(flag);
d4530 1
a4530 2
      print_header(local_args.header); 
      print_flag(flag);
d4549 1
a4549 2
         print_header(local_args.header); 
         print_flag(flag);
d4557 1
a4557 2
      print_header(local_args.header); 
      print_flag(flag);
d4561 1
a4561 2
      print_header(local_args.header); 
      print_flag(flag);
d4572 1
a4572 2
      print_header(local_args.header); 
      print_flag(flag);
d4612 1
a4612 1
   flag CHAR := ' ';
d4712 1
a4712 2
      print_header(local_args.header); 
      print_flag(flag);
d4719 1
a4719 2
   print_header(local_args.header); 
   print_flag(flag);
d4726 1
a4726 2
      print_header(local_args.header); 
      print_flag(flag);
d4731 1
a4731 2
   print_header(local_args.header); 
   print_flag(flag);
d4735 1
a4735 2
   print_header(local_args.header); 
   print_flag(flag);
d4739 1
a4739 2
   print_header(local_args.header); 
   print_flag(flag);
d4760 1
a4760 2
         print_header(local_args.header);
         print_flag(flag);
d4782 1
a4782 2
   print_header(local_args.header); 
   print_flag(flag);
d4786 1
a4786 2
   print_header(local_args.header); 
   print_flag(flag);
d4791 1
a4791 2
   print_header(local_args.header); 
   print_flag(flag);
d4795 1
a4795 2
   print_header(local_args.header); 
   print_flag(flag);
d4800 1
a4800 2
   print_header(local_args.header); 
   print_flag(flag);
d4807 1
a4807 2
      print_header(local_args.header); 
      print_flag(flag);
d4955 1
a4955 2
      print_header(local_args.header); 
      print_flag(flag);
d4960 1
a4960 2
   print_header(local_args.header); 
   print_flag(flag);
d4973 1
a4973 2
         print_header(local_args.header); 
         print_flag(flag);
d4978 1
a4978 2
      print_header(local_args.header); 
      print_flag(flag);
d4983 1
a4983 2
      print_header(local_args.header); 
      print_flag(flag);
d4987 1
a4987 2
      print_header(local_args.header); 
      print_flag(flag);
d4991 1
a4991 2
      print_header(local_args.header); 
      print_flag(flag);
d4996 1
a4996 2
      print_header(local_args.header); 
      print_flag(flag);
d5030 1
a5030 2
               print_header(local_args.header);
               print_flag(flag);
d5047 1
a5047 2
      print_header(local_args.header); 
      print_flag(flag);
d5051 1
a5051 2
      print_header(local_args.header); 
      print_flag(flag);
d5055 1
a5055 2
      print_header(local_args.header); 
      print_flag(flag);
d5061 1
a5061 2
         print_header(local_args.header); 
         print_flag(flag);
d5066 1
a5066 2
         print_header(local_args.header); 
         print_flag(flag);
d5077 1
a5077 2
         print_header(local_args.header); 
         print_flag(flag);
d5083 1
a5083 2
      print_header(local_args.header); 
      print_flag(flag);
d5087 1
a5087 2
      print_header(local_args.header); 
      print_flag(flag);
d5099 1
a5099 2
      print_header(local_args.header); 
      print_flag(flag);
d5103 1
a5103 2
      print_header(local_args.header); 
      print_flag(flag);
d5107 1
a5107 2
      print_header(local_args.header); 
      print_flag(flag);
d5111 1
a5111 2
      print_header(local_args.header); 
      print_flag(flag);
d5125 1
a5125 2
            print_header(local_args.header); 
            print_flag(flag);
d5135 1
a5135 2
      print_header(local_args.header); 
      print_flag(flag);
d5141 1
a5141 2
      print_header(local_args.header); 
      print_flag(flag);
d5345 1
a5345 1
   flag CHAR := ' ';
d5488 1
a5488 2
         print_header(local_args.header);
         print_flag(flag); 
d5538 1
a5538 1
   flag CHAR := ' '; 
d5554 1
a5554 2
      print_header(a_in.header);
      print_flag(flag);
d5579 1
a5579 1
   flag CHAR := ' ';
d5667 1
a5667 2
      print_header(local_args.header); 
      print_flag(flag);
d5672 1
a5672 2
   print_header(local_args.header); 
   print_flag(flag);
d5678 1
a5678 2
   print_header(local_args.header); 
   print_flag(flag);
d5682 1
a5682 2
   print_header(local_args.header); 
   print_flag(flag);
d5705 1
a5705 2
               print_header(local_args.header); 
               print_flag(flag);
d5710 1
a5710 2
            print_header(local_args.header); 
            print_flag(flag);
d5714 1
a5714 2
            print_header(local_args.header); 
            print_flag(flag);
d5722 1
a5722 2
         print_header(local_args.header); 
         print_flag(flag);
d5771 1
a5771 2
      print_header(local_args.header); 
      print_flag(flag);
d5776 1
a5776 2
   print_header(local_args.header); 
   print_flag(flag);
d5782 1
a5782 2
   print_header(local_args.header); 
   print_flag(flag);
d5786 1
a5786 2
   print_header(local_args.header); 
   print_flag(flag);
d5808 1
a5808 2
               print_header(local_args.header); 
               print_flag(flag);
d5813 1
a5813 2
            print_header(local_args.header); 
            print_flag(flag);
d5817 1
a5817 2
            print_header(local_args.header); 
            print_flag(flag);
d5824 1
a5824 2
         print_header(local_args.header); 
         print_flag(flag);
d5987 1
a5987 1
   flag CHAR := ' ';
a5998 7
--   TYPE cheese_values IS
--      RECORD (
--         stat_type  VARCHAR2(100),
--         last_use   DATE         ,
--         nbtimes    INTEGER      
--      );

a6002 2
DBMS_OUTPUT.ENABLE (1000000);

a6010 10
--   IF give_action('Statistics',a_in.stat_by) = 'US'  
--   THEN
--      OPEN cheese_curvar FOR
--      SELECT usr.UserName stat_type, MAX(usr.NbUsages) nbtimes
--      FROM SCANBOOKUSERS usr, SCANBOOKSESSIONS sess
--      WHERE sess.UserName = usr.UserName
--      GROUP by usr.UserName 
--      ORDER by usr.LastUsage
--      ;

d6053 1
a6053 2
      print_header(head); 
      print_flag(flag);
d6063 1
a6063 2
      print_header(head); 
      print_flag(flag);
d6079 1
a6079 1
   flag CHAR := ' ';
d6087 1
a6087 2
   print_header(head); 
   print_flag(flag);
d6567 2
a6568 8
dbms_output.put_line(' Enter in my_test ');
--------

--COLONEL(
--procname=>'write_GlobalStat'
--,institute=>'CERN'
--);

d6580 1
a6580 34

--COLONEL(
--procname=>'write_RunorCart'
--,typedat=>'Real DATA'
--,institute=>'CERN'
--,wantwhat=>'All available informations on a Run or cartridge'
--,data_type=>'MINI'
--,DataYear=>'1998'
--,runorfill=>''
--,selby=>'YEAR'
--,RunOrCart=>'CRT y13663.41'
--,McYear=>'1998'
--);

COLONEL(
procname=>'init2'
,user_name=>'jacotf'
,os_name=>'Digital UNIX'
,navigator=>'JDK'
,hardware=>'alpha'
,ip_address=>'137.138.214.241'
,ProgVers=>'V0025'
,typedat=>'Real DATA'
,institute=>'CERN'
,wantwhat=>'List of Real Data cartridges and creation of FILI cards'
,data_type=>'MINI'
,DataYear=>'1995 /LEP 1'
,runorfill=>''
,selby=>'YEAR'
,RunOrCart=>''
,McYear=>'1999'
,kinMass=>''
);

@


1.8
log
@lep_energy_flag added
@
text
@d2470 1
a2470 1
         print_string(SUBSTR(fili_line,1,150));
d2926 1
a2926 1
         print_string(SUBSTR(fili_line,1,150));
@


1.7
log
@Bug corrige dans write_mc_fili (lep energy)
@
text
@d2213 1
d2395 2
d2401 2
d2420 1
a2420 1
                             LENGTH(LepEnergyList(jj)));
d2422 1
d2425 1
a2425 1
                          lep_energy_print || ' GEV === ***');
d2428 1
a2428 1

d2445 1
a2445 1
                         bos_type || '''  ! ' || fili_rec.Details;
d2465 1
a2465 1
                         exclam || fili_rec.Details;
d2470 1
a2470 1
         print_string(SUBSTR(fili_line,1,132));
d2482 2
d2526 6
a2531 1
         print_string('***** Some Runs have been excluded. To see their list you can: ');
d2557 11
d2591 1
d2610 1
d2617 1
a2619 5
            lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
            lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
            lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
  
d2622 1
a2622 1
                          ' nb**-1   ****');
d2685 1
d2850 2
d2853 1
d2856 2
d2877 1
d2880 1
a2880 1
                          lep_energy_print || ' GEV === ***');
d2921 2
a2922 1
                         tape_file || cart_label || size_file || '''' || exclam || details ;
d2926 1
a2926 1
         print_string(SUBSTR(fili_line,1,132));
d2937 2
d2981 6
a2986 1
         print_string('***** Some Runs have been excluded. To see their list you can: ');
d3012 11
d3046 1
d3065 1
d3072 1
a3074 5
            lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
            lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
            lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
  
d3077 1
a3077 1
                          ' nb**-1   ****');
d3316 2
d3360 6
a3365 1
         print_string('***** Some Runs have been excluded. To see their list you can: ');
d3390 10
d3516 1
a3518 5
         lep_energy_gev := SUBSTR(LepEnergyList(jj),1,LENGTH(LepEnergyList(jj))-3);
         lep_energy_reste := SUBSTR(LepEnergyList(jj),LENGTH(LepEnergyList(jj))-2,
                             LENGTH(LepEnergyList(jj)));
         lep_energy_print := lep_energy_gev || '.' || lep_energy_reste;
  
d6086 1
a6086 1
  usr_rec usr_cur%ROWTYPE;
@


1.6
log
@Update_UsersStats modified for scanbook experts
@
text
@d5500 1
@


1.5
log
@Bug for year 1995 corrected
@
text
@d5950 38
d5991 2
a5992 1
|| Update the SCANBOOKUSERS table 
d6002 5
d6024 1
a6024 1
         UserName like local_args.user_name
@


1.4
log
@Correct RunsInfo + web_output
@
text
@d853 3
a855 2
   loc INTEGER;
   year_is RUNBYYEAR.Year%TYPE;
d866 5
a870 1
         year_is := convert_year(a_in.datayear);
d875 2
a876 1
         WHERE year = year_is;
d899 3
a901 1
   year_is RUNBYYEAR.Year%TYPE;
d913 5
a917 1
         year_is := convert_year(a_in.datayear);
d922 2
a923 1
         WHERE year = year_is;
d3171 1
a3171 1
   IF a_in.datayear < 1996
d3174 1
a3174 1
   ELSIF a_in.datayear >= 2000
a6640 3
--   argg args;
--    OfficProg VARCHAR2(300);
--    iok INTEGER;
a6644 9
--   argg.ProgVers := '306';
/*
|| Verify if the user is using the official Programs Version 
|| If not, send him a message.
*/
--   dbms_output.put_line(' Before exec check_Progversion');
--   check_Progversion(argg,iok);

--   dbms_output.put_line(' After exec check_Progversion');
d6676 20
d6718 2
a6719 2
-- Recompile package new_general_procedures
-- alter package new_general_procedures compile ;
@


1.3
log
@bug WBADRUNS + print VdetLumi
@
text
@d94 6
a99 6
         ExEnergy   NUMBER       ,
         GoodRuns   INTEGER      ,
         Nbhabha    INTEGER      ,
         Lumi       NUMBER       ,
         Nhadr      INTEGER      ,
         VdetLumi   NUMBER       
d2197 4
d2400 5
d2406 1
a2406 2
                      to_char(to_number(LepEnergyList(jj)/1000)) || 
                      '.00 GEV === ***');
d2580 5
d2586 2
a2587 3
                      to_char(to_number(LepEnergyList(jj)/1000)) || 
                      '.00 GEV :   ' || to_char(lumin_tot) || 
                      ' nb**-1   ****');
d2647 4
d2832 5
d2838 1
a2838 2
                      to_char(to_number(LepEnergyList(jj)/1000)) || 
                      '.00 GEV === ***');
d3011 5
d3017 2
a3018 3
                      to_char(to_number(LepEnergyList(jj)/1000)) || 
                      '.00 GEV :   ' || to_char(lumin_tot) || 
                      ' nb**-1   ****');
d3105 4
d3119 5
a3123 6
   tot_ExEnergy NUMBER;
   tot_GoodRuns INTEGER;
   tot_Nbhabha  INTEGER;
   tot_Lumi     NUMBER;
   tot_Nhadr    INTEGER;
   tot_VdetLumi NUMBER;
a3319 1
   tot_GoodRuns := 0;
d3377 1
d3380 1
a3380 4
--            tot_ExEnergy := tot_ExEnergy + srun_rec.RoundedEnergy;
--            all_lepenergy(srun_rec.RoundedEnergy).ExEnergy := tot_ExEnergy;

            tot_GoodRuns := tot_GoodRuns + 1;
d3383 1
a3383 1
            tot_Nbhabha := tot_Nbhabha + srun_rec.NumBh;
d3386 1
a3386 1
            tot_Lumi := tot_Lumi + srun_rec.Lumin;
d3389 1
a3389 1
            tot_Nhadr := tot_Nhadr + srun_rec.NumZ0;
d3392 1
a3392 1
            tot_VdetLumi := tot_VdetLumi + srun_rec.VdetLumi;
d3395 2
a3396 5
--            all_lepenergy(srun_rec.RoundedEnergy).ExEnergy := srun_rec.ExactEnergy;

            tot_GoodRuns := tot_GoodRuns + 1;
            all_lepenergy(srun_rec.RoundedEnergy).GoodRuns := tot_GoodRuns;

a3397 1

a3398 1

a3399 1

d3441 6
a3446 1
      THEN 
d3448 2
a3449 3
                      to_char(to_number(LepEnergyList(jj)/1000)) || 
                      '.00 GEV :   ' || to_char(lumin_tot) || 
                      ' nb**-1   ****');
a3633 1

a3634 1

a3739 1
/*
d3760 1
a3760 1
      print_string('  Nominal LEP     Number of     Number of   Luminosity    Number of  ');
d3762 1
a3762 1
      print_string('  Nominal LEP     Number of     Number of   Luminosity    Number of           ' || vlum );
d3770 3
a3772 3
      print_string('  energy (Gev)    Good Runs      Bhabhas     nb**-1       e+ e- -> Hadrons    ');
   ELSE
      print_string('  energy (Gev)    Good Runs      Bhabhas     nb**-1       e+ e- -> Hadrons     nb**-1 ');
d3785 1
a3787 5
--                      '.00 GEV :   ' || to_char(lumin_tot) || 
      print_string('     ' || to_char(current_lepenergy/1000) || '.000 ');
      print_string(all_lepenergy(current_lepenergy).GoodRuns, '999999',7);
      print_string(all_lepenergy(current_lepenergy).Nbhabha, '9999999999',5);
      print_string;
d3789 14
a3802 4
--      IF vlum != ' '
--      THEN
--         print_string(all_lepenergy(current_lepenergy).VdetLumi,'999D999',2);
--      END IF;
d3804 6
a3812 1
*/
d6327 5
a6336 10
/*
|| If web_output parameter is not NULL 
|| Change the default MIME header that the PL/SQL Agent returns
*/ 
   Global_web_output := web_output;
   IF Global_web_output IS NOT NULL
   THEN
      owa_util.mime_header('text/plain',TRUE);
   END IF;   

d6380 48
@


1.2
log
@Nomination d'un COLONEL
@
text
@d67 1
a75 13
   TYPE badrun_values IS
      RECORD (
         FirstRun      INTEGER      ,
         LastRun       INTEGER      ,
         LUmin         NUMBER(10,3) ,
         Comments      VARCHAR2(200)
      );

   TYPE BadRuns_table IS
      TABLE of run_values
      INDEX BY BINARY_INTEGER;


d83 1
d92 15
d2040 1
a2040 1
      print_string(Luminosity,'999D999',4);
d2042 1
a2042 1
      print_string(a_rec.Commentaire,6);
d3058 1
d3070 1
a3070 1
   sel_flag VARCHAR2(10);
d3072 2
a3073 2
   last_sel INTEGER;
   RunFill VARCHAR2(500);
d3077 2
a3078 2
   begin_line VARCHAR2(5);
   current_run INTEGER;
d3080 1
d3085 2
a3086 2
   tot_NZ0Hadr INTEGER := 0;            
   Run_per_fill VARCHAR2(255) := ' ';
d3088 2
d3091 8
a3098 1
   date_time VARCHAR2(60);
d3101 9
a3109 7
   nb_runq INTEGER;
   nwd INTEGER;
   nblanks INTEGER;
   phys_sel VARCHAR2(60);
   istart INTEGER;
   nwrite INTEGER;
   rq_key RUNQUALS.RunqualKeyword%TYPE;
a3111 1
   runs_title VARCHAR2(200);
d3128 12
d3293 1
d3304 2
a3305 2
         all_runs(srun_rec.RunNumb).LepFill := srun_rec.LepFill;
         all_runs(srun_rec.RunNumb).WDate := srun_rec.WritDate;
d3307 6
a3312 5
         all_runs(srun_rec.RunNumb).EVnumb := srun_rec.EVnumb;
         all_runs(srun_rec.RunNumb).NumZ0 := srun_rec.NumZ0;
         all_runs(srun_rec.RunNumb).NumBh := srun_rec.NumBh;
         all_runs(srun_rec.RunNumb).LUmin := srun_rec.LUmin;
         all_runs(srun_rec.RunNumb).Runsel := srun_rec.RunSelection;
d3324 3
d3339 3
d3351 34
d3388 1
d3524 2
a3525 2
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
d3530 4
a3533 1
   print_string('  Run  LepFill  Date    Exact     Number of Events    ' ||
d3535 4
d3540 1
d3543 6
d3550 2
a3551 1
                  '  nb**-1      RunQ   Physics Tools Selections');
d3556 2
a3557 2
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
d3574 4
d3586 1
a3586 1
             print_string(runQ(iq), 6);
d3622 2
a3623 2
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
d3628 6
a3633 1
   print_string('  Fill   Date      Exact    NZ0     Lumi      List of runs for this Fill ');
d3635 1
d3638 6
a3643 1
   print_string('         yymmdd    Energy   Hadr    nb**-1' );
d3648 2
a3649 2
   print_string('----------------------------------------------------' ||
                '----------------------------------------------------');
d3662 1
a3662 1
      print_string(all_fills(current_fill).NZ0Hadr,'99999',1);
d3665 5
d3688 6
a3693 1
               print_string(' ',44);
d3720 1
d3731 53
d6624 2
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
         physgroups    VARCHAR2(300),
d47 2
a48 1
         useWsel       VARCHAR2(100),
d51 1
d54 1
a54 2
*/        
         stat_by       VARCHAR2(100),
d144 3
a146 1
   Global_web_output VARCHAR2(50);
d148 1
a148 1
   PROCEDURE general
d165 1
a165 1
         physgroups    IN VARCHAR2 := NULL,
d180 1
a180 1
         useWsel       IN VARCHAR2 := 'Ignore',
d186 1
a186 1

d803 193
d1179 1
a1179 1
FUNCTION convert_physgroups
d1182 1
a1182 1
|| Returns the physgroups modified according to the runquality selected 
d1188 3
d1192 1
a1192 1

d1202 4
a1205 1
   ELSIF a_in.runquality = 'Phys. Groups'
d1207 8
a1214 1
      RETURN a_in.physgroups;           
d1395 3
d1399 2
d1408 4
d1885 2
d1898 1
a1898 1
   phys_groups VARCHAR2(50):= convert_physgroups(a_in); 
d1959 1
a1959 1
                 AND (INSTR(a_in.useWsel,'Apply') = 0
a2136 23
PROCEDURE changed_Wsel
   (a_in IN args)
/*
|| Button W selections clicked
|| 1) Reinitialize the Lep Energy button
|| 2) Reexecute the procedure give_processing_level 
*/
IS

   local_args args := a_in;

BEGIN

      local_args.header := 0;
      give_datalepenergy(local_args);

      local_args.header := 1;
      local_args.energy_lep := 'ANY'; 
      give_processing_level(local_args);
                                
END changed_Wsel;


a2157 1

d2161 2
d2199 1
a2199 1
   phys_groups VARCHAR2(50):= convert_physgroups(a_in);
d2213 8
d2309 1
a2309 1
                 AND (INSTR(a_in.useWsel,'Apply') = 0
d2355 1
a2355 1
                 AND (INSTR(a_in.useWsel,'Apply') = 0
d2448 2
a2449 1
|| Write the SRUN cards. 
d2453 60
d2604 2
d2645 1
a2645 1
   phys_groups VARCHAR2(50):= convert_physgroups(a_in);
d2657 8
d2732 1
a2732 1
                 AND (INSTR(a_in.useWsel,'Apply') = 0
d2778 1
a2778 1
          AND (INSTR(a_in.useWsel,'Apply') = 0
d2868 1
d2872 60
d3017 1
a3017 1
BEGIN
d3060 2
d3097 1
a3097 1
   phys_groups VARCHAR2(50):= convert_physgroups(a_in);
d3111 8
d3155 1
a3155 1
          AND (INSTR(a_in.useWsel,'Apply') = 0
d3200 2
a3201 1
|| Do a loop on the lep energies.
d3203 60
a3263 1
   local_args.header := 1;
d3601 18
d5845 7
d5856 1
d5860 1
a5860 1
      OPEN cheese_curvar FOR
d5864 11
a5874 1
      ;
d5911 1
d5920 1
a5920 1
      stattype := cheese_rec.stat_type; 
d6082 1
a6082 2

PROCEDURE general
d6099 1
a6099 1
      physgroups    IN VARCHAR2 := NULL,
d6114 1
a6114 1
      useWsel       IN VARCHAR2 := 'Ignore',
d6131 4
a6134 1
   
d6163 1
a6163 1
   arguments.physgroups    := physgroups;   
d6177 3
a6179 1
   arguments.useWsel       := useWsel;
d6266 2
a6267 1
 
a6370 4
   IF procname = 'changed_Wsel'
   THEN  
      changed_Wsel(arguments);
   END IF;
d6376 1
a6376 1
/* End of procedure general */
d6382 1
a6382 1
END general;
d6390 3
d6397 9
d6407 1
a6407 1
--general(
d6412 1
a6412 1
--general(
d6424 1
a6424 1
--general(
@


1.1.1.1
log
@ import jscanbook
@
text
@@
