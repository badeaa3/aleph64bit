head	1.1;
access;
symbols
	jul313_3:1.1
	jul313_2:1.1
	jul313_1:1.1
	jul313:1.1
	jul312_1:1.1
	jul312:1.1
	jul311:1.1
	jul310_1:1.1
	jul310:1.1
	jul309_1:1.1
	jul309:1.1
	jul308_6:1.1
	jul308_5:1.1
	jul308_4:1.1
	jul308_3:1.1
	jul308_2:1.1
	jul308_1:1.1
	jul308:1.1
	jul307_4:1.1
	jul307_3:1.1
	jul307_2:1.1
	jul307_1:1.1
	jul307:1.1
	jul306_3:1.1
	jul306_2:1.1
	jul306_1:1.1
	jul306:1.1
	jul305_4:1.1
	jul305_3:1.1
	jul305_2:1.1
	jul305_1:1.1
	jul305:1.1
	jul304_3:1.1
	jul304_2:1.1
	jul304_1:1.1
	jul304:1.1
	jul303_7:1.1
	jul303_6:1.1
	jul303_5:1.1
	jul303_4:1.1
	jul303_3:1.1
	jul303_2_mc1:1.1
	jul303_2:1.1
	jul303_1_mc1:1.1
	jul303_1:1.1
	jul303_v:1.1
	jul303:1.1
	jul302_6:1.1
	jul302_5:1.1
	jul302_4:1.1
	jul302_3:1.1
	jul302_2:1.1
	jul302_1:1.1
	jul302:1.1
	jul285_1:1.1
	jul285:1.1
	jul284_1:1.1
	jul284:1.1
	jul283_1:1.1
	jul283:1.1
	jul282_1:1.1
	jul282:1.1
	jul281_3:1.1
	jul281_2:1.1
	jul281_1:1.1
	jul281:1.1
	jul280_1:1.1
	jul280:1.1;
locks; strict;
comment	@c @;


1.1
date	96.05.06.15.54.20;	author flr;	state Exp;
branches;
next	;


desc
@@


1.1
log
@re-installed jul280 from the historian source because some routines were missing.
@
text
@      SUBROUTINE VMKR90
C----------------------------------------------------------------------
C!  - PREPARE VMRE banks used in hit reconstruction
C!    For Vdet version '90
C!
C
C   A. Bonissent, June 1995
C
C?
C!======================================================================
#ifndef DOC
C      IMPLICIT NONE
C
      SAVE NAVMRE
C
#include "vmrejj.h"
#include "vregjj.h"
#include "bcs.h"
      LOGICAL FIRST
      DATA FIRST /.TRUE./
#include "bmacro.h"
      IF(FIRST)THEN
         FIRST=.FALSE.
         NAVMRE = NAMIND('VMRE')
      ENDIF
C
C  Find the bank
C
      KVMRE = IW(NAVMRE)
      IF( KVMRE .EQ. 0)THEN
        CALL RERROR('VMKR90',1,'Cant find database banks')
        GOTO 999
      END IF
C
C  Loop over the big bank and break it down into
C  separate banks for each wafer.
C
      NVMRE = LROWS(KVMRE)
      IF(NVMRE.NE.0)THEN
C
C  Decode the wafer address of the first region
C
        IADDR = ITABL(KVMRE,1,JVREFC)
        CALL VUNADD(IADDR,NCHAN,ILAY,IWFF,IFAC,IVIEW,ICHAN)
        CALL VAENWA(IROMD,ILAY,IWFF,IFAC,IVIEW)
      ENDIF
C Say that we start a new module
      NEWMD=1
      DO IVMRE=1,NVMRE
C
C  If we start a new module, make the bank - maximum possible size
C
        IF(NEWMD.EQ.1)THEN
          KVREG = NBANK('VREG',IROMD,LMHLEN+NVMRE*LVREGA)
          IF(KVREG .EQ. 0)THEN
            CALL RERROR('VMKR90',2,'Out of BOS space')
            GOTO 999
          END IF
          IW(KVREG+LMHCOL) = LVREGA
          IW(KVREG+LMHROW) = 0
          NEWMD=0
        END IF
C
C  Pack in the new region, unpacking the channel numbers where needed
C
        IW(KNEXT(KVREG)+JVREFC) = ICHAN+1
        IADDR = ITABL(KVMRE,IVMRE,JVMRLC)
        CALL VUNADD(IADDR,NCHAN,ILAY,IWFF,IFAC,IVIEW,ICHAN)
        IW(KNEXT(KVREG)+JVRELC) = ICHAN+1
        IW(KNEXT(KVREG)+JVRECS) = ITABL(KVMRE,IVMRE,JVMRCS)
        IW(KNEXT(KVREG)+JVRECS+1) = 0
        IW(KNEXT(KVREG)+JVRECS+2) = 0
        IW(KNEXT(KVREG)+JVRERF) = ITABL(KVMRE,IVMRE,JVMRRF)
        IW(KVREG+LMHROW) = LROWS(KVREG) + 1
C
C  Decode the wafer address of next region
C
        IADDR = ITABL(KVMRE,IVMRE+1,JVMRFC)
        CALL VUNADD(IADDR,NCHAN,ILAY,IWFF,IFAC,IVIEW,ICHAN)
        CALL VAENWA(IRONX,ILAY,IWFF,IFAC,IVIEW)
C
C  If new module or last row, remake bank to size
C
        IF(IRONX.NE.IROMD.OR.IVMRE.EQ.NVMRE)THEN
          NVREG = LROWS(KVREG)
          KVREG = NBANK('VREG',IROMD,LMHLEN+NVREG*LVREGA)
          IROMD=IRONX
          NEWMD=1
        END IF
      END DO
  999 CONTINUE
      RETURN
      END
#endif
@
