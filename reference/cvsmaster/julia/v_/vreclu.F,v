head	1.3;
access;
symbols
	jul313_3:1.3
	jul313_2:1.3
	jul313_1:1.3
	jul313:1.3
	jul312_1:1.3
	jul312:1.3
	jul311:1.3
	jul310_1:1.3
	jul310:1.3
	jul309_1:1.3
	jul309:1.3
	jul308_6:1.3
	jul308_5:1.3
	jul308_4:1.3
	jul308_3:1.3
	jul308_2:1.3
	jul308_1:1.3
	jul308:1.3
	jul307_4:1.3
	jul307_3:1.3
	jul307_2:1.3
	jul307_1:1.3
	jul307:1.3
	jul306_3:1.3
	jul306_2:1.3
	jul306_1:1.3
	jul306:1.3
	jul305_4:1.3
	jul305_3:1.3
	jul305_2:1.3
	jul305_1:1.3
	jul305:1.3
	jul304_3:1.3
	jul304_2:1.3
	jul304_1:1.3
	jul304:1.3
	jul303_7:1.3
	jul303_6:1.3
	jul303_5:1.3
	jul303_4:1.3
	jul303_3:1.3
	jul303_2_mc1:1.3
	jul303_2:1.3
	jul303_1_mc1:1.3
	jul303_1:1.3
	jul303_v:1.3
	jul303:1.3
	jul302_6:1.3
	jul302_5:1.3
	jul302_4:1.3
	jul302_3:1.3
	jul302_2:1.3
	jul302_1:1.3
	jul302:1.3
	jul285_1:1.3
	jul285:1.3
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.3
date	96.03.12.15.48.53;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.21.45;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.37;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.38;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@      SUBROUTINE VRECLU(IROMD,NR)
C
C----------------------------------------------------------------------
C!  - Select final clusters
C!
C!   Inputs:
C!        - IROMD       I/  cluster address from VHLS
C!
C!  Modified 16-1-94 by Dave Brown for the VDET upgrade
C!  Modified March 1995 A. Bonissent, M. Thulasidas
C!                 reorganise and debug
C?
C!======================================================================
#ifndef DOC
C      IMPLICIT NONE
      SAVE FIRST, NAVCSG, NAVPLH, NAVTRS, NAVPHN
C
C      INTEGER JVFLFG,LVFLGA
#include "vflgjj.h"
C      INTEGER JVFPPH,LVFPHA
#include "vfphjj.h"
C      INTEGER JVCOCM,LVCOMA
#include "vcomjj.h"
C      INTEGER JVFHHA,LVFHLA
#include "vfhljj.h"
#include "vdflgs.h"
#include "vrecon.h"
#include "vprtnc.h"
#include "vcsgjj.h"
C
C PARAMETERS-
C MSUNB = mask for defining generic 'unbonded' strip
C MSGOOD = ANTI-mask for defining generic good strip
C These are designed so that a half bonded strip will be counted
C as good, but will still be skipped over if it's in the middle
C of a cluster, and it's PH is below threshold.
C
      INTEGER MGOOD,MSKIP
      PARAMETER (MSKIP = VBUNBD+VBUNUS)
      PARAMETER (MGOOD = VBSUPP+VBHOTC+VBNOIS+VBUNBD+VBUNUS)
C
C  Input variables
C
      INTEGER MODNUM
      INTEGER KVFHL,KVFPH,KVFLG,KVCOM
C
C  Output variables- none
C
C  Functions
C
      INTEGER NBANK,NLINK
      INTEGER VFWAFF,VIWFFW
C
C  Local variables
C
      INTEGER NAVCSG,NAVFHL,NAVCOM,NAVFLG,NR
      INTEGER NAVPLH,NAVTRS,NAVFPH,NAVPHN
      INTEGER NVCSG,KVCSG,IVCSG,ILOOP
      INTEGER IPH,IBEG,IADDR
      INTEGER IRET,IMOD
      INTEGER ISTRP,JSTRP,KSTRP,IFRS,ILS,NSIZ
      INTEGER IROMD,ILAY,IWFF,IWAF,IWMX,IPHI,IVIEW
      INTEGER PSUM, NUNBD
      INTEGER IDUM,JDUM
      LOGICAL FIRST
      DATA FIRST /.TRUE./
      INTEGER IFLG,IFL,ISTRT,I
      LOGICAL SGOOD,SSKIP,IHIS1
      INTEGER NAMIND,VDYEAR
      INTEGER MSUNB
      PARAMETER (MSUNB = VBUNBD+VBUNUS)
      LOGICAL SUNBD, LOWTH
      INTEGER IWF,IVW,LYR
C
C  Inline functions
C
#include "bcs.h"
C      INTEGER LCOLS,LROWS,ID,KNEXT,KROW,NRBOS,LFRWRD,LFRROW,ITABL,L
C      REAL RTABL
#include "bmacro.h"
      SUNBD(IFLG) = IAND(IFLG,MSUNB).GT.0
      SGOOD(IFLG) = IFLG.GT.0.AND.IAND(IFLG,MGOOD).EQ.0
      SSKIP(IFLG) = IAND(IFLG,MSKIP).GT.0
      IHIS1(I) = IAND(I,1) .EQ. 1
      LOWTH(IWF,IVW,LYR) = IVW.EQ.1.AND.
     >   ((LYR.EQ.1.AND.IWF.NE.1).OR.(LYR.EQ.2.AND.IWF.EQ.3))
C
C Code starts here
C
      IF(FIRST)THEN
         FIRST=.FALSE.
         NAVCSG=NAMIND('VCSG')
      ENDIF
      KVFHL=NLINK('VFHL',NR)
      KVCOM=NLINK('VCOM',NR)
      KVFPH=NLINK('VFPH',NR)
      KVFLG=NLINK('VFLG',NR)
      KVCSG=IW(NAVCSG)
      NVCSG=LROWS(KVCSG)
C
C  Unpack the address
C
      CALL VADEWA(IROMD,ILAY,IWFF,IPHI,IVIEW)
C
C Find the module (1 or 2) this is useful for new Vdet
C IWAF is useless here
C
      IRET = VFWAFF(IWFF,IMOD,IWAF)
C
C  If requested, histogram
C
      IF(IHIS1(HISTLV))THEN
        DO IVCSG=1,NVCSG
          IPH=RTABL(KVCSG,IVCSG,JVCSMP+IWAF-1)
          IFL=ITABL(KVCSG,IVCSG,JVCSMF+IWAF-1)
          IF(SGOOD(IFL))CALL HFILL(HISOFF+13,
     &    FLOAT(IPH),0.0,1.0)
        END DO
      END IF
      ISTRT=1
      NSIZ=0
      NUNBD=0
      PSUM=0
C
C For new Vdet, we clusterize separately on each wafer;
C This is not done for Vdet91
C
      IWMX=1
      IF(VDYEAR().EQ.95)IWMX=3
      DO 100 IWAF=1,IWMX
      IF(IWMX.EQ.3.AND.LOWTH(IWAF,IVIEW,ILAY))THEN
        CALL VRECLT(KVFHL,KVFPH,KVFLG,KVCOM,
     >             ILAY,IPHI,IVIEW,IMOD,IWAF)
        GO TO 100
      ENDIF
      DO 101 ILOOP=1,NVCSG
        IVCSG=ILOOP+ISTRT-1
        IF(IVCSG.GT.NVCSG)IVCSG=IVCSG-NVCSG
        IPH=RTABL(KVCSG,IVCSG,JVCSMP+IWAF-1)
        IFL=ITABL(KVCSG,IVCSG,JVCSMF+IWAF-1)
        IF(SGOOD(IFL).AND.IPH.GE.MNPULS)THEN
          IF(NSIZ.EQ.0)THEN
             IBEG = IVCSG
             NUNBD=0
          ENDIF
          NSIZ = NSIZ + 1
          PSUM=PSUM+IPH
        ENDIF
        IF(NSIZ.GT.0)THEN
C
C-- one skips strips only if one has already started building
C-- a cluster
C
          IF(SSKIP(IFL))THEN
            NUNBD=NUNBD+1
            NSIZ = NSIZ+1
          ENDIF
C
C-- if (pulsht < 0 and good strip) or
C--    (end of module) or
C--    (too many unbounded strips) or
C--    (a bad strip)
C--    [ a bad strip is one that is not good AND can't be skipped ]
C-- then
C--    a cluster is found
C
          IF ((IPH.LT.MNPULS.AND.SGOOD(IFL)) .OR.
     $       IVCSG.EQ.NVCSG .OR.
     $       NUNBD.GT.MXUNBD .OR.
     $       (.NOT.SSKIP(IFL).AND..NOT.SGOOD(IFL))) THEN

C
C             HERE a cluster has been found
C
C Fix the bug for VDET95 only
C
             IF(VDYEAR().EQ.95)THEN
                IFRS=IBEG
                ILS=IFRS+NSIZ-1
             ELSE
C
C  VDET91
C
C Add one strip at each extremity
C and accumulate the pulseheight if strip is good
C
C
C******************** Here a bug is introduced to reproduce the  ********
C******************** results of the (bugged) official code      ********
C******************** January 1995                               ********
C  This will be studied in more details, and fixed as soon as possible
C  May have lateral effects like for example cluster separation
C
               IFRS=IBEG-1
               IF(IFRS.EQ.0)IFRS=NVCSG
               IFL=ITABL(KVCSG,IFRS,JVCSMF+IWAF-1)
C               IF(SGOOD(IFL))THEN     !   this would be right
               IF(SUNBD(IFL))THEN      !   BUG ******
                  PSUM=PSUM+RTABL(KVCSG,IFRS,JVCSMP+IWAF-1)
                  NSIZ=NSIZ+1
               ELSE
                  IFRS=IBEG
               ENDIF
               ILS=IFRS+NSIZ
               IFL=ITABL(KVCSG,ILS,JVCSMF+IWAF-1)
C               IF(SGOOD(IFL))THEN     !   this would be right
               IF(SUNBD(IFL))THEN      !   BUG ******
                   PSUM=PSUM+RTABL(KVCSG,ILS,JVCSMP+IWAF-1)
                   NSIZ=NSIZ+1
               ELSE
                   ILS=IFRS+NSIZ-1
               ENDIF
C
             ENDIF
             IF(IHIS1(HISTLV))THEN
               CALL HFILL(HISOFF+20,FLOAT(PSUM),0.0,1.0)
             END IF
C
C  Final sum pulseheight cut
C
             IF(PSUM .GE. FNLSUM)THEN
C
C  For Vdet95, we need to change IWAF, wafer in module, into
C  IWFF, wafer in face
C
               IF(VDYEAR().EQ.95)IRET = VIWFFW(IMOD,IWAF,IWFF)
C
C Put cluster in banks
C
               CALL VCLBNK(KVFHL,KVFPH,KVFLG,KVCOM,IFRS,ILS,
     >                     ILAY,IPHI,IVIEW,IWAF,IWFF)
C
C
C  Increment counter for run summary
C
               NFNLHT(IVIEW) = NFNLHT(IVIEW) + 1
             ENDIF
C
C Reset cluster size
C
             NSIZ=0
             PSUM=0
          ENDIF
        ENDIF
  101 CONTINUE
  100 CONTINUE
      RETURN
      END
#endif
@


1.2
log
@julia version 279
@
text
@a0 1
*DK vreclu
d15 4
d20 1
d22 1
d24 1
d56 2
a57 1
      INTEGER NAVCSG,NAVFHL,NAVCOM,NAVFPH,NAVFLG,NR
d60 1
d72 2
a73 1
      LOGICAL SUNBD
d78 2
d85 2
d131 6
a136 1
      DO 100 ILOOP=1,NVCSG
a222 3
C Fill cluster in bank
C
C  Pack address for VFHL bank
d228 5
a232 20
               CALL VPKADD(IADDR,
     &          NSIZ,ILAY,IWFF,IPHI,IVIEW,IFRS)
               IW(KNEXT(KVFHL)+JVFHHA)=IADDR
               IW(KVFHL+LMHROW) = LROWS(KVFHL) + 1
C
C  Pack common mode word- use first strip of cluster
C
               IW(KNEXT(KVCOM)+JVCOCM) = ITABL(KVCSG,IFRS,JVCSCM)
               IW(KVCOM+LMHROW) = LROWS(KVCOM) + 1
C
C  Pack strips and flags
C
               DO JSTRP=IFRS,ILS
                 IW(KNEXT(KVFPH)+JVFPPH) =
     >                            RTABL(KVCSG,JSTRP,JVCSMP+IWAF-1)
                 IW(KNEXT(KVFLG)+JVFLFG) =
     >                            ITABL(KVCSG,JSTRP,JVCSMF+IWAF-1)
                 IW(KVFPH+LMHROW) = LROWS(KVFPH) + 1
                 IW(KVFLG+LMHROW) = LROWS(KVFLG) + 1
               END DO
d245 1
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
      SUBROUTINE VRECLU(IADDR,IPULS,IFLAG,ICOMM,
     &  IVFHL,IVFPH,IVFLG,IVCOM)
C!======================================================================
d8 1
a8 6
C!        - IADDR       I/  cluster address from VHLS
C!        - IPULS       I/  array of strips pulses
C!        - IFLAG       I/  array for hot channels flags
C!        - ICOMM       I/  array of common mode
C!        - IVFHL, IVFPH, IVFLG, IVCOM
C!                      I/  banks pointers
d10 3
a15 2
#include "implicit.h"
#include "vdimpl.h"
d18 1
a19 1
#include "vcomjj.h"
a20 1
#include "bcs.h"
d23 1
d32 2
a33 3
      INTEGER MGOOD,MSUNB,MSKIP
      PARAMETER (MSKIP = VBUNBD+VBUNUS+VBHALF)
      PARAMETER (MSUNB = VBUNBD+VBUNUS)
d38 2
a39 2
      INTEGER IADDR,IPULS(*),IFLAG(*),ICOMM(*)
      INTEGER IVFHL,IVFPH,IVFLG,IVCOM
d46 1
d50 5
a54 2
      INTEGER JSTRP,KSTRP,LSTRP,MSTRP,OSTRP
      INTEGER ILAY,IWAF,IPHI,IVIEW
d57 8
a64 7
      REAL DUMMY
C
C  Variables for inline functions
C
#include "vdbmcr.h"
      INTEGER IFLG ,I
      LOGICAL SGOOD,SUNBD,SSKIP,IHIS1
d68 1
d70 1
a71 1
      SUNBD(IFLG) = IAND(IFLG,MSUNB).GT.0
d75 13
d90 6
a95 1
      CALL VADDUN(IADDR,IDUM,ILAY,IWAF,IPHI,IVIEW,JDUM)
d100 6
a105 4
        DO 32 JSTRP=1,NSTPWF
          IF(SGOOD(IFLAG(JSTRP)))CALL HFILL(HISOFF+13,
     &    FLOAT(IPULS(JSTRP)),DUMMY,1.0)
   32   CONTINUE
d107 93
d201 1
a201 1
C  Loop over all channels, looking for strips above threshold
d203 3
a205 94
      JSTRP = 1
   20 CONTINUE
      IF(JSTRP.LE.NSTPWF)THEN
C
C  Look for strips above threshold that aren't flagged as noisy
C  or unbonded.  Also, histogram where necessary
C
        IF(.NOT.SGOOD(IFLAG(JSTRP)).OR.IPULS(JSTRP).LT.MNPULS)THEN
          JSTRP = JSTRP + 1
        ELSE
C
C  Start a cluster
C
          MSTRP = 1
          PSUM = IPULS(JSTRP)
          NUNBD = 0
C
C  Add strips to this cluster as long as ;
C  We are still on the wafer AND ;
C  (the strips are above threshold AND good) OR;
C  (the strips are unbonded AND the number of such consecutive
C  unbonded strips doesn't exceed the limit).
C
   21     CONTINUE
          IF(  JSTRP+MSTRP.LT.NSTPWF.AND.
     &    ( (SGOOD(IFLAG(JSTRP+MSTRP)).AND.IPULS(JSTRP+MSTRP).GE.MNPULS)
     &          .OR.
     &      (SSKIP(IFLAG(JSTRP+MSTRP)).AND.NUNBD.LT.MXUNBD) )  )THEN
C
C  If this isn't just a skip for an unbonded strip, add in the PH
C
            IF(SGOOD(IFLAG(JSTRP+MSTRP)).AND.
     &        IPULS(JSTRP+MSTRP).GE.MNPULS)THEN
              PSUM = PSUM + IPULS(JSTRP+MSTRP)
            ELSE
              NUNBD = NUNBD + 1
            END IF
            MSTRP = MSTRP + 1
            GOTO 21
          END IF
          LSTRP = JSTRP+MSTRP-1
C
C  Cut on preliminary pulseheight.
C
          IF(IHIS1(HISTLV))THEN
            CALL HFILL(HISOFF+19,FLOAT(PSUM),DUMMY,1.0)
          END IF
          IF(PSUM .GE. MNPSUM)THEN
C
C  Check backwards to the last 'bonded' strip, dropping any
C  unbonded that might be tagging on at the end.
C
   23       CONTINUE
            IF(MSTRP.GT.0.AND..NOT.SGOOD(IFLAG(JSTRP+MSTRP-1)))THEN
              MSTRP = MSTRP - 1
              GOTO 23
            END IF
C
C  Error check
C
            IF(MSTRP .LE. 0)THEN
              CALL RERROR('VRECLU',1,'Zero length cluster')
              MSTRP = 1
            END IF
C
C  Try to save 1 strip on either side.
C  If these were read out, are bonded, and not noisy,
C  Add them to the cluster and into the pulseheight sum.
C
C  First strip
C
            OSTRP = MAX(1,JSTRP-1)
            IF(.NOT.SUNBD(IFLAG(OSTRP)))THEN
              OSTRP = JSTRP
            ELSE
              PSUM = PSUM + IPULS(OSTRP)
            END IF
C
C  Last strip
C
            LSTRP = MIN(NSTPWF,JSTRP+MSTRP)
            IF(.NOT.SUNBD(IFLAG(LSTRP)))THEN
              LSTRP = JSTRP+MSTRP-1
            ELSE
              PSUM = PSUM + IPULS(LSTRP)
            END IF
            MSTRP = LSTRP-OSTRP+1
C
C  pulseheight cut and histogram
C
            IF(IHIS1(HISTLV))THEN
              CALL HFILL(HISOFF+20,FLOAT(PSUM),DUMMY,1.0)
            END IF
            IF(PSUM .GE. FNLSUM)THEN
d208 4
d213 4
a216 3
              CALL VADDPK(IW(KNEXT(IVFHL)+JVFHHA),
     &        MSTRP,ILAY,IWAF,IPHI,IVIEW,OSTRP)
              IW(IVFHL+LMHROW) = IW(IVFHL+LMHROW) + 1
d220 2
a221 2
              IW(KNEXT(IVCOM)+JVCOCM) = ICOMM(OSTRP)
              IW(IVCOM+LMHROW) = IW(IVCOM+LMHROW) + 1
d225 21
a245 15
              DO 22 KSTRP=OSTRP,LSTRP
                IW(KNEXT(IVFPH)+JVFPPH) = IPULS(KSTRP)
                IW(KNEXT(IVFLG)+JVFLFG) = IFLAG(KSTRP)
                IW(IVFPH+LMHROW) = IW(IVFPH+LMHROW) + 1
                IW(IVFLG+LMHROW) = IW(IVFLG+LMHROW) + 1
   22         CONTINUE
            END IF
          END IF
          JSTRP = LSTRP + 1
        END IF
        GOTO 20
      END IF
C
C  Done with this wafer
C
@


1.1.1.1
log
@import julia 300
@
text
@@
