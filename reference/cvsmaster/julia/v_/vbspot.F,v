head	1.5;
access;
symbols
	jul313_3:1.5
	jul313_2:1.5
	jul313_1:1.5
	jul313:1.5
	jul312_1:1.5
	jul312:1.5
	jul311:1.5
	jul310_1:1.5
	jul310:1.5
	jul309_1:1.5
	jul309:1.5
	jul308_6:1.5
	jul308_5:1.5
	jul308_4:1.5
	jul308_3:1.5
	jul308_2:1.5
	jul308_1:1.5
	jul308:1.5
	jul307_4:1.5
	jul307_3:1.5
	jul307_2:1.5
	jul307_1:1.5
	jul307:1.5
	jul306_3:1.5
	jul306_2:1.5
	jul306_1:1.5
	jul306:1.5
	jul305_4:1.5
	jul305_3:1.5
	jul305_2:1.5
	jul305_1:1.5
	jul305:1.4
	jul304_3:1.4
	jul304_2:1.4
	jul304_1:1.4
	jul304:1.4
	jul303_7:1.4
	jul303_6:1.4
	jul303_5:1.4
	jul303_4:1.4
	jul303_3:1.4
	jul303_2_mc1:1.4
	jul303_2:1.4
	jul303_1_mc1:1.4
	jul303_1:1.4
	jul303_v:1.4
	jul303:1.4
	jul302_6:1.4
	jul302_5:1.4
	jul302_4:1.4
	jul302_3:1.4
	jul302_2:1.4
	jul302_1:1.4
	jul302:1.4
	jul285_1:1.4
	jul285:1.4
	jul284_1:1.4
	jul284:1.4
	jul283_1:1.4
	jul283:1.4
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.5
date	97.12.05.13.40.13;	author cattanem;	state Exp;
branches;
next	1.4;

1.4
date	96.09.10.15.00.16;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	96.03.12.15.48.00;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.20.50;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.30;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.31;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Changes in Julia for xlum
@
text
@      SUBROUTINE VBSPOT
C----------------------------------------------------------------------
C!  - Measure the beamspot using the ALEPH VDET
C!
C!   Author   :- Dave Brown, George Redlinger           8-APR-1993
C!
C!   Modified :- Steve Wasserbaech
C!       Nov 1994: Avoid taus to measure the beam spot
C!       Apr 1995: Use ABS on d0 and z0 cuts; remove call to VDAMB
C!   Modified: SW, 18 October 1995
C!   Fix an unbelievable ancient bug in inline function NW;
C!   switch to VBPC; introduce VBSP card; allow FRFT 0 if no VDET
C!   hits are required; allow tautau rejection and VDET hit
C!   definition to be switchable with VBPC; add some features
C!   to facilitate use in Alpha.
C?
C!   Modified :- M.Cattaneo 97/12/05
C!      Call xvdeok instead of VDETOK
C!======================================================================
#ifndef DOC
C     IMPLICIT NONE
      SAVE FIRST, NAVBPC, NAVBSP, NAFRTL, NAREVH
#include "bcs.h"
#include "rcurnt.h"
#include "vbpcjj.h"
#include "frftjj.h"
#include "frtljj.h"
#include "revhjj.h"
#include "alcons.h"
#include "vbscom.h"
C
C     Maximum Number of tracks per event:
      INTEGER MAXTR
      PARAMETER (MAXTR = 200)
C
C     Magnetic field conversion factor:
      REAL XKG
      PARAMETER (XKG=0.00001)
C
      INTEGER NAFRTL, NAREVH
      INTEGER NAVBPC, KVBPC, KALPB, KFRFT, KFRTL, NTRK
      INTEGER NAVBSP, KVBSP
      INTEGER KREVH, KCLASW, NDO, IP, NDAT
      INTEGER NAMIND, NLINK
      INTEGER NVDET(MAXTR)
      REAL DUM, CP1, SP1, CP2, SP2, TL1, TL2, RI1, RI2, P1, P2
      REAL EFRAC, ACOL, CHI2, CHIDOF, TL, RI, PTRK, SPH, CPH, D0B
      REAL ALFIEL
      LOGICAL FIRST, GOOD, XVDEOK, ALLEP1
      EXTERNAL XVDEOK
      DATA FIRST / .TRUE. /
C
C  Inline functions
C
      INTEGER ITRK, ILAY
      INTEGER NU, NW, NHITM, NHIT
#include "bmacrod.h"
C
      NU(ITRK,ILAY) = MIN(IAND(ISHFT(NVDET(ITRK),-2*(ILAY-1)),3),1)
      NW(ITRK,ILAY) = MIN(IAND(ISHFT(NVDET(ITRK),-4-2*(ILAY-1)),3),1)
C  "matched" hits (= at least one r-phi and one z hit in a layer):
      NHITM(ITRK) = NU(ITRK,1)*NW(ITRK,1) + NU(ITRK,2)*NW(ITRK,2)
C  r-phi hits only:
      NHIT(ITRK) = NU(ITRK,1) + NU(ITRK,2)
#include "bmacro.h"
C-----------------------------------------------------------------------
C
      IF (FIRST) THEN
        FIRST = .FALSE.
        NAVBPC = NAMIND('VBPC')
        NAVBSP = NAMIND('VBSP')
        NAFRTL = NAMIND('FRTL')
        NAREVH = NAMIND('REVH')
      ENDIF
      KVBPC = IW(NAVBPC)
      IF (KVBPC .LE. 0) GO TO 999
C
C   Do nothing for MC unless VBSP card is present:
C
      KVBSP = IW(NAVBSP)
      IF (FMCRUN .AND. (KVBSP .LE. 0)) GO TO 999
C
C  Make sure the VBPC row number (= LEP energy regime) is valid:
C
      IF (IVBPC .LE. 0) GO TO 999
C
C  Make sure that an ALPB has been created:
C
      KALPB = NLINK('ALPB',IRUNRC)
      IF (KALPB .LE. 0) GO TO 999
C
C  If we require VDET hits, make sure the VDET is on
C  and FRFT 2 is available:
C
      IF (ITABL(KVBPC,IVBPC,JVBPVM) .GT. 0) THEN
        GOOD = XVDEOK(DUM)
        IF (.NOT. GOOD) GO TO 999
        KFRFT = NLINK('FRFT',2)
C
C  otherwise FRFT 0 is good enough:
C
      ELSE
        KFRFT = NLINK('FRFT',2)
        IF (KFRFT .LE. 0) KFRFT = NLINK('FRFT',0)
      ENDIF
C
C  Make sure we have FRFT and FRTL:
C
      KFRTL = IW(NAFRTL)
      IF ((KFRFT .LE. 0) .OR. (KFRTL .LE. 0)) GO TO 999
      NTRK = LROWS(KFRFT)
C
C   Get the number of VDET hits:
C
      CALL VDHITS(NVDET,MAXTR)
C
C  For LEP 1:
C  Different action for class 24 events (to reject taus):
C  accept only if the event has two tracks and
C  is inconsistent with tautau.
C
      IF (ITABL(KVBPC,IVBPC,JVBPTR) .EQ. 1) THEN
        KREVH = IW(NAREVH)
        IF (KREVH .LE. 0) GO TO 999
        KCLASW = IW(KREVH+LMHLEN+JREVEC)
        IF ((IAND(KCLASW,ISHFT(1,23)) .NE. 0) .OR. (NTRK .LT. 5)) THEN
          IF (NTRK .NE. 2) GO TO 999
          CP1 = COS(RTABL(KFRFT,1,JFRFP0))
          SP1 = SIN(RTABL(KFRFT,1,JFRFP0))
          CP2 = COS(RTABL(KFRFT,2,JFRFP0))
          SP2 = SIN(RTABL(KFRFT,2,JFRFP0))
          TL1 = RTABL(KFRFT,1,JFRFTL)
          TL2 = RTABL(KFRFT,2,JFRFTL)
          RI1 = RTABL(KFRFT,1,JFRFIR)
          RI2 = RTABL(KFRFT,2,JFRFIR)
          P1 = ABS(ALFIEL(DUM) * CLGHT * SQRT(1.+TL1*TL1) * XKG / RI1)
          P2 = ABS(ALFIEL(DUM) * CLGHT * SQRT(1.+TL2*TL2) * XKG / RI2)
          EFRAC = (P1+P2)/RENLEP
          ACOL = SQRT(MAX(0.,2.*(1.+(CP1*CP2 + SP1*SP2 + TL1*TL2)/
     &                (SQRT(1.+TL1*TL1)*SQRT(1.+TL2*TL2)))))
          GOOD = (RI1*RI2 .LE. 0.)
          GOOD = GOOD .AND. (EFRAC .GT. 0.9) .AND. (EFRAC .LT. 1.1)
          GOOD = GOOD .AND. (ACOL .LT. 0.01)
          IF (.NOT. GOOD) GO TO 999
        ENDIF
      ENDIF
C
C  Generic track selection
C
      DO ITRK=1,NTRK
        CHI2 = RTABL(KFRFT,ITRK,JFRFC2)
        NDO = ITABL(KFRFT,ITRK,JFRFDF)
        IF (NDO .GT. 0) THEN
          CHIDOF = CHI2/NDO
        ELSE
          CHIDOF = CHI2
        ENDIF
        TL = RTABL(KFRFT,ITRK,JFRFTL)
        RI = RTABL(KFRFT,ITRK,JFRFIR)
        PTRK = ABS(ALFIEL(DUM) * CLGHT * SQRT(1.+TL*TL) * XKG / RI)
        D0B = RTABL(KFRFT,ITRK,JFRFD0)
C
C   For MC only, measure the d0 with respect to (XBMC,YBMC).
C   This allows the beam size to be controlled (in ALPHA).
C
        IF (FMCRUN) THEN
          CPH = COS(RTABL(KFRFT,ITRK,JFRFP0))
          SPH = SIN(RTABL(KFRFT,ITRK,JFRFP0))
          D0B = D0B - XBMC*SPH + YBMC*CPH
        ENDIF
C
C   Momentum cut:
        GOOD = (PTRK .GE. RTABL(KVBPC,IVBPC,JVBPPM))
C
C   d0 cut:
        GOOD = GOOD .AND. (ABS(D0B) .LT. RTABL(KVBPC,IVBPC,JVBPD0))
C
C   z0 cut:
        GOOD = GOOD .AND.
     &   (ABS(RTABL(KFRFT,ITRK,JFRFZ0)) .LT. RTABL(KVBPC,IVBPC,JVBPZ0))
C
C   Cut on TPC hits:
        GOOD = GOOD .AND.
     &   (ITABL(KFRTL,ITRK,JFRTNT) .GE. ITABL(KVBPC,IVBPC,JVBPTM))
C   Cut on ITC hits:
        GOOD = GOOD .AND.
     &   (ITABL(KFRTL,ITRK,JFRTNI) .GE. ITABL(KVBPC,IVBPC,JVBPIM))
C
C   Cut on matched VDET hits or r-phi hits only:
        IF (ITABL(KVBPC,IVBPC,JVBPVH) .EQ. 1) THEN
          GOOD = GOOD .AND. (NHITM(ITRK) .GE. ITABL(KVBPC,IVBPC,JVBPVM))
        ELSE
          GOOD = GOOD .AND. (NHIT(ITRK) .GE. ITABL(KVBPC,IVBPC,JVBPVM))
        ENDIF
C
C   Cut on chi**2/dof:
        GOOD = GOOD .AND. (CHIDOF .LE. RTABL(KVBPC,IVBPC,JVBPC2))
C
C   If it is a good track, save the necessary information in work bank:
C
        IF (GOOD) THEN
          IP = IBSTRK(IBSBUF)
          IF (LFRROW(IP) .LT. 1) THEN
            NDAT = IW(IP) + 100*LCOLS(IP)
            CALL WBANK(IW, IBSTRK(IBSBUF), NDAT, *800)
            IP = IBSTRK(IBSBUF)
          ENDIF
          RW(KNEXT(IP)+1) = RTABL(KFRFT,ITRK,JFRFD0)
          RW(KNEXT(IP)+2) = RTABL(KFRFT,ITRK,JFRFP0)
          RW(KNEXT(IP)+3) = RTABL(KFRFT,ITRK,JFRFEM+9)
          IW(KNEXT(IP)+4) = ISQNRC
          IW(IP+LMHROW) = IW(IP+LMHROW) + 1
        ENDIF
      ENDDO
C
C  If a VBSP card is given, don't call VBMFIT until the end of the job:
C
      IF (NCHOP .NE. 0) GO TO 999
C
C  If we have enough tracks, send them on to be fitted.  We can now
C  safely drop the previous batch of tracks.  Instruct the fit
C  to add a new row to the output bank.
C
      IF (LROWS(IBSTRK(IBSBUF)) .GE. ITABL(KVBPC,IVBPC,JVBPNC)) THEN
        IW(IBSTRK(JBSBUF)+LMHROW) = 0
        IF (IBSFEV .EQ. 1) THEN
          CALL VBMFIT(.FALSE.)
        ELSE
          CALL VBMFIT(.TRUE.)
        ENDIF
C
C  Change buffers, set flag
C
        KBSBUF = IBSBUF
        IBSBUF = JBSBUF
        JBSBUF = KBSBUF
C
C  Assume the next block will start with the next event of this run:
C
        IBSFEV = IEVTRC + 1
      ENDIF
C
      GO TO 999
C
  800 CALL RERROR ('VBSPOT', -1, 'No space to increase work bank!')
      GO TO 999
C
  999 RETURN
      END
#endif
@


1.4
log
@Replace explicit BOS macro decln. by bmacrod.h
@
text
@d17 2
d22 1
a22 1
      SAVE FIRST, NAVBPC, NAVBSP
d40 1
d49 2
a50 2
      LOGICAL FIRST, GOOD, VDETOK, ALLEP1
      EXTERNAL VDETOK
d72 2
d96 1
a96 1
        GOOD = VDETOK(DUM)
d109 1
a109 1
      KFRTL = IW(NAMIND('FRTL'))
d123 1
a123 1
        KREVH = IW(NAMIND('REVH'))
@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@d54 1
a54 3
      INTEGER ID,NRBOS,L,KI,KI1,KI2
      INTEGER LCOLS,LROWS,KNEXT,KROW,LFRWRD,LFRROW,ITABL
      REAL RTABL
@


1.2
log
@julia version 279
@
text
@a0 1
*DK vbspot
a23 2
      INTEGER JFRFIR, JFRFTL, JFRFP0, JFRFD0, JFRFZ0, JFRFAL,
     >        JFRFEM, JFRFC2, JFRFDF, JFRFNO, LFRFTA
a24 2
      INTEGER JFRTIV, JFRTNV, JFRTII, JFRTNI, JFRTNE, JFRTIT,
     >        JFRTNT, JFRTNR, LFRTLA
a25 2
      INTEGER JREVDS, JREVFE, JREVNE, JREVSB, JREVTI, JREVRB,
     >        JREVEC, LREVHA
@


1.1
log
@Initial revision
@
text
@d8 9
d20 2
d24 3
a26 2
#include "alcbjj.h"
#include "alpbjj.h"
d28 2
d31 3
d37 3
a39 1
C?  Maximum Number of tracks per event
d41 13
a53 3
      PARAMETER (MAXTR = 200)
      DIMENSION NVDET(MAXTR)
      LOGICAL GOOD, VDETOK
d55 1
a55 2
      INTEGER GTSTUP, AGETDB
      DATA XKG / 0.00001 /
d59 6
a64 2
      INTEGER ILAY
      INTEGER NU,NW,NHIT
d66 5
a70 2
      NW(ITRK,ILAY) = MIN(IAND(ISHFT(NVDET(ITRK),-2-2*(ILAY-1)),3),1)
      NHIT(ITRK)=NU(ITRK,1)*NW(ITRK,1)+NU(ITRK,2)*NW(ITRK,2)
d72 14
a85 2
C------------------------------------------------------------------------
C?   Do Nothing for MC Run
d87 1
a87 1
      IF (FMCRUN) GOTO 999
d89 3
a91 1
C?   If No constants or no ALPB bank skip
a92 4
      NAALCB = NAMIND ('ALCB')
      KALCB = IW(NAALCB)
      IF (KALCB.LE.0) GOTO 999

d94 4
a97 1
      IF (KALPB.LE.0) GOTO 999
d99 6
a104 1
C  Reject bad VDET events
a105 3
      GOOD =  VDETOK(DUM)
      IF ( .NOT.GOOD ) THEN
        GOTO 999
d107 2
d111 1
a111 1
C?  At least some VDET tracks
d113 2
a114 3
      KFRFT = NLINK ('FRFT',2)
      KFRTL = IW( NAMIND('FRTL') )
      IF ( KFRFT.LE.0 .OR. KFRTL.LE.0 ) GOTO 999
d117 1
a117 1
C?  Get the number of VDET hits
d121 29
a149 25
C?  Get ambiguity bit too
C
      CALL VDAMB(NVDET,MAXTR)
C
C  Different action for class 15,16; for class 15, make sure this
C  isn't a tau
C
      IF( NTRK.EQ.2 )THEN
        CP1 = COS (RTABL(KFRFT,1,JFRFP0))
        SP1 = SIN (RTABL(KFRFT,1,JFRFP0))
        CP2 = COS (RTABL(KFRFT,2,JFRFP0))
        SP2 = SIN (RTABL(KFRFT,2,JFRFP0))
        TL1 = RTABL(KFRFT,1,JFRFTL)
        TL2 = RTABL(KFRFT,2,JFRFTL)
        RI1 = RTABL(KFRFT,1,JFRFIR)
        RI2 = RTABL(KFRFT,2,JFRFIR)
        P1 = ABS(ALFIEL(DUM) * CLGHT * SQRT(1.+TL1*TL1) * XKG / RI1)
        P2 = ABS(ALFIEL(DUM) * CLGHT * SQRT(1.+TL2*TL2) * XKG / RI2)
        EFRAC = (P1+P2)/RENLEP
        ACOL = SQRT(MAX(0.,2.*(1.+(CP1*CP2 + SP1*SP2 + TL1*TL2)/
     &              (SQRT(1.+TL1*TL1)*SQRT(1.+TL2*TL2)))))
        GOOD = RI1*RI2.LE.0.
        GOOD = GOOD .AND. EFRAC .GT. .9 .AND. EFRAC .LT. 1.1
        GOOD = GOOD .AND. ACOL .LT. .01
        IF (.NOT.GOOD) GOTO 999
d154 4
a157 4
      DO ITRK = 1, NTRK
        CHI2 = RTABL (KFRFT,ITRK,JFRFC2)
        NDO  = ITABL (KFRFT,ITRK,JFRFDF)
        IF (NDO .GT. 0)THEN
d161 3
a163 3
        END IF
        TL   = RTABL(KFRFT,ITRK,JFRFTL)
        RI   = RTABL(KFRFT,ITRK,JFRFIR)
d165 34
a198 13
        GOOD = PTRK .GE. RTABL(KALCB,1,JALCMM)
        GOOD = GOOD
     &      .AND. RTABL(KFRFT,ITRK,JFRFD0) .LT. RTABL(KALCB,1,JALCD0)
        GOOD = GOOD
     &      .AND. RTABL(KFRFT,ITRK,JFRFZ0) .LT. RTABL(KALCB,1,JALCZ0)
        GOOD = GOOD
     &      .AND. ITABL(KFRTL,ITRK,JFRTNT) .GE. ITABL(KALCB,1,JALCMT)
        GOOD = GOOD
     &      .AND. ITABL(KFRTL,ITRK,JFRTNI) .GE. ITABL(KALCB,1,JALCMI)
        GOOD = GOOD
     &      .AND. NHIT(ITRK) .GE. ITABL(KALCB,1,JALCMV)
        GOOD = GOOD
     &      .AND. CHIDOF .LE. RTABL(KALCB,1,JALCC2)
d200 2
a201 2
C?  If it is a good track
C?  Save the necessary information in Working bank
d203 3
a205 1
        IF(GOOD)THEN
d207 1
a207 1
          IF ( LFRROW(IP).LT.1 ) THEN
d209 1
a209 1
            CALL WBANK (IW, IBSTRK(IBSBUF), NDAT, *800)
d212 7
a218 6
          RW (KNEXT(IP)+1) = RTABL(KFRFT,ITRK,JFRFD0)
          RW (KNEXT(IP)+2) = RTABL(KFRFT,ITRK,JFRFP0)
          RW (KNEXT(IP)+3) = RTABL(KFRFT,ITRK,JFRFEM+9)
          IW (IP+LMHROW) = IW (IP+LMHROW) + 1
        END IF
      END DO
d220 5
a224 1
C  If we have enough tracks, send them on to be fit.  We can now
d226 1
a226 1
C  to add a new row to the output bank
d228 3
a230 3
      IF(LROWS(IBSTRK(IBSBUF)).GE.ITABL(KALCB,1,JALCNB)) THEN
        IW (IBSTRK(JBSBUF)+LMHROW) = 0
        IF (IBSFEV.EQ.1) THEN
d238 3
a240 3
        KBSBUF=IBSBUF
        IBSBUF=JBSBUF
        JBSBUF=KBSBUF
d242 1
a242 2
C  Assume the next block will start with the next event
C  of this run.
d245 1
a245 1
      END IF
d247 1
a247 1
      GOTO 999
d249 2
a250 2
  800 CALL RERROR ('VBSPOT', -1, 'No Space to increase workbank !!')
      GOTO 999
@


1.1.1.1
log
@import julia 300
@
text
@@
