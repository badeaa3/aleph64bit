head	1.3;
access;
symbols
	jul313_3:1.3
	jul313_2:1.3
	jul313_1:1.3
	jul313:1.3
	jul312_1:1.3
	jul312:1.3
	jul311:1.3
	jul310_1:1.3
	jul310:1.3
	jul309_1:1.3
	jul309:1.3
	jul308_6:1.3
	jul308_5:1.3
	jul308_4:1.3
	jul308_3:1.3
	jul308_2:1.3
	jul308_1:1.3
	jul308:1.3
	jul307_4:1.3
	jul307_3:1.3
	jul307_2:1.3
	jul307_1:1.3
	jul307:1.3
	jul306_3:1.3
	jul306_2:1.3
	jul306_1:1.3
	jul306:1.3
	jul305_4:1.3
	jul305_3:1.3
	jul305_2:1.3
	jul305_1:1.3
	jul305:1.3
	jul304_3:1.3
	jul304_2:1.3
	jul304_1:1.3
	jul304:1.3
	jul303_7:1.3
	jul303_6:1.3
	jul303_5:1.3
	jul303_4:1.3
	jul303_3:1.3
	jul303_2_mc1:1.3
	jul303_2:1.3
	jul303_1_mc1:1.3
	jul303_1:1.3
	jul303_v:1.3
	jul303:1.3
	jul302_6:1.3
	jul302_5:1.3
	jul302_4:1.3
	jul302_3:1.3
	jul302_2:1.3
	jul302_1:1.3
	jul302:1.3
	jul285_1:1.3
	jul285:1.3
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.3
date	96.03.12.15.48.34;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.21.22;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.34;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.35;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@      SUBROUTINE VDSMAP(IROMD,GOOD)
C----------------------------------------------------------------------
C!  - Performs the map from electronics channels to strip numbers
C!
C
C  This subroutine takes as input hits from a single wafer
C  and produces as output an edited version of same,
C  with address mapped onto the actual (integer) strip numbers,
C  unmapped channels removed, and special case strips flaged.
C  D. Brown, 9-4-90
C  Modified 16-1-94 by Dave Brown for the VDET upgrade
C  Modified March 1995 A. Bonissent, M. Thulasidas
C                 reorganise and debug
C
C  INPUT  :
C      IROMD   :  Readout module address
C  OUTPUT :
C      GOOD    :  Flag if everything went OK
C
C  Upgraded 13-1-94 for new vdet    D. Brown
C?
C!======================================================================
#ifndef DOC
C
C  Inputs
C
      INTEGER IROMD
      LOGICAL GOOD
C
C  Parameters
C
C
C  Global includes
C
#include "bcs.h"
#include "vcsgjj.h"
#include "vdflgs.h"
#include "vpecjj.h"
#include "vregjj.h"
#include "vganjj.h"
#include "vpesjj.h"
#include "vrecon.h"
C
C  Function calls
C
      INTEGER NLINK
      INTEGER NAMIND
      INTEGER VNELRM, VNSCRM
C
C  Local variables
C
      INTEGER KVCSG,NVCSG,NAVCSG
      INTEGER NCHAN,NSTRP, NROST
      INTEGER KLIN
      INTEGER ILAY,IZ,IPH,IVIEW
      INTEGER IRWFL,IVREG
      INTEGER IOFL,INFL
      INTEGER KVREG,KVPEC,KVGAN,KVPES
      INTEGER IVCSG,JSTRP,ISTRP
      INTEGER IVGAN,NVGAN,IFSGN,ILSGN
      INTEGER JFLAG,PCFLG,PSFLG
      INTEGER NVREG,IFCRG,ILCRG
      INTEGER IVPEC,NVPEC,PCHAN
      INTEGER NVPES,IVPES,PSTRP
      INTEGER OPULS,IPULS
      REAL GAIN
C
C  Variables for inline functions
C
      LOGICAL SUNMP,SZERO,OSUPP,OOVER,OEROR,FIRST
      INTEGER I,J
      DATA FIRST /.TRUE./
#include "bmacro.h"
C
C  Inline functions
C
      SUNMP(J) = IAND(J,VBUNMP).EQ.VBUNMP
      SZERO(J) = IAND(J,VBUNBD+VBUNUS).GT.0
      OSUPP(J) = IAND(J,OBSUPP).EQ.OBSUPP
      OOVER(J) = IAND(J,OBOVER).EQ.OBOVER
      OEROR(J) = IAND(J,OBEROR).EQ.OBEROR
      IF(FIRST)THEN
        FIRST=.FALSE.
        NAVCSG=NAMIND('VCSG')
      ENDIF
C
C  Start of code
C
      GOOD = .TRUE.
C
C Decode address,
C get the view and the number of readout channels
C
      CALL VADEWA(IROMD,ILAY,IZ,IPH,IVIEW)
      NCHAN = VNELRM(IVIEW)
      KVCSG=IW(NAVCSG)
      NVCSG=LROWS(KVCSG)
C
      IF(MCEVNT)THEN
C
C  In MC data, no mapping needs to be done.  Just copy over.
C
        DO IVCSG=1,NCHAN
          KLIN=KROW(KVCSG,IVCSG)
          RW(KLIN+JVCSMP)=ITABL(KVCSG,IVCSG,JVCSRP)
          IW(KLIN+JVCSMF)=ITABL(KVCSG,IVCSG,JVCSRF)
        ENDDO
        GOTO 999
      END IF
      DO 10 IVCSG=1,NCHAN
C
C Get the raw flag
C
        IRWFL = ITABL(KVCSG,IVCSG,JVCSRF)
        IF (IRWFL.NE.0)THEN
          JFLAG = VB100U
C
C  Translate the Online strip flags
C
          IF(OSUPP(IRWFL))JFLAG = IOR(JFLAG,VBSUPP) ! suppressed strip
          IF(OOVER(IRWFL))JFLAG = IOR(JFLAG,VBOVER) ! DAC overflow
C
C  Flag the linedriver; this is used in correcting for the linedriver
C  decay in VDET91 data
C
          IF(IVCSG-1.GE.NCHAN/2)JFLAG = IOR(JFLAG,VBLIN2)
C
C Fill in the full flag column
C
          IW(KROW(KVCSG,IVCSG)+JVCSFF)=JFLAG
          IW(KROW(KVCSG,IVCSG)+JVCSSA)=IVCSG
        ENDIF
 10   CONTINUE
C
C  Link mapping bank
C
      KVREG = NLINK('VREG',IROMD)
      IF(KVREG .EQ. 0)THEN
        CALL RERROR('VDSMAP',1,'Cant find mapping information bank')
        GOOD = .FALSE.
        GOTO 999
      END IF
C
C And apply channel to strip mapping
C
      NVREG=LROWS(KVREG)
      DO 20 IVREG=1,NVREG
        IFCRG = ITABL(KVREG,IVREG,JVREFC)
        ILCRG = ITABL(KVREG,IVREG,JVRELC)
        JSTRP = ITABL(KVREG,IVREG,JVRECS)
        JFLAG = ITABL(KVREG,IVREG,JVRERF)
        IF(IFCRG.LT.1.OR.ILCRG.GT.NCHAN)THEN
          CALL RERROR('VDSMAP',3,'Mapping bank confusion')
          GOOD = .FALSE.
          GOTO 999
        END IF
        DO 21 IVCSG=IFCRG,ILCRG
C
C  Skip empty channels
C
          IRWFL=ITABL(KVCSG,IVCSG,JVCSRF)
          IF(IRWFL.GT.0)THEN
C
C Compute flag in the region
C
            IOFL=ITABL(KVCSG,IVCSG,JVCSFF)  ! Old flag
            INFL=IOR(IOFL,JFLAG)            ! New flag
C
C Compute the strip address
C
C if the first strip in the region (JSTRP) is given to be zero
C the mapped strip (ISTRP) should be zero.  that is guaranteed
C if IFCRG=ILCRG, which may not be the case.
C
            IF (IFCRG.NE.ILCRG .AND. JSTRP.EQ.0) THEN
              ISTRP = 0
            ELSE
              ISTRP = JSTRP+IVCSG-IFCRG
            ENDIF
C
C And fill
C
            IW(KROW(KVCSG,IVCSG)+JVCSSA)=ISTRP
            IW(KROW(KVCSG,IVCSG)+JVCSFF)=INFL
          ENDIF
 21     CONTINUE
 20   CONTINUE
C
C  Link peculiar channel bank
C
      KVPEC = NLINK('VPEC',IROMD)
C
C  Peculiar banks are not required
C
      IF(KVPEC .NE. 0)THEN
        NVPEC = LROWS(KVPEC)
        DO 30 IVPEC=1,NVPEC
          IVCSG = ITABL(KVPEC,IVPEC,JVPECA)
C
C  Skip empty channels
C
          IRWFL=ITABL(KVCSG,IVCSG,JVCSRF)
          IF(IRWFL.GT.0)THEN
            JFLAG = ITABL(KVPEC,IVPEC,JVPESF)
C
C Compute flag for the peculiar strip
C
            IOFL=ITABL(KVCSG,IVCSG,JVCSFF)  ! Old flag
            INFL=IOR(IOFL,JFLAG)            ! New flag
C
C And fill
C
            IW(KROW(KVCSG,IVCSG)+JVCSFF)=INFL

          ENDIF
 30     CONTINUE
      END IF
C
C  Link the gain bank
C
      KVGAN = NLINK('VGAN',IROMD)
      IF(KVGAN .EQ. 0)THEN
        CALL RERROR('VDSMAP',2,'Cant find gain bank')
        GOOD = .FALSE.
        GOTO 999
      END IF
      NVGAN = LROWS(KVGAN)
      DO 50 IVGAN=1,NVGAN
        IFSGN = ITABL(KVGAN,IVGAN,JVGAFS)
        ILSGN = ITABL(KVGAN,IVGAN,JVGALS)
        GAIN = RTABL(KVGAN,IVGAN,JVGAWG)
        IF(IFSGN.LT.1.OR.ILSGN.GT.NCHAN)THEN
          CALL RERROR('VDSMAP',4,'Gain bank confusion')
          GOOD = .FALSE.
          GOTO 999
        END IF
        DO 51 IVCSG=IFSGN,ILSGN
C
C  Skip empty channels
C
          IRWFL=ITABL(KVCSG,IVCSG,JVCSRF)
          IF(IRWFL.GT.0)THEN
C
C And fill
C
            RW(KROW(KVCSG,IVCSG)+JVCSSG)=GAIN
          ENDIF
 51     CONTINUE
 50   CONTINUE
C
C-- the number of read-out strips [or strip channels per module]
C
      NROST = VNSCRM(IVIEW)
C
C  Calculate the pulseheight for the useable strips
C
      DO 60 IVCSG=1,NCHAN
C
C check on the raw flag rather than the full flag
C
        IRWFL=ITABL(KVCSG,IVCSG,JVCSRF)
        IF (IRWFL.NE.0) THEN
          JFLAG=ITABL(KVCSG,IVCSG,JVCSFF)
          IF(.NOT. SZERO(JFLAG))THEN
            GAIN=RTABL(KVCSG,IVCSG,JVCSSG)
            IPULS=ITABL(KVCSG,IVCSG,JVCSRP)
            OPULS = IPULS*GAIN
          ELSE
            OPULS = 0
C
            JFLAG = IOR(JFLAG,VBZERO)
          END IF
          ISTRP=ITABL(KVCSG,IVCSG,JVCSSA)
C
C  use only sensible istrp
C
          IF (ISTRP.GT.0 .AND. ISTRP.LE.NROST) THEN
            KLIN=KROW(KVCSG,ISTRP)
            RW(KLIN+JVCSMP) = OPULS
C
C  Set the flag for this channel/strip
C
            IW(KLIN+JVCSMF) = JFLAG
          ENDIF
        ENDIF
 60   CONTINUE
C
C  Link peculiar (hot channels) strip bank
C
      KVPES = NLINK('VPES',IROMD)
C
C  Peculiar banks are not required
C
      IF(KVPES .NE. 0)THEN
        NVPES = LROWS(KVPES)
        DO 40 IVPES=1,NVPES
          IVCSG = ITABL(KVPES,IVPES,JVPEHA)
C
C  Check to see if this hot strip was read out this event- IE, has a
C  flag>0.  This must be checked as opposed to PH=/0, as it's possible
C  to readout a PH of 0.
C
C  Skip empty channels
C
           IOFL=ITABL(KVCSG,IVCSG,JVCSMF)  ! Old flag
           IF(IOFL.GT.0)THEN
            JFLAG = ITABL(KVPES,IVPES,JVPESF)
C
C Compute flag for the peculiar strip
C
            INFL=IOR(IOFL,JFLAG)            ! New flag
C
C And fill
C
            IW(KROW(KVCSG,IVCSG)+JVCSMF)=INFL
           ENDIF
 40     CONTINUE
      END IF
 999  CONTINUE
      RETURN
      END
#endif
@


1.2
log
@julia version 279
@
text
@a0 1
*DK vdsmap
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
      SUBROUTINE VDSMAP(IADDR,IPULS,IFLAG,OPULS,OFLAG,IGOOD)
d12 8
d21 1
a24 2
#include "implicit.h"
#include "vdimpl.h"
d28 2
a29 8
      INTEGER IADDR
C
      INTEGER IPULS(0:*),IFLAG(0:*)
C
C  Outputs
C
      INTEGER OPULS(*),OFLAG(*)
      LOGICAL IGOOD
a32 2
#include "vmpcjj.h"
#include "vmrejj.h"
d37 1
d39 4
a43 1
#include "vdmods.h"
d48 2
d53 14
a66 7
      INTEGER BNUMB,IVREG,IVPEC
      INTEGER ICAM,IFCAM,ILCAM,PCAM
      INTEGER NSTRP,JSTRP,ISTRP
      INTEGER JFLAG,PFLAG,KFLAG
      INTEGER IREG,NREG,IPEC,NPEC
      INTEGER ILAY,IWAF,IPHI,IVIEW
      INTEGER JPULS
d71 1
a71 4
      LOGICAL S200U,SUNMP,ODD,SUNBD,S100U
      LOGICAL S2ALL,SSWAP,S2UNB,EVEN,SZERO
      INTEGER ISWAP
      LOGICAL UNPHS
d73 2
a74 1
#include "vdbmcr.h"
d76 1
a76 1
C  Inline functions- these are used to define bonding situations
a77 5
#include "bmacro.h"
      EVEN(I) = MOD(I,2).EQ.0
      S100U(J) = IAND(J,VB100U).EQ.VB100U
      S200U(J) = IAND(J,VB200U).EQ.VB200U
      S2ALL(J) = IAND(J,VB2ALL).EQ.VB2ALL
a78 1
      SUNBD(J) = IAND(J,VBUNBD).EQ.VBUNBD
d80 7
a86 5
      SSWAP(J) = IAND(J,VBSWAP).EQ.VBSWAP
      S2UNB(J,I) = .NOT.(EVEN(I) .OR. S2ALL(J))
      UNPHS(I) = IAND(I,VBUNPH).EQ.VBUNPH
C       ISWAP(I) = 0->1, 1->0, 2->3, 3->2, etc.
      ISWAP(I) = I+1-2*IAND(I,1)
a88 9
C  See if the input address is corrupt
C
      IGOOD = .TRUE.
      IF(UNPHS(IADDR))THEN
        CALL RERROR('VDSMAP',2,
     &  'Bad wafer address- wafer rejected')
        IGOOD = .FALSE.
        RETURN
      END IF
d90 1
a90 1
C  Unpack the address- # of strips and strip # are meaningless here
d92 2
a93 1
      CALL VADDUN(IADDR,NSTRP,ILAY,IWAF,IPHI,IVIEW,ISTRP)
d95 4
a98 3
C  In MC data, no mapping needs to be done.  Just copy over
C  the arrays, and set the appropriate flag for the normal
C  bonding pattern.
d102 1
a102 1
C  Find the strip pitch flag for this wafer
d104 6
a109 18
        JFLAG = IBFLAG(ILAY,IWAF,IPHI,IVIEW)
C
C  Loop over the strips, and simply pack the data into the
C  output arrays.  Don't forget the shift of 1, which corresponds
C  to the fact that the MC data is stored originally as strip number,
C  not camex channel number
C
        DO 21 ICAM=0,NSTPWF-1
          IF(IFLAG(ICAM).GT.0)THEN
            OPULS(ICAM+1) = IPULS(ICAM)
            IF(IFLAG(ICAM).GT.0)THEN
              OFLAG(ICAM+1) = JFLAG
            ELSE
              OFLAG(ICAM+1) = 0
            END IF
          END IF
 21     CONTINUE
        RETURN
d111 1
d113 1
a113 2
C  Take out the online swapp of modules 9 and 10 phi side.  This
C  affects only very old 1990 data, and some 1992 data.
d115 3
a117 1
      IF(SWAPP9)THEN
d119 1
a119 1
C  For 1992, the complete modules BO09 and BO07 were swapped
d121 2
a122 7
        IF(LR1992.AND.
     &     ILAY.EQ.2.AND.IWAF.LT.3.AND.(IPHI.EQ.7.OR.IPHI.EQ.9))THEN
          IF(IPHI.EQ.7)THEN
            IPHI=9
          ELSE
            IPHI=7
          END IF
d124 2
a125 1
C  For 1990, this swapps modules 9 and 10, phi side only
d127 1
a127 8
        ELSE IF(LR1990.AND.ILAY .EQ. 1 .AND. IVIEW .EQ. IVIEWP .AND.
     &     (IPHI .EQ. 9 .OR. IPHI .EQ. 10))THEN
          IF(IPHI .EQ. 9)THEN
            IPHI = 10
          ELSE
            IPHI = 9
          END IF
        END IF
d129 1
a129 1
C  Re-define the module address
d131 4
a134 2
        CALL VADDPK(IADDR,NSTRP,ILAY,IWAF,IPHI,IVIEW,ISTRP)
      END IF
d136 1
a136 1
C  Link region bank
d138 5
a142 6
      CALL VAENWA(BNUMB,ILAY,IWAF,IPHI,IVIEW)
      IVREG = NLINK('VREG',BNUMB)
      IF(IVREG .EQ. 0)THEN
        CALL RERROR('VDSMAP',5,'Cant find mapping information bank')
        IGOOD = .FALSE.
        RETURN
d145 1
a145 12
C  Initialize pointers for first region
C  IFCAM is channel number of first strip of region
C  ILCAM is channel number of last strip of region
C  JSTRP is strip number of first strip of region
C  JFLAG is region flag
C
      IREG = 1
      NREG = LROWS(IVREG)
      IFCAM = ITABL(IVREG,IREG,JVMRFC)
      ILCAM = ITABL(IVREG,IREG,JVMRLC)
      JSTRP = ITABL(IVREG,IREG,JVMRCS)
      JFLAG = ITABL(IVREG,IREG,JVMRRF)
d147 12
a158 1
C  Link peculiar strip bank
d160 1
a160 1
      IVPEC = NLINK('VPEC',BNUMB)
d162 2
a163 1
C  Peculiar banks are not required
d165 1
a165 1
      IF(IVPEC .NE. 0)THEN
d167 2
a168 11
C  Initialize peculiar strips
C  PCAM is the channel number of the peculiar strip
C  PFLAG is the flag of that strip
C
        IPEC = 1
        NPEC = LROWS(IVPEC)
        PCAM = ITABL(IVPEC,IPEC,JVMPCA)
        PFLAG = ITABL(IVPEC,IPEC,JVMPSF)
      ELSE
        NPEC = 0
      END IF
d170 1
a170 1
C  Wafer gain
d172 3
a174 1
      GAIN = WGAINS(ILAY,IWAF,IPHI,IVIEW)
d176 5
a180 3
C  Now loop through the channels, translating their channel number
C  into true strip number.  Unbonded, unmapped channels are simply
C  skipped.
d182 1
a182 1
      DO 26 ICAM=0,NSTPWF-1
d184 5
a188 1
C  Skip empty strips
d190 1
a190 1
        IF(IFLAG(ICAM).GT.0)THEN
d192 1
a192 2
C   Check the same region
C  DO WHILE for the IBM
d194 1
a194 15
   22     CONTINUE
          IF(ICAM .GT. ILCAM .AND. IREG .LT. NREG)THEN
            IREG = IREG + 1
            IFCAM = ITABL(IVREG,IREG,JVMRFC)
            ILCAM = ITABL(IVREG,IREG,JVMRLC)
            JSTRP = ITABL(IVREG,IREG,JVMRCS)
            JFLAG = ITABL(IVREG,IREG,JVMRRF)
            GOTO 22
          END IF
          IF(ICAM .LT. IFCAM .OR. ICAM .GT. ILCAM)THEN
            CALL RERROR('VDSMAP',3,'Mapping bank confusion')
            IGOOD = .FALSE.
            RETURN
          END IF
          IF(NPEC.GT.0)THEN
d196 4
a199 1
C  Check if this is a 'peculiar' strip
d201 1
a201 1
            IF(ICAM .LT. PCAM)THEN
d203 3
a205 1
C  Normal strip
d207 1
a207 2
              KFLAG = JFLAG
            ELSE IF(ICAM .GE. PCAM)THEN
d209 2
a210 1
C  Peculiar strip
d212 1
a212 5
              IF(ICAM .EQ. PCAM)THEN
                KFLAG = IOR(JFLAG,PFLAG)
              ELSE
                KFLAG = JFLAG
              END IF
d214 5
a218 1
C  Move to next peculiar strip
d220 1
a220 1
              IPEC = IPEC + 1
d222 17
a238 1
C  DO WHILE for the IBM
d240 1
a240 9
   23         CONTINUE
              IF(ICAM .GT. ITABL(IVPEC,IPEC,JVMPCA) .AND.
     &        IPEC .LT. NPEC)THEN
                IPEC = IPEC + 1
                PCAM = ITABL(IVPEC,IPEC,JVMPCA)
                PFLAG = ITABL(IVPEC,IPEC,JVMPSF)
                GOTO 23
              END IF
              IF(IPEC .GT. NPEC .OR. ICAM .GT. PCAM)THEN
d242 2
a243 1
C  Here, no more peculiar strips- turn off the search
d245 1
a245 8
                PCAM = NSTPWF+1
                PFLAG = 0
                NPEC = 0
              END IF
            END IF
          ELSE
            KFLAG = JFLAG
          END IF
d247 4
a250 3
C  Next, parse on the region flag to decide what to do with this channel
C  The catagories are given in order of their frequency of occurance.
C  First, check that the strip is even bonded.
d252 1
a252 2
          IF(.NOT. (SUNMP(KFLAG) .OR.
     &     (S200U(KFLAG) .AND. S2UNB(KFLAG,ICAM-IFCAM))) )THEN
d254 1
a254 2
C  This strip should be saved (IE everything not in the above catagory
C  should be ignored).  Compute the strip number based on the flag
d256 1
a256 1
            IF(S100U(KFLAG).AND. .NOT. SSWAP(KFLAG))THEN
d258 1
a258 2
C  For 100U bonding, the strip number is simply the begining strip number of
C  region plus however many strips into the region we are.
d260 1
a260 2
              ISTRP = JSTRP+ICAM-IFCAM
            ELSE IF(S200U(KFLAG).AND. .NOT. S2ALL(KFLAG))THEN
d262 9
a270 2
C  For even or odd 200U bonding, the first channel of the region is required
C  to be bonded to the first strip, so the strip number increments simply
d272 3
a274 3
              ISTRP = JSTRP+(ICAM-IFCAM)/2

            ELSE IF(S100U(KFLAG).AND. SSWAP(KFLAG))THEN
d276 1
a276 1
C  Here, we must swap the strip numbers in pairs
d278 3
a280 3
              ISTRP = JSTRP+ISWAP(ICAM-IFCAM)

            ELSE IF(S200U(KFLAG).AND. S2ALL(KFLAG))THEN
d282 1
a282 1
C  Here is a section of 200U pitch bonded to every channel
d284 4
a287 2
              ISTRP = JSTRP+ICAM-IFCAM
            END IF
d289 1
a289 1
C  Check that the strip number makes physical sense
d291 1
a291 4
            IF(ISTRP .LT. 1 .OR. ISTRP .GT. NSTPWF)THEN
              CALL RERROR('VDSMAP',4,'Strip # out of range')
              GOTO 26
            END IF
d293 1
a293 1
C  Set the flag for this strip
d295 4
a298 5
            IF (ICAM.LT.256) THEN
              OFLAG(ISTRP) = KFLAG
            ELSE
              OFLAG(ISTRP) = IOR(KFLAG,VBTPDC)
            ENDIF
d300 3
a302 2
C  Online event-by-event conditions are passed in, and must have
C  their flags set here
d304 1
a304 1
            IF(IAND(IFLAG(ICAM),OBSUPP).EQ.OBSUPP)THEN
d306 3
a308 1
C  Channel flagged as suppressed ONLINE
d310 1
a310 2
              OFLAG(ISTRP) = IOR(OFLAG(ISTRP),VBSUPP)
            ELSE IF(IAND(IFLAG(ICAM),OBOVER).EQ.OBOVER)THEN
d312 1
a312 1
C  Channel flagged as hardware OVERFLOW
d314 1
a314 35
              OFLAG(ISTRP) = IOR(OFLAG(ISTRP),VBOVER)
            ELSE IF(IAND(IFLAG(ICAM),OBEROR).EQ.OBEROR)THEN
C
C  Unspecified problem with PH- set UNUSABLE flag
C
              OFLAG(ISTRP) = IOR(OFLAG(ISTRP),VBUNUS)
            END IF
C
C  Next, calculate the new pulseheight
C
            IF(.NOT. SZERO(OFLAG(ISTRP)))THEN
              OPULS(ISTRP) = IPULS(ICAM)*GAIN
            ELSE
C
C  If this is an unbonded channel that should have been bonded,
C  or an unuseable channel, set the pulse height to zero.
C
              OPULS(ISTRP) = 0
            END IF
          ELSE
C
C  Here, some special stuff which modifies the INPUT flag array;
C  This is used only for some special monitoring jobs
C
            IFLAG(ICAM) = IOR(IFLAG(ICAM),VBUNMP)
C
C  Set flag saying it is the second group of 256 channels.  This
C  works both for 1990 and 1991
C
            IF (ICAM.GT.255) IFLAG(ICAM) = IOR(IFLAG(ICAM),VBTPDC)
          END IF
        END IF
   26 CONTINUE
C
C  That's all
d316 5
@


1.1.1.1
log
@import julia 300
@
text
@@
