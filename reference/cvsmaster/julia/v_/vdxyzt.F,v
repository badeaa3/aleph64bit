head	1.6;
access;
symbols
	jul313_3:1.6
	jul313_2:1.6
	jul313_1:1.6
	jul313:1.6
	jul312_1:1.6
	jul312:1.6
	jul311:1.6
	jul310_1:1.6
	jul310:1.6
	jul309_1:1.6
	jul309:1.6
	jul308_6:1.6
	jul308_5:1.6
	jul308_4:1.6
	jul308_3:1.6
	jul308_2:1.6
	jul308_1:1.6
	jul308:1.6
	jul307_4:1.6
	jul307_3:1.6
	jul307_2:1.6
	jul307_1:1.6
	jul307:1.6
	jul306_3:1.6
	jul306_2:1.6
	jul306_1:1.6
	jul306:1.6
	jul305_4:1.6
	jul305_3:1.6
	jul305_2:1.6
	jul305_1:1.6
	jul305:1.6
	jul304_3:1.6
	jul304_2:1.6
	jul304_1:1.6
	jul304:1.6
	jul303_7:1.6
	jul303_6:1.6
	jul303_5:1.6
	jul303_4:1.6
	jul303_3:1.6
	jul303_2_mc1:1.6
	jul303_2:1.6
	jul303_1_mc1:1.6
	jul303_1:1.6
	jul303_v:1.4
	jul303:1.4
	jul302_6:1.4
	jul302_5:1.4
	jul302_4:1.4
	jul302_3:1.4
	jul302_2:1.4
	jul302_1:1.4
	jul302:1.4
	jul285_1:1.4
	jul285:1.4
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.6
date	97.06.03.11.06.03;	author cattanem;	state Exp;
branches;
next	1.5;

1.5
date	97.06.03.10.31.34;	author cattanem;	state Exp;
branches;
next	1.4;

1.4
date	96.12.03.11.02.46;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	96.03.12.15.48.36;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.21.24;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.35;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.36;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.6
log
@fix typo in vdxyzt
@
text
@      SUBROUTINE VDXYZT
C----------------------------------------------------------------------
C!  - creates the banks VDXY,VDZT from the banks VFPH,VFHL,VFLG
C!   Author   :- D. Brown           18-SEP-1991
C!
C!  Modified 16-1-94 by Dave Brown for the VDET upgrade
C!  Modified March 1995 A. Bonissent, M. Thulasidas
C!                 reorganise and debug
C! Modified June 1995 handle Vdet95, multiplexing was not foreseen
C! Modified November 1996 A. Bonissent, keep track of strips which 
C!                                 belong to two clusters (after splitting)
C! Modified 3/6/97 M.Cattaneo, replace call exit() by RERROR,
C!                             move 999 label to include BDROP of work banks
C?
C!======================================================================
#ifndef DOC
C      IMPLICIT NONE
C
C  Global includes
C
#include "vwrljj.h"
#include "vdflgs.h"
#include "vdqflg.h"
#include "vcsgjj.h"
#include "vrecon.h"
#include "vprtnc.h"
C      INTEGER JVDXXC,JVDXYC,JVDXUC,JVDXSX,JVDXSY,JVDXSU
C      INTEGER JVDXPH,JVDXQF,JVDXNA,JVDXIP,JVDXIW
C      INTEGER JVDXIH,LVDXYA
#include "vdxyjj.h"
C      INTEGER JVDZZC,JVDZWC,JVDZSZ,JVDZSW,JVDZPH,JVDZQF
C      INTEGER JVDZNA,JVDZIP,JVDZIW,JVDZIH,LVDZTA
#include "vdztjj.h"
C
C These are here only because we access the banks. But the hac
c parameters
C are not used in this routine
C
C      INTEGER JVFHHA,LVFHLA
#include "vfhljj.h"
C      INTEGER JVFPPH,LVFPHA
#include "vfphjj.h"
C      INTEGER JVFLFG,LVFLGA
#include "vflgjj.h"
#include "vspljj.h"
      INTEGER VDRSPS,VDPSLC,VABCVU,VVUWXY, VSPXYZ
      INTEGER VDYEAR, VJWAFF, VMWAFJ, VJFACI
C
C  Local variables
C
      INTEGER KVCSG
      INTEGER NAVFPH,NAVCSG,NAVWRL
      INTEGER IGARB,IGARB2,KLINE,NCOL
      INTEGER KVFHL,KVFPH,KVFLG,KVWRL,KVSPL
      INTEGER VNELRM
      INTEGER KBANK,IMPPH,IMPFL,INDEX
      INTEGER NROMD,NRONX,IBNUM,NRXYZ,NNXYZ,NZERO
      INTEGER IADDR,ILAY,IWFF,IFAC,IVIEW,IVWN
      INTEGER JLAY,JWFF,JWNX,JFAC,JVIEW
      INTEGER JWAF,IWA,MMOD,MMODN,IWANX
      INTEGER NSTRP,ISTRP,JSTRP,KSTRP,FSTRP,MSTRP,NSTNX
      INTEGER ISTRT,INWRM,ILOWT
      INTEGER NVFHL,IVFHL,NHIT,NVFPH,NCLU
      INTEGER NSEP,ISEP,MXSEP,NCHMX,NSERO
      INTEGER NAMIND
      INTEGER NDATA
      INTEGER NPOS,IFLAG
      INTEGER NC,NE,HID
      INTEGER IRC,IRET,I,JS
      INTEGER BCOL(2)/LVDZTA,LVDXYA/
      REAL SSPOS(2),PPSUM(2)
      REAL PULSE,PULSO,PULSN,PULS
      REAL PSUM,SPOS
      REAL SCUT,PSCUT
      REAL VUW(3),XYZ(3),ABC(3),PSTRP
      REAL ESUM,CSUM,EFRST,CFIRST,ETA
      CHARACTER*4 BNAME(2)/'VDZT','VDXY'/
      LOGICAL FIRST
      DATA FIRST /.TRUE./
      PARAMETER (MXSEP=50)
      INTEGER IBEG(MXSEP),NSCLU(MXSEP)
C
C  BOS functions
C
      INTEGER NLINK,NBANK
C
C  Variables for inline functions
C
      LOGICAL IHIS1,IHIS8
      INTEGER ILINE
      INTEGER IFLG
      LOGICAL LOWTH
      INTEGER IWF,IVW,LYR
#include "bcs.h"
C      INTEGER LCOLS,LROWS,ID,KNEXT,KROW,NRBOS,LFRWRD,LFRROW,ITABL,L
C      REAL RTABL
       SAVE NAVFPH, NAVCSG, NAVWRL
#include "bmacro.h"
C
C  Inline functions
C
      IHIS1(IFLG) = IAND(IFLG,1) .EQ. 1
      IHIS8(IFLG) = IAND(IFLG,8) .EQ. 8
      ILINE(IFLG) = IAND(IFLG,VBLIN2)/VBLIN2
      LOWTH(IWF,IVW,LYR) = IVW.EQ.1.AND.
     >   ((LYR.EQ.1.AND.IWF.NE.1).OR.(LYR.EQ.2.AND.IWF.EQ.3))
      IF(FIRST)THEN
        FIRST=.FALSE.
        NCHMX = MAX(VNELRM(1),VNELRM(2))
        NAVFPH=NAMIND('VFPH')
        NAVCSG=NAMIND('VCSG')
        NAVWRL=NAMIND('VWRL')
      ENDIF
C
C  Drop old banks
C
      CALL BDROP(IW,'VDXYVDZTVSPL')
C
C  get the pointer of the first VFPH
C
      KVFPH = IW(NAVFPH)
C
C  If any exist, make the bank for the temporary storage
C
      IF(KVFPH.GT.0)THEN
        NDATA = NCHMX*LVCSGA+LMHLEN
        CALL AUBOS('VCSG',0,NDATA,KVCSG,IGARB)
        IF(IGARB.EQ.2)THEN
          CALL RERROR('VDXYZT',1,'Out of BOS space; event rejected')
          GOTO 999
        END IF
        IW(KVCSG+LMHROW)=NCHMX
        IW(KVCSG+LMHCOL)=LVCSGA
C
C Create also a vspl bank 100000 which will be used as a buffer
C Size is twice the number of strips (max. : each strip split)
C
        NDATA = 2*NCHMX*LVSPLA+LMHLEN
        CALL AUBOS('VSPL',100000,NDATA,KVSPL,IGARB)
        IF(IGARB.EQ.2)THEN
          CALL RERROR('VDXYZT',1,'Out of BOS space; event rejected')
          GOTO 999
        END IF
        IW(KVSPL+LMHROW)=0
        IW(KVSPL+LMHCOL)=LVSPLA
C
C Reaccess
C
        KVCSG=IW(NAVCSG)
      END IF

C
C Say that no VDXY or VDZT bank has yet been open
C
      INWRM=1
C
C For Vdet95, we need to create the bank for relations at module level
C
      IF(VDYEAR().EQ.95)THEN
        NDATA = NCHMX*LVWRLA+LMHLEN
        CALL AUBOS('VWRL',0,NDATA,KVWRL,IGARB)
        IF(IGARB.EQ.2)THEN
          CALL RERROR('VDXYZT',1,'Out of BOS space; event rejected')
          GOTO 999
        END IF
        KVCSG=IW(NAVCSG)
        IW(KVWRL+LMHCOL)=LVWRLA
        IW(KVWRL+LMHROW)=NCHMX
      ENDIF
C
C  Loop over all VFPH banks
C
      DO WHILE(KVFPH.GT.0)
C
C  Get the VFHL,VFLG bank indices
C
        IBNUM = IW(KVFPH-2)
        KVFHL = NLINK('VFHL',IBNUM)
        KVFLG = NLINK('VFLG',IBNUM)
        IF(KVFHL .LE. 0 .OR. KVFLG .LE. 0)THEN
          CALL RERROR('VDXYZT',1,'VFHL,VFLG banks missing')
          GOTO 999
        END IF
C
C  loop over the clusters in this VFHL bank
C
        NVFHL = LROWS(KVFHL)
        NVFPH = LROWS(KVFPH)
C
C  Unpack the first cluster address
C
        IF(NVFHL.NE.0)THEN
          IADDR = ITABL(KVFHL,1,JVFHHA)
          CALL VUNADD(IADDR,NSTRP,ILAY,IWFF,IFAC,IVIEW,FSTRP)
          CALL VAENWA(NROMD,ILAY,IWFF,IFAC,IVIEW)
C
C Find the module nb and wafer in module
C
          IRET = VJFACI(ILAY,IFAC,JFAC)
          IRET = VJWAFF(JFAC,IWFF,JWAF)
          IRET = VMWAFJ(JWAF,MMOD,IWA)
C
C Special encoding for VDXY/VDZT
C
          CALL VAENWA(NRXYZ,ILAY,IWFF,IFAC,1)
        ENDIF
        ISTRT=0
        DO IVFHL = 1,NVFHL
          SCUT = SEPSIG*SNOISE(IVIEW)
          PSCUT = POSSIG*SNOISE(IVIEW)
C
C  Copy the pulseheights and flags into local bank
C
          PULSO = 0.0
          DO ISTRP=1,NSTRP
            JSTRP = ISTRT+ISTRP
            PULSE = ITABL(KVFPH,JSTRP,1)
            IFLAG = ITABL(KVFLG,JSTRP,1)
C
C  If needed, correct for the decay factor
C
            PULSN = PULSE
            IF(IVIEW.EQ.2.AND.IDCLIN.EQ.ILINE(IFLAG))THEN
              PULSN = PULSE + DECFAC*(PULSE-PULSO)
            END IF
            KLINE = KROW(KVCSG,ISTRP+FSTRP-1)
            RW(KLINE+JVCSMP) = PULSN
            IW(KLINE+JVCSMF) = IFLAG
C
C  Save uncorrected pulseheight in case we are correcting the next one
C
            PULSO = PULSE
          END DO
C
C  Test histograms for charge division
C
          IF(IHIS8(HISTLV))THEN
C
C  Check for appropriate clusters
C
            NE = 0
            ESUM = 0.0
            DO ISTRP=1,NSTRP
              JSTRP = FSTRP+ISTRP-1
              PULSE = RTABL(KVCSG,ISTRP,JVCSMP)
              IFLAG = ITABL(KVCSG,ISTRP,JVCSMF)
              IF(PULSE.GE.PSCUT)THEN
                NE = NE + 1
                IF(NE .EQ. 1)EFRST = PULSE
                ESUM = ESUM + PULSE
              END IF
            END DO
            IF(NE.EQ.2)THEN
              ETA = EFRST/ESUM
              IF(IVIEW.EQ.2)THEN
                HID = 100+10*ILINE(IFLAG)+1
                CALL HFILL(HID,ETA,0.0,1.0)
              ELSE
                CALL HFILL(130,ETA,0.0,1.0)
              END IF
            END IF
          END IF
C
C  Hit separation
C
          IF(VDYEAR().EQ.95.AND.LOWTH(IWA,IVIEW,ILAY))THEN
            CALL VSEPLT(
     >              ILAY,IWA,FSTRP,NSTRP,NSEP,SSPOS,PPSUM,IBEG,NSCLU)
            ILOWT=1
          ELSE
            CALL VSEPAR(SCUT,FSTRP,NSTRP,NSEP,IBEG,NSCLU)
            ILOWT=0
          ENDIF
C
C  IBEG is the beginning of each subcluster w/r FSTRP, the begin
C  of the original cluster.
C  We now need to translate
C
          DO ISEP=1,NSEP
            IBEG(ISEP)=IBEG(ISEP)+FSTRP-1
          ENDDO
C
C  Loop over the separated clusters
C
          DO 22 ISEP=1,NSEP
C
C  calculate the strip coordinate cluster position
C  (only if not in the low theta region)
C
C Here, we use scut, while poscut should probably be used
C
            IF(ILOWT.EQ.0)THEN
              CALL VLCPOS(IBEG(ISEP),NSCLU(ISEP),SCUT,SPOS,PSUM,NPOS)
              SPOS = SPOS+IBEG(ISEP)-1
            ELSE
              SPOS=SSPOS(ISEP)+FSTRP-1
              PSUM=PPSUM(ISEP)
            ENDIF
            IF(NPOS .LE. 0)THEN
              CALL RERROR('VDXYZT',6,'Position calculation error')
              GOTO 22
            END IF
C
C  Histogram the hit width
C
            IF(IHIS1(HISTLV))THEN
              CALL HFILL(HISOFF+30+IVIEW,FLOAT(NPOS),0.0,1.0)
              CALL HFILL(HISOFF+20+IVIEW,PSUM,0.0,1.0)
            END IF
C
C  Re-make final pulseheight cut
C
            IF(PSUM .GE. FNLSUM)THEN
C
C  Translate strip position to global position
C
              IRC = VSPXYZ
     >           (SPOS,IVIEW,ILAY,IFAC,IWFF,NROMD,VUW,XYZ)
              IF (IRC.NE.1) GOTO 22
C
C  Tag separated clusters
C
                IF(NSEP .GT. 1)THEN
                  IFLAG = ISEPBT
                ELSE
                  IFLAG = 0
                END IF
C
C  Add cluster information to VDXY/VDZT bank.
C
C  If we are processing a readout module for the first time, create
C  the bank
                IF(INWRM.EQ.1)THEN
                  IF(IVIEW.EQ.1)THEN
                    NCOL=LVDZTA
                  ELSE
                    NCOL=LVDXYA
                  ENDIF
                  NDATA=LMHLEN+NCOL*NVFPH
                  CALL AUBOS(BNAME(IVIEW),NRXYZ,NDATA,KBANK,IGARB)
                  IF(IGARB.EQ.2)THEN
                    CALL RERROR('VDXYZT',2,'Error making BOS bank')
                    GOTO 999
                  ENDIF
                  IF(IGARB.EQ.1)THEN
                    KBANK = NLINK(BNAME(IVIEW),NRXYZ)
                    KVFHL = NLINK('VFHL',IBNUM)
                    KVFLG = NLINK('VFLG',IBNUM)
                    KVFPH = NLINK('VFPH',IBNUM)
                    KVSPL = NLINK('VSPL',100000)
                    KVCSG = IW(NAVCSG)
                    KVWRL = IW(NAVWRL)
                  ENDIF
                  IW(KBANK+LMHCOL)=NCOL
                  IW(KBANK+LMHROW)=0
                  INWRM=0
                ENDIF
                KLINE = KNEXT(KBANK)
                IF(IVIEW .EQ. 1)THEN
                  RW(KLINE+JVDZZC) = XYZ(3)
                  RW(KLINE+JVDZWC) = VUW(3)
                  RW(KLINE+JVDZSZ) = ERRNOM(IVIEW)
                  RW(KLINE+JVDZSW) = ERRNOM(IVIEW)
                  RW(KLINE+JVDZPH) = PSUM
                  IW(KLINE+JVDZIH) = IVFHL
                  IW(KLINE+JVDZIW) = IBNUM
                  IW(KLINE+JVDZQF) = IFLAG
                ELSE
                  RW(KLINE+JVDXXC) = XYZ(1)
                  RW(KLINE+JVDXYC) = XYZ(2)
                  RW(KLINE+JVDXUC) = VUW(2)
                  RW(KLINE+JVDXSX) = ERRNOM(IVIEW)
                  RW(KLINE+JVDXSY) = ERRNOM(IVIEW)
                  RW(KLINE+JVDXSU) = ERRNOM(IVIEW)
                  RW(KLINE+JVDXPH) = PSUM
                  IW(KLINE+JVDXIH) = IVFHL
                  IW(KLINE+JVDXIW) = IBNUM
                  IW(KLINE+JVDXQF) = IFLAG
                END IF
                NCLU = LROWS(KBANK) + 1
                IW(KBANK+LMHROW) = NCLU
C
C Say that there are no shared strips (yet)
C
                JSH1=0
                JSH2=0
C
C Keep track of split clusters
C
                IF(NSEP.GT.1)THEN
                  IF(LFRROW(KVSPL).LT.1)THEN
                    CALL RERROR('VDXYZT',-1,
     >                  'Something wrong, VSPL too small !!!')
                  ELSE
                    NVSPL=LROWS(KVSPL)+1
                    IW(KVSPL+LMHROW)=NVSPL
                    KADDR = KROW(KVSPL,NVSPL)
                    IW(KADDR+JVSPNH)=NCLU
                    IW(KADDR+JVSPFS)=IBEG(ISEP)
                    IW(KADDR+JVSPLS)=IBEG(ISEP)+NSCLU(ISEP)-1
C
C Is there a shared strip ?
C
                    DO J=1,NSEP
                      IF(J.NE.ISEP)THEN
                        JS1=IBEG(J)
                        JS2=IBEG(J)+NSCLU(J)-1
                        IF(JS2.EQ.IBEG(ISEP))JSH1=1
                        IF(JS1.EQ.IBEG(ISEP)+NSCLU(ISEP)-1)JSH2=1
                      ENDIF
                    ENDDO
                    IW(KADDR+JVSPSF)=JSH1
                    IW(KADDR+JVSPSL)=JSH2
                  ENDIF
                ENDIF
C
C  Keep track of relations between clusters and R/O strips in each wafer
C
                IF(VDYEAR().EQ.95)THEN
                   DO I=1,NSCLU(ISEP)
                      JS = IBEG(ISEP) + I - 1
                      IW(KROW(KVWRL,JS)+JVWRLC+IWA-1) = NCLU
C And pulseheight ...
                      PULS = RTABL(KVCSG,JS,JVCSMP)
C If the strip is shared, pulseheight should be counted twice
                      COEF=1.
                      IF((I.EQ.1.AND.JSH1.EQ.1).OR.
     >                   (I.EQ.NSCLU(ISEP).AND.JSH2.EQ.1))THEN
                           COEF=2.
                      ENDIF
                      RW(KROW(KVWRL,JS)+JVWRSP+IWA-1) = PULS*COEF
                   ENDDO
                ENDIF
            END IF
 22       CONTINUE
          IF(IVFHL.LT.NVFHL)THEN
C
C  Uncode the wafer address of the next cluster
C
            IADDR = ITABL(KVFHL,IVFHL+1,JVFHHA)
            CALL VUNADD(IADDR,NSTNX,ILAY,IWFF,IFAC,IVWN,FSTRP)
            CALL VAENWA(NRONX,ILAY,IWFF,IFAC,IVWN)
C
C Make the special encoding for VDXY/VDZT banks : view=1 !
C
            CALL VAENWA(NNXYZ,ILAY,IWFF,IFAC,1)
C
C Find the module nb and wafer in module
C
            IRET = VJFACI(ILAY,IFAC,JFAC)
            IRET = VJWAFF(JFAC,IWFF,JWAF)
            IRET = VMWAFJ(JWAF,MMODN,IWANX)
          ENDIF
C
C  If next readout module is different, or end of bank,
C  one readout module has been finished. Close the bank
C  But only if it exists
C
          IF(NRONX.NE.NROMD.OR.IVFHL.EQ.NVFHL)THEN
            IF(INWRM.EQ.0)THEN
              NHIT = LROWS(KBANK)
              NDATA=LMHLEN+NCOL*NHIT
              CALL AUBOS(BNAME(IVIEW),NRXYZ,NDATA,KBANK,IGARB)
C
C Copy VSPL 100000 into the VSPL with right NR
C Only if there some rows in it.
C
              NVSPL = LROWS(KVSPL)
              IF(NVSPL.NE.0)THEN
                NDATA = NVSPL*LVSPLA+LMHLEN
                NRVS = NRXYZ + IVIEW-1
                CALL AUBOS('VSPL',NRVS,NDATA,KVSP2,IGARB)
                IF(IGARB.EQ.2)THEN
                  CALL RERROR('VDXYZT',2,'Error making BOS bank')
                  GOTO 999
                ENDIF
                IF(IGARB.EQ.1)THEN
                  KBANK = NLINK(BNAME(IVIEW),NRXYZ)
                  KVFHL = NLINK('VFHL',IBNUM)
                  KVFLG = NLINK('VFLG',IBNUM)
                  KVFPH = NLINK('VFPH',IBNUM)
                  KVSPL = NLINK('VSPL',100000)
                  KVCSG = IW(NAVCSG)
                  KVWRL = IW(NAVWRL)
                ENDIF
                CALL UCOPY(IW(KVSPL+1),IW(KVSP2+1),NDATA)
              ENDIF
C
C and reset VSPL
C
              IW(KVSPL+LMHROW)=0
            ENDIF
C
C  If next module (or view) is different, or end of bank,
C  one module has been finished, make global cluster relations
C  in this module
C
          IF(MMODN.NE.MMOD.OR.
     >       IVWN.NE.IVIEW.OR.
     >       IVFHL.EQ.NVFHL)THEN
             IF(VDYEAR().EQ.95)THEN
               CALL VMGCRL(NROMD,MMOD)
               NZERO=IW(KVWRL)-LMHLEN
               CALL VZERO(IW(KVWRL+LMHLEN+1),NZERO)
             ENDIF
             MMOD=MMODN
          ENDIF
          IWA=IWANX
C
C Say that no VDXY or VDZT bank is anymore opened
C
            INWRM=1
C
C Reset VCSG temporary bank
C
            CALL VZERO(IW(KVCSG+LMHLEN+1),IW(KVCSG)-LMHLEN)
C
            NRXYZ=NNXYZ
            NROMD=NRONX
            IVIEW=IVWN
          ENDIF
C
C  Advance pointer in VFPH
C
          ISTRT = ISTRT + NSTRP
          NSTRP = NSTNX
        END DO
C
C  Move to next VFPH index
C
        KVFPH = IW(KVFPH-1)
      END DO
C
C  Drop work bank
C
 999  CALL BDROP(IW,'VCSGVWRL')
      RETURN
      END
#endif
@


1.5
log
@Fixes for julia 303.1
@
text
@d393 1
a393 1
    &                   'Something wrong, VSPL too small !!!')
@


1.4
log
@Julia version 285
@
text
@d12 2
d391 10
a400 10
                   IF(LFRROW(KVSPL).LT.1)THEN
                     WRITE(6,*)' Something wrong, VSPL too small !!!'
                     call exit
                   ENDIF
                   NVSPL=LROWS(KVSPL)+1
                   IW(KVSPL+LMHROW)=NVSPL
                   KADDR = KROW(KVSPL,NVSPL)
                   IW(KADDR+JVSPNH)=NCLU
                   IW(KADDR+JVSPFS)=IBEG(ISEP)
                   IW(KADDR+JVSPLS)=IBEG(ISEP)+NSCLU(ISEP)-1
d404 11
a414 10
                   DO J=1,NSEP
                     IF(J.NE.ISEP)THEN
                       JS1=IBEG(J)
                       JS2=IBEG(J)+NSCLU(J)-1
                       IF(JS2.EQ.IBEG(ISEP))JSH1=1
                       IF(JS1.EQ.IBEG(ISEP)+NSCLU(ISEP)-1)JSH2=1
                     ENDIF
                   ENDDO
                   IW(KADDR+JVSPSF)=JSH1
                   IW(KADDR+JVSPSL)=JSH2
d536 2
a537 2
      CALL BDROP(IW,'VCSGVWRL')
 999  RETURN
@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@d10 2
d43 1
d50 3
a52 3
      INTEGER NAVFPH,NAVCSG
      INTEGER IGARB,KLINE,NCOL
      INTEGER KVFHL,KVFPH,KVFLG,KVWRL
d95 1
d110 1
d115 1
a115 1
      CALL BDROP(IW,'VDXYVDZT')
d132 16
d149 1
d158 1
a158 1
         NDATA = NCHMX*LVWRLA+LMHLEN
d344 1
d348 1
d350 1
d381 33
d422 7
a428 1
                      RW(KROW(KVWRL,JS)+JVWRSP+IWA-1) = PULS
d461 28
@


1.2
log
@julia version 279
@
text
@a0 1
*DK vdxyzt
d13 1
d23 3
d27 2
d35 1
d37 1
d39 1
d49 1
a49 1
      INTEGER KVFHL,KVFPH,KVFLG
d52 1
a52 1
      INTEGER NROMD,NRONX,IBNUM,NRXYZ,NNXYZ
d55 1
a55 1
      INTEGER JWAF
d57 3
a59 3
      INTEGER ISTRT,INWRM
      INTEGER NVFHL,IVFHL,NHIT,NVFPH
      INTEGER NSEP,ISEP,MXSEP,NCHMX
d64 1
a64 1
      INTEGER IRC
d66 2
a67 1
      REAL PULSE,PULSO,PULSN
d87 2
d90 2
d99 2
d242 8
a249 1
          CALL VSEPAR(SCUT,FSTRP,NSTRP,NSEP,IBEG,NSCLU)
d264 1
d268 7
a274 1
            CALL VLCPOS(IBEG(ISEP),NSCLU(ISEP),SCUT,SPOS,PSUM,NPOS)
d291 1
a291 1
C  Translate strip position to local and global position
a292 1
              SPOS = SPOS+IBEG(ISEP)-1
@


1.1
log
@Initial revision
@
text
@d6 5
a13 2
#include "implicit.h"
#include "vdimpl.h"
d17 1
a17 1
#include "bcs.h"
d20 1
d22 8
d33 2
a34 6
#include "vdxyjj.h"
#include "vdztjj.h"
#include "vtcejj.h"
#include "vdmods.h"
#include "vdnamc.h"
#include "vprtnc.h"
d38 30
a67 20
      INTEGER MAXSTR
      PARAMETER (MAXSTR = 50)
      INTEGER IVIEW,ISTR,ILAY,IPHI,IWAF,JVIEW,IBNUM
      INTEGER BNUMB,NSTP,ISTRP,JSTRP
      INTEGER IADDR,OADDR
      INTEGER IVFHL,IVFPH,IVFLG
      INTEGER IND,ISIZE,NCLS,ICLS,NUMCL,IWIDT,IPHO,IFLO
      INTEGER NCLU,ICLU
      INTEGER IFLAG(MAXSTR),ISTRT(MAXSTR),NSTRP(MAXSTR)
      REAL SCENT,DUMMY
      REAL POS,LPOS,PITCH
      REAL VUW(3),XYZ(3)
      REAL UERR,WERR
      REAL RPULS(MAXSTR),PHCUT,PSUM
      REAL SEPSIG,ROOT2,SNOISE
C
C  Temporary; some cuts as data statements, these should eventually
C  come from the database
C

d75 2
a76 3
#include "vdbmcr.h"
      LOGICAL SAMWF,IHIS1
      LOGICAL S100U,TPD1,TPD2,PL50,MN50
d78 2
a79 1
      INTEGER I,J,K
d81 1
a81 2
C  Nominal values for co-ordinate errors; these are the best we can
C  say for errors without knowing the track parameters
d83 9
a91 2
      DATA UERR/.0013/,WERR/.0016/
      DATA SEPSIG/3./,ROOT2/1.414214/
d93 1
a93 1
C  Inline functions
d95 1
a95 8
#include "bmacro.h"
      SAMWF(J,K) = IAND(J,VMADDR).EQ.IAND(K,VMADDR)
      IHIS1(I) = IAND(I,1) .EQ. 1
      S100U(IFLG) = IAND(IFLG,VB100U).EQ.VB100U
      TPD1(IFLG) = IAND(IFLG,VBTPDC).EQ.0
      TPD2(IFLG) = IAND(IFLG,VBTPDC).EQ.VBTPDC
      PL50(IFLG) = IAND(IFLG,VBPL50).EQ.VBPL50
      MN50(IFLG) = IAND(IFLG,VBMN50).EQ.VBMN50
d99 1
a99 1
      IVFPH = IW(NAVFPH)
d101 1
a101 1
C  protection to check if the bank really exists
d103 14
a116 3
      IF (IVFPH.LE.0)THEN
        GOTO 999
      ENDIF
d118 1
a118 1
C  Drop old banks
d120 11
a130 1
      CALL BDROP(IW,'VDXYVDZT')
d134 1
a134 2
  900 CONTINUE
      IF(IVFPH .GT. 0)THEN
d138 5
a142 6
        IBNUM = IW(IVFPH-2)
        ISIZE = LROWS(IVFPH)
        IVFHL = NLINK('VFHL',IBNUM)
        IVFLG = NLINK('VFLG',IBNUM)
        IF(IVFHL .LE. 0 .OR. IVFLG .LE. 0)THEN
          CALL RERROR('VDXYZT',2,'Pulseheight banks inconsistant')
d146 1
a146 1
C  loop over all the clusters of the VFHL bank
d148 2
a149 4
        ISTRP=1
        OADDR = -1
        NCLS=LROWS(IVFHL)
        DO 20 ICLS=1,NCLS
d151 1
a151 1
C  Unpack the cluster address
d153 4
a156 2
          IADDR=ITABL(IVFHL,ICLS,JVFHHA)
          CALL VADDUN(IADDR,NSTP,ILAY,IWAF,IPHI,IVIEW,ISTR)
d158 1
a158 1
C  Increment counter for run summary
d160 3
a162 1
          NFNLHT(IVIEW) = NFNLHT(IVIEW) + 1
d164 1
a164 1
C  Check to see if this is a new address
d166 6
a171 1
          IF(.NOT.SAMWF(IADDR,OADDR))THEN
d173 1
a173 1
C  new wafer- First, remake the old bank to size
d175 44
a218 4
            IF(OADDR .GE. 0)THEN
              NUMCL = LROWS(IND)
              IF (JVIEW.EQ.IVIEWZ) THEN
                IND=NBANK('VDZT',BNUMB,LMHLEN+LVDZTA*NUMCL)
d220 1
a220 1
                IND=NBANK('VDXY',BNUMB,LMHLEN+LVDXYA*NUMCL)
d223 1
d225 1
a225 2
C  Now prepare the new wafer
C  Get the strip system wafer center and pitch
d227 1
a227 6
            SCENT = WSCENT(ILAY,IWAF,IPHI,IVIEW)
            IF(S100U(IBFLAG(ILAY,IWAF,IPHI,IVIEW)))THEN
              PITCH = .01
            ELSE
              PITCH = .02
            END IF
d229 3
a231 25
C  Build the position bank- different for r-phi and Z directions
C  Also set the strip noise, which can also be different
C  VDZT and VDXY are created with the maximum lentgh (total number of pulse
C  heitghs)
C
            CALL VAENWA(BNUMB,ILAY,IWAF,IPHI,IVIEWZ)
            IF (IVIEW.EQ.IVIEWZ) THEN
              IND=NBANK('VDZT',BNUMB,LMHLEN+LVDZTA*ISIZE)
              IF (IND.LE.0) THEN
                CALL RERROR('VDXYZT',3,'Error making BOS bank')
                GOTO 999
              ENDIF
              IW(IND+LMHCOL)=LVDZTA
              IW(IND+LMHROW)=0
              SNOISE = WSNOIS
            ELSE
              IND=NBANK('VDXY',BNUMB,LMHLEN+LVDXYA*ISIZE)
              IF (IND.LE.0) THEN
                CALL RERROR('VDXYZT',3,'Error making BOS bank')
                GOTO 999
              ENDIF
              IW(IND+LMHCOL)=LVDXYA
              IW(IND+LMHROW)=0
              SNOISE = USNOIS
            ENDIF
d233 3
a235 1
C  Reset the counters
d237 1
a237 3
            JVIEW = IVIEW
            OADDR = IADDR
          END IF
d239 1
a239 1
C  Unpack the pulseheight list and flags into local arrays
d241 1
a241 26
          IF (NSTP .GT. MAXSTR)THEN
            CALL RERROR('VDXYZT',5,' VFHL cluster too wide')
            GOTO 23
          END IF
          DO 21 JSTRP=1,NSTP
            IPHO=IVFPH+LMHLEN+ISTRP+JSTRP-1
            IFLO=IVFLG+LMHLEN+ISTRP+JSTRP-1
            RPULS(JSTRP) = IW(IPHO)
            IFLAG(JSTRP) = IW(IFLO)
C
C  If needed, correct these for the decay factor
C
          IF( ((LR1992 .AND. IVIEW .EQ. IVIEWP .AND. TPD1(IFLAG(JSTRP)))
     &     .OR.(LR1991 .AND. IVIEW .EQ. IVIEWP .AND. TPD2(IFLAG(JSTRP)))
     &     .OR.(LR1990 .AND. S100U(IFLAG(JSTRP)))).AND. JSTRP.NE.1 )
     &       RPULS(JSTRP)=IW(IPHO) + DECFAC*(IW(IPHO)-IW(IPHO-1))
C
   21     CONTINUE
C
C  First crude attempt at 2-hit separation
C
          CALL VSEPAR(RPULS,NSTP,SEPSIG*SNOISE,NCLU,ISTRT,NSTRP)
          IF(NCLU .LE. 0)THEN
            CALL RERROR('VDXYZT',7,'Cluster separation error')
          END IF
          DO 22 ICLU=1,NCLU
d243 1
a243 1
C  calculate a strip-coordinate cluster position from the pulseheights
d245 2
a246 3
            CALL VLCPOS(RPULS(ISTRT(ICLU)),NSTRP(ICLU),
     &      SEPSIG*SNOISE,LPOS,PSUM,IWIDT)
            IF(IWIDT .LE. 0)THEN
d254 2
a255 10
              IF(IVIEW .EQ. 1)THEN
                IF(IWAF .EQ. 1 .OR. IWAF .EQ. 4)THEN
                  CALL HFILL(HISOFF+31,FLOAT(IWIDT),DUMMY,1.0)
                ELSE
                  CALL HFILL(HISOFF+32,FLOAT(IWIDT),DUMMY,1.0)
                END IF
              ELSE
                CALL HFILL(HISOFF+30,FLOAT(IWIDT),DUMMY,1.0)
              END IF
              CALL HFILL(HISOFF+21,PSUM,DUMMY,1.0)
d262 1
a262 1
C  Check for +-50 micron bonding; this only affects 1990
d264 11
a274 5
              IF(LR1990)THEN
                IF     (PL50(IFLAG(ISTRT(ICLU))))THEN
                  LPOS = LPOS + .5
                ELSE IF(MN50(IFLAG(ISTRT(ICLU))))THEN
                  LPOS = LPOS - .5
a275 1
              END IF
d277 77
a353 1
C  Translate this into a wafer local position
d355 4
a358 1
              POS = (ISTR+ISTRT(ICLU)+LPOS-SCENT-2)*PITCH
d360 3
a362 1
C  Pack the position into a co-ordinate array
d364 6
a369 9
              IF(IVIEW .EQ. IVIEWZ)THEN
                VUW(1) = 0.
                VUW(2) = 0.
                VUW(3) = POS
              ELSE
                VUW(1) = 0.
                VUW(2) = POS
                VUW(3) = 0.
              END IF
d371 3
a373 2
C  Translate cluster position to absolute co-ordinate system.  This
C  also corrects the VUW co-ordinate for the readout direction.
d375 11
a385 1
              CALL VDWFXY(BNUMB,VUW,XYZ)
d387 1
a387 15
C  Add cluster information to VDXY/VDZT bank.
C  The XYZ errors are really meaningless, and are not used anywhere.
C  Here, they are used to store the readout strip pitch.
C  Local co-ordinate errors however are approximately correct.
C  A final version of the co-ordinate errors needs tracking information,
C  and so is done by the track refit routines.
C
              IF(IVIEW .EQ. IVIEWZ)THEN
                RW(KNEXT(IND)+JVDZZC) = XYZ(3)
                RW(KNEXT(IND)+JVDZWC) = VUW(3)
                RW(KNEXT(IND)+JVDZSZ) = PITCH
                RW(KNEXT(IND)+JVDZSW) = WERR
                RW(KNEXT(IND)+JVDZPH) = PSUM
                IW(KNEXT(IND)+JVDZIH) = ICLS
                IW(KNEXT(IND)+JVDZIW) = IBNUM
d389 1
a389 1
C  Tag separated clusters
d391 1
a391 25
                IF(NCLU .GT. 1)THEN
                  IW(KNEXT(IND)+JVDZQF) = ISEPBT
                ELSE
                  IW(KNEXT(IND)+JVDZQF) = 0
                END IF
              ELSE
                RW(KNEXT(IND)+JVDXXC) = XYZ(1)
                RW(KNEXT(IND)+JVDXYC) = XYZ(2)
                RW(KNEXT(IND)+JVDXUC) = VUW(2)
                RW(KNEXT(IND)+JVDXSX) = PITCH
                RW(KNEXT(IND)+JVDXSY) = PITCH
                RW(KNEXT(IND)+JVDXSU) = UERR
                RW(KNEXT(IND)+JVDXPH) = PSUM
                IW(KNEXT(IND)+JVDXIH) = ICLS
                IW(KNEXT(IND)+JVDXIW) = IBNUM
                IF(NCLU .GT. 1)THEN
                  IW(KNEXT(IND)+JVDXQF) = ISEPBT
                ELSE
                  IW(KNEXT(IND)+JVDXQF) = 0
                END IF
              END IF
              IW(IND+LMHROW) = IW(IND+LMHROW) + 1
            END IF
   22     CONTINUE
   23     CONTINUE
d393 1
a393 1
C  Advance pointer for VFPH
d395 4
a398 2
          ISTRP=ISTRP+NSTP
   20   CONTINUE
d400 1
a400 10
C  Remake final banks
C
        IF(OADDR .GT. 0)THEN
          NUMCL = LROWS(IND)
          IF (IVIEW.EQ.IVIEWZ) THEN
            IND=NBANK('VDZT',BNUMB,LMHLEN+LVDZTA*NUMCL)
          ELSE
            IND=NBANK('VDXY',BNUMB,LMHLEN+LVDXYA*NUMCL)
          END IF
        END IF
d402 3
a404 1
C  Check
d406 1
a406 3
        IF(ISTRP .NE. ISIZE+1)THEN
          CALL RERROR('VDXYZT',4,'Strip counting error')
        END IF
d408 2
a409 1
C  Update pointer, and return for next VFPH bank
d411 1
a411 3
        IVFPH = IW(IVFPH-1)
        GOTO 900
      END IF
d413 2
a414 1
  999 RETURN
@


1.1.1.1
log
@import julia 300
@
text
@@
