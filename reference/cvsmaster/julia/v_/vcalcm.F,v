head	1.3;
access;
symbols
	jul313_3:1.3
	jul313_2:1.3
	jul313_1:1.3
	jul313:1.3
	jul312_1:1.3
	jul312:1.3
	jul311:1.3
	jul310_1:1.3
	jul310:1.3
	jul309_1:1.3
	jul309:1.3
	jul308_6:1.3
	jul308_5:1.3
	jul308_4:1.3
	jul308_3:1.3
	jul308_2:1.3
	jul308_1:1.3
	jul308:1.3
	jul307_4:1.3
	jul307_3:1.3
	jul307_2:1.3
	jul307_1:1.3
	jul307:1.3
	jul306_3:1.3
	jul306_2:1.3
	jul306_1:1.3
	jul306:1.3
	jul305_4:1.3
	jul305_3:1.3
	jul305_2:1.3
	jul305_1:1.3
	jul305:1.3
	jul304_3:1.3
	jul304_2:1.3
	jul304_1:1.3
	jul304:1.3
	jul303_7:1.3
	jul303_6:1.3
	jul303_5:1.3
	jul303_4:1.3
	jul303_3:1.3
	jul303_2_mc1:1.3
	jul303_2:1.3
	jul303_1_mc1:1.3
	jul303_1:1.3
	jul303_v:1.3
	jul303:1.3
	jul302_6:1.3
	jul302_5:1.3
	jul302_4:1.3
	jul302_3:1.3
	jul302_2:1.3
	jul302_1:1.3
	jul302:1.3
	jul285_1:1.3
	jul285:1.3
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.3
date	96.03.12.15.48.01;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.20.53;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.30;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.31;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@      SUBROUTINE VCALCM
C
C----------------------------------------------------------------------
C!  Removes coherent noise from hits
C
C   Computes the Common Mode independently for each cluster belonging
C   to a particular wafer stored in IPULS
C   CM is defined by an iterative procedure which removes all elements
C   higher or lower than the average plus or minus given numbers of
C   standard deviations.
C   The maximum element is removed at entry upon the assumption that it,
C   at least, constitutes the signal.
C   Convergence can be achieved either when no more elements are removed
C   by a cycle or a number of elements smaller than a given value are
C   left in the cluster.
C   Author : C. Vannini 1/4/90
C
C  Modified 15-1-94 Dave Brown for 95 VDET
C  Modified March 1995 A. Bonissent, M. Thulasidas
C                 reorganise and debug
C-----------------------------------------------------------------------
C
C
C   Internal variables:
C      REAL CMODE             ! Common mode computed on a subset of PHIN
C      REAL CSIGM             ! Std. Dev. of the NCHAN elements of PHIN
C      LOGICAL RETRY          ! Used in the iterative calculation of CM
C      REAL HIGTR             ! Pulses above this value are discarded
C                             ! under the assumption that "it's signal"
C      REAL LOWTR             ! Pulses below this value are discarded
C                             ! as too negative spikes "are not real"
C?
C!======================================================================
#ifndef DOC
#include "vdflgs.h"
#include "vcsgjj.h"
#include "vrecon.h"
#include "vprtnc.h"
      INTEGER NVCSG,IVCSG
      INTEGER IMAX, MXVAL
      INTEGER ICM, ICS
      INTEGER NAVCSG,NAMIND,KVCSG,IFLG,KLIN,KLMX
      INTEGER IPULS
      INTEGER JSTRP,FSTRP,LSTRP,MSTRP,NUSED
      REAL PULS
      REAL CMODE, CSIGM, DUMMY
      REAL HIGTR, LOWTR
      LOGICAL OUTLY, FIRST
C
C  Parameters- these define the flag conditions for channels not to be
C  used in computing the common mode, and those not to be adjusted for
C  the common mode
C
      INTEGER MSNCM,MSCNG
      PARAMETER (MSNCM = VBUNBD+VBUNUS+VBOVER+VBSUPP+VBHOTC)
C-
C- Dave B. wanted it to be :
C--      PARAMETER (MSCNG = VBUNBD+VBUNUS)
C- But since we do not understand it,
C  we restored what it was in old code (gives same results as before)
C- Manoj 13-feb-1995
C-
      PARAMETER (MSCNG = VBUNBD+VBUNUS+VBOVER)
      DATA FIRST /.TRUE./
C
C  Inline functions- bit comparisons
C  NCMFL .TRUE. means the channel shouldn't be used for common mode comp
C  NCHNG .TRUE. means the channel value shouldn't be changed.
C
      LOGICAL NCMFL, NCHNG, IHIS1
      INTEGER INPUT
      INTEGER IAND,ISHFT
#include "bcs.h"
#include "bmacro.h"
      NCMFL(INPUT) = IAND(INPUT,MSNCM) .GT. 0
      NCHNG(INPUT) = INPUT.EQ.0.OR.IAND(INPUT,MSCNG).GT.0
      IHIS1(INPUT) = IAND(INPUT,1) .EQ. 1
C----------------------------------------------------------------------
      IF(FIRST)THEN
         FIRST=.FALSE.
         NAVCSG=NAMIND('VCSG')
      ENDIF
      KVCSG=IW(NAVCSG)
      NVCSG=LROWS(KVCSG)
      MSTRP=0
      MXVAL  = -999
C
C  Loop over the wafer, finding the clusters
C
      DO 100 IVCSG=1,NVCSG
C
C  Look for non-blank strips
C
        IFLG = ITABL(KVCSG,IVCSG,JVCSMF)
        IF(IFLG.NE.0)THEN
           KLIN=KROW(KVCSG,IVCSG)
C
C If there is no current cluster, we start one. otherwise
C keep extending it
C
           IF(MSTRP.EQ.0)THEN
             FSTRP=IVCSG
C-- need to initialize NUSED
             NUSED = 0
           ENDIF
           LSTRP=IVCSG
           MSTRP=MSTRP+1
           IF (NCMFL(IFLG)) THEN
             IW(KLIN+JVCSRF) = 1
           ELSE
             IW(KLIN+JVCSRF) = 0
             NUSED = NUSED + 1
             IPULS=  RTABL(KVCSG,IVCSG,JVCSMP)
             IF (IPULS.GT.MXVAL) THEN
               MXVAL = IPULS
               IMAX = IVCSG
             ENDIF
           ENDIF
        ELSEIF(MSTRP.NE.0)THEN
C
C  Here we finish a cluster
C
C
C   Remove maximum
C
          IW(KROW(KVCSG,IMAX)+JVCSRF) = 1
          NUSED =  NUSED-1
C
C  Histogram
C
          IF(IHIS1(HISTLV))THEN
            CALL HFILL(HISOFF+42,FLOAT(NUSED),DUMMY,1.0)
          END IF
C
C   Iterate common mode computation, as long as outlying pulseheights
C   and enough channels remain
C
          OUTLY = .TRUE.
C
C--  need to initialize the common mode in case the while
C--  is not entered.
C
          CMODE = 0.0
          CSIGM = 0.0
C  Do While accepted in JULIA as now works on all compilers
C                                               (P. Comas, May 1995)
          DO WHILE(OUTLY.AND.NUSED.GT.MINCMD)
C
C   Compute mean on currently enabled cluster elements.
C
            CALL VCMEAN (FSTRP,MSTRP,CMODE,CSIGM)
C
C  Count the channels inside the limits
C
            NUSED = 0
            OUTLY = .FALSE.
            HIGTR = CMODE + HCUTCM*CSIGM
            LOWTR = CMODE - LCUTCM*CSIGM
            DO JSTRP = FSTRP, LSTRP
              IF (ITABL(KVCSG,JSTRP,JVCSRF).EQ.0) THEN
                PULS = RTABL(KVCSG,JSTRP,JVCSMP)
                IF (PULS .GT. HIGTR. OR. PULS .LT. LOWTR) THEN
                  IW(KROW(KVCSG,JSTRP)+JVCSRF) = 1    ! Outlyer
                  OUTLY = .TRUE.
                ELSE
                  NUSED = NUSED + 1
                ENDIF
              ENDIF
            END DO
          END DO
C
C   Subtract the CM from the input pulse-heights of good strips
C
          ICM   = NINT(CMODE)
          ICS   = NINT(CSIGM)
          DO JSTRP = FSTRP, LSTRP
            KLIN = KROW(KVCSG,JSTRP)
            IF (.NOT.NCHNG(ITABL(KVCSG,JSTRP,JVCSMF))) THEN
              RW(KLIN + JVCSMP) = RTABL(KVCSG,JSTRP,JVCSMP) - ICM
            END IF
C
C  Pack common mode; offset avoids problems with negative numbers
C
            IW(KLIN + JVCSCM) = IPHOFF + ICM + ISHFT(ICS,16)
          END DO
C
C  Flag noisy strips
C
          IF(ICS .GT. MXSIGM)THEN
            NNOSHT(1) = NNOSHT(1) + 1
            DO JSTRP = FSTRP, LSTRP
              IW(KROW(KVCSG,JSTRP)+JVCSMF) =
     >           IOR(ITABL(KVCSG,JSTRP,JVCSMF),VBNOIS)
            END DO
          END IF
C
C  Histograms
C
          IF(IHIS1(HISTLV))THEN
            CALL HFILL(HISOFF+40,CMODE,DUMMY,1.0)
            CALL HFILL(HISOFF+41,CSIGM,DUMMY,1.0)
            CALL HFILL(HISOFF+43,FLOAT(NUSED),DUMMY,1.0)
          END IF
C
C Say that we have no cluster started
C and that the maximum value is very small
C
          MSTRP=0
          MXVAL=-999
        END IF
  100 CONTINUE
      RETURN
      END
#endif
@


1.2
log
@julia version 279
@
text
@a0 1
*DK vcalcm
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
      SUBROUTINE VCALCM (IPULS,IFLAG,LFLAG,ICOMM)
d8 1
a8 1
C   to a particular wafer stored in IPULS(512).
d18 4
a23 7
C   Input:
C      INTEGER IPULS(512)      ! Array of wafer pulse-heights
C      INTEGER IFLAG(512)     ! Input array of flagged strips in PHIN
C      LOGICAL LFLAG(512)     ! working array for excluding elements of
C                             ! PHIN from common mode computation
C   Output:
C      INTEGER IPULS(512)     ! Output array of pulse-heights
d29 1
a29 1
C      REAL HIGTR            ! Pulses above this value are discarded
d31 1
a31 1
C      REAL LOWTR            ! Pulses below this value are discarded
a35 2
#include "implicit.h"
#include "vdimpl.h"
d37 1
d40 2
a41 5
C
      INTEGER IPULS(*)
      INTEGER IFLAG(*)
      INTEGER ICOMM(*)
      LOGICAL LFLAG(*)
d43 4
d48 2
a49 4
      INTEGER NSTRP, FSTRP, LSTRP, ISTRP, NCHAN
      LOGICAL RETRY
      REAL HIGTR,LOWTR
      INTEGER I, IMAX, MXVAL
d57 7
d65 1
d74 2
d77 2
a78 2
      NCHNG(INPUT) = IAND(INPUT,MSCNG) .GT. 0
      IHIS1(I) = IAND(I,1) .EQ. 1
d80 41
d122 1
a122 1
C  Loop on one entire wafer
a123 46
      ISTRP = 1
   11 CONTINUE
      IF(ISTRP.LE.NSTPWF)THEN
        IF (IFLAG(ISTRP).EQ.0) THEN
          ISTRP = ISTRP + 1
          GO TO 11
        ENDIF
C
C  'else' a new cluster is starting here
C
        FSTRP  = ISTRP
        CMODE  = 0.
        CSIGM  = 0.
        MXVAL  = -999
        IMAX   = FSTRP
        NCHAN  = 0
   12   CONTINUE
        IF(ISTRP.LE.NSTPWF.AND.IFLAG(ISTRP).NE.0)THEN
C
C  Fill working bank LFLAG with .true. if unusable channel, .false.
C  if good, counts the number of valid elements and find the maximum
C
          IF (NCMFL(IFLAG(ISTRP))) THEN
            LFLAG(ISTRP) = .TRUE.
          ELSE
            LFLAG(ISTRP) = .FALSE.
            NCHAN = NCHAN + 1
            IF (IPULS(ISTRP).GT.MXVAL) THEN
              MXVAL = IPULS(ISTRP)
              IMAX = ISTRP
            ENDIF
          ENDIF
          ISTRP = ISTRP + 1
          GOTO 12
        END IF
        LSTRP = ISTRP - 1
        NSTRP = ISTRP - FSTRP
        CALL HFILL(HISOFF+42,FLOAT(NCHAN),DUMMY,1.0)
C
C  Protect agains 'empty' clusters
C
        IF(NCHAN-1 .LT. NCHANM)THEN
          CMODE = 0.
          CSIGM = 0.
          GOTO 100
        END IF
d127 2
a128 1
        LFLAG(IMAX) = .TRUE.
d130 1
a130 1
C   Computation of Common Mode of single cluster.
d132 6
a137 1
   10   CONTINUE
d139 1
a139 1
C   Compute mean on currently enabled cluster elements.
d141 2
a142 29
        CALL VCMEAN (IPULS(FSTRP),LFLAG(FSTRP),NSTRP,CMODE,CSIGM)
        RETRY = .FALSE.
        NCHAN = 0
        HIGTR = CMODE + HCUTCM*CSIGM
        LOWTR = CMODE - LCUTCM*CSIGM
        DO 21 I = FSTRP, LSTRP
          IF (.NOT.LFLAG(I)) THEN
            IF (FLOAT(IPULS(I)) .GT. HIGTR. OR.
     &          FLOAT(IPULS(I)) .LT. LOWTR) THEN
C   At least one outstanding signal was found, so loop on CM
C   computation once more.
              LFLAG(I) = .TRUE.
              RETRY = .TRUE.
            ELSE
C   Increment valid channel counter.
              NCHAN = NCHAN + 1
            ENDIF
          ENDIF
   21   CONTINUE
C
C   Check if any signal found and removed, or if too few elements left.
C
        IF ( RETRY .AND. NCHAN .GT. NCHANM ) GO TO 10
C
  100   CONTINUE
C ---   --------
C   Subtract the CM from the input pulse-height array Leave the pulse-height
C   alone for unbonded and missing channels.  Store also the common mode
C   itself and the channel-by-channel sigma.
d144 5
a148 2
        ICM   = NINT(CMODE)
        ICS   = NINT(CSIGM)
d150 3
a152 1
C  Histograms
d154 1
a154 5
        IF(IHIS1(HISTLV))THEN
          CALL HFILL(HISOFF+40,CMODE,DUMMY,1.0)
          CALL HFILL(HISOFF+41,CSIGM,DUMMY,1.0)
          CALL HFILL(HISOFF+43,FLOAT(NCHAN),DUMMY,1.0)
        END IF
d156 40
a195 3
        DO 22 I = FSTRP, LSTRP
          IF (.NOT. NCHNG(IFLAG(I))) THEN
            IPULS(I) = IPULS(I) - ICM
d198 1
a198 1
C  Offset by IPHOFF the common mode value to avoid negatives!
d200 5
a204 2
          ICOMM(I) = IPHOFF + ICM + ISHFT(ICS,16)
   22   CONTINUE
d206 2
a207 2
C  Flag noisy channels- these will subsequently be ignored in the
C  cluster search.
d209 2
a210 5
        IF(ICS .GT. MXSIGM)THEN
          NNOSHT(1) = NNOSHT(1) + 1
          DO 23 I = FSTRP, ISTRP-1
            IFLAG(I) = IOR(IFLAG(I),VBNOIS)
   23     CONTINUE
d212 1
a212 4
C
        GOTO 11
      END IF
C
@


1.1.1.1
log
@import julia 300
@
text
@@
