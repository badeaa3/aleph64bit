head	1.4;
access;
symbols
	jul313_3:1.4
	jul313_2:1.4
	jul313_1:1.4
	jul313:1.4
	jul312_1:1.4
	jul312:1.4
	jul311:1.4
	jul310_1:1.4
	jul310:1.4
	jul309_1:1.4
	jul309:1.4
	jul308_6:1.4
	jul308_5:1.4
	jul308_4:1.4
	jul308_3:1.4
	jul308_2:1.4
	jul308_1:1.4
	jul308:1.4
	jul307_4:1.4
	jul307_3:1.3
	jul307_2:1.3
	jul307_1:1.3
	jul307:1.3
	jul306_3:1.3
	jul306_2:1.3
	jul306_1:1.3
	jul306:1.3
	jul305_4:1.3
	jul305_3:1.3
	jul305_2:1.3
	jul305_1:1.3
	jul305:1.3
	jul304_3:1.3
	jul304_2:1.3
	jul304_1:1.3
	jul304:1.3
	jul303_7:1.3
	jul303_6:1.3
	jul303_5:1.3
	jul303_4:1.3
	jul303_3:1.3
	jul303_2_mc1:1.3
	jul303_2:1.3
	jul303_1_mc1:1.3
	jul303_1:1.3
	jul303_v:1.3
	jul303:1.3
	jul302_6:1.3
	jul302_5:1.3
	jul302_4:1.3
	jul302_3:1.3
	jul302_2:1.3
	jul302_1:1.3
	jul302:1.3
	jul285_1:1.3
	jul285:1.3
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.4
date	98.08.24.15.02.00;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	96.03.12.15.44.43;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.20.30;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.20.14;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.20.15;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.4
log
@mods for julia 307.4
@
text
@      SUBROUTINE TRKELS(IER)
C
C---------------------------------------------------------------------
C! Sum up dE/dx for tracks
C!
C!    Author:   R. Johnson   23-04-87
C!    Modified: R. Johnson   21-01-91 flag track segments with more
C!                           than 40% of the samples saturated
C!                           11-09-91 nonlinear and z corrections
C!                           24-08-92 2-sided truncated mean
C!                           2-3-93   data-base control such that
C!                                    old algorithm still works
C!              D. Casper    26-7-98  ensure that zero charge samples
C!                                    remain zero after correction
C!
C!    Output: IER     /I      Set to 1 if BOS runs out of space.
C!                            Set to 0 for a good return.
C!
C!    Called by TPCREC
C!
C!    Description
C!    -----------
C!    This routine calculates the truncated mean for each TPC track.
C!    The output goes into the banks TELS and TEXS.
C!
C!--------------------------------------------------------------------
#ifndef DOC
C
#include "tgftjj.h"
#include "alcons.h"
#include "tparac.h"
#include "tflags.h"
#include "tpgpar.h"
#include "telsjj.h"
#include "texsjj.h"
#include "twitjj.h"
#include "twtbjj.h"
#include "bcs.h"
#include "tpgeow.h"
#include "tpgeom.h"
#include "tpccon.h"
#include "twirct.h"
#include "twircl.h"
C
C++   Workbank indices:
C
      COMMON/TRKEWB/ ISORTW,ITWRRW
C
C++   Local variables:
C
      DIMENSION NCLST(LTSECT),SPLST(LTSECT),SZLST(LTSECT)
      DIMENSION SLLST(LTSECT),NHTOT(LTSECT),ISFLG(LTSECT)
      DIMENSION NHSTR(LTSECT)
      CHARACTER TEXT*120
      LOGICAL FIRST
      SAVE RMEL,RMPI,RMKA,RMPR,FIRST,NTWTB,NTWIT,NTWAT,NTELS,NTEXS
      DATA FIRST/.TRUE./
C
      DATA RMEL/0.000511/,RMPI/0.1395685/,
     &     RMKA/0.493667/,RMPR/0.9382796/
C
C
C-------------------------- Statement Functions ---------------------
C
#include "bmacro.h"
C
C--------------------------------------------------------------------
C
      IF (FIRST) THEN
        FIRST=.FALSE.
        NTWTB=NAMIND('TWTB')
        NTWIT=NAMIND('TWIT')
        NTWAT=NAMIND('TWAT')
        NTELS=NAMIND('TELS')
        NTEXS=NAMIND('TEXS')
        NTGFT=NAMIND('TGFT')
        ISORTW=0
        ITWRRW=0
      ENDIF
C
      IER=0
C
C++   Drop the output banks if old ones still are hanging around
C
      IF (IW(NTELS).NE.0) CALL BDROP(IW,'TELS')
      IF (IW(NTEXS).NE.0) CALL BDROP(IW,'TEXS')
C
C++   Check that the required input banks are available
C
      KTWTB=IW(NTWTB)
      IF (KTWTB.EQ.0) GO TO 999
      KTWIT=IW(NTWIT)
      IF (KTWIT.EQ.0) GO TO 999
      KTWAT=IW(NTWAT)
      IF (KTWAT.EQ.0) GO TO 999
      KTGFT=IW(NTGFT)
      IF (KTGFT.EQ.0) GO TO 999
C
C++   Create a workbank for sorting dE/dx samples
C
      NWTOT=NTWIRE(1)+NTWIRE(2)
      IW(1)=1
      CALL WBANK(IW,ISORTW,2*NWTOT,*998)
      IW(ISORTW-3)=INTCHA('WRTW')
C
C++   Create the named banks for output
C
      LEN= LROWS(KTWIT)*LTELSA + LMHLEN
      IW(1)=1
      CALL AUBOS('TELS',0,LEN,KTELS,IGARB)
      IF (IGARB.EQ.2) GO TO 997
      CALL BLIST(IW,'T+','TELS')
      IW(KTELS+LMHCOL)=LTELSA
      IW(KTELS+LMHROW)=0
C
      KTWIT=IW(NTWIT)
      MXTEX=3*LROWS(KTWIT)
      LEN= MXTEX*LTEXSA + LMHLEN
      IW(1)=1
      CALL AUBOS('TEXS',0,LEN,KTEXS,IGARB)
      IF (IGARB.EQ.2) GO TO 997
      CALL BLIST(IW,'T+','TEXS')
      IW(KTEXS+LMHCOL)=LTEXSA
      IW(KTEXS+LMHROW)=0
C
      KTWTB=IW(NTWTB)
      KTWIT=IW(NTWIT)
      KTWAT=IW(NTWAT)
      KTELS=IW(NTELS)
      KTGFT=IW(NTGFT)
C
      CALL BWIND(IW,'TWRR',LTSECT,ITWRRW)
C
C++   Loop over all tracks with associated wires
C
      CINT=1.0-SLOPCL*ALOG(TWSTEP(1))
      DO 500 ITK=1,LROWS(KTWIT)
        NWR=ITABL(KTWIT,ITK,JTWING)
C
C++     Cut on number of associated wire pulses
C
        IF (NWR.LT.MNSPTW) GO TO 500
        IF (NWR.GT.NWTOT) THEN
          WRITE(TEXT,360) NWR
          CALL RERROR('TRKELS',1,TEXT(1:115))
  360     FORMAT('Too many (',I4,') wire samples on a single track.&',
     &           'The excess data are being lost.  ',
     &           'This indicates a problem in TRKWRA')
          NWR=NWTOT
        ENDIF
C
        TANL=RTABL(KTGFT,ITK,JTGFTL)
        SINT=1./SQRT(1.+TANL**2)
C
        IW(KTELS+LMHROW)=LROWS(KTELS)+1
        MTELS=LROWS(KTELS)
C
        IOFF=ITABL(KTWIT,ITK,JTWIOS)+LMHLEN
C
C++     Make a list of dE/dx values to use for sorting.  Also, count the
C++     number of samples in each sector and the track length.  We
C++     apply here a correction for variations in sample length, which
C++     includes a logarithmic correction.  Since the sample length
C++     usually varies only slowly along a track, we can use a truncated
C++     Taylor expansion to keep the logarithm updated.
C
        SMP0=RTABL(KTWTB,IW(KTWAT+IOFF+1),JTWTSL)
        SMPL=ALOG(SMP0)
        CALL VZERO(NHTOT(1),LTSECT)
        DO 400 IWR=1,NWR
          ITW=IW(KTWAT+IOFF+IWR)
          CHRGS=RTABL(KTWTB,ITW,JTWTCE)
          SMP=RTABL(KTWTB,ITW,JTWTSL)
          RNCR= (SMP-SMP0)/SMP0
          IF (ABS(RNCR).LT.RNCRTW) THEN
            SMPL=SMPL + (1. - 0.5*RNCR)*RNCR
          ELSE
            SMPL=ALOG(SMP)
          ENDIF
          IDD=ITABL(KTWTB,ITW,JTWTWI)
          ISLOT=IDD/65536
C
C++       Make a non-linear correction for sample length, plus a
C++       correction for the drift dependence
C
          ZTK=RTABL(KTWTB,ITW,JTWTPN)
          Q=CHRGS/(CINT+SLOPCL*SMPL)
          IF (Q .GT. 0) THEN
           IF (GRNMCL.GT.0.) THEN
            IF (.NOT.FZERTW) THEN
C
C++           Here, correct only for the dependence on the angle
C++           in the x-y plane (used starting 1992).
C
              SPERP=SMP*SINT
              QCNL=GRNMCL*(Q/SMP + (1.-(TWSTEP(1)/SPERP))*RNLNCL)
     &                                             / (1.+ADSPCL*ZTK)
            ELSE
C
C++           Here correct for overall dependence on angle (1991 data)
C
              QCNL=GRNMCL*(Q/SMP + (1.-(TWSTEP(1)/SMP))*RNLNCL)
     &                                             / (1.+ADSPCL*ZTK)
            ENDIF
           ELSE
            QCNL=Q/SMP
           ENDIF
          ELSE
            QCNL = 0.
          ENDIF
          RW(ISORTW+IWR)=QCNL
          IF (FZERTW) THEN
            IF (CHRGS.GT.0.) NHTOT(ISLOT)=NHTOT(ISLOT)+1
          ELSE
            NHTOT(ISLOT)=NHTOT(ISLOT)+1
          ENDIF
          SMP0=SMP
  400   CONTINUE
C
C++     Sort the dE/dx values
C
        CALL SORTZV(RW(ISORTW+1),IW(ISORTW+NWR+1),NWR,1,0,0)
C
C++     If requested, we can ignore the hits with zero charge
C++     (from wires below threshold)
C
        IBEG=1
        IF (FZERTW) THEN
          DO 3189 K=1,NWR
            IWR=IW(ISORTW+NWR+K)
            CHRGS=RW(ISORTW+IWR)
            IF (CHRGS.EQ.0.) THEN
              IBEG=IBEG+1
            ELSE
              GO TO 3190
            ENDIF
 3189     CONTINUE
 3190     CONTINUE
        ENDIF
C
C++     Calculate the truncated sum of dE/dx and the average drift
C++     separately for each sector.
C
        CALL VZERO(NCLST(1),LTSECT)
        CALL VZERO(SZLST(1),LTSECT)
        CALL VZERO(SPLST(1),LTSECT)
        CALL VZERO(SLLST(1),LTSECT)
        CALL VZERO(ISFLG(1),LTSECT)
        DO 368 ISLOT=1,LTSECT
          NHSTR(ISLOT)=MAX(1,NHTOT(ISLOT)*KTRNTW/100)
          NHTOT(ISLOT)=NHTOT(ISLOT)*JTRNCL/100
  368   CONTINUE
        DO 450 K=IBEG,NWR
          IWR=IW(ISORTW+NWR+K)
          ITW=IW(KTWAT+IOFF+IWR)
          IDD=ITABL(KTWTB,ITW,JTWTWI)
          ISLOT=IDD/65536
          IF (NCLST(ISLOT).GE.NHTOT(ISLOT)) GO TO 450
          CHRGS=RW(ISORTW+IWR)
C
C++       Are any saturated pulses ending up in the final sum?
C++       Since the samples are arranged in order of PH, if any
C++       are saturated, the last one will be.
C
          IF (NCLST(ISLOT).EQ.NHTOT(ISLOT)-1.AND.CHRGS.GT.0.) THEN
            IF (IW(ITWRRW).GE.ISLOT) THEN
              KTWRR=IW(ITWRRW+ISLOT)
            ELSE
              KTWRR=0
            ENDIF
            IF (KTWRR.GT.0) THEN
              IHPT=IDD - ISLOT*65536
              IHTWD=IW(KTWRR+LMHLEN+IHPT)
              IPH=IBITS(IHTWD,14,10)
              IF (IPH.GE.1023) ISFLG(ISLOT)=1
            ELSE
              CALL RERROR('TRKELS',4,'Cannot find the TWRR bank in '//
     &                    'order to test for saturation.')
            ENDIF
          ENDIF
          NCLST(ISLOT)=NCLST(ISLOT) + 1
          SLLST(ISLOT)=SLLST(ISLOT) + RTABL(KTWTB,ITW,JTWTSL)
          IF (NCLST(ISLOT).GE.NHSTR(ISLOT)) THEN
            IF (CHRGS.LE.0.) THEN
              SPLST(ISLOT)=SPLST(ISLOT) + RNRMCL(ISLOT)*ADCMTW
            ELSE
              SPLST(ISLOT)=SPLST(ISLOT) + CHRGS
            ENDIF
            ZPUL=RTABL(KTWTB,ITW,JTWTPN)
            SZLST(ISLOT)=SZLST(ISLOT) + ZPUL
          ENDIF
  450   CONTINUE
C
C++     Fill an entry into TEXS for each sector with hits on this track.
C
        IOFXS=LROWS(KTEXS)
        NSECT=0
        DO 470 ISLOT=1,LTSECT
          IF (NCLST(ISLOT).LT.4) GO TO 470
C
C++       Extend the TEXS bank in the unlikely event that it
C++       runs out of space.
C
          IF (LROWS(KTEXS).EQ.MXTEX) THEN
            LEN= IW(KTEXS) + MXTEX*LTEXSA
            MXTEX=2*MXTEX
            CALL AUBOS('TEXS',0,LEN,KTEXS,IGARB)
            IF (IGARB.EQ.2) GO TO 997
            IF (IGARB.NE.0) THEN
              KTELS=IW(NTELS)
              KTWTB=IW(NTWTB)
              KTWIT=IW(NTWIT)
              KTWAT=IW(NTWAT)
            ENDIF
          ENDIF
          NSECT=NSECT+1
          IW(KTEXS+LMHROW)=LROWS(KTEXS)+1
          MTEXS=LROWS(KTEXS)
C
          RTRNK=FLOAT(NCLST(ISLOT)-NHSTR(ISLOT)+1)
          IW(KROW(KTEXS,MTEXS)+JTEXSI)=ISLOT
          RW(KROW(KTEXS,MTEXS)+JTEXTM)=SPLST(ISLOT)/RTRNK
          RW(KROW(KTEXS,MTEXS)+JTEXTL)=SLLST(ISLOT)
          IW(KROW(KTEXS,MTEXS)+JTEXNS)=NCLST(ISLOT)
          RW(KROW(KTEXS,MTEXS)+JTEXAD)=SZLST(ISLOT)/RTRNK
          IW(KROW(KTEXS,MTEXS)+JTEXTN)=ITK
          IW(KROW(KTEXS,MTEXS)+JTEXSF)=ISFLG(ISLOT)
  470   CONTINUE
C
C++     Fill the pointer bank, TELS
C
        IW(KROW(KTELS,MTELS)+JTELNG)= NSECT
        IW(KROW(KTELS,MTELS)+JTELSO)= IOFXS
        IW(KROW(KTELS,MTELS)+JTELTN)= ITK
  500 CONTINUE
C
C++   Set final sizes of the output banks
C
      CALL AUBPRS('TELSTEXS')
      GO TO 999
C
  997 CONTINUE
      IER=2
      CALL RERROR('TRKELS',2,'No room in BOS for name banks')
      GO TO 999
  998 CONTINUE
      IER=3
      CALL RERROR('TRKELS',3,'No room in BOS for workbanks')
  999 CONTINUE
      CALL WDROP(IW,ISORTW)
      CALL WDROP(IW,ITWRRW)
      RETURN
      END
#endif
@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
 	fawian.F ffield.F fidhea.F fidrot.F finiru.F fitall.F fitwri.F
 	fkink.F fkkpar.F floweh.F flowfi.F flowtr.F fmuid.F fpiden.F
 	frefit.F ftpcer.F ftrack.F
 	gambnk.F gapeco.F gasteer.F
 	hcalib.F hcalrd.F hcatow.F hcbhis.F hcfclu.F hchist.F hclcra.F
 	hcltst.F hclufi.F hcos.F hcsimm.F hdgdeb.F hdgfil.F hdgpot.F
 	hdgsum.F hdprec.F hdspre.F hflnoi.F hinijo.F hiniru.F hmener.F
 	hmfind.F hmroad.F hnoise.F hnoisy.F hpatco.F hphnoi.F hplink.F
 	hprana.F hpranp.F hprdig.F hpreda.F hprpot.F hprsum.F hprunc.F
 	hrcomp.F hrcpat.F hrdcal.F hroad.F hslink.F hslowc.F hspare.F
 	hsptre.F hstofi.F htrack.F htubfi.F htwcr.F
 	iasign.F iattma.F ibnkin.F icaswt.F icftoi.F iclimb.F icrcco.F
 	ideadw.F idigpr.F ienang.F ifind1.F ifind2.F ifitp.F iftrak.F
 	igetti.F igettp.F igicha.F iheler.F iinijo.F iiniru.F iintrk.F
 	imatch.F inigap.F insect.F intrak.F ipakdi.F ipdsti.F iphcor.F
 	ipreda.F iprsum.F ipstat.F irefin.F ireopd.F isave.F ishuff.F
 	ishufl.F islowc.F isrch.F itbook.F itccut.F itcopr.F itcrec.F
 	itcrep.F itctpc.F itctrk.F itcxng.F iterr.F itextn.F ithist.F
 	itidy1.F itidy2.F itlnk1.F itlnk2.F itpcan.F itrak.F itrecf.F
 	itreci.F itree.F itrkci.F itrkeq.F itrkzr.F itrmca.F
@
text
@d13 2
d188 2
a189 1
          IF (GRNMCL.GT.0.) THEN
d205 3
d209 1
a209 1
            QCNL=Q/SMP
d284 1
a284 1
            IF (CHRGS.EQ.0.) THEN
@


1.2
log
@julia version 279
@
text
@a0 1
*DK trkels
@


1.1
log
@Initial revision
@
text
@d55 1
a60 1
      SAVE RMEL,RMPI,RMKA,RMPR,FIRST,NTWTB,NTWIT,NTWAT,NTELS,NTEXS
@


1.1.1.1
log
@import julia 300
@
text
@@
