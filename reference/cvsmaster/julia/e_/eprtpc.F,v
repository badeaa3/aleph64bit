head	1.7;
access;
symbols
	jul313_3:1.7
	jul313_2:1.7
	jul313_1:1.7
	jul313:1.7
	jul312_1:1.6
	jul312:1.6
	jul311:1.6
	jul310_1:1.6
	jul310:1.6
	jul309_1:1.6
	jul309:1.6
	jul308_6:1.6
	jul308_5:1.6
	jul308_4:1.6
	jul308_3:1.6
	jul308_2:1.6
	jul308_1:1.5
	jul308:1.5
	jul307_4:1.5
	jul307_3:1.5
	jul307_2:1.5
	jul307_1:1.5
	jul307:1.5
	jul306_3:1.5
	jul306_2:1.5
	jul306_1:1.5
	jul306:1.5
	jul305_4:1.5
	jul305_3:1.5
	jul305_2:1.5
	jul305_1:1.5
	jul305:1.5
	jul304_3:1.5
	jul304_2:1.5
	jul304_1:1.5
	jul304:1.5
	jul303_7:1.5
	jul303_6:1.5
	jul303_5:1.4
	jul303_4:1.4
	jul303_3:1.4
	jul303_2_mc1:1.4
	jul303_2:1.4
	jul303_1_mc1:1.4
	jul303_1:1.4
	jul303_v:1.4
	jul303:1.4
	jul302_6:1.4
	jul302_5:1.4
	jul302_4:1.4
	jul302_3:1.4
	jul302_2:1.4
	jul302_1:1.4
	jul302:1.4
	jul285_1:1.3
	jul285:1.3
	jul284_1:1.3
	jul284:1.3
	jul283_1:1.3
	jul283:1.3
	jul282_1:1.3
	jul282:1.3
	jul281_3:1.3
	jul281_2:1.3
	jul281_1:1.3
	jul281:1.3
	jul280_1:1.3
	jul280:1.3
	jul279:1.2
	v300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.7
date	2000.10.26.09.04.16;	author cattanem;	state Exp;
branches;
next	1.6;

1.6
date	98.10.14.16.23.08;	author cattanem;	state Exp;
branches;
next	1.5;

1.5
date	97.07.16.15.16.11;	author cattanem;	state Exp;
branches;
next	1.4;

1.4
date	97.03.06.09.54.42;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	96.03.12.14.57.46;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.17.16.26;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.14.18.03;	author aljul;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.14.18.04;	author aljul;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Mods for julia 313
@
text
@      SUBROUTINE EPRTPC(IER)
C----------------------------------------------------------------------
C!  - PREPARE TPC TRKS FOR ECAL EXTRAP.
C!                                                                     *
C!  AUTHOR   : A. BONISSENT  870125                                    *
C!                                                                     *
C!                                                                     *
C!  BANKS :                                                            *
C!    INPUT   : FRFT                                                   *
C!    OUTPUT  : ETP1                                                   *
C!    CREATED : ETP1                                                   *
C!                                                                     *
C! CHANGES HELIX PARAMETRISATION FROM TPC TO ECAL DESCRIPTION          *
C!                                                                     *
C!  MODIFIED : D.Casper 960605  Use extrapolation from outermost       *
C!                              coordinate, as calculated by UFECAL    *
C!                              and stored in the bank TRIK.  This     *
C!                              feature can be turned off by giving    *
C!                              an ENKF card, in which case the old    *
C!                              values, extrapolating from the origin, *
C!                              will be used.                          *
C!             D.Casper 960609  Do not extrapolate incoming tracks of  *
C!                              a kink.                                *
C!           M.Cattaneo 970716  Comment call to UFITQL (results are    *
C!                              never used!!)                          *
C!           M.Cattaneo 981014  Protect against divide by zero         *
C!           M.Cattaneo 001009  Protect against divide by zero         *
C!                                                                     *
C!       IER = return code ( 0 if normal)                              *
C?                                                                     *
C!======================================================================
#ifndef DOC
C!
C?
C!======================================================================
#ifndef DOC
#include "bcs.h"
#include "rlunit.h"
#include "rparac.h"
#include "rflags.h"
#include "frftjj.h"
#include "tarcjj.h"
#include "alcons.h"
#include "ectcom.h"
#include "etp1jj.h"
#include "trikjj.h"
#include "yknkjj.h"
      INTEGER TTLOOP
      INTEGER UFITQL
      LOGICAL FIRST
      SAVE FIRST,NAFRFT,NATARC,NAYKNK
      DATA FIRST /.TRUE./
      DATA RECMN/186.2/,ZECMN/254.2/,THRTR/5.E-05/,NTURN/5/
C
C?  NTURN = MAX NUMBER OF TURNS
C
#include "bmacro.h"
      IF(FIRST)THEN
         FIRST=.FALSE.
         NAFRFT=NAMIND('FRFT')
         NATARC=NAMIND('TARC')
         NAYKNK=NAMIND('YKNK')
         NAENKF=NAMIND('ENKF')
      ENDIF
      IER=0
      KFRFT  = IW(NAFRFT)
      IF(KFRFT.NE.0)THEN
C
C? GET NUMBER OF TRACKS
C
         NTRKS=LROWS(KFRFT)
C
C?   CREATE ETP1 BANK
C
         CALL AUBOS('ETP1',0,NTRKS*LETP1A+LMHLEN,KETP1,IGARB)
         IF (IGARB.EQ.2) GOTO 30
C
C?   FILL MINIHEADER
C
         IW(KETP1+1)=LETP1A
         IW(KETP1+2)=NTRKS
C        KTGFT=IW(NATGFT)
         KFRFT  = IW(NAFRFT)
         KTARC  = IW(NATARC)
         KYKNK  = IW(NAYKNK)
C
C? LOOP ON TRACKS
C
         DO 10 ITK=1,NTRKS
C
C? First of all, set up bank line
C
             KLINE=KROW(KETP1,ITK)
C
C***** Call to UFITQL and subsequent check on return code commented out
C***** by M.Cattaneo, 16-Jul-1997 because UFITQL never returns 5 
C
C? First, verify that the track should be extrapolated, according
C?  to Dave's new flag
C?     4 means bad track
C
C*****             INEWFL=UFITQL(ITK)
C
C? AUG. 29 1991 : bad tracks which should not be associated
C?   are now type 5
C
C*****             IF(INEWFL.EQ.5)THEN
C*****               IFLAG=0
C*****               GO TO 11
C*****             ENDIF
C
C  Do not extrapolate tracks coming into a kink
C
             IF(KYKNK.GT.0)THEN
                DO IKNK = 1, LROWS(KYKNK)
                    IF (ITK .EQ. ITABL(KYKNK,IKNK,JYKNIT)) THEN
                        IFLAG=0
                        GO TO 11
                    ENDIF
                ENDDO
             ENDIF
C
             IARC=TTLOOP(ITK)
             IF(IARC.EQ.0)THEN
C
C? Normal tracks (1 arc only)
C
               RECIP=-RTABL(KFRFT,ITK,JFRFIR)
               TLAM=RTABL(KFRFT,ITK,JFRFTL)
               COTH=TLAM/SQRT(1.+TLAM**2)
               Z0  =RTABL(KFRFT,ITK,JFRFZ0)
               IFRFT=KROW(KFRFT,ITK)
               CALL UNEWDP(RW(IFRFT+1),D0P,PHI0P)
               D0  =   D0P * SIGN(1.,-RECIP)
               PHI0=   PHI0P
             ELSE IF(IARC.GT.0)THEN
C
C? Track loops many turns; take the last arc
C
               RECIP = -RTABL(KTARC,IARC,JTARIR)
               TLAM  = RTABL(KTARC,IARC,JTARTL)
               PHI0  = RTABL(KTARC,IARC,JTARP0)
               D0    = RTABL(KTARC,IARC,JTARD0)
               Z0    = RTABL(KTARC,IARC,JTARZ0)
C
C? If we move in the inverse sense, some parameters have to be
C?   inverted
C
               INVER = ITABL(KTARC,IARC,JTARAN)
               IF(INVER.LT.0)THEN
                 PHI0 = PHI0 - PI
                 D0   = -D0
                 RECIP= -RECIP
                 TLAM = -TLAM
               ENDIF
               COTH  = TLAM/SQRT(1.+TLAM**2)
             ELSE
C
C? Iarc<0 : the track in not good (eg ITC only, etc...)
C
               IFLAG=0
               GO TO 11
             ENDIF
C
C?      SENSE OF TURN (SIGN OF RADIUS)
C
             SIGRA=SIGN(1.,RECIP)
C
C? SIGN OF COSTH
C
             SIGCO=SIGN(1.,COTH)
             SITH=SQRT(1.-COTH**2)
             THETA=ACOS(COTH)
C
C
C?  TO GO TO BARREL
C
             SIPH0=SIN(PHI0)
             COPH0=COS(PHI0)
             DPHI = 0.
C
C?   CHECK THAT CURVATURE IS FINITE; ELSE, MAKE LINEAR EXTRAPOLATION,
C?    AND GIVE STANDARD MAX VALUE TO MOMENTUM
C
             IF(ABS(RECIP).LT.THRTR)THEN
               CCNST=0.
               PXY=90.
               IF(COTH.NE.0)THEN
                 DSZ=(ZECMN-Z0*SIGCO)/ABS(COTH)
                 DSXY=SQRT(RECMN**2-D0**2)/SIN(THETA)
                 DS=AMIN1(DSZ,DSXY)
               ELSE
                 DS=RECMN-ABS(D0)
               ENDIF
               SINBR=-DS*SIN(THETA)
               IFLAG=1
             ELSE
C
C?  ANGLE BETWEEN TRACK AND X AXIS AT ENTRY POINT
C
               RADIU=1./RECIP
               RAD=ABS(RADIU)
               DIST=RAD-D0
               IF( DIST .EQ. 0.0 ) THEN
                  IFLAG=0
                  GO TO 11
               ENDIF
               COPHI=-(RECMN**2-RAD**2-DIST**2)/(2.*RAD*DIST)
C
C?  GET MOMENTUM PROJECTION IN X-Y PLANE
C
               PXY=AAAKEC*RAD*ABS(FILDEC)
C
C?  SEE IF TRACK INTERSECTS ECAL
C
               IF(ABS(COPHI).LT.1.)THEN
                 DSXY=RAD*ACOS(COPHI)/SIN(THETA)
C
C?  Check that costheta is finite (avoid divide by zero)
C
                 IF(COTH.NE.0)THEN
                    DSZ=(ZECMN-Z0*SIGCO)/ABS(COTH)
                    DS=AMIN1(DSZ,DSXY)
                 ELSE
                    DS=DSXY
                 ENDIF
               ELSE
                 IF(COTH.NE.0)THEN
                    DS=(ZECMN-Z0*SIGCO)/ABS(COTH)
                 ELSE
                    IFLAG=0
                    GO TO 11
                 ENDIF
               ENDIF
C
C?    DO NOT EXTRAPOLATE TRACKS WHICH MAKE
C?   MORE THAN NTURN  LOOPS BEFORE THEY REACH ECAL
C
               IFLAG=0
               IF(DS.GT.TWOPI*RAD*FLOAT(NTURN))GO TO 11
CMC  Check that DS is finite (avoid divide by zero)
               IF( DS .EQ. 0.0 ) GOTO 11
CMC
               IFLAG=1
C
C? PHI CHANGE FROM POINT 0, TO ENTRY INTO ECAL
C
               DPHI=-DS*SITH/RADIU
C
               SINB=SIN(DPHI)
               COSB=COS(DPHI)
               CCNST=(1.-COSB)/SINB
               SINBR=SINB*RADIU
             ENDIF
             X=-D0*SIGRA*SIPH0+SINBR*(CCNST*SIPH0-COPH0)
             Y= D0*SIGRA*COPH0-SINBR*(CCNST*COPH0+SIPH0)
             Z=Z0+DS*COTH
             ALPHA=PHI0+DPHI
C
C?  MAKE PROJECTIONS OF P
C
             PX=PXY*COS(ALPHA)
             PY=PXY*SIN(ALPHA)
             PZ=PXY*COTH/SITH
             PTOT=SQRT(PX**2+PY**2+PZ**2)
             PX=PX/PTOT
             PY=PY/PTOT
             PZ=PZ/PTOT
C
C?  MAKE CHARGE
C
             CHRGE=SIGN(1.,FILDEC*SIGRA)
C
C?  FILL BANK ETP1 (ONE ROW)
C
 11          CONTINUE
             IW(KLINE+JETPEF)=IFLAG
             IF (IFLAG.NE.0) THEN
               KTRIK = NLINK('TRIK',ITK)
               IF (IW(NAENKF).NE.0 .OR. KTRIK.EQ.0 ) THEN
                 RW(KLINE+JETPX3)=X
                 RW(KLINE+JETPX3+1)=Y
                 RW(KLINE+JETPX3+2)=Z
                 RW(KLINE+JETPP3)=PX
                 RW(KLINE+JETPP3+1)=PY
                 RW(KLINE+JETPP3+2)=PZ
                 RW(KLINE+JETPPT)=PTOT
                 RW(KLINE+JETPCH)=CHRGE
               ELSE
                 CALL UCOPY(RW(KTRIK+LMHLEN+JTRIX3),RW(KLINE+JETPX3),8)
               ENDIF
             ENDIF
   10    CONTINUE
      ELSE
C
C?   IF FRFT DOES NOT EXIST,CREATE EMPTY BANK; FILL MINIHEADER
C
         NTRKS=0
         CALL AUBOS('ETP1',0,NTRKS*LETP1A+LMHLEN,KETP1,IGARB)
         IF (IGARB.EQ.2) GOTO 30
         IW(KETP1+1)=LETP1A
         IW(KETP1+2)=NTRKS
         IF (JDBDRF(4) .GE. 1) THEN
            CALL RERROR('EPRTPC',1,' BANK FRFT DOES NOT EXIST')

         ENDIF
      ENDIF
C
C?  PUT BANK IN LIST
C
      CALL BLIST(IW,'E+','ETP1')
      RETURN
   30 CONTINUE
      CALL RERROR('EPRTPC',2,' exit')
      IER=1
      RETURN
      END
#endif
#endif
@


1.6
log
@julia 308.02
@
text
@d27 1
d241 3
@


1.5
log
@julia 303.06
@
text
@d26 1
d203 4
@


1.4
log
@Tracking upgrade
@
text
@d24 2
d93 3
d100 1
a100 1
             INEWFL=UFITQL(ITK)
d105 4
a108 4
             IF(INEWFL.EQ.5)THEN
               IFLAG=0
               GO TO 11
             ENDIF
@


1.3
log
@import jul280 from historian
Modified Files:
	aamain.F aboldr.F ajmmcl.F almmcl.F altime.F aulpol.F
 Modified Files:
	bccrun.F bcpack.F binijo.F biniru.F bmsum.F bpreda.F bprsum.F
	bslowc.F
	cabook.F calrec.F calrel.F calrep.F calsup.F cashet.F casmp.F
	casneu.F casnmp.F cclorl.F cctrmi.F ccutpe.F cdang.F cdths.F
 	cegclu.F cencch.F cencne.F cesclu.F cexcob.F cexhis.F cfpass.F
 	cfpmip.F cfpnmp.F cgrunc.F chclu.F chgclu.F chsclu.F cinijo.F
 	cinirl.F cinpar.F cinsrl.F cisgam.F cishit.F cludis.F cmoni.F
 	cnighb.F coslst.F cpadwr.F cparad.F cpotcr.F cpoteh.F cpotlc.F
 	cptcom.F crcalo.F crchrl.F crcjob.F crcpar.F crhclu.F cthclu.F
 	ctkchg.F ctrmip.F ctrpar.F ctrtoc.F cvrify.F
 	e1bpei.F e2bpei.F e3bpei.F e4bary.F e4cosz.F e4dead.F e4deij.F
 	e4fdij.F e4fide.F e4find.F e4fnec.F e4frac.F e4gtbr.F e4gtpl.F
 	e4gtso.F e4gtst.F e4gttw.F e4indi.F e4lea1.F e4ovrl.F e4pal.F
 	e4r1r2.F e4r2r3.F e4r3r4.F e4radc.F e4res2.F e4res3.F e4tstl.F
 	e4xyz0.F eautop.F ebegid.F eboxki.F ecalig.F ecblda.F ecboba.F
	ecbook.F eccaob.F ecchkb.F ecclco.F ecclus.F ecdamp.F ecdebg.F
 	ecdete.F ecdigi.F ecener.F eceras.F ecfclu.F ecfils.F ecfmip.F
 	ecfobj.F ecgflw.F ecgmix.F echarg.F echcgl.F echedc.F echiba.F
 	echist.F echtag.F ecinit.F ecinrv.F eclamp.F eclana.F ecleib.F
 	eclgeo.F eclope.F eclorl.F eclost.F ecltag.F ecltrk.F ecltyp.F
 	ecluar.F ecmesp.F ecmod.F ecmopl.F ecncob.F ecobnk.F ecoent.F
 	ecoidp.F ecos.F ecpasr.F ecplm.F ecprin.F ecprlo.F ecrcob.F
 	ecre4d.F ecreib.F ecrmip.F ecrndx.F ecrpei.F ecrtr.F ecrunq.F
 	ecscmd.F ecst.F ecsupp.F ecsw1093.F ecsw94.F ectemp.F ecthre.F
 	ectopo.F ectpc.F ectrap.F ectrea.F ecxmod.F edisal.F edlist.F
 	efaxe.F efbook.F eferrr.F eficlp.F eficv.F efiecp.F efieib.F
 	efijob.F efix.F efixi94.F eflcst.F efolmk.F efpard.F eftiel.F
 	egacst.F egaest.F egetds.F egfcst.F egttks.F ehcflo.F ehlix.F
 	ehreg.F eidedx.F eident.F eieffl.F einhlx.F einijo.F einirl.F
 	einiru.F einitk.F einsrl.F eipard.F eithr.F eknewb.F eknewe.F
 	elecid.F elongi.F emfill.F emskei.F emskev.F emskf.F emski.F
 	emskji.F emskmu.F enfmsk.F enighb.F enoise.F enprox.F enstat.F
 	epadcl.F epatrn.F epcalo.F epchg.F epneu.F epreda.F eproba.F
 	eprsto.F eprsum.F eprtpc.F ereset.F eroad.F escdef.F escoun.F
 	esfil.F eslas.F eslct.F eslctf.F eslowc.F estag.F esveto.F
 	eswpst.F etdifp.F ethres.F etrdev.F ewdifp.F ewircl.F ex3ijk.F
@
text
@d15 10
a24 1
C!
d26 1
a26 1
C?
d42 2
d47 1
a47 1
      SAVE FIRST,NAFRFT,NATARC
d58 2
d79 3
a81 2
        KFRFT  = IW(NAFRFT)
        KTARC  = IW(NATARC)
d89 1
a89 1
         KLINE=KROW(KETP1,ITK)
d95 1
a95 1
         INEWFL=UFITQL(ITK)
d100 18
a117 6
         IF(INEWFL.EQ.5)THEN
            IFLAG=0
            GO TO 11
         ENDIF
         IARC=TTLOOP(ITK)
         IF(IARC.EQ.0)THEN
d121 9
a129 9
            RECIP=-RTABL(KFRFT,ITK,JFRFIR)
            TLAM=RTABL(KFRFT,ITK,JFRFTL)
            COTH=TLAM/SQRT(1.+TLAM**2)
            Z0  =RTABL(KFRFT,ITK,JFRFZ0)
            IFRFT=KROW(KFRFT,ITK)
            CALL UNEWDP(RW(IFRFT+1),D0P,PHI0P)
            D0  =   D0P * SIGN(1.,-RECIP)
            PHI0=   PHI0P
         ELSEIF(IARC.GT.0)THEN
d133 5
a137 5
            RECIP = -RTABL(KTARC,IARC,JTARIR)
            TLAM  = RTABL(KTARC,IARC,JTARTL)
            PHI0  = RTABL(KTARC,IARC,JTARP0)
            D0    = RTABL(KTARC,IARC,JTARD0)
            Z0    = RTABL(KTARC,IARC,JTARZ0)
d142 9
a150 9
            INVER = ITABL(KTARC,IARC,JTARAN)
            IF(INVER.LT.0)THEN
               PHI0 = PHI0 - PI
               D0   = -D0
               RECIP= -RECIP
               TLAM = -TLAM
            ENDIF
            COTH  = TLAM/SQRT(1.+TLAM**2)
         ELSE
d154 3
a156 3
            IFLAG=0
            GO TO 11
         ENDIF
d160 1
a160 1
            SIGRA=SIGN(1.,RECIP)
d164 3
a166 3
         SIGCO=SIGN(1.,COTH)
         SITH=SQRT(1.-COTH**2)
         THETA=ACOS(COTH)
d171 3
a173 3
            SIPH0=SIN(PHI0)
            COPH0=COS(PHI0)
            DPHI = 0.
d178 13
a190 13
         IF(ABS(RECIP).LT.THRTR)THEN
            CCNST=0.
            PXY=90.
            IF(COTH.NE.0)THEN
              DSZ=(ZECMN-Z0*SIGCO)/ABS(COTH)
              DSXY=SQRT(RECMN**2-D0**2)/SIN(THETA)
              DS=AMIN1(DSZ,DSXY)
            ELSE
              DS=RECMN-ABS(D0)
            ENDIF
              SINBR=-DS*SIN(THETA)
              IFLAG=1
         ELSE
d194 4
a197 4
            RADIU=1./RECIP
            RAD=ABS(RADIU)
            DIST=RAD-D0
            COPHI=-(RECMN**2-RAD**2-DIST**2)/(2.*RAD*DIST)
d201 1
a201 1
            PXY=AAAKEC*RAD*ABS(FILDEC)
d205 2
a206 2
            IF(ABS(COPHI).LT.1.)THEN
               DSXY=RAD*ACOS(COPHI)/SIN(THETA)
d210 14
a223 14
         IF(COTH.NE.0)THEN
           DSZ=(ZECMN-Z0*SIGCO)/ABS(COTH)
           DS=AMIN1(DSZ,DSXY)
         ELSE
           DS=DSXY
         ENDIF
       ELSE
         IF(COTH.NE.0)THEN
           DS=(ZECMN-Z0*SIGCO)/ABS(COTH)
         ELSE
           IFLAG=0
           GO TO 11
         ENDIF
            ENDIF
d228 3
a230 3
            IFLAG=0
            IF(DS.GT.TWOPI*RAD*FLOAT(NTURN))GO TO 11
            IFLAG=1
d234 1
a234 1
            DPHI=-DS*SITH/RADIU
d236 9
a244 9
            SINB=SIN(DPHI)
            COSB=COS(DPHI)
            CCNST=(1.-COSB)/SINB
            SINBR=SINB*RADIU
         ENDIF
         X=-D0*SIGRA*SIPH0+SINBR*(CCNST*SIPH0-COPH0)
         Y= D0*SIGRA*COPH0-SINBR*(CCNST*COPH0+SIPH0)
         Z=Z0+DS*COTH
         ALPHA=PHI0+DPHI
d248 7
a254 7
         PX=PXY*COS(ALPHA)
         PY=PXY*SIN(ALPHA)
         PZ=PXY*COTH/SITH
         PTOT=SQRT(PX**2+PY**2+PZ**2)
         PX=PX/PTOT
         PY=PY/PTOT
         PZ=PZ/PTOT
d258 1
a258 1
         CHRGE=SIGN(1.,FILDEC*SIGRA)
d262 17
a278 10
         RW(KLINE+JETPX3)=X
         RW(KLINE+JETPX3+1)=Y
         RW(KLINE+JETPX3+2)=Z
         RW(KLINE+JETPP3)=PX
         RW(KLINE+JETPP3+1)=PY
         RW(KLINE+JETPP3+2)=PZ
         RW(KLINE+JETPPT)=PTOT
         RW(KLINE+JETPCH)=CHRGE
   11       CONTINUE
         IW(KLINE+JETPEF)=IFLAG
@


1.2
log
@julia version 279
@
text
@a0 1
*DK eprtpc
@


1.1
log
@Initial revision
@
text
@d21 4
d272 1
@


1.1.1.1
log
@import julia 300
@
text
@@
