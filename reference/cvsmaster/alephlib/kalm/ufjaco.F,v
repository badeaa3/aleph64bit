head	1.3;
access;
symbols
	aleph316_2:1.3
	aleph316_1:1.3
	aleph316:1.3
	aleph315_7:1.3
	aleph315_6:1.3
	aleph315_5:1.3
	aleph315_4:1.3
	aleph315_3:1.3
	aleph315_2:1.3
	aleph315_1:1.3
	aleph315:1.3
	aleph314_2:1.3
	aleph314_1:1.3
	aleph314:1.3
	aleph313_1:1.3
	aleph313:1.3
	aleph312_1:1.2
	aleph312:1.2
	aleph311_1:1.2
	aleph311:1.2
	aleph310_3:1.2
	aleph310_2:1.2
	aleph310_1:1.2
	aleph310:1.2
	aleph309_1:1.2
	aleph309:1.2
	aleph308_3:1.2
	aleph308_2:1.2
	aleph308_1:1.2
	aleph308:1.2
	aleph307_6:1.2
	aleph307_5:1.2
	aleph307_4:1.2
	aleph307_2:1.2
	aleph307_1:1.2
	aleph307:1.2
	aleph306:1.2
	aleph305_4:1.2
	aleph305_3:1.2
	aleph305_2:1.2
	aleph305_1:1.2
	aleph305:1.2
	aleph304_5:1.2
	aleph304_4:1.2
	aleph304_3:1.2
	aleph304_2:1.2
	aleph304_1:1.2
	aleph304:1.2
	aleph303_3:1.2
	aleph303_2:1.2
	aleph303_1_mc1:1.2
	aleph303_1:1.2
	aleph303:1.2
	aleph302_9:1.2
	aleph302_8:1.2
	aleph302_7:1.2
	aleph302_6:1.2
	aleph302_5:1.2
	aleph302_4:1.2
	aleph302_3:1.1
	aleph302_2:1.1
	aleph302_1:1.1
	aleph302:1.2;
locks; strict;
comment	@c @;


1.3
date	99.10.26.09.32.27;	author cattanem;	state Exp;
branches;
next	1.2;

1.2
date	97.04.02.08.55.55;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	97.03.06.11.59.19;	author flr;	state Exp;
branches;
next	;


desc
@@


1.3
log
@for Alephlib 313
@
text
@      INTEGER FUNCTION UFJACO(R_OLD,R_NEW,STATE,DFDX)
C! Get Jacobian of transport from one radius to another
C!
C! Modified: D.Smith 991025 Double precision fixes for Linux
C!
#ifndef DOC
      IMPLICIT NONE

      INTEGER I, J

      DOUBLE PRECISION R_OLD, R_NEW, STATE(5), DFDX(5,5)
      DOUBLE PRECISION T, DELTA_PHI, DT_DRPHI, DT_DPHI, DT_DOMEGA
      DOUBLE PRECISION PHI_NEW, FACTOR, DENOM
      DOUBLE PRECISION INV_R_OLD, INV_STATE5, SINPHINEW

      INTEGER UTPROC

C  Initialize Jacobian
C don't bother using the symmetry; the optimizer can do better if the
C     loop limits are fixed.
      DO I = 1, 5
        DO J = 1, 5
          DFDX(J,I) = 0.D0
        END DO
        DFDX(I,I) = 1.D0
      ENDDO

C  Get the advance in process time

      UFJACO = UTPROC(R_OLD,R_NEW,STATE,T)
      IF(UFJACO .NE. 0) RETURN

C Calculate the Jacobian

C double precision divides are 2-5 times slower than multiplies, so
C     create some temps.
      UFJACO = -1
      IF (ABS(R_OLD).LT.1.D-15 .OR. ABS(STATE(5)).LT.1.D-15) RETURN
      INV_R_OLD = 1.0D0 / R_OLD
      INV_STATE5 = 1.0D0 / STATE(5)

      DELTA_PHI = STATE(3) - STATE(1) * INV_R_OLD
      DENOM = ( DSIN(T)*INV_STATE5 + R_OLD*DCOS( DELTA_PHI + T ) )
      IF (DENOM .EQ. 0D0) RETURN
      DT_DRPHI = ( DCOS( DELTA_PHI + T ) - DCOS(DELTA_PHI) ) / DENOM
      DT_DPHI = - R_OLD * DT_DRPHI
      DENOM =   STATE(5) * ( DSIN(T)*INV_STATE5 + 
     +              R_OLD*DCOS(DELTA_PHI + T ) ) 
      IF (DENOM .EQ. 0D0) RETURN
      DT_DOMEGA = ( 4.D0 * DSIN(T/2.D0)**2 * INV_STATE5
     +             + R_OLD*(DSIN(DELTA_PHI + T)-DSIN(DELTA_PHI)) ) /
     +               DENOM

      PHI_NEW = STATE(3) + T
      SINPHINEW = DSIN(PHI_NEW)
      DENOM = R_OLD*DCOS(STATE(1)*INV_R_OLD)-(DSIN(STATE(3))
     &  - SINPHINEW)*INV_STATE5
      IF (DENOM .EQ. 0D0) RETURN
      FACTOR = R_NEW / DENOM

      DFDX(1,1) = FACTOR*( DCOS( STATE(1)*INV_R_OLD ) +
     $     DT_DRPHI * SINPHINEW * INV_STATE5 )
      DFDX(1,3) = FACTOR*INV_STATE5*( (1.D0+DT_DPHI)*SINPHINEW -
     $     DSIN(STATE(3)) )
      DFDX(1,5) = FACTOR*INV_STATE5*( (DCOS(STATE(3)+T)
     +     - DCOS(STATE(3)) )*INV_STATE5 + SINPHINEW * DT_DOMEGA )

      FACTOR = DTAN(STATE(4))*INV_STATE5

      DFDX(2,1) = FACTOR * DT_DRPHI
      DFDX(2,3) = FACTOR * DT_DPHI
      DENOM = STATE(5) * (DCOS(STATE(4)))**2
      IF (DENOM .EQ. 0D0) RETURN
      DFDX(2,4) = T / DENOM
      DFDX(2,5) = FACTOR * ( DT_DOMEGA - T*INV_STATE5 )
      DFDX(3,1) = DT_DRPHI
      DFDX(3,3) = 1.D0 + DT_DPHI
      DFDX(3,5) = DT_DOMEGA

      UFJACO = 0
      RETURN
      END
#endif
@


1.2
log
@alephlib 302 corr.file no 4
@
text
@d3 3
d38 1
a38 1
      IF (ABS(R_OLD).LT.1.E-15 .OR. ABS(STATE(5)).LT.1.E-15) RETURN
d44 1
a44 1
      IF (DENOM .EQ. 0.) RETURN
d49 1
a49 1
      IF (DENOM .EQ. 0.) RETURN
d58 1
a58 1
      IF (DENOM .EQ. 0.) RETURN
d73 1
a73 1
      IF (DENOM .EQ. 0.) RETURN
@


1.1
log
@1st test version aleph302
@
text
@d8 1
a8 1
      DOUBLE PRECISION R_OLD, R_NEW, STATE(1), DFDX(5,5)
d10 1
a10 1
      DOUBLE PRECISION PHI_NEW, FACTOR
d34 2
d40 3
a42 2
      DT_DRPHI = ( DCOS( DELTA_PHI + T ) - DCOS(DELTA_PHI) ) /
     +             ( DSIN(T)*INV_STATE5 + R_OLD*DCOS( DELTA_PHI + T ) )
d44 3
d49 1
a49 2
     +             ( STATE(5) * ( DSIN(T)*INV_STATE5 + R_OLD*DCOS(
     +             DELTA_PHI + T ) ))
d53 4
a56 3

      FACTOR = R_NEW / (R_OLD*DCOS(STATE(1)*INV_R_OLD)-(DSIN(STATE(3))
     &  - SINPHINEW)*INV_STATE5)
d69 3
a71 1
      DFDX(2,4) = T / ( STATE(5) * (DCOS(STATE(4)))**2 )
@
