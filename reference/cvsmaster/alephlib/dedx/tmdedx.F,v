head	1.4;
access;
symbols
	aleph316_2:1.4
	aleph316_1:1.4
	aleph316:1.4
	aleph315_7:1.4
	aleph315_6:1.4
	aleph315_5:1.4
	aleph315_4:1.4
	aleph315_3:1.4
	aleph315_2:1.4
	aleph315_1:1.4
	aleph315:1.4
	aleph314_2:1.4
	aleph314_1:1.4
	aleph314:1.4
	aleph313_1:1.4
	aleph313:1.4
	aleph312_1:1.4
	aleph312:1.4
	aleph311_1:1.1.1.1
	aleph311:1.1.1.1
	aleph310_3:1.1.1.1
	aleph310_2:1.1.1.1
	aleph310_1:1.1.1.1
	aleph310:1.1.1.1
	aleph309_1:1.1.1.1
	aleph309:1.1.1.1
	aleph308_3:1.1.1.1
	aleph308_2:1.1.1.1
	aleph308_1:1.1.1.1
	aleph308:1.1.1.1
	aleph307_6:1.1.1.1
	aleph307_5:1.1.1.1
	aleph307_4:1.1.1.1
	aleph307_2:1.1.1.1
	aleph307_1:1.1.1.1
	aleph307:1.1.1.1
	aleph306:1.1.1.1
	aleph305_4:1.1.1.1
	aleph305_3:1.1.1.1
	aleph305_2:1.1.1.1
	aleph305_1:1.1.1.1
	aleph305:1.1.1.1
	aleph304_5:1.1.1.1
	aleph304_4:1.1.1.1
	aleph304_3:1.1.1.1
	aleph304_2:1.1.1.1
	aleph304_1:1.1.1.1
	aleph304:1.1.1.1
	aleph303_3:1.1.1.1
	aleph303_2:1.1.1.1
	aleph303_1_mc1:1.1.1.1
	aleph303_1:1.1.1.1
	aleph303:1.1.1.1
	aleph302_9:1.1.1.1
	aleph302_8:1.1.1.1
	aleph302_7:1.1.1.1
	aleph302_6:1.1.1.1
	aleph302_5:1.1.1.1
	aleph302_4:1.1.1.1
	aleph302_3:1.1.1.1
	aleph302_2:1.1.1.1
	aleph302_1:1.1.1.1
	aleph302:1.1.1.1
	aleph216:1.1.1.1
	aleph215_3:1.1.1.1
	aleph215_2:1.1.1.1
	aleph215:1.1.1.1
	aleph214:1.1.1.1
	aleph213:1.1.1.1
	aleph212:1.1.1.1
	ALEPH212:1.1.1;
locks; strict;
comment	@c @;


1.4
date	99.09.03.09.04.45;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.09.59.07;	author cattanem;	state Exp;
branches;
next	1.2;

1.2
date	99.07.30.08.51.02;	author cattanem;	state Exp;
branches;
next	1.1;

1.1
date	96.02.07.11.40.54;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.02.07.11.40.55;	author flr;	state Exp;
branches;
next	;


desc
@@


1.4
log
@write obsolescence warning once only
@
text
@      SUBROUTINE TMDEDX(ITK,RI,RSIG,NS,TL,IER)
C----------------------------------------------------------------------
C! Routine for backward compatibility only. Call TMPDDX directly instead
C
C  M.Cattaneo 1999-07-29
C----------------------------------------------------------------------
#ifndef DOC
C
      LOGICAL FIRST /.TRUE./
#include "bcs.h"
      IF( FIRST ) THEN
        WRITE(IW(6),*)
     &   'Routine TMDEDX is obsolete. Please use TMPDDX instead'
        FIRST = .FALSE.
      ENDIF
C
      CALL TMPDDX('WIRE',ITK,RI,RSIG,XNS,TL,IER)
      NS = NINT(XNS)

      RETURN
      END
#endif
@


1.3
log
@still Aleph312...
@
text
@d9 1
d11 2
a12 1
      WRITE(IW(6),*)
d14 2
@


1.2
log
@Alephlib 312 test
@
text
@a12 1
      XNS = REAL(NS)
d14 1
@


1.1
log
@Initial revision
@
text
@d2 2
d5 1
a5 27
C-------------------------------------------------------------------
C! Return reduced and calibrated dE/dx for a single track.
C!
CKEY DEDX TPC MDST
C!
C!    Author:  R. Johnson    31-05-89
C!    Modified:W. Wiedenmann 31-08-93 use new banks TCGX/TCSX
C!
C! Input:   ITK         /I       Track number in FRFT bank
C! Output:  RI          /R       Measured ionization (1.0=minion, Q=1)
C!          RSIG        /R       Relative error on the dE/dx
C!                               The error to be used in analysis
C!                               should be calculated from:
C!                               SIGMA**2= (RSIG*Iexp)**2 + SIG_P**2
C!                               where Iexp is the expected ionization
C!                               for a given hypothesis, and SIG_P
C!                               is the contribution from momentum
C!                               error.
C!          NS          /R       Number of useful wire samples on track
C!          TL          /T       Useful length of the track (cm)
C!          IER         /I       Error return= 0 for success
C!                               2= can't find dE/dx bank
C!                               3= track has no dE/dx information
C!                               4= cannot find calibration banks
C!                               6= no valid dE/dx calibration exists
C!                                  for this run
C!
d10 2
a11 123
#include "texsjj.h"
#include "tc1xjj.h"
#include "tpgpar.h"
      DIMENSION SNR(LTSECT)
C
      LOGICAL FOUND
      INTEGER ALGTDB,GTSTUP
      CHARACTER  DET*2, LIST*4
      PARAMETER (DET='TP', LIST='TC1X')
      DATA IROLD /0/
      DATA NTC1X, NTEXS / 2*0/
C
C++   Distance between TPC sense wires
C
      DATA DWIR/0.400/
C
#include "bmacro.h"
C
      IF (NTC1X.EQ.0) THEN
        NTEXS=NAMIND('TEXS')
        NTC1X=NAMIND('TC1X')
      ENDIF
C
#include "gtdbbk.h"
      KTC1X=IW(NTC1X)
      IF (KTC1X.EQ.0) THEN
         IER=4
         GOTO 999
      ENDIF
      CALL TDEDXV(RNRMA,SNR,IER)
      IF (IER.NE.0) THEN
         IER=4
         GOTO 999
      ENDIF
C
C++   Link to the dE/dx reconstructed information
C
      KTEXS=IW(NTEXS)
      IF (KTEXS.EQ.0) THEN
        IER=2
        GO TO 999
      ENDIF
C
C++   Overall normalization.  If this is zero, then there is no
C++   valid dE/dx calibration for this run.
C
      IF (RNRMA.LE.0.) THEN
        IER=6
        RETURN
      ENDIF
C
C++   Get the particle's measured dE/dx, track length, and # samples
C
      NS=0
      TRMN=0.
      TL=0.
      FOUND=.FALSE.
      DO 100 ISG=1,LROWS(KTEXS)
        IPNT=ITABL(KTEXS,ISG,JTEXTN)
        IF (IPNT.NE.ITK) THEN
          IF (FOUND) GO TO 101
          GO TO 100
        ENDIF
        FOUND=.TRUE.
C
C++     Skip sectors with more than 40% of hits saturated
C
        IF (ITABL(KTEXS,ISG,JTEXSF).EQ.1) GO TO 100
C
C++     Skip sectors which could not be calibrated (RNRMS=0)
C
        ISLOT=ITABL(KTEXS,ISG,JTEXSI)
        RNRMS= SNR(ISLOT)
        IF (RNRMS.LE.0.) GO TO 100
C
C++     Measured ionization (truncated mean)
C
        TMS=RTABL(KTEXS,ISG,JTEXTM)
C
C++     Correction for sample length
C
        NSMP=ITABL(KTEXS,ISG,JTEXNS)
        IF (NSMP.LE.1) GO TO 100
        RNSMP=FLOAT(NSMP)
        ASL=RTABL(KTEXS,ISG,JTEXTL)/RNSMP
        SMPL=ALOG(ASL/DWIR)
C
C++     Correct the sector-to-sector normalization
C
        TMS= TMS*RNRMS
C
C++     Add the contributions from different sectors, weighted by the
C++     number of wire pulses in the sector
C
        TRMN=TRMN + TMS * RNSMP
C
C++     Add up the total track length and number of samples
C
        NS=NS + NSMP
        TL=TL+ RTABL(KTEXS,ISG,JTEXTL)
  100 CONTINUE
  101 CONTINUE
      IF (NS.EQ.0) THEN
        IER=3
        GO TO 999
      ENDIF
      RI=TRMN/FLOAT(NS)
C
C++   Correct the truncated mean with overall normalization factor
C
      RI= RI*RNRMA
C
C++   We want NS to represent the number of samples BEFORE truncation,
C++   so we divide by JTRUNK.  The same applies to TL, the length.
C
      JTRUNK=ITABL(KTC1X,1,JTC1TP)
      NS=(NS*100)/JTRUNK
      TL=TL*100./FLOAT(JTRUNK)
C
C++   Get the resolution corresponding to this track length and number
C++   of samples.
C
      RSIG=TDXERR(NS,TL,IER)
d13 3
a15 2
      IER=0
  999 CONTINUE
@


1.1.1.1
log
@import aleph212 from alws
@
text
@@
