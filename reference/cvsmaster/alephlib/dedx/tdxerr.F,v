head	1.3;
access;
symbols
	aleph316_2:1.3
	aleph316_1:1.3
	aleph316:1.3
	aleph315_7:1.3
	aleph315_6:1.3
	aleph315_5:1.3
	aleph315_4:1.3
	aleph315_3:1.3
	aleph315_2:1.3
	aleph315_1:1.3
	aleph315:1.3
	aleph314_2:1.3
	aleph314_1:1.3
	aleph314:1.3
	aleph313_1:1.3
	aleph313:1.3
	aleph312_1:1.3
	aleph312:1.3
	aleph311_1:1.1.1.1
	aleph311:1.1.1.1
	aleph310_3:1.1.1.1
	aleph310_2:1.1.1.1
	aleph310_1:1.1.1.1
	aleph310:1.1.1.1
	aleph309_1:1.1.1.1
	aleph309:1.1.1.1
	aleph308_3:1.1.1.1
	aleph308_2:1.1.1.1
	aleph308_1:1.1.1.1
	aleph308:1.1.1.1
	aleph307_6:1.1.1.1
	aleph307_5:1.1.1.1
	aleph307_4:1.1.1.1
	aleph307_2:1.1.1.1
	aleph307_1:1.1.1.1
	aleph307:1.1.1.1
	aleph306:1.1.1.1
	aleph305_4:1.1.1.1
	aleph305_3:1.1.1.1
	aleph305_2:1.1.1.1
	aleph305_1:1.1.1.1
	aleph305:1.1.1.1
	aleph304_5:1.1.1.1
	aleph304_4:1.1.1.1
	aleph304_3:1.1.1.1
	aleph304_2:1.1.1.1
	aleph304_1:1.1.1.1
	aleph304:1.1.1.1
	aleph303_3:1.1.1.1
	aleph303_2:1.1.1.1
	aleph303_1_mc1:1.1.1.1
	aleph303_1:1.1.1.1
	aleph303:1.1.1.1
	aleph302_9:1.1.1.1
	aleph302_8:1.1.1.1
	aleph302_7:1.1.1.1
	aleph302_6:1.1.1.1
	aleph302_5:1.1.1.1
	aleph302_4:1.1.1.1
	aleph302_3:1.1.1.1
	aleph302_2:1.1.1.1
	aleph302_1:1.1.1.1
	aleph302:1.1.1.1
	aleph216:1.1.1.1
	aleph215_3:1.1.1.1
	aleph215_2:1.1.1.1
	aleph215:1.1.1.1
	aleph214:1.1.1.1
	aleph213:1.1.1.1
	aleph212:1.1.1.1
	ALEPH212:1.1.1;
locks; strict;
comment	@c @;


1.3
date	99.09.03.09.04.44;	author cattanem;	state Exp;
branches;
next	1.2;

1.2
date	99.07.30.08.51.00;	author cattanem;	state Exp;
branches;
next	1.1;

1.1
date	96.02.07.11.40.54;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.02.07.11.40.55;	author flr;	state Exp;
branches;
next	;


desc
@@


1.3
log
@write obsolescence warning once only
@
text
@      FUNCTION TDXERR(NS,TL,IER)
C----------------------------------------------------------------------
C! Routine for backward compatibility only. Call TPXERR directly instead
C
C  M.Cattaneo 1999-07-29
C----------------------------------------------------------------------
#ifndef DOC
C
      LOGICAL FIRST /.TRUE./
#include "bcs.h"
      IF( FIRST ) THEN
        WRITE(IW(6),*)
     &   'Function TDXERR is obsolete. Please use TPXERR instead'
        FIRST = .FALSE.
      ENDIF
C
      XNS = REAL(NS)
      TDXERR = TPXERR('WIRE',XNS,TL,IER)
C
      RETURN
      END
#endif
@


1.2
log
@Alephlib 312 test
@
text
@d9 1
d11 2
a12 1
      WRITE(IW(6),*)
d14 2
@


1.1
log
@Initial revision
@
text
@d2 2
d5 1
a5 10
C-------------------------------------------------------------------
C! Get expected relative dE/dx error
CKEY DEDX TPC ERROR
C  R. Johnson  9-2-90
C
C  Input:   NS      /I     Number of dE/dx samples before truncation
C           TL      /R     Track length
C  Output:  TDXERR  /R     Error on the dE/dx (units 1=minion)
C           IER     /I     Non-zero if database banks not found
C
d10 2
a11 73
#include "tc4xjj.h"
C
      LOGICAL FOUND
C
C - set necessary data for GTDBBK
      INTEGER ALGTDB, GTSTUP
      CHARACTER DET*2, LIST*4
      PARAMETER (DET='TP', LIST='TC4X')
      DATA IROLD/0/
C
      DATA NTC4X/0/
      DATA WIRNT/0.4/
C
#include "bmacro.h"
C
      IF (NS.LE.0) THEN
        CALL ALTELL(' TDXERR: NS=0.  Abort to avoid divide by 0',0,
     &              'RETURN')
        TDXERR=.2
      ENDIF
      IF (NTC4X.EQ.0) THEN
        NTC4X=NAMIND('TC4X')
      ENDIF
C
C++   Look for the calibration constants
#include "gtdbbk.h"
      KTC4X=IW(NTC4X)
      IF (KTC4X.EQ.0) THEN
          IER=4
          GO TO 999
      ENDIF
C
C++   Get data-base constants for resolution parameterization
C
      DX=TL/FLOAT(NS)
      SMPL=ALOG(DX/WIRNT)
      DO 34 I=1,LROWS(KTC4X)
        IF (SMPL.GE.RTABL(KTC4X,I,JTC4MN)
     &         .AND. SMPL.LE.RTABL(KTC4X,I,JTC4MX)) THEN
          IB=I
          GO TO 35
        ENDIF
   34 CONTINUE
      CALL ALTELL(' TDXERR: sample length out of range of bank TC4X.',0,
     &            'RETURN')
      IB=1
   35 CONTINUE
C
      RFLAG= RTABL(KTC4X,IB,JTC4RP+6)
      IF (RFLAG.EQ.0. .AND. IRUN.GT.2000) THEN
C
C++     22 July 1991:
C++     Parameterization for calibration used on 89/90 data.
C++     This will no longer be used if 89/90 data are reprocessed.
C
        A= RTABL(KTC4X,IB,JTC4RP+3)
        B= RTABL(KTC4X,IB,JTC4RP+4)
        ARG= A/FLOAT(NS) + B
        IF (ARG.LT.0.) THEN
          CALL ALTELL(' TDXERR: SQRT of negative number. '//
     &             'Bad calibration consts in bank TC4X?',0,'RETURN')
          TDXERR=0.055
        ELSE
          TDXERR=SQRT(ARG)
        ENDIF
      ELSE
C
C++     This is the prefered formula, which takes into account both
C++     the sample-length dependence and the number of wires
C
        PNORM= RTABL(KTC4X,IB,JTC4RP)
        PPOW1= RTABL(KTC4X,IB,JTC4RP+1)
        PPOW2= RTABL(KTC4X,IB,JTC4RP+2)
d13 2
a14 2
        TDXERR= PNORM*(DX**PPOW2)*((FLOAT(NS))**PPOW1)
      ENDIF
a15 2
      IER=0
  999 CONTINUE
@


1.1.1.1
log
@import aleph212 from alws
@
text
@@
