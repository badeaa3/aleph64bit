head	1.5;
access;
symbols
	aleph316_2:1.5
	aleph316_1:1.5
	aleph316:1.5
	aleph315_7:1.5
	aleph315_6:1.5
	aleph315_5:1.5
	aleph315_4:1.5
	aleph315_3:1.5
	aleph315_2:1.5
	aleph315_1:1.5
	aleph315:1.5
	aleph314_2:1.5
	aleph314_1:1.4
	aleph314:1.4
	aleph313_1:1.4
	aleph313:1.4
	aleph312_1:1.3
	aleph312:1.3
	aleph311_1:1.3
	aleph311:1.3
	aleph310_3:1.3
	aleph310_2:1.3
	aleph310_1:1.3
	aleph310:1.3
	aleph309_1:1.2
	aleph309:1.2
	aleph308_3:1.2
	aleph308_2:1.2
	aleph308_1:1.2
	aleph308:1.2
	aleph307_6:1.2
	aleph307_5:1.2
	aleph307_4:1.2
	aleph307_2:1.2
	aleph307_1:1.2
	aleph307:1.2
	aleph306:1.2
	aleph305_4:1.1.1.1
	aleph305_3:1.1.1.1
	aleph305_2:1.1.1.1
	aleph305_1:1.1.1.1
	aleph305:1.1.1.1
	aleph304_5:1.1.1.1
	aleph304_4:1.1.1.1
	aleph304_3:1.1.1.1
	aleph304_2:1.1.1.1
	aleph304_1:1.1.1.1
	aleph304:1.1.1.1
	aleph303_3:1.1.1.1
	aleph303_2:1.1.1.1
	aleph303_1_mc1:1.1.1.1
	aleph303_1:1.1.1.1
	aleph303:1.1.1.1
	aleph302_9:1.1.1.1
	aleph302_8:1.1.1.1
	aleph302_7:1.1.1.1
	aleph302_6:1.1.1.1
	aleph302_5:1.1.1.1
	aleph302_4:1.1.1.1
	aleph302_3:1.1.1.1
	aleph302_2:1.1.1.1
	aleph302_1:1.1.1.1
	aleph302:1.1.1.1
	aleph216:1.1.1.1
	aleph215_3:1.1.1.1
	aleph215_2:1.1.1.1
	aleph215:1.1.1.1
	aleph214:1.1.1.1
	aleph213:1.1.1.1
	aleph212:1.1.1.1
	ALEPH212:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2000.01.28.14.19.22;	author cattanem;	state Exp;
branches;
next	1.4;

1.4
date	99.10.26.09.32.38;	author cattanem;	state Exp;
branches;
next	1.3;

1.3
date	98.10.02.13.30.54;	author cattanem;	state Exp;
branches;
next	1.2;

1.2
date	97.11.05.17.08.48;	author cattanem;	state Exp;
branches;
next	1.1;

1.1
date	96.02.07.11.40.27;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.02.07.11.40.28;	author flr;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Mods to fjmmcl
@
text
@CKEY PHYSICS
C! various subprograms related to physics
 ! correction file no.2 for ALEPHLIB 31.4
    FJMMCL : Geneva algorithm added, invariant mass combination added,
             clustering to fixed number of jets added
             ADDED ALSO ENTRY POINT  GETYIJ(MyYvalues,nsteps) 
             in order to get transition values back          (G.Dissertori)

 ! ALEPHLIB 31.3
    PAIRFD : Double precision fixes for Linux                   (D.Smith)

 ! ALEPHLIB 31.0
     PAIRFD : Protection to avoid crashes when reading MINIs with
              the ITCO bank                          (T.Greening, J.Boucrot)

 ! ALEPHLIB 30.6
    ALTHRU,PIDECY : fix variable type inconsistencies in function calls, 
                    for Linux                            (A.Waananen)

 ! ALEPHLIB 21.2
   FJMMCL - (JADE algorithm) Speed up by doing linear search (O.Callot)

Name:   FJMMCL
Type:   Subroutine (meant to be user-callable)
Purpose:Find jets using the JADE minimal mass cluster algorithm
Usage:
        +----------------------------------------------------------------+
        |     CALL  FJMMCL( YCUT, ENORM, SCHEME, VERSN, ARRAY1, ARRAY2,  |
        |    &              NPAR, PPARX, PPARY,  PPARZ, PPARE,  NJETMX,  |
        |    &              NJET, PJETX, PJETY,  PJETZ, PJETE,  JNOFP  ) |
        +----------------------------------------------------------------+

Input:  YCUT            REAL    ycut value ( (M/ENORM)**2 )
        ENORM           REAL    normalising energy (if 0.0, use visible E)
        SCHEME          CHAR*2  combination scheme, either 'E ', 'E0', 'P '
        VERSN           CHAR*6  formula, either 'NORMAL' or 'BETTER'
        ARRAY1(k)       REAL    workspace (k = 1,NPAR*NPAR)
        ARRAY2(k)       REAL    workspace (k = 1,NPAR)
        NPAR            INT     number of particles
        PPARX,Y,Z,E(i)  REAL    4-momentum of input particles (i=1,NPAR)
        NJETMX          INT     maximum number of jets there is space for

Output: NJET            INT     +ve number of jets found (normal return)
                                 -1 input  error (NPAR/ENORM)
                                 -2 error from individ. track
                                 -3 too many jets
                                 -4 unknown particle combination scheme wanted
                                 -5 neither NORMAL nor BETTER algorithm wanted
        PJETX,Y,Z,E(j)  REAL    4-momentum of jet j (j=1,NJET < NJETMX)
        JNOFP(i)        INT     jet no. of particle i   (i=1,NPAR)

Calls:  s/r JPCOMB (ALEPHLIB)

Notes:  The JADE method for finding jets has a number of options. The
        standard ('NORMAL') formula is:
                      2*E(i)*E(j)*(1-cos(theta_i_j))         .
        An improved formula ('BETTER') has been proposed by Dokshitzer
        and is:
                      2*Min(E(i),E(j))*(1-cos(theta_i_j))    .

        There is also a choice of particle combination schemes (how the
        particle 4-vectors are added to form the jets). The E scheme
        is the Lorentz-invariant approach; the E0 scheme normalises the
        momentum components to produce massless jets while the P scheme
        sets the energy to the total momentum to achieve the same effect.



Name:   JPCOMB
Type:   Subroutine (not meant to be user-callable)
Purpose:Combine 2 particles according to input scheme (for FJMMCL)
Usage:
        +----------------------------------------------------------------+
        |     CALL  JPCOMB( ( SCHEME, PP, IP1, IP2 )                     |
        +----------------------------------------------------------------+

Input:  SCHEME          CHAR*2  combination scheme, either 'E ', 'E0', 'P '
        PP(5,k)         REAL    array of 5-vectors (k = 1,no_of_particles)
        IP1             INT     pointer to particle 1 in PP ("winner")
        IP2             INT     pointer to particle 2 in PP ("loser")

Output: PP(5,k)         REAL    as defined above (modified)

Calls:  none

Notes:  (See also notes for FJMMCL)
        The 5-vectors describing particle_2 (PX, PY, PZ, E, PTOT) are
        added to those of particle_1 according to the desired scheme and
        the result overwrites the data for particle_1. The data for
        particle_2 are set to (0,0,0,0,-1).



Name:   PJLINK
Type:   Subroutine (meant to be user-callable)
Purpose:Update links between particles and jets after further evolution
        of jets from a low ycut to a higher ycut (JADE method).
Usage:
        +----------------------------------------------------------------+
        |     CALL  PJLINK( KOLDPJ, NP, KJJ, NJ, KNEWPJ, ERROR )         |
        +----------------------------------------------------------------+

Input:  KOLDPJ(i)       INT     Association of particle i to 'old' jet
        NP              INT     Number of 'old' jets
        KJJ(k)          INT     Association of 'old' jet k to 'new' jet
        NJ              INT     Number of 'new' jets

Output: KNEWPJ(i)       INT     Association of particle i to 'new' jet
        ERROR           LOGICAL = .TRUE. if KOLDPJ has an illegal jet number
                                = .FALSE. otherwise

Calls:  none

Notes:  The routine assumes the original particles are numbered 1..NP
        and that the old jets are in the range 1..NJ.



@


1.4
log
@for Alephlib 313
@
text
@d3 5
@


1.3
log
@Alephlib 310
@
text
@d4 3
@


1.2
log
@Alephlib 306
@
text
@d4 4
@


1.1
log
@Initial revision
@
text
@d4 4
@


1.1.1.1
log
@import aleph212 from alws
@
text
@@
