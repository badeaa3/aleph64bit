head	1.2;
access;
symbols
	aleph316_2:1.2
	aleph316_1:1.2
	aleph316:1.2
	aleph315_7:1.2
	aleph315_6:1.2
	aleph315_5:1.2
	aleph315_4:1.2
	aleph315_3:1.2
	aleph315_2:1.2
	aleph315_1:1.2
	aleph315:1.2
	aleph314_2:1.2
	aleph314_1:1.2
	aleph314:1.2
	aleph313_1:1.2
	aleph313:1.2
	aleph312_1:1.2
	aleph312:1.2
	aleph311_1:1.2
	aleph311:1.2
	aleph310_3:1.2
	aleph310_2:1.2
	aleph310_1:1.2
	aleph310:1.2
	aleph309_1:1.2
	aleph309:1.2
	aleph308_3:1.2
	aleph308_2:1.2
	aleph308_1:1.2
	aleph308:1.2
	aleph307_6:1.2
	aleph307_5:1.2
	aleph307_4:1.2
	aleph307_2:1.2
	aleph307_1:1.2
	aleph307:1.2
	aleph306:1.2
	aleph305_4:1.2
	aleph305_3:1.2
	aleph305_2:1.2
	aleph305_1:1.2
	aleph305:1.2
	aleph304_5:1.2
	aleph304_4:1.2
	aleph304_3:1.2
	aleph304_2:1.2
	aleph304_1:1.2
	aleph304:1.2
	aleph303_3:1.2
	aleph303_2:1.2
	aleph303_1_mc1:1.2
	aleph303_1:1.2
	aleph303:1.2
	aleph302_9:1.2
	aleph302_8:1.2
	aleph302_7:1.2
	aleph302_6:1.2
	aleph302_5:1.2
	aleph302_4:1.2
	aleph302_3:1.2
	aleph302_2:1.2
	aleph302_1:1.2
	aleph302:1.2
	aleph216:1.2
	aleph215_3:1.2
	aleph215_2:1.2
	aleph215:1.2
	aleph214:1.2
	aleph213:1.2
	c300:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	96.05.03.15.19.59;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	96.04.23.15.22.39;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.04.23.15.22.40;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@replace flag C by ALEPH_C
Modified Files:
  c/ 	lpkit.c vgbslv.c vldlps.c
@
text
@#if defined(ALEPH_C)

#include "vgbran.h"

lprec *vldlps(int ntrk, const int nhits[NHITDIM], 
	      const int nUseHit[][NHITDIM],
	      int npat, const struct VGBPAT *pat )
{
   lprec *Mlp;
   int l, i, ipat;
   REAL *colArr;
   int hit, offset, h1, h2;
   
   Mlp = make_lp(0, 0);

   /* objective function row; nothing to do */

   /* track constraints */
   for (i=0 ; i<ntrk; i++)
   {
      str_add_constraint(Mlp, "", EQ, 1.0);
   }
   
   /* hit constraints */
   for (l=0; l<NHITDIM; l++)
   {
      for (i = 0; i<nhits[l]; i++)
      {
	 if (nUseHit[i][l] == 1) 
	 {
	    /* hit used only once */
	    str_add_constraint(Mlp, "", EQ, 1.0);
	 }
	 else
	 {
	    /* hit used 1 or 2 times */
	    str_add_constraint(Mlp, "", GE, 1.0);
	    Mlp->orig_upbo[Mlp->rows] = 1.0;
	 }
      }
   }
   
   /* rows are done. now, columns (ie. patterns) */
   
   /* lp_solve has rows numbered 0..Mpl->rows */
   colArr = (REAL *) malloc((Mlp->rows+1)*sizeof(REAL));
   if (colArr == NULL) 
   {
      free(Mlp);
      return NULL;
   }
   
   /* generate 1 row per hit, allowing the hit to be assigned to trk 0 with */
   /* no penalty */
   for (i=0; i<=Mlp->rows; i++) colArr[i] = 0.0;
   offset = ntrk+1;
   for (l=0; l<NHITDIM; l++)
   {
      for (i=0; i<nhits[l]; i++)
      {
	 colArr[offset] = 1.0;
	 /* store the column */
	 add_column(Mlp, colArr);
	 
	 /* set bounds */
	 set_upbo(Mlp, Mlp->columns, 1.0);
	 set_int(Mlp, Mlp->columns, 1);
	 
	 colArr[offset] = 0.0;
	 offset++;
      }
   }
   
   for (ipat=0; ipat<npat; ipat++)
   {
      /* objective */
      colArr[0] = pat[ipat].obj;

      /* clear out track and hit number columns */
      for (i=1; i<=Mlp->rows; i++) colArr[i] = 0.0;
	 
      /* track number */
      if (pat[ipat].trk > 0) colArr[pat[ipat].trk] = 1.0;
	 
      /* hits */
      offset = ntrk;
      for (l=0; l<NHITDIM; l++)
      {
	 hit = pat[ipat].hit[l];
	 if (hit > 0) 
	 {
	    if (hit <= nhits[l])
	       colArr[offset + hit] = 1.0;
	    else 
	    {
	       /* this is a overlap ("greek") hit. the real hit numbers
		  are packed into one integer like h1*GRKSCF + h2 */
	       h1 = hit / GRKSCF;
	       h2 = hit - h1 * GRKSCF;
	       colArr[offset + h1] = 1.0;
	       colArr[offset + h2] = 1.0;
	    }
	 }
	 offset += nhits[l];
      }
	 
      /* store the column */
      add_column(Mlp, colArr);

      /* set bounds */
      set_upbo(Mlp, Mlp->columns, 1.0);
      set_int(Mlp, Mlp->columns, 1);
   }

   free(colArr);
   return Mlp;
}

#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#if defined(C)
@


1.1.1.1
log
@move c300 to alephlib/c
@
text
@@
