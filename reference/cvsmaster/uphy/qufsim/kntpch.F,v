head	1.2;
access;
symbols
	uphy1-0:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.2
date	98.06.13.16.52.06;	author janot;	state Exp;
branches;
next	1.1;

1.1
date	96.08.16.13.38.15;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.16.13.38.16;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update
@
text
@      INTEGER FUNCTION kntpch(xve1,xve2,pin,helix,xc,qqq,ier)
C------------------------------------------------------------------
C!  Determine the number of hits of a track in the TPC
C   (1 hit <==> Delta R = 6.00 cm)
C
C   Inputs : -- xve1 (3) : origin of the track
C            -- xve2 (3) : end    of the track, if any
C            -- pin  (3) : momentum at the origin
C            -- helix(6) : parameter of the helix
C            -- xc   (2) : center of the circle
C            -- qqq      : particle charge
C
C   Output : -- kntpch   : # of hits
C            -- ier      : error code
C                          = 0 : OK
C                          = 1 : The track begins outside the TPC
C                          = 2 : The track never enters the TPC
C
C  Patrick Janot -- 27 Oct 1993
C
C  Modified: Marumi kado -- 13 mai 1998 correction for TPC
C                                       sectors
C
C------------------------------------------------------------------
#include "parcut.h"
#include "resolu.h"
      PARAMETER ( delta = 6.00, dead = 4.00)
      DIMENSION xve1(3), xve2(3), pin(3), helix(6), xc(2)
      DIMENSION pin1(7), pout1(6), pout2(6), vect(3), cc(3), xx(3)
      DIMENSION pout(6)
      LOGICAL first
      DATA first/.TRUE./
C


      IF ( first ) THEN
        rdim6 = rdime(6) + 7.50
        rdim7 = rdime(7) - 9.00
        pi = 4.*ATAN(1.)
        first = .FALSE.
      ENDIF
C
      amom = SQRT(pin(1)**2+pin(2)**2+pin(3)**2)
      DO 1 i = 1, 3
      vect(i)   = pin(i)/amom
      pin1(i)   = xve1(i)
    1 pin1(i+3) = vect(i)
      pin1(7)   = amom
C
      ier = 0
      kntpch  = 0
      CALL vzero(pout1(1),6)
      CALL vzero(pout2(1),6)
C
C It is already outside the TPC
C
      IF ( SQRT(xve1(1)**2+xve1(2)**2) .GE. rdim7 .OR.
     .     ABS(xve1(3))                .GE. zdime(7) ) THEN
        ier = 1
        IF ( idbg .GE. 10 )
     .  WRITE(6,*) 'Track begins outside the TPC'
        GOTO 999
      ENDIF
C
C It never enters the TPC
C
      IF ( SQRT(xve1(1)**2+xve1(2)**2) .LT. rdim6 ) THEN
C       CALL auhcyl(rdim6,zdime(6),bfield,qqq, pin1,pout1,icode)
        IF ( pin1(6) .EQ. 0. ) pin1(6) = 1E-5
        CALL auhcyl(rdim6,zdime(6),bfield*ABS(qqq),qqq/ABS(qqq),
     .              pin1,pout1,icode)
        IF ( icode .EQ. 0 .OR. icode .EQ. 2 ) THEN
          ier = 2
          IF ( idbg .GE. 10 )
     .    WRITE(6,*) 'Track never enters the TPC'
          GOTO 999
        ENDIF
      ELSE
        CALL ucopy(pin1(1),pout1(1),6)
      ENDIF
      radin  = SQRT( pout1(1)**2 + pout1(2)**2 )
      zedin  = ABS(pout1(3))
C
C Else, extrapolate up to the end of the TPC
C
C     CALL auhcyl(rdim7,zdime(7),bfield,qqq, pin1,pout2,jcode)
      IF ( pin1(6) .EQ. 0. ) pin1(6) = 1E-5
      CALL auhcyl(rdim7,zdime(7),bfield*ABS(qqq),qqq/ABS(qqq),
     .            pin1,pout2,jcode)
      radout = SQRT( pout2(1)**2 + pout2(2)**2 )
      zedout = ABS(pout2(3))
      IF ( idbg .GE. 10 ) THEN
        WRITE(6,*) 'Extrapolation code : ',jcode
        WRITE(6,*) 'In  : ',pin1
        WRITE(6,*) 'Out : ',pout2
        WRITE(6,*) 'r/z in  : ',radin,zedin
        WRITE(6,*) 'r/z out : ',radout,zedout
      ENDIF
C
C Make only half a turn if it exits the TPC via the caps or if
C AUHCYL gave up.
C
      IF ( jcode .EQ. 2 .OR. jcode .EQ. 0 ) THEN
        cphi = ( xc(1)*(pout1(1)-xc(1))
     .         + xc(2)*(pout1(2)-xc(2)) )
     .       / SQRT ( xc(1)**2 + xc(2)**2 )
     .       / SQRT ((pout1(1)-xc(1))**2 + (pout1(2)-xc(2))**2)
        IF ( cphi .GE.  1.0 ) cphi =  0.99999999
        IF ( cphi .LE. -1.0 ) cphi = -0.99999999
        phi = ACOS(cphi)
        demira = SQRT(xc(1)**2+xc(2)**2) + 1./ABS(helix(1))
        demizd = xve1(3) + phi*helix(2)/ABS(helix(1))
        IF (     demira  .LT. rdim7 .AND.
     .       ABS(demizd) .LT. zdime(7))  THEN
          radout = demira
          zedout = ABS(demizd)
          IF ( idbg .GE. 10 ) THEN
            WRITE(6,*) 'After only half a turn : '
            WRITE(6,*) 'r/z : ',radout,zedout
          ENDIF
        ENDIF
      ENDIF
C
C Compute the radial length of the trajectory
C
      rad2 = SQRT(xve2(1)**2+xve2(2)**2)
      IF ( rad2 .LE. radout ) radout = rad2
      rlength = AMAX1(radout-radin, 0.)
      IF ( idbg .GE. 10 ) WRITE(6,*) 'Trajectory length : ',rlength
C
C And the number of hits !
C
      kntpch  = NINT(rlength/delta)
      IF ( idbg .GE. 10 ) THEN
        WRITE(6,*) 'radin,radout,rlength : ',radin,radout,rlength
        WRITE(6,*) 'kntpch               : ',kntpch
      ENDIF
      IF ( kntpch  .EQ. 0 ) GOTO 999
C
C Remove hits between inner and outer sectors, if any
C
      IF ( radin  .LT. rdim6+10.*delta .AND.
     .     radout .GT. rdim6+ 9.*delta ) THEN
            kntpch = kntpch-1
          ENDIF
      IF ( idbg .GE. 10 ) THEN
        WRITE(6,*) 'kntpch inner/outer   : ',kntpch
      ENDIF
      IF ( kntpch  .EQ. 0 ) GOTO 999
C
C Are we in the TPC crack ?
C
      ncr = 0
      DO ihit = 1 , kntpch
        rad = radin + (FLOAT(ihit)-.5)*delta
        zed = zdime(7)
        CALL vzero(pout(1),6)
        CALL auhcyl(rad,zed,bfield*ABS(qqq),qqq/ABS(qqq),
     .              pin1,pout,icode)
        proeff = TANH(ACOS(ABS(pout(6)))*180./pi/10.)
        IF ( icode .NE. 1 ) THEN                      ! Bug in AUHCYL
          ncr = ncr + 1
C        ELSEIF ( RNDM(ihit) .GT. 0.96*proeff ) THEN   ! Inefficiency
        ELSEIF ( RNDM(ihit) .GT. 0.973*proeff ) THEN   ! Inefficiency
          ncr = ncr + 1
        ELSE                                          ! TPC cracks
          delphi = 0.4*dead/rad*180./pi
          phi = ATAN2(pout(2),pout(1))*180./pi
          IF ( phi .LT. 0. ) phi = 360. + phi
          IF ( rad .LT. rdim6+9.*delta ) THEN
            phi = AMOD(phi,60.)
            IF (ABS(AMIN1(phi,60.-phi)).LT. delphi ) THEN
              ncr=ncr+1
            ENDIF
          ELSEIF ( rad .GT. rdim6+10.*delta ) THEN
            IF ( rad .LT. rdim6+18.*delta ) THEN
              phi = AMOD(phi-15.,30.)
              IF ( ABS(AMIN1(phi,30.-phi)) .LT. delphi ) THEN
                ncr = ncr + 1 
              ENDIF
            ELSE
              ph1 = AMOD(phi-17.,60.)
              ph2 = AMOD(phi-43.,60.)
              IF ( ABS(AMIN1(ph1,60.-ph1)) .LT. delphi ) THEN
                ncr = ncr + 1
              ENDIF
              IF ( ABS(AMIN1(ph2,60.-ph2)) .LT. delphi ) THEN
                ncr = ncr + 1
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDDO
C

C
      kntpch = kntpch - ncr
      IF ( idbg .GE. 10 ) THEN
        WRITE(6,*) 'kntpch crack/effic.  : ',kntpch
      ENDIF
      IF ( kntpch  .LE. 0 ) GOTO 999
C
C Last, but not least, account for a low angle mask (e+e- 500 GeV)
C
      tantpc = TAN(tpcacc*pi/180.)
C
      IF ( ABS(radin /zedin ) .GT. tantpc .AND.
     .     ABS(radout/zedout) .GT. tantpc ) GOTO 999
C
      IF ( ABS(radin /zedin ) .LE. tantpc .AND.
     .     ABS(radout/zedout) .LE. tantpc ) THEN
        kntpch  = 0
        GOTO 999
      ENDIF
C
      zint = (radin - zedin * (radin-radout)/(zedin-zedout))
     .     / (tantpc        - (radin-radout)/(zedin-zedout))
      rint = zint * tantpc
C
      IF     ( ABS(radin /zedin ) .LE. tantpc ) THEN
        fracout = ABS((radout-rint)/(radout-radin))
      ELSEIF ( ABS(radout/zedout) .LE. tantpc ) THEN
        fracout = ABS((radin-rint)/(radout-radin))
      ELSE
        fracout = 1.
        WRITE(6,*) 'Arghhh ! qu''est-ce-c''est qu''c''te merdier ?'
C        WRITE(*,*) 'Arghhh ! qu''est-ce-c''est qu''c''te merdier ?'
      ENDIF

      kntpch  = NINT(fracout * FLOAT(kntpch))
C
  999 RETURN
      END
@


1.1
log
@Initial revision
@
text
@a17 1

d20 4
d34 2
d114 1
a114 1
     .       ABS(demizd) .LT. zdime(7)       )  THEN
d143 3
a145 1
     .     radout .GT. rdim6+ 9.*delta ) kntpch = kntpch - 1
d163 2
a164 1
        ELSEIF ( RNDM(ihit) .GT. 0.96*proeff ) THEN   ! Inefficiency
d167 1
a167 1
          delphi = 0.5*dead/rad*180./pi
d172 3
a174 1
            IF ( AMIN1(phi,60.-phi) .LT. delphi ) ncr = ncr + 1
d178 3
a180 1
              IF ( AMIN1(phi,30.-phi) .LT. delphi ) ncr = ncr + 1
d184 6
a189 2
              IF ( AMIN1(ph1,60.-ph1) .LT. delphi ) ncr = ncr + 1
              IF ( AMIN1(ph2,60.-ph2) .LT. delphi ) ncr = ncr + 1
d195 2
d227 1
d229 1
a229 1
C
@


1.1.1.1
log
@2nd try to import uphy
@
text
@@
