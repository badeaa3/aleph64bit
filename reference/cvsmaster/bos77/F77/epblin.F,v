head	1.4;
access;
symbols
	bos3489-1:1.3.0.2
	bos3589:1.4
	bos3489:1.3
	bos3389:1.3
	bos3289:1.3
	bos3189:1.3
	bos3089:1.2
	v3089:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.4
date	97.01.29.15.48.59;	author flr;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.14.54.58;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	96.03.11.12.52.47;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.13.58.42;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.13.58.43;	author flr;	state Exp;
branches;
next	;


desc
@@


1.4
log
@release bos3589: new epio routines
@
text
@      SUBROUTINE EPBLIN(IBUF,IERR)
*
* epiocom.inc
*
      COMMON/EPCOMM/NMUNIT,NWUNIT,NCONT,ISTART,LASTUT,LREF,LIST(350)
      EQUIVALENCE (NOUTUT,LIST(8))
*
      DIMENSION ILBHD(16)
*
* wordsize.inc
*
C    number of bits/word
      INTEGER NBITPW, NCHAPW, NBITPC, N16PW
      PARAMETER   (NBITPW=32, NCHAPW=4, NBITPC=8, N16PW=2)
*
      DIMENSION IBUF(1)

      LUN=LIST(ISTART+10)
C--SET NP (PHYS BLOCK LENGTH) = 0  AND NEW FORMAT INDICATOR
      LIST(ISTART+14)=0
      IERR=0
*
      IF(LIST(ISTART+16).EQ.0) CALL EPOPEN(2,IERR)
      if(IERR.ne.0)goto 20
*
      LIST(ISTART+16)=2
      IF(LIST(ISTART+17).LT.2)LIST(ISTART+17)=0
      MAXWDS=LIST(ISTART+1)
      MAXWDS=MAXWDS/N16PW
*
      IF(LIST(ISTART+33).EQ.2)THEN
        NWDONE=MAXWDS
        IF(LIST(ISTART+32).EQ.1)  THEN
          call cfseek(list(istart+25),0,MAXWDS,LIST(ISTART+11),ISTAT)
          IF(ISTAT.NE.0)goto 45
        ENDIF
        call cfget(list(istart+25),0,MAXWDS,NWDONE,IBUF,ISTAT)
        if(ISTAT.eq.-1)goto 20
        if(ISTAT.ne.0 )goto 40
*
      ELSE IF(LIST(ISTART+33).EQ.1)THEN
C In random mode hitting EOF is return as an error.
C As disk errors are rare, assume they are End of File
        READ(LUN,ERR=20,IOSTAT=IOSEOF,REC=LIST(ISTART+11)+1)
     1       (IBUF(IWRD),IWRD=1,MAXWDS)
        IF (IOSEOF.EQ.-1) GOTO 20
*
      ELSE
        READ(LUN,ERR=40,END=20)(IBUF(IWRD),IWRD=1,MAXWDS)
      ENDIF
*
      NB=MAXWDS*N16PW*2
      GOTO 50
*
C--EOF or OPEN ERROR, CANNOT FIND FILE
 20   IF(LIST(ISTART+19) .EQ. 1)GOTO 30
      LIST(ISTART+19)=1
      IERR=1
      GOTO 9999
C EOI
 30   IERR=3
      GOTO 9999
C PARITY
 40   LIST(ISTART+13)=LIST(ISTART+13)+1
      IERR=2
      GOTO 9999
C Error from cfseek
 45   IERR=25
      GOTO 9999
C GOOD BLOCK
 50   LIST(ISTART+11)=LIST(ISTART+11) +1
C RESET EOF FLAG
      LIST(ISTART+19)=0
C--UPDATE FILE ADDRESS IF DISK. WE ASSUME F-FORMAT WITH 28 WORDS/SECTOR
      IF(LIST(ISTART+18) .EQ. 0)GOTO 70
C--HEADERLESS BLOCK
C--- IF CONTROL WORD 27 SET, SWAP BYTES IF DONE IN PREVIOUS BLOCK
      IF(LIST(ISTART+28).NE.0)  CALL BTSWAP(IBUF,NB)
      LIST(ISTART+7)=0
      LIST(ISTART+15)=0
      LIST(ISTART+18)=LIST(ISTART+18) - 1
      LIST(ISTART+14)=NB/2
      GOTO 77777
C--BLOCK WITH HEADER
 70   CONTINUE
*--- could be 32 bit header - blow 16 16-bit words to check
      CALL BLO16W(IBUF,1,ILBHD,1,16)
*--- make sure it is not 16-bit
         LIST(ISTART+28)=0
         LIST(ISTART+29)=0
         IF(LIST(ISTART+27).EQ.0)  GOTO 72
         IF(ILBHD(7).EQ.29954.AND.ILBHD(8).EQ.31280)  GOTO 72
*---    or byte swapped 16-bit
         IF(ILBHD(7).EQ.  629.AND.ILBHD(8).EQ.12410)  GOTO 71
*--- check for 32 bit - control words 7 and 8 (identical)
*     first number is 7967 = 1F1F hex and therefore invariant under
*     byte swapping, second is 19132 = 4ABC hex and is used to byte swap
      IF(ILBHD(13).EQ.7967.AND.ILBHD(15).EQ.7967)  THEN
*---  32 bit header - byte swap ?
         IF(ILBHD(14).NE.19132)  THEN
            CALL BTSWAP(IBUF,NB)
            CALL BLO16W(IBUF,1,ILBHD,1,16)
            LIST(ISTART+28)=1
         ENDIF
         IF(ILBHD(14).NE.19132.OR.ILBHD(16).NE.19132)  THEN
*--- looks like 32 bit, but is not
            IERR=22
            GOTO 9999
         ENDIF
*--- definitly 32 bit physical header
         CALL BLO32W(IBUF,1,ILBHD,1,12)
         CALL CFRIBM(ILBHD,12,2)
*--- set 32 bit ph. header
         LIST(ISTART+29)=1
         NP=ILBHD(1)
         IF(NP.LE.0) GOTO 9901
         IF(NP .GT. LIST(ISTART+1).OR.NP.GT.NB/2) GOTO 9902
         NPHL=ILBHD(2)
         IF(NPHL.LT.LIST(6).OR.NPHL.GT.NP)  THEN
            IERR=7
            GOTO 9999
         ENDIF
      ENDIF
      IF(LIST(ISTART+29).EQ.1)GOTO 150
*--- 16 bit physical header
C--- SWAP BYTES IF CONTROL WORD 27 SET, AND IF 16-BIT WORDS 7 AND 8
C    IN THE BLOCK HEADER ARE WRONG FOR EP FORMAT.
   71    CONTINUE
         CALL BTSWAP(IBUF,NB)
         CALL BLO16W(IBUF,1,ILBHD,1,12)
         LIST(ISTART+28)=1
   72    CONTINUE
         NP=ILBHD(1)
         IF(NP.LE.0) GOTO 9901
         IF(NP .GT. LIST(ISTART+1).OR.NP.GT.NB/2) GOTO 9902
         NPHL=ILBHD(2)
         IF (NPHL. LT. LIST(6) .OR. NPHL .GT. NP
     1   .OR. (ILBHD(7).NE.29954) .OR. (ILBHD(8).NE.31280))
     2   GO TO 110
*--- set 16 bit header
         LIST(ISTART+29)=0
         GO TO 150
 110     CONTINUE
         IF(LIST(ISTART+27).LT.2)GOTO 120
         IERR=7
         GOTO 9999
C--OLD FORMAT
 120     IF (NPHL .LT.5 .OR. NPHL.GT.NP)IERR=7
         IF (IERR .NE.0) GOTO 9999
         LIST(ISTART+17) =1
         LIST(ISTART+3)=16
C--WE HAVE A GOOD HEADER - 16 bit or 32 bit (ILBHD(6) = 0 or 1)
  150 CONTINUE
      IF(LIST(ISTART+17).EQ.1)  GOTO 160
      LIST(ISTART+3)=ILBHD(11)
      LIST(ISTART+9)=ILBHD(6)
      LIST(ISTART+18)=ILBHD(9)
  160 CONTINUE
      LIST(ISTART+14)=NP
      LIST(ISTART+15)=ILBHD(4)
      LIST(ISTART+7)=NPHL
      LIST(ISTART+4)=ILBHD(5)
77777 RETURN
 9901 CONTINUE
C--- BLOCK LENGTH (IBUF(1)) LE 0 - PROBABLY NOT EP FORMAT
      IERR=4
      GOTO 9999
 9902 CONTINUE
C--- IBUF(1) GT REAL PRL OR UNIT BUFFER TOO SMALL
      IERR=5
 9999 CONTINUE
      LIST(ISTART+14)=0
      GOTO 77777
      END




































































































@


1.3
log
@replace ${VENDOR} by ALEPH_${VENDOR}
Modified Files:
  F77/ 	blo32w.F cfribm.F ctoibm.F epblin.F epdacr.F epdefu.F ephead.F
 	epinit.F epopen.F
@
text
@a0 1
#if defined(ALEPH_DEC) &&  ! defined(UNIX)
d2 3
a4 2
CD    COMMON/EPDBGC/DBUGFL
CD    LOGICAL DBUGFL
d7 1
d9 4
d15 1
a15 1
CSELF,IF=CDC,IBM,UNIVAC,NORD,CRAY,CONVEX,STF77,STF77VX.
d17 1
a17 2
CD    LABEL=1001
CD    IF(DBUGFL)  PRINT*,LABEL,ISTART
d21 2
d24 2
a25 1
      IF(IERR.ne.0) GOTO 20
d30 12
a41 1
      IF(LIST(ISTART+33).EQ.1)THEN
d44 4
a47 1
       READ(LUN,ERR=20,REC=LIST(ISTART+11)+1)(IBUF(IWRD),IWRD=1,MAXWDS)
d49 1
a49 1
       READ(LUN,ERR=40,END=20)(IBUF(IWRD),IWRD=1,MAXWDS)
d51 1
d54 2
a55 1
C--EOF
d58 1
a58 2
C--OPEN ERROR, CANNOT FIND FILE
 25   IERR=1
d67 3
a71 2
CD    LABEL=1050
CD    IF(DBUGFL)PRINT*,LABEL,ISTART,(LIST(ISTART+JJJ),JJJ=11,22)
d74 1
a133 2
CD    LABEL=1070
CD    IF(DBUGFL)PRINT*,LABEL,ISTART,(LIST(ISTART+JJJ),JJJ=11,22)
d175 100
a274 1
#endif
@


1.2
log
@import new version made for cvs on alws.
add eprwnd.F to test the descriptor before calling CFREW. Should be included
into the EPIO next release.
 Added Files:
 	eprwnd.F
@
text
@d1 1
a1 1
#if defined(DEC) &&  ! defined(UNIX)
@


1.1
log
@Initial revision
@
text
@a0 1
*DK epblin
@


1.1.1.1
log
@import bos77 3089
@
text
@@
