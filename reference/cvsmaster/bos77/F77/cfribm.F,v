head	1.3;
access;
symbols
	bos3489-1:1.3.0.2
	bos3589:1.3
	bos3489:1.3
	bos3389:1.3
	bos3289:1.3
	bos3189:1.3
	bos3089:1.2
	v3089:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.3
date	96.05.03.14.54.55;	author flr;	state Exp;
branches;
next	1.2;

1.2
date	96.03.11.12.50.07;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.13.58.43;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.13.58.44;	author flr;	state Exp;
branches;
next	;


desc
@@


1.3
log
@replace ${VENDOR} by ALEPH_${VENDOR}
Modified Files:
  F77/ 	blo32w.F cfribm.F ctoibm.F epblin.F epdacr.F epdefu.F ephead.F
 	epinit.F epopen.F
@
text
@#if defined(UNIX) && defined(ALEPH_DEC)
      SUBROUTINE CFRIBM(IARRAY,NW,MODE)
C -----------------------------------------------------------
CLatB. private version
C -----------------------------------------------------------
C      ++++++++ STANDARD FORTRAN VERSION +++++++++++
C              The numbers must be right adj., zero filled.
C              MODE = 1 : convert 16-bit integers
C                   = 2 : convert 32-bit integers (Dummy)
C                   = 3 : convert 32-bit floating
      DIMENSION IARRAY(*)
C     PARAMETER (IBIG=16#7FFF FFFF,ISMA=16#0080 0000)
      PARAMETER (IBIG=2147483647,ISMA=8388608)
CLatB
      integer*2 sw0(2), sw1(2)
      integer lw0, lw1
      equivalence (sw0,lw0)
      equivalence (sw1,lw1)
C
      IF(NW.LE.0)   GO TO 999
      IF(MODE.EQ.1) THEN
C
C                16-bit integers
C
        DO 110,I=1,NW
          IARRAY(I) = IAND(IARRAY(I),65535)
 110    CONTINUE
      ELSEIF(MODE.EQ.2) THEN
C
C                32-bit integers (word swap)
C
         do 120 i=1, nw
             lw0 = iarray(i)
             sw1(2) = sw0(1)
             sw1(1) = sw0(2)
             iarray(i) = lw1
 120     continue

      ELSE IF(MODE.EQ.3) THEN
C
C                Convert the first NW words of IARRAY from
C                IBM 32-bit floating point representation to
C                IEEE single-precision (32-bit) floating point
C                representation
         do 130 i=1, nw
             lw0 = iarray(i)
             sw1(2) = sw0(1)
             sw1(1) = sw0(2)
             iarray(i) = lw1
 130     continue
        DO 2 J=1,NW
C
C                Check for exact 0
           IF(IARRAY(J).EQ.0) GO TO 2
C
C              Make sure ILEFT gets defined to something!
           ILEFT = 0
C
C                Get exponent
           IEXPO  = ISHFT(ISHFT(IARRAY(J),1),-25)
           IF(BTEST(IARRAY(J),23)) THEN
              ILEFT = 0
           ELSEIF(BTEST(IARRAY(J),22)) THEN
              ILEFT = 1
           ELSEIF(BTEST(IARRAY(J),21)) THEN
              ILEFT = 2
           ELSEIF(BTEST(IARRAY(J),20)) THEN
              ILEFT = 3
           END IF
           IEXPO = IEXPO * 4 - ILEFT - 130
           IF(IEXPO.LE.0) THEN
              IDUMMY = ISMA
              GO TO 1
           ELSEIF(IEXPO.GT.255) THEN
              IDUMMY = IBIG
              GO TO 1
           END IF
           IDUMMY = ISHFT(IARRAY(J),ILEFT)
           IDUMMY = IOR(IAND(IDUMMY,2**23-1),ISHFT(IEXPO,23))
   1       IF(BTEST(IARRAY(J),31)) IDUMMY = IBSET(IDUMMY,31)
           IARRAY(J) = IDUMMY
   2    CONTINUE
      END IF
C
 999  continue
      END
#endif
@


1.2
log
@import new version made for cvs on alws.
add eprwnd.F to test the descriptor before calling CFREW. Should be included
into the EPIO next release.
 Added Files:
 	eprwnd.F
@
text
@d1 1
a1 1
#if defined(UNIX) && defined(DEC)
@


1.1
log
@Initial revision
@
text
@a0 1
*DK cfribm
@


1.1.1.1
log
@import bos77 3089
@
text
@@
