head	1.2;
access;
symbols
	bos3489-1:1.2.0.2
	bos3589:1.2
	bos3489:1.2
	bos3389:1.2
	bos3289:1.2
	bos3189:1.2
	bos3089:1.2
	v3089:1.1.1.1
	flr:1.1.1;
locks; strict;
comment	@c @;


1.2
date	96.03.11.12.52.38;	author flr;	state Exp;
branches;
next	1.1;

1.1
date	94.12.07.13.58.27;	author flr;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	94.12.07.13.58.28;	author flr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@import new version made for cvs on alws.
add eprwnd.F to test the descriptor before calling CFREW. Should be included
into the EPIO next release.
 Added Files:
 	eprwnd.F
@
text
@      SUBROUTINE DARES

*     RESERVE UNIT LUNDA

*     USED SUBROUTINE: DELAY(N)
*                      MAKES A WAIT FOR N*1/100 SEC
*     PROGRAM CAN WORK WITHOUT THIS SUBROUTINE, ITS USE HOWEVER
*     DECREASES THE PROBABILITY FOR CONFLICT IN CASES, WHERE MORE THAN
*     ONE JOB MODIFIES THE DATA SET AT THE SAME TIME.
*     IN SUCH A CONFLICT ONE OF THE JOBS MAY NOT GET ACCESS TO THE DATA
*     SET AFTER 10 TRIALS AND WILL THEN STOP WITH ABEND
*     SOURCE PAM CONTAINS DUMMY SUBROUTINE DELAY

#include "dacom.h"
#include "param.h"
      COMMON/BCS/IW(1000)
      INTEGER IRECB(8),IRECM(8),IRECU(8)
      CHARACTER*4 CHAINT
      DATA    IRECB/8*0/,IRECM/8*0/
*
*     IRECB = BLANK RECORD
*     IRECM = WRITE RECORD
*     IRECU = READ RECORD
*
*     SKIP, IF EXCLUSIVE USE
      IF(IW(IUB+2).EQ.1) GOTO 65
      IDRR=0
      IDDR=0
      DO 02 M=1,8
      IRECM(M)=0
   02 IRECB(M)=0
      IRECM(1)=NADA
      IRECM(2)=NRDA
      CALL DATIME(IRECM(3),IRECM(4))
      CALL TIMEL(RSEC)

*     TIMEL CAN RETURN A TIME > 1 SEC, IF LESS THAN 0.01 SEC IS LEFT

      IRECM(5)=RSEC*1000.0
      IRECM(6)=IRECM(5)
      IF(RSEC.LT.2.0) THEN
         IF(IW(LUP).GT.0) WRITE(IW(LUP),104) LUNDA,CHAINT(IRECM(1)),
     +   (IRECM(M),M=2,8)
         CALL BABEND('DARES')
      END IF

      ITRY=0

   10 ISTA=1
      READ (UNIT=LUNDA,REC=1,ERR=99) IRECU
      IW(IUB+4)=IW(IUB+4)+1
      GOTO 70

   20 ISTA=2
      WRITE(UNIT=LUNDA,REC=1,ERR=99) IRECM
      READ (UNIT=LUNDA,REC=2,ERR=99) IRECU
      IW(IUB+4)=IW(IUB+4)+1
      IW(IUB+6)=IW(IUB+6)+1
      GOTO 70

   30 ISTA=3
      WRITE(UNIT=LUNDA,REC=2,ERR=99) IRECM
      READ (UNIT=LUNDA,REC=1,ERR=99) IRECU
      IW(IUB+4)=IW(IUB+4)+1
      IW(IUB+6)=IW(IUB+6)+1
      GOTO 70

   40 ISTA=4
      READ (UNIT=LUNDA,REC=2,ERR=99) IRECU
      IW(IUB+4)=IW(IUB+4)+1
      GOTO 70

   50 WRITE(UNIT=LUNDA,REC=1,ERR=99) IRECB
      IW(IUB+6)=IW(IUB+6)+1

*     DATA SET IS RESERVED
   60 ITRY=ITRY+1
#include "unlock.h"
      IF(ITRY.GT.10) GOTO 90
*     WAIT QUASI RANDOM TIME
      CALL DELAYP(100+100*MOD(ITRY*ITRY,10))
*     TEST FOR SOME TIME INTERVAL STATUS OF DATA SET
      DO 64 JL=1,3
      DO 61 I=3,1,-1
   61 READ(UNIT=LUNDA,REC=I,ERR=99) IRECU
      IW(IUB+4)=IW(IUB+4)+3
      DO 62 I=1,8
      IF(IRECU(I).NE.0) GOTO 64
   62 CONTINUE
      GOTO 10
   64 CONTINUE
      GOTO 10

   65 IDATE=IW(IUB+17)
      READ(UNIT=LUNDA,REC=3,ERR=99) (IW(IUB+10+I),I=1,8)
#include "unlock.h"
      IDRR=0
      IDDR=0
*     COPY RECORD CONTENT TO IRECB
      DO 66 I=1,8
   66 IRECB(I)=IW(IUB+10+I)
      IW(IUB+17)=IDATE
      IW(IUB+4)=IW(IUB+4)+1
      GOTO 100

   70 DO 75 I=1,8
      IF(IRECU(I).NE.0) GOTO 80
   75 CONTINUE
      GOTO (20,30,60,60),ISTA

   80 DO 85 I=1,8
      IF(IRECU(I).EQ.IRECM(I)) GOTO 85
*     DIFFERENT JOB, COMPARE TIME
      MIND=(IRECM(4)/100-IRECU(4)/100)*60+
     +     MOD(IRECM(4),100)-MOD(IRECU(4),100)
      IF(IRECM(3).NE.IRECU(3)) MIND=MIND+1440
      IF(ITRY.EQ.0.AND.IW(LUP).GT.0) THEN
         WRITE(IW(LUP),101) LUNDA,MIND
         WRITE(IW(LUP),102) CHAINT(IRECM(1)),(IRECM(M),M=2,8)
         WRITE(IW(LUP),102) CHAINT(IRECU(1)),(IRECU(M),M=2,8)
      END IF
      IF(MIND.GT.60.AND.ISTA.LE.2) THEN
         WRITE(UNIT=LUNDA,REC=ISTA) IRECB
         IW(IUB+4)=IW(IUB+4)+1
         IF(IW(LUP).GT.0) WRITE(IW(LUP),103)
      END IF
      GOTO 60
   85 CONTINUE
      GOTO (50,30,40,65),ISTA

   90 CALL BABEND('DARES')
   99 CALL BABEND('DARES')

      ENTRY DADES

*     FREE DATA SET

*     WRITE IF RECORD 3 MODIFIED
      DO 87 I=1,8
      IF(IW(IUB+10+I).NE.IRECB(I)) GOTO 88
   87 CONTINUE
      GOTO 89
   88 WRITE(UNIT=LUNDA,REC=3) (IW(IUB+10+I),I=1,8)
   89 IW(IUB+6)=IW(IUB+6)+1
      IF(IW(IUB+2).EQ.1) GOTO 100
      DO 84 M=1,8
   84 IRECB(M)=0
      WRITE(UNIT=LUNDA,REC=1) IRECB
      WRITE(UNIT=LUNDA,REC=2) IRECB
      IW(IUB+6)=IW(IUB+6)+2

*     THREE READ OPERATIONS TO MAKE SURE THAT PREVIOUS WRITE OPERATIONS
*     ARE EXECUTED (AND NOT ONLY MADE IN BUFFER)

      READ (UNIT=LUNDA,REC=3) IRECU
      READ (UNIT=LUNDA,REC=1) IRECU
      READ (UNIT=LUNDA,REC=2) IRECU
      IW(IUB+4)=IW(IUB+4)+3

*     THREE MORE READ OPERATIONS TO MAKE SURE THAT THERE IS A PERIOD
*     IN REAL TIME, WHERE THE DATA SET IS FREE AND CAN BE USED BY
*     ANOTHER JOB

      READ (UNIT=LUNDA,REC=3) IRECU
      READ (UNIT=LUNDA,REC=1) IRECU
      READ (UNIT=LUNDA,REC=2) IRECU
      IW(IUB+4)=IW(IUB+4)+3
#include "unlock.h"
      CALL DELAYP(100)
      IF(ITRY.NE.0.AND.IW(LUP).GT.0) WRITE(IW(LUP),111) ITRY

  100 RETURN
  101 FORMAT('0---------- DATA SET',I3,' IS RESERVED SINCE ',
     +   'MORE THAN',I8,' MINUTES'/
     +   13X,'FOR MORE THAN 60 MINUTES RESERVATION WILL BE IGNORED')
  102 FORMAT(' ------ ',A4,3X,7I10)
  103 FORMAT('0DATA SET FORCED TO BE FREE')
  104 FORMAT('0---------- DA-UNIT',I3,' PROGRAM STOP BECAUSE LESS',
     + ' THAN 2 SECONDS TIME LEFT BEFORE MODIFICATION OF DATASET'/
     +  2X,A4,7I10)
  111 FORMAT(10X,'ITRY=',I3)
      END
@


1.1
log
@Initial revision
@
text
@a0 1
*DK dares
@


1.1.1.1
log
@import bos77 3089
@
text
@@
