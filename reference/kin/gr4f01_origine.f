************************************************************************
*    ====================================================              *
      SUBROUTINE BASES( FXN, S, SIGMA, CTIME, IT1, IT2 )
*    ====================================================              *
*      Subroutine BASES for the Numerical integration.                 *
*      In terms of this program Integration can be done, furthermore   *
*      a probability distribution can be made for the event generation.*
*      The event with weight one is generated by program SPRING.       *
* ((Input))                                                            *
*    from the arguement                                                *
*      FXN    : Name of function program                               *
*    from the labeled common /BASE1/                                   *
*      XL(50) : Lower limits of the integration variabels              *
*      XU(50) : upper limits of the integration variabels              *
*      NDIM   : Dimension of the integration                           *
*      NCALL  : Number of sampling points per iteration                *
*    from the lebeled common /BASE2/                                   *
*      ITMX*  : Number of iteration                                    *
*      ACC*   : Required accuracies                                    *
* ((Output))                                                           *
*      S      : Estimate of the integral                               *
*      SIGMA  : Standard deviation of the estimate                     *
*      CTIME  : Computing time required for integration                *
*      IT1    : Number of iterations for the grid defining step        *
*      IT2    : Number of iterations for the integration step          *
C*                                                                     *
C*       Coded by S.Kawabata         April '94                         *
C*                                                                     *
C***********************************************************************
C
C
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL FXN
      PARAMETER (MXDIM = 100)
*
*     JFLAG =  0 : First trial for defining grids.
*     JFLAG =  1 : First trial for event accumulation.
*     JFLAG =  2 : Second or more trial for defining grids.
*     JFLAG =  3 : Second or more trial for accumulation.
*                                                                      *
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE2/ ACC1,ACC2,ITMX1,ITMX2
      REAL*4 STIME
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,ITG,ITF
      CHARACTER*80 ERROR
      COMMON /BWARN1/ NERROR
      COMMON /BWARN2/ ERROR(3,3)
*        INTV = ( 0 / 1 / any ) = ( Batch / Batch(Unix) / Interactive )
*        IPNT = ( 0 / any ) = ( IBM Type / Ascii printer )
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
       COMMON/NINFO/ NODEID, NUMNOD
       COMMON /BDATE/ IDATE(3),ITIME(2)
*            IDATE(1) : year        ITIME(1) : hour
*            IDATE(2) : month       ITIME(2) : minute
*            IDATE(3) : day
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
 
*-------------------------------------------------
*     Check the parameters defined by user
*------------------------------------------------------
 
      CALL BSCHCK
 
* ---------------------------------------------------------------
*          Initialize timer
* ---------------------------------------------------------------
 
       CALL BSDATE
 
       JFLAG  = 0
       LU     = 6
       IF( INTV .GT. 1 ) THEN
           CALL BSPRNT( LU, 1, IDUM1, IDUM2 )
       ENDIF
 
C  -----------------------------------------------------
C     Defining grids
C  -----------------------------------------------------
*
       DO 100 I = 1, NWILD
          IG(I) = 1
  100  CONTINUE
 
       CALL BSETGU
 
       IF( INTV .GT. 1 ) THEN
           CALL BSPRNT( LU, 4, IDUM1, IDUM2 )
       ENDIF
 
       CALL BSUTIM( 0, 2 )
 
*     ===================
       CALL BSINTG( FXN )
*     ===================        For a parallel computer
C                                      CALL BSCAST( JFLAG, 1 )
 
*  ----------------------------------------------------
*     Accumulation to make probability distribution
*  ----------------------------------------------------
*     ===================
       CALL BSINTG( FXN )
*     ===================        For a parallel computer
C                                      CALL BSCAST( JFLAG, 1 )
       S     = AVGI
       SIGMA = SD
       CTIME = STIME
       IT1   = ITG
       IT2   = ITF
 
       CALL BSUTIM( 0, 2 )
       TIMEB2 = RTIME
 
       IF( NERROR .GT. 0 ) THEN
           WRITE(6,9900)
 9900      FORMAT(1X,'****************************************',
     .               '***************************************',
     .           /1X,'* (((( Warning in the integration step ',
     .               '))))                                   *',
     .           /1X,'*                                      ',
     .               '                                       *')
           DO 990 J = 1,NERROR
           DO 990 I = 1,3
              WRITE(6,9901) ERROR(I,J)
 9901         FORMAT(1X,A79)
  990      CONTINUE
           WRITE(6,9902)
 9902      FORMAT(1X,'*                                      ',
     .               '                                       *',
     .           /1X,'*(( Suggestion ))                      ',
     .               '                                       *',
     .           /1X,'* (1) Try integration again with larger ',
     .               'number of sample points than this job.*',
     .           /1X,'* or                                   ',
     .               '                                       *',
     .           /1X,'* (2) The integral variables are not sui',
     .               'ted for the function.                 *',
     .           /1X,'*     Take another integral variables !!',
     .               '                                      *',
     .           /1X,'*                                       ',
     .               '                                      *',
     .           /1X,'****************************************',
     .               '***************************************')
       ENDIF
 
       IF( INTV .GT. 1 ) THEN
           CALL BSPRNT( LU, 2, IDUM1, IDUM2 )
       ENDIF
 
       RETURN
       END
************************************************************************
*     ==========================                                       *
       SUBROUTINE BHINIT( LUN )
*     ==========================                                       *
*                                                                      *
* ((Purpose))                                                          *
*    Initialization program for  histograms and scatter plots.         *
*    This program is called by USERIN.                                 *
* ((Arguments))                                                        *
*    LUN    : logical unit number for message print                    *
* !! Caution!!                                                         *
*    When LUN is set equal to 0, the message print is suppressed.      *
* (( Common /PLOTH/ ))                                                 *
*                                                                      *
*    NW                     : Total number of words of used buffer     *
*                                                                      *
*    NHIST                  : Number of Histograms                     *
*    NSCAT                  : Number of Scat_Plots                     *
*                                                                      *
*   -----------------                                                  *
*     Hashing Table                                                    *
*   -----------------                                                  *
*                                                                      *
*     XHASH(   1,i)      : NH Number of histograms for the i-th class  *
*     XHASH(   2,i) = K  : Serial number of histograms                 *
*              :                     :                                 *
*     XHASH(NH+1,i) = K  : Serial number of histograms                 *
*                     |                                                *
*              MAPL(1,K) = ID  : Histogram ID                          *
*              MAPL(2,K) = IP1 : the 1st pointer to the K-th buffer    *
*              MAPL(3,K) = IP2 : the 2nd pointer to the K-th buffer    *
*              MAPL(4,K) = IP3 : the 3rd pointer to the K-th buffer    *
*                                                                      *
* (( Common /PLOTB/ ))                                                 *
*                                                                      *
*   --------------------                                               *
*     Histogram buffer                                                 *
*   --------------------                                               *
*                                                                      *
*    IP1  = NW + 1                                                     *
*           NW = NW + 281    : Updated NW                              *
*       BUFF( IP1 )          = Xmin                                    *
*       BUFF( IP1 + 1 )      = Xmax                                    *
*       IBUF( IP1 + 2 )      = No. of bins                             *
*       BUFF( IP1 + 3 )      = Bin width                               *
*    IP2  = IP1 + 4                                                    *
*       IBUF(   IP2       )                                            *
*          => IBUF( +  51 )  = No. of sampling points                  *
*       BUFF(   IP2 +  52)                                             *
*          => BUFF( + 103 )  = Sum of Fi for the current IT            *
*       BUFF(   IP2 + 104)                                             *
*          => BUFF( + 155 )  = Sum of Fi**2 for the current IT         *
*       BUFF(   IP2 + 156)                                             *
*          => BUFF( + 207 )  = Sum of Fi for total                     *
*       BUFF(   IP2 + 208)                                             *
*          => BUFF( + 259 )  = Sum of Fi**2 for total                  *
*    IP3  = IP1 + 264                                                  *
*       IBUF( IP3 )          = Tag for spring                          *
*       IBUF( IP3   +  1 )                                             *
*          => IBUF( + 16 )   = Title of this histogram                 *
*                                                                      *
*   --------------------                                               *
*     Scat_Plot buffer                                                 *
*   --------------------                                               *
*                                                                      *
* IP1   = NW + 1                                                       *
*         NW  = NW + 2527                                              *
*       BUFF( IP1 )          = Xmin                                    *
*       BUFF( IP1 + 1 )      = Xmax                                    *
*       IBUF( IP1 + 2 )      = No. of bins for X                       *
*       BUFF( IP1 + 3 )      = Bin width for X                         *
*       BUFF( IP1 + 4 )      = Ymin                                    *
*       BUFF( IP1 + 5 )      = Ymax                                    *
*       IBUF( IP1 + 6 )      = No. of bins for Y                       *
*       BUFF( IP1 + 7 )      = Bin width for Y                         *
* IP2   = IP1 + 8                                                      *
*       BUFF(   IP2       )  = No. of sampling points                  *
*       BUFF(   IP2 +   1 )                                            *
*          => BUFF( +2500 )  = Sum of Fi                               *
* IP3   = IP1 + 2509                                                   *
*       IBUF( IP3 )          = X-Tag for spring                        *
*       IBUF( IP3   +  1 )   = Y-Tag for spring                        *
*       IBUF( IP3   +  2 )                                             *
*          => IBUF( + 17 )   = Title of this histogram                 *
*                                                                      *
*  ((Author))                                                          *
*    S.Kawabata    June '90 at KEK                                     *
*                                                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
 
      COMMON/PLOTLU/ LU
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
         LU   = LUN
 
         NW     = 0
 
         DO 50 I = 1, 13
           XHASH(1,I) = 0
           DHASH(1,I) = 0
   50    CONTINUE
         NHIST    = 0
         NSCAT    = 0
         DO 100 I = 1, NHS
           MAPL(1,I)= 0
  100    CONTINUE
         DO 200 I = 1, NSC
           MAPD(1,I)= 0
  200    CONTINUE
C
      RETURN
      END
************************************************************************
*     =========================                                        *
       SUBROUTINE BHPLOT( LU )
*     =========================                                        *
* ((Purpose))                                                          *
*     Interface routine to print histograms and scatter plots.         *
*     Routines XHPLOT and DHPLOT are called to print them.             *
* ((Author))                                                           *
*     S.Kawabata  June '90  at KEK                                     *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      REAL*8 AVGI,SD,CHI2A
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,ITG,ITF
*                                                                      *
*--------------------------- Entry point ------------------------------*
*
      IF( ITF .LE. 0 ) RETURN
*    ===================                                               *
      CALL XHCHCK( LU )
*    ===================
 
      IF( NHIST .LE. 0 ) THEN
         IF(LU.GT.0) WRITE(LU,9000)
 9000    FORMAT(1X,'No Histogram')
      ELSE
         DO 500 J = 1, NHIST
            IFBASE(J) = 1
*          =====================
            CALL XHPLOT(LU, 0, J )
*          =====================
  500    CONTINUE
      ENDIF
 
*    ===================
      CALL DHPLOT( LU )
*    ===================
 
      RETURN
      END
************************************************************************
*    ====================                                              *
      SUBROUTINE BHRSET
*    ====================                                              *
* ((Purpose))                                                          *
*     To reset contents of histograms and scatter plots.               *
* ((Author))                                                           *
*     S.Kawabata  June '90 at KEK                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
*-------------------------- Clear Histograms --------------------------*
*                                                                      *
         DO 200 J    = 1, NHIST
           IP2       = MAPL(3,J)
           DO 100 I  = IP2,IP2+259
             IBUF(I) = 0
  100      CONTINUE
           IFBASE(J) = 0
  200    CONTINUE
*                                                                      *
*-------------------------- Clear Scat. Plots -------------------------*
*                                                                      *
         DO 500  J   = 1, NSCAT
           IP2       = MAPD(3,J)
           DO 400  I = IP2,IP2+2500
             IBUF(I) = 0.0
  400      CONTINUE
  500    CONTINUE
*                                                                      *
      RETURN
      END
************************************************************************
*     ====================                                             *
       SUBROUTINE BHSAVE
*     ====================                                             *
* ((Purpose))                                                          *
*     To save contents of temporary buffers to the histogram buffers,  *
*     in order to avoid the precision problem.                         *
* ((Author))                                                           *
*     S.Kawabata  June '90 at KEK                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
      DO 200 J = 1, NHIST
         IP2   = MAPL(3,J)
         NC    = IBUF( MAPL(2,J)+2 ) + 1
         IB1   = IP2 + 52
         IB2   = IB1 + 52
         DO 100 I = 0,NC
            I1    = I + IB1
            I2    = I1 + 104
            BUFF(I2)  = BUFF(I2) + BUFF(I1)
            BUFF(I1)  = 0.0
            I1    = I + IB2
            I2    = I1 + 104
            BUFF(I2)  = BUFF(I2) + BUFF(I1)
            BUFF(I1)  = 0.0
  100    CONTINUE
  200 CONTINUE
C
      RETURN
      END
************************************************************************
*    ===================                                               *
      SUBROUTINE BSCHCK
*    ===================                                               *
* ((Purpose))                                                          *
*     To check user's initialization parameters.                       *
*                                                                      *
*        Coded by S.Kawabata        Oct. '85                           *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER ( MXDIM = 100)
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2
 
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE1/ XLT(MXDIM),XUT(MXDIM),NDIMT,NWILDT,
     .               IGT(MXDIM),NCALLT
      COMMON /BASE2/ ACC1T,ACC2T,ITMX1T,ITMX2T
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
      COMMON /XHCNTL/ LOCK
 
      LOCK  = 1
 
      IF( IBASES .NE.  1 ) THEN
          WRITE(6,9000)
 9000     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   BSINIT was not called before calling BASES  *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
          STOP
      ENDIF
 
 
      IF( NDIM .LT. 1) THEN
          WRITE(6,9100)
 9100     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   NDIM was not set before calling BASES.      *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
          STOP
      ENDIF
 
      NDIMT = NDIM
 
      DO 200 I = 1,NDIM
         IF( XU(I) .LE. -1.0D37) THEN
             WRITE(6,9200) I,I
 9200        FORMAT(
     .        5X,'*************************************************',
     .       /5X,'*                                               *',
     .       /5X,'*   XL(',I6,' ).  XU(',I6,' ) were not set      *',
     .       /5X,'*    before calling BASES.                      *',
     .       /5X,'*   Process was terminated due to this error.   *',
     .       /5X,'*                                               *',
     .       /5X,'*************************************************')
             STOP
         ENDIF
 
         IGT(I)  = IG(I)
         XLT(I)  = XL(I)
         XUT(I)  = XU(I)
 
  200 CONTINUE
C
C  Change the maximum number of the wild variables
C 10 ===> 15
      IF( NWILD .LT.  0) THEN
          NWILD = MIN( NDIM, 15)
          WRITE(6,9300) NWILD
 9300     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   NWILD was not set before calling BASES.     *',
     .    /5X,'*                                               *',
     .    /5X,'*   NWILD is set equal to the value(',I6,' ).   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
      ELSE
     .IF( NWILD .GT. 15) THEN
          NWILDO = NWILD
          NWILD  = MIN( NDIM, 15)
          WRITE(6,9400) NWILDO, NWILD
 9400     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   NWILD(',I6,' ) was too large number.        *',
     .    /5X,'*                                               *',
     .    /5X,'*   NWILD is set equal to the value(',I6,' ).   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
      ENDIF
 
      NWILDT = NWILD
      NCALLT = NCALL
 
      ITMX1T = ITMX1
      ITMX2T = ITMX2
      ACC1T  = ACC1
      ACC2T  = ACC2
C
      RETURN
      END
C***********************************************************************
C*=======================                                              *
       SUBROUTINE BSDATE
C*=======================                                              *
C*((Purpose))                                                          *
C*    Changethe format of the time stamp.                              *
C*    This program should be modified according to the machine.        *
C*((Author))                                                           *
C*    S.Kawabata  Nov. '91 at KEK                                      *
C*    For HP      Jul. '92 at KEK                                      *
C***********************************************************************
       COMMON /BDATE/ IDATE(3),ITIME(2)
       COMMON /SLATE/ IS(40)
*            IDATE(1) : year        ITIME(1) : hour
*            IDATE(2) : month       ITIME(2) : minute
*            IDATE(3) : day
 
       CALL UXDATE(IY,IM,ID,IHH,IMM)
CERN   call datime(id,it)
CERN   CALL UCOPY(IS(1),IDATE(1),5)
CERN   IDATE(1) = MOD(IDATE(1),1900)
       IDATE(1) = IY
       IDATE(2) = IM
       IDATE(3) = ID
       ITIME(1) = IHH
       ITIME(2) = IMM
       RETURN
       END
************************************************************************
*    ===========================================                       *
      SUBROUTINE BSDIMS( MDIM, MWILD, XLL, XUU )
*    ===========================================                       *
* ((Purpose))                                                          *
*     To set the BASES parameters.                                     *
* ((Input))                                                            *
*     MDIM   : The number of dimension of integral                     *
*     MWILD  : The number of wild variables                            *
*     XLL(i) : The lower value of the i-th integral variable           *
*     XUU(i) : The upper value of the i-th integral variable           *
* ((Output))                                                           *
*     These parameters are to be set in the labeled common /BPARM1/    *
* (Caution)                                                            *
*     The parameter IG(i) is not able to set by this routine.          *
*     If some of parameters IG(i) are required to be changed,          *
*     it is done by calling the subroutine BSGRID.                     *
*                                                                      *
*        Coded by S.Kawabata         August '94                        *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50 )
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL

      DIMENSION XLL(MDIM), XUU(MDIM)

*=========================================================
 
      NDIM   = MDIM
      NWILD  = MWILD
      DO 100 I= 1, NDIM
         XL(I) = XLL(I)
         XU(I) = XUU(I)
  100 CONTINUE
 
       RETURN
       END
C***********************************************************************
C*                                                                     *
C*========================                                             *
C*    SUBROUTINE BSETGU                                                *
C*========================                                             *
C*((Function))                                                         *
C*     Initialization of Bases progam                                  *
C*     This is called only when IFLAG=0.                               *
C*     ( IFLAG = 0 ; First Trial of Defining Grid step )               *
C*                                                                     *
C*    Changed by S.Kawabata    Aug. 1984 at Nagoya Univ.               *
C*    Last update              Oct. 1985 at KEK                        *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE BSETGU
C
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
      COMMON /BASE6/ D(NDMX,MXDIM),
     .               ALPH,XSAVE(NDMX,MXDIM),XTI,XTSI,XACC,ITSX
 
      DIMENSION  XIN(NDMX)
      DATA  ONE/ 1.0D0/
C
C---------------------------------------------------------------
C           Define the number of grids and sub-regions
C---------------------------------------------------------------
C==> Determine NG : Number of grids
          NG    = (NCALL/2.)**(1./NWILD)
         IF(NG .GT. 25) NG  = 25
  100    IF(NG .LT.  2) NG  =  1
         IF(NG**NWILD .GT. LENG) THEN
            NG  = NG - 1
            GO TO 100
         ENDIF
C
C==> Determine ND : Number of sub-regions
          M     = NDMX/NG
          ND    = M*NG
C
C==> Determine NPG: Number of sampling points per subhypercube
          NSP   = NG**NWILD
          NPG   = NCALL/NSP
 
          XI(1,1)= ONE
          MA(1)  = 1
          DX(1)  = XU(1)-XL(1)
 
          IF( NDIM .GT. 1 ) THEN
              DO 130 J = 2,NDIM
                 XI(1,J)= ONE
                 DX(J)  = XU(J)-XL(J)
                 IF( J .LE. NWILD ) THEN
                    MA(J)  = NG*MA(J-1)
                 ENDIF
  130         CONTINUE
          ENDIF
C
C---------------------------------------------------------------
C           Set size of subregions uniform
C---------------------------------------------------------------
          NDM   = ND-1
          RC    = ONE/ND
          DO 155 J =1,NDIM
             K     = 0
             XN    = 0.D0
             DR    = XN
             I     = K
  140        K     = K+1
             DR    = DR+ONE
             XO    = XN
             XN    = XI(K,J)
  145       IF(RC .GT. DR) GO TO 140
             I     = I+1
             DR    = DR-RC
             XIN(I)= XN-(XN-XO)*DR
            IF(I .LT. NDM) GO TO 145
             DO 150 I  = 1,NDM
                XI(I,J)= XIN(I)
  150        CONTINUE
             XI(ND,J)  = ONE
  155     CONTINUE
********************************************* Updated Feb.08 '94
          IF( ITSX .GT. 0 ) THEN
              IPSAVE = 1
              XACC    = 1.0D37
              XTI     = 0.0D0
              XTSI    = XACC
              ITSX    = 1
              DO 200 J = 1, NDIM
              DO 200 I = 1, ND
                 XSAVE(I,J) = XI(I,J)
  200         CONTINUE
          ENDIF
C
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*========================                                             *
C*    SUBROUTINE BSETGV( IFLAG )                                       *
C*========================                                             *
C*((Function))                                                         *
C*    Refine the grid sizes                                            *
C*                                                                     *
C*    Coded   by S.Kawabata    Aug. 1984 at Nagoya Univ.               *
C*    Last update              Oct. 1985 at KEK                        *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE BSETGV( IFLAG )
C
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
      COMMON /BASE6/ D(NDMX,MXDIM),
     .               ALPH,XSAVE(NDMX,MXDIM),XTI,XTSI,XACC,ITSX
      REAL*4 STIME
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,ITG,ITF
*
 
      DIMENSION  XIN(NDMX),R(NDMX),DT(MXDIM),DDX(NDMX)
      DATA  ONE/1.0D0/,ZERO/0.0D0/,N0/0/,N1/1/
*
*========= Save the grid information for the best accuracy ===========
*
      IF( ITSX .GT. 0 ) THEN
          IF( IFLAG .EQ. 0 ) THEN
              IF( IT .GE. 5 ) THEN
                  IF( ( TI .GT. AVGI+SD) .AND. TSI .LT. XTSI ) THEN
                      DO 400 J = 1, NDIM
                      DO 400 I = 1, ND
                         XSAVE(I,J) = XI(I,J)
  400                 CONTINUE
                      XACC         = TACC
                      ITSX         = IT
                      XTI          = TI
                      XTSI         = TSI
                  ENDIF
              ENDIF
          ELSE
              IF( ( XTI .GT. TI) .AND. XTSI .LT. TSI ) THEN
                  DO 500 J = 1, NDIM
                  DO 500 I = 1, ND
                     XI(I,J) = XSAVE(I,J)
  500             CONTINUE
*                ==========
                   RETURN
*                ==========
              ENDIF
          ENDIF
      ENDIF
 
C======= SMOOTHING THE FUNCTION D(I,J)
C
        CLOGE   = 1.0D0/LOG(10.0D0)
 
        NDM     = ND-1
        DO 780 J= N1,NDIM
         IF( IG(J) .EQ. 1 ) THEN
          DDX(1)= 0.5D0*(D(1,J) + D(2,J))
          DO 710 I=2,NDM
            DDX(I)= (D(I+1,J) + D(I,J) + D(I-1,J))/3.D0
  710     CONTINUE
          DDX(ND) = 0.5D0*(D(NDM,J) + D(ND,J))
          DT(J) = 0.D0
          DO 720 I = 1, ND
             D(I,J) = DDX(I)
             DT(J)  = DT(J)+D(I,J)
  720     CONTINUE
C
C=========== REDEFINE THE GRID
C
 
          DTLOG   = LOG(DT(J))
          DT10    = CLOGE*DTLOG
          RC    = ZERO
          DO 730 I= N1,ND
            R(I)  = ZERO
            IF(D(I,J) .GT. ZERO) THEN
               DILOG = LOG(D(I,J))
               IF( DT10 - CLOGE*DILOG  .LE. 70.0D0 ) THEN
                   XO    = DT(J)/D(I,J)
                   R(I)  = ((XO-ONE)/(XO*(DTLOG-DILOG)))**ALPH
               ELSE
C                  XO    = DT(J)/D(I,J)
                   R(I)  = (DTLOG-DILOG)**(-ALPH)
               ENDIF
            ENDIF
            RC    = RC+R(I)
  730     CONTINUE
          RC    = RC/ND
          K     = N0
          XN    = N0
          DR    = XN
          I     = K
  740  K     = K + N1
          DR    = DR+R(K)
          XO    = XN
          XN    = XI(K,J)
  750 IF(RC.GT.DR)GO TO 740
          I     = I + N1
          DR    = DR-RC
          XIN(I)= XN-(XN-XO)*DR/R(K)
      IF(I.LT.NDM)GO TO 750
          DO 760 I= N1,NDM
            XI(I,J)= XIN(I)
  760     CONTINUE
          XI(ND,J)= ONE
         ENDIF
  780   CONTINUE
C
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*========================                                             *
C*    SUBROUTINE BSGETW( WEIGHT )                                      *
C*========================                                             *
C*((Function))                                                         *
C*    Get Weight                                                       *
C*                                                                     *
C*    Coded   by T.Ishikawa    Jun. 1995 at KEK                        *
C*    Last update              Jun. 1995 at KEK                        *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE BSGETW( WEIGHT )
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
*
*========= Save the grid information for the best accuracy ===========
*
      WEIGHT = WGT
C
      RETURN
      END
************************************************************************
*    ==================================                                *
      SUBROUTINE BSGRID( MDIM, IGG )
*    ==================================                                *
* ((Purpose))                                                          *
*     To change the grid optimizing flag.                              *
* ((Input))                                                            *
*     MDIM   : The number of dimension of integral                     *
*     IGG(i) : The flag switches whether the grid of i-th variable     *
*              is to be optimized ( 1 ) or kept uniform ( 0 ).         *
* ((Output))                                                           *
*     These parameters are to be set in the labeled common /BPARM1/    *
*                                                                      *
*        Coded by S.Kawabata         August '94                        *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50 )
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL

      DIMENSION IGG(MDIM)

*=========================================================
 
      NDIM   = MDIM
      DO 100 I= 1, NDIM
         IG(I) = IGG(I)
  100 CONTINUE
 
       RETURN
       END
************************************************************************
*    ===============================                                   *
      SUBROUTINE BSHBOK( IOFSET )
*    ===============================                                   *
* ((Purpose))                                                          *
*      To write the ID-th histogram on the unit LUNIT.                 *
* ((Input))                                                            *
*      LUNIT: Logical unit number                                      *
*      ID   : Historgram ID                                            *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata   June '90 at KEK                                   *
*                                                                      *
************************************************************************
 
      REAL*8         SCALLS,WGT,TI,TSI,TACC
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))

      CHARACTER*80 TITLE
 
      COMMON/PLOTLU/ LU
 
C
      IF( NHIST .GT. 0 ) THEN

          NTOTAL= SCALLS

          DO 500 IHIST = 1, NHIST
             ID    = MAPL(1,IHIST)
             ID    = ID + IOFSET
             IP1   = MAPL(2,IHIST)
             XMIN  = BUFF(IP1)
             XMAX  = BUFF(IP1+1)
             NXBIN = IBUF(IP1+2)
             DEV   = BUFF(IP1+3)
             IP2   = MAPL(3,IHIST)
             IP3   = MAPL(4,IHIST)
 
*        WRITE(LU,9200) ID,LUNIT,(BUFF(I),I=IP3+1,IP3+15),
*    .              NTOTAL,NXBIN,DEV
*9200    FORMAT(/1H1,
*    .         1X,'** Histogram ID(',I5,' ) was saved in Unit(',I2,') **',
*    .         /1X,'Title : ',15A4,
*    .         /1X,'Entries     =',I10,
*    .         /1X,'No. of bins =',I10,'  Width =',G13.4)
 
             WRITE( TITLE, 9500) (BUFF(I), I=IP3+1,IP3+16)
 9500        FORMAT(16A4)

             CALL HBOOK1( ID, TITLE, NXBIN, XMIN, XMAX, 0.0 )
 
             IPF   = IP2 + 156
             IPF2  = IPF + 52
             FACT       = 1./(NTOTAL*DEV)
             DO 400 I = 1, NXBIN
                TX     = BUFF(I+IPF)
                NX     = IBUF(I+IP2)
                VLS    = TX*FACT
*               IF( NX .GT. 1 ) THEN
*                   DEV2   =  NX*BUFF(I+IPF2)-TX*TX
*                   IF( DEV2 .LE. 0.0 ) THEN
*                       VER = 0.0
*                   ELSE
*                       VER = FACT*SQRT( DEV2/( NX-1 ))
*                   ENDIF
*               ELSEIF( NX .EQ. 1 ) THEN
*                   VER = VLS
*               ELSE
*                   VER = 0.0
*               ENDIF
                XX     = XMIN + DEV*(FLOAT(I) - 0.5)
 
	        CALL HFILL( ID, XX, 0.0, VLS )
  400        CONTINUE
 
  500     CONTINUE

      ENDIF

      IF( NSCAT .GT. 0 ) THEN
         DO 900 ISCAT = 1, NSCAT
 
            IP3   = MAPD(4,ISCAT)
 
            WRITE( TITLE, 9500) (BUFF(I), I=IP3+2,IP3+17)

            ID    = MAPD(1,ISCAT)
            ID    = ID + IOFSET + 10000
 
            IP1   = MAPD(2,ISCAT)
            XL    = BUFF(IP1)
            XU    = BUFF(IP1+1)
            NX    = IBUF(IP1+2)
            DX    = BUFF(IP1+3)
            YL    = BUFF(IP1+4)
            YU    = BUFF(IP1+5)
            NY    = IBUF(IP1+6)
            DY    = BUFF(IP1+7)

            CALL HBOOK2( ID, TITLE, NX, XL, XU, NY, YL, YU, 0.0 )
 
            IP2   = MAPD(3,ISCAT)
            NTOTAL= IBUF(IP2)
            FACT       = 1./(NTOTAL*DX*DY)
            
            DO 300 L = 0, NY-1
               IB     = NX*L + IP2
               DO 200 I = 1,NX
                  VLS   = BUFF( I + IB )* FACT
                  XX    = XL + DX*(FLOAT(I) - 0.5)
                  YY    = YL + DY*(FLOAT(L) - 0.5)
 
                  CALL HFILL( ID, XX, YY, VLS )

  200          CONTINUE
  300       CONTINUE
 
  900    CONTINUE
      ENDIF

      RETURN
      END
***********************************************************************
*============================                                         *
      SUBROUTINE BSINFO( LU )
*============================                                         *
*((Purpose))                                                          *
*    Print the information for                                        *
*        (1) BASES parameters                                         *
*        (2) Computer time information                                *
*        (3) Convergency behavior of the Grid optimization step       *
*        (4) Convergency behavior of the integration step             *
*(( Input ))                                                          *
*    LU  :  Logical unit number of printer                            *
*                                                                     *
*           by S.Kawabata    March 1994 at KEK
*                                                                     *
***********************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*4 STIME
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,ITG,ITF
 
*  Print Title
 
      CALL BSPRNT( LU, 1, IDUM1, IDUM2 )
 
*  Print Bases parameters
 
      CALL BSPRNT( LU, 4, IDUM1, IDUM2 )
 
*  Print Computing time information
 
      CALL BSPRNT( LU, 3, IDUM1, IDUM2 )
 
*  Print Convergency Behaviors
 
      DO 100 ISTEP = 0, 1
         ITX  = ITG
         IF( ISTEP .EQ. 1 ) ITX = ITF

      IF( ITX .GT. 0 ) THEN

         CALL BSPRNT( LU, 8, ITX, ISTEP )
 
      ENDIF
  100 CONTINUE
 
      RETURN
      END
************************************************************************
*    ===================                                               *
      SUBROUTINE BSINIT
*    ===================                                               *
* ((Purpose))                                                          *
*     Initialization of BASE50/SPRING50.                               *
*     Function of this routine is                                      *
*       (0) Set the size of histogram and scatter plot buffers         *
*       (1) Set the parameters INTV and IPNT                           *
*             INTV = ( 0 / 1 / any )                                   *
*                  = ( Batch / Batch(Unix) / Interactive )             *
*             IPNT = ( 0 / any )                                       *
*                  = ( IBM Type / Ascii printer )                      *
*       (2) Set the acceleration factor ALPHA by 1.5                   *
*            The range of this value is from 0.0 to 2.0.               *
*            ALPHA = 0.0 results in no grid-optimization.              *
*       (3) Set the grid-optimization flag IGOPT ( Default value 0 )   *
*             IGOPT = 0  :  The grid is optimized by VEGAS algorithm   *
*             IGOPT = 1  :  The grid is optimized so that the accuracy *
*                           of each iteration be minimized.            *
*       (4) Set Node-ID number NODEID and the number of nodes NUMNOD   *
*       (5) Set seed of radom number                                   *
*       (6) Set the values of BASES paremeters with default ones.      *
*       (7) Set the values of parameters with non-sense values,        *
*            which should be set again with the true values by User    *
*            before running BASES.                                     *
*                                                                      *
*        Coded by S.Kawabata         March '94                         *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50 )
      COMMON /RNDSEED/ISEED
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2
 
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE6/ D(NDMX,MXDIM),
     .               ALPH,XSAVE(NDMX,MXDIM),XTI,XTSI,XACC,IGOPT
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
       COMMON/NINFO/ NODEID, NUMNOD
       COMMON /BDATE/ IDATE(3),ITIME(2)
*            IDATE(1) : year        ITIME(1) : hour
*            IDATE(2) : month       ITIME(2) : minute
*            IDATE(3) : day
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
*=========================================================
* (0) Initialization of timer and Histogram buffer
*     Timer initialization
       CALL BSTIME( TIME0, 0 )
       TIMEB1 = TIME0
       TIMINT = 0
*
*     Histogram buffer initialization
       LU  = 6
       CALL BHINIT( LU )
 
*=========================================================
 
* (1) Set the parameters INTV and IPNT
       INTV  = 2
       IPNT  = 1
* (2) Set the acceleration factor ALPHA by 1.5
       ALPH  = 1.5D0
* (3) Set the grid-optimization flag IGOPT
       IGOPT = 0
* (4) Set Node-ID number NODEID and the number of nodes NUMNOD
*      IF( INTV .EQ. 0 ) THEN
           NODEID = 0
           NUMNOD = 1
*      ELSE
*          NODEID = 0
*          NUMNOD = 1
*      ENDIF
 
C---------------------------------------------------------------
C (5)  Set initial seeds of random number generator
C---------------------------------------------------------------
        ISEED = 12345
C
       CALL DRNSET( ISEED )
C ---------------------------------------------------------------
C (6),(7)  Set BASES parameters equal to default values
C ---------------------------------------------------------------
C
       NDIM   = -1
       NWILD  =  1
       ITMX1  = 15
       ITMX2  = 100
       NCALL  = 1000
       ACC1   = 0.2D0
       ACC2   = 0.01D0
       DO 100 I = 1,MXDIM
          IG(I) = 1
          XU(I)  = -1.0D37
  100  CONTINUE
 
*    Initialization of computing time table of BASES
       DO 200 I = 0, 2
          TIMEBS(I) = 0.0
  200  CONTINUE
 
*-------------------------------------------
*      Don't change IBASES from this value
*-------------------------------------------
       IBASES =  1
 
       RETURN
       END

***********************************************************************
*                                                                     *
*    ==========================                                       *
      SUBROUTINE BSINTG( FXN )
*    ==========================                                       *
*((Function))                                                         *
*    Subroutine performs N-dimensional Monte Carlo integration        *
*    for four vector generation of simulated events                   *
*                                                                     *
*       JFLAG = 0 ; First Trial of Defining Grid                      *
*       JFLAG = 1 ; First Trial of Data Accumulation                  *
*       JFLAG = 2 ; Second Trial of Defining Grid                     *
*       JFLAG = 3 ; Second Trial of Data Accumulation                 *
*                                                                     *
*    Coded   by S.Kawabata    July 1980 at DESY, Hamburg              *
*    Last update              March 1994                              *
*                                                                     *
***********************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)

      EXTERNAL FXN
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE2/ ACC1,ACC2,ITMX1,ITMX2
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
      PARAMETER (ITM = 50)
      REAL*4 TIME, EFF, WRONG, TRSLT, TSTD, PCNT
      COMMON /BASE5/ ITRAT(ITM,0:1),TIME(ITM,0:2),EFF(ITM,0:1),
     .               WRONG(ITM,0:1),RESLT(ITM,0:1),ACSTD(ITM,0:1),
     .               TRSLT(ITM,0:1),TSTD(ITM,0:1),PCNT(ITM,0:1)
      COMMON /BASE6/ D(NDMX,MXDIM),
     .               ALPH,XSAVE(NDMX,MXDIM),XTI,XTSI,XACC,ITSX
      REAL*4 STIME
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,ITG,ITF
      CHARACTER*80 ERROR
      COMMON /BWARN1/ NERROR
      COMMON /BWARN2/ ERROR(3,3)
*
*        INTV = ( 0 / 1 / any ) = ( Batch / Batch(Unix) / Interactive )
*        IPNT = ( 0 / any ) = ( IBM Type / Ascii printer )
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      REAL*8  X(MXDIM)
      INTEGER KG(MXDIM),IA(MXDIM)
 
      COMMON/NINFO/ NODEID, NUMNOD
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
C     REAL*8  TX(2)
      INTEGER NCNODE(2,512),NPNODE(2,512)
C     INTEGER NEFF(2)
*
*     Parameters for checking convergency
*
      DATA ACLMT,FC / 25.0D0, 5.0D0 /
 
 
      DATA  ONE/ 1.0D0/, ZERO/0.0D0/, LU / 6/
      DATA  N0/0/, N1/1/, HUNDRT/100.0D0/
 
************************************************************************
*                       Initialization Part
************************************************************************
*=======================================================================
*          Determine the number of hypercubes NSP
*=======================================================================
 
      XND     = ND
      NSP     = NG**NWILD
      XJAC    = 1.0D0
      DO  5 I = 1, NDIM
         XJAC = XJAC*DX(I)
    5 CONTINUE
      CALLS   = NSP*NPG
      DXG     = 1.0D0/NG
      DV2G    = DXG**(2*NWILD)/NPG/NPG/(NPG-1)
      DXG     = DXG*XND
 
      IF( NSP .EQ. 1 ) THEN
*=======================================================================
*           Determination of the number of sampling points
*               per node in the single hypercube case
*=======================================================================
          MEX     = MOD(NPG,NUMNOD)
          NPERCP  = NPG/NUMNOD
          NPGT    = 0
          DO  12 NODEX = 1,NUMNOD
             NPGS  = NPGT + 1
             NPGT  = NPGT + NPERCP
             IF( NODEX .LE. MEX ) NPGT = NPGT + 1
             NCNODE(1,NODEX) = 1
             NCNODE(2,NODEX) = 1
             NPNODE(1,NODEX) = NPGS
             NPNODE(2,NODEX) = NPGT
   12     CONTINUE
      ELSE
*=======================================================================
*          Determination of the number of hypercubes
*              per node in many hypercubes case
*=======================================================================
          MEX     = MOD(NSP,NUMNOD)
          NPERCP  = NSP/NUMNOD
          NSPT    = 0
          DO  15 NODEX = 1,NUMNOD
             NSPS  = NSPT + 1
             NSPT  = NSPT + NPERCP
             IF( NODEX .LE. MEX ) NSPT = NSPT + 1
             NCNODE(1,NODEX) = NSPS
             NCNODE(2,NODEX) = NSPT
             NPNODE(1,NODEX) = 1
             NPNODE(2,NODEX) = NPG
   15     CONTINUE
      ENDIF
*=======================================================================
      NEND    = N0
      ATACC   = ZERO
      NERROR  = N0
      NER1    = N0
      NER2    = N0
      NER3    = N0
      SUMTI   = ZERO
      SUMTSI  = ZERO
 
      IF(JFLAG .EQ. N0 .OR. JFLAG .EQ. N1 ) THEN
*-----------------------------------------------------------------------
*        JFLAG = 0  : The first trial of the grid optim. step
*        JFLAG = 1  : The first trial of the integration step
*-----------------------------------------------------------------------
         DO 10 J  = N1,NSP
           DXD(J) = ZERO
           DXP(J) = ZERO
   10    CONTINUE
*       -----------------
         ISTEP   = JFLAG
*       -----------------
         IT1   = N1
         SI    = ZERO
         SI2   = ZERO
         SWGT  = ZERO
         SCHI  = ZERO
*       =============
         CALL BHRSET
*       =============
         NSU     = N0
         SCALLS= ZERO
      ELSE
*-----------------------------------------------------------------------
*        JFLAG = 2  : The continuation of the grid optim. step
*        JFLAG = 3  : The continuation of the integration step
*-----------------------------------------------------------------------
C        IF( JFLAG .EQ. 2 ) THEN
*           -------------
C            ISTEP  = N0
*           -------------
C        ELSE
C    .   IF( JFLAG .EQ. 3 ) THEN
*           -------------
C            ISTEP  = N1
*           -------------
C        ELSE
C                *****************
C                      STOP
C                *****************
C         ENDIF
C
C         IT1   = IT + 1
      ENDIF
 
*------- Set the expected accuracy and the max. iteration number -------
 
      ITMX   = ITMX1
      ACC    = ACC1*0.01D0
      IF( ISTEP .EQ. N1 ) THEN
         ITMX = ITMX2
         ACC  = ACC2*0.01D0
      ENDIF
 
*-------- Print the title of the convergency behavior table -----------
*                  in the interactive mode
      IF( INTV .GT. 1 ) THEN
*         -----------------------------------
           CALL BSPRNT( LU, 5, ISTEP, IDUM2 )
*         -----------------------------------
      ENDIF
      NEGFLG     = 0
 
*    =====================
      CALL BSUTIM( 0, 2 )
*    =====================
 
*********************************************************************
*               Main Integration Loop
*********************************************************************
*    ========
      DO 500  IT = IT1,ITMX
*    ========
*=======================================================================
*                 Initialization for the iteration
*=======================================================================
 
         SCALLS  = SCALLS + CALLS
         NGOOD   = N0
         NEGTIV  = N0
         TI      = ZERO
         TSI     = TI
 
         IF( ISTEP .EQ. N0 ) THEN
             DO 200 J= N1,NDIM
             DO 200 I=1,ND
                D(I,J)= TI
  200        CONTINUE
         ENDIF
 
         NODEX  = NODEID
         IF( NODEID .EQ. 0 )  NODEX = NUMNOD
 
*---------------------------------------------------------------------
*        Distributing hyper cubes to NumNode nodes
*           NCNODE(1,NODEX)   : 1st cube number for the node NODEX
*           NCNODE(2,NODEX)   : Last cube number for the node NODEX
*                    NODEX    : node number 1 => NumNode(=0)
*                    NODEX    : node number 1 => NumNode(=0)
*---------------------------------------------------------------------
 
         NSP1  = NCNODE(1,NODEX)
         NSP2  = NCNODE(2,NODEX)
*                                 Dummy loopfor a parallel processor
C                                 IF( NSP1 .GT. 1 ) THEN
C                                     CALL DRLOOP( NDIM*NPG*(NSP1-1) )
C                                 ENDIF
 
*=====================================================================
*      Loop for hypercube from NSP1 to NSP2 in the NodeX-th node
*=====================================================================
*       ========
         DO 400 NCB = NSP1, NSP2
*       ========
            FB      = 0.0
            F2B     = 0.0
            NP      = NCB - 1
            IF( NWILD .GT. 1 ) THEN
                DO 210 J = 1,NWILD-1
                   NUM   = MOD(NP,MA(J+1))
                   KG(J) = NUM/MA(J) + 1
  210           CONTINUE
            ENDIF
            KG(NWILD)     = NP/MA(NWILD) + 1
 
*---------------------------------------------------------------------
*       If number of hypercubes is only one,
*        Distributing sampling points to NumNode nodes
*           NPNODE(1,NODEX)   : 1st sample point for the node NODEX
*           NPNODE(2,NODEX)   : Last sample point for the node NODEX
*                    NODEX    : node number 1 => NumNode(=0)
*---------------------------------------------------------------------
 
            NPG1  = NPNODE(1,NODEX)
            NPG2  = NPNODE(2,NODEX)
*                                 Dummy loop for a parallel processor
C                                 IF( NPG1 .GT. 1 ) THEN
C                                     CALL DRLOOP( NDIM*(NPG1-1) )
C                                 ENDIF
 
*=====================================================================
*          Loop for sampling points from NPG1 to NPG2
*                in the single hypercube case
*=====================================================================
*          ========
            DO 300 NTY = NPG1,NPG2
*          ========
*---------------------------------------------------------------------
*        Determine the integration variables by random numbers
*---------------------------------------------------------------------
 
               WGT   = XJAC
               DO 250 J= 1,NDIM
                  IF( J .LE. NWILD ) THEN
                      XN  = (KG(J)-DRN(IDUMY))*DXG+1.D0
                  ELSE
                      XN  = ND*DRN(IDUMY)+1.D0
                  ENDIF
                  IA(J)   = XN
                  IAJ     = IA(J)
                  IF( IAJ .EQ. 1) THEN
                      XO  = XI(IAJ,J)
                      RC  = (XN-IA(J))*XO
                  ELSE
                      XO  = XI(IAJ,J)-XI(IAJ-1,J)
                      RC  = XI(IAJ-1,J)+(XN-IAJ)*XO
                  ENDIF
                  X(J)    = XL(J)+RC*DX(J)
                  WGT     = WGT*XO*XND
  250          CONTINUE
*-----------------------------------------------------------------------
*                     =======
               FXG  =  FXN(X)*WGT
*                     =======
*-----------------------------------------------------------------------
*             Check the value of the integrand
*-----------------------------------------------------------------------
 
               IF( FXG .NE. 0.0 ) THEN
                   NGOOD = NGOOD + 1
                   IF( ISTEP .EQ. 1 ) THEN
                       DXD(NCB) = DXD(NCB) + FXG
                       IF( FXG .GT. DXP(NCB) ) DXP(NCB) = FXG
                   ENDIF
                   IF( FXG .LT. 0.0 ) THEN
                       NEGTIV= NEGTIV+ 1
                       IF( NEGFLG .EQ. 0 ) THEN
                          IF(LU.GT.0) WRITE(6,9200) IT,NODEID
 9200                     FORMAT(1X,
     .                       '******* WARNING FROM BASES ********',
     .                       '***********',
     .                       /1X,'*  Negative FUNCTION at IT =',I3,1X,
     .                       ', node = ',I3,1X,'*',
     .                       /1X,'***********************************',
     .                       '***********')
                          NEGFLG  = 1
                       ENDIF
                   ENDIF
               ENDIF
 
*-----------------------------------------------------------------------
*              Accumulation of FXG and FXG*FXG
*-----------------------------------------------------------------------
 
               F2    = FXG*FXG
               FB    = FB + FXG
               F2B   = F2B + F2
 
               IF( ISTEP .EQ. 0 ) THEN
                   DO 260  J = 1,NDIM
                      D(IA(J),J)= D(IA(J),J)+F2
  260              CONTINUE
               ENDIF
*======
  300       CONTINUE
*======
*------------------------------------------- for a parallel processor
*                                 Dummy loop for a parallel processor
C                                 IF( NPG2 .LT. NPG ) THEN
C                                     CALL DRLOOP(NDIM*(NPG-NPG1))
C                                 ENDIF
*                                 Global sum of FB and F2B
C                                 IF( NSP .EQ. 1 ) THEN
C                                     CALL BSDSUM(  FB, 1 )
C                                     CALL BSDSUM( F2B, 1 )
C                                 ENDIF
*-----------------------------------------------------------------------
 
*-----------------------------------------------------------------------
*         Calculate the estimate and variance in the hypercube
*-----------------------------------------------------------------------
 
            F2B   = DSQRT(F2B*NPG)
            F2S   = (F2B-FB)*(F2B+FB)
            TI    = TI+FB
            TSI   = TSI + F2S
 
*======
  400    CONTINUE
*======
*------------------------------------------- for a parallel processor
*                                 Dummy loop
C                                 IF( NSP2 .LT. NSP ) THEN
C                                     CALL DRLOOP(NDIM*NPG*(NSP-NSP2))
C                                 ENDIF
 
*                                 Global sum of efficiency and frequency
*                                     of negative valued function
C                                 NEFF(1) = NGOOD
C                                 NEFF(2) = NEGTIV
C                                 CALL BSISUM( NEFF, 2 )
 
C                                 TX(1) = TI
C                                 TX(2) = TSI
C                                 IF( NSP .EQ. 1 ) THEN
C                                     CALL BSDSUM(   TX, 2 )
C                                 ENDIF
 
*                                 Global sum of grid information
C                                 IF( ISTEP .EQ. 0 ) THEN
C                                     NOWORK = NDMX*NDIM
C                                     CALL BSDSUM(    D, NOWORK )
C                                 ENDIF
 
*=====================================================================
*           Compute Result of this Iteration
*=====================================================================
*--------------------------------------------------------------------
*           Accumulate the histogram entries
*--------------------------------------------------------------------
*       -------------
         CALL BHSAVE
*       -------------
*--------------------------------------------------------------------
 
C        TI     = TX(1)
C        TSI    = TX(2)
C        NGOOD  = NEFF(1)
C        NEGTIV = NEFF(2)
 
         TI    = TI/CALLS
         TSI   = TSI*DV2G
**
         IF( TSI .LE. 1.0D-37 ) TSI = 1.0D-37
**
         TI2   = TI*TI
 
         IF( NGOOD .LE. 10 ) THEN
*           --------------------------------
             CALL BSPRNT( LU, 9, IDUM1, IDUM2 )
*           --------------------------------
*            *****************
                   STOP
*            *****************
 
         ENDIF
 
*--------------------------------------------------------------------
*               Calculate the cumulative result
*--------------------------------------------------------------------
 
         WGT   = ONE/TSI
         SI    = SI+TI*WGT
         SWGT  = SWGT+WGT
         SCHI  = SCHI+TI2*WGT
         AVGI  = SI/SWGT
         CHI2A = ZERO
         IF(IT .GT. N1 ) CHI2A = (SCHI - SI*AVGI)/(IT-.999D0)
         SD    = DSQRT(ONE/SWGT)
 
*---------------------------------------------------------------------
*             Save the results in the buffer
*---------------------------------------------------------------------
 
         TSI   = DSQRT(TSI)
         ITX         = MOD( IT, ITM)
         IF( ITX .EQ. 0 ) ITX = ITM
         ITRAT(ITX,ISTEP)  = IT
         EFF  (ITX,ISTEP)  = NGOOD/CALLS*HUNDRT
         WRONG(ITX,ISTEP)  = NEGTIV/CALLS*HUNDRT
         RESLT(ITX,ISTEP)  = AVGI
         ACSTD(ITX,ISTEP)  = SD
         TRSLT(ITX,ISTEP)  = TI
         TACC              = ABS(TSI/TI*HUNDRT)
         TSTD (ITX,ISTEP)  = TACC
         PCNT (ITX,ISTEP)  = ABS(SD/AVGI*HUNDRT)
 
*----------------------------------------------------------------------
*                  Check cumulative accuracy
*----------------------------------------------------------------------
 
         IF( NODEID .EQ. 0 ) THEN
 
*-------------------  Check cumulative accuracy -----------------------
 
             SDAV  = SD/AVGI
             IF((ABS(SDAV) .LE. ACC)) NEND = N1
 
             IF( ISTEP .EQ. N1 ) THEN
                 IF( TACC .GT. ACLMT ) THEN
                     IF( NER1 .EQ. 0 ) THEN
                         NERROR = NERROR + 1
                         IF(LU.GT.0) 
     .                   WRITE(ERROR(1,NERROR),9900) NERROR,IT,ACLMT
 9900                    FORMAT('* (',I1,') Temp. accuracy of it-#',
     .                         I3,' is too large comparing to',
     .                         F6.2,' percent.',6X,'*')
                         IF(LU.GT.0) 
     .                   WRITE(ERROR(2,NERROR),9901) TACC,ACLMT 
 9901                    FORMAT('*',8X,'Temp. accuracy (',
     .                         F7.4,' % )  >>   (',
     .                         F7.4,' % )',23X,'*')
                         IF(LU.GT.0) WRITE(ERROR(3,NERROR),9902)
 9902                    FORMAT('*',77X,'*')
                         NER1  = 1
                     ENDIF
                 ENDIF
                 IF( IT .GT. 1 ) THEN
                     IF(( TI .GT. AVTI+FDEVI ) .OR.
     .                  ( TI .LT. AVTI-FDEVI )      ) THEN
                          IF( NER2 .EQ. 0 ) THEN
                              NERROR = NERROR + 1
                              IF(LU.GT.0) 
     .                        WRITE(ERROR(1,NERROR),9910) NERROR,IT,FC
 9910                         FORMAT('* (',I1,') Temp. estimate of ',
     .                        'it-#',I3,' fluctuates more than ',
     .                               F4.1,'*average-sigma.',6X,'*')
                              RE = TI
*patch TI:1995/08/25
                              ARE = ABS(RE)
*old                          CALL BSORDR( RE, FX2, ORDER, IORDR )
                              CALL BSORDR( ARE, FX2, ORDER, IORDR )
*patch end
                              RE = TI/ORDER
                              RE1 = AVTI
                              AC  = FDEVI 
*patch TI:1995/08/25
                              ARE1 = ABS(AVTI)
                              AAC  = ABS(FDEVI)
                              IF( ARE1 .GE. AAC ) THEN
                                  CALL BSORDR( ARE1, FX2, ORDR1, IORDR1)
                              ELSE
                                  CALL BSORDR( AAC, FX2, ORDR1, IORDR1)
                              ENDIF
*                             IF( RE1 .GE. AC ) THEN
*                                 CALL BSORDR( RE1, FX2, ORDR1, IORDR1)
*                             ELSE
*                                 CALL BSORDR( AC, FX2, ORDR1, IORDR1)
*                             ENDIF
*patch end
                              RE1 = AVTI/ORDR1
                              AC  = AC/ORDR1
                              IF(LU.GT.0) 
     .                        WRITE(ERROR(2,NERROR),9911) RE,IORDR, 
     .                                          RE1,AC,IORDR1 
 9911                         FORMAT('*        Temp. Estimate (',
     .                         F10.6,' E',I3,')  >  (',F10.6,'+',F8.6,
     .                         ' ) E',I3,', or',1X,'*')
                              IF(LU.GT.0) 
     .                        WRITE(ERROR(3,NERROR),9912) RE,IORDR, 
     .                                          RE1,AC,IORDR1 
 9912                         FORMAT('*        Temp. Estimate (',
     .                         F10.6,' E',I3,')  <  (',F10.6,'-',F8.6,
     .                         ' ) E',I3,5X,'*')
                              NER2 = 1
                          ENDIF
                     ENDIF
                     IF( TSI .GT. FDEVI ) THEN
                         IF( NER3 .EQ. 0 ) THEN
                             NERROR = NERROR + 1
                             IF(LU.GT.0) 
     .                       WRITE(ERROR(1,NERROR),9920) NERROR,IT,FC
 9920                        FORMAT('* (',I1,') Error of it-#',
     .                              I3,' fluctuates more than',F4.1,
     .                              '*average-sigma.',16X,'*')
                             RE1 = TSI
*patch TI:1995/08/25
                             ARE1 = ABS(TSI)
*                            CALL BSORDR( RE1, FX2, ORDER, IORDR)
                             CALL BSORDR( ARE1, FX2, ORDER, IORDR)
*patch end;
                             RE1 = TSI/ORDER
                             AC  = FDEVI 
*patch TI:1995/08/25
                             AAC  = ABS(FDEVI)
*                            CALL BSORDR( AC, FX2, ORDR1, IORDR1)
                             CALL BSORDR( AAC, FX2, ORDR1, IORDR1)
*patch end;
                             AC  = AC/ORDR1
                             IF(LU.GT.0) 
     .                       WRITE(ERROR(2,NERROR),9921) RE1,IORDR, 
     .                                         AC,IORDR1 
 9921                        FORMAT('*        Temp. Error (',
     .                         F10.6,' E',I3,')  >  (',F10.6,
     .                         ' E',I3,')',18X,'*')
                             IF(LU.GT.0) WRITE(ERROR(3,NERROR),9902)
                             NER3  = 1
                         ENDIF
                     ENDIF
                 ENDIF
                 SUMTSI = SUMTSI + TSI
                 SUMTI  = SUMTI  + TI
                 AVTSI  = SUMTSI/FLOAT(IT)
                 AVTI   = SUMTI/FLOAT(IT)
                 FDEVI  = FC*AVTSI
             ENDIF
         ENDIF
 
*------------------------------------------- for a parallel processor
 
*                                  Broadcast
C                                  CALL BSCAST( NEND, 1 )
 
*----------------------------------------------------------------------
*        Smoothing the Distribution D(I,J) and refine the grids
*----------------------------------------------------------------------
 
         IF( ISTEP .LE. N0 ) THEN
             IF( IT .EQ. ITMX ) NEND = N1
*           ---------------------
             CALL BSETGV( NEND )
*           ---------------------
         ENDIF
*       ==========================
         CALL BSUTIM( 0, ISTEP )
*       ==========================
 
         TIME (ITX,ISTEP)  = TIMINT
         STIME             = TIMINT
 
*---- Print the convergency behavior table in the interactive mode ----
         IF( INTV .GT. 1 ) THEN
*            ---------------------------------
              CALL BSPRNT ( LU, 6, ISTEP, IDUM2 )
*            ---------------------------------
         ENDIF
 
         IF( NEND .EQ. N1 ) GO TO 600
 
*       ======================
         CALL BSUTIM( 0, 2 )
*       ======================
*======
  500 CONTINUE
*======
      IT    = IT - N1
      NEND  = N1
 
***********************************************************************
*                   Termination of BASES
***********************************************************************
*======
  600 CONTINUE
*======
*---------------------------------------------- For a parallel computer
 
*                                 Global sum of histograms
C                                 CALL BHSUM
*                                 Global sum of probabilities
C                                 CALL BSDSUM(  DXD, NSP )
*                                 Global sum of the max.value in each HC
C                                 CALL BSDSUM(  DXP, NSP )
 
 
*======================= End of the step ? ============================
 
      IF( NEND .EQ. N1 ) THEN
          IF( INTV .GT. 1 ) THEN
*            ---------------------------------
              CALL BSPRNT ( LU, 7, IDUM1, IDUM2 )
*            ---------------------------------
          ENDIF
          IF( ISTEP .EQ. N0) THEN
              JFLAG   = N1
              ITG     = IT
          ELSE
              JFLAG   = N0
              ITF     = IT
          ENDIF
      ENDIF
*    ======================
       CALL BSUTIM( 0, 2 )
*    ======================
 
      RETURN
      END
***********************************************************************
*    ===================================                              *
      SUBROUTINE BSLIST( LU, I, ISTEP )
*    ===================================                              *
* ((purpose))                                                         *
*     Print out results of each iteration and cumulative result       *
* ((Argument))                                                        *
*  (Input)                                                            *
*     LU      : Logical unit number for the printer                   *
*     I       : Address in the arrays of common /BASE5/               *
*     ISTEP   : The Set-Identifier                                    *
*               ISTEP = ( 0 / 1 ) = ( Grid opt. / Integration step )  *
*                                                                     *
*     S. Kawabata   March '94                                         *
***********************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (ITM = 50)
      REAL*4 TIME, EFF, WRONG, TRSLT, TSTD, PCNT
      COMMON /BASE5/ ITRAT(ITM,0:1),TIME(ITM,0:2),EFF(ITM,0:1),
     .               WRONG(ITM,0:1),RESLT(ITM,0:1),ACSTD(ITM,0:1),
     .               TRSLT(ITM,0:1),TSTD(ITM,0:1),PCNT(ITM,0:1)
 
      CALL BSTCNV( TIME(I,ISTEP), IH, MN, IS1, IS2 )
 
      RE  = RESLT(I,ISTEP)
      AC  = ABS(ACSTD(I,ISTEP))
      ARE = ABS(RE)
      IF( ARE .GE. AC) THEN
          CALL BSORDR( ARE, F2, ORDER, IORDR)
      ELSE
          CALL BSORDR(  AC, F2, ORDER, IORDR )
      ENDIF
      RE  = RE/ORDER
      AC  = AC/ORDER
      IEFF = EFF(I,ISTEP)
      IF(LU.GT.0) WRITE(LU,9631) ITRAT(I,ISTEP),IEFF,WRONG(I,ISTEP),
     .              TRSLT(I,ISTEP),TSTD(I,ISTEP),
     .              RE,AC,IORDR,PCNT(I,ISTEP),IH,MN,IS1,IS2
 9631 FORMAT(I4,I4,F6.2,1P,E11.3, 0P,1X,F6.3,
     .              F10.6,'(+-',F8.6,')E',I3.2,1X,F6.3,
     .          1X,I3,':',I2,':',I2,'.',I2.2)
 
 
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*=============================================                        *
C*    SUBROUTINE BSORDR( VAL, F2, ORDER, IORDR)                        *
C*=============================================                        *
C*((Function))                                                         *
C*    To resolve the real number VAL into mantester and exponent parts.*
C*  When VAL = 1230.0 is given, output are                             *
C*        F2 = 1.2  and ORDER = 4.0.                                   *
C*((Input))                                                            *
C*  VAL  : Real*8 value                                                *
C*((Output))                                                           *
C*  F2   : The upper two digits is given                               *
C*  ORDER: Order is given                                              *
C*  IORDR: Exponent is given                                           *
C*((Author))                                                           *
C*  S.Kawabata                                                         *
C*                                                                     *
C***********************************************************************
 
      SUBROUTINE BSORDR(VAL, F2, ORDER, IORDR)
      IMPLICIT REAL*8 (A-H,O-Z)
 
      IF( VAL .NE. 0.0 ) THEN
          ORDER    =  LOG10( VAL )
          IORDR    =  INT( ORDER )
          IF( ORDER .LT. 0.0D0 ) IORDR = IORDR - 1
          ORDER  = 10.D0**IORDR
          F2     = VAL/ORDER
      ELSE
          IORDR  = 0
          ORDER  = 1.0D0
          F2    = 0.0D0
      ENDIF
 
      RETURN
      END
************************************************************************
*    ================================================                  *
      SUBROUTINE BSPARM( MCALL, AC1, AC2, IT1, IT2 )
*    ================================================                  *
* ((Purpose))                                                          *
*     To set the BASES parameters.                                     *
* ((Input))                                                            *
*     MCALL  : The number of sample points per iteration.              *
*              This actual number is to be determined by taking the    *
*              number of dimensions into account.                      *
*     AC1 %  : The required accuracy at the grid optimization step     *
*     AC2 %  : The required accuracy at the integration step.          *
*     IT1    : The max. number of iteration at the grid opt. step.     *
*     IT2    : Thr max. number of iteration at the integration step.   *
* ((Output))                                                           *
*     These parameters are set in the labeled common /BPARM1/ and      *
*     /BPARM2/.
*                                                                      *
*        Coded by S.Kawabata         August '94                        *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50 )
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2

      INTEGER MCALL, IT1, IT2
      REAL*8 AC1, AC2
 
      NCALL = MCALL
      ACC1  = AC1
      ACC2  = AC2
      ITMX1 = IT1
      ITMX2 = IT2

      RETURN
      END
***********************************************************************
*    =======================================                          *
      SUBROUTINE BSPRNT( LU, ID, IP1, IP2 )
*    =======================================                          *
* ((purpose))                                                         *
*     Print out routine of BASES.                                     *
*  (Argument)                                                         *
*     ID  : Identity number of printouts.                             *
*     IP1... IP2 : Integer                                            *
*  (Author)                                                           *
*     S. Kawabata   May 1992                                          *
*     Last update   March 1994                                        *
***********************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE2/ ACC1,ACC2,ITMX1,ITMX2
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
      PARAMETER (ITM = 50)
      REAL*4 TIME, EFF, WRONG, TRSLT, TSTD, PCNT
      COMMON /BASE5/ ITRAT(ITM,0:1),TIME(ITM,0:2),EFF(ITM,0:1),
     .               WRONG(ITM,0:1),RESLT(ITM,0:1),ACSTD(ITM,0:1),
     .               TRSLT(ITM,0:1),TSTD(ITM,0:1),PCNT(ITM,0:1)
      REAL*4 STIME
      COMMON /BSRSLT/AVGI,SD,CHI2A,STIME,IT1,ITF
      CHARACTER*51 ICH(0:1)
      CHARACTER*1 CN
*        INTV = ( 0 / 1 / any ) = ( Batch / Batch(Unix) / Interactive )
*        IPNT = ( 0 / any ) = ( IBM Type / Ascii printer )
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
*
       COMMON /BDATE/ IDATE(3),ITIME(2)
*            IDATE(1) : year        ITIME(1) : hour
*            IDATE(2) : month       ITIME(2) : minute
*            IDATE(3) : day
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
      REAL*4 XTIME
*
       COMMON/NINFO/ NODEID, NUMNOD
*
      DATA  ICH / 'Convergency Behavior for the Grid Optimization Step',
     .            'Convergency Behavior for the Integration Step      '/
 
      IF( NODEID .NE. 0 ) RETURN
      CN = CHAR(12)
 
      GO TO ( 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 ), ID
C----------------------------------------------------------- BSMAIN
 
  100 IF( IPNT .EQ. 0 ) THEN
          IF(LU.GT.0) WRITE(LU,9600)
 9600     FORMAT(/1H1,/1H )
      ELSE
          IF(LU.GT.0) WRITE(LU,9610) CN
 9610     FORMAT(A1)
      ENDIF
      IF(LU.GT.0) WRITE(LU,9620) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
 9620 FORMAT(55X,'Date: ',I2,'/',I2,'/',I2,2X,I2.2,':',I2.2)
      IF(LU.GT.0) WRITE(LU,9050)
 9050 FORMAT(
     . 8X,'**********************************************************',
     ./8X,'*                                                        *',
     ./8X,'*     BBBBBBB     AAAA     SSSSSS   EEEEEE   SSSSSS      *',
     ./8X,'*     BB    BB   AA  AA   SS    SS  EE      SS    SS     *',
     ./8X,'*     BB    BB  AA    AA  SS        EE      SS           *',
     ./8X,'*     BBBBBBB   AAAAAAAA   SSSSSS   EEEEEE   SSSSSS      *',
     ./8X,'*     BB    BB  AA    AA        SS  EE            SS     *',
     ./8X,'*     BB    BB  AA    AA  SS    SS  EE      SS    SS     *',
     ./8X,'*     BBBB BB   AA    AA   SSSSSS   EEEEEE   SSSSSS      *',
     ./8X,'*                                                        *',
     ./8X,'*                   BASES Version 5.1                    *',
     ./8X,'*           coded by S.Kawabata KEK, March 1994          *',
     ./8X,'**********************************************************')
 
          RETURN
C----------------------------------------------------------- BSMAIN
 
  200     IF( IPNT .EQ. 0 ) THEN
              IF(LU.GT.0) WRITE(LU,9600)
          ELSE
              IF(LU.GT.0) WRITE(LU,9610) CN
          ENDIF
          IF(LU.GT.0) WRITE(LU,9300)
 9300     FORMAT(20X,
     .         '****** END OF BASES *********')
 
C----------------------------------------------------------- BSMAIN
 
  300 CONTINUE
      IF(LU.GT.0) WRITE(LU,9305)
 9305 FORMAT(
     .//5X,'<<   Computing Time Information   >>')
 
*     WRITE(LU,9310) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
*9310 FORMAT(/15X,'Start at: ',I2,'/',I2,'/',I2,2X,I2.2,':',I2.2)
*     CALL BSDATE
*     WRITE(LU,9320) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
*9320 FORMAT(15X,'End   at: ',I2,'/',I2,'/',I2,2X,I2.2,':',I2.2)
      IF(LU.GT.0) WRITE(LU,9330)
 9330 FORMAT(/15X,'(1) For BASES              H: M:  Sec')
      CALL BSTCNV(TIMEBS(2),IH,MN,IS1,IS2)
      IF(LU.GT.0) WRITE(LU,9340) IH, MN, IS1, IS2
 9340 FORMAT(19X,'Overhead           : ',I3,':',I2,':',I2,'.',I2.2)
      CALL BSTCNV(TIMEBS(0),IH,MN,IS1,IS2)
      IF(LU.GT.0) WRITE(LU,9350) IH, MN, IS1, IS2
 9350 FORMAT(19X,'Grid Optim. Step   : ',I3,':',I2,':',I2,'.',I2.2)
      CALL BSTCNV(TIMEBS(1),IH,MN,IS1,IS2)
      IF(LU.GT.0) WRITE(LU,9360) IH, MN, IS1, IS2
 9360 FORMAT(19X,'Integration Step   : ',I3,':',I2,':',I2,'.',I2.2)
      XTIME = TIMEB2 - TIMEB1
      CALL BSTCNV(XTIME,IH,MN,IS1,IS2)
      IF(LU.GT.0) WRITE(LU,9365) IH, MN, IS1, IS2
 9365 FORMAT(19X,'Go time for all    : ',I3,':',I2,':',I2,'.',I2.2)
      EXTIM  = TIMEBS(1)*1000.0/SCALLS/0.7
      IF(LU.GT.0) WRITE(LU,9375)
 9375 FORMAT(/15X,'(2) Expected event generation time')
      IF(LU.GT.0) WRITE(LU,9376) EXTIM
 9376 FORMAT(19X,'Expected time for 1000 events :',F10.2,' Sec')
      RETURN
 
C----------------------------------------------------------- BASES
 
  400 NSP   = NG**NWILD
      MCALL = NSP*NPG
      IF(LU.GT.0) WRITE(LU,9400) NDIM,NWILD,MCALL,NCALL,ND,NG,NSP
 9400 FORMAT(
     .//5X,'<<   Parameters for BASES    >>',
     .//5X,' (1) Dimensions of integration etc.',
     . /5X,'     # of dimensions :    Ndim    =',I9,3X,'( 50 at max.)',
     . /5X,'     # of Wilds      :    Nwild   =',I9,3X,'( 15 at max.)',
     . /5X,'     # of sample points : Ncall   =',I9,'(real)',
     .                                         I9,'(given)',
     . /5X,'     # of subregions    : Ng      =',I9,' / variable',
     . /5X,'     # of regions       : Nregion =',I9,' / variable',
     . /5X,'     # of Hypercubes    : Ncube   =',I9,
     .//5X,' (2) About the integration variables')
      IF(LU.GT.0) WRITE(LU,9405)
 9405 FORMAT(10X,'------',2('+---------------'),'+-------+-------')
      IF(LU.GT.0) WRITE(LU,9410)
 9410 FORMAT(10X,'    i       XL(i)           XU(i)     ',
     .           '  IG(i)   Wild')
      IF(LU.GT.0) WRITE(LU,9405)
       DO 450 I = 1,NDIM
          IF( I .LE. NWILD ) THEN
          IF(LU.GT.0) WRITE(LU,9420) I,XL(I),XU(I),IG(I)
 9420     FORMAT(10X,I5,1P,2('  ',E14.6),'  ',3X,0P,I1,3X,
     .                       '   yes')
          ELSE
*         IF(LU.GT.0) WRITE(LU,9421) I,XL(I),XU(I),IG(I)
*9421     FORMAT(10X,I5,1P,2('  ',E14.6),'  ',3X,0P,I1,3X,
*    .                        '    no')
          ENDIF
  450  CONTINUE
       IF(LU.GT.0) WRITE(LU,9405)
       IF(LU.GT.0) WRITE(LU,9450) ITMX1,ACC1,ITMX2,ACC2
 9450  FORMAT(
     . /5X,' (3) Parameters for the grid optimization step',
     . /5X,'     Max.# of iterations: ITMX1 =',I9,
     . /5X,'     Expected accuracy  : Acc1  =',F9.4,' %',
     .//5X,' (4) Parameters for the integration step',
     . /5X,'     Max.# of iterations: ITMX2 =',I9,
     . /5X,'     Expected accuracy  : Acc2  =',F9.4,' %')
 
          RETURN
C----------------------------------------------------------- BASES
 
  500    IF( INTV .LE. 1 )    RETURN
         ISTEP  = IP1
         IF( IPNT .EQ. 0 ) THEN
             IF(LU.GT.0) WRITE(LU,9600)
         ELSE
             IF(LU.GT.0) WRITE(LU,9610) CN
         ENDIF
         IF(LU.GT.0) WRITE(LU,9620) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
         IF(LU.GT.0) WRITE(LU,9500) ICH(ISTEP)
 9500    FORMAT(15X,A)
         IF(LU.GT.0) WRITE(LU,9570)
         IF(LU.GT.0) WRITE(LU,9550)
 9550    FORMAT(1X,'<- Result of  each iteration ->',
     .          2X,'<-     Cumulative Result     ->',
     .          1X,'< CPU  time >',
     .         /1X,' IT Eff R_Neg   Estimate  Acc %',
     .          2X,'Estimate(+- Error )order  Acc %',
     .          1X,'( H: M: Sec )')
         IF(LU.GT.0) WRITE(LU,9570)
 9570    FORMAT(1X,7('----------'),'--------')
         RETURN
 
C----------------------------------------------------------- BASES
 
  600    IF( INTV .LE. 1 ) RETURN
         ISTEP  = IP1
         ITX = MOD( IT, ITM)
         IF( ITX .EQ. 0 ) ITX = ITM
 
         CALL BSLIST( LU, ITX, ISTEP )
 
         RETURN
 
  700    IF( INTV .LE. 1 ) RETURN
         IF(LU.GT.0) WRITE(LU,9570)
 
         RETURN
C----------------------------------------------------------- BASES
 
  800    ITJ    = IP1
         ISTEP  = IP2
         ITX  = MOD( ITJ, ITM )
         IF( ITX .EQ. 0 ) ITX = ITM
 
         IF( ITRAT(1,ISTEP) .EQ. 1 ) THEN
             NDEV   = 1
         ELSE
             NDEV   = 2
             ITFN   = ITM
             ITMN   = 10000
             DO 610 I = 1,ITM
                IF( ITRAT(I,ISTEP) .LT. ITMN ) THEN
                    ITST = I
                    ITMN = ITRAT(I,ISTEP)
                ENDIF
  610        CONTINUE
             IF( ITST .EQ. 1 ) NDEV = 1
         ENDIF
 
         IF( IPNT .EQ. 0 ) THEN
             IF(LU.GT.0) WRITE(LU,9600)
         ELSE
             IF(LU.GT.0) WRITE(LU,9610) CN
         ENDIF
         IF(LU.GT.0) WRITE(LU,9620) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
         IF(LU.GT.0) WRITE(LU,9500) ICH(ISTEP)
         IF(LU.GT.0) WRITE(LU,9570)
         IF(LU.GT.0) WRITE(LU,9550)
         IF(LU.GT.0) WRITE(LU,9570)
 
  625    IF( NDEV .EQ. 1 ) THEN
             ITST = 1
             ITFN = ITX
         ENDIF
 
         DO 650 I = ITST, ITFN
 
            CALL BSLIST( LU, I, ISTEP )
 
  650    CONTINUE
         NDEV  = NDEV - 1
         IF( NDEV .GT. 0 ) GO TO 625
         IF(LU.GT.0) WRITE(LU,9570)
 
      RETURN
 
C----------------------------------------------------------- BASES
 
  900 IF(LU.GT.0) WRITE(LU,9950)
 9950 FORMAT(1X,'******** FATAL ERROR IN BASES **************',
     .      /1X,'There are no enough good points in this iteration.',
     .      /1X,'Process was terminated due to this error.')
 
      RETURN
 
C-----------------------------------------------------------------
 1000 LOOP = IP1
      IF( IP2 .NE. 0 ) THEN
          IF( IPNT .EQ. 0 ) THEN
              IF(LU.GT.0) WRITE(LU,9600)
           ELSE
              IF(LU.GT.0) WRITE(LU,9610) CN
           ENDIF
           IF(LU.GT.0) WRITE(LU,9620) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
           IF(LU.GT.0) WRITE(LU,9650)
 9650      FORMAT(
     .      20X,'Results of Integration',
     .     /10X,5('----------'),'------',
     .     /10X,' Loop#  Estimate(+- Error )order',
     .                     '  It1  It2 ( H: M: Sec )',
     .     /10X,5('----------'),'------')
      ENDIF
 
      RE  = AVGI
      AC  = ABS(SD)
      ARE = ABS(RE)
      IF( ARE .GE. AC) THEN
          CALL BSORDR( ARE, F2, ORDER, IORDR)
      ELSE
          CALL BSORDR(  AC, F2, ORDER, IORDR )
      ENDIF
      RE  = RE/ORDER
      AC  = AC/ORDER
      CALL BSTCNV( STIME, IH, MN, IS1, IS2)
      IF(LU.GT.0) WRITE(LU,9660) LOOP,RE,AC,IORDR,IT1,IT,IH,MN,IS1,IS2
 9660 FORMAT(10X,I6,F10.6,'(+-',F8.6,')E',I3.2,2I5,
     .        1X,I3,':',I2,':',I2,'.',I2.2,
     .      /10X,5('----------'),'------')
 
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*========================                                             *
C*    SUBROUTINE BSPUTW( WEIGHT )                                      *
C*========================                                             *
C*((Function))                                                         *
C*    Put Weight                                                       *
C*                                                                     *
C*    Coded   by T.Ishikawa    Jun. 1995 at KEK                        *
C*    Last update              Jun. 1995 at KEK                        *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE BSPUTW( WEIGHT )
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
*
*========= Save the grid information for the best accuracy ===========
*
      WGT = WEIGHT
C
      RETURN
      END
************************************************************************
*                                                                      *
*    ==========================                                        *
      SUBROUTINE BSREAD( LUN )
*    ==========================                                        *
* ((Function))                                                         *
*     Read temporary result from the logocal unit LUN                  *
* ((Auther))                                                           *
*     S.Kawabata    June '90 at KEK                                    *
*                                                                      *
************************************************************************
 
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ ND1(5*MXDIM+3)
*     COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
*    .               IG(MXDIM),NCALL
C     COMMON /BASE2/ ND2(6)
*     COMMON /BASE2/ ACC1,ACC2,ITMX1,ITMX2
      COMMON /BASE3/ ND3(11)
*     COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
      COMMON /BASE4/ ND4(2*MXDIM*(NDMX+1)+4*LENG+MXDIM+3)
*     COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
*    .               ND,NG,NPG,MA(MXDIM)
      PARAMETER (ITM  = 50 )
*     COMMON /BASE5/ ND5(22*ITM)
      COMMON /BASE5/ ND5(23*ITM)
*     REAL*4 TIME, EFF, WRONG, TRSLT, TSTD, PCNT
*     COMMON /BASE5/ ITRAT(ITM,0:1),TIME(ITM,0:2),EFF(ITM,0:1),
*    .               WRONG(ITM,0:1),RESLT(ITM,0:1),ACSTD(ITM,0:1),
*    .               TRSLT(ITM,0:1),TSTD(ITM,0:1),PCNT(ITM,0:1)
      COMMON /RANDM/ ND6(45)

 
      PARAMETER ( NHS = 50, NSC = 50 )
      COMMON /PLOTH/ NPH(18*(NHS+NSC)+29),NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
*     INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
*     COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
*    .              NHIST, MAPL(4,NHS),
*    .              NSCAT, MAPD(4,NSC),
*    .              NW
 
      COMMON/NINFO/ NODEID, NUMNOD
 
*     print *,'<<bsread>> nodeid,lun',nodeid,lun
      IF( NODEID .NE. 0 ) RETURN
      if(lun.eq.0) return
      REWIND LUN
      READ(LUN) ND1,ND3,ND4,ND5,ND6,NPH
C     READ(LUN) ND1,ND2,ND3,ND4,ND5,ND6,NPH
 
      READ(LUN) NW,(IBUF(I),I=1,NW)
C
*     print *,'<<BSREAD>> fin'
      RETURN
      END
************************************************************************
*=================================================
      SUBROUTINE BSTCNV( TIME, IH, MN, IS1, IS2 )
*=================================================
* (Purpose)
*    Resolve TIME in second into IH, MN, IS1, IS2
* (Input)
*    TIME : in the unit of second
* (Output)
*    IH   : Hours
*    MN   : Minute
*    IS1  : Second
*    IS2  : 0.xx Second
* (Author)
*    S.Kawabata 1992 June 15
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*4 TIME
      INTEGER  HOUR
      DATA HOUR, MINUT, N100/ 360000, 6000, 100 /
 
      ISEC  = TIME*N100
      IH    = 0
      MN    = IH
      IF( ISEC .GE. MINUT ) THEN
          ITIME = ISEC
          IF( ISEC .GE. HOUR ) THEN
              IH    = ITIME/HOUR
              IHX   = IH*HOUR
              ITIME = ITIME - IHX
              ISEC  = ISEC - IHX
          ENDIF
          MN    = ITIME/MINUT
          ISEC  = ISEC - MN*MINUT
      ENDIF
      IS1  = ISEC/N100
      IS2  = MOD( ISEC, N100)
 
      RETURN
      END
*CMZ :          24/06/94  10.51.47  by  Unknown
*-- Author :
C
C***********************************************************************
C*=================================                                    *
C* SUBROUTINE BSTIME( TIME, IFLG )                                     *
C*=================================                                    *
C*((Purpose))                                                          *
C*        Interface routine to get used CPU time from FORTRAN          *
C*        Library routine CLOCK etc.                                   *
C*((Input))                                                            *
C*        IFLG  : Flag                                                 *
C*          IFLG = 0 : Initialization of clock routine.                *
C*          IFLG = 1 : Get used CPU time.                              *
C*((Output))                                                           *
C*        TIME  : Used CPU time in second.                             *
C*                                                                     *
C*       Coded by S.Kawabata        Oct. '85                           *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE BSTIME( TIME, IFLG )
C
      save time_init
C
 
      IF( IFLG .NE. 0 ) THEN
C
C         iutime.c should be compiled.
C
          TIME = uxtime() - time_init
*         CALL TIMEX(TIME)
C
      ELSE
 
          time_init = uxtime()
*         CALL TIMEST(9999999.)
          TIME      = 0.0
 
      ENDIF
C
      RETURN
      END
      SUBROUTINE BSUTIM( JOB, ID )
 
C     COMMON/NINFO/ NODEID, NUMNOD
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
 
*  Prior to call thisroutine, BSTIME( TIME0, 1 ) should be called
*  for initialize the time offset TIME0.
*
*     print *,'bsutim .. job, id ',job,id
      CALL BSTIME( RTIME, 1)
      DTIME      = RTIME - TIME0
 
      IF( JOB .EQ. 0 ) THEN
*       For BASES computing time
*         ID  = 0  : Grid defining step
*               1  : Integration step
*               2  : Others
 
          TIMEBS(ID) = TIMEBS(ID) + DTIME
 
          IF( ID .LE. 1 ) THEN
              TIMINT = TIMINT + DTIME
          ENDIF
      ELSE
*       For SPRING computing time
*         ID  = 0  : Event generation
*               1  : Overhead
*               2  : Others
 
          TIMESP(ID) = TIMESP(ID) + DTIME
 
      ENDIF
 
      TIME0      = RTIME
 
      RETURN
      END
************************************************************************
*                                                                      *
*    ==========================                                        *
      SUBROUTINE BSWRIT( LUN )
*    =====================                                             *
* ((Purpose))                                                          *
*     Read temporary result from disk file.                            *
* ((Auther))                                                           *
*     S.Kawabata  June '90 at KEK                                      *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ ND1(5*MXDIM+3)
*     COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
*    .               IG(MXDIM),NCALL
C     COMMON /BASE2/ ND2(6)
*     COMMON /BASE2/ ACC1,ACC2,ITMX1,ITMX2
      COMMON /BASE3/ ND3(11)
*     COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
      COMMON /BASE4/ ND4(2*MXDIM*(NDMX+1)+4*LENG+MXDIM+3)
*     COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
*    .               ND,NG,NPG,MA(MXDIM)
      PARAMETER (ITM  = 50 )
*     COMMON /BASE5/ ND5(22*ITM)
      COMMON /BASE5/ ND5(23*ITM)
*     REAL*4 TIME, EFF, WRONG, TRSLT, TSTD, PCNT
*     COMMON /BASE5/ ITRAT(ITM,0:1),TIME(ITM,0:2),EFF(ITM,0:1),
*    .               WRONG(ITM,0:1),RESLT(ITM,0:1),ACSTD(ITM,0:1),
*    .               TRSLT(ITM,0:1),TSTD(ITM,0:1),PCNT(ITM,0:1)
      COMMON /RANDM/ ND6(45)
 
      PARAMETER ( NHS = 50, NSC = 50 )
      COMMON /PLOTH/ NPH(18*(NHS+NSC)+29),NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
*     INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
*     COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
*    .              NHIST, MAPL(4,NHS),
*    .              NSCAT, MAPD(4,NSC),
*    .              NW
 
      COMMON/NINFO/ NODEID, NUMNOD
 
      IF( NODEID .NE. 0 ) RETURN
      IF(LUN.EQ.0) RETURN
      REWIND LUN
      WRITE(LUN) ND1,ND3,ND4,ND5,ND6,NPH
C     WRITE(LUN) ND1,ND2,ND3,ND4,ND5,ND6,NPH
      IF(NW .EQ. 0 ) NW = 281
      WRITE(LUN) NW,(IBUF(I),I=1,NW)
C
      RETURN
      END
************************************************************************
*    =======================================                           *
       SUBROUTINE DHFILL( ID, DX, DY, FX )
*    =======================================                           *
* ((Function))                                                         *
*     To fill scatter plot                                             *
*   This routine identifies the bin number which is to be updated      *
*   with weight FX*WGT.  Up to five points per plot are able to        *
*   be stacked before calling BHUPDT or SHUPDT.                        *
* ((Input))                                                            *
*   ID    : Histogram identification number                            *
*   DX    : Input x value                                              *
*   DY    : Input y value                                              *
*   FX    : Input value of the function                                *
* ((Author))                                                           *
*   S.Kawabata         June '90 at KEK                                 *
*                                                                      *
************************************************************************
 
      REAL*8 DX, DY, FX
      COMMON /BASE0/ IFLAG,IBASES
      REAL*8 SCALLS,WGT,TI,TSI,TACC
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C     COMMON /PLOTLU/ LU
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
*======================================================================*
*               Find the scatter plot ID in the table                  *
*======================================================================*
*                                                                      *
      IF( NSCAT .GT. 0 ) THEN
          I  = IABS(MOD( ID, 13 )) + 1
          IF( DHASH(1, I) .EQ. 1 ) THEN
            IF( ID .EQ. MAPD( 1, DHASH(2,I))) THEN
                ISCAT = DHASH(2,I)
                GO TO 200
            ENDIF
          ELSEIF( DHASH(1, I) .GT. 1 ) THEN
            DO 100 K = 2, DHASH(1,I)+1
               IF( ID .EQ. MAPD( 1, DHASH(K,I))) THEN
                   ISCAT = DHASH(K,I)
                   GO TO 200
               ENDIF
  100       CONTINUE
          ENDIF
      ENDIF
C     IF( LU .GT. 0 ) THEN
C         WRITE(LU,9000) ID
C9000     FORMAT(1X,'No Scat_Plot corresponds to ID =',I5,
C    .          /1X,' This call is neglected ]]]')
C     ENDIF
      RETURN
 
*                                                                      *
*======================================================================*
*               Determine the bin numbers for x and y                  *
*======================================================================*
*                                                                      *
  200 X     = DX*1.0
      Y     = DY*1.0
 
          IP1   = MAPD(2,ISCAT)
          XMIN  = BUFF(IP1)
          XMAX  = BUFF(IP1+1)
          MXBIN = IBUF(IP1+2)
          DEV   = BUFF(IP1+3)
          IX    =   0
          IY    =   0
          IF( X .GE. XMIN .AND. X .LE. XMAX ) THEN
              IX   = INT( (X - XMIN)/DEV+ 1.0 )
              IF( IX .GT. MXBIN ) IX =   0
          ENDIF
C
          IF( IX .GT. 0 ) THEN
              YMIN  = BUFF(IP1+4)
              YMAX  = BUFF(IP1+5)
              MYBIN = IBUF(IP1+6)
              DEV   = BUFF(IP1+7)
              IF( Y .GE. YMIN .AND. Y .LE. YMAX ) THEN
                  IY   = INT((Y - YMIN)/DEV + 1.0)
                 IF( IY .GT. MYBIN ) THEN
                     IX  =  0
                     IY  =  0
                 ENDIF
              ENDIF
          ENDIF
*                                                                      *
*======================================================================*
*               Fill the scatter plot ID                               *
*======================================================================*
*----------------------------------------------------------------------*
*               For BASES                                              *
*----------------------------------------------------------------------*
*                                                                      *
      IF( IBASES .EQ. 1 ) THEN
          IF( IY .GT. 0 ) THEN
 
              IP2       = MAPD(3,ISCAT)
              IBUF(IP2) = SCALLS
              IP2       = IX + MXBIN*(IY - 1) + IP2
              BUFF(IP2) = BUFF(IP2) + FX*WGT
 
          ENDIF
 
*----------------------------------------------------------------------*
*               For SPRING                                             *
*----------------------------------------------------------------------*
*                                                                      *
      ELSE
 
          IP3         = MAPD(4,ISCAT)
          IBUF(IP3)   = IX
          IBUF(IP3+1) = IY
 
      ENDIF
 
      RETURN
      END
************************************************************************
*  =================================================================== *
      SUBROUTINE DHINIT(ID,DXMIN,DXMAX,NXBIN,DYMIN,DYMAX,NYBIN,TNAME)
*  =================================================================== *
* ((Function))                                                         *
*     To define a scatter plot                                         *
* ((Input))                                                            *
*    ID   : scatter plot identification number                         *
*    DXMIN: Lower limit of X for the scatter plot                      *
*    DXMAX: Upper limit of X for the scatter plot                      *
*    NXBIN: Number of bins of X for the plot (Max. is 50 )             *
*    DYMIN: Lower limit of Y for the scatter plot                      *
*    DYMAX: Upper limit of Y for the scatter plot                      *
*    NYBIN: Number of bins of Y for the plot (Max. is 50 )             *
*    TNAME: Title of the plot in the character string (upto 64         *
*            characters)                                               *
* ((Author))                                                           *
*    S.Kawabata     June '90 at KEK                                    *
*                                                                      *
************************************************************************
 
      REAL*8 DXMIN,DXMAX,DYMIN,DYMAX
      CHARACTER*(*) TNAME
      CHARACTER*64 NAME
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
*     COMMON/XHCNTL/ LOCK
      COMMON/PLOTLU/ LU
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
*======================================================================*
*               Find the scatter plot ID in the table                  *
*======================================================================*
*                                                                      *
      IF( NSCAT .GE. NSC ) THEN
*         IF( LOCK .NE. 0 ) RETURN
          IF( LU .GT. 0 ) THEN
            IF(LU.GT.0) WRITE(LU,9000) NSCAT,ID
 9000       FORMAT(1X,'Numberof Scat_plots exceeds ',I3,' at ID = ',I3,
     .            /1X,'This call is neglected.')
          ENDIF
          RETURN
      ENDIF
 
      IEXIST = 0
      I  = IABS(MOD( ID, 13 )) + 1
      NS     = DHASH(1, I)
 
      IF( NS .EQ. 1 ) THEN
            IF( ID .EQ. MAPD( 1, DHASH(2,I))) THEN
*               IF( LOCK .NE. 0 ) RETURN
                IEXIST = DHASH(2,I)
            ENDIF
      ELSEIF( NS .GT. 1 ) THEN
          DO 100 K = 2, DHASH(1,I)+1
            IF( ID .EQ. MAPD( 1, DHASH(K,I))) THEN
*               IF( LOCK .NE. 0 ) RETURN
                IEXIST = DHASH(K,I)
                GO TO 110
            ENDIF
  100    CONTINUE
  110    CONTINUE
      ENDIF
      XMIN  = DXMIN*1.0
      XMAX  = DXMAX*1.0
      YMIN  = DYMIN*1.0
      YMAX  = DYMAX*1.0
 
      IF( IEXIST .GT. 0 ) THEN
          IF( LU .GT. 0 ) THEN
            IF(LU.GT.0) WRITE(LU,9100) ID
          ENDIF
 9100     FORMAT(1X,'Scat_Plot ID (',I3,' ) exists already.')
          IP1    =  MAPD(2,IEXIST)
          IF(( XMIN .EQ. BUFF(IP1))   .AND.
     .       ( XMAX .EQ. BUFF(IP1+1)) .AND.
     .       ( NXBIN .EQ. IBUF(IP1+2)) )    THEN
             IF(( YMIN .EQ. BUFF(IP1+4))   .AND.
     .          ( YMAX .EQ. BUFF(IP1+5)) .AND.
     .          ( NYBIN .EQ. IBUF(IP1+6)) )    THEN
                  IF( LU .GT. 0 ) THEN
                      IF(LU.GT.0) WRITE(LU,9110)
                  ENDIF
 9110             FORMAT(1X,' This call is neglected.')
                  RETURN
             ENDIF
          ENDIF
          IF( LU .GT. 0 ) THEN
              IF(LU.GT.0) 
     .        WRITE(LU,9120) ID,XMIN,XMAX,NXBIN,YMIN,YMAX,NYBIN
          ENDIF
 9120     FORMAT(1X,'Scat_Plot ( ID =',I3,' ) parameters are replaced',
     .          /1X,'by the following new parameters :',
     .          /1X,' XMIN(',E12.5,')  XMAX(',E12.5,' )  XBIN(',I4,' )',
     .          /1X,' YMIN(',E12.5,')  YMAX(',E12.5,' )  YBIN(',I4,' )')
      ENDIF
      IF(NXBIN .GT. 50 .OR. NYBIN .GT. 50 ) THEN
         IF( LU .GT. 0 ) THEN
             IF(LU.GT.0) WRITE(LU,9300) NXBIN,NYBIN,ID
         ENDIF
 9300    FORMAT(1X,'Bin size (',2I3,' )  exceeds 50 at ID =',I5,
     .         /1X,' This call is neglected .')
         RETURN
      ELSEIF((XMIN .GE. XMAX) .OR. (YMIN .GE. YMAX)) THEN
         IF( LU .GT. 0 ) THEN
             IF(LU.GT.0) WRITE(LU,9400) ID,XMIN,XMAX,YMIN,YMAX
         ENDIF
 9400    FORMAT(1X,'Lower limit is larger than upper at SC_PL ID =',I5,
     .         /1X,' This call is neglected .',
     .         /1X,' XMIN =',G13.4,' XMAX =',G13.4,
     .         /1X,' YMIN =',G13.4,' YMAX =',G13.4)
         RETURN
      ENDIF
      IF(DHASH(1,I) .GE. NSC ) THEN
         IF( LU .GT. 0 ) THEN
             IF(LU.GT.0) WRITE(LU,9500) I
         ENDIF
 9500    FORMAT(1X,I5,'-th Hash table overflow',
     .         /1X,' This call is neglected.')
         RETURN
      ENDIF
 
      IF( IEXIST .GT. 0 ) THEN
          NSCT     = IEXIST
      ELSE
          NSCAT        = NSCAT + 1
          DHASH(1,I)   = DHASH(1,I) + 1
          K            = DHASH(1,I) + 1
          DHASH(K,I)   = NSCAT
          NSCT         = NSCAT
          IP1    = NW + 1
          NW  = NW + 2527
          MAPD(1,NSCT)  = ID
          MAPD(2,NSCT)  = IP1
      ENDIF
 
         BUFF(IP1     ) = XMIN
         BUFF(IP1 +  1) = XMAX
         IBUF(IP1 +  2) = NXBIN
         DEV            = XMAX - XMIN
         BUFF(IP1 +  3) = DEV/NXBIN
         BUFF(IP1 +  4) = YMIN
         BUFF(IP1 +  5) = YMAX
         IBUF(IP1 +  6) = NYBIN
         DEV            = YMAX - YMIN
         BUFF(IP1 +  7) = DEV/NYBIN
      IP2   = IP1 + 8
         MAPD(3,NSCT)  = IP2
         IBUF(IP2     ) = 0
      IP3   = IP1 + 2509
         MAPD(4,NSCT)  = IP3
         IBUF(IP3     ) =  0
         IBUF(IP3 +  1) =  0
 
         I1   = IP3 + 2
         I2   = I1 + 15
         NAME = TNAME
         READ(NAME,9800) (BUFF(I),I=I1,I2)
 9800    FORMAT(16A4)
 
      RETURN
      END
************************************************************************
*     =========================                                        *
       SUBROUTINE DHPLOT( LU )
*     =========================                                        *
* ((Purpose))                                                          *
*      To print scatter plots for BASES and SPRING                     *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata    June '90                                         *
*                                                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
 
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      CHARACTER*1  PLUS,MINUS,BLNK,STAR,NUM(0:9),NEG(0:9),SHARP,PNT
      REAL*4       X(50)
      CHARACTER*1 CHARR(50), CN
      CHARACTER*80 FORM1,FORM
      DATA  PLUS /'+'/, MINUS /'-'/, BLNK /' '/, STAR /'*'/
      DATA  SHARP /'#'/,  PNT /'.'/
      DATA  NUM  / '0','1','2','3','4','5','6','7','8','9'/
      DATA  NEG  / '-','a','b','c','d','e','f','g','h','i'/
*                                                                      *
*--------------------------- Entry point ------------------------------*
*                                                                      *
      CN   = CHAR(12)
 
      IF( NSCAT .GT. 0 ) THEN
         DO 900 ISCAT = 1, NSCAT
            IP3   = MAPD(4,ISCAT)
            IF( IPNT .EQ. 0 ) THEN
                IF(LU.GT.0) WRITE(LU,9010)
            ELSE
                IF(LU.GT.0) WRITE(LU,9020) CN
            ENDIF
 9010       FORMAT(/1H1)
 9020       FORMAT(A1)
            IF(LU.GT.0) 
     .      WRITE(LU,9100) MAPD(1,ISCAT),(BUFF(I), I=IP3+2,IP3+17)
 9100       FORMAT(/5X,'Scat_Plot (ID =',I3,' ) for ',16A4,/)
 
            IP1   = MAPD(2,ISCAT)
            XL    = BUFF(IP1)
            XU    = BUFF(IP1+1)
            NX    = IBUF(IP1+2)
            DX    = BUFF(IP1+3)
            XM    = ABS(XU)
            XX    = ABS(XL)
            IF( XX .GT. XM ) XM = XX
            CALL XHORDR( XU, FX, XORD, IXORD)
            YL    = BUFF(IP1+4)
            YU    = BUFF(IP1+5)
            NY    = IBUF(IP1+6)
            DY    = BUFF(IP1+7)
            MIDY  = NY/2
            IF( MIDY .EQ. 0 ) MIDY = 1
            YM    = ABS(YU)
            YY    = ABS(YL)
            IF( YY .GT. YM ) YM = YY
            CALL XHORDR( YM, FY, YORD, IYORD)
            IP2   = MAPD(3,ISCAT)
            NTOTAL= IBUF(IP2)
            VMAX  = BUFF(IP2+1)
            VMIN  = VMAX
            DO 100 J = 0,NY-1
               IB    = NX*J + IP2
               DO 100 I = 1,NX
                  VLS    = BUFF( I + IB )
                  IF( VLS .GT. VMAX ) VMAX = VLS
                  IF( VLS .LT. VMIN ) VMIN = VLS
  100       CONTINUE
***
            IF( VMAX .EQ. 0.0 .AND. VMIN .EQ. 0.0 ) THEN
                VMAX  = 10.0
                VMIN  = 0.0
            ENDIF
***
            IF( VMAX .GT. -VMIN ) THEN
                UNIT = ABS(VMAX)/11.0
            ELSE
                UNIT = ABS(VMIN)/11.0
            ENDIF
            IF(LU.GT.0) WRITE(FORM1,9200) NX
*9200       FORMAT('(7X,''E'',I3,3X,''+'',',I2,'(''--''),''-+'')')
 9200       FORMAT('(7X,''E'',I3,3X,''+'',',I2,'(''-''),''+'')')
            IF(LU.GT.0) WRITE(LU,FORM1) IYORD
            DO 300 L = NY-1,0,-1
               IB     = NX*L + IP2
               DO 200 I = 1,NX
                 XNUM   = BUFF( I + IB )/UNIT
                 IF( XNUM .LT. 0 0 ) THEN
                     NUMB   = XNUM - 1.0
                     IF(     NUMB .GE. -1 )THEN
                             CHARR(I) = MINUS
                     ELSEIF( NUMB .GE. -10 ) THEN
                            CHARR(I) = NEG(-NUMB-1)
                     ELSE
                            CHARR(I) = SHARP
                     ENDIF
                 ELSE
                     NUMB   = XNUM + 1.0
                     IF(     XNUM .EQ. 0.0 ) THEN
                             CHARR(I) = BLNK
                     ELSEIF( NUMB .LE.  1 ) THEN
                             CHARR(I) = PLUS
                             IF( VMIN .GE. 0.0 ) CHARR(I) = PNT
                     ELSEIF( NUMB .LE. 10 ) THEN
                             CHARR(I) = NUM(NUMB-1)
                     ELSE
                             CHARR(I) = STAR
                     ENDIF
                 ENDIF
  200          CONTINUE
 
               Y   = (L*DY + YL)/YORD
               IF( L .EQ. MIDY ) THEN
                   IF(LU.GT.0) WRITE(FORM,9300) NX
*9300              FORMAT('(5X,F6.3,'' Y I'',',I2,'(1X,A1),'' I'')')
 9300              FORMAT('(5X,F6.3,'' Y I'',',I2,'A1,''I'')')
               ELSE
                   IF(LU.GT.0) WRITE(FORM,9310) NX
*9310              FORMAT('(5X,F6.3,''   I'',',I2,'(1X,A1),'' I'')')
 9310              FORMAT('(5X,F6.3,''   I'',',I2,'A1,''I'')')
               ENDIF
               IF(LU.GT.0) WRITE(LU,FORM) Y,(CHARR(M),M=1,NX)
 
  300       CONTINUE
 
            IF(LU.GT.0) WRITE(LU,FORM1) IYORD
 
            NXH   = NX/2
            IF( NXH .EQ. 0 ) NXH = 1
            IF(LU.GT.0) WRITE(FORM,9400) NXH
 
*           IF(LU.GT.0) WRITE(FORM,9400) NX
 9400       FORMAT('(6X,''Low-'',5X,',I2,'X,''X'')')
            IF(LU.GT.0) WRITE(LU,FORM)
 
            XORD     = XORD*10.
            DO 400 I = 1, NX
               X(I)  = ((I-1)*DX + XL)/XORD
               IF( X(I) .LT. 0.0 ) THEN
                   CHARR(I)  = MINUS
                   X(I)      = -X(I)
               ELSE
                   CHARR(I)  = BLNK
               ENDIF
  400       CONTINUE
            IF(LU.GT.0) WRITE(FORM1,9500) NX
*9500       FORMAT('(6X,''Edge'',5X,',I2,'(1X,A1))')
 9500       FORMAT('(6X,''Edge'',5X,',I2,'A1)')
            IF(LU.GT.0) WRITE(LU,FORM1) (CHARR(M),M=1,NX)
 
            XORD      = 1.0
            DO 600 I  = 1,5
               IF( I .EQ. 2 ) THEN
                   IF(LU.GT.0) WRITE(FORM,9602) NX
 9602              FORMAT('(7X,''E'',I3,4X',I2,
     .                    '(''.''))')
                   IF(LU.GT.0) WRITE(LU,FORM) IXORD
               ELSE
                   DO 500 J = 1, NX
                      XX        = X(J)*10.0
                      NUMB      = XX
                      CHARR(J)  = NUM(NUMB)
                      X(J)      = XX - FLOAT(NUMB)
  500              CONTINUE
                   IF(     I .EQ. 4 ) THEN
                           IF(LU.GT.0) WRITE(FORM,9604) NX
 9604                      FORMAT('(7X,''Low-'',4X,',I2,
     .                            'A1)')
                   ELSEIF( I .EQ. 5 ) THEN
                           IF(LU.GT.0) WRITE(FORM,9605) NX
 9605                      FORMAT('(7X,''Edge'',4X,',I2,
     .                            'A1)')
                   ELSE
                           IF(LU.GT.0) WRITE(FORM,9601) NX
 9601                      FORMAT('(15X,',I2,
     .                            'A1)')
                   ENDIF
                   IF(LU.GT.0) WRITE(LU,FORM) (CHARR(M),M=1,NX)
               ENDIF
  600       CONTINUE
 
  900    CONTINUE
      ENDIF
C
      RETURN
      END
C**********************************************************************
C*======================                                              *
C* FUNCTION DRN( ISEED)                                               *
C*======================                                              *
C*  Machine-independent Random number generator                       *
C*     General purpose Version,  OK as long as >= 32 bits             *
C*((Arguement))                                                       *
C*  ISEED: Seed                                                       *
C*                                                                    *
C**********************************************************************
 
*     REAL FUNCTION DRN*8(ISEED)
      DOUBLE PRECISION FUNCTION DRN(ISEED)
 
      COMMON/RANDM/RDM(31),RM1,RM2,IA1,IC1,M1,IX1,
     .                             IA2,IC2,M2,IX2,
     .                             IA3,IC3,M3,IX3
 
C Generate Next number in sequence
 
      IX1    = MOD( IA1*IX1+IC1, M1 )
      IX2    = MOD( IA2*IX2+IC2, M2 )
      IX3    = MOD( IA3*IX3+IC3, M3 )
      J      = 1 + (31*IX3)/M3
      DRN    = RDM(J)
      RDM(J) = ( FLOAT(IX1)+FLOAT(IX2)*RM2 )*RM1
 
C Omit following statement if function arguement passed by value:
 
      ISEED = IX1
      RETURN
      END
C**********************************************************************
C*============================                                        *
C* Subroutine DRNSET( ISEED )                                         *
C*============================                                        *
C*((Purpose))                                                         *
C*  Initialization routine of                                         *
C*         Machine-independent Random number generator                *
C*         General purpose Version,  OK as long as >= 32 bits         *
C*((Arguement))                                                       *
C*  ISEED: SEED                                                       *
C*                                                                    *
C**********************************************************************
 
      SUBROUTINE DRNSET( ISEED )
 
      COMMON/RANDM/RDM(31),RM1,RM2,IA1,IC1,M1,IX1,
     .                             IA2,IC2,M2,IX2,
     .                             IA3,IC3,M3,IX3
 
      IA1 =    1279
      IC1 =  351762
      M1  = 1664557
      IA2 =    2011
      IC2 =  221592
      M2  = 1048583
      IA3 =   15091
      IC3 =    6171
      M3  =   29201
C Initialization
 
      IX1  = MOD( ISEED, M1 )
      IX1  = MOD( IA1*IX1+IC1, M1 )
      IX2  = MOD( IX1, M2 )
      IX1  = MOD( IA1*IX1+IC1, M1 )
      IX3  = MOD( IX1,M3)
      RM1  = 1./FLOAT(M1)
      RM2  = 1./FLOAT(M2)
      DO 100 J = 1,31
         IX1   = MOD( IA1*IX1+IC1, M1 )
         IX2   = MOD( IA2*IX2+IC2, M2 )
         RDM(J)= ( FLOAT(IX1)+FLOAT(IX2)*RM2 )*RM1
  100 CONTINUE
 
      RETURN
      END
      Subroutine setrnd(is)
      integer*4 is, iseed
      COMMON /RNDSEED/ISEED
      iseed=is
      return
      end
************************************************************************
*    ===================                                               *
      SUBROUTINE SHCLER
*    ===================                                               *
* ((FUNCTION))                                                         *
*     To cancel the update of histograms and scatter plots in case     *
*   of the trial was rejected.                                         *
* ((Author))                                                           *
*     S.Kawabata June '90 at KEK                                       *
*                                                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C
C    update for QEDPS on June 13. '97
C
      COMMON /PLOTC/ NHIT(NHS), IXSP(50,NHS)
 
      IF( NHIST .GT. 0 ) THEN
         DO 200  J   = 1, NHIST
           IP3       = MAPL(3,J)
           IBUF(IP3) = -1
C         update for QEDPS on June 13. '97
           NHIT(J)     = 0
  200    CONTINUE
      ENDIF
C
      IF( NSCAT .GT. 0 ) THEN
         DO 500   K    = 1, NSCAT
           IP3         = MAPD(4,K)
           IBUF(IP3)   =  0
           IBUF(IP3+1) =  0
  500    CONTINUE
      ENDIF
C
      RETURN
      END
************************************************************************
*    ===========================                                       *
      SUBROUTINE SHFILL( NTRY )
*    ===========================                                       *
* ((Function))                                                         *
*     To fill the number of trials for a event generation              *
* ((Input))                                                            *
*    NTYR : the number of trials for the current event                 *
* ((Author))                                                           *
*    S.Kawabata    April 1994                                          *
*                                                                      *
************************************************************************
 
      PARAMETER ( MXBIN = 51 )
      COMMON/PLOTSP/ NBIN,IBUFSP( MXBIN )
 
      IF( NTRY .LE. NBIN ) THEN
          IBUFSP( NTRY ) = IBUFSP( NTRY ) + 1
      ELSE
          IBUFSP( NBIN+1 ) = IBUFSP( NBIN+1 ) + 1
      ENDIF
 
      RETURN
      END
************************************************************************
*    ============================                                      *
      SUBROUTINE SHINIT( MXTRY )
*    ============================                                      *
* ((Function))                                                         *
*     To clear the histogram buffer for generation efficiency          *
* ((Input))                                                            *
*    MXTRY: Maximum number of trials for one event generation          *
* ((Author))                                                           *
*    S.Kawabata    April 1994                                          *
*                                                                      *
************************************************************************
 
      INTEGER MXTRY
      PARAMETER ( MXBIN = 51 )
      COMMON/PLOTSP/ NBIN,IBUFSP( MXBIN )
 
      IF( MXTRY .GT. 50 ) THEN
          NBIN  = 50
      ELSE
          NBIN  = MXTRY
      ENDIF
 
      DO 100 I = 1,NBIN+1
         IBUFSP(I) = 0
  100 CONTINUE
 
      RETURN
      END
************************************************************************
*    =========================                                         *
      SUBROUTINE SHPLOT( LU )
*    =========================                                         *
C*((Function))                                                         *
C*    To print histograms and scatter plots defined by XHINIT and      *
C*  DHINIT.                                                            *
C*    For the original histograms, a special histograms are printd     *
C*  by this routine. For the additional histograms and scatter plots   *
C*  routines XHPLOT and DHPLOT are called.                             *
C*((Author))                                                           *
C*    S.Kawabata   June '90 at KEK                                     *
C*                                                                     *
C***********************************************************************
 
      REAL*8         SCALLS,WGT,TI,TSI,TACC
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
 
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      CHARACTER*50 CHARR,CHR1
      CHARACTER*52 SCALE
      REAL  VAL(0:51),VLOG(0:51)
      REAL  VERR(0:51)
      CHARACTER*1  BLNK,STAR,CROS,AI,CN
      DATA  YMAX / 50/, BLNK /' '/, STAR /'*'/, CROS /'O'/
      DATA  AI /'I'/
 
      CN  = CHAR(12)
 
      CALL XHCHCK( LU )
 
      IF( NHIST .GT. 0 ) THEN
*                 add March 1994
         CALL SHUPDT
*
C        NTOTAL= SCALLS
         DO 500 IHIST = 1, NHIST
          IF(IFBASE(IHIST) .EQ. 1 ) THEN
            IP3  = MAPL(4,IHIST)
            IF( IPNT .EQ. 0 ) THEN
                IF(LU.GT.0) WRITE(LU,9010)
            ELSE
                IF(LU.GT.0) WRITE(LU,9020) CN
            ENDIF
 9010       FORMAT(/1H1)
 9020       FORMAT(A1)
            IF(LU.GT.0) 
     .      WRITE(LU,9050) MAPL(1,IHIST),(BUFF(I), I=IP3+1,IP3+15)
 9050       FORMAT(1X,'Original Histogram (ID =',I3,' ) for ',15A4)
 
            IP1   = MAPL(2,IHIST)
            XMIN  = BUFF(IP1)
            XMAX  = BUFF(IP1+1)
            NXBIN = IBUF(IP1+2) + 1
            DEV   = BUFF(IP1+3)
            VMAX  = 0.0
            VORG  = 0.0
            VEVT  = 0.0
C           FACT       = 1./(NTOTAL*DEV)
            FACT       = 1./(SCALLS*DEV)
            IP2   = MAPL(3,IHIST)
            IPX   = IP2 + 52
            IPF   = IP2 + 156
            IPF2  = IPF + 52
C           VAL(0)     = BUFF(IPF)/NTOTAL
            VAL(0)     = BUFF(IPF)/SCALLS
C           VAL(NXBIN) = BUFF(IPF+NXBIN)/NTOTAL
            VAL(NXBIN) = BUFF(IPF+NXBIN)/SCALLS
            VEVT1 = BUFF(IPX) + BUFF(IPX+NXBIN)
            DO  50 I   = 1,NXBIN-1
                TX     = BUFF(I+IPF)
                NX     = IBUF(I+IP2)
                VLS    = TX*FACT
                IF( VMAX .LT. VLS ) VMAX = VLS
                VAL(I) = VLS
                IF( NX .GT. 1 ) THEN
                  DEV2   =  NX*BUFF(I+IPF2)-TX*TX
                  IF( DEV2 .LE. 0.0 ) THEN
                      VERR(I)= 0.0
                  ELSE
                      VERR(I)= FACT*SQRT( DEV2/( NX-1 ))
                  ENDIF
*TI             ELSEIF( NX .EQ. 1 ) THEN
*TI               VERR(I)= VLS
                ELSE
                  VERR(I)= 0.0
                ENDIF
                VORG   = VLS + VORG
                VEVT   = BUFF(I+IPX) + VEVT
   50       CONTINUE
            NTOT   = INT(VEVT+VEVT1)
            IF( VMAX .LE. 0.0 .AND. VEVT .GT. 0.0 ) THEN
                  IF(LU.GT.0) WRITE(LU,9060) MAPL(1,IHIST)
 9060             FORMAT(/5X,'***************************************',
     .                   /5X,'* Since BASES has no entry            *',
     .                   /5X,'*     in the histogram ID(',I6,' ),   *',
     .                   /5X,'*  an additional hist. is given       *',
     .                   /5X,'*     in the next page in stead.      *',
     .                   /5X,'***************************************')
C
                  CALL XHPLOT( LU, 1, IHIST )
C
                  GO TO 500
            ELSEIF( VEVT .LE. 0) THEN
                  IF(LU.GT.0) WRITE(LU,9070) IHIST
 9070             FORMAT(/5X,'***************************************',
     .                   /5X,'*    SPRING has no entry              *',
     .                   /5X,'*     in the histogram ID(',I6,' )    *',
     .                   /5X,'***************************************')
                  GO TO 500
            ENDIF
            VNORM = VORG/VEVT
            XNORM = VNORM*DEV
            VLMAX = ALOG10(VMAX)
            VLMIN = VLMAX
            DO  60 I = 0,NXBIN
              IF( VAL(I) .GT. 0.0 ) THEN
                  VLS   = ALOG10( VAL(I) )
                 IF( I .GT. 0 .AND. I .LT. NXBIN ) THEN
                    IF( VLS .LT. VLMIN ) VLMIN = VLS
                 ENDIF
                 VLOG(I)  = VLS
              ELSE
                 VLOG(I)  = 0.0
              ENDIF
   60       CONTINUE
C
             VXMAX = VLMAX
             IF( VLMIN .LT. 0.0) THEN
                VXMIN = IFIX(VLMIN) - 1.0
             ELSE
                VXMIN = IFIX(VLMIN)
             ENDIF
             CALL XHRNGE( 1, VXMIN, VXMAX, VLMIN, VLMAX, VLSTP)
             UNITL = (VLMAX-VLMIN)/YMAX
C
             CALL XHSCLE( 1, VLMIN, VLMAX, VLSTP, UNITL, SCALE, CHR1)
C
C
             IF(LU.GT.0) WRITE(LU,9150) NTOT
 9150        FORMAT(1X,'Total =',I10,' events',
     .              3X,'"*" : Orig. Dist. in Log Scale.')
             VXMIN = 10.0**VLMIN
             IF(LU.GT.0) WRITE(LU,9200) SCALE
 9200        FORMAT(1X,'   x      d(Sig/dx)  dN/dx',A52)
             IF(LU.GT.0) WRITE(LU,9250) CHR1
 9250        FORMAT(1X,
     .             '+-------+----------+-------+',
     .       A50 )
C
 
            VX    = ABS(XMAX)
            XM    = ABS(XMIN)
            IF( XM .GT. VX ) VX = XM
 
            CALL XHORDR( VX, F2, ORD, IORD )
 
            DO 200 I = 0,NXBIN
              RNORM = VNORM
              IF( I .EQ. 0 .OR. I .EQ. NXBIN ) RNORM = XNORM
              VX    = VAL(I)
              XL     = BUFF( I + IPX )
              NX     = XL
              IF( VX .GT. 0.0 ) THEN
                 NUMBL  = (VLOG(I) - VLMIN)/UNITL + 1.0
              ELSE
                 NUMBL  = 0
              ENDIF
              IF( NX .GT. 0 ) THEN
                 NUMB   = ( LOG10( XL*RNORM ) - VLMIN)/UNITL + 1.0
                 ERL    = SQRT(XL)
                 DERL   = (XL + ERL)*RNORM
                 NERUP  = ( LOG10( DERL ) - VLMIN)/UNITL + 1.0
                 DERL   = (XL - ERL)*RNORM
                 IF( DERL .GT. 0.0 ) THEN
                     NERLW  = ( LOG10( DERL ) - VLMIN)/UNITL + 1.0
                 ELSE
                     NERLW  = 0
                 ENDIF
              ELSE
                 NUMB   = 0
                 NERUP  = 0
                 NERLW  = 0
              ENDIF
              IF( NUMB  .GT. 50 ) NUMB = 50
              IF( NUMBL .GT. 50 ) NUMBL= 50
              DO 100 K = 1,50
                IF( K .LE. NUMBL) THEN
                  CHARR(K:K) = STAR
                ELSE
                  IF( K .EQ. 50 ) THEN
                    CHARR(K:K) = AI
                  ELSE
                    CHARR(K:K) = BLNK
                  ENDIF
                ENDIF
C
                IF(     K .EQ. NUMB ) THEN
                        CHARR(K:K) = CROS
                        IF( K .EQ. NERUP .AND. K .EQ. NERLW ) GO TO 100
                ENDIF
                IF(     K .EQ. NERUP ) THEN
                        CHARR(K:K) = '>'
                ELSEIF( K .EQ. NERLW ) THEN
                        CHARR(K:K) = '<'
                ENDIF
 
  100         CONTINUE
 
              CALL XHORDR( VX, F2, ORDER, IORDR )
 
             IF( I .EQ. 0 .OR. I .EQ. NXBIN ) THEN
                 IF(LU.GT.0) WRITE(LU,9300) IORD,F2,IORDR,NX,CHARR
 9300            FORMAT(1X,'I  E',I3,' I',F6.3,'E',I3,'I',
     .                                            I7,'I',A50)
             ELSE
                   XM    = (XMIN + DEV*(I-1))/ORD
                   IF(LU.GT.0) WRITE(LU,9340) XM,F2,IORDR,NX,CHARR
 9340              FORMAT(1X,'I',F6.3,' I',F6.3,'E',I3,'I',
     .                                        I7,'I',A50)
             ENDIF
  200       CONTINUE
             IF(LU.GT.0) WRITE(LU,9250) CHR1
             IF(LU.GT.0) WRITE(LU,9260)
 9260    FORMAT(1X,
     .       '   x      d(Sig/dx)  dN/dx',4X,
     .       '"O" : Generated Events.',
     .       '( Arbitrary unit in Log )')
C
           ELSE
C
              CALL XHPLOT( LU, 1, IHIST )
C
           ENDIF
  500    CONTINUE
      ENDIF
C
      CALL DHPLOT( LU )
C
      RETURN
      END
************************************************************************
*    ====================                                              *
      SUBROUTINE SHRSET
*    ====================                                              *
* ((Function))                                                         *
*     To reset the content of histograms and scatter plots.            *
* ((Author))                                                           *
*     S.Kawabata   June '90 at KEK                                     *
*                                                                      *
* **********************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C
C   update for QEDPS on June 16. '97
C
      COMMON /PLOTC/ NHIT(NHS), IXSP(50,NHS)

      IF( NHIST .GT. 0 ) THEN
         DO 100 IHIST = 1, NHIST
            IP2       = MAPL(3,IHIST) + 52
            IP3       = MAPL(4,IHIST)
            IBUF(IP3) = -1
            NHIT(IHIST) = 0
            DO 100 I = 0,51
               BUFF(I+IP2) = 0.0
  100      CONTINUE
      ENDIF
C
      IF( NSCAT .GT. 0 ) THEN
         DO 400   ISCAT = 1, NSCAT
            IP3         = MAPD(4,ISCAT)
            IBUF(IP3)   = 0
            IBUF(IP3+1) = 0
            IP2         = MAPD(3,ISCAT)
            IBUF(IP2)   = 0
            DO 400   I  = IP2+1,IP2+2500
               BUFF(I)  = 0.0
  400      CONTINUE
      ENDIF
C
      RETURN
      END
************************************************************************
*    ====================                                              *
      SUBROUTINE SHUPDT
*    ====================                                              *
* ((Function))                                                         *
*     To update histograms and scatter plots with unit weight.         *
*   The bin number to be updated is marked by XHFILL and DHFILL.       *
* ((Author))                                                           *
*     S.Kawabata  June '90 at KEK                                      *
*                                                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C
C   update for QEDPS on June 13. '97
C
      COMMON /PLOTC/ NHIT(NHS), IXSP(50,NHS)
 
      IF( NHIST .GT. 0 ) THEN
         DO 150   IHIST   = 1, NHIST
            IP3       = MAPL(4,IHIST)
C
C   update for QEDPS on June 13. '97
C
*           IX        = IBUF(IP3)
            NOHIT    = NHIT(IHIST)
            DO 140 I = 1, NOHIT
               IX    = IXSP( I, IHIST)
               IF( IX .GE. 0 ) THEN
                   IP       = IX + MAPL(3,IHIST) + 52
                   BUFF(IP) = BUFF(IP) + 1.
 
                   IBUF(IP3)  = -1
               ENDIF
  140       CONTINUE
            NHIT(IHIST) = 0
  150    CONTINUE
      ENDIF
C
      IF( NSCAT .GT. 0 ) THEN
         DO 250   ISCAT   = 1, NSCAT
            IP3         = MAPD(4,ISCAT)
            IX          = IBUF(IP3)
            IF( IX .GT. 0 ) THEN
                IP1   = MAPD(2,ISCAT)
                MXBIN = IBUF(IP1+2)
                MYBIN = IBUF(IP1+6)
                IP2       = MAPD(3,ISCAT)
                IBUF(IP2) = IBUF(IP2) + 1
                IY        = IBUF(IP3+1)
                IF( IX .GT. 0 .AND. IX .LE. MXBIN .AND.
     .              IY .GT. 0 .AND. IY .LE. MYBIN ) THEN
                    IP       = IX + MXBIN*(IY-1) + IP2
                    BUFF(IP) = BUFF(IP) + 1.0
                ENDIF
                IBUF(IP3)   =  0
                IBUF(IP3+1) =  0
           ENDIF
C
  250    CONTINUE
      ENDIF
C
      RETURN
      END
************************************************************************
*    ===================                                               *
      SUBROUTINE SPCHCK
*    ===================                                               *
* ((Purpose))                                                          *
*     To check user's initialization parameters.                       *
*                                                                      *
*        Coded by S.Kawabata      April  '94                           *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER ( MXDIM = 100)
      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2
 
      COMMON /BASE0/ JFLAG,IBASES
      COMMON /BASE1/ XLT(MXDIM),XUT(MXDIM),NDIMT,NWILDT,
     .               IGT(MXDIM),NCALLT
      COMMON /BASE2/ ACC1T,ACC2T,ITMX1T,ITMX2T
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      IF( NDIM .NE. NDIMT ) THEN
          WRITE(6,9100) NDIM,NDIMT
 9100     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   Given NDIM(',I6,' ) does not match          *',
     .    /5X,'*      to NDIM(',I6,' ) in BASES.               *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
          STOP
      ENDIF
 
      IF( NWILD .NE. NWILDT ) THEN
          WRITE(6,9110) NWILD,NWILDT
 9110     FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   Given NWILD(',I6,' ) does not match         *',
     .    /5X,'*      to NWILD(',I6,' ) in BASES.              *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
          STOP
      ENDIF
 
      DO 200 I = 1,NDIM
         IF( XL(I) .NE. XLT(I) ) THEN
             WRITE(6,9200) I,XL(I),I,XLT(I)
 9200        FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   Given XL(',I3,' ) = ',D15.8,'            *',
     .    /5X,'*      does not match to                        *',
     .    /5X,'*      to XL(',I3,' ) = ',D15.8,' in BASES   *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
             STOP
         ENDIF
         IF( XU(I) .NE. XUT(I) ) THEN
             WRITE(6,9210) I,XU(I),I,XUT(I)
 9210        FORMAT(
     .     5X,'*************************************************',
     .    /5X,'*                                               *',
     .    /5X,'*   Given XU(',I3,' ) = ',D15.8,'            *',
     .    /5X,'*      does not match to                        *',
     .    /5X,'*      to XU(',I3,' ) = ',D15.8,' in BASES   *',
     .    /5X,'*                                               *',
     .    /5X,'*   Process was terminated due to this error.   *',
     .    /5X,'*                                               *',
     .    /5X,'*************************************************')
             STOP
         ENDIF
  200 CONTINUE
 
      RETURN
      END
************************************************************************
*    ===============================                                   *
      SUBROUTINE SPHBOK( IOFSET )
*    ===============================                                   *
* ((Purpose))                                                          *
*      To write the ID-th histogram on the unit LUNIT.                 *
* ((Input))                                                            *
*      LUNIT: Logical unit number                                      *
*      ID   : Historgram ID                                            *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata   June '90 at KEK                                   *
*                                                                      *
************************************************************************
 
      COMMON /SPRNG2/ MXTRY,NEVENT, NTRIAL, MISS 

      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))

      CHARACTER*80 TITLE
 
      COMMON/PLOTLU/ LU

      REAL*4 COUNT(NHS), ECOUNT(NHS)
 
C
      IF( NHIST .GT. 0 ) THEN


          DO 500 IHIST = 1, NHIST
C                             ID1 : ID number of IHIST-th histogram
C                             BMAX : Maximum content of Hist ID1 from BASES
             IFLH  = IFBASE(IHIST)
             IF( IFLH .EQ. 1 ) THEN
                 ID1   = MAPL(1,IHIST)
                 BSUM  = HSUM( ID1 )
             ELSE
                 BSUM  = 0.0
             ENDIF

             ID    = MAPL(1,IHIST)
             ID    = ID + IOFSET + 20000
             IP1   = MAPL(2,IHIST)
             XMIN  = BUFF(IP1)
             XMAX  = BUFF(IP1+1)
             NXBIN = IBUF(IP1+2)
             DEV   = BUFF(IP1+3)
             IP2   = MAPL(3,IHIST)
             IP3   = MAPL(4,IHIST)
 
 
             WRITE( TITLE, 9500) (BUFF(I), I=IP3+1,IP3+16)
 9500        FORMAT(16A4)

             CALL HBOOK1( ID, TITLE, NXBIN, XMIN, XMAX, 0.0 )

             IPX   = IP2 + 52
C               To obtain the maximum content of Spring hist ID1
             SSUM  = NEVENT
C                        FACT : Normalization factor
             FACT  = BSUM/SSUM
             DO  400 I   = 0, NXBIN

                 XX     = XMIN + DEV*(FLOAT(I) - 0.5)
 
	        CALL HFILL( ID, XX, 0.0, BUFF( I + IPX ) )

                COUNT(I)  = BUFF( I+IPX )
                ECOUNT(I) = SQRT( BUFF( I+IPX ) )
                IF( IFLH .EQ. 1 ) THEN
                    COUNT(I) = COUNT(I) * FACT
                    ECOUNT(I) = ECOUNT(I) * FACT
                ENDIF
  400        CONTINUE

             CALL HPAK(  ID,  COUNT )
             CALL HPAKE( ID, ECOUNT )
 
  500     CONTINUE

      ENDIF

      IF( NSCAT .GT. 0 ) THEN
         DO 900 ISCAT = 1, NSCAT
 
            IP3   = MAPD(4,ISCAT)
 
            WRITE( TITLE, 9500) (BUFF(I), I=IP3+2,IP3+17)

            ID    = MAPD(1,ISCAT)
            ID    = ID + IOFSET + 30000
 
            IP1   = MAPD(2,ISCAT)
            XL    = BUFF(IP1)
            XU    = BUFF(IP1+1)
            NX    = IBUF(IP1+2)
            DX    = BUFF(IP1+3)
            YL    = BUFF(IP1+4)
            YU    = BUFF(IP1+5)
            NY    = IBUF(IP1+6)
            DY    = BUFF(IP1+7)

            CALL HBOOK2( ID, TITLE, NX, XL, XU, NY, YL, YU, 0.0 )
 
            IP2   = MAPD(3,ISCAT)
            
            DO 700 L = 0, NY-1
               IB     = NX*L + IP2
               DO 600 I = 1,NX

                  XX    = XL + DX*(FLOAT(I) - 0.5)
                  YY    = YL + DY*(FLOAT(L) - 0.5)
 
                  CALL HFILL( ID, XX, YY, BUFF( I + IB ) )

  600          CONTINUE
  700       CONTINUE
 
  900    CONTINUE
      ENDIF
 
      RETURN
      END
************************************************************************
*    =========================                                         *
      SUBROUTINE SPHIST( LU )
*    =========================                                         *
* ((Purpose))                                                          *
*      To print the histogram for event generation                     *
* ((Input))                                                            *
*      LU   : logical unit number for the printer to be printed        *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata    April 1994                                       *
*                                                                      *
************************************************************************
 
      PARAMETER ( MXBIN = 51 )
      COMMON/PLOTSP/ NBIN,IBUFSP( MXBIN )
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      REAL  VAL(MXBIN),VLOG(MXBIN)
      CHARACTER*50 CHARR,CHAR1
      CHARACTER*52 SCALE
      CHARACTER*1  BLNK,STAR,OO,AI,CN
      DATA  YMAX / 50/
      DATA  BLNK /' '/, STAR /'*'/, OO /'O'/, AI /'I'/
 
      CN    = CHAR(12)
      IF( IPNT .EQ. 0 ) THEN
          IF(LU.GT.0) WRITE(LU,9000)
 9000     FORMAT(/1H1,/1H )
      ELSE
          IF(LU.GT.0) WRITE(LU,9005) CN
 9005     FORMAT(A1)
      ENDIF
          IF(LU.GT.0) WRITE(LU,9102)
 9102     FORMAT(5X,
     .  '************* Number of trials to get an event *************')
 
      XMIN  = 1.0
      XMAX  = NBIN
      DEV   = 1.0
      NBIN1 = NBIN + 1
 
          NTOTAL     = IBUFSP(NBIN1)
          VAL(NBIN1) = FLOAT(NTOTAL)
          VMIN       = 0.0
          VMAX       = VMIN
          DO  55 I   = 1,NBIN
              NTR    = IBUFSP(I)
              VLS    = FLOAT( NTR )
              NTOTAL = NTR + NTOTAL
              IF( VMAX .LT. VLS ) VMAX = VLS
              VAL(I) = VLS
   55     CONTINUE
 
          VLMAX = LOG10(VMAX)
          VLMIN = VLMAX
 
           DO  60 I = 1,NBIN1
               IF( VAL(I) .GT. 0.0 ) THEN
                   VLS   = LOG10( VAL(I) )
                   IF( I .LE. NBIN ) THEN
                       IF( VLS .LT. VLMIN ) VLMIN = VLS
                   ENDIF
                   VLOG(I)  = VLS
               ENDIF
   60      CONTINUE
 
           IF( VLMIN .LT. 0.0) THEN
               VXMIN = IFIX(VLMIN) - 1.0
           ELSE
               VXMIN = IFIX(VLMIN)
           ENDIF
           VXMAX = VLMAX
           IFLG  = 1
           CALL XHRNGE( IFLG, VXMIN, VXMAX, VLMIN, VLMAX, VLSTP )
           UNITL = (VLMAX-VLMIN)/YMAX
 
       IFLG   = 0
           IF( VMIN .GE. 0.0 ) THEN
               VXMAX  = 1.2*VMAX
               VXMIN  = 0.0
               CALL XHRNGE( IFLG, VXMIN, VXMAX, VMIN, VMAX, VSTP )
           ELSE
               VXMAX  = 1.1*VMAX
               VXMIN  = 1.1*VMIN
               CALL XHRNGE( IFLG, VXMIN, VXMAX, VMIN, VMAX, VSTP )
           ENDIF
 
       UNIT  = (VMAX-VMIN)/YMAX
 
       CALL XHSCLE( IFLG, VMIN, VMAX, VSTP, UNIT, SCALE, CHAR1 )
 
             IF(LU.GT.0) WRITE(LU,9210) NTOTAL
 9210        FORMAT(1X,'Total =',I10,' events',
     .        3X,'"*" : No. of events in Linear scale.')
             IF(LU.GT.0) WRITE(LU,9205) SCALE
 9205        FORMAT(1X,'   x      Lg(dN/dx)  dN/dx',A52)
             IF(LU.GT.0) WRITE(LU,9251) CHAR1
 9251        FORMAT(1X,
     .             '+-------+----------+-------+',
     .       A50 )
 
       VX    = ABS(XMAX)
       XM    = ABS(XMIN)
       IF( XM .GT. VX ) VX = XM
 
       CALL XHORDR( VX, F2, ORD, IORD )
 
       IF( VMIN .LT. 0.0 ) THEN
           V1    = VMIN
           NUMBL = 1
           DO 150 I = 1, 80
              V2    = V1 + UNIT
              IF( V1 .LE. 0.0 .AND. V2 .GE. 0.0 ) THEN
                  NUMBL  = I
                  GO TO 180
              ENDIF
              V1    = V2
  150      CONTINUE
       ENDIF
 
  180  DO 300 I = 1,NBIN1
          VX   = VAL(I)
          IF( VMIN .GE. 0.0 ) THEN
              IF( VX .GT. 0.0 ) THEN
                  NUMBL  = (VLOG(I) - VLMIN)/UNITL + 1.0
                  NUMB   = VX/UNIT + 1.0
              ELSE
                  NUMBL  = 0
                  NUMB   = 0
              ENDIF
              IF( NUMB .GT. 50 ) NUMB = 50
              IF( NUMBL.GT. 50 ) NUMBL= 50
              DO 200 K = 1,50
                 IF(     ( K .GT. NUMBL) .AND. (K .GT. NUMB ) ) THEN
                           IF( K .EQ. 50 ) THEN
                               CHARR(K:K) = AI
                           ELSE
                               CHARR(K:K) = BLNK
                           ENDIF
                 ELSEIF( ( K .LE. NUMBL) .AND. (K .GT. NUMB )) THEN
                           CHARR(K:K) = OO
                 ELSEIF( ( K .GT. NUMBL) .AND. (K .LE. NUMB )) THEN
                           CHARR(K:K) = STAR
                 ELSEIF( ( K .LE. NUMBL) .AND. (K .LE. NUMB)) THEN
                           IF( NUMB .GE. NUMBL ) THEN
                               CHARR(K:K) = OO
                           ELSE
                               CHARR(K:K) = STAR
                           ENDIF
                 ENDIF
  200         CONTINUE
          ELSE
 
              V1          = VMIN
              NHIG        = 1
              DO 220  J = 1, 50
                 V2     = V1 + UNIT
                 IF( VX .GE. V1 .AND. VX .LT. V2 ) THEN
                     NHIG   = J
                     GO TO 240
                 ENDIF
                 V1    = V2
  220         CONTINUE
  240         NLOW   = NUMBL
              IF( NHIG .LT. NLOW) THEN
                  NX    = NHIG
                  NHIG  = NLOW
                  NLOW  = NX
              ENDIF
 
              DO 250 K = 1, 49
                 IF(     K .EQ. NUMBL ) THEN
                         CHARR(K:K) = AI
                 ELSEIF( K .GT. NHIG ) THEN
                         CHARR(K:K) = BLNK
                 ELSEIF( K .LT. NLOW ) THEN
                         CHARR(K:K) = BLNK
                 ELSE
                     IF( K .EQ. NHIG .AND. K .EQ. NLOW) THEN
                         CHARR(K:K) = AI
                     ELSE
                         CHARR(K:K) = STAR
                     ENDIF
                 ENDIF
  250         CONTINUE
              CHARR(50:50) = AI
          ENDIF
 
             NX  = VAL(I)
             VX     = VAL(I)
             VX1    = VX
             IF( VX .LT. 0.0 ) VX1 = -VX
             CALL XHORDR( VX1, F2, ORDER, IORDR )
             F2     = VX/ORDER
             IF( I .EQ. NBIN1 ) THEN
                 IF(LU.GT.0) WRITE(LU,9400) IORD,F2,IORDR,NX,CHARR
 9400            FORMAT(1X,'I  E',I3,' I',F6.3,'E',I3,'I',
     .                                            I7,'I',A50)
             ELSE
                   XM  = (XMIN + DEV*(I - 1))/ORD
                   IF(LU.GT.0) WRITE(LU,9440) XM,F2,IORDR,NX,CHARR
 9440              FORMAT(1X,'I',F6.3,' I',F6.3,'E',I3,'I',
     .                                        I7,'I',A50)
             ENDIF
 
  300  CONTINUE
 
       IF( VMIN .GE. 0.0 ) THEN
           CALL XHSCLE( 1, VLMIN, VLMAX, VLSTP, UNITL, SCALE, CHAR1)
           VXMIN  = 10**VLMIN
       ENDIF
 
           IF(LU.GT.0) WRITE(LU,9251) CHAR1
           IF(LU.GT.0) WRITE(LU,9205) SCALE
           IF(LU.GT.0) WRITE(LU,9360)
 9360      FORMAT(30X,'"O" : No. of Events in Log. scale.')
 
C
 
      RETURN
      END
***********************************************************************
*============================                                         *
      SUBROUTINE SPINFO( LU )
*============================                                         *
*((Purpose))                                                          *
*    Print the information for                                        *
*        (1) BASES parameters                                         *
*        (2) Computer time information                                *
*        (3) Convergency behavior of the Grid optimization step       *
*        (4) Convergency behavior of the integration step             *
*(( Input ))                                                          *
*    LU  :  Logical unit number of printer                            *
*                                                                     *
*           by S.Kawabata    March 1994 at KEK
*                                                                     *
***********************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON /BDATE/ IDATE(3),ITIME(2)
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      COMMON /SPRNG2/ MXTRY,NEVENT, NTRIAL, MISS
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
*     COMMON/PLOTH/ XHASH(ILH,13),DHASH(IDH,14),IFBASE(ILH),
*    .              MAXL, NHIST, MAPL(4,ILH),
*    .              MAXD, NSCAT, MAPD(4,IDH),
*    .              NW
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
 
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
      REAL*4 XTIME
 
      CHARACTER*1 CN
 
       IF( IPNT .EQ. 0 ) THEN
           IF(LU.GT.0) WRITE(LU,9300)
       ELSE
           CN     = CHAR(12)
           IF(LU.GT.0) WRITE(LU,9350) CN
       ENDIF
 9300  FORMAT(/1H1,////1H )
 9350  FORMAT(A1,////1X)
       IF(LU.GT.0) WRITE(LU,9360) (IDATE(I),I=1,3),(ITIME(J),J=1,2)
 9360  FORMAT(55X,'Date: ',I2,'/',I2,'/',I2,2X,I2.2,':',I2.2)
       IF(LU.GT.0) WRITE(LU,9400)
 9400 FORMAT(
     . 8X,'**********************************************************',
     ./8X,'*                                                        *',
     ./8X,'*    SSSSS   PPPPPP   RRRRRR   IIIII  N    NN   GGGGG    *',
     ./8X,'*   SS   SS  PP   PP  RR   RR   III   NN   NN  GG   GG   *',
     ./8X,'*   SS       PP   PP  RR   RR   III   NNN  NN  GG        *',
     ./8X,'*    SSSSS   PPPPPP   RRRRR     III   NNNN NN  GG  GGGG  *',
     ./8X,'*        SS  PP       RR  RR    III   NN NNNN  GG   GG   *',
     ./8X,'*   SS   SS  PP       RR   RR   III   NN  NNN  GG   GG   *',
     ./8X,'*    SSSSS   PP       RR    RR IIIII  NN   NN   GGGGG    *',
     ./8X,'*                                                        *',
     ./8X,'*                  SPRING Version 5.1                    *',
     ./8X,'*           coded by S.Kawabata KEK, March 1994          *',
     ./8X,'**********************************************************')
*                                                                      *
          EFF   = FLOAT(NEVENT)/FLOAT(NTRIAL)*100.D0
          CALL BSTIME( RTIME, 1 )
          XTIME = RTIME - TIMES1
          IF(LU.GT.0) 
     .    WRITE(LU,9500) NEVENT,EFF,(TIMESP(I),I=0,2),XTIME,MXTRY,MISS
 9500     FORMAT(/5X,'Number of generated events    =',I10,
     .         /5X,'Generation efficiency         =',F10.3,' Percent',
     .         /5X,'Computing time for generation =',F10.3,' Seconds',
     .         /5X,'               for Overhead   =',F10.3,' Seconds',
     .         /5X,'               for Others     =',F10.3,' Seconds',
     .         /5X,'GO time for event generation  =',F10.3,' Seconds',
     .         /5X,'Max. number of trials MXTRY   =',I10,' per event',
     .         /5X,'Number of miss-generation     =',I10,' times')
 
      CALL SPHIST( LU )
 
      RETURN
      END
C***********************************************************************
C*====================================                                 *
C* SUBROUTINE SPRGEN( F, MXTRY, NTRY )                                 *
C*====================================                                 *
C*                                                                     *
C*     Generation of events according to the probability density       *
C*     which is stored in a disk file.                                 *
C*                                                                     *
C*    Coded   by S.Kawabata   at July,1980                             *
C*    Update     S.Kawabata   September '84                            *
C*                                                                     *
C***********************************************************************
C
       SUBROUTINE SPRGEN(F,MXTRY,NTRY)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      EXTERNAL F
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
 
      COMMON /SPRNG1/ XND, DXG, XJAC, DXMAX, NSP
 
      DIMENSION Y(MXDIM),KG(MXDIM)
      DATA ONE/1.0D0/
C
C
      RX    = DRN(IDUMY)*DXMAX
C
C  -------------- Binary Search  --------------------------------
C
      IPMIN = 1
      IPMAX = NSP
C
 300  IC    = (IPMIN+IPMAX)/2
        IF(RX .LT. DXD(IC)) THEN
          IPMAX = IC
        ELSE
          IPMIN = IC
        ENDIF
      IF(IPMAX-IPMIN .GT.  2) GO TO 300
C
      IC    = IPMIN-1
 350  IC    = IC+1
      IF(DXD(IC) .LT. RX) GO TO 350
C
C --------------------------------------------------------------------
C      Identify the hypecube number from sequential number IC
C --------------------------------------------------------------------
C
       FMAX  = DXP(IC)
C
       IX    = IC-1
 
       KG(NWILD) = IX/MA(NWILD) + 1
       IF( NWILD .GT. 1 ) THEN
           DO 400 J = 1,NWILD-1
              NUM   = MOD(IX,MA(J+1))
              KG(J) = NUM/MA(J) + 1
  400      CONTINUE
       ENDIF
C
C  ------------------------------------------------------------------
C                     Sample and test a event
C  ------------------------------------------------------------------
C
      DO 600 NTRY = 1,MXTRY
        WGT   = XJAC
        DO 550 J=1,NDIM
          IF( J .LE. NWILD) THEN
             XN    = (KG(J)-DRN(IDUMY))*DXG+ONE
          ELSE
             XN    = ND*DRN(IDUMY) + ONE
          ENDIF
          IAJ   = XN
          IF(IAJ .EQ. 1) THEN
            XO    = XI(IAJ,J)
            RC    = (XN-IAJ)*XO
          ELSE
            XO    = XI(IAJ,J)-XI(IAJ-1,J)
            RC    = XI(IAJ-1,J)+(XN-IAJ)*XO
          ENDIF
          Y(J)  = XL(J) + RC*DX(J)
          WGT   = WGT*XO*XND
  550   CONTINUE
C
*       FX    = F(Y)*WGT
        FF    = F(Y)
        FX    = FF*WGT
        FUNCT = FX/FMAX
C
        IF( FX .GT. 0.0D0 ) THEN
*           IF( DRN(DUMY) .LE. FUNCT ) GO TO 700
            XJ = DRN(IDUMY)
            IF( XJ .LE. FUNCT ) GO TO 700
*           IF( XJ .LE. FUNCT ) THEN
*               WRITE(6,9999) NTRY,IC,FF,WGT,XJ,FUNCT
*9999           FORMAT(1X,'NTRY,IC,FF,WGT,XJ,FUNCT = ',2I5,4E12.4)
*               GO TO 700
*           ENDIF
        ELSE
     .  IF( FX .LT. 0.0D0 ) THEN
            WRITE(6,9100) IC
 9100       FORMAT(
     .      /5X,'********** FATAL ERROR IN SPRING **********',
     .      /5X,'* A negative value of function was found  *',
     .      /5X,'*        in the ',I6,'-th Hypercube.      *',
     .      /5X,'*******************************************')
            WRITE(6,9405)
 9405       FORMAT(5X,'------',3('+---------------'),'+')
            WRITE(6,9410)
 9410       FORMAT(5X,'    i       XL(i)             X       ',
     .                '     XU(i)')
            WRITE(6,9405)
            DO 450 I = 1,NDIM
                WRITE(6,9420) I,XL(I),Y(I),XU(I)
 9420           FORMAT(5X,I5,1P,3('  ',E14.6))
  450       CONTINUE
            WRITE(6,9405)
            STOP
        ENDIF
C
        CALL SHCLER
C
  600 CONTINUE
 
      NTRY  = MXTRY + 1
 
  700 RETURN
      END
************************************************************************
*    ==================================                                *
      SUBROUTINE SPRING(FUNC, MXTRY )
*    ==================================                                *
*         Main Program for the Event generation program SPRING.        *
*                                                                      *
*        Coded by S.Kawabata        September '84                      *
*                                                                      *
************************************************************************
 
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL FUNC
      COMMON /BASE0/ NDUM,IBASES
      PARAMETER (MXDIM = 100, NDMX = 50, LENG = 32768)
      COMMON /BASE1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     .               IG(MXDIM),NCALL
      COMMON /BASE4/ XI(NDMX,MXDIM),DX(MXDIM),DXD(LENG),DXP(LENG),
     .               ND,NG,NPG,MA(MXDIM)
      COMMON /BDATE/ IDATE(3),ITIME(2)
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      COMMON /SPRNG1/ XND, DXG, XJAC, DXMAX, NSP
      COMMON /SPRNG2/ MXTRYP,NEVENT, NTRIAL,MISS
 
      REAL*4 TIMEBS,TIMINT,TIMESP,TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME1/ TIME0,RTIME,TIMEB1,TIMEB2,TIMES1
      COMMON /BTIME2/ TIMEBS(0:2),TIMINT,TIMESP(0:2)
*                                                                      *
*----------------------------- Entry point ----------------------------*
*                                                                      *
*======================================================================*
*                  Initialization of the program                       *
*======================================================================*
*----------------------------------------------------------------------*
*                     initialize timer etc.                            *
*----------------------------------------------------------------------*
*                                                                      *
       IF( IBASES .GT. 0 ) THEN
 
           CALL SPCHCK
 
           CALL BSTIME( TIME0, 0 )
           TIMES1 = TIME0
 
           MXTRYP = MXTRY
           INTV   = 0
           IBASES = 0
           MISFLG = 0
 
           CALL BSDATE
 
           DO 10 I = 0,2
              TIMESP(I) = 0.0
   10      CONTINUE
*                                                                      *
            IF( MXTRY .LT. 10 ) MXTRY = 50
            NBIN    = MXTRY
            IF( MXTRY .GT. 50) NBIN = 50
            MXTRY1  = MXTRY + 1
            MISS    = 0
            NEVENT  = 0
            NTRIAL  = 0
 
            CALL SHINIT( MXTRY1 )
 
*           -------------
             CALL SHRSET
*            -------------
*----------------------------------------------------------------------*
*             Make the cumulative probability distribution             *
*----------------------------------------------------------------------*
*                                                                      *
            XND     = ND
            DXG     = XND/NG
            NSP     = NG**NWILD
 
*///// DEBUG
*       MCALL   = NSP*NPG
*       CALL BSPRNT( 4, MCALL, IDUM2, IDUM3, IDUM4 )
*
            XJAC    = 1.0
            DO 50 I = 1, NDIM
               XJAC = XJAC*DX(I)
   50       CONTINUE
            DXMAX   = 0.0D0
            DO 100  I = 1,NSP
               IF( DXD( I ) .LT. 0.0D0 ) THEN
                   WRITE(6,9100) I
 9100              FORMAT(
     .             /5X,'********** FATAL ERROR IN SPRING **********',
     .             /5X,'*     Negative probability was found      *',
     .             /5X,'*        in the ',I6,'-th Hypercube.      *',
     .             /5X,'*******************************************')
                   STOP
               ENDIF
 
               DXMAX    = DXMAX + DXD( I )
               DXD(I)   = DXMAX
  100       CONTINUE
*        =====================
          CALL BSUTIM( 1, 1 )
*        =====================
      ENDIF
*     =====================
       CALL BSUTIM( 1, 2 )
*     =====================
      IF( IBASES .EQ. 1 ) THEN
          WRITE(6,9000)
 9000     FORMAT(
     .      1X,'**************************************************',
     .     /1X,'*    Flag IBASES was not equal to "0".           *',
     .     /1X,'*                                                *',
     .     /1X,'*   Process was terminated by this error.        *',
     .     /1X,'*   Call S.Kawabata.                             *',
     .     /1X,'**************************************************')
           STOP
       ENDIF
C
C  update for QEDPS on June 16. '97
C
       CALL SHUPDT
*                                                                      *
*======================================================================*
*                       Event generation                               *
*======================================================================*
*     =====================
  500  CALL BSUTIM( 1, 1 )
*     =====================
 
*     ==================================
        CALL SPRGEN( FUNC, MXTRY, IRET)
*     ==================================
 
*     =====================
       CALL BSUTIM( 1, 0 )
*     =====================
 
      CALL SHFILL( IRET )
 
      IF( IRET .LE. MXTRY ) THEN
          NTRIAL =NTRIAL + IRET
          NEVENT = NEVENT + 1
          CALL SHUPDT
      ELSE
          NTRIAL =NTRIAL + IRET - 1
          MISS = MISS + 1
          IF( MISFLG .EQ. 0 .AND. MISS .GT. MXTRY ) THEN
              WRITE(6,9600) MXTRY
 9600         FORMAT(1X,'****************************************',
     .                  '****************************************',
     .              /1X,'* (((( Warning ))))                     ',
     .                  '                                       *',
     .              /1X,'*                                       ',
     .                  '                                       *',
     .              /1X,'*  The number of mis-generations is foun',
     .                  'd more than',I3,' times.                  *')
              WRITE(6,9610)
 9610         FORMAT(1X,'*                                       ',
     .                  '                                       *',
     .              /1X,'*(( Suggestion ))                       ',
     .                  '                                       *',
     .              /1X,'* (1) Try integration again with larger ',
     .                  'number of sample points than this job. *',
     .              /1X,'* or                                    ',
     .                  '                                       *',
     .              /1X,'* (2) The integral variables are not sui',
     .                  'ted for the function.                  *',
     .              /1X,'*     Take another integral variables !!',
     .                  '                                       *',
     .              /1X,'*                                       ',
     .                  '                                       *',
     .              /1X,'****************************************',
     .                  '****************************************')
            MISFLG = 1
          ENDIF
          GO TO 500
      ENDIF
*     =====================
  600  CALL BSUTIM( 1, 1 )
*     =====================
 
      RETURN
      END
#include <time.h>
/* long	iutime() */
/*main()*/
void uxdate_(year,mon,day,hour,min)
int	*year, *mon, *day, *hour, *min;
{
	struct	tm q;
        struct  tm *localtime();
        time_t  tp;
        time_t  mktime();
        time_t  time();
        char    *ctime();
	char    *date;
        

        time(&tp);
        date = ctime(&tp);
        q = *localtime(&tp);
        *year = q.tm_year;
        *mon  = q.tm_mon + 1;
        *day  = q.tm_mday;
        *hour = q.tm_hour;
        *min  = q.tm_min;

	return;
}
#include <sys/times.h>
#include <unistd.h>
float	uxtime_() 
{
	struct	tms q;
	long 	t,s;
	long    sysconf();
	long    ticks;
	float   uxtime;


        ticks = sysconf(_SC_CLK_TCK);
	times(&q);
        t = q.tms_utime + q.tms_cutime
           +q.tms_stime + q.tms_cstime;
	return (float) t/ (float) ticks;
}
************************************************************************
*    =======================                                           *
      SUBROUTINE XHCHCK(LU)
*    =======================                                           *
* ((Purpose))                                                          *
*      To check the contents of the histogram table                    *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata    June '90                                         *
*                                                                      *
************************************************************************
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
 
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
      CHARACTER*1 CN
 
      CN  = CHAR(12)
 
      IF( IPNT .EQ. 0 ) THEN
         IF(LU.GT.0) WRITE(LU,9000)
      ELSE
         IF(LU.GT.0) WRITE(LU,9010) CN
      ENDIF
 9000 FORMAT(/1H1)
 9010 FORMAT(A1)
 
      IF(LU.GT.0) WRITE(LU,9050) NW
 9050 FORMAT(
     . //5X,'*********  Contents of the histogram Header *********',
     .     //1X,'(1) Actual Buffer size     = ',I6,' Words')
      IF(LU.GT.0) WRITE(LU,9100) NHS,NHIST
 9100 FORMAT(1X,'(2) Contents of Histograms ',
     .      /1X,'    Max. No. of Histograms = ',I6,
     .      /1X,'    Number   of Histograms = ',I6)
 
      IF( NHIST .GT. 0 ) THEN
          IF(LU.GT.0) WRITE(LU,9200)
 9200     FORMAT(1X,'   ID     X_min        X_max    X_bin',
     .              ' Hash Hst#')
          DO 200 I = 1, 13
             NT    = XHASH(1,I)
             IF( NT .GT. 0 ) THEN
                 DO 100 J = 2, NT+1
                    K     = XHASH(J,I)
                    IP1   = MAPL(2,K)
                    IP3   = MAPL(4,K)
                    XMIN  = BUFF(IP1)
                    XMAX  = BUFF(IP1+1)
                    NBIN  = IBUF(IP1+2)
        IF(LU.GT.0) WRITE(LU,9300) MAPL(1,K),XMIN,XMAX,NBIN,I,NT,K
 9300               FORMAT(1X,I5,1X,1PE12.4,1X,E12.4,I5,2I3,I5)
  100            CONTINUE
             ENDIF
  200     CONTINUE
      ENDIF
 
      IF(LU.GT.0) WRITE(LU,9400) NSC,NSCAT
 9400 FORMAT(1X,'(3) Contents of Scatter Plots',
     .      /1X,'    Max. No. of Scat_Plots = ',I6,
     .      /1X,'    Number   of Scat_Plots = ',I6)
 
      IF( NSCAT .GT. 0 ) THEN
          IF(LU.GT.0) WRITE(LU,9500)
 9500     FORMAT(1X,'   ID      X_min   ',
     .              '     X_max   X-Bin    Y_min   ',
     .              '     Y_max   Y_Bin Hash Hst#')
          DO 400 I = 1, 13
             NT    = DHASH(1,I)
             IF( NT .GT. 0 ) THEN
                 DO 300 J = 2, NT+1
                    K     = DHASH(J,I)
                    IP1   = MAPD(2,K)
                    IP3   = MAPD(4,K)
                    XMIN  = BUFF(IP1)
                    XMAX  = BUFF(IP1+1)
                    NXBN  = IBUF(IP1+2)
                    YMIN  = BUFF(IP1+4)
                    YMAX  = BUFF(IP1+5)
                    NYBN  = IBUF(IP1+6)
        IF(LU.GT.0) WRITE(LU,9600) MAPD(1,K),XMIN,XMAX,NXBN,
     .                            YMIN,YMAX,NYBN,I,NT,K
 9600               FORMAT(1X,I5,1X,1PE12.4,1X,E12.4,I5,
     .                                 E12.4,1X,E12.4,I5,2I3,I5)
  300            CONTINUE
             ENDIF
  400     CONTINUE
      ENDIF
      RETURN
      END
************************************************************************
*    ==============================                                    *
      SUBROUTINE XHFILL(ID, DX, FX )
*    ==============================                                    *
* ((Function))                                                         *
*     To fill histograms.                                              *
*   This routine identifies the bin number which is to be updated      *
*   with weight FX*WGT.  Up to five points per histogram are able      *
*   to be stacked before calling BHUPDT or SHUPDT.                     *
* ((Input))                                                            *
*   ID    : Histogram identification number                            *
*   DX    : Input value                                                *
*   FX    : Input value of the function                                *
* ((Author))                                                           *
*   S.Kawabata         June '90 at KEK                                 *
*                                                                      *
************************************************************************
 
      REAL*8 DX,FX
      COMMON /BASE0/ IFLAG,IBASES
      REAL*8         SCALLS,WGT,TI,TSI,TACC
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C
C    update for QEDPS on June 13. '97
C
      COMMON /PLOTC/ NHIT(NHS), IXSP(50,NHS)
 
C     COMMON/PLOTLU/ LU
C
      IF( NHIST .GT. 0 ) THEN
C
          I  = IABS(MOD( ID, 13 )) + 1
          IF( XHASH(1, I) .EQ. 1 ) THEN
            IF( ID .EQ. MAPL( 1, XHASH(2,I))) THEN
                IHIST = XHASH(2,I)
                GO TO 200
            ENDIF
          ELSEIF( XHASH(1, I) .GT. 1 ) THEN
            DO 100 K = 2, XHASH(1,I)+1
               IF( ID .EQ. MAPL( 1, XHASH(K,I))) THEN
                   IHIST = XHASH(K,I)
                   GO TO 200
               ENDIF
  100       CONTINUE
          ENDIF
      ENDIF
C     IF( LU .GT. 0 ) THEN
C         WRITE(LU,9000) ID
C     ENDIF
C9000 FORMAT(1X,'No Histogram corresponds to ID =',I5,
C    .      /1X,' This call is neglected.')
      RETURN
C
 
  200 X     = DX*1.0
 
          IX    = -1
          IP1   = MAPL(2,IHIST)
          XMIN  = BUFF(IP1)
          XMAX  = BUFF(IP1+1)
          NXBIN = IBUF(IP1+2)
          DEV   = BUFF(IP1+3)
          IF(     X .LT. XMIN ) THEN
                  IX   = 0
          ELSEIF( X .GT. XMAX ) THEN
                 IX   = NXBIN + 1
          ELSE
                 IX   = INT((X - XMIN)/DEV + 1.0)
                 IF( IX .GT. NXBIN ) IX = NXBIN
          ENDIF
C        PRINT*,'ID, IHIST, IFBASE =',ID,IHIST,(IFBASE(I),I=1,NHIST)
 
      IF( IBASES .EQ. 1 ) THEN
 
          IP2       = MAPL(3,IHIST) + IX
          IBUF(IP2) = IBUF(IP2) + 1
          FXWGT     = FX*WGT
          IP2       = IP2 + 52
          BUFF(IP2) = BUFF(IP2) + FXWGT
          IP2       = IP2 + 52
          BUFF(IP2) = BUFF(IP2) + FXWGT*FXWGT
*   Add March 1994
          IFBASE(IHIST) = 1
 
      ELSE
C        PRINT*,'ID, IHIST, IFBASE =',ID,IHIST,(IFBASE(I),I=1,NHIST)
 
*        IP3        =  MAPL(4,IHIST)
*        IBUF(IP3)  = IX
C
C    update for QEDPS 0n June 13. '97
C
         NH             = NHIT(IHIST)
         NH             = NH + 1
C
C   update for QEDPS on June 16. '97
         IF( NH .GT. 50 ) THEN
             write(6,999) ID, NH
  999        format(1x,'********* Fatal Error in XHFILL ************',
     .             /1x,'  Histogram ID(',I3,' )',
     .             /1x,'   filling ',I3,' times is too many.',
     .             /1x,'************* Forced stop !! ***************' )
*             <<<<<>>>>>
                STOP
*             <<<<<>>>>>
         ENDIF

         NHIT(IHIST)    = NH
         IXSP(NH,IHIST) = IX
 
      ENDIF
 
C
      RETURN
      END
************************************************************************
*    ============================================                      *
      SUBROUTINE XHINIT(ID,DXMIN,DXMAX,NBIN,TNAME)
*    ============================================                      *
* ((Function))                                                         *
*     To define a histogram.                                           *
* ((Input))                                                            *
*    ID   : Histogram identification number                            *
*    DXMIN: Lower limit of the histogram                               *
*    DXMAX: Upper limit of the histogram                               *
*    NBIN : Number of bins for the histogram (Max. is 50 )             *
*    TNAME: Title of the histogram in the character string (upto 64    *
*            characters)                                               *
* ((Author))                                                           *
*    S.Kawabata    June '90                                            *
*                                                                      *
************************************************************************
 
      REAL*8 DXMIN, DXMAX
      CHARACTER*(*) TNAME
      CHARACTER*68  NAME
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
C
C   update for QEDPS on June 13. '97
C
      COMMON /PLOTC/ NHIT(NHS), IXSP(50,NHS)
 
*     COMMON/XHCNTL/ LOCK
      COMMON/PLOTLU/ LU
 
      IF( NHIST .GE. NHS ) THEN
*         IF( LOCK .NE. 0 ) RETURN
          IF( LU .GT. 0 ) THEN
              WRITE(LU,9000) NHIST,ID
          ENDIF
 9000     FORMAT(1X,'Number of Histograms exceeds ',I3,' at ID = ',I3,
     .            /1X,'This call is neglected.')
          RETURN
      ENDIF
 
      IEXIST = 0
      I  = IABS(MOD( ID, 13 )) + 1
      NH = XHASH(1,I)
 
      IF( NH .EQ. 1 ) THEN
            IF( ID .EQ. MAPL( 1, XHASH(2,I))) THEN
*               IF( LOCK .NE. 0 ) RETURN
                IEXIST = XHASH(2,I)
            ENDIF
      ELSEIF( NH .GT. 1 ) THEN
          DO 100 K = 2, NH+1
            IF( ID .EQ. MAPL( 1, XHASH(K,I))) THEN
*               IF( LOCK .NE. 0 ) RETURN
                IEXIST = XHASH(K,I)
                GO TO 110
            ENDIF
  100    CONTINUE
  110    CONTINUE
      ENDIF
      XMIN  = DXMIN*1.0
      XMAX  = DXMAX*1.0
 
      IF( IEXIST .GT. 0 ) THEN
          IF( LU .GT. 0 ) THEN
              WRITE(LU,9100) ID
          ENDIF
 9100     FORMAT(1X,'Histogram ID (',I3,' ) exists already.')
          IP1    =  MAPL(2,IEXIST)
          IF(( XMIN .EQ. BUFF(IP1))   .AND.
     .       ( XMAX .EQ. BUFF(IP1+1)) .AND.
     .       ( NBIN .EQ. IBUF(IP1+2)) )    THEN
               IF( LU .GT. 0 ) THEN
                   WRITE(LU,9110)
               ENDIF
 9110          FORMAT(1X,' This call is neglected.')
               RETURN
          ENDIF
          IF( LU .GT. 0 ) THEN
              WRITE(LU,9120) ID,XMIN,XMAX,NBIN
          ENDIF
 9120     FORMAT(1X,'Histogram ( ID =',I3,' ) parameters are replaced',
     .          /1X,'by the following new parameters :',
     .          /1X,' XMIN(',E12.5,')  XMAX(',E12.5,' )  NBIN(',I4,' )')
      ENDIF
 
      IF((NHIST .GE. NHS) .AND. (ID .GT. 0) ) THEN
*         IF( LOCK .NE. 0 ) RETURN
          IF( LU .GT. 0 ) THEN
              WRITE(LU,9000) NHS,ID
          ENDIF
         RETURN
      ENDIF
 
      IF(NBIN  .GT. 50 ) THEN
         IF( LU .GT. 0 ) THEN
             WRITE(LU,9200) NBIN,ID
         ENDIF
 9200    FORMAT(1X,'Bin size (',I3,' )  exceeds 50 at ID =',I5,
     .         /1X,' This call is neglected.')
         RETURN
      ENDIF
      IF(XMIN  .GE. XMAX ) THEN
         IF( LU .GT. 0 ) THEN
             WRITE(LU,9300) ID
         ENDIF
 9300    FORMAT(1X,'Lower limit is larger than upper at ID =',I5,
     .         /1X,' This call is neglected.')
         RETURN
      ENDIF
      IF(XHASH(1,I) .GE. NHS) THEN
         IF( LU .GT. 0 ) THEN
             WRITE(LU,9400) I
         ENDIF
 9400    FORMAT(1X,I5,'-th Hash table overflow',
     .         /1X,' This call is neglected.')
         RETURN
      ENDIF
 
      IF( IEXIST .GT. 0 ) THEN
          NHST     = IEXIST
      ELSE
          NHIST        = NHIST + 1
          XHASH(1,I)   = XHASH(1,I) + 1
          K            = XHASH(1,I) + 1
          XHASH(K,I)   = NHIST
          NHST         = NHIST
          IP1    = NW + 1
          NW  = NW + 281
          MAPL(1,NHST)  = ID
          MAPL(2,NHST)  = IP1
      ENDIF
         BUFF(IP1     ) = XMIN
         BUFF(IP1 +  1) = XMAX
         IBUF(IP1 +  2) = NBIN
         DEV            = XMAX - XMIN
         BUFF(IP1 +  3) = DEV/NBIN
      IP2   = IP1 + 4
         MAPL(3,NHST)  = IP2
      IP3   = IP1 + 264
         MAPL(4,NHST)  = IP3
         IBUF(IP3)     = -1
 
         I1   = IP3 + 1
         I2   = I1 + 15
         NAME = TNAME
         READ(NAME,9800) (BUFF(I),I=I1,I2)
 9800    FORMAT(16A4)
C
C    update for QEDPS on June 13. '97
C
         NHIT(NHST) = 0
 
C
 1000 CONTINUE
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*=============================================                        *
C*    SUBROUTINE XHORDR( VAL, F2, ORDER, IORDR)                        *
C*=============================================                        *
C*((Function))                                                         *
C*    To resolve the real number VAL into mantester and exponent parts.*
C*  When VAL = 1230.0 is given, output are                             *
C*        F2 = 1.2  and ORDER = 4.0.                                   *
C*((Input))                                                            *
C*  VAL  : Real*4 value                                                *
C*((Output))                                                           *
C*  F2   : The upper two digits is given                               *
C*  ORDER: Order is given                                              *
C*  IORDR: Exponent is given                                           *
C*((Author))                                                           *
C*  S.Kawabata                                                         *
C*                                                                     *
C***********************************************************************
 
      SUBROUTINE XHORDR(VAL, F2, ORDER, IORDR)
 
      IF( VAL .NE. 0.0 ) THEN
          ORDER    =  LOG10( VAL )
          IORDR    =  INT( ORDER )
          IF( ORDER .LT. 0.0 ) IORDR = IORDR - 1
          ORDER  = 10.0**IORDR
          F2     = VAL/ORDER
      ELSE
          IORDR  = 0
          ORDER  = 1.0
          F2    = 0.0
      ENDIF
 
      RETURN
      END
************************************************************************
*    =====================================                             *
      SUBROUTINE XHPLOT( LU, IFG, IHIST )
*    =====================================                             *
* ((Purpose))                                                          *
*      To print histograms for BASES and SPRING.                       *
* ((Input))                                                            *
*      IFG  : Flag which indicats whether this is called by BASES      *
*             or SPRING.  IFG = ( 0 / anyother) = ( By BASES/ SPRING)  *
*      IHIST: Serial number of the histogram                           *
*                                                                      *
* ((Author))                                                           *
*       S.Kawabata    June '90 at KEK                                  *
*     Last update     March '94                                        *
*                                                                      *
************************************************************************
 
      REAL*8         SCALLS,WGT,TI,TSI,TACC
      COMMON /BASE3/ SCALLS,WGT,TI,TSI,TACC,IT
 
      PARAMETER ( NHS = 50, NSC = 50 )
      INTEGER*4 XHASH,DHASH,NHIST,MAPL,IFBASE,NSCAT,MAPD
      COMMON/PLOTH/ XHASH(NHS+1,13),DHASH(NSC+1,14),IFBASE(NHS),
     .              NHIST, MAPL(4,NHS),
     .              NSCAT, MAPD(4,NSC),
     .              NW
      COMMON /PLOTB/ IBUF( 281*NHS + 2527*NSC )
      REAL*4         BUFF( 281*NHS + 2527*NSC )
      EQUIVALENCE (IBUF(1),BUFF(1))
 
      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP
 
      REAL  VAL(0:51),VLOG(0:51),VERR(0:51)
      CHARACTER*50 CHARR,CHAR1
      CHARACTER*52 SCALE
      CHARACTER*1  BLNK,STAR,OO,AI,CN
      DATA  YMAX / 50/
      DATA  BLNK /' '/, STAR /'*'/, OO /'O'/, AI /'I'/

      IF(LU.EQ.0) RETURN
 
      CN    = CHAR(12)
      IP3   = MAPL(4,IHIST)
      IF(     IFG .EQ. 0 ) THEN
            IF( IPNT .EQ. 0 ) THEN
                WRITE(LU,9000)
            ELSE
                WRITE(LU,9005) CN
            ENDIF
 9000       FORMAT(/1H1)
 9005       FORMAT(A1)
            WRITE(LU,9100) MAPL(1,IHIST),(BUFF(I),I=IP3+1,IP3+16)
 9100       FORMAT(1X,'Histogram (ID =',I3,' ) for ',16A4)
      ELSEIF( IFG .EQ. -10 ) THEN
            IF( IPNT .EQ. 0 ) THEN
                WRITE(LU,9000)
            ELSE
                WRITE(LU,9005) CN
            ENDIF
            WRITE(LU,9102) (BUFF(I),I=IP3+1,IP3+16)
 9102       FORMAT(5X,16A4)
      ELSE
            IF( IPNT .EQ. 0 ) THEN
                WRITE(LU,9000)
            ELSE
                WRITE(LU,9005) CN
            ENDIF
            WRITE(LU,9105) MAPL(1,IHIST),(BUFF(I),I=IP3+1,IP3+16)
 9105       FORMAT(
     .      1X,'Additional Histogram (ID =',I3,' ) for ',16A4)
      ENDIF
 
      IP1   = MAPL(2,IHIST)
      XMIN  = BUFF(IP1)
      XMAX  = BUFF(IP1+1)
      NXBIN = IBUF(IP1+2) + 1
      DEV   = BUFF(IP1+3)
      IP2   = MAPL(3,IHIST)
 
      IF( IFG .EQ. 0 ) THEN
C         NTOTAL     = SCALLS
          FACT       = 1./(SCALLS*DEV)
          IPF   = IP2 + 156
          IPF2  = IPF + 52
          VAL(0)     = BUFF(IPF)/SCALLS
          VAL(NXBIN) = BUFF(IPF+NXBIN)/SCALLS
          VMAX       = FACT*BUFF(IPF+1)
          VMIN       = VMAX
          DO  50 I   = 1,NXBIN-1
              TX     = BUFF(I+IPF)
              NX     = IBUF(I+IP2)
              VLS    = TX*FACT
              IF( VMAX .LT. VLS ) VMAX = VLS
              IF( VMIN .GT. VLS ) VMIN = VLS
              VAL(I) = VLS
              IF( NX .GT. 1 ) THEN
                  DEV2   =  NX*BUFF(I+IPF2)-TX*TX
                  IF( DEV2 .LE. 0.0 ) THEN
                      VERR(I)= 0.0
                  ELSE
                      VERR(I)= FACT*SQRT( DEV2/( NX-1 ))
                  ENDIF
*TI           ELSEIF( NX .EQ. 1 ) THEN
*TI               VERR(I)= VLS
              ELSE
                  VERR(I)= 0.0
              ENDIF
 
   50     CONTINUE
      ELSE
          IPX   = IP2 + 52
          VAL(0)     = BUFF(IPX)
          VAL(NXBIN) = BUFF(IPX+NXBIN)
          NTOTAL     = INT(VAL(0)) + INT(VAL(NXBIN))
          VMIN       = 0.0
          VMAX       = VMIN
          DO  55 I   = 1,NXBIN-1
              VLS    = BUFF(I+IPX)
              NTOTAL = INT(VLS) + NTOTAL
              IF( VMAX .LT. VLS ) VMAX = VLS
              VAL(I) = VLS
              IF( VLS .GT. 0.0 ) THEN
                  VERR(I) = SQRT(VLS)
              ELSE
                  VERR(I) = 0.0
              ENDIF
   55     CONTINUE
       ENDIF
***
       IF( VMAX .EQ. 0.0 .AND. VMIN .EQ. 0.0) THEN
           V0 = VAL(0)
           VM = VAL(NXBIN)
           IF( V0 .GE. 0.0 .AND. VM .GE. 0.0 ) THEN
               VMIN  = 0.0
               IF( V0 .GT. VM  ) THEN
                   VMAX = V0
               ELSE
                   VMAX = VM
               ENDIF
           ELSEIF( V0 .LT. 0.0 .AND. VM .LT. 0.0 ) THEN
               VMAX  = 0.0
               IF( V0 .LT. VM ) THEN
                   VMIN  = V0
               ELSE
                   VMIN  = VM
               ENDIF
           ELSEIF( V0 .GT. VM ) THEN
               VMAX  = V0
               VMIN  = VM
           ELSE
               VMAX  = VM
               VMIN  = V0
           ENDIF
       ENDIF
***
       IF( VMIN .GE. 0.0 ) THEN
C//VV
           IF( VMAX .GT. 0.0 ) THEN
               VLMAX = LOG10(VMAX)
           ELSE
               VLMAX = 2.0
           ENDIF
C//
           VLMIN = VLMAX
           DO  60 I = 0,NXBIN
               IF( VAL(I) .GT. 0.0 ) THEN
                   VLS   = LOG10( VAL(I) )
                   IF( I .GT. 0 .AND. I .LT. NXBIN ) THEN
                       IF( VLS .LT. VLMIN ) VLMIN = VLS
                   ENDIF
                   VLOG(I)  = VLS
C//VV
C              ELSE
C                  VLOG(I)  = 0.0
               ENDIF
   60      CONTINUE
 
           IF( VLMIN .LT. 0.0) THEN
               VXMIN = IFIX(VLMIN) - 1.0
           ELSE
               VXMIN = IFIX(VLMIN)
           ENDIF
           VXMAX = VLMAX
           IFLG  = 1
           CALL XHRNGE( IFLG, VXMIN, VXMAX, VLMIN, VLMAX, VLSTP )
           UNITL = (VLMAX-VLMIN)/YMAX
 
       ENDIF
 
       IFLG   = 0
       IF( VMAX .GT. 0.0 ) THEN
           IF( VMIN .GE. 0.0 ) THEN
               VXMAX  = 1.2*VMAX
               VXMIN  = 0.0
               CALL XHRNGE( IFLG, VXMIN, VXMAX, VMIN, VMAX, VSTP )
           ELSE
               VXMAX  = 1.1*VMAX
               VXMIN  = 1.1*VMIN
               CALL XHRNGE( IFLG, VXMIN, VXMAX, VMIN, VMAX, VSTP )
           ENDIF
       ELSE
          VXMAX  = 0.0
          VXMIN  = 1.1*VMIN
          CALL XHRNGE( IFLG, VXMIN, VXMAX, VMIN, VMAX, VSTP )
       ENDIF
 
       UNIT  = (VMAX-VMIN)/YMAX
 
       CALL XHSCLE( IFLG, VMIN, VMAX, VSTP, UNIT, SCALE, CHAR1 )
C
C
       IF( IFG .EQ. 0 ) THEN
           WRITE(LU,9150)
 9150      FORMAT(30X,'Linear Scale indicated by "*"')
           WRITE(LU,9200) SCALE
 9200      FORMAT(1X,'    x      d(Sigma)/dx    ',A52)
           WRITE(LU,9250) CHAR1
 9250      FORMAT(1X,
     .                '+-------+------------------+',
     .           A50 )
       ELSE
             WRITE(LU,9210) NTOTAL
 9210        FORMAT(1X,'Total =',I10,' events',
     .        3X,'"*" : No. of events in Linear scale.')
             WRITE(LU,9205) SCALE
 9205        FORMAT(1X,'   x      Lg(dN/dx)  dN/dx',A52)
             WRITE(LU,9251) CHAR1
 9251        FORMAT(1X,
     .             '+-------+----------+-------+',
     .       A50 )
       ENDIF
 
       VX    = ABS(XMAX)
       XM    = ABS(XMIN)
       IF( XM .GT. VX ) VX = XM
 
       CALL XHORDR( VX, F2, ORD, IORD )
 
       IF( VMIN .LT. 0.0 ) THEN
           V1    = VMIN
           NUMBL = 1
           DO 150 I = 1, 80
              V2    = V1 + UNIT
              IF( V1 .LE. 0.0 .AND. V2 .GE. 0.0 ) THEN
                  NUMBL  = I
                  GO TO 180
              ENDIF
              V1    = V2
  150      CONTINUE
       ENDIF
 
  180  DO 300 I = 0,NXBIN
          VX   = VAL(I)
          IF( VMIN .GE. 0.0 ) THEN
              IF( VX .GT. 0.0 ) THEN
                  NUMBL  = (VLOG(I) - VLMIN)/UNITL + 1.0
                  NUMB   = VX/UNIT + 1.0
              ELSE
                  NUMBL  = 0
                  NUMB   = 0
              ENDIF
              IF( NUMB .GT. 50 ) NUMB = 50
              IF( NUMBL.GT. 50 ) NUMBL= 50
              DO 200 K = 1,50
                 IF(     ( K .GT. NUMBL) .AND. (K .GT. NUMB ) ) THEN
                           IF( K .EQ. 50 ) THEN
                               CHARR(K:K) = AI
                           ELSE
                               CHARR(K:K) = BLNK
                           ENDIF
                 ELSEIF( ( K .LE. NUMBL) .AND. (K .GT. NUMB )) THEN
                           CHARR(K:K) = OO
                 ELSEIF( ( K .GT. NUMBL) .AND. (K .LE. NUMB )) THEN
                           CHARR(K:K) = STAR
                 ELSEIF( ( K .LE. NUMBL) .AND. (K .LE. NUMB)) THEN
                           IF( NUMB .GE. NUMBL ) THEN
                               CHARR(K:K) = OO
                           ELSE
                               CHARR(K:K) = STAR
                           ENDIF
                 ENDIF
  200         CONTINUE
          ELSE
 
              V1          = VMIN
              NHIG        = 1
              DO 220  J = 1, 50
                 V2     = V1 + UNIT
                 IF( VX .GE. V1 .AND. VX .LT. V2 ) THEN
                     NHIG   = J
                     GO TO 240
                 ENDIF
                 V1    = V2
  220         CONTINUE
  240         NLOW   = NUMBL
              IF( NHIG .LT. NLOW) THEN
                  NX    = NHIG
                  NHIG  = NLOW
                  NLOW  = NX
              ENDIF
 
              DO 250 K = 1, 49
                 IF(     K .EQ. NUMBL ) THEN
                         CHARR(K:K) = AI
                 ELSEIF( K .GT. NHIG ) THEN
                         CHARR(K:K) = BLNK
                 ELSEIF( K .LT. NLOW ) THEN
                         CHARR(K:K) = BLNK
                 ELSE
                     IF( K .EQ. NHIG .AND. K .EQ. NLOW) THEN
                         CHARR(K:K) = AI
                     ELSE
                         CHARR(K:K) = STAR
                     ENDIF
                 ENDIF
  250         CONTINUE
              CHARR(50:50) = AI
          ENDIF
 
          IF( IFG .EQ. 0 ) THEN
 
              NX     = IBUF(I+IP2)
              VX     = VAL(I)
              VX1    = VX
              IF( VX .LT. 0.0 ) VX1 = -VX
 
 
              IF( I .EQ. 0 .OR. I. EQ. NXBIN ) THEN
                  CALL XHORDR( VX1, F2, ORDER, IORDR )
                  F2     = VX/ORDER
                  WRITE(LU,9300) IORD,F2,IORDR,CHARR
 9300             FORMAT(1X,'I  E',I3,' I',F6.3,8X,'E',I3,
     .                                     'I',A50)
              ELSE
                  XM    = (XMIN + DEV*(I-1))/ORD
                  VE     = VERR(I)
                  IF( VE .GT. VX1 ) THEN
                      CALL XHORDR(  VE, F2, ORDER, IORDR )
                  ELSE
                      CALL XHORDR( VX1, F2, ORDER, IORDR )
                  ENDIF
                  F2   = VX/ORDER
                  VE   = VE/ORDER
                  WRITE(LU,9340) XM,F2,VE,IORDR,CHARR
 9340             FORMAT(1X,'I', F6.3,' I',F6.3,'+-',F5.3,' E',I3,
     .                                    'I',A50)
             ENDIF
          ELSE
             NX  = VAL(I)
             VX     = VAL(I)
             VX1    = VX
             IF( VX .LT. 0.0 ) VX1 = -VX
             CALL XHORDR( VX1, F2, ORDER, IORDR )
             F2     = VX/ORDER
             IF( I .EQ. 0 .OR. I .EQ. NXBIN ) THEN
                 WRITE(LU,9400) IORD,F2,IORDR,NX,CHARR
 9400            FORMAT(1X,'I  E',I3,' I',F6.3,'E',I3,'I',
     .                                            I7,'I',A50)
             ELSE
                   XM  = (XMIN + DEV*(I - 1))/ORD
                   WRITE(LU,9440) XM,F2,IORDR,NX,CHARR
 9440              FORMAT(1X,'I',F6.3,' I',F6.3,'E',I3,'I',
     .                                        I7,'I',A50)
             ENDIF
          ENDIF
  300  CONTINUE
 
       IF( VMIN .GE. 0.0 ) THEN
           CALL XHSCLE( 1, VLMIN, VLMAX, VLSTP, UNITL, SCALE, CHAR1)
           VXMIN  = 10**VLMIN
       ENDIF
 
       IF( IFG .EQ. 0 ) THEN
           WRITE(LU,9250) CHAR1
           IF( VMIN .GE. 0.0 ) THEN
               WRITE(LU,9200) SCALE
               WRITE(LU,9260)
 9260          FORMAT(30X,'Logarithmic Scale indicated by "O"')
           ELSE
               WRITE(LU,9200) SCALE
           ENDIF
       ELSE
           WRITE(LU,9251) CHAR1
           WRITE(LU,9205) SCALE
           WRITE(LU,9360)
 9360      FORMAT(30X,'"O" : No. of Events in Log. scale.')
       ENDIF
 
C
  500  CONTINUE
 
      RETURN
      END
C***********************************************************************
C*                                                                     *
C*============================================================         *
C*  SUBROUTINE XHRNGE( IFLG, VMIN, VMAX, VTMIN, VTMAX, STEP)           *
C*============================================================         *
C*((Function))                                                         *
C*    Determine the vertical range of the histogram.                   *
C*((Input))                                                            *
C*    IFLG   : Flag which indicates whether logarithmic or linear      *
C*             scale.  IFLG = ( 1 / any other ) = ( log / linear )     *
C*    VMIN,VMAX : Minimum and maximum values of vertical window.       *
C*((Output))                                                           *
C*    VTMIN,VTMAX : Minimum and maxmum values of optimized vertical    *
C*                  window.                                            *
C*    STEP   : step of scale for the optimized vertical window         *
C*((Author))                                                           *
C*    S.Kawabata    Oct '85  at KEK                                    *
C*                                                                     *
C***********************************************************************
C
      SUBROUTINE XHRNGE( IFLG, VMIN, VMAX, VTMIN, VTMAX, STEP)
C
C     IFLG =    1 : Log scale
C            other: Linear scale
C
      PARAMETER ( NBIN  = 25 )
      REAL    WIND(NBIN),STP1(NBIN),STP2(NBIN)
C
      DATA WIND/
     .   1.00, 1.10, 1.20, 1.30, 1.40, 1.50, 1.60, 1.80, 2.00,  2.20,
     .   2.50, 2.70, 3.00, 3.30, 3.60, 4.00, 4.50, 5.00, 5.50,  6.00,
     .   6.50, 7.00, 8.00, 9.00, 10.0/
*     DATA STP1/
*    .   0.20, 0.22, 0.30, 0.26, 0.28, 0.30, 0.32, 0.36, 0.40,  0.44,
*    .   0.50, 0.54, 0.60, 0.66, 0.60, 0.80, 0.90, 1.00, 1.10,  1.00,
*    .   1.30, 1.00, 1.60, 1.80, 2.00/
      DATA STP1/
     .   0.250,0.275,0.300,0.325,0.350,0.375,0.400,0.450,0.500,0.550,
     .   0.625,0.675,0.750,0.825,0.900,1.000,1.125,1.250,1.375,1.500,
     .   1.625,1.750,2.000,2.250,2.500/
      DATA STP2/
     .   1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,  1.00,
     .   1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00,  2.00,
     .   2.00, 2.00, 2.00, 2.00, 2.00/
C
          XMAX   = VMAX
          XMIN   = VMIN
          IFLAG  = IFLG
          IF( IFLG .NE. 1 .AND. VMIN .LT. 0.0 ) THEN
              IF( VMAX .LE. 0.0 )THEN
                  IFLAG  = 2
                  XMAX  = - VMIN
                  XMIN  =  0.0
              ELSE
                  AVMIN  = - VMIN
                  XMIN  =0.0
                  IF( VMAX .GE. AVMIN ) THEN
                      IFLAG  = 3
                      XMAX  = VMAX
                      XMIN1 = AVMIN
                  ELSE
                      IFLAG  = 4
                      XMAX  = AVMIN
                      XMIN1 = VMAX
                  ENDIF
              ENDIF
          ENDIF
          DSCALE = XMAX - XMIN
          CALL XHORDR( DSCALE, DSF2, DSORDR, IORD)
 
          DO 100 I = 2, 25
             IF( DSF2 .GE. WIND(I-1) .AND.
     .           DSF2 .LE. WIND( I )       ) GO TO 200
 100      CONTINUE
          I = 25
C
 200      CONTINUE
 
          XMAX = WIND(I)*DSORDR + XMIN
          IF(     DSORDR .GE. 10.0 .OR. IFLG .NE. 1 ) THEN
                  STEP1  = STP1(I)
                  STEP   = STEP1*DSORDR
          ELSE
                  STEP1  = STP2(I)
                  STEP   = STEP1
          ENDIF
 
          IF(     IFLAG .LE. 1 ) THEN
                  VTMAX  = XMAX
                  VTMIN  = XMIN
          ELSEIF( IFLAG .EQ. 2 ) THEN
                  VTMAX  = XMIN
                  VTMIN  = -XMAX
          ELSE
 
                  XPLUS   = 0.0
                  DO 300 J = 1, 10
                     XPLUS = XPLUS + STEP
                     IF( XPLUS .GT. XMIN1 ) GO TO 400
 300              CONTINUE
 400              XMIN = XPLUS
                  XMAX = XMAX
                  IF( IFIX((WIND(I)+0.1)/STEP1)+J .GT. 7 ) THEN
                      STEP = 2.0*STEP
                  ENDIF
                  IF( IFLAG .EQ. 3 ) THEN
                      VTMAX  = XMAX
                      VTMIN  = -XMIN
                  ELSE
                      VTMAX  = XMIN
                      VTMIN  = -XMAX
                  ENDIF
          ENDIF
C
      RETURN
      END
************************************************************************
*    =========================================================         *
      SUBROUTINE XHSCLE( IFLG,VMIN,VMAX,VSTP,UNIT,SCALE,CHAR)
*    =========================================================         *
* ((Function))                                                         *
*     Determine the vertical scale and make it's format                *
* ((Input))                                                            *
*     IFLG   : Flag which indicates whether logarithmic or linear      *
*              scale.  IFLG = ( 1 / any other ) = ( log / linear )     *
*     VMIN,VMAX : Minimum and maximum values of vertical window.       *
*     VSTEP  : Step of unit scale                                      *
*     UNIT   : Unit of one mark *(or o)                                *
* ((Output))                                                           *
*     NSCL   : Number of scale mark                                    *
*     NBLK   : Number of blanks between scale marks                    *
*     CHAR   : Format of scale                                         *
* ((Author))                                                           *
*     S.Kawabata    Oct '85  at KEK                                    *
*                                                                      *
************************************************************************
 
      CHARACTER*50 CHAR
      CHARACTER*52 SCALE
      CHARACTER*1 PLUS,MINUS
      DATA PLUS /'+'/, MINUS /'-'/
 
C     IFLG =    1 : Log scale
C            other: Linear scale
      WRITE(SCALE,9000)
 9000 FORMAT(5('          '))
      IF( IFLG .EQ. 1 ) THEN
          SC  = 10.**VMIN
      ELSE
          SC  = VMIN
      ENDIF
 
      WRITE(SCALE(1:8),9100) SC
 9100 FORMAT(1P,E8.1)
      I2    = 8
      STV   = VSTP + VMIN
      STV1  = STV
      VAL1  = VMIN
      CHAR(50:50) = PLUS
      DO  100   I = 1, 49
          VAL2    = VAL1 + UNIT
          IF( STV .GE. VAL1 .AND. STV .LT. VAL2 ) THEN
              CHAR(I:I)  = PLUS
              NSCL       = NSCL + 1
              IF( IFLG .EQ. 1 ) THEN
                 SC          = 10.0**STV
              ELSE
                 IF(     STV1 .EQ. 0.0 ) THEN
                         SC           = STV
                 ELSEIF( ABS(STV/STV1) .LT. 1.E-2 ) THEN
                         SC           = 0.0
                 ELSE
                         SC          = STV
                 ENDIF
                 STV1       = STV
              ENDIF
              STV  = STV + VSTP
              IF( I2 .LT. I-1 ) THEN
                  I2   = I + 8
                  IF( I2 .LE. 52 ) THEN
                      WRITE(SCALE(I+1:I2),9100) SC
                  ENDIF
              ENDIF
          ELSE
              CHAR(I:I) = MINUS
          ENDIF
          VAL1      = VAL2
  100 CONTINUE
C
      IF( NSCL .EQ. 0 ) THEN
          IF( IFLG .EQ. 1 ) THEN
             SC       = 10.0**VMAX
          ELSE
             SC       = VMAX
          ENDIF
          WRITE(SCALE(44:52),9100) SC
      ENDIF
C
      RETURN
      END
C ******************************************************************    
C *                                                                *    
C *                                                                *    
C *   SUBROUTINE FFFF(N:I*4, AJM1:C*16(4,2,2), AJM2:C*16(4,2,2),   *    
C *  &                EM:R*(4), AALL:C*16(2,2,2,2))                *    
C *                                                                *    
C *                                                                *    
C *       Purpose: To calculate fermion-fermion interactions       *    
C *                mediated by vector boson.                       *    
C *                                                                *    
C *                                                                *    
C *       N=: No. of polarization states for intermadiated         *    
C *           vector boson                                         *    
C *       AJM1,AJM2=: Vertex amplitudes for fermion-fermion-       *    
C *           vector boson vertices calculated by subroutine FFV.  *    
C *       EM=: Weight factors to reconstruct the numerator of      *    
C *            vector boson propagator.                            *    
C *       AALL=: Calculated results for all possible helicity      *    
C *              states.                                           *    
C *                                                                *    
C *                                                                *    
C *                                       written by H. Tanaka     *    
C ******************************************************************    
C                                                                       
C                                                                       
C              ====================================                     
               SUBROUTINE FFFF(N,AJM1,AJM2,EM,AALL)                     
C              ====================================                     
C                                                                       
C                                                                       
        IMPLICIT REAL*8(A-H,O-Z)                                        
        COMPLEX*16 AALL,AJM1,AJM2                                       
        DIMENSION AJM1(4,2,2),AJM2(4,2,2),AALL(2,2,2,2),EM(4)           
CX      REAL*16 EE                                                      
                                                                        
        DO 10 J3=1,2                                                    
        DO 10 J4=1,2                                                    
        AALL(1,1,J3,J4)=0.D0                                            
        AALL(1,2,J3,J4)=0.D0                                            
        AALL(2,1,J3,J4)=0.D0                                            
        AALL(2,2,J3,J4)=0.D0                                            
        EE=1.D0                                                         
        DO 10 L=1,N                                                     
        EE=EM(L)                                                        
        AALL(1,1,J3,J4)=AALL(1,1,J3,J4)+AJM1(L,1,1)*AJM2(L,J3,J4)*EE    
        AALL(1,2,J3,J4)=AALL(1,2,J3,J4)+AJM1(L,1,2)*AJM2(L,J3,J4)*EE    
        AALL(2,1,J3,J4)=AALL(2,1,J3,J4)+AJM1(L,2,1)*AJM2(L,J3,J4)*EE    
        AALL(2,2,J3,J4)=AALL(2,2,J3,J4)+AJM1(L,2,2)*AJM2(L,J3,J4)*EE    
   10   CONTINUE                                                        
        RETURN                                                          
        END                                                             
C
C ********************************************************************
C *         S                                                        *
C *         |                                                        *
C *         |                                                        *
C * F1--<---|---<---F2    SUBROUTINE FFS                             *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for scalor boson-    *
C *              massive fermions vertex.                            *
C *                                                                  *
C *     L=: Polarization state of vector boson.                      *
C *     I,II=: Indices to specify fermion(I,II=3) or antifermion     *
C *            (I,II=1) state.                                       *
C *     AM,AAM=: Masses of fermions.                                 *
C *     AL,AR=: Coupling constants for vertex.                       *
C *     C,CC=: Phase factors for massive fermions.                   *
C *     P1,P2,Q1,Q2=: Light-like vectors decomposed by subroutine    *
C *                   SPLTQ.                                         *
C *     AALL=: Calculated results of vertex amplitudes for all       *
C *            possible helicity states.                             *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ===========================================================
        SUBROUTINE FFS(II,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALL)
C       ===========================================================
C
C
C
C   FFS              CALCULATION OF FFS   MASSIVE CASE
C
C   I,II=1:V    I,II=3:U
C      J,JJ=1:HS=-   J,JJ=2:HS=+
C
CDD     SUBROUTINE FFS(L,II,I,AAM,AM,AL,AR,PP,P,AALL)
CXX     SUBROUTINE FFS(L,II,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALL)
        IMPLICIT REAL*8(A-H,O-Z)
        COMPLEX*16 AALL
        COMPLEX*16 C,CC,AALL11,AALL22,AALL12,AALL21
        DIMENSION P1(4),P2(4),Q1(4),Q2(4),C(2),CC(2)
        DIMENSION AALL(2,2),AALL11(2),AALL22(2),AALL12(2),AALL21(2)
        CALL FFS0(Q1,P1,AALL11)
        CALL FFS0(Q2,P2,AALL22)
        CALL FFS0(Q1,P2,AALL12)
        CALL FFS0(Q2,P1,AALL21)
 
        R  = DFLOAT(I  - 2)
        RR = DFLOAT(II - 2)
        IF (AM.LE.0.0D0) THEN
          R = 0.0D0
        ENDIF
        IF (AAM.LE.0.0D0) THEN
          RR = 0.0D0
        ENDIF
 
        J1 = (5-II)/2
        J2 = 3 - J1
        K1 = (5-I)/2
        K2 = 3 - K1
 
        AALL(J1,K2)=(AR*AALL11(1))
     &               +(AL*R*RR*C(1)*CC(2)*AALL22(2))
        AALL(J2,K1)=(AL*AALL11(2))
     &               +(AR*R*RR*C(2)*CC(1)*AALL22(1))
        AALL(J2,K2)=-(AR*RR*CC(1)*AALL21(1))
     &                -(AL*R*C(1)*AALL12(2))
        AALL(J1,K1)=-(AL*RR*CC(2)*AALL21(2))
     &                -(AR*R*C(2)*AALL12(1))
 
 
CX      R=DFLOAT(I)-2.D0
CX      RR=DFLOAT(II)-2.D0
CX      IF (AM.LE.0.D0) R=0.D0
CX      IF (AAM.LE.0.D0) RR=0.D0
CX      IF (AAM.LE.0.D0) RR=0.D0
CX      IF (AM.LE.0.D0) R=0.D0
CX      IF (II.EQ.3.AND.I.EQ.3) THEN
CX      AALL(1,2)=AR*AALL11(1)+AL*R*RR*C(1)*CC(2)*AALL22(2)
CX      AALL(2,1)=AL*AALL11(2)+AR*R*RR*C(2)*CC(1)*AALL22(1)
CX      AALL(2,2)=-AR*RR*CC(1)*AALL21(1)-AL*R*C(1)*AALL12(2)
CX      AALL(1,1)=-AL*RR*CC(2)*AALL21(2)-AR*R*C(2)*AALL12(1)
CX      ELSE IF (II.EQ.3.AND.I.EQ.1) THEN
CX      AALL(1,1)=AR*AALL11(1)+AL*R*RR*C(1)*CC(2)*AALL22(2)
CX      AALL(2,2)=AL*AALL11(2)+AR*R*RR*C(2)*CC(1)*AALL22(1)
CX      AALL(2,1)=-AR*RR*CC(1)*AALL21(1)-AL*R*C(1)*AALL12(2)
CX      AALL(1,2)=-AL*RR*CC(2)*AALL21(2)-AR*R*C(2)*AALL12(1)
CX      ELSE IF (II.EQ.1.AND.I.EQ.3) THEN
CX      AALL(2,2)=AR*AALL11(1)+AL*R*RR*C(1)*CC(2)*AALL22(2)
CX      AALL(1,1)=AL*AALL11(2)+AR*R*RR*C(2)*CC(1)*AALL22(1)
CX      AALL(1,2)=-AR*RR*CC(1)*AALL21(1)-AL*R*C(1)*AALL12(2)
CX      AALL(2,1)=-AL*RR*CC(2)*AALL21(2)-AR*R*C(2)*AALL12(1)
CX      ELSE IF (II.EQ.1.AND.I.EQ.1) THEN
CX      AALL(2,1)=AR*AALL11(1)+AL*R*RR*C(1)*CC(2)*AALL22(2)
CX      AALL(1,2)=AL*AALL11(2)+AR*R*RR*C(2)*CC(1)*AALL22(1)
CX      AALL(1,1)=-AR*RR*CC(1)*AALL21(1)-AL*R*C(1)*AALL12(2)
CX      AALL(2,2)=-AL*RR*CC(2)*AALL21(2)-AR*R*C(2)*AALL12(1)
CX      END IF
C       WRITE(6,100) Q1(4),P1(4),Q(4)
CX
CX      WRITE(6,*) 'II,I,AAM,AM',II,I,AAM,AM
C100    FORMAT(2X,3D15.5)
 
        RETURN
      END
C
C
C *******************************************************************
C *                                                                 *
C *         S                                                       *
C *         |                                                       *
C *         |                                                       *
C * F1--<---|---<---F2    SUBROUTINE FFS0                           *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *   Purpose: To calculate vertex amplitudes for scalor boson-     *
C *            massless fermions vertex.                            *
C *                                                                 *
C *   P1,P2=: Momenta of massless fermions.                         *
C *   AALL=: Calculated results for vertex amplitudes.              *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *                                          written by H. Tanaka   *
C *******************************************************************
C
C
C               ============================
                SUBROUTINE FFS0(P1,P2,AALL)
C               ============================
C
C
C
C    FFS0     FUNCTION S(P1,P2) AND T(P1,P2)
C
C      X(+,P1)X(-,P2)  :  2
C      X(-,P1)X(+,P2)  :  1
C
        IMPLICIT REAL*8(A-H,O-Z)
        REAL*8 P1,P2
        COMPLEX*16 AALL
        DIMENSION P1(4),P2(4),AALL(2)
 
        IF (P1(4).LE.0.0D0 .OR. P2(4).LE.0.0D0) THEN
          AALL(1) = 0.0D0
          AALL(2) = 0.0D0
CX        WRITE(6,*) ' AALL = 0 '
          RETURN
        END IF
 
        PT1  = SQRT(P1(2)**2 + P1(3)**2)
        IF(PT1.LE.0.0D0) THEN
          RR1Y = SIGN(1.0D0, P1(1))
          RR1Z = 0.0D0
        ELSE
          RR1Y = P1(2)/PT1
          RR1Z = P1(3)/PT1
        ENDIF
        IF(P1(1).GE.0.D0) THEN
          PS1  = SQRT(P1(4) + P1(1))
          RPP1 = PT1/PS1
        ELSE
          RPP1 = SQRT(P1(4) - P1(1))
          PS1  = PT1/RPP1
        ENDIF
        R1Y = RR1Y*PS1
        R1Z = RR1Z*PS1
 
        PT2  = SQRT(P2(2)**2 + P2(3)**2)
        IF(PT2.LE.0.0D0) THEN
          RR2Y = SIGN(1.0D0, P2(1))
          RR2Z = 0.0D0
        ELSE
          RR2Y = P2(2)/PT2
          RR2Z = P2(3)/PT2
        ENDIF
        IF(P2(1).GE.0.D0) THEN
          PS2  = SQRT(P2(4) + P2(1))
          RPP2 = PT2/PS2
        ELSE
          RPP2 = SQRT(P2(4) - P2(1))
          PS2  = PT2/RPP2
        ENDIF
        R2Y = RR2Y*PS2
        R2Z = RR2Z*PS2
 
        RR  =  RPP2*R1Y-RPP1*R2Y
        RIMM = RPP2*R1Z-RPP1*R2Z
 
        AALL(2)=DCMPLX(RR,RIMM)
        AALL(1)=-DCONJG(AALL(2))
 
        RETURN
      END
C
C ********************************************************************
C *         S                                                        *
C *         !                                                        *
C *         !                                                        *
C * F1--<---!---<---F2    SUBROUTINE FFSC                            *
C *                                                                  *
C *     Purpose: to calculate vertex amplitudes for scalar boson-    *
C *              massive fermions vertex.                            *
C *                                                                  *
C *                 T             T -1                               *
C *      U(II,AAM,Q) (AL*PL+AR*PR) C  U(I,AM,P)                      *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *     I,II=: indices to specify fermion(I,II=3) or antifermion     *
C *            (I,II=1) state.                                       *
C *     AM,AAM=: masses of fermions.                                 *
C *     AL,AR=: coupling constants for vertex.                       *
C *     C,CC=: phase factors for massive fermions.                   *
C *     P1,P2,Q1,Q2=: light-like vectors decomposed by subroutine    *
C *                   SPLTQ.                                         *
C *     AALL=: calculated results of vertex amplitudes for all       *
C *            possible helicity states.                             *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ===========================================================
        SUBROUTINE FFSC(II,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALLL)
C       ===========================================================
C
        IMPLICIT REAL*8(A-H,O-Z)
        COMPLEX*16 AALL,AALLL,C,CC
        DIMENSION P1(4),P2(4),Q1(4),Q2(4),C(2),CC(2)
        DIMENSION AALL(2,2),AALLL(2,2)

        I2 = II - 2
        I2 = -I2
        I2 = I2 + 2

        CALL FFS(I2,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALL)

        AALLL(1,1) = -AALL(1,1)
        AALLL(1,2) = -AALL(1,2)
        AALLL(2,1) = -AALL(2,1)
        AALLL(2,2) = -AALL(2,2)

        RETURN
        END
C
C      ************************************************************
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *             ============================                 *
C      *                CHANEL   (version. 2.X)                   *
C      *             ============================                 *
C      *                                                          *
C      *                                                          *
C      *             SUBROUTINES for SUSY processes.              *
C      *             Version. 2 should be added.                  *
C      *                                                          *
C      *                   Written by H. Tanaka                   *
C      *                                                          *
C      *                                                          *
C      *                        ---------                         *
C      *                        Reference                         *
C      *                        ---------                         *
C      *    ' Numerical Calculation of Helicity Amplitudes        *
C      *      for Processes Involving Massive Fermions'           *
C      *                                                          *
C      *      H. Tanaka, Hiroshima University preprint            *
C      *         Comput. Phys. Commun. 58(1990) 153 - 168         *
C      *                                                          *
C      *                                                          *
C      *                         and                              *
C      *                                                          *
C      *    ' Numerical Calculation of Feynman Amplitudes         *
C      *      for Electroweak Theories and Application to         *
C      *      e(-) e(+) --> W(+) W(-) photon '                    *
C      *                                                          *
C      *                                                          *
C      *          H. Tanaka, T. Kanako and Y. Shimizu             *
C      *          KEK preprint 90 - 29, May 1990.                 *
C      *          Submitted to Comput. Phys. Commun.              *
C      *                                                          *
C      *   version for real*8 & complex*16                        *
C      *                                                          *
C      *                                                          *
C      ************************************************************

C
C ********************************************************************
C *         S                                                        *
C *         !                                                        *
C *         !                                                        *
C * F1--<---!---<---F2    SUBROUTINE FFST                            *
C *                                                                  *
C *     Purpose: to calculate vertex amplitudes for scalar boson-    *
C *              massive fermions vertex.                            *
C *                                                                  *
C *                 T             T_        T                        *
C *      U(II,AAM,Q) (AL*PL+AR*PR) U(I,AM,P)                         *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *     I,II=: indices to specify fermion(I,II=3) or antifermion     *
C *            (I,II=1) state.                                       *
C *     AM,AAM=: masses of fermions.                                 *
C *     AL,AR=: coupling constants for vertex.                       *
C *     C,CC=: phase factors for massive fermions.                   *
C *     P1,P2,Q1,Q2=: light-like vectors decomposed by subroutine    *
C *                   SPLTQ.                                         *
C *     AALL=: calculated results of vertex amplitudes for all       *
C *            possible helicity states.                             *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ===========================================================
        SUBROUTINE FFST(II,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALLL)
C       ===========================================================
C
        IMPLICIT REAL*8(A-H,O-Z)
        COMPLEX*16 AALL,AALLL,C,CC
        DIMENSION P1(4),P2(4),Q1(4),Q2(4),C(2),CC(2)
        DIMENSION AALL(2,2),AALLL(2,2)

CX      CALL FFS(I,II,AM,AAM,AL,AR,C,CC,P1,P2,Q1,Q2,AALL)

CX      AALLL(1,1) = AALL(1,1)
CX      AALLL(1,2) = AALL(2,1)
CX      AALLL(2,1) = AALL(1,2)
CX      AALLL(2,2) = AALL(2,2)

        I1 = I - 2
        I1 = -I1
        I1 = I1 + 2

        I2 = II - 2
        I2 = -I2
        I2 = I2 + 2

        CALL FFS(I2,I1,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,AALL)

        AALLL(1,1) = -AALL(1,1)
        AALLL(1,2) = -AALL(1,2)
        AALLL(2,1) = -AALL(2,1)
        AALLL(2,2) = -AALL(2,2)

        RETURN
        END
C
C ********************************************************************
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *   SUBROUTINE FFV(L:I*4, II:I*4, I:I*4, AAM:R*8, AM:R*8,          *
C *  &               AL:R*8, AR:R*8, CC:C*16(2), C:C*16(2),          *
C *  &               Q1:R*8(4), Q2:R*8(4), P1:R*8(4), P2:R*8(4),     *
C *  &               Q:R*8(4), AALL:C*16(4,2,2))                     *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for vector boson-    *
C *              massive fermions vertex.                            *
C *                                                                  *
C *     L=: Polarization state of vector boson.                      *
C *     I,II=: Indices to specify fermion(I,II=3) or antifermion     *
C *            (I,II=1) state.                                       *
C *     AM,AAM=: Masses of fermions.                                 *
C *     AL,AR=: Coupling constants for vertex.                       *
C *     C,CC=: Phase factors for massive fermions.                   *
C *     P1,P2,Q1,Q2=: Light-like vectors decomposed by subroutine    *
C *                   SPLTQ.                                         *
C *     Q=: Polarization vector of vector boson.                     *
C *     AALL=: Calculated results of vertex amplitudes for all       *
C *            possible helicity states.                             *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C *                                                                  *
C *    Q1, Q2 : FOR UB OR VB                                         *
C *    P1, P2 : FOR U OR V                                           *
C *                                                                  *
C *                                                                  *
C ********************************************************************
C
C
C       ===========================================================
        SUBROUTINE FFV(L,II,I,AAM,AM,AL,AR,CC,C,Q1,Q2,P1,P2,Q,AALL)
C       ===========================================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        COMPLEX*16 AALL
        COMPLEX*16 C,CC,AALL11,AALL22,AALL12,AALL21
        DIMENSION Q(4),P1(4),P2(4),Q1(4),Q2(4),C(2),CC(2)
        DIMENSION AALL(4,2,2),AALL11(2),AALL22(2),AALL12(2),AALL21(2)
 
        CALL FFV0(Q1,P1,Q,AALL11)
        CALL FFV0(Q2,P2,Q,AALL22)
        CALL FFV0(Q1,P2,Q,AALL12)
        CALL FFV0(Q2,P1,Q,AALL21)
        R  = DFLOAT(I  - 2)
        RR = DFLOAT(II - 2)
        IF (AM.LE.0.0D0) THEN
          R = 0.0D0
        ENDIF
        IF (AAM.LE.0.0D0) THEN
          RR = 0.0D0
        ENDIF
 
        J1 = (5-II)/2
        J2 = 3 - J1
        K1 = (5-I)/2
        K2 = 3 - K1
 
        AALL(L,J1,K1)=(AL*AALL11(1))
     &               +(AR*R*RR*C(2)*CC(2)*AALL22(2))
        AALL(L,J2,K2)=(AR*AALL11(2))
     &               +(AL*R*RR*C(1)*CC(1)*AALL22(1))
        AALL(L,J1,K2)=-(AR*RR*CC(2)*AALL21(2))
     &                -(AL*R*C(1)*AALL12(1))
        AALL(L,J2,K1)=-(AL*RR*CC(1)*AALL21(1))
     &                -(AR*R*C(2)*AALL12(2))
 
 
        RETURN
      END
C
C *******************************************************************
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *   SUBROUTINE FFV0(P1:R*8(4), P2:R*8(4), P:R*8(4), AALL:C*16(2)) *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *   Purpose: To calculate vertex amplitudes for vector boson-     *
C *            massless fermions vertex.                            *
C *                                                                 *
C *   P1,P2=: Momentum of massless fermions.                        *
C *   P=: Polarization vector of vector boson coupled to fermion.   *
C *   AALL=: Calculated results of vertex amplitudes.               *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *                                                                 *
C *                                          written by H. Tanaka   *
C *******************************************************************
C
C
C               ============================
                SUBROUTINE FFV0(P1,P2,P,AALL)
C               ============================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0)
        REAL*8 P,P1,P2
        COMPLEX*16 AALL
        DIMENSION P(4),P1(4),P2(4),AALL(2)
 
        IF (P1(4).LE.0.0D0 .OR. P2(4).LE.0.0D0) THEN
          AALL(1) = 0.0D0
          AALL(2) = 0.0D0
          RETURN
        END IF
 
        PT1  = SQRT(P1(2)**2 + P1(3)**2)
        IF(PT1.LE.0.0D0) THEN
          RR1Y = SIGN(ONE, P1(1))
          RR1Z = 0.0D0
        ELSE
          RR1Y = P1(2)/PT1
          RR1Z = P1(3)/PT1
        ENDIF
        IF(P1(1).GE.0.D0) THEN
          PS1  = SQRT(P1(4) + P1(1))
          RPP1 = PT1/PS1
        ELSE
          RPP1 = SQRT(P1(4) - P1(1))
          PS1  = PT1/RPP1
        ENDIF
        R1Y = RR1Y*PS1
        R1Z = RR1Z*PS1
 
        PT2  = SQRT(P2(2)**2 + P2(3)**2)
        IF(PT2.LE.0.0D0) THEN
          RR2Y = SIGN(ONE, P2(1))
          RR2Z = 0.0D0
        ELSE
          RR2Y = P2(2)/PT2
          RR2Z = P2(3)/PT2
        ENDIF
        IF(P2(1).GE.0.D0) THEN
          PS2  = SQRT(P2(4) + P2(1))
          RPP2 = PT2/PS2
        ELSE
          RPP2 = SQRT(P2(4) - P2(1))
          PS2  = PT2/RPP2
        ENDIF
        R2Y = RR2Y*PS2
        R2Z = RR2Z*PS2
 
        RR   = RPP1*RPP2*(P(4)+P(1))-RPP1*(P(2)*R2Y+P(3)*R2Z)
     *        -RPP2*(P(2)*R1Y+P(3)*R1Z)+(P(4)-P(1))*(R1Y*R2Y+R1Z*R2Z)
        RIMM = RPP1*(P(2)*R2Z-P(3)*R2Y)+RPP2*(P(3)*R1Y-P(2)*R1Z)
     *        +(P(4)-P(1))*(R1Z*R2Y-R1Y*R2Z)
 
        AALL(1)=DCMPLX(RR,-RIMM)
        AALL(2)=DCMPLX(RR, RIMM)
 
        RETURN
      END
      SUBROUTINE FFV00(LIND,AL,AR,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      DIMENSION Q(4)
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE
C- Q1,P1
           IF( LP13.AND.LP23 ) THEN
               ALL11R = P13RPP*P23RPP*(Q(4)+Q(1))
     .                 -P13RPP*(Q(2)*P23R2Y+Q(3)*P23R2Z)
     .                 -P23RPP*(Q(2)*P13R1Y+Q(3)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Y*P23R2Y+P13R1Z*P23R2Z)
               ALL11I = P13RPP*(Q(2)*P23R2Z-Q(3)*P23R2Y)
     .                 +P23RPP*(Q(3)*P13R1Y-Q(2)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Z*P23R2Y-P13R1Y*P23R2Z)
           ENDIF

           AALL(LIND,1,1) = AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,2,2) = AR*DCMPLX(ALL11R, ALL11I)

        RETURN
      END
*-----------------------------------------------------------------------
*     FFV  revised 94/04/08 by T.Ishikawa
*     AAM !=0 , AM != 0
*-----------------------------------------------------------------------
      SUBROUTINE FFVMM1(LIND,II,IO,AL,AR,CC,C,Q1,Q2,P1,P2,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      COMPLEX*16 C,CC
      DIMENSION Q(4),P1(4),P2(4),Q1(4)
      DIMENSION Q2(4),C(2),CC(2)
      INTEGER II,IO
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LQ1      = .TRUE.
          LQ2      = .TRUE.
          LP1      = .TRUE.
          LP2      = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LQ1 = .FALSE.
          IF( Q2(4) .LE. 0.0D0 ) LQ2 = .FALSE.
          IF( P1(4) .LE. 0.0D0 ) LP1 = .FALSE.
          IF( P2(4) .LE. 0.0D0 ) LP2 = .FALSE.
C-
          IF( LQ1 ) THEN
               PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q1RR1Y    = SIGN(ONE, Q1(1))
                   Q1RR1Z    = 0.0D0
               ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
               ENDIF
               IF( Q1(1).GE.0.D0) THEN
                   PS1       = SQRT(Q1(4) + Q1(1))
                   Q1RPP1    = PT1/PS1
               ELSE
                   Q1RPP1    = SQRT(Q1(4) - Q1(1))
                   PS1       = PT1/Q1RPP1
               ENDIF
               Q1R1Y    = Q1RR1Y*PS1
               Q1R1Z    = Q1RR1Z*PS1
           ENDIF

           IF( LQ2 ) THEN
               PT1        = SQRT(Q2(2)*Q2(2) + Q2(3)*Q2(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q2RR1Y    = SIGN(ONE, Q2(1))
                   Q2RR1Z    = 0.0D0
               ELSE
                   Q2RR1Y    = Q2(2)/PT1
                   Q2RR1Z    = Q2(3)/PT1
               ENDIF
               IF( Q2(1).GE.0.D0) THEN
                   PS1       = SQRT(Q2(4) + Q2(1))
                   Q2RPP1    = PT1/PS1
               ELSE
                   Q2RPP1    = SQRT(Q2(4) - Q2(1))
                   PS1       = PT1/Q2RPP1
               ENDIF
               Q2R1Y    = Q2RR1Y*PS1
               Q2R1Z    = Q2RR1Z*PS1
           ENDIF
C-
           IF( LP1 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P1RPP2    = PT2/PS2
               ELSE
                   P1RPP2    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P1RPP2
               ENDIF
               P1R2Y    = P1RR2Y*PS2
               P1R2Z    = P1RR2Z*PS2
           ENDIF

           IF( LP2 ) THEN
               PT2     = SQRT(P2(2)*P2(2) + P2(3)*P2(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P2RR2Y    = SIGN(ONE, P2(1))
                   P2RR2Z    = 0.0D0
               ELSE
                   P2RR2Y    = P2(2)/PT2
                   P2RR2Z    = P2(3)/PT2
               ENDIF
               IF( P2(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P2(4) + P2(1))
                   P2RPP2    = PT2/PS2
               ELSE
                   P2RPP2    = SQRT(P2(4) - P2(1))
                   PS2       = PT2/P2RPP2
               ENDIF
               P2R2Y    = P2RR2Y*PS2
               P2R2Z    = P2RR2Z*PS2
           ENDIF

           R     = DBLE(IO - 2)
           RR    = DBLE(II - 2)

C
           J1    = (5-II)/2
           J2    = 3 - J1
           K1    = (5-IO)/2
           K2    = 3 - K1

      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP1 ) THEN
               ALL11R = Q1RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P1R2Y+Q1R1Z*P1R2Z)
               ALL11I = Q1RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P1R2Y-Q1R1Y*P1R2Z)
           ENDIF
C- Q2,P2
           IF( LQ2.AND.LP2 ) THEN
               ALL22R = Q2RPP1*P2RPP2*(Q(4)+Q(1))
     .                 -Q2RPP1*(Q(2)*P2R2Y+Q(3)*P2R2Z)
     .                 -P2RPP2*(Q(2)*Q2R1Y+Q(3)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Y*P2R2Y+Q2R1Z*P2R2Z)
               ALL22I = Q2RPP1*(Q(2)*P2R2Z-Q(3)*P2R2Y)
     .                 +P2RPP2*(Q(3)*Q2R1Y-Q(2)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Z*P2R2Y-Q2R1Y*P2R2Z)
           ENDIF
C- Q1,P2
           IF( LQ1.AND.LP2 ) THEN
               ALL12R = Q1RPP1*P2RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P2R2Y+Q(3)*P2R2Z)
     .                 -P2RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P2R2Y+Q1R1Z*P2R2Z)
               ALL12I = Q1RPP1*(Q(2)*P2R2Z-Q(3)*P2R2Y)
     .                 +P2RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P2R2Y-Q1R1Y*P2R2Z)
           ENDIF
C- Q2,P1
           IF( LQ2.AND.LP1 ) THEN
               ALL21R = Q2RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q2RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q2R1Y+Q(3)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Y*P1R2Y+Q2R1Z*P1R2Z)
               ALL21I = Q2RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q2R1Y-Q(2)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Z*P1R2Y-Q2R1Y*P1R2Z)
           ENDIF
C---
           AALL(LIND,J1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
     &                 +(AR*R*RR*C(2)*CC(2)*DCMPLX(ALL22R, ALL22I))
           AALL(LIND,J2,K2)= AR*DCMPLX(ALL11R, ALL11I)
     &                 +(AL*R*RR*C(1)*CC(1)*DCMPLX(ALL22R,-ALL22I))
           AALL(LIND,J1,K2)= -(AR*RR*CC(2)*DCMPLX(ALL21R, ALL21I))
     &                 -(AL*R*C(1)*DCMPLX(ALL12R,-ALL12I))
           AALL(LIND,J2,K1)= -(AL*RR*CC(1)*DCMPLX(ALL21R,-ALL21I))
     &                 -(AR*R*C(2)*DCMPLX(ALL12R, ALL12I))

        RETURN
      END
C   08/03/94 403291234  MEMBER NAME  FFV0M    *.FORT        E2FORT
      SUBROUTINE FFVMM2(LIND,AL,AR,C,Q1,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION  AALL(4,2,2)
      COMPLEX*16 C
      DIMENSION  Q(4),Q1(4)
      DIMENSION  C(2)
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LP13   = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LP13 = .FALSE.
C-
          IF( LP13 ) THEN
              PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
              IF( PT1 .LE. 0.0D0) THEN
                  Q1RR1Y    = SIGN(ONE, Q1(1))
                  Q1RR1Z    = 0.0D0
              ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
              ENDIF
              IF( Q1(1).GE.0.D0) THEN
                  PS1       = SQRT(Q1(4) + Q1(1))
                  P13RPP    = PT1/PS1
              ELSE
                  P13RPP    = SQRT(Q1(4) - Q1(1))
                  PS1       = PT1/P13RPP
              ENDIF
              P13R1Y    = Q1RR1Y*PS1
              P13R1Z    = Q1RR1Z*PS1
          ENDIF
      ENDIF
C- Q1,P1
           IF( LP13.AND.LP1 ) THEN
               ALL11R = P13RPP*P1RPP2*(Q(4)+Q(1))
     .                 -P13RPP*(Q(2)*P1R2Y +Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*P13R1Y+Q(3)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Y*P1R2Y+P13R1Z*P1R2Z)
               ALL11I = P13RPP*(Q(2)*P1R2Z -Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*P13R1Y-Q(2)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Z*P1R2Y-P13R1Y*P1R2Z)
           ENDIF
C- Q1,P2
           IF( LP13.AND.LP2 ) THEN
               ALL12R = P13RPP*P2RPP2*(Q(4)+Q(1))
     .                 -P13RPP*(Q(2)*P2R2Y +Q(3)*P2R2Z)
     .                 -P2RPP2*(Q(2)*P13R1Y+Q(3)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Y*P2R2Y+P13R1Z*P2R2Z)
               ALL12I = P13RPP*(Q(2)*P2R2Z -Q(3)*P2R2Y)
     .                 +P2RPP2*(Q(3)*P13R1Y-Q(2)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Z*P2R2Y-P13R1Y*P2R2Z)
           ENDIF

           AALL(LIND,1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,2,K2)= AR*DCMPLX(ALL11R, ALL11I)
           AALL(LIND,1,K2)= -AL*R*C(1)*DCMPLX(ALL12R,-ALL12I)
           AALL(LIND,2,K1)= -AR*R*C(2)*DCMPLX(ALL12R, ALL12I)

        RETURN
      END
        SUBROUTINE FFVMM3(LIND,AL,AR,CC,P1,Q,AALL)
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0D0)
        COMPLEX*16 AALL
        DIMENSION  AALL(4,2,2)
        COMPLEX*16 CC
        DIMENSION  Q(4),P1(4)
        DIMENSION  CC(2)
        COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
C
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE
      IF( LIND .EQ. 1 ) THEN
           LP23      = .TRUE.
           IF( P1(4) .LE. 0.0D0 ) LP23 = .FALSE.
C-
           IF( LP23 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P23RPP    = PT2/PS2
               ELSE
                   P23RPP    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P23RPP
               ENDIF
               P23R2Y    = P1RR2Y*PS2
               P23R2Z    = P1RR2Z*PS2
           ENDIF
      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP23 ) THEN
               ALL11R = Q1RPP1*P23RPP*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P23R2Y+Q(3)*P23R2Z)
     .                 -P23RPP*(Q(2)*Q1R1Y +Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P23R2Y+Q1R1Z*P23R2Z)
               ALL11I = Q1RPP1*(Q(2)*P23R2Z-Q(3)*P23R2Y)
     .                 +P23RPP*(Q(3)*Q1R1Y -Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P23R2Y-Q1R1Y*P23R2Z)
           ENDIF
C- Q2,P1
           IF( LQ2.AND.LP23 ) THEN
               ALL21R = Q2RPP1*P23RPP*(Q(4)+Q(1))
     .                 -Q2RPP1*(Q(2)*P23R2Y+Q(3)*P23R2Z)
     .                 -P23RPP*(Q(2)*Q2R1Y +Q(3)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Y*P23R2Y+Q2R1Z*P23R2Z)
               ALL21I = Q2RPP1*(Q(2)*P23R2Z-Q(3)*P23R2Y)
     .                 +P23RPP*(Q(3)*Q2R1Y-Q(2)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Z*P23R2Y-Q2R1Y*P23R2Z)
           ENDIF
C---

           AALL(LIND,J1,1) = AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,J2,2) = AR*DCMPLX(ALL11R, ALL11I)
           AALL(LIND,J1,2) = -AR*RR*CC(2)*DCMPLX(ALL21R, ALL21I)
           AALL(LIND,J2,1) = -AL*RR*CC(1)*DCMPLX(ALL21R,-ALL21I)

      RETURN
      END
      SUBROUTINE FFVMM4(LIND,AL,AR,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      DIMENSION Q(4)
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE
C- Q1,P1
           IF( LP13.AND.LP23 ) THEN
               ALL11R = P13RPP*P23RPP*(Q(4)+Q(1))
     .                 -P13RPP*(Q(2)*P23R2Y+Q(3)*P23R2Z)
     .                 -P23RPP*(Q(2)*P13R1Y+Q(3)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Y*P23R2Y+P13R1Z*P23R2Z)
               ALL11I = P13RPP*(Q(2)*P23R2Z-Q(3)*P23R2Y)
     .                 +P23RPP*(Q(3)*P13R1Y-Q(2)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Z*P23R2Y-P13R1Y*P23R2Z)
           ENDIF

           AALL(LIND,1,1) = AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,2,2) = AR*DCMPLX(ALL11R, ALL11I)

        RETURN
      END
*-----------------------------------------------------------------------
*     FFV  revised 94/08/13 by T.Ishikawa
*      AAM != 0, AM = 0
*-----------------------------------------------------------------------
      SUBROUTINE FFVMM5(LIND,II,IO,AL,AR,CC,C,Q1,Q2,P1,P2,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      COMPLEX*16 C,CC
      DIMENSION Q(4),P1(4),P2(4),Q1(4)
      DIMENSION Q2(4),C(2),CC(2)
      INTEGER II,IO
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LQ1      = .TRUE.
          LQ2      = .TRUE.
          LP1      = .TRUE.
          LP2      = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LQ1 = .FALSE.
          IF( Q2(4) .LE. 0.0D0 ) LQ2 = .FALSE.
          IF( P1(4) .LE. 0.0D0 ) LP1 = .FALSE.
          IF( P2(4) .LE. 0.0D0 ) LP2 = .FALSE.
C-
          IF( LQ1 ) THEN
               PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q1RR1Y    = SIGN(ONE, Q1(1))
                   Q1RR1Z    = 0.0D0
               ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
               ENDIF
               IF( Q1(1).GE.0.D0) THEN
                   PS1       = SQRT(Q1(4) + Q1(1))
                   Q1RPP1    = PT1/PS1
               ELSE
                   Q1RPP1    = SQRT(Q1(4) - Q1(1))
                   PS1       = PT1/Q1RPP1
               ENDIF
               Q1R1Y    = Q1RR1Y*PS1
               Q1R1Z    = Q1RR1Z*PS1
           ENDIF

           IF( LQ2 ) THEN
               PT1        = SQRT(Q2(2)*Q2(2) + Q2(3)*Q2(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q2RR1Y    = SIGN(ONE, Q2(1))
                   Q2RR1Z    = 0.0D0
               ELSE
                   Q2RR1Y    = Q2(2)/PT1
                   Q2RR1Z    = Q2(3)/PT1
               ENDIF
               IF( Q2(1).GE.0.D0) THEN
                   PS1       = SQRT(Q2(4) + Q2(1))
                   Q2RPP1    = PT1/PS1
               ELSE
                   Q2RPP1    = SQRT(Q2(4) - Q2(1))
                   PS1       = PT1/Q2RPP1
               ENDIF
               Q2R1Y    = Q2RR1Y*PS1
               Q2R1Z    = Q2RR1Z*PS1
           ENDIF
C-
           IF( LP1 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P1RPP2    = PT2/PS2
               ELSE
                   P1RPP2    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P1RPP2
               ENDIF
               P1R2Y    = P1RR2Y*PS2
               P1R2Z    = P1RR2Z*PS2
           ENDIF

           R     = DBLE(IO - 2)
           RR    = DBLE(II - 2)
C
           J1    = (5-II)/2
           J2    = 3 - J1
           K1    = (5-IO)/2
           K2    = 3 - K1

      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP1 ) THEN
               ALL11R = Q1RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P1R2Y+Q1R1Z*P1R2Z)
               ALL11I = Q1RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P1R2Y-Q1R1Y*P1R2Z)
           ENDIF
C- Q2,P1
           IF( LQ2.AND.LP1 ) THEN
               ALL21R = Q2RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q2RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q2R1Y+Q(3)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Y*P1R2Y+Q2R1Z*P1R2Z)
               ALL21I = Q2RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q2R1Y-Q(2)*Q2R1Z)
     .                 +(Q(4)-Q(1))*(Q2R1Z*P1R2Y-Q2R1Y*P1R2Z)
           ENDIF
C---
           AALL(LIND,J1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,J2,K2)= AR*DCMPLX(ALL11R, ALL11I)
           AALL(LIND,J1,K2)= -(AR*RR*CC(2)*DCMPLX(ALL21R, ALL21I))
           AALL(LIND,J2,K1)= -(AL*RR*CC(1)*DCMPLX(ALL21R,-ALL21I))

      RETURN
      END
C   08/03/94 403291234  MEMBER NAME  FFV0M    *.FORT        E2FORT
      SUBROUTINE FFVMM6(LIND,AL,AR,C,Q1,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION  AALL(4,2,2)
      COMPLEX*16 C
      DIMENSION  Q(4),Q1(4)
      DIMENSION  C(2)
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LP13   = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LP13 = .FALSE.
C-
          IF( LP13 ) THEN
              PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
              IF( PT1 .LE. 0.0D0) THEN
                  Q1RR1Y    = SIGN(ONE, Q1(1))
                  Q1RR1Z    = 0.0D0
              ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
              ENDIF
              IF( Q1(1).GE.0.D0) THEN
                  PS1       = SQRT(Q1(4) + Q1(1))
                  P13RPP    = PT1/PS1
              ELSE
                  P13RPP    = SQRT(Q1(4) - Q1(1))
                  PS1       = PT1/P13RPP
              ENDIF
              P13R1Y    = Q1RR1Y*PS1
              P13R1Z    = Q1RR1Z*PS1
          ENDIF
      ENDIF
C- Q1,P1
           IF( LP13.AND.LP1 ) THEN
               ALL11R = P13RPP*P1RPP2*(Q(4)+Q(1))
     .                 -P13RPP*(Q(2)*P1R2Y +Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*P13R1Y+Q(3)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Y*P1R2Y+P13R1Z*P1R2Z)
               ALL11I = P13RPP*(Q(2)*P1R2Z -Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*P13R1Y-Q(2)*P13R1Z)
     .                 +(Q(4)-Q(1))*(P13R1Z*P1R2Y-P13R1Y*P1R2Z)
           ENDIF

           AALL(LIND,1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,2,K2)= AR*DCMPLX(ALL11R, ALL11I)

      RETURN
      END
*-----------------------------------------------------------------------
*     FFV  revised 94/04/08 by T.Ishikawa
*     AAM =0 , AM != 0
*-----------------------------------------------------------------------
      SUBROUTINE FFVMM7(LIND,II,IO,AL,AR,CC,C,Q1,Q2,P1,P2,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      COMPLEX*16 C,CC
      DIMENSION Q(4),P1(4),P2(4),Q1(4)
      DIMENSION Q2(4),C(2),CC(2)
      INTEGER II,IO
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LQ1      = .TRUE.
          LQ2      = .TRUE.
          LP1      = .TRUE.
          LP2      = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LQ1 = .FALSE.
          IF( Q2(4) .LE. 0.0D0 ) LQ2 = .FALSE.
          IF( P1(4) .LE. 0.0D0 ) LP1 = .FALSE.
          IF( P2(4) .LE. 0.0D0 ) LP2 = .FALSE.
C-
          IF( LQ1 ) THEN
               PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q1RR1Y    = SIGN(ONE, Q1(1))
                   Q1RR1Z    = 0.0D0
               ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
               ENDIF
               IF( Q1(1).GE.0.D0) THEN
                   PS1       = SQRT(Q1(4) + Q1(1))
                   Q1RPP1    = PT1/PS1
               ELSE
                   Q1RPP1    = SQRT(Q1(4) - Q1(1))
                   PS1       = PT1/Q1RPP1
               ENDIF
               Q1R1Y    = Q1RR1Y*PS1
               Q1R1Z    = Q1RR1Z*PS1
           ENDIF
C-
           IF( LP1 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P1RPP2    = PT2/PS2
               ELSE
                   P1RPP2    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P1RPP2
               ENDIF
               P1R2Y    = P1RR2Y*PS2
               P1R2Z    = P1RR2Z*PS2
           ENDIF

           IF( LP2 ) THEN
               PT2     = SQRT(P2(2)*P2(2) + P2(3)*P2(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P2RR2Y    = SIGN(ONE, P2(1))
                   P2RR2Z    = 0.0D0
               ELSE
                   P2RR2Y    = P2(2)/PT2
                   P2RR2Z    = P2(3)/PT2
               ENDIF
               IF( P2(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P2(4) + P2(1))
                   P2RPP2    = PT2/PS2
               ELSE
                   P2RPP2    = SQRT(P2(4) - P2(1))
                   PS2       = PT2/P2RPP2
               ENDIF
               P2R2Y    = P2RR2Y*PS2
               P2R2Z    = P2RR2Z*PS2
           ENDIF

           R     = DBLE(IO - 2)
           RR    = DBLE(II - 2)

C
           J1    = (5-II)/2
           J2    = 3 - J1
           K1    = (5-IO)/2
           K2    = 3 - K1

      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP1 ) THEN
               ALL11R = Q1RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P1R2Y+Q1R1Z*P1R2Z)
               ALL11I = Q1RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P1R2Y-Q1R1Y*P1R2Z)
           ENDIF

C- Q1,P2
           IF( LQ1.AND.LP2 ) THEN
               ALL12R = Q1RPP1*P2RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P2R2Y+Q(3)*P2R2Z)
     .                 -P2RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P2R2Y+Q1R1Z*P2R2Z)
               ALL12I = Q1RPP1*(Q(2)*P2R2Z-Q(3)*P2R2Y)
     .                 +P2RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P2R2Y-Q1R1Y*P2R2Z)
           ENDIF

C---
           AALL(LIND,J1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,J2,K2)= AR*DCMPLX(ALL11R, ALL11I)
           AALL(LIND,J1,K2)= -(AL*R*C(1)*DCMPLX(ALL12R,-ALL12I))
           AALL(LIND,J2,K1)= -(AR*R*C(2)*DCMPLX(ALL12R, ALL12I))

      RETURN
      END
        SUBROUTINE FFVMM8(LIND,AL,AR,CC,P1,Q,AALL)
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0D0)
        COMPLEX*16 AALL
        DIMENSION  AALL(4,2,2)
        COMPLEX*16 CC
        DIMENSION  Q(4),P1(4)
        DIMENSION  CC(2)
        COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2
C
      COMMON /WRKFFX/P13RPP,P13R1Y,P13R1Z,P23RPP,P23R2Y,P23R2Z,LP13,LP23
      LOGICAL    LP13,LP23

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE
      IF( LIND .EQ. 1 ) THEN
           LP23      = .TRUE.
           IF( P1(4) .LE. 0.0D0 ) LP23 = .FALSE.
C-
           IF( LP23 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P23RPP    = PT2/PS2
               ELSE
                   P23RPP    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P23RPP
               ENDIF
               P23R2Y    = P1RR2Y*PS2
               P23R2Z    = P1RR2Z*PS2
           ENDIF
      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP23 ) THEN
               ALL11R = Q1RPP1*P23RPP*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P23R2Y+Q(3)*P23R2Z)
     .                 -P23RPP*(Q(2)*Q1R1Y +Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P23R2Y+Q1R1Z*P23R2Z)
               ALL11I = Q1RPP1*(Q(2)*P23R2Z-Q(3)*P23R2Y)
     .                 +P23RPP*(Q(3)*Q1R1Y -Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P23R2Y-Q1R1Y*P23R2Z)
           ENDIF
C---
           AALL(LIND,J1,1) = AL*DCMPLX(ALL11R,-ALL11I)
           AALL(LIND,J2,2) = AR*DCMPLX(ALL11R, ALL11I)

      RETURN
      END
*-----------------------------------------------------------------------
*     FFV  revised 94/08/13 by T.Ishikawa
*     AAM =0 , AM = 0
*-----------------------------------------------------------------------
      SUBROUTINE FFVMM9(LIND,II,IO,AL,AR,CC,C,Q1,Q2,P1,P2,Q,AALL)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ONE = 1.0D0)
      COMPLEX*16 AALL
      DIMENSION AALL(4,2,2)
      COMPLEX*16 C,CC
      DIMENSION Q(4),P1(4),P2(4),Q1(4)
      DIMENSION Q2(4),C(2),CC(2)
      INTEGER II,IO
      COMMON /CHWORK/
     .        ALL11R,ALL11I,ALL12R,ALL12I,ALL21R,ALL21I,ALL22R,ALL22I,
     .        R,RR,
     .        Q1RPP1,Q1R1Y,Q1R1Z,Q2RPP1,Q2R1Y,Q2R1Z,
     .        P1RPP2,P1R2Y,P1R2Z,P2RPP2,P2R2Y,P2R2Z,
     .        J1,J2,K1,K2,
     .        LQ1,LQ2,LP1,LP2
      LOGICAL    LQ1,LQ2,LP1,LP2

*------------------------ Entry point ----------------------------------
         ALL11R = 0.0D0
         ALL11I = 0.0D0
         ALL12R = 0.0D0
         ALL12I = 0.0D0
         ALL21R = 0.0D0
         ALL21I = 0.0D0
         ALL22R = 0.0D0
         ALL22I = 0.0D0

      DO 90 I3= 1 , 2
      DO 90 I2= 1 , 2
         AALL(LIND,I2,I3)=(0.0D0,0.0D0)
   90 CONTINUE

      IF( LIND .EQ. 1 ) THEN
          LQ1      = .TRUE.
          LQ2      = .TRUE.
          LP1      = .TRUE.
          LP2      = .TRUE.
          IF( Q1(4) .LE. 0.0D0 ) LQ1 = .FALSE.
          IF( Q2(4) .LE. 0.0D0 ) LQ2 = .FALSE.
          IF( P1(4) .LE. 0.0D0 ) LP1 = .FALSE.
          IF( P2(4) .LE. 0.0D0 ) LP2 = .FALSE.
C-
          IF( LQ1 ) THEN
               PT1        = SQRT(Q1(2)*Q1(2) + Q1(3)*Q1(3))
               IF( PT1 .LE. 0.0D0) THEN
                   Q1RR1Y    = SIGN(ONE, Q1(1))
                   Q1RR1Z    = 0.0D0
               ELSE
                   Q1RR1Y    = Q1(2)/PT1
                   Q1RR1Z    = Q1(3)/PT1
               ENDIF
               IF( Q1(1).GE.0.D0) THEN
                   PS1       = SQRT(Q1(4) + Q1(1))
                   Q1RPP1    = PT1/PS1
               ELSE
                   Q1RPP1    = SQRT(Q1(4) - Q1(1))
                   PS1       = PT1/Q1RPP1
               ENDIF
               Q1R1Y    = Q1RR1Y*PS1
               Q1R1Z    = Q1RR1Z*PS1
           ENDIF

C-
           IF( LP1 ) THEN
               PT2     = SQRT(P1(2)*P1(2) + P1(3)*P1(3))
               IF( PT2 .LE. 0.0D0) THEN
                   P1RR2Y    = SIGN(ONE, P1(1))
                   P1RR2Z    = 0.0D0
               ELSE
                   P1RR2Y    = P1(2)/PT2
                   P1RR2Z    = P1(3)/PT2
               ENDIF
               IF( P1(1) .GE. 0.D0) THEN
                   PS2       = SQRT(P1(4) + P1(1))
                   P1RPP2    = PT2/PS2
               ELSE
                   P1RPP2    = SQRT(P1(4) - P1(1))
                   PS2       = PT2/P1RPP2
               ENDIF
               P1R2Y    = P1RR2Y*PS2
               P1R2Z    = P1RR2Z*PS2
           ENDIF


           R     = DBLE(IO - 2)
           RR    = DBLE(II - 2)

C
           J1    = (5-II)/2
           J2    = 3 - J1
           K1    = (5-IO)/2
           K2    = 3 - K1

      ENDIF
C- Q1,P1
           IF( LQ1.AND.LP1 ) THEN
               ALL11R = Q1RPP1*P1RPP2*(Q(4)+Q(1))
     .                 -Q1RPP1*(Q(2)*P1R2Y+Q(3)*P1R2Z)
     .                 -P1RPP2*(Q(2)*Q1R1Y+Q(3)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Y*P1R2Y+Q1R1Z*P1R2Z)
               ALL11I = Q1RPP1*(Q(2)*P1R2Z-Q(3)*P1R2Y)
     .                 +P1RPP2*(Q(3)*Q1R1Y-Q(2)*Q1R1Z)
     .                 +(Q(4)-Q(1))*(Q1R1Z*P1R2Y-Q1R1Y*P1R2Z)
           ENDIF
C---
      AALL(LIND,J1,K1)= AL*DCMPLX(ALL11R,-ALL11I)
      AALL(LIND,J2,K2)= AR*DCMPLX(ALL11R, ALL11I)

      RETURN
      END
C ********************************************************************
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *   SUBROUTINE PHASEQ(I:I*4, P:R*8(4), C:C*16(2))                  *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *   Purpose: To calculate phase factors for massive fermion.       *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *         I=: I=1 for complex phase C                              *
C *             I=2 for conjugate of phase C                         *
C *         P=: Momuntum of massive fermion.                         *
C *         C=: Calculated phase factors.                            *
C *                                            written by H. Tanaka  *
C ********************************************************************
C
C
C               ========================
                SUBROUTINE PHASEQ(I,P,C)
C               ========================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0)
 
        COMPLEX*16 C
        DIMENSION P(4),C(2)
 
        PTN=DSQRT(P(2)**2+P(3)**2)
        IF (PTN.LE.0.D0) THEN
          PYN=SIGN(ONE, P(1))
          PZN=0.0D0
        ELSE
          PYN=P(2)/PTN
          PZN=P(3)/PTN
        ENDIF
        IF (I.EQ.2) PZN=-PZN
        C(1)=DCMPLX(-PYN,PZN)
        C(2)=DCMPLX( PYN,PZN)
        RETURN
      END
************************************************************************
C
C      ************************************************************
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *             ============================                 *
C      *                CHANEL   (Version. 1.1)                   *
C      *             ============================                 *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                   Written by H. Tanaka                   *
C      *                                                          *
C      *                                                          *
C      *                        ---------                         *
C      *                        Reference                         *
C      *                        ---------                         *
C      *    ' Numerical Calculation of Helicity Amplitudes        *
C      *      for Processes Involving Massive Fermions'           *
C      *                                                          *
C      *      H. Tanaka, Hiroshima University preprint            *
C      *         Accepted to Comput. Phys. Commun.                *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      ************************************************************
C
C
C
C
C
C ******************************************************************
C *                                                                *
C *  SUBROUTINE POL(I:I*4, AM:R*8, P:R*8(4), EP:R*8(4), EM:R*8(4)) *
C *                                                                *
C *     Purpose: To set components of polarization vectors.        *
C *                                                                *
C *     I= : Polarization states   I=1,2 : Transverse              *
C *                                I=3   : Longitudinal            *
C *                                I=4   : Scalar                  *
C *                                                                *
C *     AM= : Mass of vector boson                                 *
C *     P = : Momentum of vector boson                             *
C *     EP= : Polarization vector for state I                      *
C *     EM= : Weight factors                                       *
C *                                                                *
C *                                                                *
C *                                                                *
C *     Note                                                       *
C *     ----                                                       *
C *                                                                *
C *     For summation of the polarization vectors I=1 to 4,        *
C *     following gauges are chosen :                              *
C *                                                                *
C *     Unitary gauge : for massive vector boson                   *
C *     Feynman gauge : for massless vector boson                  *
C *                                                                *
C *                                                                *
C *                                    written by H. Tanaka        *
C ******************************************************************
C
C
C              ============================
               SUBROUTINE POL(I,AM,P,EP,EM)
C              ============================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0)
        DIMENSION P(4),EP(4),EM(4)
        DATA DD/0.D0/
 
        PT2 = P(1)**2 + P(2)**2
        PP  = (P(4) - P(3))*(P(4) + P(3)) - PT2
        IF (PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = P(2)*PTI
          RTX = P(1)*PTI
        END IF
        PN2 = PT2 + P(3)**2
        IF (PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF (PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = P(1)*PNI
          RNY = P(2)*PNI
          RNZ = P(3)*PNI
          RTN = PT*PNI
        END IF
        IF (I.EQ.1) THEN
          EP(1) =  RTX*RNZ
          EP(2) =  RTY*RNZ
          EP(3) = -RTN
          EP(4) =  0.0D0
          EM(1) =  1.0D0
        ELSE IF (I.EQ.2) THEN
          EP(1) = -RTY
          EP(2) =  RTX
          EP(3) =  0.0D0
          EP(4) =  0.0D0
          EM(2) =  1.0D0
        ELSE IF (I.EQ.3) THEN
          APP=ABS(PP)
          IF (APP.LE.DD) THEN
            EP(1) = 0.0D0
            EP(2) = 0.0D0
            EP(3) = 0.0D0
            EP(4) = 0.0D0
            EM(3) = 0.0D0
          ELSE
            RPPI  = 1.0D0/SQRT(APP)
            EP(1) = RNX*P(4)*RPPI
            EP(2) = RNY*P(4)*RPPI
            EP(3) = RNZ*P(4)*RPPI
            EP(4) = PN*RPPI
            EM(3) = SIGN(1.0D0, PP)
          ENDIF
        ELSE IF (I.EQ.4) THEN
          APP = ABS(PP)
          IF (APP.LE.DD) THEN
            EP(1) = 0.D0
            EP(2) = 0.D0
            EP(3) = 0.D0
            EP(4) = 0.D0
            EM(4) = 0.0D0
          ELSE
            RPPI  = 1.0D0/SQRT(APP)
            EP(1) = P(1)*RPPI
            EP(2) = P(2)*RPPI
            EP(3) = P(3)*RPPI
            EP(4) = P(4)*RPPI
            IF (AM.GT.0.D0) THEN
              EM(4)=  SIGN(ONE, PP)*(PP/AM**2-1.0D0)
            ELSE
              EM(4)= -SIGN(ONE, PP)
            END IF
          ENDIF
        END IF
        RETURN
      END
C
C
C
C ******************************************************************
C *                                                                *
C *  SUBROUTINE POLA(I:I*4, A:R*8 , AM:R*8, P:R*8(4),              *
C *                                       EP:R*8(4), EM:R*8(4))    *
C *                                                                *
C *     Purpose: To set components of polarization vectors         *
C *              for covarient gauge.                              *
C *                                                                *
C *     I= : Polarization states   I=1,2 : Transverse              *
C *                                I=3   : Longitudinal            *
C *                                I=4   : Scalar                  *
C *                                                                *
C *     A = : Gauge parametor                                      *
C *     AM= : Mass of vector boson                                 *
C *     P = : Momentum of vector boson                             *
C *     EP= : Polarization vector for state I                      *
C *     EM= : Weight factors                                       *
C *                                                                *
C *                                                                *
C *                                                                *
C *     Note                                                       *
C *     ----                                                       *
C *                                                                *
C *     For summation of the polarization vectors I=1 to 4,        *
C *     following gauges are chosen :                              *
C *                                                                *
C *     For A < 100                                                *
C *                                                                *
C *     Covarient gauge : for massive and massless vector boson    *
C *     Feynman gauge : if A*AM**2 = P*P                           *
C *                                                                *
C *     For A > 100                                                *
C *                                                                *
C *     Unitary gauge : for massive vector boson                   *
C *     Covarient gauge : for massless vector boson                *
C *                                                                *
C *                                    written by H. Tanaka        *
C ******************************************************************
C
C
C              ===================================
               SUBROUTINE POLA(I,A,AM,P,EP,EM)
C              ===================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION P(4),EP(4),EM(4)
        DATA DD/0.D0/
 
        PT2 = P(1)**2 + P(2)**2
        PP  = (P(4) - P(3))*(P(4) + P(3)) - PT2
        IF (PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = P(2)*PTI
          RTX = P(1)*PTI
        END IF
        PN2 = PT2 + P(3)**2
        IF (PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF (PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = P(1)*PNI
          RNY = P(2)*PNI
          RNZ = P(3)*PNI
          RTN = PT*PNI
        END IF
        IF (I.EQ.1) THEN
          EP(1) =  RTX*RNZ
          EP(2) =  RTY*RNZ
          EP(3) = -RTN
          EP(4) =  0.0D0
          EM(1) =  1.0D0
CX        EM(1) =  PROP
        ELSE IF (I.EQ.2) THEN
          EP(1) = -RTY
          EP(2) =  RTX
          EP(3) =  0.0D0
          EP(4) =  0.0D0
          EM(2) =  1.0D0
CX        EM(2) =  PROP
        ELSE IF (I.EQ.3) THEN
          APP=ABS(PP)
          IF (APP.LE.DD) THEN
            EP(1) = 0.0D0
            EP(2) = 0.0D0
            EP(3) = 0.0D0
            EP(4) = 0.0D0
            EM(3) = 0.0D0
          ELSE
            RPPI  = 1.0D0/SQRT(APP)
            EP(1) = RNX*P(4)*RPPI
            EP(2) = RNY*P(4)*RPPI
            EP(3) = RNZ*P(4)*RPPI
            EP(4) = PN*RPPI
            EM(3) = SIGN(1.0D0, PP)
CX          EM(3) = SIGN(1.0D0, PP)*PROP
          ENDIF
        ELSE IF (I.EQ.4) THEN
          APP = ABS(PP)
          IF (APP.LE.DD) THEN
            EP(1) = 0.D0
            EP(2) = 0.D0
            EP(3) = 0.D0
            EP(4) = 0.D0
            EM(4) = 0.0D0
          ELSE
            RPPI  = 1.0D0/SQRT(APP)
            EP(1) = P(1)*RPPI
            EP(2) = P(2)*RPPI
            EP(3) = P(3)*RPPI
            EP(4) = P(4)*RPPI
              AM2 = AM*AM
CX          IF (A.NE.1.D0.AND.A.LT.100.D0) THEN
            IF (A.LT.100.D0) THEN
              IF (A*AM2.NE.PP) THEN
              EM(4) = SIGN(1.0D0, PP)*(AM2-PP)/(PP-A*AM2)*A
              ELSE
              EM(4)= -SIGN(1.0D0, PP)
              WRITE(6,*) ' Caution : p*p = a*m**2 '
              WRITE(6,*) '  a = 1 was taken. '
              END IF
CX          ELSE IF (A.EQ.1.D0) THEN
CX            EM(4)= -SIGN(1.0D0, PP)
            ELSE
            IF (AM.GT.0.D0) THEN
              EM(4)=  SIGN(1.0D0, PP)*(PP/AM**2-1.0D0)
            ELSE
              EM(4) =-SIGN(1.0D0, PP)*A
            END IF
            END IF
          ENDIF
        END IF
        RETURN
      END
C ******************************************************************
C *                                                                *
C *  SUBROUTINE POLP(I:I*4, A:R*8 , AM:R*8, P:R*8(4),              *
C *                                       EP:R*8(4), EM:R*8(4))    *
C *                                                                *
C *     Purpose: To set components of polarization vectors         *
C *              for QED vertex with on-shell fermions.            *
C *                                                                *
C *              -                                                 *
C *              U(P2)(EP)U(P1) vertex with P1**2=P2**2=m**2       *
C *                                                                *
C *                                                                *
C *     I= : Polarization states   I=1,2 : Transverse              *
C *                                I=3   : Longitudinal            *
C *                                I=4   : Scalar                  *
C *                                                                *
C *     (*) I=5: EP(P)=P for massless gauge bosons.                *
C *         ( For check of gouge invarience for external           *
C *           massless gouge boson legs.)                          *
C *                                                                *
C * X   A = : Gauge parametor                                      *
C *     AM= : Mass of vector boson                                 *
C *     P = : Momentum of vector boson                             *
C *     EP= : Polarization vector for state I                      *
C *     EM= : Weight factors                                       *
C *                                                                *
C *                                                                *
C *                                                                *
C *     Note                                                       *
C *     ----                                                       *
C *                                                                *
C *     Use only to QED vertex.  Gauge invarience can not          *
C *     be cheched in this subroutine.                             *
C *                                    written by H. Tanaka        *
C ******************************************************************
C
C
C              ===================================
               SUBROUTINE POLP(I,A,AM,P,EP,EM)
C              ===================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION P(4),EP(4),EM(4)
        DATA DD/0.D0/

        PT2 = P(1)**2 + P(2)**2
        PP  = (P(4) - P(3))*(P(4) + P(3)) - PT2
        IF (PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = P(2)*PTI
          RTX = P(1)*PTI
        END IF

        PN2 = PT2 + P(3)**2
        IF (PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF (PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = P(1)*PNI
          RNY = P(2)*PNI
          RNZ = P(3)*PNI
          RTN = PT*PNI
        END IF

        IF (I.EQ.1) THEN
          EP(1) =  RTX*RNZ
          EP(2) =  RTY*RNZ
          EP(3) = -RTN
          EP(4) =  0.0D0
          EM(1) =  1.0D0
CX        EM(1) =  PROP
        ELSE IF (I.EQ.2) THEN
          EP(1) = -RTY
          EP(2) =  RTX
          EP(3) =  0.0D0
          EP(4) =  0.0D0
          EM(2) =  1.0D0
CX        EM(2) =  PROP
        ELSE IF (I.EQ.3) THEN
          APP=ABS(PP)
          IF (APP.LE.DD) THEN
            EP(1) = 0.0D0
            EP(2) = 0.0D0
            EP(3) = 0.0D0
            EP(4) = 0.0D0
            EM(3) = 0.0D0
          ELSE
            EP(1) = 0.D0
            EP(2) = 0.D0
            EP(3) = 0.D0
            EP(4) = -SQRT(APP)/PN
            EM(3) = SIGN(1.0D0, PP)
CX          EM(3) = SIGN(1.0D0, PP)*PROP
          ENDIF
        ELSE IF (I.EQ.4) THEN
            EP(1) = 0.D0
            EP(2) = 0.D0
            EP(3) = 0.D0
            EP(4) = 0.D0
            EM(4) = 0.0D0
        ELSE IF (I.EQ.5) THEN
          EP(1) = P(1)
          EP(2) = P(2)
          EP(3) = P(3)
          EP(4) = P(4)
        END IF

        RETURN
        END
************************************************************************
      SUBROUTINE SMCONF(LT1,LT2,LP1,LP2,EW,AV1,AV2,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * DUMMY ARRAY SIZE.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      COMPLEX*16 AV1(0:LASIZE), AV2(0:LASIZE), AV(0:LASIZE)
      INTEGER    LT1(0:LTSIZE), LT2(0:LTSIZE), LT(0:LTSIZE)
      INTEGER    LP1, LP2
      DIMENSION  EW(2)
*
*   CONNECT TWO PARTIAL AMPLITUDES BY A FERMIONIC PROPAGATOR.
*   DENOMINATOR OF THE PROPAGATOR SHOULD BE MULTIPLIED ELSEWHERE.
*
*      EW       : INPUT  : WEIGHT FOR PROPAGATOR
*      AV1, AV2 : INPUT  : TABLES OF AMPLITUDES
*      LT1, LT2 : INPUT  : TABLES OF SIZES.
*      AV       : OUTPUT : TABLES OF AMPLITUDES
*      LT       : OUTPUT : TABLES OF SIZES.
*
*      DECLARATION OF TABLE OF AMPLITUDES
*
*         DIMENTION AV(LAV)
*         LAV = (FOR I = 1 TO N PRODUCT LT(I)),  N = LT(0)
*
*      IS EQUIVALENT TO
*
*         DIMENSION AV(0:LT(1)-1, 0:LT(2)-1, ... , 0:LT(N)-1)
*
*      AN ELEMENT OF THE TABLE
*
*         AV(I_1, I_2, ... , I_N),    0 <= I_J < LT(J)
*
*      IS ACCESSIBLE BY
*
*         AV(I)
*
*      WHERE
*
*         I = (FOR J = 1 TO N  SUM I_J*BASE_J)
*         BASE_J = (FOR K = 1 TO J - 1 PRODUCT LT(K))
*
*      THIS SUBROUTINE CALCULATES.
*
*        AV( I_1, ..., I_(LP1-1), I_(LP1+1), ..., I_(LT1(0)),
*            J_1, ..., J_(LP2-1), J_(LP2+1), ..., J_(LT2(0)) )
*
*        = (FOR K1 = 0 TO 1, K2 = 0 TO 1  SUM
*             AV1(I_1,...,I_(LP1-1),K1,K2,I_(LP1+1),...,I_(LT1(0)))
*            *AV2(J_1,...,J_(LP2-1),K1,K2,J_(LP2+1),...,J_(LT2(0)))
*            *EW(K2) )
*
*       WHERE, K1 IS THE SPIN INDEX AND K2 IS THE INDEX CORRESPONDING
*       TO DECOMPOSED MOMENTA L1 AND L2.
*
      DIMENSION EM(0:3)

*      COMPLEX*32 AVK
      COMPLEX*16 AVK

*-----------------------------------------------------------------------
      EM(0) = EW(1)
      EM(1) = EW(1)
      EM(2) = EW(2)
      EM(3) = EW(2)
      LP = LT1(LP1)
      IF(LP.NE.LT2(LP2)) THEN
        WRITE(6,*) '*** SMCONF:INCONSISTENT TABLE SIZE OF AMPLITUDE.'
        WRITE(6,*) 'LT1(',LP1,') = ', LT1(LP1)
        WRITE(6,*) 'LT2(',LP2,') = ', LT2(LP2)
        WRITE(6,*) 'LT1 =', LT1
        WRITE(6,*) 'LT2 =', LT2
        STOP
      ENDIF
      J = 0
      ILOW1 = 1
      DO 10 I = 1, LP1 - 1
        J = J + 1
        LT(J) = LT1(I)
        ILOW1  = ILOW1 * LT1(I)
   10 CONTINUE
      IHIGH1 = 1
      DO 20 I = LP1 + 1, LT1(0)
        J = J + 1
        LT(J) = LT1(I)
        IHIGH1 = IHIGH1 * LT1(I)
   20 CONTINUE
      ILOW2 = 1
      DO 30 I = 1, LP2 - 1
        J = J + 1
        LT(J) = LT2(I)
        ILOW2  = ILOW2 * LT2(I)
   30 CONTINUE
      IHIGH2 = 1
      DO 40 I = LP2 + 1, LT2(0)
        J = J + 1
        LT(J) = LT2(I)
        IHIGH2 = IHIGH2 * LT2(I)
   40 CONTINUE
      LT(0) = J
      ILOW   = ILOW1 * IHIGH1
      IHIGH  = ILOW2 * IHIGH2
*
      DO 100 IL1 = 0, ILOW1  - 1
      DO 100 IH1 = 0, IHIGH1 - 1
        IL  = IH1 * ILOW1 + IL1
        KK1 = IH1 * ILOW1 * LP + IL1
        DO 100 IL2 = 0, ILOW2  - 1
        DO 100 IH2 = 0, IHIGH2 - 1
          IH  = IH2 * ILOW2 + IL2
          KK2 = IH2 * ILOW2 * LP + IL2
          K   = IH  * ILOW  + IL
          AVK = 0.0D0
          DO 200 IPOL = 0, LP - 1
            K1 = KK1 + IPOL * ILOW1
            K2 = KK2 + IPOL * ILOW2
            AVK = AVK + AV1(K1)*AV2(K2)*EM(IPOL)
  200     CONTINUE
          AV(K) = AVK
  100 CONTINUE
*     CALL CTIME('SMCONF')
      RETURN
      END
************************************************************************
      SUBROUTINE SMCONS(LT1,LT2,LP1,LP2,AV1,AV2,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      COMPLEX*16 AV1(0:LASIZE), AV2(0:LASIZE), AV(0:LASIZE)
      INTEGER    LP1, LP2
      INTEGER    LT1(0:LTSIZE), LT2(0:LTSIZE), LT(0:LTSIZE)
*
*   Connect two partial amplitudes by a propagator of vector boson.
*   Denominator of the propagator should be multiplied elsewhere.
*
*      AV1, AV2 : input  : Tables of amplitudes
*      LT1, LT2 : input  : Tables of sizes.
*      AV       : output : resulting table of amplitudes
*      LT       : output : resulting table of sizes
*
*      Declaration of table of amplitudes
*
*         DIMENTION AV(lav)
*         lav = (for i = 1 to n product LT(i)),  n = LT(0)
*
*      is equivalent to
*
*         DIMENSION AV(0:LT(1)-1, 0:LT(2)-1, ... , 0:LT(n)-1)
*
*      An element of the table
*
*         AV(i_1, i_2, ... , i_n),    0 <= i_j < LT(j)
*
*      is accessible by
*
*         AV(i)
*
*      where
*
*         i = (for j = 1 to n  sum i_j*base_j)
*         base_j = (for k = 1 to j - 1 product LT(k))
*
*      This subroutine calculates.
*
*        AV( i_1, ..., i_(LT1(0)), j_1, ..., j_(LT2(0)) )
*
*        =    AV1( i_1, ..., i_(LT1(0)) ) * AV2( j_1, ..., j_(LT2(0)) )
*
*-----------------------------------------------------------------------
      IF(LT1(LP1).NE.1 .OR. LT2(LP2).NE.1) THEN
        WRITE(6,*) '*** SMCONS:INCONSISTENT TABLE SIZE OF AMPLITUDE.'
        WRITE(6,*) 'LT1(',LP1,') = ', LT1(LP1)
        WRITE(6,*) 'LT2(',LP2,') = ', LT2(LP2)
        WRITE(6,*) 'LT1 =', LT1
        WRITE(6,*) 'LT2 =', LT2
        STOP
      ENDIF
      LT(0) = LT1(0) + LT2(0) - 2
      IT = 1
      IL1 = 1
      DO 10 I = 1, LT1(0)
        IF(LP1.NE.I) THEN
          IL1    = IL1*LT1(I)
          LT(IT) = LT1(I)
          IT     = IT + 1
        ENDIF
   10 CONTINUE
      IL2 = 1
      DO 20 I = 1, LT2(0)
        IF(LP2.NE.I) THEN
          IL2 = IL2*LT2(I)
          LT(IT) = LT2(I)
          IT     = IT + 1
        ENDIF
   20 CONTINUE
      K = 0
      DO 100 K2 = 0, IL2 - 1
      DO 100 K1 = 0, IL1 - 1
        AV(K) = AV1(K1)*AV2(K2)
        K = K + 1
  100 CONTINUE
*     CALL CTIME('SMCONS')
      RETURN
      END
************************************************************************
      SUBROUTINE SMCONV(LT1,LT2,LP1,LP2,EW,AV1,AV2,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      COMPLEX*16 AV1(0:LASIZE), AV2(0:LASIZE), AV(0:LASIZE)
      INTEGER    LT1(0:LTSIZE), LT2(0:LTSIZE), LT(0:LTSIZE)
      INTEGER    LP1, LP2
      DIMENSION  EW(0:3)
*
*   Connect two partial amplitudes by a propagator of vector boson.
*   Denominator of the propagator should be multiplied elsewhere.
*
*      EW       : input  : Weight for propagator
*      AV1, AV2 : input  : Tables of amplitudes
*      LT1, LT2 : input  : Tables of sizes.
*      AV       : output : resulting table of amplitudes
*      LT       : output : resulting table of sizes
*
*      Declaration of table of amplitudes
*
*         DIMENTION AV(lav)
*         lav = (for i = 1 to n product LT(i)),  n = LT(0)
*
*      is equivalent to
*
*         DIMENSION AV(0:LT(1)-1, 0:LT(2)-1, ... , 0:LT(n)-1)
*
*      An element of the table
*
*         AV(i_1, i_2, ... , i_n),    0 <= i_j < LT(j)
*
*      is accessible by
*
*         AV(i)
*
*      where
*
*         i = (for j = 1 to n  sum i_j*base_j)
*         base_j = (for k = 1 to j - 1 product LT(k))
*
*      This subroutine calculates.
*
*        AV( i_1, ..., i_(LP1-1), i_(LP1+1), ..., i_(LT1(0)),
*            j_1, ..., j_(LP2-1), j_(LP2+1), ..., j_(LT2(0)) )
*
*        = (for k = 0 to LP-1  sum
*             AV1( i_1, ..., i_(LP1-1), k, i_(LP1+1), ..., i_(LT1(0)) )
*            *AV2( j_1, ..., j_(LP2-1), k, j_(LP2+1), ..., j_(LT2(0)) )
*            *EW(k) )
*
*       where, LP = LT1(LP1) = LT2(LP2) is a degree of freedom for
*       vector boson poralization.
*

*      COMPLEX*32 AVK
      COMPLEX*16 AVK

*-----------------------------------------------------------------------
      LP = LT1(LP1)
      IF(LP.NE.LT2(LP2)) THEN
        WRITE(6,*) '*** SMCONV:INCONSISTENT TABLE SIZE OF AMPLITUDE.'
        WRITE(6,*) 'LT1(',LP1,') = ', LT1(LP1)
        WRITE(6,*) 'LT2(',LP2,') = ', LT2(LP2)
        WRITE(6,*) 'LT1 =', LT1
        WRITE(6,*) 'LT2 =', LT2
        STOP
      ENDIF
      J = 0
      ILOW1 = 1
      DO 10 I = 1, LP1 - 1
        J = J + 1
        LT(J) = LT1(I)
        ILOW1  = ILOW1 * LT1(I)
   10 CONTINUE
      IHIGH1 = 1
      DO 20 I = LP1 + 1, LT1(0)
        J = J + 1
        LT(J) = LT1(I)
        IHIGH1 = IHIGH1 * LT1(I)
   20 CONTINUE
      ILOW2 = 1
      DO 30 I = 1, LP2 - 1
        J = J + 1
        LT(J) = LT2(I)
        ILOW2  = ILOW2 * LT2(I)
   30 CONTINUE
      IHIGH2 = 1
      DO 40 I = LP2 + 1, LT2(0)
        J = J + 1
        LT(J) = LT2(I)
        IHIGH2 = IHIGH2 * LT2(I)
   40 CONTINUE
      LT(0) = J
      ILOW   = ILOW1 * IHIGH1
CC    IHIGH  = ILOW2 * IHIGH2
*
      DO 100 IL1 = 0, ILOW1  - 1
      DO 100 IH1 = 0, IHIGH1 - 1
        IL  = IH1 * ILOW1 + IL1
        KK1 = IH1 * ILOW1 * LP + IL1
        DO 100 IL2 = 0, ILOW2  - 1
        DO 100 IH2 = 0, IHIGH2 - 1
          IH  = IH2 * ILOW2 + IL2
          KK2 = IH2 * ILOW2 * LP + IL2
          K   = IH  * ILOW  + IL
          AVK = 0.0D0
          DO 200 IPOL = 0, LP - 1
            K1 = KK1 + IPOL * ILOW1
            K2 = KK2 + IPOL * ILOW2
            AVK = AVK + AV1(K1)*AV2(K2)*EW(IPOL)
  200     CONTINUE
          AV(K) = AVK
  100 CONTINUE
*     CALL CTIME('SMCONV')
      RETURN
      END
* File smcpol.f
* 
*          Fortran source code generator
* 
************************************************************************
      subroutine smcpol(la, lvt, avt)
      implicit real*8(a-h,o-z)
      parameter (ltsize = 20, lasize = 1024 )
**    include 'incl1.f'
**    include 'inclk.f'
**    integer    lvt(0:nextn)
      integer    lvt(0:ltsize)
**    complex*16 avt(0:lag-1)
      complex*16 avt(0:lasize)
*
**    integer j(nextn), jv(nextn)
      integer j(ltsize), jv(ltsize)
      complex*16 zi, zr, ztv, ztw
      data ifst/0/
      save ifst, zr, zi
*-----------------------------------------------------------------------
      if(ifst.eq.0) then
        ifst = 1
        r2 = 1.0d0/sqrt(2.0d0)
        zr = dcmplx(1.0d0,0.0d0)*r2
        zi = dcmplx(0.0d0,1.0d0)*r2
      endif

      nextn = lvt(0)
      print *,'smcpol:nextn',nextn
      ja = la
*     if(lt(ja) .ne. 2) then
*       write(*,*) 'smcpol: cannot calculate circlar polarization'
*       write(*,*) 'lt = ', lt
*       write(*,*) 'lt(',ja,') = ', lt(ja), ' <> 2'
*       stop
*     endif
      if(lvt(ja) .ne. 2) then
        write(*,*) 'smcpol: cannot calculate circlar polarization'
        write(*,*) 'lt = ', lvt
        write(*,*) 'lt(',ja,') = ', lvt(ja), ' <> 2'
        stop
      endif

      ibas  = 1
      do 10 i = 1, nextn
        jv(i) = ibas
        ibas  = ibas*lvt(i)
        j(i)  = 0
   10 continue

  100 continue
        iv = 0
        do 110 i = 1, nextn
          iv = iv +   jv(i)*j(i)
  110   continue
        iw = iv + jv(ja)

        ztv =   zr*avt(iv) + zi*avt(iw)
        ztw =   zr*avt(iv) - zi*avt(iw)
        avt(iv) = ztv
        avt(iw) = ztw

c       write(*,*) 'smcpol:', j
c       write(*,*) 'smcpol:', iv, iw, avt(iv)
c       write(*,*) 'smcpol:', iw, iv, avt(iw)

        ii = 1
  120   continue
          if(ii .eq. ja) then
            ii = ii + 1
            if(ii.gt.nextn) then
              goto 190
            endif
          endif
          j(ii) = j(ii) + 1
          if(j(ii).ge.lvt(ii)) then
            j(ii) = 0
            ii = ii + 1
            if(ii.le.nextn) then
              goto 120
            else
              goto 190
            endif
          endif
        goto 100
  190 continue
      return
      end
************************************************************************
      SUBROUTINE SMEXTF(IO, AM, PE, PS, CE)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
      INTEGER    IO
*     REAL*8     AM
      DIMENSION  PE(4), PS(4,2)
      COMPLEX*16 CE(2, 2)
*
*   Decompose momentum of internal fermion.
*
*         PE = L1 + L2
*         L1**2 = 0
*         L2**2 = 0
*         PS(*,1) = L1
*         PS(*,2) = L2
*
*     IO : input  : 1: imcoming, u or v    2: outgoing, ub or vb
*     AM : input  : mass of the fermion.
*     PE : input  : momentum of the fermion.
*     PS : output : decomposed momenta.
*     CE : output : phase factor, only CE(*, IO) is used.
*
*-----------------------------------------------------------------------
      CALL SPLTQ(AM, PE, PS(1,2), PS(1,1))
      CALL PHASEQ(IO, PE, CE(1,IO))
*     CALL CTIME('SMEXTF')
      RETURN
      END
************************************************************************
      SUBROUTINE SMEXTV(LP, AM, PI, EP, EW, IGAUG)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0, ANOGAU=200.0D0)
      INTEGER LP
*     REAL*8    AM
      DIMENSION PI(4), EP(4,LP), EW(LP)
*
*   Caluculate polarization vectors for vector boson.
*
*     LP    : input  : degree of freedom
*                      2: ext. photon
*                      3: int. photon or ext. weak-boson
*                      4: int. weak-boson
*     AM    : input  : mass of the vector boson
*     PI    : input  : momentum of the vector boson
*     EP    : output : set of polarization vectors
*     EW    : output : weights for the polariztion vectors
*     IGAUG : input  : selctor of gauge parameter
*
* Common for Gauge Parameters 1:A, 2:W, 3:Z, 4:QCD
      COMMON /SMGAUG/AGAUGE(0:4)
*-----------------------------------------------------------------------
*TI
*      write(6,*) '<<SMEXTV>> LP ',LP
*TI
      DO 10 I = 1, LP
        EW(I) = 0.0
   10 CONTINUE
 
      IF(LP.EQ.1) THEN
        DO 20 I = 1, 4
          EP(I,1) = PI(I)
   20   CONTINUE
        EW(1) = 1.0D0
 
*     AXIAL GAUGE
      ELSE IF(IGAUG.EQ.-1) THEN
        VNK = PI(4) - PI(1)
        IF (VNK.NE.0.D0) THEN
          I   = 1
          J   = 3
        ELSE
          VNK = PI(4) - PI(3)
          I   = 3
          J   = 1
        ENDIF
        EP(4,1) = PI(2)/VNK
        EP(I,1) = PI(2)/VNK
        EP(2,1) = 1
        EP(J,1) = 0
        EP(4,2) = PI(J)/VNK
        EP(I,2) = PI(J)/VNK
        EP(2,2) = 0
        EP(J,2) = 1
        EW(1)   = 1
        EW(2)   = 1
        IF(LP.GT.2) THEN
          AKK = PI(4)**2 - PI(1)**2 - PI(2)**2 - PI(3)**2
          IF(AKK.GT.0) THEN
            SIGNK = 1.0
          ELSE
            SIGNK =-1.0
          ENDIF
          AKK   = SQRT(ABS(AKK))
          EP(4,3) = AKK/VNK
          EP(I,3) = AKK/VNK
          EP(2,3) = 0
          EP(J,3) = 0
          EW(3)   = SIGNK
        ENDIF
 
*     UNITARY GAUGE
      ELSE IF(IGAUG.EQ.0) THEN
        DO 30 I = 1, LP
          CALL POLA(I, ANOGAU, AM, PI, EP(1,I), EW)
   30   CONTINUE
 
*     COVARIANT GAUGE
      ELSE
        DO 40 I = 1, LP
          CALL POLA(I, AGAUGE(IGAUG), AM, PI, EP(1,I), EW)
   40   CONTINUE
      ENDIF
 
*     CALL CTIME('SMEXTV')
      RETURN
      END
************************************************************************
      SUBROUTINE SMFFS(L2,L1,EW2,EW1,AM2,AM1,CPL,CE2,CE1,
     &                 PS2,PS1,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2
      DIMENSION  EW1(1), EW2(1)
*     REAL*8     AM1, AM2
      COMPLEX*16 CPL(2)
      COMPLEX*16 CE1(2,L1), CE2(2,L2)
      DIMENSION  PS1(4,3), PS2(4,3)
*     DIMENSION  PS1(4,L1/2+1), PS2(4,L2/2+1)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate fermion-fermion-scalar vertex.
*
*           ! 3                 _      _
*           !                1  u  or  v
*      -->--+-->---          2  u  or  v
*        2     1             3  scalar boson
*
*     L1, L2   : input  : If external then 2 else 4, for fermion
*     EW1, EW2 : input  : If >=0 then particle else anti-particle
*     AM1, AM2 : input  : masses of the fermions
*     CPL      : input  : coupling constants (L, R)
*     CE1, CE2 : input  : phase factor, calculated by SMINTF or SMEXTF
*     PS1, PS2 : input  : decomposed momenta (L21, L22 , L1) or
*                         (L21, L22) calculated by SMINTF or SMEXTF
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      COMPLEX*16 AVT(2,2,2,2), CPN
      DIMENSION  P0(4), CPR(2)
      DATA P0/4*ZERO/, AM0/ZERO/
*-----------------------------------------------------------------------
      IF(CPL(1).NE.ZERO) THEN
        CPN = CPL(1)
        CPR(1) = ONE
        CPR(2) = CPL(2)/CPL(1)
      ELSE IF(CPL(2).NE.ZERO) THEN
        CPN = CPL(2)
        CPR(2) = ONE
        CPR(1) = CPL(1)/CPL(2)
      ELSE
CC      WRITE(6,*) '*** SMFFS:COUPLING CONSTANT FOR FFS VERTEX IS 0.'
CC      WRITE(6,*) 'L2=',L2,' L1=',L1,' EW2=',EW2,' EW1=',EW1
CC      WRITE(6,*) 'AM2=',AM2,' AM1=',AM1,' CPL=',CPL
CC      FOR FACOM
CC      CALL SDFDMP(1, 0)
CC      STOP
        CPN = ZERO
        CPR(1) = ONE
        CPR(2) = ONE
      ENDIF
      IF(EW1(1).GE.ZERO) THEN
        K1 = 3
      ELSE
        K1 = 1
      ENDIF
      IF(EW2(1).GE.ZERO) THEN
        K2 = 3
      ELSE
        K2 = 1
      ENDIF
      LT(0) = 3
      LT(1) = L2
      LT(2) = L1
      LT(3) = 1
      CALL FFS(K1,K2,AM1,AM2,CPR(1),CPR(2),CE1(1,2),CE2(1,1),
     &         PS1(1,1),PS1(1,2),PS2(1,1),PS2(1,2), AVT(1,1,1,1))
      IF(L1.EQ.4) THEN
          CALL FFS( 3,K2,AM0,AM2,CPR(1),CPR(2),CE1(1,4),CE2(1,1),
     &             PS1(1,3),P0,      PS2(1,1),PS2(1,2), AVT(1,1,2,1))
      ENDIF
      IF(L2.EQ.4) THEN
          CALL FFS(K1, 3,AM1,AM0,CPR(1),CPR(2),CE1(1,2),CE2(1,3),
     &             PS1(1,1),PS1(1,2),PS2(1,3),P0,       AVT(1,1,1,2))
  300   CONTINUE
      ENDIF
      IF(L1.EQ.4 .AND. L2.EQ.4) THEN
          CALL FFS( 3, 3,AM0,AM0,CPR(1),CPR(2),CE1(1,4),CE2(1,3),
     &             PS1(1,3),P0,      PS2(1,3),P0,       AVT(1,1,2,2))
  400   CONTINUE
      ENDIF
      IA = 0
      DO 500 IP1 = 1, L1/2
      DO 500 IL1 = 1, 2
      DO 500 IP2 = 1, L2/2
      DO 500 IL2 = 1, 2
        AV(IA) = CPN*AVT(IL1, IL2, IP1, IP2)
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMFFS ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMFFV(L2,L1,LV,EW2,EW1,AM2,AM1,CPL,CE2,CE1,
     &                 PS2,PS1,EP,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, LV
      DIMENSION  EW1(1), EW2(1)
*     REAL*8     AM1, AM2
      COMPLEX*16 CPL(2)
      COMPLEX*16 CE1(2,L1), CE2(2,L2)
      DIMENSION  PS1(4,3), PS2(4,3)
*     DIMENSION  PS1(4,L1/2+1), PS2(4,L2/2+1)
      DIMENSION  EP(4,LV)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:LV*L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate fermion-fermion-vector vertex.
*
*           ! 3                 _      _
*           !                1  u  or  v
*      -->--+-->---          2  u  or  v
*        2     1             3  vector boson
*
*     L1, L2   : input  : If external then 2 else 4, for fermion
*     LV       : input  : number of polarization vectors (2, 3 OR 4)
*     EW1, EW2 : input  : If >=0 then particle else anti-particle
*     AM1, AM2 : input  : masses of the fermions
*     CPL      : input  : coupling constants (L, R)
*     CE1, CE2 : input  : phase factor, calculated by SMINTF or SMEXTF
*     PS1, PS2 : input  : decomposed momenta (L21, L22 , L1) or
*                         (L21, L22) calculated by SMINTF or SMEXTF
*     EP       : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      COMPLEX*16 AVT(4,2,2,2,2), CPN
      DIMENSION  P0(4), CPR(2)
      DATA P0/4*ZERO/, AM0/ZERO/
*-----------------------------------------------------------------------
      IF(CPL(1).NE.ZERO) THEN
        CPN = CPL(1)
        CPR(1) = ONE
        CPR(2) = CPL(2)/CPL(1)
      ELSE IF(CPL(2).NE.ZERO) THEN
        CPN = CPL(2)
        CPR(2) = ONE
        CPR(1) = CPL(1)/CPL(2)
      ELSE
CC      WRITE(6,*) '*** SMFFV:COUPLING CONSTANT FOR FFV VERTEX IS 0.'
CC      WRITE(6,*) 'L2=',L2,' L1=',L1,' LV=',LV,' EW2=',EW2,' EW1=',EW1
CC      WRITE(6,*) 'AM2=',AM2,' AM1=',AM1,' CPL=',CPL
CC      FOR FACOM
CC      CALL SDFDMP(1, 0)
CC      STOP
        CPN = ZERO
        CPR(1) = ONE
        CPR(2) = ONE
      ENDIF
      IF(EW1(1).GE.ZERO) THEN
        K1 = 3
      ELSE
        K1 = 1
      ENDIF
      IF(EW2(1).GE.ZERO) THEN
        K2 = 3
      ELSE
        K2 = 1
      ENDIF
      LT(0) = 3
      LT(1) = L2
      LT(2) = L1
      LT(3) = LV
      DO 100 LP = 1, LV
      CALL FFV(LP,K1,K2,AM1,AM2,CPR(1),CPR(2), CE1(1,2),CE2(1,1),
     &         PS1(1,1),PS1(1,2),PS2(1,1),PS2(1,2),EP(1,LP),
     &         AVT(1,1,1,1,1))
  100 CONTINUE
      IF(L1.EQ.4) THEN
        DO 200 LP = 1, LV
          CALL FFV(LP,3,K2,AM0,AM2,CPR(1),CPR(2), CE1(1,4),CE2(1,1),
     &             PS1(1,3),P0,PS2(1,1),PS2(1,2),EP(1,LP),
     &             AVT(1,1,1,2,1))
  200   CONTINUE
      ENDIF
      IF(L2.EQ.4) THEN
        DO 300 LP = 1, LV
          CALL FFV(LP,K1,3,AM1,AM0,CPR(1),CPR(2), CE1(1,2),CE2(1,3),
     &             PS1(1,1),PS1(1,2),PS2(1,3),P0,EP(1,LP),
     &             AVT(1,1,1,1,2))
  300   CONTINUE
      ENDIF
      IF(L1.EQ.4 .AND. L2.EQ.4) THEN
        DO 400 LP = 1, LV
          CALL FFV(LP,3,3,AM0,AM0,CPR(1),CPR(2), CE1(1,4),CE2(1,3),
     &             PS1(1,3),P0,PS2(1,3),P0,EP(1,LP),
     &             AVT(1,1,1,2,2))
  400   CONTINUE
      ENDIF
      IA = 0
      DO 500 IL  = 1, LV
      DO 500 IP1 = 1, L1/2
      DO 500 IL1 = 1, 2
      DO 500 IP2 = 1, L2/2
      DO 500 IL2 = 1, 2
        AV(IA) = CPN*AVT(IL, IL1, IL2, IP1, IP2)
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMFFV ')
      RETURN
      END
*-----------------------------------------------------------------------
*     SMFFV revised 94/04/08 by T.Ishikawa
*-----------------------------------------------------------------------
      SUBROUTINE SMFFV(L2,L1,LV,EW2,EW1,AM2,AM1,CPL,CE2,CE1,
     &                 PS2,PS1,EP,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE=20,LASIZE = 1024)
      INTEGER    L1, L2, LV
      DIMENSION  EW1(1), EW2(1)

      COMPLEX*16 CPL(2)
      COMPLEX*16 CE1(2,L1), CE2(2,L2)
      DIMENSION  PS1(4,3), PS2(4,3)

      DIMENSION  EP(4,LV)
      COMPLEX*16 AV(0:LASIZE)

      INTEGER    LT(0:LTSIZE)

      COMPLEX*16 AVT(4,2,2,2,2), CPN
      DIMENSION     CPR(2)

*--------------------------- Entry point -------------------------------

      IF( CPL(1) .NE. ZERO) THEN
          CPN      = CPL(1)
          CPR(1) = ONE
          CPR(2) = CPL(2)/CPL(1)
      ELSEIF( CPL(2).NE.ZERO) THEN
          CPN      = CPL(2)
          CPR(2) = ONE
          CPR(1) = CPL(1)/CPL(2)
      ELSE
          CPN      = ZERO
          CPR(1) = ONE
          CPR(2) = ONE
      ENDIF

      IF(EW1(1).GE.ZERO) THEN
         K1 = 3
      ELSE
         K1 = 1
      ENDIF
      IF(EW2(1).GE.ZERO) THEN
         K2 = 3
      ELSE
         K2 = 1
      ENDIF

      LT(0) =  3
      LT(1) =  L2
      LT(2) =  L1
      LT(3) =  LV

      DO 100 LP = 1, LV
      CALL FFVMM(LP,K1,K2,AM1,AM2,CPR(1),CPR(2),CE1(1,2),CE2(1,1),
     &         PS1(1,1),PS1(1,2),PS2(1,1),PS2(1,2),
     &         EP(1,LP),AVT(1,1,1,1,1))
  100 CONTINUE

      IF(L1.EQ.4) THEN
        DO 200 LP = 1, LV
          CALL FFV0M(LP,CPR(1),CPR(2),CE2(1,1),PS1(1,3),
     &               EP(1,LP),AVT(1,1,1,2,1))
  200   CONTINUE
      ENDIF

      IF(L2.EQ.4) THEN
        DO 300 LP = 1, LV
          CALL FFVM0(LP,CPR(1),CPR(2),CE1(1,2),PS2(1,3),
     &               EP(1,LP),AVT(1,1,1,1,2))
  300   CONTINUE
      ENDIF

      IF(L1.EQ.4 .AND. L2.EQ.4) THEN
        DO 400 LP = 1, LV
         CALL FFV00(LP,CPR(1),CPR(2),EP(1,LP),AVT(1,1,1,2,2))
  400   CONTINUE
      ENDIF

      IA = 0
      DO 500 IL  = 1, LV
      DO 500 IP1 = 1, L1/2
      DO 500 IL1 = 1, 2
      DO 500 IP2 = 1, L2/2
      DO 500 IL2 = 1, 2
         AV(IA) = CPN*AVT(IL, IL1, IL2, IP1, IP2)
         IA = IA + 1
  500 CONTINUE

      RETURN
      END
*-----------------------------------------------------------------------
*     SMFFV revised 94/04/08 by T.Ishikawa
*-----------------------------------------------------------------------
      SUBROUTINE SMFFV(L2,L1,LV,EW2,EW1,AM2,AM1,CPL,CE2,CE1,
     &                 PS2,PS1,EP,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE=20,LASIZE = 1024)
      INTEGER    L1, L2, LV
      DIMENSION  EW1(1), EW2(1)

      COMPLEX*16 CPL(2)
      COMPLEX*16 CE1(2,L1), CE2(2,L2)
      DIMENSION  PS1(4,3), PS2(4,3)

      DIMENSION  EP(4,LV)
      COMPLEX*16 AV(0:LASIZE)

      INTEGER    LT(0:LTSIZE)

      COMPLEX*16 AVT(4,2,2,2,2), CPN
      DIMENSION     CPR(2)

*--------------------------- Entry point -------------------------------

      IF( CPL(1) .NE. ZERO) THEN
          CPN      = CPL(1)
          CPR(1) = ONE
          CPR(2) = CPL(2)/CPL(1)
      ELSEIF( CPL(2).NE.ZERO) THEN
          CPN      = CPL(2)
          CPR(2) = ONE
          CPR(1) = CPL(1)/CPL(2)
      ELSE
          CPN      = ZERO
          CPR(1) = ONE
          CPR(2) = ONE
      ENDIF

      IF(EW1(1).GE.ZERO) THEN
         K1 = 3
      ELSE
         K1 = 1
      ENDIF
      IF(EW2(1).GE.ZERO) THEN
         K2 = 3
      ELSE
         K2 = 1
      ENDIF

      LT(0) =  3
      LT(1) =  L2
      LT(2) =  L1
      LT(3) =  LV

      IF( AM1.GT.0.0D0 )THEN
          IF( AM2.GT.0.0D0 )THEN

              DO 110 LP = 1, LV
                 CALL FFVMM1(LP,K1,K2,CPR(1),CPR(2),
     .                      CE1(1,2),CE2(1,1),PS1(1,1),PS1(1,2),
     .                      PS2(1,1),PS2(1,2),EP(1,LP),AVT(1,1,1,1,1))
  110         CONTINUE

              IF(L1.EQ.4) THEN
                 DO 120 LP = 1, LV
                    CALL FFVMM2(LP,CPR(1),CPR(2),CE2(1,1),PS1(1,3),
     &                        EP(1,LP),AVT(1,1,1,2,1))
  120            CONTINUE
              ENDIF

              IF(L2.EQ.4) THEN
                 DO 130 LP = 1, LV
                    CALL FFVMM3(LP,CPR(1),CPR(2),CE1(1,2),PS2(1,3),
     &                          EP(1,LP),AVT(1,1,1,1,2))
  130            CONTINUE
              ENDIF

              IF(L1.EQ.4 .AND. L2.EQ.4) THEN
                 DO 140 LP = 1, LV
                    CALL FFVMM4(LP,CPR(1),CPR(2),
     .                          EP(1,LP),AVT(1,1,1,2,2))
  140            CONTINUE
              ENDIF

          ELSE

              DO 210 LP = 1, LV
                 CALL FFVMM5(LP,K1,K2,CPR(1),CPR(2),
     .                      CE1(1,2),CE2(1,1),PS1(1,1),PS1(1,2),
     .                      PS2(1,1),PS2(1,2),EP(1,LP),AVT(1,1,1,1,1))
  210         CONTINUE

              IF(L1.EQ.4) THEN
                 DO 220 LP = 1, LV
                    CALL FFVMM6(LP,CPR(1),CPR(2),CE2(1,1),PS1(1,3),
     &                        EP(1,LP),AVT(1,1,1,2,1))
  220            CONTINUE
              ENDIF

              IF(L2.EQ.4) THEN
                 DO 230 LP = 1, LV
                    CALL FFVMM3(LP,CPR(1),CPR(2),CE1(1,2),PS2(1,3),
     &                          EP(1,LP),AVT(1,1,1,1,2))
  230            CONTINUE
              ENDIF

              IF(L1.EQ.4 .AND. L2.EQ.4) THEN
                 DO 240 LP = 1, LV
                    CALL FFVMM4(LP,CPR(1),CPR(2),
     .                          EP(1,LP),AVT(1,1,1,2,2))
  240            CONTINUE
              ENDIF
          ENDIF
      ELSE
          IF( AM2.GT.0.0D0 )THEN
              DO 310 LP = 1, LV
                 CALL FFVMM7(LP,K1,K2,CPR(1),CPR(2),
     .                      CE1(1,2),CE2(1,1),PS1(1,1),PS1(1,2),
     .                      PS2(1,1),PS2(1,2),EP(1,LP),AVT(1,1,1,1,1))
  310         CONTINUE

              IF(L1.EQ.4) THEN
                 DO 320 LP = 1, LV
                    CALL FFVMM2(LP,CPR(1),CPR(2),CE2(1,1),PS1(1,3),
     &                        EP(1,LP),AVT(1,1,1,2,1))
  320            CONTINUE
              ENDIF

              IF(L2.EQ.4) THEN
                 DO 330 LP = 1, LV
                    CALL FFVMM8(LP,CPR(1),CPR(2),CE1(1,2),PS2(1,3),
     &                          EP(1,LP),AVT(1,1,1,1,2))
  330            CONTINUE
              ENDIF

              IF(L1.EQ.4 .AND. L2.EQ.4) THEN
                 DO 340 LP = 1, LV
                    CALL FFVMM4(LP,CPR(1),CPR(2),
     .                          EP(1,LP),AVT(1,1,1,2,2))
  340            CONTINUE
              ENDIF

          ELSE

              DO 410 LP = 1, LV
                 CALL FFVMM9(LP,K1,K2,CPR(1),CPR(2),
     .                      CE1(1,2),CE2(1,1),PS1(1,1),PS1(1,2),
     .                      PS2(1,1),PS2(1,2),EP(1,LP),AVT(1,1,1,1,1))
  410         CONTINUE

              IF(L1.EQ.4) THEN
                 DO 420 LP = 1, LV
                    CALL FFVMM6(LP,CPR(1),CPR(2),CE2(1,1),PS1(1,3),
     &                        EP(1,LP),AVT(1,1,1,2,1))
  420            CONTINUE
              ENDIF

              IF(L2.EQ.4) THEN
                 DO 430 LP = 1, LV
                    CALL FFVMM8(LP,CPR(1),CPR(2),CE1(1,2),PS2(1,3),
     &                          EP(1,LP),AVT(1,1,1,1,2))
  430            CONTINUE
              ENDIF

              IF(L1.EQ.4 .AND. L2.EQ.4) THEN
                 DO 440 LP = 1, LV
                    CALL FFVMM4(LP,CPR(1),CPR(2),
     .                          EP(1,LP),AVT(1,1,1,2,2))
  440            CONTINUE
              ENDIF

          ENDIF
      ENDIF

      IA = 0
      DO 500 IL  = 1, LV
      DO 500 IP1 = 1, L1/2
      DO 500 IL1 = 1, 2
      DO 500 IP2 = 1, L2/2
      DO 500 IL2 = 1, 2
         AV(IA) = CPN*AVT(IL, IL1, IL2, IP1, IP2)
         IA = IA + 1
*        print *,'smffv i,l,p1,l1,p2,l2',ia,il,ip1,il1,ip2,il2,
*    *    AVT(IL, IL1, IL2, IP1, IP2)
  500 CONTINUE

      RETURN
      END
************************************************************************
      SUBROUTINE SMGGG(L1,L2,L3,K1,K2,K3,CPL,P1,P2,P3,E1,E2,E3,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3
      INTEGER    K1, K2, K3
      COMPLEX*16 CPL
      DIMENSION  P1(4),    P2(4),    P3(4)
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L3*L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate gluon-gluon-gluon vertex.
*
*           ! 3
*           V
*      -->--+--<---
*        2     1
*
*     L1,L2,L3 : input  : number of polarization vectors (2, 3 OR 4)
*     K1,K2,K3 : input  : if incoming momentum then 1 else -1
*     CPL      : input  : coupling constant.
*     P1,P2,P3 : input  : momentum vectors
*     E1,E2,E3 : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      DIMENSION  PP1(4), PP2(4), PP3(4)
*-----------------------------------------------------------------------
      LT(0) = 3
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      DO 10 J = 1, 4
        PP1(J) = K1*P1(J)
        PP2(J) = K2*P2(J)
        PP3(J) = K3*P3(J)
   10 CONTINUE
      IA = 0
      DO 500 IL3 = 1, L3
        E3P  =  E3(4,IL3)*(PP1(4)-PP2(4)) - E3(1,IL3)*(PP1(1)-PP2(1))
     &        - E3(2,IL3)*(PP1(2)-PP2(2)) - E3(3,IL3)*(PP1(3)-PP2(3))
      DO 500 IL2 = 1, L2
        E2P  =  E2(4,IL2)*(PP3(4)-PP1(4)) - E2(1,IL2)*(PP3(1)-PP1(1))
     &        - E2(2,IL2)*(PP3(2)-PP1(2)) - E2(3,IL2)*(PP3(3)-PP1(3))
        E2E3 =  E2(4,IL2)*E3(4,IL3) - E2(1,IL2)*E3(1,IL3)
     &        - E2(2,IL2)*E3(2,IL3) - E2(3,IL2)*E3(3,IL3)
      DO 500 IL1 = 1, L1
        E1E2 =  E1(4,IL1)*E2(4,IL2) - E1(1,IL1)*E2(1,IL2)
     &        - E1(2,IL1)*E2(2,IL2) - E1(3,IL1)*E2(3,IL2)
        E1E3 =  E1(4,IL1)*E3(4,IL3) - E1(1,IL1)*E3(1,IL3)
     &        - E1(2,IL1)*E3(2,IL3) - E1(3,IL1)*E3(3,IL3)
        E1P  =  E1(4,IL1)*(PP2(4)-PP3(4)) - E1(1,IL1)*(PP2(1)-PP3(1))
     &        - E1(2,IL1)*(PP2(2)-PP3(2)) - E1(3,IL1)*(PP2(3)-PP3(3))
        AV(IA) =       CPL*(E1P*E2E3 + E2P*E1E3 + E3P*E1E2)
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMGGG ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMGGGG(L1,L2,L3,L4,CPL,E1,E2,E3,E4,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3, L4
      COMPLEX*16 CPL
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3), E4(4,L4)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate 4-gluon vertex.
*
*           ! 4
*           V            -cpl*(g(1,3)*g(2,4) - g(1,4)*g(2,3))
*      -->--+--<---
*        1  ^  3
*           !2
*
*     L1,L2,L3,L4 : input  : number of polarization vectors (2, 3 OR 4)
*     CPL         : input  : coupling constant.
*     E1,E2,E3,E4 : input  : set of polarization vectors
*     AV          : output : table of amplitudes
*     LT          : output : table of sizes in AV
*-----------------------------------------------------------------------
      LT(0) = 4
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      LT(4) = L4
      IA = 0
      DO 500 IL4 = 1, L4
      DO 500 IL3 = 1, L3
      DO 500 IL2 = 1, L2
        E2E4 =  E2(4,IL2)*E4(4,IL4) - E2(1,IL2)*E4(1,IL4)
     &        - E2(2,IL2)*E4(2,IL4) - E2(3,IL2)*E4(3,IL4)
        E2E3 =  E2(4,IL2)*E3(4,IL3) - E2(1,IL2)*E3(1,IL3)
     &        - E2(2,IL2)*E3(2,IL3) - E2(3,IL2)*E3(3,IL3)
      DO 500 IL1 = 1, L1
        E1E4 =  E1(4,IL1)*E4(4,IL4) - E1(1,IL1)*E4(1,IL4)
     &        - E1(2,IL1)*E4(2,IL4) - E1(3,IL1)*E4(3,IL4)
        E1E3 =  E1(4,IL1)*E3(4,IL3) - E1(1,IL1)*E3(1,IL3)
     &        - E1(2,IL1)*E3(2,IL3) - E1(3,IL1)*E3(3,IL3)
        AV(IA) = CPL*(E1E3*E2E4 - E1E4*E2E3)
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMGGGG')
      RETURN
      END
************************************************************************
      SUBROUTINE SMINIT(NV, NS)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (LVER=1, LSUBV=1)
*
*   INITIALIZE RUN-TIME RUOTINES
*
*   INPUT
*     NV, NS : VERSION NUMBER
*
*-----------------------------------------------------------------------
      IF(NV.NE.LVER .OR. NS.NE.LSUBV) THEN
        WRITE(6,100) NV, NS
  100   FORMAT(' ****** VERSION ',I4,'.',I2.2,' IS NOT SUPPORTED *****')
        STOP
      ENDIF
      RETURN
      END
************************************************************************
      SUBROUTINE SMINTF(AM, PI, VM, EW, PS, CE)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*     REAL*8     AM
      DIMENSION  PI(4), EW(2), PS(4,3)
      COMPLEX*16 CE(2,4)
*
*   Decompose momentum of internal fermion.
*
*            PI = L1 + L2          off-shell momentum
*            L1**2  = 0            massless on-shell
*            L2**2  = AM**2        massive on-shell
*            L2 = L21 + L22
*
*            L21**2 = 0            massless on-shell
*            L22**2 = 0            massless on-shell
*            PS(*, 1) = L21
*            PS(*, 2) = L22
*            PS(*, 3) = L1
*
*     AM : input  : Mass of the fermion
*     PI : input  : Momentum of the fermion (off-shell)
*     EW : output : Weight for L2 and L1
*     PS : output : Decomposed massless momenta
*     CE : output : Phase factor for L2 and L1.
*
*     1994/12/17 : fug fix for pi(j) = 0, j <> 3     T.Kaneko
*     1994/12/20 :                                   Y.Kurihara
*
      DIMENSION PM(4)
*     DATA DD/1.0D-7/
      DATA DD/0.0D0/
*-----------------------------------------------------------------------
      PSN  = SQRT(PI(1)**2 + PI(2)**2 + PI(3)**2)
      IF(ABS(PI(4)).LE.DD) THEN
        IF(PSN.LE.DD) THEN
            P0  = 0.0D0
        ELSE
            A   = 1.0D0/SQRT(3.0D0)
            B   = A
            C   = A
            DEN = PI(4)-A*PI(1)-B*PI(2)-C*PI(3)
            P0  = (VM - AM**2)/(2.0D0*DEN)
        ENDIF
      ELSE 
        IF(PSN.LE.DD) THEN
            A = 1.0D0
            B = 0.0D0
            C = 0.0D0
            DEN = PI(4)-PI(1)
        ELSE IF(PI(4) .LT. 0.0D0) THEN
            PSNI = 1.0D0/PSN
            A = - PI(1)*PSNI
            B = - PI(2)*PSNI
            C = - PI(3)*PSNI
            den=    pi(4)**2
     .-         max(pi(1)**2,pi(2)**2,pi(3)**2)
     .-         max(min(max(pi(1)**2,pi(2)**2),pi(3)**2)
     .,                 min(pi(1)**2,pi(2)**2)          )
     .-         min(pi(1)**2,pi(2)**2,pi(3)**2)
            den=den/(pi(4)-psn)
        ELSE
            PSNI = 1.0D0/PSN
            A = PI(1)*PSNI
            B = PI(2)*PSNI
            C = PI(3)*PSNI
            den=    pi(4)**2
     .-         max(pi(1)**2,pi(2)**2,pi(3)**2)
     .-         max(min(max(pi(1)**2,pi(2)**2),pi(3)**2)
     .,                 min(pi(1)**2,pi(2)**2)          )
     .-         min(pi(1)**2,pi(2)**2,pi(3)**2)
            den=den/(pi(4)+psn)
        ENDIF
c       DEN = PI(4)-A*PI(1)-B*PI(2)-C*PI(3)
        P0  = (VM - AM**2)/(2.0D0*DEN)
      ENDIF

      P10  = ABS(P0)
      IF (P10.LE.0.0D0) THEN
        EW(2) = 0.0D0
      ELSE
        EW(2) = SIGN(1.0D0, P0)
      END IF
      PS(1, 3) = A*P10
      PS(2, 3) = B*P10
      PS(3, 3) = C*P10
      PS(4, 3) =   P10
 
      P00=PI(4)-EW(2)*PS(4, 3)
      P20=ABS(P00)
      IF (P20.LE.0.0D0) THEN
        EW(1) = 0.0D0
      ELSE
        EW(1) = SIGN(1.0D0, P00)
      END IF
 
      PM(1) = EW(1)*(PI(1) - EW(2)*PS(1, 3))
      PM(2) = EW(1)*(PI(2) - EW(2)*PS(2, 3))
      PM(3) = EW(1)*(PI(3) - EW(2)*PS(3, 3))
      PM(4) = EW(1)*(PI(4) - EW(2)*PS(4, 3))
 
      CALL SPLTQ(AM, PM, PS(1,2), PS(1,1))
      CALL PHASEQ(1,      PM, CE(1,1))
      CALL PHASEQ(2,      PM, CE(1,2))
      CALL PHASEQ(1, PS(1,3), CE(1,3))
      CALL PHASEQ(2, PS(1,3), CE(1,4))
 
*     write(*,*) 'pi = ', pi(1),pi(2),pi(3),pi(4),' mass=',am
*     write(*,*) 'p1 = ', ps(1,1),ps(2,1),ps(3,1),ps(4,1),
*    &           ps(4,1)**2-ps(1,1)**2-ps(2,1)**2-ps(3,1)**2
*     write(*,*) 'p2 = ', ps(1,2),ps(2,2),ps(3,2),ps(4,2),
*    &           ps(4,2)**2-ps(1,2)**2-ps(2,2)**2-ps(3,2)**2
*     write(*,*) 'p3 = ', ps(1,3),ps(2,3),ps(3,3),ps(4,3),
*    &           ps(4,3)**2-ps(1,3)**2-ps(2,3)**2-ps(3,3)**2
*     write(*,*) 'pm = ', pm(1),pm(2),pm(3),pm(4),
*    &           pm(4)**2-pm(1)**2-pm(2)**2-pm(3)**2,am**2

*     CALL CTIME('SMINTF')
      RETURN
      END
************************************************************************
      SUBROUTINE SMINTP(LP, AM, PI, EP, EW, VM, IGAUG)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0, ANOGAU=200.0D0)
      INTEGER LP
*     REAL*8    AM, VM
      DIMENSION PI(4), EP(4,LP), EW(LP)
*
*   Caluculate polarization vectors for vector boson.
*   QED vertex with on-shell fermions.
* Gauge invarience can not be checked by using this subroutine.
*
*
*     LP    : input  : degree of freedom
*                      2: ext. photon
*                      3: int. photon or ext. weak-boson
*                      4: int. weak-boson
*     NP    : OUTPUT : EFFECTIVE VALUE OF LP
*     AM    : input  : mass of the vector boson
*     PI    : input  : momentum of the vector boson
*     EP    : output : set of polarization vectors
*     EW    : output : weights for the polariztion vectors
*     VM    : input  : PI.PI
*     IGAUG : input  : selctor of gauge parameter
*
* Common for Gauge Parameters 1:A, 2:W, 3:Z, 4:QCD
      COMMON /SMGAUG/AGAUGE(0:4)

      DATA DD/0.0D0/
*-----------------------------------------------------------------------
      DO 40 I = 1, LP
        EW(I) = 0.0D0
   40 CONTINUE

CX    WRITE(6,*) ' ------  SMINTP --------- '
      IF(LP.EQ.1) THEN
        DO 30 I = 1, 4
          EP(I,1) = PI(I)
   30   CONTINUE
        EW(1) = 1.0D0
        NP    = 1
      END IF

        APP=ABS(VM)
        RAPP = SQRT(APP)

*     COVARIANT GAUGE
        PT2 = PI(1)**2 + PI(2)**2
        IF(PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = PI(2)*PTI
          RTX = PI(1)*PTI
        ENDIF
        PN2 = PT2 + PI(3)**2
CX      PP = (PI(4)-PI(3))*(PI(4)+PI(3))-PT2
        IF(PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF(PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = PI(1)*PNI
          RNY = PI(2)*PNI
          RNZ = PI(3)*PNI
          RTN = PT*PNI
        ENDIF

        EP(1,1) =  RTX*RNZ
        EP(2,1) =  RTY*RNZ
        EP(3,1) = -RTN
        EP(4,1) =  0.0D0
        EW(1) =  1.0D0

        EP(1,2) = -RTY
        EP(2,2) =  RTX
        EP(3,2) =  0.0D0
        EP(4,2) =  0.0D0
        EW(2) =  1.0D0
        NP = 2

c       WRITE(6,*) 'PI(1) PI(2) ',PI(1),PI(2)
c       WRITE(6,*) 'PT PTI RTY  ',PT,PTI,RTY
c       WRITE(6,*) 'EP          ',EP(1,2)

        IF(LP.GE.3) THEN
          IF (APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = 0.D0
            EP(2,NP) = 0.D0
            EP(3,NP) = 0.D0
            EP(4,NP) = -RAPP/PN
CX          EP(4,NP) = -1.D0/PN
            EW(NP) = SIGN(1.0D0, VM)
c           WRITE(6,*) ' NP APP EP ',NP,APP,EP(4,NP)
          ENDIF
        ENDIF

        IF(LP.GE.4) THEN
          IF (APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = 0.D0
            EP(2,NP) = 0.D0
            EP(3,NP) = 0.D0
            EP(4,NP) = 0.D0
            EW(NP) = 0.D0
            AM2 = AM*AM
         END IF
       END IF

c       WRITE(6,*) 'NP EP  ',NP,EP(1,2)
*     CALL CTIME('SMINTV')
      RETURN
      END
************************************************************************
      SUBROUTINE SMINTT(LP, AM, PI, EP, EW, VM, IGAUG)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0, ANOGAU=200.0D0)
      INTEGER LP
*     REAL*8    AM, VM
      DIMENSION PI(4), EP(4,LP), EW(LP)
*
*   Caluculate polarization vectors for vector boson.
*   QED vertex with on-shell fermions.
* Gauge invarience can not be checked by using this subroutine.
*
*
*     LP    : input  : degree of freedom
*                      2: ext. photon
*                      3: int. photon or ext. weak-boson
*                      4: int. weak-boson
*     NP    : OUTPUT : EFFECTIVE VALUE OF LP
*     AM    : input  : mass of the vector boson
*     PI    : input  : momentum of the vector boson
*     EP    : output : set of polarization vectors
*     EW    : output : weights for the polariztion vectors
*     VM    : input  : PI.PI
*     IGAUG : input  : selctor of gauge parameter
*
* Common for Gauge Parameters 1:A, 2:W, 3:Z, 4:QCD
      COMMON /SMGAUG/AGAUGE(0:4)

      DATA DD/0.0D0/
*-----------------------------------------------------------------------
      DO 40 I = 1, LP
        EW(I) = 0.0D0
   40 CONTINUE

CX    WRITE(6,*) ' ------  SMINTP --------- '
      IF(LP.EQ.1) THEN
        DO 30 I = 1, 4
          EP(I,1) = PI(I)
   30   CONTINUE
        EW(1) = 1.0D0
        NP    = 1
        END IF

        APP=ABS(VM)
        RAPP = SQRT(APP)

*     COVARIANT GAUGE
        PT2 = PI(1)**2 + PI(2)**2
        IF(PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = PI(2)*PTI
          RTX = PI(1)*PTI
        ENDIF
        PN2 = PT2 + PI(3)**2
CX      PP = (PI(4)-PI(3))*(PI(4)+PI(3))-PT2
        IF(PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF(PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = PI(1)*PNI
          RNY = PI(2)*PNI
          RNZ = PI(3)*PNI
          RTN = PT*PNI
        ENDIF

        EP(1,1) =  RTX*RNZ/RAPP
        EP(2,1) =  RTY*RNZ/RAPP
        EP(3,1) = -RTN/RAPP
        EP(4,1) =  0.0D0
        EW(1) =  1.0D0

        EP(1,2) = -RTY/RAPP
        EP(2,2) =  RTX/RAPP
        EP(3,2) =  0.0D0
        EP(4,2) =  0.0D0
        EW(2) =  1.0D0
        NP = 2

        WRITE(6,*) 'PI(1) PI(2) ',PI(1),PI(2)
        WRITE(6,*) 'PT PTI RTY  ',PT,PTI,RTY
        WRITE(6,*) 'EP          ',EP(1,2)

        IF(LP.GE.3) THEN
          IF (APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = 0.D0
            EP(2,NP) = 0.D0
            EP(3,NP) = 0.D0
CX          EP(4,NP) = -RAPP/PN
            EP(4,NP) = -1.D0/PN
            EW(NP) = SIGN(1.0D0, VM)
            WRITE(6,*) ' NP APP EP ',NP,APP,EP(4,NP)
          ENDIF
        ENDIF

        IF(LP.GE.4) THEN
          IF (APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = 0.D0
            EP(2,NP) = 0.D0
            EP(3,NP) = 0.D0
            EP(4,NP) = 0.D0
            EW(NP) = 0.D0
            AM2 = AM*AM
         END IF
       END IF

        WRITE(6,*) 'NP EP  ',NP,EP(1,2)
*     CALL CTIME('SMINTV')
      RETURN
      END
************************************************************************
      SUBROUTINE SMINTV(LP, AM, PI, EP, EW, VM, IGAUG)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0, ANOGAU=200.0D0)
      INTEGER LP
*     REAL*8    AM, VM
      DIMENSION PI(4), EP(4,LP), EW(LP)
*
*   Caluculate polarization vectors for vector boson.
*
*     LP    : input  : degree of freedom
*                      2: ext. photon
*                      3: int. photon or ext. weak-boson
*                      4: int. weak-boson
*     NP    : OUTPUT : EFFECTIVE VALUE OF LP
*     AM    : input  : mass of the vector boson
*     PI    : input  : momentum of the vector boson
*     EP    : output : set of polarization vectors
*     EW    : output : weights for the polariztion vectors
*     VM    : input  : PI.PI
*     IGAUG : input  : selctor of gauge parameter
*
* Common for Gauge Parameters 1:A, 2:W, 3:Z, 4:QCD
      COMMON /SMGAUG/AGAUGE(0:4)
 
      DATA DD/0.0D0/
*-----------------------------------------------------------------------
      DO 40 I = 1, LP
        EW(I) = 0.0D0
   40 CONTINUE
 
      IF(LP.EQ.1) THEN
        DO 30 I = 1, 4
          EP(I,1) = PI(I)
   30   CONTINUE
        EW(1) = 1.0D0
        NP    = 1
 
*del  AXIAL GAUGE
*del  ELSE IF(IGAUG.EQ.-1) THEN
*del    VNK = PI(4) - PI(1)
*del    IF (VNK.NE.0.D0) THEN
*del      I = 1
*del      J = 3
*del    ELSE
*del      VNK = PI(4) - PI(3)
*del      I = 3
*del      J = 1
*del    ENDIF
*del    EP(4,1) = PI(2)/VNK
*del    EP(I,1) = PI(2)/VNK
*del    EP(2,1) = 1
*del    EP(J,1) = 0
*del    EP(4,2) = PI(J)/VNK
*del    EP(I,2) = PI(J)/VNK
*del    EP(2,2) = 0
*del    EP(J,2) = 1
*del    EW(1)   = 1
*del    EW(2)   = 1
*del    NP      = 2
*del    IF(LP.GT.2) THEN
*del      IF(AKK.GT.0) THEN
*del        SIGNK = 1.0
*del      ELSE
*del        SIGNK =-1.0
*del      ENDIF
*del      AKK   = SQRT(ABS(AKK))
*del      EP(4,3) = VM/VNK
*del      EP(I,3) = VM/VNK
*del      EP(2,3) = 0
*del      EP(J,3) = 0
*del      EW(3)   = SIGNK
*del      NP      = 4
*del    ENDIF
*
*     COVARIANT GAUGE
      ELSE
        PT2 = PI(1)**2 + PI(2)**2
        IF(PT2.LE.DD) THEN
          PT  = 0.0D0
          RTY = 1.0D0
          RTX = 0.0D0
        ELSE
          PT  = SQRT(PT2)
          PTI = 1.0D0/PT
          RTY = PI(2)*PTI
          RTX = PI(1)*PTI
        ENDIF
        PN2 = PT2 + PI(3)**2
        IF(PN2.LE.DD) THEN
          PN  = 0.0D0
          RNX = 0.0D0
          RNY = 0.0D0
          RNZ = 1.0D0
          RTN = 0.0D0
        ELSE IF(PN2.GT.DD) THEN
          PN  = SQRT(PN2)
          PNI = 1.0D0/PN
          RNX = PI(1)*PNI
          RNY = PI(2)*PNI
          RNZ = PI(3)*PNI
          RTN = PT*PNI
        ENDIF
 
        EP(1,1) =  RTX*RNZ
        EP(2,1) =  RTY*RNZ
        EP(3,1) = -RTN
        EP(4,1) =  0.0D0
        EW(1) =  1.0D0
 
        EP(1,2) = -RTY
        EP(2,2) =  RTX
        EP(3,2) =  0.0D0
        EP(4,2) =  0.0D0
        EW(2) =  1.0D0
        NP    =  2
 
        APP=ABS(VM)
        IF(LP.GE.3) THEN
          IF(APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = RNX*PI(4)*RPPI
            EP(2,NP) = RNY*PI(4)*RPPI
            EP(3,NP) = RNZ*PI(4)*RPPI
            EP(4,NP) = PN*RPPI
            EW(NP) = SIGN(1.0D0, VM)
          ENDIF
        ENDIF
 
        IF(LP.GE.4) THEN
          IF (APP.GT.DD) THEN
            NP = NP + 1
            RPPI  = 1.0D0/SQRT(APP)
            EP(1,NP) = PI(1)*RPPI
            EP(2,NP) = PI(2)*RPPI
            EP(3,NP) = PI(3)*RPPI
            EP(4,NP) = PI(4)*RPPI
            AM2 = AM*AM
 
*           COVARIANT GAUGE
            IF(IGAUG.NE.0) THEN
              A = AGAUGE(IGAUG)
              AVM = VM - A*AM2
              IF (ABS(AVM).GT.DD) THEN
                EW(NP) =  SIGN(1.0D0, VM)*(AM2-VM)*A/AVM
              ELSE
                EW(NP) = -SIGN(1.0D0, VM)
                WRITE(6,*) ' Caution : p*p = a*m**2 '
                WRITE(6,*) '  a = 1 was taken. '
              END IF
 
*           UNITARY GAUGE
            ELSE
              IF (AM.GT.0.D0) THEN
                EW(NP) =   SIGN(1.0D0, VM)*(VM/AM**2-1.0D0)
              ELSE
                EW(NP) = -SIGN(1.0D0, VM)*ANOGAU
              END IF
            END IF
          ENDIF
        END IF
      END IF
 
*     CALL CTIME('SMINTV')
      RETURN
      END
************************************************************************
      SUBROUTINE SMPRPD(APROP, AMOMQ, AMASSQ, AMAG)
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 APROP
      REAL*8     AMOMQ, AMASSQ, AMAG
      COMMON /CHCNTL/ jwidth
*
*    Calculate denominator of propagator.
*
*     APROP  : in/out : product of denominator of propagators.
*     AMOMP  : input  : square of mementum.
*     AMASSQ : input  : square of mass.
*     AMAG   : input  : mass * width.
*-----------------------------------------------------------------------
      IF (AMOMQ .GT. 0) THEN
          if( jwidth .eq. 0 ) then
              if( amassq .eq. 0.0d0) then
                  wid=0.d0
              else
                  wid=amag/amassq*amomq
              end if
              APROP = - APROP*DCMPLX(AMOMQ - AMASSQ, wid)
          else
              APROP = - APROP*DCMPLX(AMOMQ - AMASSQ, AMAG)
          endif
      ELSE
        APROP = - APROP*DCMPLX(AMOMQ - AMASSQ, 0.0D0)
      ENDIF
 
*     CALL CTIME('SMPRPD')
      RETURN
      END
************************************************************************
      SUBROUTINE SMSSS(CPL, LT, AV)
      IMPLICIT REAL*8(A-H,O-Z)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      COMPLEX*16 CPL
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate scalar-scalar-scalar-scalar vertex.
*
*           ! 3
*           V
*      -->--+--<---
*        1     2
*
*     CPL      : input  : coupling constant.
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*-----------------------------------------------------------------------
      LT(0) = 3
      LT(1) = 1
      LT(2) = 1
      LT(3) = 1
      AV(0) = CPL
*     CALL CTIME('SMSSS ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMSSSS(CPL, LT, AV)
      IMPLICIT REAL*8(A-H,O-Z)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      COMPLEX*16 CPL
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate scalar-scalar-scalar-scalar vertex.
*
*           ! 4
*           V
*      -->--+--<---
*        1  ^  3
*           !2
*
*     CPL      : input  : coupling constant.
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*-----------------------------------------------------------------------
      LT(0) = 4
      LT(1) = 1
      LT(2) = 1
      LT(3) = 1
      LT(4) = 1
      AV(0) = CPL
*     CALL CTIME('SMSSSS')
      RETURN
      END
************************************************************************
      SUBROUTINE SMSSV(L1,K2,K3,CPL,P2,P3,E1,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1
      INTEGER    K2, K3
      COMPLEX*16 CPL
      DIMENSION  P2(4),    P3(4)
      DIMENSION  E1(4,L1)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate vector-scalar-scalar vertex.
*
*           ! 3(S)
*           V
*      -->--+--<---
*      2(S)     1(V)
*
*     L1       : input  : number of polarization vectors (2, 3 OR 4)
*     K2,K3    : input  : if incoming momentum then 1 else -1
*     CPL      : input  : coupling constant.
*     P2,P3    : input  : momentum vectors
*     E1       : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      DIMENSION  PP2(4), PP3(4)
*-----------------------------------------------------------------------
      LT(0) = 3
      LT(1) = 1
      LT(2) = 1
      LT(3) = L1
      DO 10 J = 1, 4
        PP2(J) = K2*P2(J)
        PP3(J) = K3*P3(J)
   10 CONTINUE
      IA = 0
      DO 500 IL1 = 1, L1
        CALL SSV(1.0D0,PP2,PP3,E1(1,IL1),AV0)
        AV(IA) = CPL*AV0
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMSSV ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMSSVV(L1,L2,CPL,E1,E2,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2
      COMPLEX*16 CPL
      DIMENSION  E1(4,L1), E2(4,L2)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate vector-vector-scalar-scalar vertex.
*
*           ! 4(S)
*           V
*      -->--+--<---
*     1(V)  ^  3(S)
*           !2(V)
*
*     L1,L2    : input  : number of polarization vectors (2, 3 OR 4)
*     CPL      : input  : coupling constant.
*     E1,E2    : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
*-----------------------------------------------------------------------
      LT(0) = 4
      LT(1) = 1
      LT(2) = 1
      LT(3) = L1
      LT(4) = L2
      IA = 0
      DO 500 IL2 = 1, L2
      DO 500 IL1 = 1, L1
        CALL VVS(1.0D0,E1(1,IL1),E2(1,IL2),AV0)
        AV(IA) = CPL*AV0
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMSSVV')
      RETURN
      END
************************************************************************
      SUBROUTINE SMSVV (L1,L2,CPL,E1,E2,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2
      COMPLEX*16 CPL
      DIMENSION  E1(4,L1), E2(4,L2)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate vector-vector-scalar vertex.
*
*           ! 3(S)
*           V
*      -->--+--<---
*      2(V)     1(V)
*
*     L1,L2    : input  : number of polarization vectors (2, 3 OR 4)
*     CPL      : input  : coupling constant.
*     E1,E2    : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
*-----------------------------------------------------------------------
      LT(0) = 3
      LT(1) = 1
      LT(2) = L1
      LT(3) = L2
      IA = 0
      DO 500 IL2 = 1, L2
      DO 500 IL1 = 1, L1
        CALL VVS(1.0D0,E1(1,IL1),E2(1,IL2),AV0)
        AV(IA) = CPL*AV0
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMSVV ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMVVV(L1,L2,L3,K1,K2,K3,CPL,P1,P2,P3,E1,E2,E3,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3
      INTEGER    K1, K2, K3
      COMPLEX*16 CPL
      DIMENSION  P1(4),    P2(4),    P3(4)
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L3*L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate vector-vector-vector vertex.
*
*           ! 3
*           V
*      -->--+--<---
*        2     1
*
*     L1,L2,L3 : input  : number of polarization vectors (2, 3 OR 4)
*     K1,K2,K3 : input  : if incoming momentum then 1 else -1
*     CPL      : input  : coupling constant.
*     P1,P2,P3 : input  : momentum vectors
*     E1,E2,E3 : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      DIMENSION  PP12(4), PP23(4), PP31(4)
*-----------------------------------------------------------------------
      LT(0) = 3
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      DO 10 J = 1, 4
        PP12(J) = K1*P1(J) - K2*P2(J)
        PP23(J) = K2*P2(J) - K3*P3(J)
        PP31(J) = K3*P3(J) - K1*P1(J)
   10 CONTINUE
      IA = 0
      DO 500 IL3 = 1, L3
        E3P1P2=E3(4,IL3)*PP12(4)-E3(1,IL3)*PP12(1)
     &        -E3(2,IL3)*PP12(2)-E3(3,IL3)*PP12(3)
      DO 500 IL2 = 1, L2
        E2P3P1=E2(4,IL2)*PP31(4)-E2(1,IL2)*PP31(1)
     &        -E2(2,IL2)*PP31(2)-E2(3,IL2)*PP31(3)
        E2E3=E2(4,IL2)*E3(4,IL3)-E2(1,IL2)*E3(1,IL3)
     &      -E2(2,IL2)*E3(2,IL3)-E2(3,IL2)*E3(3,IL3)
      DO 500 IL1 = 1, L1
CX      CALL VVV(1.0D0,PP1,PP2,PP3,E1(1,IL1),E2(1,IL2),E3(1,IL3),AV0)
        E1P2P3=E1(4,IL1)*PP23(4)-E1(1,IL1)*PP23(1)
     &        -E1(2,IL1)*PP23(2)-E1(3,IL1)*PP23(3)
        E1E2=E1(4,IL1)*E2(4,IL2)-E1(1,IL1)*E2(1,IL2)
     &      -E1(2,IL1)*E2(2,IL2)-E1(3,IL1)*E2(3,IL2)
        E1E3=E1(4,IL1)*E3(4,IL3)-E1(1,IL1)*E3(1,IL3)
     &      -E1(2,IL1)*E3(2,IL3)-E1(3,IL1)*E3(3,IL3)
        AV(IA) = CPL*(E3P1P2*E1E2+E1P2P3*E2E3+E2P3P1*E1E3)
        IA = IA + 1
  500 CONTINUE
*     CALL CTIME('SMVVV ')
      RETURN
      END
************************************************************************
      SUBROUTINE SMVVVV(L1,L2,L3,L4,CPL,E1,E2,E3,E4,LT,AV)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3, L4
      COMPLEX*16 CPL
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3), E4(4,L4)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*    Calculate vector-vector-vector-vector vertex.
*
*           ! 4
*           V
*      -->--+--<---
*        1  ^  3
*           !2
*
*     L1,L2,L3,L4 : input  : number of polarization vectors (2, 3 OR 4)
*     CPL         : input  : coupling constant.
*     E1,E2,E3,E4 : input  : set of polarization vectors
*     AV          : output : table of amplitudes
*     LT          : output : table of sizes in AV
*
*-----------------------------------------------------------------------
      LT(0) = 4
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      LT(4) = L4
*TI
*      write(6,*) ' <<SMVVVV>> LT = ',LT
*      write(6,*) ' <<SMVVVV>> L4 = ',L4
      IA = 0
      DO 500 IL4 = 1, L4
      DO 500 IL3 = 1, L3
      DO 500 IL2 = 1, L2
      DO 500 IL1 = 1, L1
        CALL VVVV(1.0D0,E1(1,IL1),E2(1,IL2),E3(1,IL3),E4(1,IL4),AV0)
        AV(IA) = CPL*AV0
        IA = IA + 1
  500 CONTINUE
*TI 25th Nov. 1991 for INTEL
*      LT(0) = 4
*      LT(1) = L1
*      LT(2) = L2
*      LT(3) = L3
*      LT(4) = L4
*      write(6,*) ' <<SMVVVV>> LT = ',LT
*      write(6,*) ' <<SMVVVV>> L4 = ',L4
*     CALL CTIME('SMVVVV')
      RETURN
      END
************************************************************************
cx      SUBROUTINE SawwV(L1,L2,L3,K1,K2,K3,CPL,P1,P2,P3,E1,E2,E3,LT,AV)
**    SUBROUTINE SawwV(L1,L2,L3,K1,K2,K3,CPL,g1,aeta,al,wm2,P1,P2,P3,
      SUBROUTINE smvww(L1,L2,L3,K1,K2,K3,CPL,g1,aeta,al,wm2,P1,P2,P3,
     &                 e1,e2,e3,lt,av)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3
      INTEGER    K1, K2, K3
      COMPLEX*16 CPL
      DIMENSION  P1(4),    P2(4),    P3(4)
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L3*L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*     Calculate vector-vector-vector vertex.
*
*           ! 3
*           V
*      -->--+--<---
*        2     1
*
*     L1,L2,L3 : input  : number of polarization vectors (2, 3 OR 4)
*     K1,K2,K3 : input  : if incoming momentum then 1 else -1
*     CPL      : input  : coupling constant.
*     P1,P2,P3 : input  : momentum vectors
*     E1,E2,E3 : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      DIMENSION  PP12(4), PP23(4), PP31(4)
      DIMENSION  PP1(4), PP2(4), PP3(4)
*-----------------------------------------------------------------------
c       common / mass / wm2
         
cx	 write(6,*) ' sawwv g1 aeta al wm2 ',g1,aeta,al,wm2
      LT(0) = 3
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      DO 10 J = 1, 4
cx        PP12(J) = K1*P1(J) - K2*P2(J)
cx        PP23(J) = K2*P2(J) - K3*P3(J)
cx        PP31(J) = K3*P3(J) - K1*P1(J)
        PP1(J) = K1*P1(J)
        PP2(J) = K2*P2(J)
        PP3(J) = K3*P3(J)
cx	write(6,*) ' j p1 p2 p3    ',j,p1(j),p2(j),p3(j)
cx	write(6,*) ' j pp1 pp2 pp3 ',j,pp1(j),pp2(j),pp3(j)
   10 CONTINUE
cx	 write(6,*) ' g1 ae al wm2 ',g1,ae,al,wm2
      IA = 0
      DO 500 IL3 = 1, L3
cx        E3P1P2=E3(4,IL3)*PP12(4)-E3(1,IL3)*PP12(1)
cx     &        -E3(2,IL3)*PP12(2)-E3(3,IL3)*PP12(3)
      DO 500 IL2 = 1, L2
cx        E2P3P1=E2(4,IL2)*PP31(4)-E2(1,IL2)*PP31(1)
cx     &        -E2(2,IL2)*PP31(2)-E2(3,IL2)*PP31(3)
cx        E2E3=E2(4,IL2)*E3(4,IL3)-E2(1,IL2)*E3(1,IL3)
cx     &      -E2(2,IL2)*E3(2,IL3)-E2(3,IL2)*E3(3,IL3)
      DO 500 IL1 = 1, L1
cx        CALL VVV(1.0D0,PP1,PP2,PP3,E1(1,IL1),E2(1,IL2),E3(1,IL3),AV(ia))
cx        CALL VVV(1.d0,PP1,PP2,PP3,E1(1,IL1),E2(1,IL2),E3(1,IL3),AV0)
	     
cx 	 write(6,*) ' g1 aeta al wm2 ',g1,aeta,al,wm2
  	call wwva(1.d0,g1,aeta,al,wm2,pp1,pp2,pp3,e1(1,il1),e2(1,il2),
     &                   e3(1,il3),av0)  
**      call wwva(1.d0,g1,aeta,al,wm2,pp3,pp1,pp2,e3(1,il3),e1(1,il1),
**   &                   e2(1,il2),av0)  
cx        E1P2P3=E1(4,IL1)*PP23(4)-E1(1,IL1)*PP23(1)
cx     &        -E1(2,IL1)*PP23(2)-E1(3,IL1)*PP23(3)
cx        E1E2=E1(4,IL1)*E2(4,IL2)-E1(1,IL1)*E2(1,IL2)
cx     &      -E1(2,IL1)*E2(2,IL2)-E1(3,IL1)*E2(3,IL2)
cx        E1E3=E1(4,IL1)*E3(4,IL3)-E1(1,IL1)*E3(1,IL3)
cx     &      -E1(2,IL1)*E3(2,IL3)-E1(3,IL1)*E3(3,IL3)
cx        AV(IA) = CPL*(E3P1P2*E1E2+E1P2P3*E2E3+E2P3P1*E1E3)
          av(ia) = cpl*av0
          IA = IA + 1
cx	  write(6,*) ' ia av0 ',ia,av0
  500 CONTINUE
*     CALL CTIME('SMVVV ')
      RETURN
      END
*971121
************************************************************************
cx      SUBROUTINE SawwV(L1,L2,L3,K1,K2,K3,CPL,P1,P2,P3,E1,E2,E3,LT,AV)
**    SUBROUTINE SawwV(L1,L2,L3,K1,K2,K3,CPL,g1,aeta,al,wm2,P1,P2,P3,
*     SUBROUTINE smvww(L1,L2,L3,K1,K2,K3,CPL,g1,aeta,al,wm2,P1,P2,P3,
*    &                 e1,e2,e3,lt,av)
      SUBROUTINE smvww(L1,L2,L3,K1,K2,K3,CPL,g1,deltka,al,wm2,P1,P2,P3,
     &                 e1,e2,e3,lt,av)
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER (ZERO = 0.0D0, ONE = 1.0D0)
*   * dummy array size.
      PARAMETER (LTSIZE = 20, LASIZE = 1024)
      INTEGER    L1, L2, L3
      INTEGER    K1, K2, K3
      COMPLEX*16 CPL
      DIMENSION  P1(4),    P2(4),    P3(4)
      DIMENSION  E1(4,L1), E2(4,L2), E3(4,L3)
      COMPLEX*16 AV(0:LASIZE)
*     COMPLEX*16 AV(0:L3*L2*L1-1)
      INTEGER    LT(0:LTSIZE)
*
*     Calculate vector-vector-vector vertex.
*
*           ! 3
*           V
*      -->--+--<---
*        2     1
*
*     L1,L2,L3 : input  : number of polarization vectors (2, 3 OR 4)
*     K1,K2,K3 : input  : if incoming momentum then 1 else -1
*     CPL      : input  : coupling constant.
*     P1,P2,P3 : input  : momentum vectors
*     E1,E2,E3 : input  : set of polarization vectors
*     AV       : output : table of amplitudes
*     LT       : output : table of sizes in AV
*
      DIMENSION  PP12(4), PP23(4), PP31(4)
      DIMENSION  PP1(4), PP2(4), PP3(4)
*-----------------------------------------------------------------------
c       common / mass / wm2
C 971121
*------------------------------------------------------------
      aeta = g1 - 1.0d0 + deltka
*------------------------------------------------------------
         
cx	 write(6,*) ' sawwv g1 aeta al wm2 ',g1,aeta,al,wm2
      LT(0) = 3
      LT(1) = L1
      LT(2) = L2
      LT(3) = L3
      DO 10 J = 1, 4
cx        PP12(J) = K1*P1(J) - K2*P2(J)
cx        PP23(J) = K2*P2(J) - K3*P3(J)
cx        PP31(J) = K3*P3(J) - K1*P1(J)
        PP1(J) = K1*P1(J)
        PP2(J) = K2*P2(J)
        PP3(J) = K3*P3(J)
cx	write(6,*) ' j p1 p2 p3    ',j,p1(j),p2(j),p3(j)
cx	write(6,*) ' j pp1 pp2 pp3 ',j,pp1(j),pp2(j),pp3(j)
   10 CONTINUE
cx	 write(6,*) ' g1 ae al wm2 ',g1,ae,al,wm2
      IA = 0
      DO 500 IL3 = 1, L3
cx        E3P1P2=E3(4,IL3)*PP12(4)-E3(1,IL3)*PP12(1)
cx     &        -E3(2,IL3)*PP12(2)-E3(3,IL3)*PP12(3)
      DO 500 IL2 = 1, L2
cx        E2P3P1=E2(4,IL2)*PP31(4)-E2(1,IL2)*PP31(1)
cx     &        -E2(2,IL2)*PP31(2)-E2(3,IL2)*PP31(3)
cx        E2E3=E2(4,IL2)*E3(4,IL3)-E2(1,IL2)*E3(1,IL3)
cx     &      -E2(2,IL2)*E3(2,IL3)-E2(3,IL2)*E3(3,IL3)
      DO 500 IL1 = 1, L1
cx        CALL VVV(1.0D0,PP1,PP2,PP3,E1(1,IL1),E2(1,IL2),E3(1,IL3),AV(ia))
cx        CALL VVV(1.d0,PP1,PP2,PP3,E1(1,IL1),E2(1,IL2),E3(1,IL3),AV0)
	     
cx 	 write(6,*) ' g1 aeta al wm2 ',g1,aeta,al,wm2
  	call wwva(1.d0,g1,aeta,al,wm2,pp1,pp2,pp3,e1(1,il1),e2(1,il2),
     &                   e3(1,il3),av0)  
**      call wwva(1.d0,g1,aeta,al,wm2,pp3,pp1,pp2,e3(1,il3),e1(1,il1),
**   &                   e2(1,il2),av0)  
cx        E1P2P3=E1(4,IL1)*PP23(4)-E1(1,IL1)*PP23(1)
cx     &        -E1(2,IL1)*PP23(2)-E1(3,IL1)*PP23(3)
cx        E1E2=E1(4,IL1)*E2(4,IL2)-E1(1,IL1)*E2(1,IL2)
cx     &      -E1(2,IL1)*E2(2,IL2)-E1(3,IL1)*E2(3,IL2)
cx        E1E3=E1(4,IL1)*E3(4,IL3)-E1(1,IL1)*E3(1,IL3)
cx     &      -E1(2,IL1)*E3(2,IL3)-E1(3,IL1)*E3(3,IL3)
cx        AV(IA) = CPL*(E3P1P2*E1E2+E1P2P3*E2E3+E2P3P1*E1E3)
          av(ia) = cpl*av0
          IA = IA + 1
cx	  write(6,*) ' ia av0 ',ia,av0
  500 CONTINUE
*     CALL CTIME('SMVVV ')
      RETURN
      END
C
C      ************************************************************
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *             ============================                 *
C      *                CHANEL   (Version. 2)                     *
C      *             ============================                 *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *                   Written by H. Tanaka                   *
C      *                                                          *
C      *                                                          *
C      *                        ---------                         *
C      *                        Reference                         *
C      *                        ---------                         *
C      *    ' Numerical Calculation of Helicity Amplitudes        *
C      *      for Processes Involving Massive Fermions'           *
C      *                                                          *
C      *      H. Tanaka, Hiroshima University preprint            *
C      *         Accepted to Comput. Phys. Commun.                *
C      *         for version 1.                                   *
C      *                                                          *
C      *                                                          *
C      *                                                          *
C      *       Version 1 should be added.                         *
C      *                                                          *
C      *                                                          *
C      ************************************************************
C
C
C ********************************************************************
C *                                                                  *
C *  SUBROUTINE SPLT(AM:R*8, P:R*8(4), S1:R*8, S2:R*8,               *
C * &                P1:R*8(4), P2:R*8(4))                           *
C *                                                                  *
C * Decompose off-shell momentum P to two on-shell momenta P1 and P2 *
C *                                                                  *
C *   P = S1*P1 + S2*P2                                              *
C *   P1**2 = 0,      S1 = +-1 (or = 0 for P1 = 0)                   *
C *   P2**2 = AM**2,  S2 = +-1 (or = 0 for P2 = 0)                   *
C *                                        ??????                    *
C *                                        consistent?               *
C *   This subroutine is not included in CHANTL version 1.1.         *
C *                                                                  *
C *                                            written by H. Tanaka  *
C ********************************************************************
C
        SUBROUTINE SPLT(AM,P,S1,S2,P1,P2)
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER (ONE = 1.0)
 
CT      REAL*16 PP,P0,P10,P20,AA,DEN0,DEN,A,B,P00,PPP
        DIMENSION P(4),P1(4),P2(4)
        DATA DD/1.0D-7/
 
CX      DDD=P(4)**2+P(1)**2+P(2)**2+P(1)**2
        DEN0  = P(4) - P(2)
        ADEN0 = ABS(DEN0)
CX      IF (P(4).EQ.0.0D0) THEN
CX        P10 = 0.0D0
CX        S1  = 0.0D0
CX      ELSE
          IF (ADEN0.LE.DD) THEN
            C   = 0.75D0
            A   = SQRT(C)
            B   = 0.5D0
            DEN = P(4)-A*P(1)-B*P(2)
          ELSE
            A   = 0.D0
            B   = 1.D0
            DEN = DEN0
          END IF
          PP   = P(4)*P(4) - P(1)*P(1) - P(2)*P(2) - P(3)*P(3)
          P0   = (PP - AM**2)/(2.0D0*DEN)
          P10  = ABS(P0)
          IF (P10.LE.0.0D0) THEN
            S1  = 0.D0
          ELSE
            S1  = SIGN(ONE, P0)
          END IF
CX      END IF
        P1(1) = A*P10
        P1(2) = B*P10
        P1(3) =   0.D0
        P1(4) =   P10
 
        P00=P(4)-S1*P1(4)
        P20=ABS(P00)
        IF (P20.LE.0.0D0) THEN
          S2 = 0.0D0
        ELSE
          S2 = SIGN(ONE, P00)
        END IF
 
CT      P2(1) = S2*(QEXTD(P(1)) - QEXTD(S1*P1(1)))
CT      P2(2) = S2*(QEXTD(P(2)) - QEXTD(S1*P1(2)))
CT      P2(3) = S2*(QEXTD(P(3)) - QEXTD(S1*P1(3)))
CT      P2(4) = S2*(QEXTD(P(4)) - QEXTD(S1*P1(4)))
        P2(1) = S2*(P(1) - S1*P1(1))
        P2(2) = S2*(P(2) - S1*P1(2))
        P2(3) = S2*(P(3) - S1*P1(3))
        P2(4) = S2*(P(4) - S1*P1(4))
CX      PPP   = AM**2 + P2(1)**2 + P2(2)**2 + P2(3)**2
CX      P2(4) = SQRT(PPP)
 
        RETURN
      END
C
C ****************************************************************
C *                                                              *
C *                                                              *
C *   SUBROUTINE SPLTQ(AM:R*8, P:R*8(4), P2:R*8(4), P1:R*8(4))   *
C *                                                              *
C * Purpose: To decompose momentum of massive fermions to two    *
C *          light-like vectors                                  *
C *                                                              *
C *                                                              *
C *                                                              *
C *                                                              *
C *      AM= : Mass of fermion.                                  *
C *      P = : Momentum of fermion.                              *
C *      P1,P2= : Decomposed light-like vectors.                 *
C *                                                              *
C *                                                              *
C *                                    written by H. Tanaka      *
C ****************************************************************
C
C
C               ============================
                SUBROUTINE SPLTQ(AM,P,P2,P1)
C               ============================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION P(4),P1(4),P2(4)
        DATA DD/0.0D0/
 
        PT1 = P(1)
        PT2 = P(2)
        PT3 = P(3)
        PN  = SQRT(PT1**2 + PT2**2 + PT3**2)
        P10 = (P(4) + PN)*0.5D0
        P20 = AM**2/(4.0*P10)
        IF (PN.LE.DD) THEN
 
          P10   =  AM*0.5D0
          P20   =  P10
 
          P1(1) =  0.D0
          P1(2) =  P10
          P1(3) =  0.D0
          P1(4) =  P10
 
          P2(1) =  0.D0
          P2(2) = -P20
          P2(3) =  0.D0
          P2(4) =  P20
 
        ELSE
 
          ANX=P(1)/PN
          ANY=P(2)/PN
          ANZ=P(3)/PN
 
          P1(1) =  P10*ANX
          P1(2) =  P10*ANY
          P1(3) =  P10*ANZ
          P1(4) =  P10
 
          P2(1) = -P20*ANX
          P2(2) = -P20*ANY
          P2(3) = -P20*ANZ
          P2(4) =  P20
 
        ENDIF
 
        RETURN
      END
C ********************************************************************
C *          3                                                       *
C *          V                                                       *
C *          |                                                       *
C *          |                                                       *
C *  S --<---|---<-- S    SUBROUTINE SSV                             *
C *  1               2                                               *
C *                                                                  *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for vector boson     *
C *              coupled to scalor boson line.                       *
C *                                                                  *
C *     GG=: Coupling constant for vertex.                           *
C *     L=: Polarization state of vector boson.                      *
C *     EP=: Polarization vectors for vector bosons.                 *
C *     P1,P2=: Momenta for scalor bosons.                           *
C *     AALL=: Calculated results of vertex amplitudes for given     *
C *            plarization states.                                   *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C            =====================================
CX           SUBROUTINE SSV(GG,L,P1,P2,EP,AALL)
             SUBROUTINE SSV(GG,P1,P2,EP,AALL)
C            =====================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
CXX     COMPLEX*16 AALL
        DIMENSION EP(4),P1(4),P2(4)
        EP1P2=EP(4)*(P1(4)-P2(4))-EP(1)*(P1(1)-P2(1))
     *       -EP(2)*(P1(2)-P2(2))-EP(3)*(P1(3)-P2(3))
        AALL=GG*EP1P2
CXX     AALL=DCMPLX(AALL,0.D0)
        RETURN
      END
C
C ********************************************************************
C *          3                                                       *
C *          S                                                       *
C *          |                                                       *
C *          |                                                       *
C *  V -->---|---<-- V    SUBROUTINE VVS                             *
C *  1               2                                               *
C *                                                                  *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for vector boson-    *
C *              scalor boson vertex.                                *
C *                                                                  *
C *     GG=: Coupling constant for vertex.                           *
C *     L1,L2=: Polarization state of vector boson.                  *
C *     EP1,EP2=: Polarization vectors for vector bosons.            *
C *     AALL=: Calculated results of vertex amplitudes for given     *
C *            plarization states.                                   *
C *                                                                  *
C *                                                                  *
C *     Comment : The momenta of particles with vertices are         *
C *               taken to flow in.                                  *
C *                                                                  *
C *      (*) This subroutine can be also used for VVSS vertex.       *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C            =====================================
CXX          SUBROUTINE VVS(GG,L1,L2,EP1,EP2,AALL)
             SUBROUTINE VVS(GG,EP1,EP2,AALL)
C            =====================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
CXX     COMPLEX*16 AALL
        DIMENSION EP1(4),EP2(4)
        E1E2=EP1(4)*EP2(4)-EP1(1)*EP2(1)-EP1(2)*EP2(2)-EP1(3)*EP2(3)
        AALL=GG*E1E2
CXX     AALL=DCMPLX(AALL,0.D0)
        RETURN
      END
C
C ********************************************************************
C *          3                                                       *
C *          |                                                       *
C *          |                                                       *
C *  1 -->---|---<-- 2    SUBROUTINE VVV                             *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for three vector-    *
C *              boson vertex.                                       *
C *                                                                  *
C *     GG=: Coupling constant for vertex.                           *
C *     L1,L2,L3=: Polarization state of vector boson.               *
C *     P1,P2,P3=: Momenta for the vector bosons.                    *
C *     EP1,EP2,EP3=: Polarization vectors for vector bosons.        *
C *     AALL=: Calculated results of vertex amplitudes for given     *
C *            plarization states.                                   *
C *                                                                  *
C *                                                                  *
C *     Comment : The momenta of particles with vertices are         *
C *               taken to flow in.                                  *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ===================================================
CXXX    SUBROUTINE VVV(GG,L1,L2,L3,P1,P2,P3,EP1,EP2,EP3,AALL)
        SUBROUTINE VVV(GG,P1,P2,P3,EP1,EP2,EP3,AALL)
C       ===================================================
C
C
CX      IMPLICIT REAL*16(A-H,O-Z)
        IMPLICIT REAL*8(A-H,O-Z)
CXX     REAL*8 GG,P1,P2,P3,EP1,EP2,EP3,AALL
CXX     COMPLEX*16 AALL
        DIMENSION P1(4),P2(4),P3(4),EP1(4),EP2(4),EP3(4)
        E3P1P2=EP3(4)*(P1(4)-P2(4))-EP3(1)*(P1(1)-P2(1))
     *        -EP3(2)*(P1(2)-P2(2))-EP3(3)*(P1(3)-P2(3))
        E1P2P3=EP1(4)*(P2(4)-P3(4))-EP1(1)*(P2(1)-P3(1))
     *        -EP1(2)*(P2(2)-P3(2))-EP1(3)*(P2(3)-P3(3))
        E2P3P1=EP2(4)*(P3(4)-P1(4))-EP2(1)*(P3(1)-P1(1))
     *        -EP2(2)*(P3(2)-P1(2))-EP2(3)*(P3(3)-P1(3))
        E1E2=EP1(4)*EP2(4)-EP1(1)*EP2(1)-EP1(2)*EP2(2)-EP1(3)*EP2(3)
        E2E3=EP2(4)*EP3(4)-EP2(1)*EP3(1)-EP2(2)*EP3(2)-EP2(3)*EP3(3)
        E1E3=EP1(4)*EP3(4)-EP1(1)*EP3(1)-EP1(2)*EP3(2)-EP1(3)*EP3(3)
        VVVV=GG*(E3P1P2*E1E2+E1P2P3*E2E3+E2P3P1*E1E3)
        AALL=VVVV
CXX     AALL=DCMPLX(AALL,0.D0)
        RETURN
      END
C
C ********************************************************************
C *          V4                                                      *
C *          |                                                       *
C *          |                                                       *
C * V1 -->---|---<-- V3   SUBROUTINE VVVV                            *
C *          |                                                       *
C *          |                                                       *
C *         V2                                                       *
C *                                                                  *
C *     V1,V2=: Charged gauge bosons ( W+ OR W- ).                   *
C *     V3,V4=: Neutral gauge bosons ( photon or Z0 ) or             *
C *             charged gouge bosons with oposite charges to         *
C *             V1 and V2.                                           *
C *                                                                  *
C *     Purpose: To calculate vertex amplitudes for four vector-     *
C *              boson vertex.                                       *
C *                                                                  *
C *     GG=: Coupling constant for vertex.                           *
C *     L1,L2,L3,L4=: Polarization state of vector boson.            *
C *     P1,P2,P3,P4=: Momenta for the vector bosons.                 *
C *     EP1,EP2,EP3,EP4=: Polarization vectors for vector bosons.    *
C *     AALL=: Calculated results of vertex amplitudes for given     *
C *            plarization states.                                   *
C *                                                                  *
C *                                                                  *
C *     Comment : The momenta of particles with vertices are         *
C *               taken to flow in.                                  *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ==============================================================
CXXX    SUBROUTINE VVVV(GG,L1,L2,L3,L4,
CXXX *             P1,P2,P3,P4,EP1,EP2,EP3,EP4,AALL)
        SUBROUTINE VVVV(GG,EP1,EP2,EP3,EP4,AALL)
C       ==============================================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
CXX     COMPLEX*16 AALL
CXX     DIMENSION P1(4),P2(4),P3(4),P4(4),EP1(4),EP2(4),EP3(4),EP4(4)
        DIMENSION EP1(4),EP2(4),EP3(4),EP4(4)
        E1E2=EP1(4)*EP2(4)-EP1(1)*EP2(1)-EP1(2)*EP2(2)-EP1(3)*EP2(3)
        E3E4=EP3(4)*EP4(4)-EP3(1)*EP4(1)-EP3(2)*EP4(2)-EP3(3)*EP4(3)
        E1E3=EP1(4)*EP3(4)-EP1(1)*EP3(1)-EP1(2)*EP3(2)-EP1(3)*EP3(3)
        E2E4=EP2(4)*EP4(4)-EP2(1)*EP4(1)-EP2(2)*EP4(2)-EP2(3)*EP4(3)
        E1E4=EP1(4)*EP4(4)-EP1(1)*EP4(1)-EP1(2)*EP4(2)-EP1(3)*EP4(3)
        E2E3=EP2(4)*EP3(4)-EP2(1)*EP3(1)-EP2(2)*EP3(2)-EP2(3)*EP3(3)
        AALL=GG*(E1E3*E2E4+E1E4*E2E3-2.D0*E1E2*E3E4)
CXX     AALL=DCMPLX(AALL,0.D0)
        RETURN
      END
C ********************************************************************
C *                                                                  *
C *          3 W(-) P3 EP3                                           *
C *          !                                                       *
C *          !                                                       *
C *  1 -->---!---<-- 2    SUBROUTINE WWVA                            *
C *  V              W(+)                                             *
C *  P1             P2                                               *
C *  EP1            EP2                                              *
C *                                                                  *
C *     Purpose: to calculate vertex amplitudes for three vector-    *
C *              boson vertex including anomalous couplings.         *
C *                                                                  *
C *     Comment : The momenta of particles with vertices are         *
C *               taken to flow in.                                  *
C *                                                                  *
C *     The constructed amplitude has the following form:            *
C *                                                                  *
C *     AALL=GG*( G1*(   (EP3.(P1-P2))*(EP1.EP2)                     *
C *                    + (EP1.(P2-P3))*(EP2.EP3)                     *
C *                    + (EP2.(P3-P1))*(EP1.EP3) )                   *
C *                                                                  *
C *         + AE*((EP1.EP3)*(EP2.P1) - (EP1.EP2)*(EP3.P1))           *
C *         + AL/WM2*((EP2.EP3)*((EP1.P3)*(P1.P2)-(EP1.P2)*(P1.P3))  *
C *                  +(EP1.EP3)*((EP2.P1)*(P2.P3)-(EP2.P3)*(P1.P2))  *
C *                  +(EP1.EP2)*((EP3.P2)*(P1.P3)-(EP3.P1)*(P2.P3))  *
C *                  +(EP1.P2)*(EP2.P3)*(EP3.P1)                     *
C *                  -(EP1.P3)*(EP2.P1)*(EP3.P2))                    *
C *                                                                  *
C *                                                                  *
C *     GG : coupling constant for the standard model.               *
C *     G1 :                                                         *
C *     AE : G1 - K                                                  *
C *     AL :                                                         *
C *     WM2: W boson mass squared.                                   *
C *     P1,P2,P3=: momenta of the vector bosons.                     *
C *     EP1,EP2,EP3=: polarization vectors of vector bosons.         *
C *     AALL=: calculated results of vertex amplitudes for given     *
C *            plarization states.                                   *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C
C        GG : COUPLING FOR STANDARD MODEL
C        G1 :
C        AE : G1 - K
C        AL :
C        WM2: W BOSON MASS SQUARED
C
C        ==========================================================
         SUBROUTINE WWVA(GG,G1,AE,AL,WM2,P1,P2,P3,EP1,EP2,EP3,AALL)
C        ==========================================================
C
         IMPLICIT REAL*8(A-H,O-Z)
*        DIMENSION P1(4),P2(4),P3(3),EP1(4),EP2(4),EP3(4)
         DIMENSION P1(4),P2(4),P3(4),EP1(4),EP2(4),EP3(4)
         GG0 = 1.D0
         CALL VVV(GG0,P1,P2,P3,EP1,EP2,EP3,AALL0)
 
        E1E2=EP1(4)*EP2(4)-EP1(1)*EP2(1)-EP1(2)*EP2(2)-EP1(3)*EP2(3)
        E1E3=EP1(4)*EP3(4)-EP1(1)*EP3(1)-EP1(2)*EP3(2)-EP1(3)*EP3(3)
        E2E3=EP2(4)*EP3(4)-EP2(1)*EP3(1)-EP2(2)*EP3(2)-EP2(3)*EP3(3)
 
        P1P2=P1(4)*P2(4)-P1(1)*P2(1)-P1(2)*P2(2)-P1(3)*P2(3)
        P1P3=P1(4)*P3(4)-P1(1)*P3(1)-P1(2)*P3(2)-P1(3)*P3(3)
        P2P3=P2(4)*P3(4)-P2(1)*P3(1)-P2(2)*P3(2)-P2(3)*P3(3)
 
        E1P2=EP1(4)*P2(4)-EP1(1)*P2(1)-EP1(2)*P2(2)-EP1(3)*P2(3)
        E1P3=EP1(4)*P3(4)-EP1(1)*P3(1)-EP1(2)*P3(2)-EP1(3)*P3(3)
        E2P3=EP2(4)*P3(4)-EP2(1)*P3(1)-EP2(2)*P3(2)-EP2(3)*P3(3)
 
        E2P1=EP2(4)*P1(4)-EP2(1)*P1(1)-EP2(2)*P1(2)-EP2(3)*P1(3)
        E3P1=EP3(4)*P1(4)-EP3(1)*P1(1)-EP3(2)*P1(2)-EP3(3)*P1(3)
        E3P2=EP3(4)*P2(4)-EP3(1)*P2(1)-EP3(2)*P2(2)-EP3(3)*P2(3)
 
        AALL1 = E1E3*E2P1 - E1E2*E3P1
        AALL2 = E2E3*(E1P3*P1P2 - E1P2*P1P3)
        AALL3 = E1E3*(E2P1*P2P3 - E2P3*P1P2)
        AALL4 = E1E2*(E3P2*P1P3 - E3P1*P2P3)
        AALL5 = E1P2*E2P3*E3P1 - E1P3*E2P1*E3P2
 
        AALL = GG*(G1*AALL0+AE*AALL1
     &       + AL/WM2*(AALL2+AALL3+AALL4+AALL5))
 
        RETURN
        END
C
C ********************************************************************
C *          V4 EP4                                                  *
C *          |                                                       *
C *          |                                                       *
C * W- -->---|---<-- V3   SUBROUTINE WWVVA                           *
C * EP1      |      EP3                                              *
C *          |                                                       *
C *         W+ EP2                                                   *
C *                                                                  *
C *                                                                  *
C *     Purpose: to calculate vertex amplitudes for three vector-    *
C *              boson vertex including anomalous couplings.         *
C *                                                                  *
C *                                                                  *
C *     Comment : the constructed amplitude has the following form:  *
C *                                                                  *
C *    AALL=GG*(EP1.EP3*EP2.EP4+EP1.EP4*EP2.EP3-2.*EP1.EP2*EP3.EP4). *
C *                                                                  *
C *     GG=: coupling constant for vertex.                           *
C *     EP1,EP2,EP3,EP4=: polarization vectors for vector bosons.    *
C *     AALL=: calculated result of vertex amplitude for given       *
C *            plarization states.                                   *
C *                                                                  *
C *                                      written by H. Tanaka        *
C ********************************************************************
C
C
C       ==============================================================
        SUBROUTINE WWVVA(GG,G1,AE,AL,WM2,P1,P2,P3,P4,
     &                                         EP1,EP2,EP3,EP4,AALL)
C       ==============================================================
C
C
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION EP1(4),EP2(4),EP3(4),EP4(4)
        DIMENSION P1(4),P2(4),P3(4),P4(4) ,PS(4)
 
         PS(1) = P1(1)+P2(1)
         PS(2) = P1(2)+P2(2)
         PS(3) = P1(3)+P2(3)
         PS(4) = P1(4)+P2(4)
 
         GG0 = 1.D0
         CALL VVVV(GG0,EP1,EP2,EP3,EP4,AALL0)
CX       WRITE(6,*) ' GG G1 AE AL ',GG,G1,AE,AL
CX       WRITE(6,*) ' AALL0 ',AALL0
 
        E1E2=EP1(4)*EP2(4)-EP1(1)*EP2(1)-EP1(2)*EP2(2)-EP1(3)*EP2(3)
        E3E4=EP3(4)*EP4(4)-EP3(1)*EP4(1)-EP3(2)*EP4(2)-EP3(3)*EP4(3)
        E1E3=EP1(4)*EP3(4)-EP1(1)*EP3(1)-EP1(2)*EP3(2)-EP1(3)*EP3(3)
        E2E4=EP2(4)*EP4(4)-EP2(1)*EP4(1)-EP2(2)*EP4(2)-EP2(3)*EP4(3)
        E1E4=EP1(4)*EP4(4)-EP1(1)*EP4(1)-EP1(2)*EP4(2)-EP1(3)*EP4(3)
        E2E3=EP2(4)*EP3(4)-EP2(1)*EP3(1)-EP2(2)*EP3(2)-EP2(3)*EP3(3)
 
        P1P2=P1(4)*P2(4)-P1(1)*P2(1)-P1(2)*P2(2)-P1(3)*P2(3)
        P3P4=P3(4)*P4(4)-P3(1)*P4(1)-P3(2)*P4(2)-P3(3)*P4(3)
        P1P3=P1(4)*P3(4)-P1(1)*P3(1)-P1(2)*P3(2)-P1(3)*P3(3)
        P2P4=P2(4)*P4(4)-P2(1)*P4(1)-P2(2)*P4(2)-P2(3)*P4(3)
        P1P4=P1(4)*P4(4)-P1(1)*P4(1)-P1(2)*P4(2)-P1(3)*P4(3)
        P2P3=P2(4)*P3(4)-P2(1)*P3(1)-P2(2)*P3(2)-P2(3)*P3(3)
        PSPS=PS(4)*PS(4)-PS(1)*PS(1)-PS(2)*PS(2)-PS(3)*PS(3)
 
        E1P2=EP1(4)*P2(4)-EP1(1)*P2(1)-EP1(2)*P2(2)-EP1(3)*P2(3)
        E3P4=EP3(4)*P4(4)-EP3(1)*P4(1)-EP3(2)*P4(2)-EP3(3)*P4(3)
        E1P3=EP1(4)*P3(4)-EP1(1)*P3(1)-EP1(2)*P3(2)-EP1(3)*P3(3)
        E2P4=EP2(4)*P4(4)-EP2(1)*P4(1)-EP2(2)*P4(2)-EP2(3)*P4(3)
        E1P4=EP1(4)*P4(4)-EP1(1)*P4(1)-EP1(2)*P4(2)-EP1(3)*P4(3)
        E2P3=EP2(4)*P3(4)-EP2(1)*P3(1)-EP2(2)*P3(2)-EP2(3)*P3(3)
        E1PS=EP1(4)*PS(4)-EP1(1)*PS(1)-EP1(2)*PS(2)-EP1(3)*PS(3)
        E2PS=EP2(4)*PS(4)-EP2(1)*PS(1)-EP2(2)*PS(2)-EP2(3)*PS(3)
        E3PS=EP3(4)*PS(4)-EP3(1)*PS(1)-EP3(2)*PS(2)-EP3(3)*PS(3)
        E4PS=EP4(4)*PS(4)-EP4(1)*PS(1)-EP4(2)*PS(2)-EP4(3)*PS(3)
 
        E2P1=EP2(4)*P1(4)-EP2(1)*P1(1)-EP2(2)*P1(2)-EP2(3)*P1(3)
        E4P3=EP4(4)*P3(4)-EP4(1)*P3(1)-EP4(2)*P3(2)-EP4(3)*P3(3)
        E3P1=EP3(4)*P1(4)-EP3(1)*P1(1)-EP3(2)*P1(2)-EP3(3)*P1(3)
        E4P2=EP4(4)*P2(4)-EP4(1)*P2(1)-EP4(2)*P2(2)-EP4(3)*P2(3)
        E4P1=EP4(4)*P1(4)-EP4(1)*P1(1)-EP4(2)*P1(2)-EP4(3)*P1(3)
        E3P2=EP3(4)*P2(4)-EP3(1)*P2(1)-EP3(2)*P2(2)-EP3(3)*P2(3)
 
        AALL1 = E3E4*PSPS
        AALL2 = E1E3*E2E4*(P2P3+P1P4)+E1E4*E2E3*(P1P3+P2P4)
        AALL3 = E1E2*(E4P3*E3PS+E3P4*E4PS)
        AALL4 = E3E4*(E2P1*E1PS+E1P2*E2PS)
        AALL5 = E2E4*(E1P3*E3P2+E1P4*E3P1-E1P4*E3P2+E3P4*E1P2)
        AALL6 = E1E4*(-E2P4*E3P1+E3P4*E2P1+E2P3*E3P1+E2P4*E3P2)
        AALL7 = E2E3*(-E4P2*E1P3+E1P2*E4P3+E4P1*E1P3+E4P2*E1P4)
        AALL8 = E1E3*(-E4P1*E2P3+E2P1*E4P3+E2P3*E4P2+E2P4*E4P1)
 
CX       WRITE(6,*) ' AALL0 ',AALL0
        AALL = GG*( G1*AALL0
     &              + AL/WM2*(AALL1+AALL2+AALL3
CX   &              - AL/WM2*(AALL1+AALL2+AALL3 ???
     &                          - AALL4-AALL5-AALL6-AALL7-AALL8))
CX       WRITE(6,*) ' AALL  ',AALL
        RETURN
        END
       SUBROUTINE ARRCLR(A,N)
       REAL*8 A(100)
       IF(N.GT.100) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN 100 ',N
        RETURN
       END IF
       DO 1 I12=1,N
1        A(I12)=0
       RETURN
       END
       SUBROUTINE ARRCPY(A,B,N)
       REAL*8 A(100),B(100)
       IF(N.GT.100) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN 100 ',N
        RETURN
       END IF
       DO 1 I11=1,N
1        A(I11)=B(I11)
       RETURN
       END
       FUNCTION DETERM(A,N)
       REAL*8 DETERM,A(100),B(10,10),SAVE
       IF(N.GT.10) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN TEN ',N
        RETURN
       END IF
       DO 1 I12=1,N
       DO 1 I11=1,N
1        B(I11,I12)=A(I11+N*(I12-1))
       DETERM=1
       DO 2 I2=1,N
        IF(B(I2,I2).EQ.0)THEN
         DO 5 I5=I2,N
          IF(B(I2,I5).EQ.0)THEN
           DETERM=0
           RETURN
          ELSE
           DO 6 I6=I2,N
            SAVE=B(I6,I5)
            B(I6,I5)=B(I5,I2)
            B(I5,I2)=SAVE
6           CONTINUE
           DETERM=-DETERM
          END IF
5         CONTINUE
        END IF
        DETERM=DETERM*B(I2,I2)
        IF(I2.EQ.N) GOTO 2
        DO 3 I3=I2+1,N
        DO 3 I4=I2+1,N
3         B(I3,I4)=B(I3,I4)-B(I3,I2)*B(I2,I4)/B(I2,I2)
2       CONTINUE
       RETURN
       END
      subroutine ktolab(p1,p2,p3,p4, p5,p6)
*
      implicit real*8(a-h,o-z)
      real*8 p1(4),p2(4),p3(4),p4(4),p5(4),p6(4)
      real*8 pk2l(4),pl2k(4),rk2l(3,3),rl2k(3,3),pt1(4)
*
      do 1 i=1,4
       pk2l(i)= p2(i)
       pl2k(i)=-p2(i)
1     continue
       pl2k(4)= p2(4)
*
      call pboost(p1,pl2k, pt1)
      call rotmtx(pt1, rl2k)
      call minvr2(rl2k, rk2l)
*
      call mvmult(rk2l,p3, p5)
      call pboost(p5,pk2l, p5)
      call mvmult(rk2l,p4, p6)
      call pboost(p6,pk2l, p6)
*
      return
      end
      subroutine labtok(p1,p2,p3,p4, p5,p6)
*
      implicit real*8(a-h,o-z)
      real*8 p1(4),p2(4),p3(4),p4(4),p5(4),p6(4)
      real*8 pl2k(4),pt1(4),rl2k(3,3)
*
      do 1 i=1,4
       pl2k(i)=-p2(i)
1     continue
       pl2k(4)= p2(4)
*
      call pboost(p1,pl2k, pt1)
      call rotmtx(pt1, rl2k)
*
      call pboost(p3,pl2k, p5)
      call mvmult(rl2k,p5, p5)
      call pboost(p4,pl2k, p6)
      call mvmult(rl2k,p6, p6)
*
      return
      end
       SUBROUTINE MEMCLC(R,N1,N2)
       COMPLEX*16 R(9)
       DO 1 I=1,N1
1       R(I)=N2
       RETURN
       END
       SUBROUTINE MEMCLR(R,N1,N2)
       REAL*8 R(9)
       DO 1 I=1,N1
1       R(I)=N2
       RETURN
       END
       FUNCTION MINOR(A,N,I,J)
       REAL*8 MINOR,A(100),B(100),DETERM
       IF(N.GT.10) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN TEN ',N
        RETURN
       END IF
       DO 1 I1=1,N-1
        II1=I1
        IF(I1.GE.I)II1=I1+1
        DO 2 I2=1,N-1
         II2=I2
         IF(I2.GE.J)II2=I2+1
2        B(I1+(N-1)*(I2-1))=A(II1+N*(II2-1))
1       CONTINUE
       MINOR=DETERM(B,N-1)
       RETURN
       END
       SUBROUTINE MINVR2(M1,M2)
       REAL*8 M1(3,3),M2(3,3),M3(3,3)
       DO 1 I=1,3
       DO 1 J=1,3
        M3(I,J)=M1(J,I)
1      CONTINUE
       DO 2 I=1,3
       DO 2 J=1,3
        M2(I,J)=M3(I,J)
2      CONTINUE
       RETURN
       END
       SUBROUTINE MINVRT(R1,R2)
       REAL*8 R1(9),R2(9)
       REAL*8 RTMP1(9)
C
       DO 1 I=1,9
1       RTMP1(I)=R1(I)
C
C      CALL DINV(3,RTMP1,3,RTMP2,ICON)
       CALL MTXINV(RTMP1,3)
       DO 2 I=1,9
2       R2(I)=RTMP1(I)
C
       RETURN
       END
       SUBROUTINE MMMULT(R1,R2,R3)
       REAL*8 R1(3,3),R2(3,3),R3(3,3),RDUMMY(3,3)
       CALL MEMCLR(RDUMMY,9,0)
       DO 1 I=1,3
       DO 2 J=1,3
       DO 3 K=1,3
3       RDUMMY(I,J)=RDUMMY(I,J)+R1(I,K)*R2(K,J)
2      CONTINUE
1      CONTINUE
       DO 4 I=1,3
       DO 5 J=1,3
5       R3(I,J)=RDUMMY(I,J)
4      CONTINUE
C
       RETURN
       END
       SUBROUTINE MTXCLR(A,N)
       REAL*8 A(100)
       IF(N.GT.10) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN TEN ',N
        RETURN
       END IF
       DO 1 I12=1,N
       DO 1 I11=1,N
1        A(I11+N*(I12-1))=0
       RETURN
       END
       SUBROUTINE MTXCPY(A,B,N)
       REAL*8 A(100),B(100)
       IF(N.GT.10) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN TEN ',N
        RETURN
       END IF
       DO 1 I12=1,N
       DO 1 I11=1,N
1       B(I11+N*(I12-1))=A(I11+N*(I12-1))
       RETURN
       END
       SUBROUTINE MTXINV(A,N)
       REAL*8 A(100),B(100),DET,DETERM,MINOR
       IF(N.GT.10) THEN
        WRITE(6,*)' # ORDER IS GREATER THAN TEN ',N
        RETURN
       END IF
       CALL MTXCPY(A,B,N)
       DET=DETERM(A,N)
       DO 2 I3=1,N
       DO 2 I2=1,N
2        A(I2+N*(I3-1))=(1-MOD(I3+I2,2)*2)*MINOR(B,N,I3,I2)/DET
       RETURN
       END
       SUBROUTINE MVMULT(R,P1,P2)
       REAL*8 R(3,3),P1(4),P2(4),PTMP(4)
C
       PTMP(1)=P1(1)*R(1,1)+P1(2)*R(1,2)+P1(3)*R(1,3)
       PTMP(2)=P1(1)*R(2,1)+P1(2)*R(2,2)+P1(3)*R(2,3)
       PTMP(3)=P1(1)*R(3,1)+P1(2)*R(3,2)+P1(3)*R(3,3)
       PTMP(4)=P1(4)
C
       P2(1)=PTMP(1)
       P2(2)=PTMP(2)
       P2(3)=PTMP(3)
       P2(4)=PTMP(4)
C
       RETURN
       END
       SUBROUTINE PBOOST(P,Q,PB)
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION P(4),Q(4),PB(4)
C
       PQ=P(1)*Q(1)+P(2)*Q(2)+P(3)*Q(3)
       Q2=Q(1)**2+Q(2)**2+Q(3)**2
       Q1=SQRT(Q2)
C
       AM=SQRT( (Q(4)-Q1)*(Q(4)+Q1) )
        F=((Q(4)-AM)*PQ/Q2+P(4))/AM
       PB(1)= P(1)+Q(1)*F
       PB(2)= P(2)+Q(2)*F
       PB(3)= P(3)+Q(3)*F
       PB(4)=(P(4)*Q(4)+PQ)/AM
       RETURN
       END
       SUBROUTINE ROTMTX(PAX, ROT)
* Debug 27/DEC/94 Y.Kurihara: To treat PAX(1)**2+PAX(2)**2=0
* Debug 04/Jan/95 Y.Kurihara: den>1.d-15 -->den>1.d-10 
*       19/Jan/95 Y.Kurihara: To treat phi rotation    
*
       IMPLICIT REAL* 8(A-H,O-Z)
       REAL*8 PAX(4)
       REAL*8 ROT(3,3),ROTTMP(3,3)
       den=SQRT(PAX(1)*PAX(1)+PAX(2)*PAX(2))
       if(den.le.1.d-10) then
         CALL MEMCLR(ROT,9,0)
         rot(1,1)=sign(1.d0,pax(3))
         rot(2,2)=sign(1.d0,pax(3))
         rot(3,3)=sign(1.d0,pax(3))
         return
       end if
       COSA=PAX(1)/den
       SINA=PAX(2)/den
       CALL MEMCLR(ROTTMP,9,0)
       ROTTMP(1,1)= COSA
       ROTTMP(1,2)= SINA
       ROTTMP(2,1)=-SINA
       ROTTMP(2,2)= COSA
       ROTTMP(3,3)= 1
       CALL MVMULT(ROTTMP,PAX,PAX)
       CALL MEMCLR(ROT,9,0)
       COSB=PAX(3)/SQRT(PAX(1)*PAX(1)+PAX(3)*PAX(3))
       SINB=PAX(1)/SQRT(PAX(1)*PAX(1)+PAX(3)*PAX(3))
       ROT(1,1)= COSB
       ROT(1,3)=-SINB
       ROT(2,2)= sign(1.d0,pax(3))
       ROT(3,1)= SINB
       ROT(3,3)= COSB
       CALL MMMULT(ROT,ROTTMP,ROT)
       RETURN
       END
       SUBROUTINE VVVMLT(P1,P2,P3)
       REAL*8 P1(0:3),P2(0:3),P3(0:3)
*      P3(4)=0
       P3(0)=0
       P3(1)=P1(2)*P2(3)-P1(3)*P2(2)
       P3(2)=P1(3)*P2(1)-P1(1)*P2(3)
       P3(3)=P1(1)*P2(2)-P1(2)*P2(1)
       RETURN
       END
       SUBROUTINE WTOLAB(P1,P2,P3, P4,P5)
* Debug 04/Jan/95 Y.Kurihara: To treat P3(1)**2+P3(2)**2=0
* Debug 04/Jan/95 Y.Kurihara: >1.d-15 --> >1.d-10
* Debug 25/Jan/95 Y.Kurihara: change to use rotmtx 
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION P1(4),P2(4),P3(4),P4(4),P5(4)
       DIMENSION ROT1(3,3),pt(4)
C DETERMIN ROTATION MATRIX 1
       pt(1)=p3(1)
       pt(2)=p3(2)
       pt(3)=p3(3)
       pt(4)=p3(4)
       call rotmtx(pt, rot1)
       CALL MINVR2(ROT1,ROT1)
C
       CALL MVMULT(ROT1,P1,P4)
       CALL MVMULT(ROT1,P2,P5)
       CALL PBOOST(P4,P3,P4)
       CALL PBOOST(P5,P3,P5)
C
       RETURN
       END
      function akmass(kfc)
      implicit real*8 (a-h,o-z)
      include 'inclk.f'
C-----
      if(abs(kfc).eq.1) then
         akmass = amdq
      else if(abs(kfc).eq.2) then
         akmass = amuq
      else if(abs(kfc).eq.3) then
         akmass = amsq
      else if(abs(kfc).eq.4) then
         akmass = amcq
      else if(abs(kfc).eq.5) then
         akmass = ambq
      else if(abs(kfc).eq.11) then
         akmass = amel
      else if(abs(kfc).eq.12) then
         akmass = amne
      else if(abs(kfc).eq.13) then
         akmass = ammu
      else if(abs(kfc).eq.14) then
         akmass = amnm
      else if(abs(kfc).eq.15) then
         akmass = amta
      else if(abs(kfc).eq.16) then
         akmass = amnt
      else if(abs(kfc).eq.23) then
         akmass = amz
      else if(abs(kfc).eq.24) then
         akmass = amw
      else 
          akmass = 0.0d0
          print *,'kfc = ',kfc
          call grcerr(2,' Invalid KFCODE @ akmass ')
      endif
      return
      end
C=======================================================================
      function akwdth(kfc)
      implicit real*8 (a-h,o-z)
      include 'inclk.f'
C-----
      if(abs(kfc).eq.1) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.2) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.3) then
         akwdth = agsq
      else if(abs(kfc).eq.4) then
         akwdth = agcq
      else if(abs(kfc).eq.5) then
         akwdth = agbq
      else if(abs(kfc).eq.11) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.12) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.13) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.14) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.15) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.16) then
         akwdth = 0.0d0
      else if(abs(kfc).eq.23) then
         akwdth = agz
      else if(abs(kfc).eq.24) then
         akwdth = agw
      else 
          akwdth = 0.0d0
          call grcerr(2,' Invalid KFCODE @ akwdth ')
      endif
      return
      end
*-----------------------------------------------------------------------
	subroutine amp4qs(pp,the,phi,jselpr,amp2)
*-----------------------------------------------------------------------
* Auther : Y. Kurihara
* Date   : 97-06-06
* Revised: 97-07-02 for grc4f.2.1 (by TI)
*
* Input  
*  pp(i) : momentum of i'th particle in GeV (final particles)
*  the(i): Polar angle of i'th partivle in radian 
*  phi(i): azimuthal angle of i'th partivle in radian 
*  
*  jselpr(j) : calculating j'th process when jselpr(j)=1 
*
* Output 
*  amp2(j) : amplitude square of j'th process. 
*   Process #   Process name         Process #   Process name
*      ( 1)    'eceCeneN'               (39)    'tctCcqcQ'
*      ( 2)    'eceNmCmn'               (40)    'mcmCdqdQ'
*      ( 3)    'eceNtCtn'               (41)    'mcmCsqsQ'
*      ( 4)    'mnmCmcmN'               (42)    'mcmCbqbQ'
*      ( 5)    'tntCtctN'               (43)    'tctCdqdQ'
*      ( 6)    'mcmNtCtn'               (44)    'tctCsqsQ'
*      ( 7)    'eceCeceC'               (45)    'tctCbqbQ'
*      ( 8)    'eceCmcmC'               (46)    'eneNuquQ'
*      ( 9)    'eceCtctC'               (47)    'eneNcqcQ'
*      (10)    'mcmCmcmC'               (48)    'eneNdqdQ'
*      (11)    'tctCtctC'               (49)    'eneNsqsQ'
*      (12)    'mcmCtctC'               (50)    'eneNbqbQ'
*      (13)    'eceCmnmN'               (51)    'mnmNuquQ'
*      (14)    'eceCtntN'               (52)    'mnmNcqcQ'
*      (15)    'eneNmcmC'               (53)    'tntNuquQ'
*      (16)    'eneNtctC'               (54)    'tntNcqcQ'
*      (17)    'tntNmcmC'               (55)    'mnmNdqdQ'
*      (18)    'mnmNtctC'               (56)    'mnmNsqsQ'
*      (19)    'eneNeneN'               (57)    'mnmNbqbQ'
*      (20)    'eneNmnmN'               (58)    'tntNdqdQ'
*      (21)    'eneNtntN'               (59)    'tntNsqsQ'
*      (22)    'mnmNmnmN'               (60)    'tntNbqbQ'
*      (23)    'tntNtntN'               (61)    'uqdQdquQ'
*      (24)    'tntNmnmN'               (62)    'cqsQsqcQ'
*      (25)    'eceNuqdQ'               (63)    'uqdQsqcQ'
*      (26)    'eceNcqsQ'               (64)    'uquQuquQ'
*      (27)    'mcmNuqdQ'               (65)    'cqcQcqcQ'
*      (28)    'mcmNcqsQ'               (66)    'dqdQdqdQ'
*      (29)    'tctNuqdQ'               (67)    'sqsQsqsQ'
*      (30)    'tctNcqsQ'               (68)    'bqbQbqbQ'
*      (31)    'eceCuquQ'               (69)    'uquQcqcQ'
*      (32)    'eceCcqcQ'               (70)    'uquQsqsQ'
*      (33)    'eceCdqdQ'               (71)    'uquQbqbQ'
*      (34)    'eceCsqsQ'               (72)    'cqcQdqdQ'
*      (35)    'eceCbqbQ'               (73)    'cqcQbqbQ'
*      (36)    'mcmCuquQ'               (74)    'dqdQsqsQ'
*      (37)    'mcmCcqcQ'               (75)    'dqdQbqbQ'
*      (38)    'tctCuquQ'               (76)    'sqsQbqbQ'
*
*
        implicit real*8 (a-h,o-z)
        include 'incl1.f'
        include 'inclk.f'
        include 'inclpd.f'
        common /grc4fs/ nthprc
        dimension amp2(76)
        dimension pp(4),the(4),phi(4)
        dimension p(4,6)
        dimension jselpr(76)
        dimension stfac(76)
        data stfac /1.00d0,2.00d0,2.00d0,1.00d0,1.00d0
     .,             2.00d0,0.25d0,1.00d0,1.00d0,0.25d0
     .,             0.25d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,0.25d0,1.00d0
     .,             1.00d0,0.25d0,0.25d0,1.00d0,2.00d0
     .,             2.00d0,2.00d0,2.00d0,2.00d0,2.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,2.00d0,0.25d0,0.25d0
     .,             0.25d0,0.25d0,0.25d0,1.00d0,1.00d0
     .,             1.00d0,1.00d0,1.00d0,1.00d0,1.00d0
     .,             1.00d0                              /
*
* set 4-vectors
*
          eb=(pp(1)+pp(2)+pp(3)+pp(4))/2.d0
          p(1,1)= 0.d0
          p(2,1)= 0.d0
          p(3,1)= eb
          p(4,1)= eb
*
          p(1,2)= 0.d0
          p(2,2)= 0.d0
          p(3,2)=-eb
          p(4,2)= eb
*
          do 1 i=1,4
            p(1,i+2)=pp(i)*sin(the(i))*cos(phi(i))
            p(2,i+2)=pp(i)*sin(the(i))*sin(phi(i))
            p(3,i+2)=pp(i)*cos(the(i))
            p(4,i+2)=pp(i)
1         continue
*
          do 2 i = 1, 4
           pe1(i) = p(i, 1)
           pe2(i) = p(i, 2)
           pe3(i) = p(i, 3)
           pe4(i) = p(i, 4)
           pe5(i) = p(i, 5)
           pe6(i) = p(i, 6)
2         continue
*
* set invariants
*
          do 3 i=1,6
          do 3 j=1,6
           prod(i,j)=p(4,i)*p(4,j)
     .              -p(1,i)*p(1,j)
     .              -p(2,i)*p(2,j)
     .              -p(3,i)*p(3,j)
3         continue

          call k9pqs(p,prod)

          aspin=0.25d0
          do 4 i=1,144
             jselg(i)=1
4         continue
*
* set coulomb factor
*
          if(jcolmb.ne.0) then
            s=4*eb*eb
            q12=2*prod(3,4)
            q22=2*prod(5,6)
            call gpcoul(s,q12,q22,coul)
*           colmbf=1.d0+coul
            colmbf=sqrt(1.d0+coul)
          else
            colmbf=1.d0
          end if
*
* amplitude calculation
*
      iprint = 0

      do 1000 nthprc = 1 , MPROC
         if( jselpr(nthprc).eq.1) then    
             ithprc = nthprc - 1
             call usrprm(ithprc,iprint)
             call setmas(ithprc,iprint)
             call procdb(ithprc)
             call amparm
             ncgrph = ngd(ithprc)
*-------------------------------------------
             if( nthprc .eq. 1 ) then
                  call ampt1
             else if( nthprc .eq. 2 ) then
                  call ampt2
             else if( nthprc .eq. 3 ) then
                  call ampt3
             else if( nthprc .eq. 4 ) then
                  call ampt4
             else if( nthprc .eq. 5 ) then
                  call ampt5
             else if( nthprc .eq. 6 ) then
                  call ampt6
             else if( nthprc .eq. 7 ) then
                  call ampt7
             else if( nthprc .eq. 8 ) then
                  call ampt8
             else if( nthprc .eq. 9 ) then
                  call ampt9
             else if( nthprc .eq. 10 ) then
                  call ampt10
             else if( nthprc .eq. 11 ) then
                  call ampt11
             else if( nthprc .eq. 12 ) then
                  call ampt12
             else if( nthprc .eq. 13 ) then
                  call ampt13
             else if( nthprc .eq. 14 ) then
                  call ampt14
             else if( nthprc .eq. 15 ) then
                  call ampt15
             else if( nthprc .eq. 16 ) then
                  call ampt16
             else if( nthprc .eq. 17 ) then
                  call ampt17
             else if( nthprc .eq. 18 ) then
                  call ampt18
             else if( nthprc .eq. 19 ) then
                  call ampt19
             else if( nthprc .eq. 20 ) then
                  call ampt20
             else if( nthprc .eq. 21 ) then
                  call ampt21
             else if( nthprc .eq. 22 ) then
                  call ampt22
             else if( nthprc .eq. 23 ) then
                  call ampt23
             else if( nthprc .eq. 24 ) then
                  call ampt24
             else if( nthprc .eq. 25 ) then
                  call ampt25
             else if( nthprc .eq. 26 ) then
                  call ampt26
             else if( nthprc .eq. 27 ) then
                  call ampt27
             else if( nthprc .eq. 28 ) then
                  call ampt28
             else if( nthprc .eq. 29 ) then
                  call ampt29
             else if( nthprc .eq. 30 ) then
                  call ampt30
             else if( nthprc .eq. 31 ) then
                  call ampt31
             else if( nthprc .eq. 32 ) then
                  call ampt32
             else if( nthprc .eq. 33 ) then
                  call ampt33
             else if( nthprc .eq. 34 ) then
                  call ampt34
             else if( nthprc .eq. 35 ) then
                  call ampt35
             else if( nthprc .eq. 36 ) then
                  call ampt36
             else if( nthprc .eq. 37 ) then
                  call ampt37
             else if( nthprc .eq. 38 ) then
                  call ampt38
             else if( nthprc .eq. 39 ) then
                  call ampt39
             else if( nthprc .eq. 40 ) then
                  call ampt40
             else if( nthprc .eq. 41 ) then
                  call ampt41
             else if( nthprc .eq. 42 ) then
                  call ampt42
             else if( nthprc .eq. 43 ) then
                  call ampt43
             else if( nthprc .eq. 44 ) then
                  call ampt44
             else if( nthprc .eq. 45 ) then
                  call ampt45
             else if( nthprc .eq. 46 ) then
                  call ampt46
             else if( nthprc .eq. 47 ) then
                  call ampt47
             else if( nthprc .eq. 48 ) then
                  call ampt48
             else if( nthprc .eq. 49 ) then
                  call ampt49
             else if( nthprc .eq. 50 ) then
                  call ampt50
             else if( nthprc .eq. 51 ) then
                  call ampt51
             else if( nthprc .eq. 52 ) then
                  call ampt52
             else if( nthprc .eq. 53 ) then
                  call ampt53
             else if( nthprc .eq. 54 ) then
                  call ampt54
             else if( nthprc .eq. 55 ) then
                  call ampt55
             else if( nthprc .eq. 56 ) then
                  call ampt56
             else if( nthprc .eq. 57 ) then
                  call ampt57
             else if( nthprc .eq. 58 ) then
                  call ampt58
             else if( nthprc .eq. 59 ) then
                  call ampt59
             else if( nthprc .eq. 60 ) then
                  call ampt60
             else if( nthprc .eq. 61 ) then
                  call ampt61
             else if( nthprc .eq. 62 ) then
                  call ampt62
             else if( nthprc .eq. 63 ) then
                  call ampt63
             else if( nthprc .eq. 64 ) then
                  call ampt64
             else if( nthprc .eq. 65 ) then
                  call ampt65
             else if( nthprc .eq. 66 ) then
                  call ampt66
             else if( nthprc .eq. 67 ) then
                  call ampt67
             else if( nthprc .eq. 68 ) then
                  call ampt68
             else if( nthprc .eq. 69 ) then
                  call ampt69
             else if( nthprc .eq. 70 ) then
                  call ampt70
             else if( nthprc .eq. 71 ) then
                  call ampt71
             else if( nthprc .eq. 72 ) then
                  call ampt72
             else if( nthprc .eq. 73 ) then
                  call ampt73
             else if( nthprc .eq. 74 ) then
                  call ampt74
             else if( nthprc .eq. 75 ) then
                  call ampt75
             else if( nthprc .eq. 76 ) then
                  call ampt76
             endif
*-------------------------------------------
             call ampsum(ansm)
             amp2(nthprc)=ansm*stfac(nthprc)
*            print *,'amsm   = ',nthprc,ansm
         endif
*
 1000 continue

      return
      end
* File amparm.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
* mod. 96.06.05 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
************************************************************************
      subroutine amparm
      implicit real*8(a-h,o-z)

      include 'incl1.f'
      include 'inclk.f'
      common /mixagl/sth2,gf
*-----------------------------------------------------------------------
**    alpha     =   1.0d0/137.0359895d0
*
      complex*16 zr, zi
      save       zr, zi
      zr = dcmplx(1.0d0, 0.0d0)
      zi = dcmplx(0.0d0, 1.0d0)
*-----------------------------------------------------------------------
*     call sminit(   1,   1)

* coupling constants
*-----------------------------------------------------------------------
      zero      =   0.0d0
      one       =   1.0d0
      two       =   2.0d0
      three     =   3.0d0
      four      =   4.0d0
*
*  qed coupling constant
*
      r2        =   sqrt(two)
      r2i       =   one/r2
      ge2       =   four*pi*alpha
      ge        =   sqrt(ge2)
      ge2h      =   ge2/two
      cqed      =   ge
*
*  electric charges
*
      ql        = - one
      qu        =   two/three
      qd        = - one/three
*
*  electro-weak coupling constants
*
*   gauge coupling constants
*
      amw2      =   amw**2
      amh2      =   amh**2
*
*     gcos      =   amw/amz

*-----------------------------------------------------------------------
* amx  : used in propagator
* bmx  : used to determine the values of coupling constants


      if(jschem.eq.0) then
*       input : amw, amz

          bmw  = amw
          bmz  = amz

          bmw2 = bmw*bmw
          bmz2 = bmz*bmz

          cth2  = bmw2/bmz2
          sth2  = 1.d0 - cth2
      else
*       input : gf, amwb

          gf   = 1.16639d-5
          sth2 = pi*alpha*r2i/gf/amw**2

ccc    check : calculate sth2 and gf from amwb2 and amzb2
ccc
ccc       sth2 = 1.0d0 - amw**2/amz**2
ccc       gf   = pi*alpha*r2i/sth2/amw**2

          cth2 = 1.0d0 - sth2
          bmw2 = r2i*ge2/4.0d0/(gf*sth2)
          bmz2 = bmw2/cth2
          bmw  = sqrt(bmw2)
          bmz  = sqrt(bmz2)

          if(jschem.eq.99) then
*           recover gauge invariance
              amw  = bmw
              amz  = bmz
          endif
      endif

      bmzw2 = bmz2 - bmw2
      bmzw  = sqrt(bmz2)
      rmz   = bmz/bmw
      gw    = bmw/bmzw
      gz    = bmz/bmzw
      gzw   = bmz/bmw
      gwz   = bmw/bmz
*----
      gcos      =   gwz
*----

*     write(*,*) 'jschem = ', jschem
*     write(*,*) 'sth2   = ', 1.0d0/gz**2
*     write(*,*) 'amw   = ', amw, '   bmw = ', bmw
*     write(*,*) 'amz   = ', amz, '   bmz = ', bmz


      gcos2     =   gcos**2
      gsin      =   sqrt(one-gcos2)
      gtan      =   gsin/gcos
      gcosi     =   one/gcos
      gcos2i    =   one/gcos2
      gcosd     =   two*gcos2 - one
*
      gg        =   ge/gsin
      gg2       =   gg**2
      ggh       =   gg/two
      gg2h      =   gg2/two
*
*   sss and ssss
*     gs        =   gg *amh2/(two *amw )
*     gs2       =   gg2*amh2/(four*amw2)
      gs        =   gg *amh2/(two *bmw )
      gs2       =   gg2*amh2/(four*bmw2)
*
*   ffw
      gwfl      =   gg*r2i
*
*   ffa
      gal       =   ql*ge
      gau       =   qu*ge
      gad       =   qd*ge
*
*   ffz
      gza       =   ggh*gcosi
      gzc       =   gg*gtan*gsin
*
      gznl      =   gza
      gzll      = - ql*gzc - gza
      gzlr      = - ql*gzc
      gzul      = - qu*gzc + gza
      gzur      = - qu*gzc
      gzdl      = - qd*gzc - gza
      gzdr      = - qd*gzc
*
*   sff
      gx        =   gg*r2i/amw
      g3        =   ggh/amw
* qcd coupling constants
*
      cqcd      =   sqrt(4.0d0*pi*alphas)
* coupling constants

        czww    = zr*( gg*gcos)
        caww    = zr*( ge)
        cggg    = zr*( cqcd)
       cwwaa    = zr*( ge2)
       cwwza    = zr*( ge*gg*gcos)
       cwwzz    = zr*( gg2*gcos2)
       cwwww    = zr*(-gg2)
       cgggg    = zr*( cqcd**2)
        cwhm    = zi*( ggh)
        cwhp    = zi*( ggh)
        cwym    = zr*( ggh)
        cwyp    = zr*(-ggh)
        czpm    = zr*(-ggh*gcosd*gcosi)
        capm    = zr*(-ge)
        czhy    = zi*( ggh*gcosi)
        chww    = zr*( gg*amw)
        chzz    = zr*( gg*amz*gcosi)
        cwzm    = zi*( ge*amz*gsin)
        cwam    = zi*(-ge*amw)
        cwzp    = zi*(-ge*amz*gsin)
        cwap    = zi*( ge*amw)
       cwwhh    = zr*( gg2h)
       czzhh    = zr*( gg2h*gcos2i)
       cwzhm    = zi*( ge2h*gcosi)
       cwzhp    = zi*(-ge2h*gcosi)
       cwahm    = zi*(-ge*ggh)
       cwahp    = zi*( ge*ggh)
       cwwyy    = zr*( gg2h)
       czzyy    = zr*( gg2h*gcos2i)
       cwzym    = zr*( ge2h*gcosi)
       cwzyp    = zr*( ge2h*gcosi)
       cwaym    = zr*(-ge*ggh)
       cwayp    = zr*(-ge*ggh)
       cwwpm    = zr*( gg2h)
       czzpm    = zr*( gg2h*(gcosd*gcosi)**2)
       caapm    = zr*( two*ge2)
       czapm    = zr*( ge*gg*gcosd*gcosi)
        chyy    = zr*(-gs)
        chhh    = zr*(-three*gs)
       chhhh    = zr*(-three*gs2)
       cyyyy    = zr*(-three*gs2)
       cpmyy    = zr*(-gs2)
       chhpm    = zr*(- gs2)
       chhyy    = zr*(-gs2)
       cpmpm    = zr*(-two*gs2)
        cwne(1) = zr*( gwfl)
        cwne(2) = zr*0
        cwnm(1) = zr*( gwfl)
        cwnm(2) = zr*0
        cwnt(1) = zr*( gwfl)
        cwnt(2) = zr*0
        cwel(1) = zr*( gwfl)
        cwel(2) = zr*0
        cwmu(1) = zr*( gwfl)
        cwmu(2) = zr*0
        cwta(1) = zr*( gwfl)
        cwta(2) = zr*0
        cwuq(1) = zr*( gwfl)
        cwuq(2) = zr*0
        cwcq(1) = zr*( gwfl)
        cwcq(2) = zr*0
        cwtq(1) = zr*( gwfl)
        cwtq(2) = zr*0
        cwdq(1) = zr*( gwfl)
        cwdq(2) = zr*0
        cwsq(1) = zr*( gwfl)
        cwsq(2) = zr*0
        cwbq(1) = zr*( gwfl)
        cwbq(2) = zr*0
        cael(1) = zr*( gal)
        cael(2) = zr*( gal)
        camu(1) = zr*( gal)
        camu(2) = zr*( gal)
        cata(1) = zr*( gal)
        cata(2) = zr*( gal)
        cauq(1) = zr*( gau)
        cauq(2) = zr*( gau)
        cacq(1) = zr*( gau)
        cacq(2) = zr*( gau)
        catq(1) = zr*(gau)
        catq(2) = zr*(gau)
        cadq(1) = zr*( gad)
        cadq(2) = zr*( gad)
        casq(1) = zr*( gad)
        casq(2) = zr*( gad)
        cabq(1) = zr*( gad)
        cabq(2) = zr*( gad)
        czne(1) = zr*( gznl)
        czne(2) = zr*0
        cznm(1) = zr*( gznl)
        cznm(2) = zr*0
        cznt(1) = zr*( gznl)
        cznt(2) = zr*0
        czel(1) = zr*( gzll)
        czel(2) = zr*( gzlr)
        czmu(1) = zr*( gzll)
        czmu(2) = zr*( gzlr)
        czta(1) = zr*( gzll)
        czta(2) = zr*( gzlr)
        czuq(1) = zr*( gzul)
        czuq(2) = zr*( gzur)
        czcq(1) = zr*( gzul)
        czcq(2) = zr*( gzur)
        cztq(1) = zr*( gzul)
        cztq(2) = zr*( gzur)
        czdq(1) = zr*( gzdl)
        czdq(2) = zr*( gzdr)
        czsq(1) = zr*( gzdl)
        czsq(2) = zr*( gzdr)
        czbq(1) = zr*( gzdl)
        czbq(2) = zr*( gzdr)
        cguq(1) = zr*( cqcd)
        cguq(2) = zr*( cqcd)
        cgdq(1) = zr*( cqcd)
        cgdq(2) = zr*( cqcd)
        cgcq(1) = zr*( cqcd)
        cgcq(2) = zr*( cqcd)
        cgsq(1) = zr*( cqcd)
        cgsq(2) = zr*( cqcd)
        cgbq(1) = zr*( cqcd)
        cgbq(2) = zr*( cqcd)
        cgtq(1) = zr*( cqcd)
        cgtq(2) = zr*( cqcd)
        cmmu(1) = zi*( ammu*gx)
        cmmu(2) = zi*0
        cmta(1) = zi*( amta*gx)
        cmta(2) = zi*0
        cpmu(1) = zi*0
        cpmu(2) = zi*(-ammu*gx)
        cpta(1) = zi*0
        cpta(2) = zi*(-amta*gx)
        cmuq(1) = zi*( amdq*gx)
        cmuq(2) = zi*(-amuq*gx)
        cmcq(1) = zi*( amsq*gx)
        cmcq(2) = zi*(-amcq*gx)
        cmtq(1) = zi*( ambq*gx)
        cmtq(2) = zi*(-amtq*gx)
        cpdq(1) = zi*( amuq*gx)
        cpdq(2) = zi*(-amdq*gx)
        cpsq(1) = zi*( amcq*gx)
        cpsq(2) = zi*(-amsq*gx)
        cpbq(1) = zi*( amtq*gx)
        cpbq(2) = zi*(-ambq*gx)
        chmu(1) = zr*(-ammu*g3)
        chmu(2) = zr*(-ammu*g3)
        chta(1) = zr*(-amta*g3)
        chta(2) = zr*(-amta*g3)
        chuq(1) = zr*(-amuq*g3)
        chuq(2) = zr*(-amuq*g3)
        chcq(1) = zr*(-amcq*g3)
        chcq(2) = zr*(-amcq*g3)
        chtq(1) = zr*(-amtq*g3)
        chtq(2) = zr*(-amtq*g3)
        chdq(1) = zr*(-amdq*g3)
        chdq(2) = zr*(-amdq*g3)
        chsq(1) = zr*(-amsq*g3)
        chsq(2) = zr*(-amsq*g3)
        chbq(1) = zr*(-ambq*g3)
        chbq(2) = zr*(-ambq*g3)
        cymu(1) = zi*(-( ammu*g3))
        cymu(2) = zi*( ammu*g3)
        cyta(1) = zi*(-( amta*g3))
        cyta(2) = zi*( amta*g3)
        cyuq(1) = zi*(-(-amuq*g3))
        cyuq(2) = zi*(-amuq*g3)
        cycq(1) = zi*(-(-amcq*g3))
        cycq(2) = zi*(-amcq*g3)
        cytq(1) = zi*(-(-amtq*g3))
        cytq(2) = zi*(-amtq*g3)
        cydq(1) = zi*(-( amdq*g3))
        cydq(2) = zi*( amdq*g3)
        cysq(1) = zi*(-( amsq*g3))
        cysq(2) = zi*( amsq*g3)
        cybq(1) = zi*(-( ambq*g3))
        cybq(2) = zi*( ambq*g3)
       cwczp    = zr*(-gg*gcos)
       cwcmz    = zr*( gg*gcos)
       cwcap    = zr*(-ge)
       cwcma    = zr*( ge)
       cwczm    = zr*( gg*gcos)
       cwcpz    = zr*(-gg*gcos)
       cwcam    = zr*( ge)
       cwcpa    = zr*(-ge)
       czcmm    = zr*(-gg*gcos)
       czcpp    = zr*( gg*gcos)
       cacmm    = zr*(-ge)
       cacpp    = zr*( ge)
       cgcgg    = zr*( cqcd)
       cpczp    = zi*(-ggh*gcosd*amz)
       cpcap    = zi*(-ge*amw)
       cpcmz    = zi*( ggh*amz)
       cmczm    = zi*( ggh*gcosd*amz)
       cmcam    = zi*( ge*amw)
       cmcpz    = zi*(-ggh*amz)
       cycmm    = zi*(-ggh*amw)
       cycpp    = zi*( ggh*amw)
       chcmm    = zr*(-ggh*amw)
       chcpp    = zr*(-ggh*amw)
       chczz    = zr*(-ggh*gcosi*amz)

      return
      end
      subroutine gr2lnd
      implicit real*8(a-h,o-z)

      include 'inclk.f'
      real*4  paru,parj
      real*4  pmas,parf,vckm
      common/ludat1/mstu(200),paru(200),mstj(200),parj(200)
      common/ludat2/kchg(500,3),pmas(500,4),parf(2000),vckm(4,4)
*     character*18 cmass,calpha

*-----------------------------------------------------------------------
*     GRACE will generate the direct statment from model file.
*     call lugive('pmas(lucomp(24,1)= 70.0d0');
*-----------------------------------------------------------------------
*     cmass(19:20) = 'd0'

*   Mass
*     write(cmass,'(e18.10)') amw
*     call lugive('pmas(24,1)='//cmass)
*     write(cmass,'(e18.10)') amz
*     call lugive('pmas(23,1)='//cmass)
*     write(cmass,'(e18.10)') ama
*     call lugive('pmas(22,1)='//cmass)

*     write(cmass,'(e18.10)') amg
*     call lugive('pmas(21,1)='//cmass)

*     write(cmass,'(e18.10)') amh
*     call lugive('pmas(25,1)='//cmass)

*     write(cmass,'(e18.10)') amne
*     call lugive('pmas(12,1)='//cmass)
*     write(cmass,'(e18.10)') amnm
*     call lugive('pmas(14,1)='//cmass)
*     write(cmass,'(e18.10)') amnt
*     call lugive('pmas(16,1)='//cmass)

*     write(cmass,'(e18.10)') amel
*     call lugive('pmas(11,1)='//cmass)
*     write(cmass,'(e18.10)') ammu
*     call lugive('pmas(13,1)='//cmass)
*     write(cmass,'(e18.10)') amta
*     call lugive('pmas(15,1)='//cmass)

*     write(cmass,'(e18.10)') amuq
*     call lugive('pmas( 2,1)='//cmass)
*     write(cmass,'(e18.10)') amcq
*     call lugive('pmas( 4,1)='//cmass)
*     write(cmass,'(e18.10)') amtq
*     call lugive('pmas( 6,1)='//cmass)

*     write(cmass,'(e18.10)') amdq
*     call lugive('pmas( 1,1)='//cmass)
*     write(cmass,'(e18.10)') amsq
*     call lugive('pmas( 3,1)='//cmass)
*     write(cmass,'(e18.10)') ambq
*     call lugive('pmas( 5,1)='//cmass)

*   Width

*     write(cmass,'(e18.10)') agw
*     call lugive('pmas(24,2)='//cmass)
*     write(cmass,'(e18.10)') agz
*     call lugive('pmas(23,2)='//cmass)
**    write(cmass,'(e18.10)') aga
**    call lugive('pmas(22,2)='//cmass)

**    write(cmass,'(e18.10)') agg
**    call lugive('pmas(21,2)='//cmass)

*     write(cmass,'(e18.10)') agh
*     call lugive('pmas(25,2)='//cmass)

**    write(cmass,'(e18.10)') agne
**    call lugive('pmas(12,2)='//cmass)
**    write(cmass,'(e18.10)') agnm
**    call lugive('pmas(14,2)='//cmass)
**    write(cmass,'(e18.10)') agnt
**    call lugive('pmas(16,2)='//cmass)

**    write(cmass,'(e18.10)') agel
**    call lugive('pmas(11,2)='//cmass)
**    write(cmass,'(e18.10)') agmu
**    call lugive('pmas(13,2)='//cmass)
**    write(cmass,'(e18.10)') agta
**    call lugive('pmas(15,2)='//cmass)

**    write(cmass,'(e18.10)') aguq
**    call lugive('pmas( 2,2)='//cmass)
*     write(cmass,'(e18.10)') agcq
*     call lugive('pmas( 4,2)='//cmass)
*     write(cmass,'(e18.10)') agtq
*     call lugive('pmas( 6,2)='//cmass)

**    write(cmass,'(e18.10)') agdq
**    call lugive('pmas( 1,2)='//cmass)
*     write(cmass,'(e18.10)') agsq
*     call lugive('pmas( 3,2)='//cmass)
*     write(cmass,'(e18.10)') agbq
*     call lugive('pmas( 5,2)='//cmass)
*  Alpha
*     calpha(19:20) = 'd0'
*     write(calpha,'(e18.10)') alpha
*     call lugive('paru(101)='//calpha)

*-----------------------------------------------------------------------
*     PUT COMMON BLOCK 
*-----------------------------------------------------------------------
*
*   Mass & Width
*
*     <Gauge Boson>
*
*         W+
          pmas(24,1) = real(amw)
          pmas(24,2) = real(agw)
*         Z0
          pmas(23,1) = real(amz)
          pmas(23,2) = real(agz)
*         A
          pmas(22,1) = real(ama)
*         g
          pmas(21,1) = real(amg)
*         H
          pmas(25,1) = real(amh)
          pmas(25,2) = real(agh)
*
*     <Quark>
*
          pmas(2,1) = real(amuq)
          pmas(4,1) = real(amcq)
          pmas(4,2) = real(agcq)
          pmas(6,1) = real(amtq)
          pmas(6,2) = real(agtq)
          pmas(1,1) = real(amdq)
          pmas(3,1) = real(amsq)
          pmas(3,2) = real(agsq)
          pmas(5,1) = real(ambq)
          pmas(5,2) = real(agbq)
*
*     <Lepton>
*
          pmas(18,1) = real(amy)
          pmas(18,2) = real(agy)
          pmas(12,1) = real(amne)
          pmas(14,1) = real(amnm)
          pmas(16,1) = real(amnt)
          pmas(11,1) = real(amel)
          pmas(13,1) = real(ammu)
          pmas(15,1) = real(amta)
*
*  Alpha
*
      paru(101) = real(alpha)

      return
      end 
C 97/06/17 TI: for MPI
C 97/06/16 TI: version up grc4f v2.1 (37)
C 97/05/06 TI: version up 34->35
c 97/04/24 TI: grc4fm (insert page clear char.)
c     last update:97/01/15 TI: add kimtyp message in grc4fm
*--------------------------------------------- Last Update -- 96/08/26 -
      subroutine grc4fm(isrc)
*-----------------------------------------------------------------------
*     output message for grc4f
*-----------------------------------------------------------------------
      implicit real*8 (a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'
*-----------------------------------------------------------------------
      common/chcntl/jwidth
      common/mixagl/sth2,gf
*-----------------------------------------------------------------------
*     common /kmcnt2/kimtyp,jit1,jit2,jncall,jkclmb
      common /kinem1/s,w,fact
*     common /cut001/coscut(2,4),engyct(2,4),amasct(2,6),aresns(2,4)
*    .,opncut,swapm2
*- QEDPS ---------------------------------------------------------------
      common/cutqp /ips,nobpho,cospho,ephoct,cosopn
*-----------------------------------------------------------------------
      integer invm(2,6)
      character*3  cflag(0:1),crun(0:1)
      character*8  cschm(0:1)
      character*20 ckinm(6)
      character*6  cclmb(0:2)
      data invm/3,4,5,6,3,5,4,6,3,6,4,5/
      data cflag /'YES','NO '/
      data crun  /'RUN','FIX'/
      data cschm /'ON-SHELL','G_mu    '/
      data ckinm /'General Purpose     ','Two-photon          ',
     &            'Identical particle  ','Mixed resonance     ',
     &            'eceCeneN oriented   ','Two-photon (eeeeee) '/
      data cclmb  /'NO    ','Bardin','Fadin '/
      character*32 line1
      character*1  newp
      common/ninfo/ nodeid, numnod

      if( nodeid .ne. 0 ) return
      newp = char(14)
      write(isrc,99) newp
   99 format(a)
*     stop
      WRITE(ISRC,100)
  100 FORMAT(
     . '*************************************************************' 
     . '***********'/
     . '*--------------------------------------------------444-------' 
     . '-lqlqlqlq-*'/
     . '*------------------------------------------------44444-------' 
     . 'lql----ql-*'/
     . '*----######---------##--##------#####----------444--44----lql' 
     . 'qlqlqlq---*'/
     . '*-####---######--##########--####---###------444----44-------' 
     . 'lql-------*')

      WRITE(ISRC,101)
  101 FORMAT(
     . '*-###------##------###------###------##----44444444444444----' 
     . 'qlq-------*'/
     . '*--##########------###------###------------44444444444444----' 
     . 'lql-------*'/
     . '*-####-------------###------######---###------------44-------' 
     . 'qlq-------*'/
     . '*-#############--#######------########--------------44----qlq' 
     . 'lqlqlq----*'/
     . '*-##--------###----------------------------------------------' 
     . '----------*')

      WRITE(ISRC,102)
  102 FORMAT(
     . '*-############-----------------------------------------------' 
     . '----------*'/
     . '*-------------------------------------------------- GRACE INS' 
     . 'IDE ------*'/
     . '*************************************************************' 
     . '***********'/
     . '*                         Version 2.1 (37)                   ',
     . '          *'/
     . '*                  Last date of change: 1997 Nov 21          ',
     . '          *')

      WRITE(ISRC,103)
  103 FORMAT(
     . '*************************************************************' 
     . '***********'/
     . '*              Copyright  Minami-Tateya Collaboration        ',
     . '          *'/
     . '*                    E*mail:grc4f@minami.kek.jp              ',
     . '          *'/
     . '*************************************************************' 
     . '***********')

      WRITE(ISRC,104)
  104 FORMAT(
     . '*************************************************************' 
     . '***********'/
     . '*   J.Fujimoto, et.al. Comput. Phys. Commun. 100 (1997) 128  ',
     . '          *'/
     . '*************************************************************' 
     . '***********')

      if( jqcdcr .eq. 0 )  then
          fqcdcr = 1.0d0
      else
          fqcdcr = 1.d0 + 2.0d0*alphas/(3.0d0*pi)
      endif
      gamw = 9.0d0/(6.0d0*sqrt(2.0d0)*pi)*gf*amw**3
      gamw = gamw*fqcdcr

      WRITE(ISRC,105) (kmprtc(k)(1:kmprtl(k)),k=3,6),ckinm(kimtyp),
     .                 w,cflag(1-jcanon),
     .                 cschm(jschem),sth2
  105 FORMAT(
     . '*   Process      : e+e- --> (3)',a,' (4)',a,' (5)',a,' (6)',a/
     . '*                                                              '
     . '        *'/
     . '*   Kinematics Type:   ',a20,'                    ',
     . '        *'/
     . '*   Energy:         ',f9.3,'(GeV)                             '
     . '        *'/
     . '*                                                              '
     . '        *'/
     . '*   Canonical CUT:       ',a,'                                 '
     . '          *'/
     . '*   Scheme       :       ',a,'                            ',
     . '          *'/
     . '*   sin(the_w)**2:       ',f8.6,'                            ',
     . '          *')

      if( jschem .eq. 1 ) WRITE(ISRC,1053) gamw

 1053 FORMAT(
     . '*   (Recommended Total W-boson width (See.Yellow Report vol.1 p'
     . '105. )  *'/
     . '*   (                    ',f7.5,'                            ',
     . '        )  *')

      WRITE(ISRC,1052) 
     .                 amw,agw,amz,agz,
     .                 amuq,amdq,amcq,amsq,amtq,ambq

 1052 FORMAT(
     . '*   Mass (Width)                                               '
     . '        *'/
     . '*         W-boson: ',f7.3,'(',f7.5,')  ',
     .           'Z-boson: ',f7.3,'(',f7.5,')         *'/
     . '*         u-quark: ',f7.3,'           d-quark:',f7.3,
     . '                   *'/
     . '*         c-quark: ',f7.3,'           s-quark:',f7.3,
     . '                   *'/
     . '*         t-quark: ',f7.3,'           b-quark:',f7.3,
     . '                   *')

      WRITE(ISRC,1055) amel,ammu,amta
 1055 FORMAT(
     . '*        electron:',f13.8,
     . '                                        *'/
     . '*            muon:',f10.5,
     . '                                           *'/
     . '*             tau:',f10.5,
     . '                                           *')
      WRITE(ISRC,1051) 
     .                 1.d0/alpha,alphas
 1051 FORMAT(
     . '*                                                              '
     . '        *'/
     . '*         alpha  :  1/',f7.3,
     . '                                          *'/
     . '*         alpha_s:',f9.5,
     . '                                            *'/
     . '*                                                              '
     . '        *')

      WRITE(ISRC,106)
  106 FORMAT(
     . '*   Experimental Cuts                                          '
     . '        *'/
     . '*        Angle Cuts                                            '
     . '        *')
      do 1062 j = 1 , 4
      WRITE(ISRC,1061) j+2, (coscut(i,j),i=1,2)
 1061 FORMAT(
     . '*             Particle ',i1,3x,f12.6,'  ---> ',f12.6,
     . '             *')
 1062 continue

      WRITE(ISRC,1071) opncut
 1071 FORMAT(
     . '*        Opening angle between two charged leptons,            '
     . '        *'/
     . '*                              charged lepton and quark        '
     . '        *'/
     . '*                 ',f12.6,
     . '                                         *')

      WRITE(ISRC,1063)
 1063 FORMAT(
     . '*        Energy CUT                                            '
     . '        *')
      do 1065 j = 1 , 4
      WRITE(ISRC,1064) j+2, (engyct(i,j),i=1,2)
 1064 FORMAT(
     . '*             Particle ',i1,3x,f12.6,'  ---> ',f12.6,
     . '             *')
 1065 continue

      WRITE(ISRC,1066)
 1066 FORMAT(
     . '*        Invariant mass CUT                                    '
     . '        *')
      do 1068 j = 1 , 6
      WRITE(ISRC,1067) (invm(i,j),i=1,2), (amasct(i,j),i=1,2)
 1067 FORMAT(
     . '*             Inv. Mass ',i1,'-',i1,f12.6,'  ---> ',f12.6,
     . '             *')
 1068 continue

*     print *,' jqedps = ',jqedps
*     print *,' isr    = ',isr
*     print *,' ips    = ',ips

      line1 = 'TREE'
      if( jqedps .eq. 0 ) then
          if( isr .eq. 1 ) then
              line1(5:14)  = ' + SF(ISR)'
          else if( isr .eq. 0 ) then
          else 
              stop
          endif
      else if( ips .eq. 1 ) then
          line1(5:17)  = ' + QEDPS(ISR)'
      else if( ips .eq. 2 ) then
          line1(5:22)  = ' + QEDPS(ISR+FSR)'
      else 
          stop
      endif

      WRITE(ISRC,107) line1,
*    .  cflag(1-jano3v),
     .  ang1a,ang1z,
     .  1.0d0-andka,1.0d0-andkz,anlma, anlmz
  107 FORMAT(
     . '*                                                              '
     . '        *'/
     . '*   OPTIONS:                                                   '
     . '        *'/
     . '*        Calculation:         ',a,'         *'/
*    . '*        Anomalous Coupling:  ',a,
*    . '                                      *'/
     . '*        Anomalous Coupling:  ',
     . '                                         *'/
     . '*             G1_gamma     :',f6.3,
     . ' G1_z         :',f6.3,'                *'/
     . '*             Kappa_gamma  :',f6.3,
     . ' Kappa_z      :',f6.3,'                *'/
     . '*             Lambda_gamma :',f6.3,
     . ' Lambda_z     :',f6.3,'                *')
      WRITE(ISRC,1072)
     .  cclmb(jcolmb),cflag(1-jqcdcr),cflag(1-jgluon)
     .  ,crun(jwidth)
*    .  cflag(1-jhadrn)
 1072 FORMAT(
     . '*        Coulomb Correction:  ',a,
     . '                                   *'/
     . '*        QCD Correction:      ',a,
     . '                                      *'/
     . '*        Gluon graph:         ',a,
     . ' (only for hadronic process)          *'/
     . '*        Width      :         ',a,
     . '                                      *'/
*    . '*        JETSET interface:    ',a,
*    . ' (only for SPRING)                    *'/
     . '*************************************************************' 
     . '***********')

      return
      end
* File grcbs.f
************************************************************************
* subroutine for BASES 5.1
      subroutine grcbs(iopt,ithprc)
      implicit real*8(a-h,o-z)

      include 'incl1.f'
      include 'inclk.f'

      include 'inclan.f'

      common / knmflg / knmgvs, knmhst, knmsph, knmisr
      external func

*     parameter ( mhsize = 100000 )
*     common /pawc/ memory(mhsize)
************************************************************************
*               DO NOT CHANGE the following parameters
      knmgvs = 1
      knmhst = 1
      knmsph = 0
      knmisr = 0
************************************************************************
*               initialization of HBOOK
*         call hlimit( mhsize )
*         call htitle('Histograms generated by BASES')
************************************************************************
*               initialization of BASES/SPRING 5.1
************************************************************************
*=======================================================================
*          initialization of bases by calling bsinit
*=======================================================================
*         -------------
           call bsinit
*         -------------
*=======================================================================
*      initialization of parameters
*          for kinematics and matrix elements
*      initialization of histograms
*=======================================================================
*         ------------------------------
           call userin( lubsrl , ithprc)
*         ------------------------------
*         ------------------------------
           call drnset( jseed )
*         ------------------------------
************************************************************************
*              numerical integration by BASES 5.1
************************************************************************

      call bases( func, estim, sigma, ctime, it1, it2 )

*     print *,'iopt,sigma',iopt,sigma
      xscton(iopt) = estim
      xscter(iopt) = sigma

      if( lubsrl .ne. 0 ) then
          call bsinfo( lubsrl )
          call bhplot( lubsrl )
      endif

************************************************************************
*             event generation by SPRING 5.1
************************************************************************
*=======================================================================
*     save the probability information to the file
*=======================================================================

*     lun = 23
*     open(lun,file='bases.data',status='unknown',form='unformatted')

      if( lubsdt .ne. 0 ) then
          call bswrit( lubsdt )
      endif
*     close ( lun )

*=======================================================================
*     save the contents of Histograms into Paw buffer
*=======================================================================
*     call bshbok( 0 )
*     call hrput( 0, 'bases.hbook','N')
      return
      end
*970626:YK:mod the shower
*970509:TI:mod the origin of photon FOR ISR
*970506:TI:mod Charge conjugate for ISR
*970419:TI:del /common/KMCNTL
* File sp2lnd.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
*      for llll,llqq,qqqq 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      subroutine sp2lnd
*  Inteface of SPRING to JETSET.
*  1996.03.13 YK: put initial e+e- information.
      implicit real*8 (a-h,o-z)
*     include 'incpar.f'
      include 'incl1.f'
      include 'inclk.f'
      dimension ijoin(2)
      integer jp(2)
      real*4 xp(2,5),xbeam,x
      real*4  p,v
      common/lujets/n,k(4000,5),p(4000,5),v(4000,5)
      integer lect
      common/helicity/lect(4000)

      common /sp4vec/ vec(4,nextn)
      real*4  rqmax
      common /kinem1/ s,w,fact
*-----------------------------------------------------------------------
*     For only QEDPS
*-----------------------------------------------------------------------
      common /qplist/plptn(10,1000),nlptn(10,1000),ntop
*-----------------------------------------------------------------------
      if( jqedps .eq. 0 ) then
* Tree level only no initial state radiation
       kc = 0
       do 10 j = 1 , nextn
        kc  = kc + 1

        p(kc,1) = real(vec(1,j))
        p(kc,2) = real(vec(2,j))
        p(kc,3) = real(vec(3,j))
        p(kc,4) = real(vec(4,j))
        p(kc,5) = real(amass1(j))

        k(kc,1) = 1
        k(kc,2) = kfcode(j)
        k(kc,3) = 1
        k(kc,4) = 0
        k(kc,5) = 0
        if( j .le. 2 ) then
         k(kc,1) = 21
         k(kc,3)=0
        endif

        v(kc,1) = 0.0
        v(kc,2) = 0.0
        v(kc,3) = 0.0
        v(kc,4) = 0.0
        v(kc,5) = 0.0
   10  continue

       n = kc
*-----------------------------------------------------------------------
      else
*-ISRTYPE can be 1 or 2 or 3
       k0 = nextn
* ntop number of QEDPS photons can be 0
       do 11 j = 1 , ntop
        if(nlptn(3,j).ne.0) goto 11
* YK:1996.03.13
*       if(nlptn(1,j).ge.3) then
        if(nlptn(1,j).ge.1) then
         kc     = nlptn(1,j)
         p(kc,1) = real(plptn(4,j))
         p(kc,2) = real(plptn(5,j))
         p(kc,3) = real(plptn(6,j))
         p(kc,4) = real(plptn(7,j))
* YK:1996.03.13
*        p(kc,5) = real(amass1(j))
         p(kc,5) = real(amass1(kc))

         k(kc,1) = 1
         k(kc,2) = kfcode(kc)
         k(kc,3) = 1
         k(kc,4) = 0
         k(kc,5) = 0
c         lect(kc)=999
*           Assume number of initial partile is 2.(Toriaezu)
         if( kc .le. 2 ) then
          k(kc,1) = 21
          k(kc,3) = 0
         endif
         v(kc,1) = 0.0
         v(kc,2) = 0.0
         v(kc,3) = 0.0
         v(kc,4) = 0.0
         v(kc,5) = 0.0
        else
         k0      = k0 + 1
         p(k0,1) = real(plptn(4,j))
         p(k0,2) = real(plptn(5,j))
         p(k0,3) = real(plptn(6,j))
         p(k0,4) = real(plptn(7,j))
         p(k0,5) = 0.0
         k(k0,1) = 1
         k(k0,2) = 22
         k(k0,3) = 1
         k(k0,4) = 0
         k(k0,5) = 0
         v(k0,1) = 0.0
         v(k0,2) = 0.0
         v(k0,3) = 0.0
         v(k0,4) = 0.0
         v(k0,5) = 0.0
         lect(k0)= 999
        endif
   11  continue
       n = k0
      endif

c generate 1 or 2  photon for the isr=1 case
      nisr=0
      if( isr.eq.1) then
         xbeam=sngl(w/2.d0)
         do 1020 i=1,2
            jp(i)=0
            do 1010 ik=1,5
               xp(i,ik)=0.
 1010       continue
            x=xbeam-p(i,4)
*       print *,'xbeam eisr nisr i p(i,4) x ',
*    &             xbeam,eisr,nisr,i,p(i,4),x
            if(x.gt.sngl(eisr)) then
               nisr=nisr+1
               jp(nisr)=i
               xp(i,3)=sign(x,p(i,3))
               xp(i,4)=x
               p(i,1)=0.
               p(i,2)=0.  
               p(i,3)=sign(sqrt(xbeam**2-p(i,5)**2),p(i,3))
               p(i,4)=xbeam  
             endif
 1020     continue
c         do 1030 i=1,20
c            print *,lect(i)
c1030     continue
c         print *,n,nisr

          if(nisr.ne.0) then                          
             do 1050 i=n,3,-1
                l=i+nisr
                lect(l)=lect(i) 
                do 1040 j=1,5
                   k(l,j)=k(i,j)
                   p(l,j)=p(i,j)
                   v(l,j)=v(i,j)
 1040           continue
 1050        continue
             n=n+nisr
             do 1070 i=1,nisr
                do 1060 m=1,5
                   p(2+i,m)=xp(jp(i),m)
                   v(2+i,m)=0.
 1060           continue
                k(2+i,1)=1
                k(2+i,2)=22
                k(2+i,3)=jp(i)
                lect(2+i)=999
 1070        continue
          endif
          j=0
          do 1080 i=3,n
             if( lect(i).ne.999.and.lect(i).ne.-999)then
                 j=j+lect(i)
             endif
 1080     continue
          if(j.ne.-4.and.j.ne.-2.and.j.ne.0.and.j.ne.2.and.j.ne.4)then
             print*,'sp2lnd n,nisr: ',n,nisr
             do 1090 i=1,n
                print *,lect(i)
 1090        continue
          endif
      endif  
*-----------------------------------------------------------------------
c Charge conjugate
*     print *,'<<sp2lnd>>'
*     print *,' chgcjpr ',chgcjpr
      if (chgcjpr.eq.1) then
       do 501 l=3,n
          if( k(l,2) .eq. 22 ) then
              if( k(l,3) .eq. 1 ) then
                  k(l,3) = 2
              else if( k(l,3) .eq. 2 ) then
                  k(l,3) = 1
              endif
          endif
        if(lucomp(-k(l,2)).ne.0) k(l,2)=-k(l,2)
        p(l,1)=-p(l,1)
        p(l,2)=-p(l,2)
        p(l,3)=-p(l,3)
        if(lect(l).ne.999.and.lect(l).ne.-999)lect(l)=-lect(l)
 501   continue
      endif 
*-----------------------------------------------------------------------
*     String Join
*-----------------------------------------------------------------------
      do 20 i = 1, kmcbmx, 2
         if( kmcstr(i,icolst) .ne. 0 ) then
* YK:1996.03.13
* YK         ijoin(1) = kmcstr( i ,icolst) - 2
             ijoin(1) = kmcstr( i ,icolst) + nisr
* YK         ijoin(2) = kmcstr(i+1,icolst) - 2
             ijoin(2) = kmcstr(i+1,icolst) +nisr
*            call lujoin(2,ijoin)
             k(ijoin(1),1) = 3
             if( k(ijoin(1),2) .gt. 0 ) then
                 k(ijoin(1),4) = ijoin(2)*10000
             else
                 k(ijoin(1),5) = ijoin(2)*10000
             endif
             k(ijoin(2),1) = 3
             if( k(ijoin(2),2) .gt. 0 ) then
                 k(ijoin(2),4) = ijoin(1)*10000
             else
                 k(ijoin(2),5) = ijoin(1)*10000
             endif
         endif
   20 continue

********************************************************************
*      'rqmax '  This q-maximum
*has to be the maximum of q-q-bar system, NOT a initial e+e- system.
********************************************************************
c     rqmax = real(w)

      if( jshowr .eq.1 ) then
        do 21 i=1,kmcbmx,2
         if(kmcstr(i,icolst) .ne.0) then
          kk1=kmcstr(i  ,icolst)+nisr
          kk2=kmcstr(i+1,icolst)+nisr
          rqmax=sqrt( (p(kk1,4)+p(kk2,4))**2
     .-               (p(kk1,1)+p(kk2,1))**2
     .-               (p(kk1,2)+p(kk2,2))**2
     .-               (p(kk1,3)+p(kk2,3))**2 )
c         call lushow(kmcstr(i,icolst),kmcstr(i+1,icolst),rqmax)
          call lushow(   kk1          ,   kk2            ,rqmax)
         endif
 21   continue
      endif
      return
      end
*-----------------------------------------------------------------------
      subroutine grcevt(iact,iopt,irtn)
*-----------------------------------------------------------------------
      integer iopt
      include 'inclk.f'
      include 'inclpi.f'
      include 'inclan.f'
      common /grccnt/ istate, inoexe
      data ifirst/-99/
      save ifirst
      data iopold/-99/
      save iopold
      save iop

*     print *,'<< grcevt >> ',ifirst,iact
      if( ifirst .eq. -99 .and. iact .ne. -3 ) then
          call grcerr(2,'  grcevt(-3) should be called')
      endif

      ifirst = -1

      irtn = 0

      if( iact .eq. -3 ) then
*----------------------------
*     Global initialization
*----------------------------
          istate = -3
          inoexe = 0

          call grcpin

          call grcgin
          call grcgni

* process data base
          call prcdbi
* kinematics data base
          call knmdbi

          do 1000 i = 1 , MPROC
             mevent(i) = 0
 1000     continue

      else if( iact .eq. -2 ) then
*----------------------------
*     Process initialization
*----------------------------

          call grcgen(c8data(0))

          istate = -2
      else if( iact .eq. -1 ) then
*----------------------------
*     BASES
*----------------------------
          if( inoexe .ne. 0 ) then
              print *,'NO Execution BASES for ',iopt,'-th process'
              return
          endif
          if( mulprc(0) .eq. 1 ) then
*-----------------------------------------
*             single process (ignore iopt)
*-----------------------------------------
              ith = mulprc(1)
              iop = 1
          else 
*-----------------------------------------
*             multi  processes 
*-----------------------------------------
              if( iopt .gt. mulprc(0) .or. iopt .le. 0 ) then 
                  print *,' Invalid  iopt:grcevt(-1,iopt,ierr)'
                  irtn = 99
                  inoexc = 1
                  return
              endif
              ith = mulprc(iopt)
              iop = iopt
          endif
          print *,'BASES for ',ith,'-th process'
*         ================
          call grcbs(iop,ith)
*         ================
          istate = -1
      else if( iact .eq.  0 ) then
*----------------------------
*     SPRING
*----------------------------
          if( inoexe .ne. 0 ) then
              print *,'NO Execution SPRING for ',iopt,'-th process'
              return
          endif
*         print *,'spring ',iopt,iopold,ith
          if( iopt .ne. iopold )then
              if( mulprc(0) .eq. 1 ) then
*-----------------------------------------------
*             single process (ignore iopt)
*-----------------------------------------------
                  ith = mulprc(1)
                  iop = 1
              else
*-----------------------------------------
*             multi  processes 
*-----------------------------------------
                  if( iopt .gt. mulprc(0) ) then 
                      print *,' Invalid  iopt:grcevt(0,iopt,ierr)'
                      return
                  endif
                  ith = mulprc(iopt)
                  iop = iopt
              endif

              if( istate .eq. 0 ) then
                  print *,' print iact = 0 ',istate,lusprl
                  call spinfo( lusprl )
                  call shplot( lusprl )
              endif

              print *,'SPRING setup for ',ith,'-th process'

              call grcsp0( ith )

              iopold = iopt
          endif
*         print *,'SPRING (real event generation)'
          mevent( iop ) = mevent( iop ) + 1

          call grcsp

          istate = 0
      else if( iact .eq. 1 ) then
*----------------------------
*     Result
*----------------------------
          print *,' print iact = 1 ',istate,lusprl
          if( istate .eq. 0 ) then
              call spinfo( lusprl )
              call shplot( lusprl )
          endif
          istate = 1
      else
          call grcerr(2,'  argument of grcevt is invalid ')
      endif
      return
      end
*-----------------------------------------------------------------------
      subroutine grcerr(iopt,msg)
*-----------------------------------------------------------------------
      character*(*) msg
      common /grccnt/ istate, inoexe
      common/ninfo/ nodeid, numnod
      if( iopt .eq. 1 ) then
          write(6,6001) nodeid,msg
      else if( iopt .eq. 2 ) then
          write(6,6002) nodeid,msg
          inoexe = 1
      else
          write(6,6003)
      endif
      if( iopt .ne. 1 ) stop
      return
 6001 format(' Warning ......(',i4,') ',a)
 6002 format(' Fatal error ..(',i4,') ',a)
 6003 format(' grcerr error (ask grc4f-manager)')
      end
*-----------------------------------------------------------------------
*     parsing for 4-body
*-----------------------------------------------------------------------
      subroutine grcgen( char8 )
      include 'inclgi.f'
      include 'inclan.f'
      character*8 char8
      character*2 ch2

*     print *,'<<grcgen>> input = ',char8
*     call grcgin
*     call grcgni

      do 1000 i = 1 , 4
         ch2 = char8(i*2-1:i*2)
         call grcgsr( ch2 , irptr)
         if( irptr .eq. -1 ) return
         call grcgst( i, irptr )
 1000 continue

*     call grcgsp

      call grcgch

      call grcgpr( char8 )

      do 2000 i = 1 , 76
         mulprc(i) = 0
         ichgcj(i) = 0
 2000 continue
      ic = 0
      do 3000 i = 0 , 76-1
         if( iprclt(i) .eq. 1 ) then
             ic = ic + 1
             mulprc(ic) = i
             ichgcj(ic) = iprc(i,2)
         endif
 3000 continue
      mulprc(0) = ic
      return
      end
*-----------------------------------------------------------------------
*     check input particle code
*-----------------------------------------------------------------------
      subroutine grcgsr( ch2 , irptr)
      character*2 ch2
      integer     irptr
      include 'inclgi.f'
*     print *,'maxnam = ',maxnam,' ',ch2
      do 100 i = 0 , maxnam-1
*        print *,i,' ',name(i)
         if( name(i) .eq. ch2 ) then
             irptr = iptr(i)
             return
         endif
  100 continue
      write(6,6001) ch2
      irptr = -1
      return
 6001 format(' <<grcgsr>> Not found ',a)
      end
*-----------------------------------------------------------------------
*     store .... (this routine is not general one ..)
*-----------------------------------------------------------------------
      subroutine grcgst( ith, irptr)
      common /grcg4f/ ignset(4,0:30)
      include 'inclgi.f'
      ip = irptr
      ignset(ith,0) = idat( ip )
*     print *,'ignset(ith,0)',ignset(ith,0)
      if( ignset(ith,0) .gt. 30 ) stop
      do 1000 i = 1 , ignset(ith,0)
         ip = ip + 1
         ignset(ith,i) = idat( ip )
 1000 continue
      return
      end
*-----------------------------------------------------------------------
*     print for debug
*-----------------------------------------------------------------------
      subroutine grcgsp
      common /grcg4f/ ignset(4,0:30)
      do 1000 ith = 1 , 4
         write(6,6001)  ith, ignset(ith,0),
     &                 (ignset(ith,k),k=1,ignset(ith,0))
 1000 continue
      return
 6001 format(' ',i1,'(',i2,'):',10i4)
      end
*-----------------------------------------------------------------------
*     Initial Clear
*-----------------------------------------------------------------------
      subroutine grcgin
      include 'inclgi.f'
      common /grcg4f/ ignset(4,0:30)
      do 1000 ith = 1 , 4
         ignset(ith,0) = 0
 1000 continue
      do 2000 ith = 0, maxprc-1
         iprclt(ith) = 0
 2000 continue
      return
      end
*-----------------------------------------------------------------------
*     print out
*-----------------------------------------------------------------------
      subroutine grcgpr( chin )
      character*(*) chin
      character*70  ch70
      include 'inclgi.f'
c                    12345678901234567890
      ch70        = ' '
      ch70( 1:20) = ' Input character is '
      ch70(21:30) = '"'//chin//'"'
c                    12345678901234567890
      ch70(31:40) = ' ------>  '
      k = 4
      icnt = 0
      do 1000 i = 0 , maxprc-1
         if( iprclt(i) .eq. 1 ) then
             icnt = icnt + 1
             ch70(k*10+1:k*10+10) = ' '//prcnms(i)//' '
             k = k + 1
             if( k .eq. 7 ) then
                 write(6,6200) ch70
                 k = 0
                 ch70 = ' '
             endif
         endif
 1000 continue
      if( icnt .eq. 0 ) then
             ch70(k*10+1:k*10+10) = ' No SELECT'
      endif
      if( k .gt. 0 ) write(6,6200) ch70
      return
 6200 format(1h ,a)
      end
*-----------------------------------------------------------------------
*     select 'candidate process' and 'match'
*-----------------------------------------------------------------------
      subroutine grcgch
      include 'inclgi.f'
      common /grcg4f/ ignset(4,0:30)

      parameter ( mxfinp = 10 )
      integer lcnt(mxfinp),mxlcnt(mxfinp),lstack(mxfinp)
      nfinp = 4
      do 1000 i = 1 , nfinp
           lcnt(i) = 1
         mxlcnt(i) = ignset(i,0)
 1000 continue
      level = 1
 2000 continue
*        print *,'top:level,lcnt',level,lcnt(level)
         lstack(level) = ignset(level,lcnt(level))
         if( level .eq. nfinp ) then
*            write(6,6001) (lstack(k),k=1,nfinp)

             call grcgmt( nfinp , lstack , irtn)

             if( irtn .ne. -99 ) then
*                print *,'found ---> ',irtn,'-th proc'
                 iprclt(irtn) = 1
             endif

             lcnt(level) = lcnt(level) + 1
             
 2500        continue
             iback = 0
*            print *,'level,lcnt,mxlcnt',level,lcnt(level),mxlcnt(level)
             if( lcnt(level) .gt. mxlcnt(level) ) then
                 lcnt(level) = 1
                 level = level - 1
*                print *,'level--',level
                 if( level .eq. 0 ) goto 3000
                 lcnt(level) = lcnt(level) + 1
*                print *,'1:lcnt++',level,lcnt(level)
                 iback = iback + 1
             endif
             if( iback .gt. 0 ) goto 2500
         else
             level = level + 1
*            print *,'level++',level
         endif
      goto 2000
 3000 continue
      return
 6001 format(' << candidate >>',10i4)
      end
*-----------------------------------------------------------------------
*     search a given process in 'process table'.
*-----------------------------------------------------------------------
      subroutine grcgmt( nfin , lstack , irtn)
      parameter ( mxfinp = 10 )
      integer nfin,lstack(mxfinp)
      include 'inclgi.f'
      integer istack(mxfinp)

      do 1000 i = 1 , nfin
         istack(i) = lstack(i)
 1000 continue

      call grcgm0( nfin , istack , irtn)
 
      if( irtn .ne. -99 ) return

      do 2000 i = 1 , nfin
         if( lstack(i) .lt. 20 ) then
             istack(i) = -lstack(i)
         else
             istack(i) =  lstack(i)
         endif
 2000 continue

      call grcgm0( nfin , istack , irtn)

      return
      end
*-----------------------------------------------------------------------
*     matching a given process in 'process table'.
*-----------------------------------------------------------------------
      subroutine grcgm0( nfin , lstack , irtn)
      parameter ( mxfinp = 10 )
      integer nfin,lstack(mxfinp)
      include 'inclgi.f'
      integer mstack(mxfinp)
*============
*  Sorting  =
*============
      do 1000 i = 1 , nfin
      do 1000 j = i+1, nfin
         if( lstack(i) .gt. lstack(j) ) then
             ltmp      = lstack(i)
             lstack(i) = lstack(j)
             lstack(j) = ltmp
         endif
 1000 continue

      irtn = -99
      do 4000 i = 0 , maxprc-1
         iadr = iprc(i,1)
*        print *,' num ',iadr,idat(iadr),nfin
         if( idat(iadr) .eq. nfin ) then
             do 2000 j = 1 , idat(iadr)
                mstack(j) = idat(iadr+j)
 2000        continue
             do 3000 j = 1 , idat(iadr)
*               print *,'ms & ls ',mstack(j),lstack(j)
                if( mstack(j) .ne. lstack(j) ) goto 3100
 3000        continue
             irtn = i
             return
 3100        continue
         endif
 4000 continue
      return
      end
*-----------------------------------------------------------------------
*     get process name
*-----------------------------------------------------------------------
      function    grcpcn( i )
      character*8 grcpcn
      include 'inclgi.f'
      include 'inclan.f'
      grcpcn ='Not proc'
      if( i .le. 0 .or. i .gt. 76 ) then
          print *,'error in <<grcpcn>>'
          return
      endif
      grcpcn = prcnms(mulprc(i))
      return
      end
c----------------------------------------------
c      Initialzation table generated by grcpars
c----------------------------------------------
       subroutine grcgni
       include 'inclgi.f'
c      number of particles 24 
c      number of generic names 33 
c      number of given process 76 
       name(   0) = 'en'
       iptr(   0) = 0
       ichg(   0) = 0
       idat(   0) = 1
       idat(   1) = 12
       name(   1) = 'eN'
       iptr(   1) = 2
       ichg(   1) = 0
       idat(   2) = 1
       idat(   3) = -12
       name(   2) = 'mn'
       iptr(   2) = 4
       ichg(   2) = 0
       idat(   4) = 1
       idat(   5) = 14
       name(   3) = 'mN'
       iptr(   3) = 6
       ichg(   3) = 0
       idat(   6) = 1
       idat(   7) = -14
       name(   4) = 'tn'
       iptr(   4) = 8
       ichg(   4) = 0
       idat(   8) = 1
       idat(   9) = 16
       name(   5) = 'tN'
       iptr(   5) = 10
       ichg(   5) = 0
       idat(  10) = 1
       idat(  11) = -16
       name(   6) = 'ec'
       iptr(   6) = 12
       ichg(   6) = -3
       idat(  12) = 1
       idat(  13) = 11
       name(   7) = 'eC'
       iptr(   7) = 14
       ichg(   7) = 3
       idat(  14) = 1
       idat(  15) = -11
       name(   8) = 'mc'
       iptr(   8) = 16
       ichg(   8) = -3
       idat(  16) = 1
       idat(  17) = 13
       name(   9) = 'mC'
       iptr(   9) = 18
       ichg(   9) = 3
       idat(  18) = 1
       idat(  19) = -13
       name(  10) = 'tc'
       iptr(  10) = 20
       ichg(  10) = -3
       idat(  20) = 1
       idat(  21) = 15
       name(  11) = 'tC'
       iptr(  11) = 22
       ichg(  11) = 3
       idat(  22) = 1
       idat(  23) = -15
       name(  12) = 'uq'
       iptr(  12) = 24
       ichg(  12) = 2
       idat(  24) = 1
       idat(  25) = 2
       name(  13) = 'uQ'
       iptr(  13) = 26
       ichg(  13) = -2
       idat(  26) = 1
       idat(  27) = -2
       name(  14) = 'cq'
       iptr(  14) = 28
       ichg(  14) = 2
       idat(  28) = 1
       idat(  29) = 4
       name(  15) = 'cQ'
       iptr(  15) = 30
       ichg(  15) = -2
       idat(  30) = 1
       idat(  31) = -4
       name(  16) = 'tq'
       iptr(  16) = 32
       ichg(  16) = 2
       idat(  32) = 1
       idat(  33) = 6
       name(  17) = 'tQ'
       iptr(  17) = 34
       ichg(  17) = -2
       idat(  34) = 1
       idat(  35) = -6
       name(  18) = 'dq'
       iptr(  18) = 36
       ichg(  18) = -1
       idat(  36) = 1
       idat(  37) = 1
       name(  19) = 'dQ'
       iptr(  19) = 38
       ichg(  19) = 1
       idat(  38) = 1
       idat(  39) = -1
       name(  20) = 'sq'
       iptr(  20) = 40
       ichg(  20) = -1
       idat(  40) = 1
       idat(  41) = 3
       name(  21) = 'sQ'
       iptr(  21) = 42
       ichg(  21) = 1
       idat(  42) = 1
       idat(  43) = -3
       name(  22) = 'bq'
       iptr(  22) = 44
       ichg(  22) = -1
       idat(  44) = 1
       idat(  45) = 5
       name(  23) = 'bQ'
       iptr(  23) = 46
       ichg(  23) = 1
       idat(  46) = 1
       idat(  47) = -5
c--------------------
c      generic names 
c--------------------
       name(  24) = 'Cc'
       iptr(  24) = 48
       idat(  48) = 3
       idat(  49) = 11
       idat(  50) = 13
       idat(  51) = 15
       name(  25) = 'CC'
       iptr(  25) = 52
       idat(  52) = 3
       idat(  53) = -11
       idat(  54) = -13
       idat(  55) = -15
       name(  26) = 'CL'
       iptr(  26) = 56
       idat(  56) = 6
       idat(  57) = 11
       idat(  58) = -11
       idat(  59) = 13
       idat(  60) = -13
       idat(  61) = 15
       idat(  62) = -15
       name(  27) = 'Bc'
       iptr(  27) = 63
       idat(  63) = 2
       idat(  64) = 13
       idat(  65) = 15
       name(  28) = 'BC'
       iptr(  28) = 66
       idat(  66) = 2
       idat(  67) = -13
       idat(  68) = -15
       name(  29) = 'eL'
       iptr(  29) = 69
       idat(  69) = 2
       idat(  70) = 11
       idat(  71) = -11
       name(  30) = 'eZ'
       iptr(  30) = 72
       idat(  72) = 2
       idat(  73) = 12
       idat(  74) = -12
       name(  31) = 'mL'
       iptr(  31) = 75
       idat(  75) = 2
       idat(  76) = 13
       idat(  77) = -13
       name(  32) = 'mZ'
       iptr(  32) = 78
       idat(  78) = 2
       idat(  79) = 14
       idat(  80) = -14
       name(  33) = 'tL'
       iptr(  33) = 81
       idat(  81) = 2
       idat(  82) = 15
       idat(  83) = -15
       name(  34) = 'tZ'
       iptr(  34) = 84
       idat(  84) = 2
       idat(  85) = 16
       idat(  86) = -16
       name(  35) = 'Nn'
       iptr(  35) = 87
       idat(  87) = 3
       idat(  88) = 12
       idat(  89) = 14
       idat(  90) = 16
       name(  36) = 'NN'
       iptr(  36) = 91
       idat(  91) = 3
       idat(  92) = -12
       idat(  93) = -14
       idat(  94) = -16
       name(  37) = 'NZ'
       iptr(  37) = 95
       idat(  95) = 6
       idat(  96) = 12
       idat(  97) = -12
       idat(  98) = 14
       idat(  99) = -14
       idat( 100) = 16
       idat( 101) = -16
       name(  38) = 'LP'
       iptr(  38) = 102
       idat( 102) = 12
       idat( 103) = 11
       idat( 104) = -11
       idat( 105) = 12
       idat( 106) = -12
       idat( 107) = 13
       idat( 108) = -13
       idat( 109) = 14
       idat( 110) = -14
       idat( 111) = 15
       idat( 112) = -15
       idat( 113) = 16
       idat( 114) = -16
       name(  39) = 'KP'
       iptr(  39) = 115
       idat( 115) = 10
       idat( 116) = 12
       idat( 117) = -12
       idat( 118) = 13
       idat( 119) = -13
       idat( 120) = 14
       idat( 121) = -14
       idat( 122) = 15
       idat( 123) = -15
       idat( 124) = 16
       idat( 125) = -16
       name(  40) = 'Uq'
       iptr(  40) = 126
       idat( 126) = 3
       idat( 127) = 2
       idat( 128) = 4
       idat( 129) = 6
       name(  41) = 'UQ'
       iptr(  41) = 130
       idat( 130) = 3
       idat( 131) = -2
       idat( 132) = -4
       idat( 133) = -6
       name(  42) = 'uP'
       iptr(  42) = 134
       idat( 134) = 2
       idat( 135) = 2
       idat( 136) = -2
       name(  43) = 'dP'
       iptr(  43) = 137
       idat( 137) = 2
       idat( 138) = 1
       idat( 139) = -1
       name(  44) = 'cP'
       iptr(  44) = 140
       idat( 140) = 2
       idat( 141) = 4
       idat( 142) = -4
       name(  45) = 'sP'
       iptr(  45) = 143
       idat( 143) = 2
       idat( 144) = 3
       idat( 145) = -3
       name(  46) = 'tP'
       iptr(  46) = 146
       idat( 146) = 2
       idat( 147) = 6
       idat( 148) = -6
       name(  47) = 'bP'
       iptr(  47) = 149
       idat( 149) = 2
       idat( 150) = 5
       idat( 151) = -5
       name(  48) = 'UP'
       iptr(  48) = 152
       idat( 152) = 6
       idat( 153) = 2
       idat( 154) = -2
       idat( 155) = 4
       idat( 156) = -4
       idat( 157) = 6
       idat( 158) = -6
       name(  49) = 'Dq'
       iptr(  49) = 159
       idat( 159) = 3
       idat( 160) = 1
       idat( 161) = 3
       idat( 162) = 5
       name(  50) = 'DQ'
       iptr(  50) = 163
       idat( 163) = 3
       idat( 164) = -1
       idat( 165) = -3
       idat( 166) = -5
       name(  51) = 'DP'
       iptr(  51) = 167
       idat( 167) = 6
       idat( 168) = 1
       idat( 169) = -1
       idat( 170) = 3
       idat( 171) = -3
       idat( 172) = 5
       idat( 173) = -5
       name(  52) = 'Qq'
       iptr(  52) = 174
       idat( 174) = 6
       idat( 175) = 1
       idat( 176) = 2
       idat( 177) = 3
       idat( 178) = 4
       idat( 179) = 5
       idat( 180) = 6
       name(  53) = 'QQ'
       iptr(  53) = 181
       idat( 181) = 6
       idat( 182) = -1
       idat( 183) = -2
       idat( 184) = -3
       idat( 185) = -4
       idat( 186) = -5
       idat( 187) = -6
       name(  54) = 'QP'
       iptr(  54) = 188
       idat( 188) = 12
       idat( 189) = 1
       idat( 190) = -1
       idat( 191) = 2
       idat( 192) = -2
       idat( 193) = 3
       idat( 194) = -3
       idat( 195) = 4
       idat( 196) = -4
       idat( 197) = 5
       idat( 198) = -5
       idat( 199) = 6
       idat( 200) = -6
       name(  55) = 'FP'
       iptr(  55) = 201
       idat( 201) = 24
       idat( 202) = 1
       idat( 203) = -1
       idat( 204) = 2
       idat( 205) = -2
       idat( 206) = 3
       idat( 207) = -3
       idat( 208) = 4
       idat( 209) = -4
       idat( 210) = 5
       idat( 211) = -5
       idat( 212) = 6
       idat( 213) = -6
       idat( 214) = 11
       idat( 215) = -11
       idat( 216) = 12
       idat( 217) = -12
       idat( 218) = 13
       idat( 219) = -13
       idat( 220) = 14
       idat( 221) = -14
       idat( 222) = 15
       idat( 223) = -15
       idat( 224) = 16
       idat( 225) = -16
       name(  56) = 'EP'
       iptr(  56) = 226
       idat( 226) = 22
       idat( 227) = 1
       idat( 228) = -1
       idat( 229) = 2
       idat( 230) = -2
       idat( 231) = 3
       idat( 232) = -3
       idat( 233) = 4
       idat( 234) = -4
       idat( 235) = 5
       idat( 236) = -5
       idat( 237) = 6
       idat( 238) = -6
       idat( 239) = 12
       idat( 240) = -12
       idat( 241) = 13
       idat( 242) = -13
       idat( 243) = 14
       idat( 244) = -14
       idat( 245) = 15
       idat( 246) = -15
       idat( 247) = 16
       idat( 248) = -16
c------------------------
c      generated process 
c------------------------
       prcnms(   0) = 'eceCeneN'
       iprc(   0,1) = 249
       iprc(   0,2) = 1
       idat( 249) = 4
       idat( 250) = -12
       idat( 251) = -11
       idat( 252) = 11
       idat( 253) = 12
       prcnms(   1) = 'eceNmCmn'
       iprc(   1,1) = 254
       iprc(   1,2) = 2
       idat( 254) = 4
       idat( 255) = -13
       idat( 256) = -12
       idat( 257) = 11
       idat( 258) = 14
       prcnms(   2) = 'eceNtCtn'
       iprc(   2,1) = 259
       iprc(   2,2) = 2
       idat( 259) = 4
       idat( 260) = -15
       idat( 261) = -12
       idat( 262) = 11
       idat( 263) = 16
       prcnms(   3) = 'mnmCmcmN'
       iprc(   3,1) = 264
       iprc(   3,2) = 1
       idat( 264) = 4
       idat( 265) = -14
       idat( 266) = -13
       idat( 267) = 13
       idat( 268) = 14
       prcnms(   4) = 'tntCtctN'
       iprc(   4,1) = 269
       iprc(   4,2) = 1
       idat( 269) = 4
       idat( 270) = -16
       idat( 271) = -15
       idat( 272) = 15
       idat( 273) = 16
       prcnms(   5) = 'mcmNtCtn'
       iprc(   5,1) = 274
       iprc(   5,2) = 2
       idat( 274) = 4
       idat( 275) = -15
       idat( 276) = -14
       idat( 277) = 13
       idat( 278) = 16
       prcnms(   6) = 'eceCeceC'
       iprc(   6,1) = 279
       iprc(   6,2) = 1
       idat( 279) = 4
       idat( 280) = -11
       idat( 281) = -11
       idat( 282) = 11
       idat( 283) = 11
       prcnms(   7) = 'eceCmcmC'
       iprc(   7,1) = 284
       iprc(   7,2) = 1
       idat( 284) = 4
       idat( 285) = -13
       idat( 286) = -11
       idat( 287) = 11
       idat( 288) = 13
       prcnms(   8) = 'eceCtctC'
       iprc(   8,1) = 289
       iprc(   8,2) = 1
       idat( 289) = 4
       idat( 290) = -15
       idat( 291) = -11
       idat( 292) = 11
       idat( 293) = 15
       prcnms(   9) = 'mcmCmcmC'
       iprc(   9,1) = 294
       iprc(   9,2) = 1
       idat( 294) = 4
       idat( 295) = -13
       idat( 296) = -13
       idat( 297) = 13
       idat( 298) = 13
       prcnms(  10) = 'tctCtctC'
       iprc(  10,1) = 299
       iprc(  10,2) = 1
       idat( 299) = 4
       idat( 300) = -15
       idat( 301) = -15
       idat( 302) = 15
       idat( 303) = 15
       prcnms(  11) = 'mcmCtctC'
       iprc(  11,1) = 304
       iprc(  11,2) = 1
       idat( 304) = 4
       idat( 305) = -15
       idat( 306) = -13
       idat( 307) = 13
       idat( 308) = 15
       prcnms(  12) = 'eceCmnmN'
       iprc(  12,1) = 309
       iprc(  12,2) = 1
       idat( 309) = 4
       idat( 310) = -14
       idat( 311) = -11
       idat( 312) = 11
       idat( 313) = 14
       prcnms(  13) = 'eceCtntN'
       iprc(  13,1) = 314
       iprc(  13,2) = 1
       idat( 314) = 4
       idat( 315) = -16
       idat( 316) = -11
       idat( 317) = 11
       idat( 318) = 16
       prcnms(  14) = 'eneNmcmC'
       iprc(  14,1) = 319
       iprc(  14,2) = 1
       idat( 319) = 4
       idat( 320) = -13
       idat( 321) = -12
       idat( 322) = 12
       idat( 323) = 13
       prcnms(  15) = 'eneNtctC'
       iprc(  15,1) = 324
       iprc(  15,2) = 1
       idat( 324) = 4
       idat( 325) = -15
       idat( 326) = -12
       idat( 327) = 12
       idat( 328) = 15
       prcnms(  16) = 'tntNmcmC'
       iprc(  16,1) = 329
       iprc(  16,2) = 1
       idat( 329) = 4
       idat( 330) = -16
       idat( 331) = -13
       idat( 332) = 13
       idat( 333) = 16
       prcnms(  17) = 'mnmNtctC'
       iprc(  17,1) = 334
       iprc(  17,2) = 1
       idat( 334) = 4
       idat( 335) = -15
       idat( 336) = -14
       idat( 337) = 14
       idat( 338) = 15
       prcnms(  18) = 'eneNeneN'
       iprc(  18,1) = 339
       iprc(  18,2) = 1
       idat( 339) = 4
       idat( 340) = -12
       idat( 341) = -12
       idat( 342) = 12
       idat( 343) = 12
       prcnms(  19) = 'eneNmnmN'
       iprc(  19,1) = 344
       iprc(  19,2) = 1
       idat( 344) = 4
       idat( 345) = -14
       idat( 346) = -12
       idat( 347) = 12
       idat( 348) = 14
       prcnms(  20) = 'eneNtntN'
       iprc(  20,1) = 349
       iprc(  20,2) = 1
       idat( 349) = 4
       idat( 350) = -16
       idat( 351) = -12
       idat( 352) = 12
       idat( 353) = 16
       prcnms(  21) = 'mnmNmnmN'
       iprc(  21,1) = 354
       iprc(  21,2) = 1
       idat( 354) = 4
       idat( 355) = -14
       idat( 356) = -14
       idat( 357) = 14
       idat( 358) = 14
       prcnms(  22) = 'tntNtntN'
       iprc(  22,1) = 359
       iprc(  22,2) = 1
       idat( 359) = 4
       idat( 360) = -16
       idat( 361) = -16
       idat( 362) = 16
       idat( 363) = 16
       prcnms(  23) = 'tntNmnmN'
       iprc(  23,1) = 364
       iprc(  23,2) = 1
       idat( 364) = 4
       idat( 365) = -16
       idat( 366) = -14
       idat( 367) = 14
       idat( 368) = 16
       prcnms(  24) = 'eceNuqdQ'
       iprc(  24,1) = 369
       iprc(  24,2) = 2
       idat( 369) = 4
       idat( 370) = -12
       idat( 371) = -1
       idat( 372) = 2
       idat( 373) = 11
       prcnms(  25) = 'eceNcqsQ'
       iprc(  25,1) = 374
       iprc(  25,2) = 2
       idat( 374) = 4
       idat( 375) = -12
       idat( 376) = -3
       idat( 377) = 4
       idat( 378) = 11
       prcnms(  26) = 'mcmNuqdQ'
       iprc(  26,1) = 379
       iprc(  26,2) = 2
       idat( 379) = 4
       idat( 380) = -14
       idat( 381) = -1
       idat( 382) = 2
       idat( 383) = 13
       prcnms(  27) = 'mcmNcqsQ'
       iprc(  27,1) = 384
       iprc(  27,2) = 2
       idat( 384) = 4
       idat( 385) = -14
       idat( 386) = -3
       idat( 387) = 4
       idat( 388) = 13
       prcnms(  28) = 'tctNuqdQ'
       iprc(  28,1) = 389
       iprc(  28,2) = 2
       idat( 389) = 4
       idat( 390) = -16
       idat( 391) = -1
       idat( 392) = 2
       idat( 393) = 15
       prcnms(  29) = 'tctNcqsQ'
       iprc(  29,1) = 394
       iprc(  29,2) = 2
       idat( 394) = 4
       idat( 395) = -16
       idat( 396) = -3
       idat( 397) = 4
       idat( 398) = 15
       prcnms(  30) = 'eceCuquQ'
       iprc(  30,1) = 399
       iprc(  30,2) = 1
       idat( 399) = 4
       idat( 400) = -11
       idat( 401) = -2
       idat( 402) = 2
       idat( 403) = 11
       prcnms(  31) = 'eceCcqcQ'
       iprc(  31,1) = 404
       iprc(  31,2) = 1
       idat( 404) = 4
       idat( 405) = -11
       idat( 406) = -4
       idat( 407) = 4
       idat( 408) = 11
       prcnms(  32) = 'eceCdqdQ'
       iprc(  32,1) = 409
       iprc(  32,2) = 1
       idat( 409) = 4
       idat( 410) = -11
       idat( 411) = -1
       idat( 412) = 1
       idat( 413) = 11
       prcnms(  33) = 'eceCsqsQ'
       iprc(  33,1) = 414
       iprc(  33,2) = 1
       idat( 414) = 4
       idat( 415) = -11
       idat( 416) = -3
       idat( 417) = 3
       idat( 418) = 11
       prcnms(  34) = 'eceCbqbQ'
       iprc(  34,1) = 419
       iprc(  34,2) = 1
       idat( 419) = 4
       idat( 420) = -11
       idat( 421) = -5
       idat( 422) = 5
       idat( 423) = 11
       prcnms(  35) = 'mcmCuquQ'
       iprc(  35,1) = 424
       iprc(  35,2) = 1
       idat( 424) = 4
       idat( 425) = -13
       idat( 426) = -2
       idat( 427) = 2
       idat( 428) = 13
       prcnms(  36) = 'mcmCcqcQ'
       iprc(  36,1) = 429
       iprc(  36,2) = 1
       idat( 429) = 4
       idat( 430) = -13
       idat( 431) = -4
       idat( 432) = 4
       idat( 433) = 13
       prcnms(  37) = 'tctCuquQ'
       iprc(  37,1) = 434
       iprc(  37,2) = 1
       idat( 434) = 4
       idat( 435) = -15
       idat( 436) = -2
       idat( 437) = 2
       idat( 438) = 15
       prcnms(  38) = 'tctCcqcQ'
       iprc(  38,1) = 439
       iprc(  38,2) = 1
       idat( 439) = 4
       idat( 440) = -15
       idat( 441) = -4
       idat( 442) = 4
       idat( 443) = 15
       prcnms(  39) = 'mcmCdqdQ'
       iprc(  39,1) = 444
       iprc(  39,2) = 1
       idat( 444) = 4
       idat( 445) = -13
       idat( 446) = -1
       idat( 447) = 1
       idat( 448) = 13
       prcnms(  40) = 'mcmCsqsQ'
       iprc(  40,1) = 449
       iprc(  40,2) = 1
       idat( 449) = 4
       idat( 450) = -13
       idat( 451) = -3
       idat( 452) = 3
       idat( 453) = 13
       prcnms(  41) = 'mcmCbqbQ'
       iprc(  41,1) = 454
       iprc(  41,2) = 1
       idat( 454) = 4
       idat( 455) = -13
       idat( 456) = -5
       idat( 457) = 5
       idat( 458) = 13
       prcnms(  42) = 'tctCdqdQ'
       iprc(  42,1) = 459
       iprc(  42,2) = 1
       idat( 459) = 4
       idat( 460) = -15
       idat( 461) = -1
       idat( 462) = 1
       idat( 463) = 15
       prcnms(  43) = 'tctCsqsQ'
       iprc(  43,1) = 464
       iprc(  43,2) = 1
       idat( 464) = 4
       idat( 465) = -15
       idat( 466) = -3
       idat( 467) = 3
       idat( 468) = 15
       prcnms(  44) = 'tctCbqbQ'
       iprc(  44,1) = 469
       iprc(  44,2) = 1
       idat( 469) = 4
       idat( 470) = -15
       idat( 471) = -5
       idat( 472) = 5
       idat( 473) = 15
       prcnms(  45) = 'eneNuquQ'
       iprc(  45,1) = 474
       iprc(  45,2) = 1
       idat( 474) = 4
       idat( 475) = -12
       idat( 476) = -2
       idat( 477) = 2
       idat( 478) = 12
       prcnms(  46) = 'eneNcqcQ'
       iprc(  46,1) = 479
       iprc(  46,2) = 1
       idat( 479) = 4
       idat( 480) = -12
       idat( 481) = -4
       idat( 482) = 4
       idat( 483) = 12
       prcnms(  47) = 'eneNdqdQ'
       iprc(  47,1) = 484
       iprc(  47,2) = 1
       idat( 484) = 4
       idat( 485) = -12
       idat( 486) = -1
       idat( 487) = 1
       idat( 488) = 12
       prcnms(  48) = 'eneNsqsQ'
       iprc(  48,1) = 489
       iprc(  48,2) = 1
       idat( 489) = 4
       idat( 490) = -12
       idat( 491) = -3
       idat( 492) = 3
       idat( 493) = 12
       prcnms(  49) = 'eneNbqbQ'
       iprc(  49,1) = 494
       iprc(  49,2) = 1
       idat( 494) = 4
       idat( 495) = -12
       idat( 496) = -5
       idat( 497) = 5
       idat( 498) = 12
       prcnms(  50) = 'mnmNuquQ'
       iprc(  50,1) = 499
       iprc(  50,2) = 1
       idat( 499) = 4
       idat( 500) = -14
       idat( 501) = -2
       idat( 502) = 2
       idat( 503) = 14
       prcnms(  51) = 'mnmNcqcQ'
       iprc(  51,1) = 504
       iprc(  51,2) = 1
       idat( 504) = 4
       idat( 505) = -14
       idat( 506) = -4
       idat( 507) = 4
       idat( 508) = 14
       prcnms(  52) = 'tntNuquQ'
       iprc(  52,1) = 509
       iprc(  52,2) = 1
       idat( 509) = 4
       idat( 510) = -16
       idat( 511) = -2
       idat( 512) = 2
       idat( 513) = 16
       prcnms(  53) = 'tntNcqcQ'
       iprc(  53,1) = 514
       iprc(  53,2) = 1
       idat( 514) = 4
       idat( 515) = -16
       idat( 516) = -4
       idat( 517) = 4
       idat( 518) = 16
       prcnms(  54) = 'mnmNdqdQ'
       iprc(  54,1) = 519
       iprc(  54,2) = 1
       idat( 519) = 4
       idat( 520) = -14
       idat( 521) = -1
       idat( 522) = 1
       idat( 523) = 14
       prcnms(  55) = 'mnmNsqsQ'
       iprc(  55,1) = 524
       iprc(  55,2) = 1
       idat( 524) = 4
       idat( 525) = -14
       idat( 526) = -3
       idat( 527) = 3
       idat( 528) = 14
       prcnms(  56) = 'mnmNbqbQ'
       iprc(  56,1) = 529
       iprc(  56,2) = 1
       idat( 529) = 4
       idat( 530) = -14
       idat( 531) = -5
       idat( 532) = 5
       idat( 533) = 14
       prcnms(  57) = 'tntNdqdQ'
       iprc(  57,1) = 534
       iprc(  57,2) = 1
       idat( 534) = 4
       idat( 535) = -16
       idat( 536) = -1
       idat( 537) = 1
       idat( 538) = 16
       prcnms(  58) = 'tntNsqsQ'
       iprc(  58,1) = 539
       iprc(  58,2) = 1
       idat( 539) = 4
       idat( 540) = -16
       idat( 541) = -3
       idat( 542) = 3
       idat( 543) = 16
       prcnms(  59) = 'tntNbqbQ'
       iprc(  59,1) = 544
       iprc(  59,2) = 1
       idat( 544) = 4
       idat( 545) = -16
       idat( 546) = -5
       idat( 547) = 5
       idat( 548) = 16
       prcnms(  60) = 'uqdQdquQ'
       iprc(  60,1) = 549
       iprc(  60,2) = 1
       idat( 549) = 4
       idat( 550) = -2
       idat( 551) = -1
       idat( 552) = 1
       idat( 553) = 2
       prcnms(  61) = 'cqsQsqcQ'
       iprc(  61,1) = 554
       iprc(  61,2) = 1
       idat( 554) = 4
       idat( 555) = -4
       idat( 556) = -3
       idat( 557) = 3
       idat( 558) = 4
       prcnms(  62) = 'uqdQsqcQ'
       iprc(  62,1) = 559
       iprc(  62,2) = 2
       idat( 559) = 4
       idat( 560) = -4
       idat( 561) = -1
       idat( 562) = 2
       idat( 563) = 3
       prcnms(  63) = 'uquQuquQ'
       iprc(  63,1) = 564
       iprc(  63,2) = 1
       idat( 564) = 4
       idat( 565) = -2
       idat( 566) = -2
       idat( 567) = 2
       idat( 568) = 2
       prcnms(  64) = 'cqcQcqcQ'
       iprc(  64,1) = 569
       iprc(  64,2) = 1
       idat( 569) = 4
       idat( 570) = -4
       idat( 571) = -4
       idat( 572) = 4
       idat( 573) = 4
       prcnms(  65) = 'dqdQdqdQ'
       iprc(  65,1) = 574
       iprc(  65,2) = 1
       idat( 574) = 4
       idat( 575) = -1
       idat( 576) = -1
       idat( 577) = 1
       idat( 578) = 1
       prcnms(  66) = 'sqsQsqsQ'
       iprc(  66,1) = 579
       iprc(  66,2) = 1
       idat( 579) = 4
       idat( 580) = -3
       idat( 581) = -3
       idat( 582) = 3
       idat( 583) = 3
       prcnms(  67) = 'bqbQbqbQ'
       iprc(  67,1) = 584
       iprc(  67,2) = 1
       idat( 584) = 4
       idat( 585) = -5
       idat( 586) = -5
       idat( 587) = 5
       idat( 588) = 5
       prcnms(  68) = 'uquQcqcQ'
       iprc(  68,1) = 589
       iprc(  68,2) = 1
       idat( 589) = 4
       idat( 590) = -4
       idat( 591) = -2
       idat( 592) = 2
       idat( 593) = 4
       prcnms(  69) = 'uquQsqsQ'
       iprc(  69,1) = 594
       iprc(  69,2) = 1
       idat( 594) = 4
       idat( 595) = -3
       idat( 596) = -2
       idat( 597) = 2
       idat( 598) = 3
       prcnms(  70) = 'uquQbqbQ'
       iprc(  70,1) = 599
       iprc(  70,2) = 1
       idat( 599) = 4
       idat( 600) = -5
       idat( 601) = -2
       idat( 602) = 2
       idat( 603) = 5
       prcnms(  71) = 'cqcQdqdQ'
       iprc(  71,1) = 604
       iprc(  71,2) = 1
       idat( 604) = 4
       idat( 605) = -4
       idat( 606) = -1
       idat( 607) = 1
       idat( 608) = 4
       prcnms(  72) = 'cqcQbqbQ'
       iprc(  72,1) = 609
       iprc(  72,2) = 1
       idat( 609) = 4
       idat( 610) = -5
       idat( 611) = -4
       idat( 612) = 4
       idat( 613) = 5
       prcnms(  73) = 'dqdQsqsQ'
       iprc(  73,1) = 614
       iprc(  73,2) = 1
       idat( 614) = 4
       idat( 615) = -3
       idat( 616) = -1
       idat( 617) = 1
       idat( 618) = 3
       prcnms(  74) = 'dqdQbqbQ'
       iprc(  74,1) = 619
       iprc(  74,2) = 1
       idat( 619) = 4
       idat( 620) = -5
       idat( 621) = -1
       idat( 622) = 1
       idat( 623) = 5
       prcnms(  75) = 'sqsQbqbQ'
       iprc(  75,1) = 624
       iprc(  75,2) = 1
       idat( 624) = 4
       idat( 625) = -5
       idat( 626) = -3
       idat( 627) = 3
       idat( 628) = 5
       return
       end
      subroutine grchel
c-----------------------------------------------------------------------
c...Purpose     
c     Print helicity informations (Utility)                       LAPP
c-----------------------------------------------------------------------
      integer it,ii,iff
      real*4  p,v
      common/lujets/n,k(4000,5),p(4000,5),v(4000,5)
      integer lect
      common/helicity/lect(4000)
      write(6,*) '   '
      write(6,*) '                            Event Helicities'
      write(6,*) '   I ','  helicity*2'
      ii=0
      it=0
      iff=0
c
      do 1000 i=1,n
         if( lect(i).ne.-999)then
            write(6,'(1x,i4,2x,i4)') i,lect(i)
            if(lect(i).ne.999)then
               it=it+lect(i)
               if(i.eq.1.or.i.eq.2)then
                  ii=ii+lect(i)
               else
                  iff=iff+lect(i)
               endif
            endif
         endif
 1000 continue
      write(6,'(1x,a4,2x,i4,2x,a18,2x,i3,2x,a16,2x,i3)')
     &'Sum:',it,'Initial state Sum:',ii,'Final state Sum:',iff
      return
      end
*-----------------------------------------------------------------------
*     grcpar   (main parser routine)
*-----------------------------------------------------------------------
      subroutine grcpar(parm,iodat,iopt,ierr)
      character*(*) parm
      dimension iodat(2)
      common /grccnt/ istate, inoexe
      ierr = 0

      if( istate .ne. -3 ) then
          print *,'grcpar ',parm 
          call grcerr(1,' grcpar is improperly called.')
          return
      endif

      call grcpfn( parm, iptr, iadr, ityp )

*     print *,'iadr,ityp',iadr,ityp,iodat
      if( iadr .eq. -99 ) then
          ierr = -1
          return
      endif

      if( ityp .eq. 0 ) then
          call grcpi4( iptr, iadr, iodat , iopt )
      else if( ityp .eq. 1 ) then
          call grcpr8( iptr, iadr, iodat , iopt )
      else if( ityp .eq. 2 ) then
          call grcpc8( iptr, iadr, iodat , iopt )
      else 
          write(6,6000)
          ierr = -2
      endif
      return
 6000 format(' <<grcpar>> type(',i3,') is not defined.')
      end
*-----------------------------------------------------------------------
*     grcpfn   (find keyword)
*-----------------------------------------------------------------------
      subroutine grcpfn( parm, iptr, iadr, ityp )
      character*(*) parm
      include 'inclpi.f'
      iadr  =  -99
      ityp  =  -99
      call grcp2l( parm )
      do 1000 i = 0 , maxact-1
         if( grcpky(i) .eq. parm ) then
             iptr = i
             iadr = ikyadr(i)
             ityp = ikytyp(i)
             return
         endif
 1000 continue
      write(6,6000) parm
 6000 format(' <<grcpfn>> keyword(',a,') is not found.')
      return
      end
*-----------------------------------------------------------------------
*     grcp2l   (to lower case)
*-----------------------------------------------------------------------
      subroutine grcp2l( parm )
      character*(*) parm
      l = len(parm)
      do 1000 i = 1 , l
         if( parm(i:i) .ge. 'A' .and. parm(i:i) .le. 'Z' ) then
             k = ichar(parm(i:i)) + ichar('a') - ichar('A')
             parm(i:i) = char(k)
         endif
 1000 continue
      return
      end
*-----------------------------------------------------------------------
*     grcpi4   (integer)
*-----------------------------------------------------------------------
      subroutine grcpi4( iptr, iadr, iodat ,iopt)
      include 'inclpi.f'
      integer iptr, iadr,iodat(2)
      indata = iodat(1)

*     print *,'grcpi4 : ',i4data(iadr),indata
      if( i4data(iadr) .ne. indata ) then
          keytch(iptr) = 1 
          if( iopt .eq. 1 ) then
              write(6,6000) grcpky(iptr),i4data(iadr),indata
          endif
          i4data(iadr) = indata
      endif
      return
 6000 format(' ',a12,' : ',i10,' --> ',i10)
      end
*-----------------------------------------------------------------------
*     grcpr8   (real*8)
*-----------------------------------------------------------------------
      subroutine grcpr8( iptr, iadr, iodat ,iopt )
      integer iptr, iadr,iodat(2)
      dimension iotmp(2)
      include 'inclpi.f'
      real*8   r8
*     equivalence (r8,iodat(1))
      equivalence (iotmp(1), r8 )

      do 1000 i = 1 , 2
         iotmp(i) = iodat(i)
 1000 continue
      if( r8data(iadr) .ne. r8 ) then
          keytch(iptr) = 1 
          if( iopt .eq. 1 ) then
              write(6,6000) grcpky(iptr),r8data(iadr),r8
          endif
          r8data(iadr) = r8
      endif
      return
 6000 format(' ',a12,' : ',e15.7,' --> ',e15.7)
      end
*-----------------------------------------------------------------------
*     grcpc8   (character*8)
*-----------------------------------------------------------------------
      subroutine grcpc8( iptr, iadr, iodat , iopt )
*     subroutine grcpc8( iptr, iadr, c8, iopt, ierr )
      integer iptr, iadr,iodat(2)
      include 'inclpi.f'
      dimension iotmp(2)
      character*8 c8
      equivalence (iotmp(1),c8)

      do 1000 i = 1 , 2
         iotmp(i) = iodat(i)
 1000 continue
      if( c8data(iadr) .ne. c8 ) then
          keytch(iptr) = 1 
          if( iopt .eq. 1 ) then
              write(6,6000) grcpky(iptr),c8data(iadr),c8
          endif
          c8data(iadr) = c8
      endif
      return
 6000 format(' ',a12,' : ',a,' --> ',a)
      end
c970702 add:iprint option
c-----------------------------------------------------------------------
      subroutine grcpgs(nthprc,iset,iprint,ng,jsel)
c-----------------------------------------------------------------------
c     Graph Selection (made in Japon)
c-----------------------------------------------------------------------
      integer jsel(ng)
      include 'incl1.f'
      include 'inclpd.f'
      integer iw(ngraph)

*     print *,'<<grcpgs>>',nthprc,iset

      if( iset .eq. 0 ) then
          do 1000 i = 1 , ngd(nthprc)
             jsel(i) = 1
 1000     continue
      else
 
          do 1500 i = 1 , ngd(nthprc)
             if( kdiagr(nthprc,iset,i) .eq. 1 ) then
                 jsel(i) = 1
             else
                 jsel(i) = 0
             endif
 1500     continue

      endif

      ic = 0
      do 2000 i = 1 , ngd(nthprc)
         if( jsel(i) .eq. 1 ) then
             ic = ic + 1
             iw(ic) = i
         endif
 2000 continue

      if( ic .eq. 0 ) then
          call grcerr(2,' No graphs are selected ')
          return
      endif

      if( iprint .ne. 0 ) then

      write(6,6200)
      m1 = 0
 3000 m2 = m1 + 20
      if( ic .gt. m2 ) then
         write(6,6000) (iw(k),k=m1+1,m2)
         m1 = m2
      else
         write(6,6000) (iw(k),k=m1+1,ic)
      endif
      if( m1 .eq. m2 ) goto 3000
      write(6,6100) ic , ngd(nthprc)

      endif

      return
 6000 format(1x,20i3)
 6100 format(1x,'  .... are selected.(',i3,' graphs in ',i3,' graphs)')
 6200 format(1x,' Graph number ')
      end
c----------------------------------------------
c      Initialzation table generated by grcpar
c----------------------------------------------
       subroutine grcpin
       include 'inclpi.f'
       grcpky(   0) = 'helicity1'
       i4data(   0) = 0
       ikyadr(   0) = 0
       ikytyp(   0) = 0
       grcpky(   1) = 'helicity2'
       i4data(   1) = 0
       ikyadr(   1) = 1
       ikytyp(   1) = 0
       grcpky(   2) = 'helicity3'
       i4data(   2) = 0
       ikyadr(   2) = 2
       ikytyp(   2) = 0
       grcpky(   3) = 'helicity4'
       i4data(   3) = 0
       ikyadr(   3) = 3
       ikytyp(   3) = 0
       grcpky(   4) = 'helicity5'
       i4data(   4) = 0
       ikyadr(   4) = 4
       ikytyp(   4) = 0
       grcpky(   5) = 'helicity6'
       i4data(   5) = 0
       ikyadr(   5) = 5
       ikytyp(   5) = 0
       grcpky(   6) = 'set'
       i4data(   6) = 0
       ikyadr(   6) = 6
       ikytyp(   6) = 0
       grcpky(   7) = 'isrtype'
       i4data(   7) = 0
       ikyadr(   7) = 7
       ikytyp(   7) = 0
       grcpky(   8) = 'canon'
       i4data(   8) = 1
       ikyadr(   8) = 8
       ikytyp(   8) = 0
       grcpky(   9) = 'qmass'
       i4data(   9) = 1
       ikyadr(   9) = 9
       ikytyp(   9) = 0
       grcpky(  10) = 'lmass'
       i4data(  10) = 1
       ikyadr(  10) = 10
       ikytyp(  10) = 0
       grcpky(  11) = 'width'
       i4data(  11) = 0
       ikyadr(  11) = 11
       ikytyp(  11) = 0
       grcpky(  12) = 'coulomb'
       i4data(  12) = 0
       ikyadr(  12) = 12
       ikytyp(  12) = 0
       grcpky(  13) = 'qcdcr'
       i4data(  13) = 0
       ikyadr(  13) = 13
       ikytyp(  13) = 0
       grcpky(  14) = 'gluon'
       i4data(  14) = 0
       ikyadr(  14) = 14
       ikytyp(  14) = 0
       grcpky(  15) = 'shower'
       i4data(  15) = 1
       ikyadr(  15) = 15
       ikytyp(  15) = 0
       grcpky(  16) = 'hadron'
       i4data(  16) = 1
       ikyadr(  16) = 16
       ikytyp(  16) = 0
       grcpky(  17) = 'scheme'
       i4data(  17) = 1
       ikyadr(  17) = 17
       ikytyp(  17) = 0
       grcpky(  18) = 'seed'
       i4data(  18) = 12345
       ikyadr(  18) = 18
       ikytyp(  18) = 0
       grcpky(  19) = 'lubsdt'
       i4data(  19) = 0
       ikyadr(  19) = 19
       ikytyp(  19) = 0
       grcpky(  20) = 'lubsrl'
       i4data(  20) = 0
       ikyadr(  20) = 20
       ikytyp(  20) = 0
       grcpky(  21) = 'lusprl'
       i4data(  21) = 0
       ikyadr(  21) = 21
       ikytyp(  21) = 0
       grcpky(  22) = 'itmx1'
       i4data(  22) = -1
       ikyadr(  22) = 22
       ikytyp(  22) = 0
       grcpky(  23) = 'itmx2'
       i4data(  23) = -1
       ikyadr(  23) = 23
       ikytyp(  23) = 0
       grcpky(  24) = 'ncall'
       i4data(  24) = -1
       ikyadr(  24) = 24
       ikytyp(  24) = 0
       grcpky(  25) = 'mxtry'
       i4data(  25) = 50
       ikyadr(  25) = 25
       ikytyp(  25) = 0
       grcpky(  26) = 'energy'
       r8data(   0) = 190.d0
       ikyadr(  26) = 0
       ikytyp(  26) = 1
       grcpky(  27) = 'eisr'
       r8data(   1) = 0.001d0
       ikyadr(  27) = 1
       ikytyp(  27) = 1
       grcpky(  28) = 'acc1'
       r8data(   2) = 0.1d0
       ikyadr(  28) = 2
       ikytyp(  28) = 1
       grcpky(  29) = 'acc2'
       r8data(   3) = 0.05d0
       ikyadr(  29) = 3
       ikytyp(  29) = 1
       grcpky(  30) = 'opncut'
       r8data(   4) = 0.0d0
       ikyadr(  30) = 4
       ikytyp(  30) = 1
       grcpky(  31) = 'thecut31'
       r8data(   5) = 180.d0
       ikyadr(  31) = 5
       ikytyp(  31) = 1
       grcpky(  32) = 'thecut32'
       r8data(   6) = 0.0d0
       ikyadr(  32) = 6
       ikytyp(  32) = 1
       grcpky(  33) = 'thecut41'
       r8data(   7) = 180.d0
       ikyadr(  33) = 7
       ikytyp(  33) = 1
       grcpky(  34) = 'thecut42'
       r8data(   8) = 0.0d0
       ikyadr(  34) = 8
       ikytyp(  34) = 1
       grcpky(  35) = 'thecut51'
       r8data(   9) = 180.d0
       ikyadr(  35) = 9
       ikytyp(  35) = 1
       grcpky(  36) = 'thecut52'
       r8data(  10) = 0.0d0
       ikyadr(  36) = 10
       ikytyp(  36) = 1
       grcpky(  37) = 'thecut61'
       r8data(  11) = 180.d0
       ikyadr(  37) = 11
       ikytyp(  37) = 1
       grcpky(  38) = 'thecut62'
       r8data(  12) = 0.0d0
       ikyadr(  38) = 12
       ikytyp(  38) = 1
       grcpky(  39) = 'engcut31'
       r8data(  13) = -1.0d0
       ikyadr(  39) = 13
       ikytyp(  39) = 1
       grcpky(  40) = 'engcut32'
       r8data(  14) = -1.0d0
       ikyadr(  40) = 14
       ikytyp(  40) = 1
       grcpky(  41) = 'engcut41'
       r8data(  15) = -1.0d0
       ikyadr(  41) = 15
       ikytyp(  41) = 1
       grcpky(  42) = 'engcut42'
       r8data(  16) = -1.0d0
       ikyadr(  42) = 16
       ikytyp(  42) = 1
       grcpky(  43) = 'engcut51'
       r8data(  17) = -1.0d0
       ikyadr(  43) = 17
       ikytyp(  43) = 1
       grcpky(  44) = 'engcut52'
       r8data(  18) = -1.0d0
       ikyadr(  44) = 18
       ikytyp(  44) = 1
       grcpky(  45) = 'engcut61'
       r8data(  19) = -1.0d0
       ikyadr(  45) = 19
       ikytyp(  45) = 1
       grcpky(  46) = 'engcut62'
       r8data(  20) = -1.0d0
       ikyadr(  46) = 20
       ikytyp(  46) = 1
       grcpky(  47) = 'invcut341'
       r8data(  21) = -1.0d0
       ikyadr(  47) = 21
       ikytyp(  47) = 1
       grcpky(  48) = 'invcut342'
       r8data(  22) = -1.0d0
       ikyadr(  48) = 22
       ikytyp(  48) = 1
       grcpky(  49) = 'invcut561'
       r8data(  23) = -1.0d0
       ikyadr(  49) = 23
       ikytyp(  49) = 1
       grcpky(  50) = 'invcut562'
       r8data(  24) = -1.0d0
       ikyadr(  50) = 24
       ikytyp(  50) = 1
       grcpky(  51) = 'invcut351'
       r8data(  25) = -1.0d0
       ikyadr(  51) = 25
       ikytyp(  51) = 1
       grcpky(  52) = 'invcut352'
       r8data(  26) = -1.0d0
       ikyadr(  52) = 26
       ikytyp(  52) = 1
       grcpky(  53) = 'invcut461'
       r8data(  27) = -1.0d0
       ikyadr(  53) = 27
       ikytyp(  53) = 1
       grcpky(  54) = 'invcut462'
       r8data(  28) = -1.0d0
       ikyadr(  54) = 28
       ikytyp(  54) = 1
       grcpky(  55) = 'invcut361'
       r8data(  29) = -1.0d0
       ikyadr(  55) = 29
       ikytyp(  55) = 1
       grcpky(  56) = 'invcut362'
       r8data(  30) = -1.0d0
       ikyadr(  56) = 30
       ikytyp(  56) = 1
       grcpky(  57) = 'invcut451'
       r8data(  31) = -1.0d0
       ikyadr(  57) = 31
       ikytyp(  57) = 1
       grcpky(  58) = 'invcut452'
       r8data(  32) = -1.0d0
       ikyadr(  58) = 32
       ikytyp(  58) = 1
       grcpky(  59) = 'ang1a'
       r8data(  33) = 1.0d0
       ikyadr(  59) = 33
       ikytyp(  59) = 1
       grcpky(  60) = 'ankaa'
       r8data(  34) = 1.0d0
       ikyadr(  60) = 34
       ikytyp(  60) = 1
       grcpky(  61) = 'anlma'
       r8data(  35) = 0.0d0
       ikyadr(  61) = 35
       ikytyp(  61) = 1
       grcpky(  62) = 'ang1z'
       r8data(  36) = 1.0d0
       ikyadr(  62) = 36
       ikytyp(  62) = 1
       grcpky(  63) = 'ankaz'
       r8data(  37) = 1.0d0
       ikyadr(  63) = 37
       ikytyp(  63) = 1
       grcpky(  64) = 'anlmz'
       r8data(  38) = 0.0d0
       ikyadr(  64) = 38
       ikytyp(  64) = 1
       grcpky(  65) = 'amw'
       r8data(  39) = 80.23d0
       ikyadr(  65) = 39
       ikytyp(  65) = 1
       grcpky(  66) = 'agw'
       r8data(  40) = 2.03367d0
       ikyadr(  66) = 40
       ikytyp(  66) = 1
       grcpky(  67) = 'amz'
       r8data(  41) = 91.1888d0
       ikyadr(  67) = 41
       ikytyp(  67) = 1
       grcpky(  68) = 'agz'
       r8data(  42) = 2.4974d0
       ikyadr(  68) = 42
       ikytyp(  68) = 1
       grcpky(  69) = 'amh'
       r8data(  43) = 10000.d0
       ikyadr(  69) = 43
       ikytyp(  69) = 1
       grcpky(  70) = 'amel'
       r8data(  44) = 0.51099906d-3
       ikyadr(  70) = 44
       ikytyp(  70) = 1
       grcpky(  71) = 'ammu'
       r8data(  45) = 105.658389d-3
       ikyadr(  71) = 45
       ikytyp(  71) = 1
       grcpky(  72) = 'amta'
       r8data(  46) = 1.7771d0
       ikyadr(  72) = 46
       ikytyp(  72) = 1
       grcpky(  73) = 'amuq'
       r8data(  47) = 5.0d-3
       ikyadr(  73) = 47
       ikytyp(  73) = 1
       grcpky(  74) = 'amcq'
       r8data(  48) = 1.3d0
       ikyadr(  74) = 48
       ikytyp(  74) = 1
       grcpky(  75) = 'amtq'
       r8data(  49) = 170.d0
       ikyadr(  75) = 49
       ikytyp(  75) = 1
       grcpky(  76) = 'amdq'
       r8data(  50) = 10.0d-3
       ikyadr(  76) = 50
       ikytyp(  76) = 1
       grcpky(  77) = 'amsq'
       r8data(  51) = 200.0d-3
       ikyadr(  77) = 51
       ikytyp(  77) = 1
       grcpky(  78) = 'ambq'
       r8data(  52) = 4.3d0
       ikyadr(  78) = 52
       ikytyp(  78) = 1
       grcpky(  79) = 'agh'
       r8data(  53) = 1000.d0
       ikyadr(  79) = 53
       ikytyp(  79) = 1
       grcpky(  80) = 'alpha'
       r8data(  54) = 1.0d0/128.07d0
       ikyadr(  80) = 54
       ikytyp(  80) = 1
       grcpky(  81) = 'alphas'
       r8data(  55) = 0.12d0
       ikyadr(  81) = 55
       ikytyp(  81) = 1
       grcpky(  82) = 'process'
       c8data(   0) = 'eceNuqdQ'
       ikyadr(  82) = 0
       ikytyp(  82) = 2
       grcpky(  83) = 'chrgconj'
       i4data(  26) = 1
       ikyadr(  83) = 26
       ikytyp(  83) = 0
       return
       end
************************************************************************
* main program for SPRING 5.1
      subroutine grcsp0(ithprc)
      implicit real*8(a-h,o-z)

      include 'inclk.f'
      include 'inclpi.f'
      common / knmflg / knmgvs, knmhst, knmsph, knmisr
      common / grcspc / jmxtry, jchrgc

************************************************************************
*               DO NOT CHANGE following Flags.
      knmgvs = 1
      knmhst = 0
      knmsph = 0
      knmisr = 0
************************************************************************
*               initialization of BASES/SPRING 5.1
************************************************************************
*=======================================================================
*          initialization of bases by calling bsinit
*=======================================================================
*         -------------
           call bsinit
*         -------------
*=======================================================================
*          read the probability information from the file
*=======================================================================
*  for file open
*         ----------------------
           call usrprm( ithprc )
*         ----------------------
*          lun = 23
*          open(lun,file='bases.data',status='old',form='unformatted')
*         -------------
           call bsread( lubsdt )
*         -------------
*          close( lun )

*=======================================================================
*      initialization of parameters
*          for kinematics and matrix elements
*      initialization of histograms
*=======================================================================
*         ------------------------------
           call userin( lusprl , ithprc)
*         ------------------------------
*=======================================================================
*     Set parameters for LUND from GRACE
*=======================================================================
*         ---------------
           call gr2lnd
*         ---------------
*         ---------------
           call drnset(jseed)
*         ---------------

c----------------------------------------------
c     generated by grcpar
c----------------------------------------------
      jmxtry = i4data(ikyadr( 25))
      jchrgc = i4data(ikyadr( 83))
c----------------------------------------------
c     set   jchrgc
c----------------------------------------------
      if( jchrgc .lt. 0 . or.
     .    jchrgc .gt. 1 ) then
              print *,'jchrgc = ',jchrgc
              call grcerr(1,' invalid parm: jchrgc')
      endif
      return
      end
*=======================================================================
*     Event Generation
*=======================================================================
      subroutine grcsp
      implicit real*8(a-h,o-z)
      common / grcspc / jmxtry, jchrgc
      external func

      call spring( func, jmxtry )

      call spdetc

      call spdeth

      call sp2lnd

      return
      end
* File incl1.f generated by GRACE Ver. 2.00(37)        1996/05/14/12:00
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      parameter (loutgo =  2, lincom =  1)
      parameter (lantip = -1, lprtcl =  1)
      parameter (lscalr =  1)
      parameter (lepexa =  2, lepexw =  3, lepexz =  3, lepexg =  2)
      parameter (lepina =  4, lepinw =  4, lepinz =  4, leping =  3)
      parameter (lextrn =  2, lintrn =  4)

* table of amplitudes
      parameter (ngraph =144)
      parameter (nextn  =6)

* number of color base
      parameter (ncbase =2)

* number of all helicity states
      parameter (lag    =64)
      parameter (ngrpsq = ngraph*ngraph)
      common /amslct/jselg(ngraph), jgraph, jhiggs,jgluon

      common /amgrph/ agcwrk(0:lag-1),agc(0:lag-1,0:ncbase-1),
     &              aprop,ancp(ngraph),ansp(0:ngraph)
     &             ,cfmtx(0:ncbase-1,0:ncbase-1)
      common /amgrpi/igraph(ngraph)
      complex*16 agc, agcwrk, aprop
      common /amcplc/     cqed,     cqcd,     czww,     caww,     cggg,
     &                   cwwaa,    cwwza,    cwwzz,    cwwww,    cgggg,
     &                    cwhm,     cwhp,     cwym,     cwyp,     czpm,
     &                    capm,     czhy,     chww,     chzz,     cwzm,
     &                    cwam,     cwzp,     cwap,    cwwhh,    czzhh,
     &                   cwzhm,    cwzhp,    cwahm,    cwahp,    cwwyy,
     &                   czzyy,    cwzym,    cwzyp,    cwaym,    cwayp,
     &                   cwwpm,    czzpm,    caapm,    czapm,     chyy,
     &                    chhh,    chhhh,    cyyyy,    cpmyy,    chhpm,
     &                   chhyy,    cpmpm,     cwne,     cwnm,     cwnt,
     &                    cwel,     cwmu,     cwta,     cwuq,     cwcq,
     &                    cwtq,     cwdq,     cwsq,     cwbq,     cael,
     &                    camu,     cata,     cauq,     cacq,     catq,
     &                    cadq,     casq,     cabq,     czne,     cznm,
     &                    cznt,     czel,     czmu,     czta,     czuq,
     &                    czcq,     cztq,     czdq,     czsq,     czbq
      common /amcplc/     cguq,     cgdq,     cgcq,     cgsq,     cgbq,
     &                    cgtq,     cmmu,     cmta,     cpmu,     cpta,
     &                    cmuq,     cmcq,     cmtq,     cpdq,     cpsq,
     &                    cpbq,     chmu,     chta,     chuq,     chcq,
     &                    chtq,     chdq,     chsq,     chbq,     cymu,
     &                    cyta,     cyuq,     cycq,     cytq,     cydq,
     &                    cysq,     cybq,    cwczp,    cwcmz,    cwcap,
     &                   cwcma,    cwczm,    cwcpz,    cwcam,    cwcpa,
     &                   czcmm,    czcpp,    cacmm,    cacpp,    cgcgg,
     &                   cpczp,    cpcap,    cpcmz,    cmczm,    cmcam,
     &                   cmcpz,    cycmm,    cycpp,    chcmm,    chcpp,
     &                   chczz

      complex*16          cqed,     cqcd,     czww,     caww,     cggg,
     &                   cwwaa,    cwwza,    cwwzz,    cwwww,    cgggg,
     &                    cwhm,     cwhp,     cwym,     cwyp,     czpm,
     &                    capm,     czhy,     chww,     chzz,     cwzm,
     &                    cwam,     cwzp,     cwap,    cwwhh,    czzhh,
     &                   cwzhm,    cwzhp,    cwahm,    cwahp,    cwwyy,
     &                   czzyy,    cwzym,    cwzyp,    cwaym,    cwayp,
     &                   cwwpm,    czzpm,    caapm,    czapm,     chyy,
     &                    chhh,    chhhh,    cyyyy,    cpmyy,    chhpm,
     &                   chhyy,    cpmpm,  cwne(2),  cwnm(2),  cwnt(2),
     &                 cwel(2),  cwmu(2),  cwta(2),  cwuq(2),  cwcq(2),
     &                 cwtq(2),  cwdq(2),  cwsq(2),  cwbq(2),  cael(2),
     &                 camu(2),  cata(2),  cauq(2),  cacq(2),  catq(2),
     &                 cadq(2),  casq(2),  cabq(2),  czne(2),  cznm(2),
     &                 cznt(2),  czel(2),  czmu(2),  czta(2),  czuq(2),
     &                 czcq(2),  cztq(2),  czdq(2),  czsq(2),  czbq(2)
      complex*16       cguq(2),  cgdq(2),  cgcq(2),  cgsq(2),  cgbq(2),
     &                 cgtq(2),  cmmu(2),  cmta(2),  cpmu(2),  cpta(2),
     &                 cmuq(2),  cmcq(2),  cmtq(2),  cpdq(2),  cpsq(2),
     &                 cpbq(2),  chmu(2),  chta(2),  chuq(2),  chcq(2),
     &                 chtq(2),  chdq(2),  chsq(2),  chbq(2),  cymu(2),
     &                 cyta(2),  cyuq(2),  cycq(2),  cytq(2),  cydq(2),
     &                 cysq(2),  cybq(2),    cwczp,    cwcmz,    cwcap,
     &                   cwcma,    cwczm,    cwcpz,    cwcam,    cwcpa,
     &                   czcmm,    czcpp,    cacmm,    cacpp,    cgcgg,
     &                   cpczp,    cpcap,    cpcmz,    cmczm,    cmcam,
     &                   cmcpz,    cycmm,    cycpp,    chcmm,    chcpp,
     &                   chczz


* Momenta of external particles
      common /amextr/pe1(4),pe2(4),pe3(4),pe4(4),pe5(4),pe6(4),
     &               prod(nextn, nextn)

      common /smextp/ps1,ew1,ce1,ps2,ew2,ce2,ps3,ew3,ce3,ps4,ew4,ce4,
     &               ps5,ew5,ce5,ps6,ew6,ce6

      real*8     ps1(4,2), ew1(1)
      complex*16 ce1(2,2)
      real*8     ps2(4,2), ew2(1)
      complex*16 ce2(2,2)
      real*8     ps3(4,2), ew3(1)
      complex*16 ce3(2,2)
      real*8     ps4(4,2), ew4(1)
      complex*16 ce4(2,2)
      real*8     ps5(4,2), ew5(1)
      complex*16 ce5(2,2)
      real*8     ps6(4,2), ew6(1)
      complex*16 ce6(2,2)

* Switch of gauge parameters
      common /smgaus/igau00,igauab,igauwb,igauzb,igaugl
      common /smgaug/agauge(0:4)

* Normalization
      common /smdbgg/fknorm,fkcall,nkcall

* Calculated table of amplitudes
      common /smatbl/av, lt, indexg
      complex*16 av(0:lag-1)
      integer    lt(0:nextn), indexg(nextn)

* Spin average
      common /amspin/aspin, jhs(nextn), jhe(nextn), jcpol(nextn)

C------ inclan.f for user
       parameter( MPROC = 76 )
       common /grcusr/ xscton(MPROC), xscter(MPROC)
       common /grcusi/ mulprc(0:MPROC), ichgcj(MPROC), mevent(MPROC)
c----------------------------------------------
c      Initialzation table generated by grcpars
c----------------------------------------------
* inclgi.f 
      parameter( maxadr = 629 )
      parameter( maxprt = 24 )
      parameter( maxgen = 33 )
      parameter( maxnam = 57 )
      parameter( maxprc = 76 )
      common /grcpdt/ idat(0:maxadr-1),ichg(0:maxprt-1),
     .                iptr(0:maxnam-1),iprc(0:maxprc-1,2),
     .                iprclt(0:maxprc-1)
      character*2  name
      common /grcpdc/ name(0:maxnam-1)
      character*8  prcnms
      common /grcppn/ prcnms(0:maxprc-1)
*970615:TI:merge
*970419:TI:kmcntl
* File inclk.f generated by GRACE Ver. 2.00(37)        1996/05/14/12:00
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
* masses and width of particles
      common /ammass/   amw,   amz,   ama,   amg,   amh,   amx,   amy,
     &                 amne,  amnm,  amnt,  amel,  ammu,  amta,  amuq,
     &                 amcq,  amtq,  amdq,  amsq,  ambq,  amcp,  amcm,
     &                 amcz,  amca,  amcg

      common /amgmma/   agw,   agz,   agh,   agx,   agy,  agcq,  agtq,
     &                 agsq,  agbq,  agcp,  agcm,  agcz

      common /amcnst/ pi, pi2, rad, gevpb, alpha, alphas, alpha0
      common /amreg / mxreg
      common /amopts/ jtgamm, jano3v, jcolmb, jqcdcr
      common /amoptc/ colmbf
      common /amoptm/ jqmass,jlmass
      common /aman3v/ ang1a, ang1z, ankaa, ankaz, andka, andkz,
     &                anlma, anlmz
      common /amoptj/ jdecay, jhadrn, jshowr
      common /amopti/ eisr

* external particles name
      character*16    kmprtc
      common /kmprt1/ kmprtc(6)
      common /kmprt2/ kmprtl(6)

* QEDPS flags
      common /amoptq/ jctype, jqedps

* masses of external particles
      common /kmmass/ amass1(6), amass2(6)

* charge(*3) and KFcode of external particles
      common /kminfo/ kcharg(6), kfcode(6)

* Color string information
      common /kmcsti/ kmcbas, kmcbmx, kmcstr(4,0:1), icinfo(6), icolst
      common /grc4fc/ jcanon, jschem
      common /grcsed/ jseed
      common /grcfil/ lubsrl, lubsdt, lubshb, lusprl, lusphb

*** ------------- for two-photon
* external,internal particle momenta
      common /kmmomt/ppi2 ,ppi3 ,ppi4 ,ppi5 ,ppi6 ,ppi7 ,ppi8 ,ppi9 
     .,  ppi10,ppi11,ppi12,ppi13,ppi14,ppi15,ppi16,ppi17,ppi18,ppi19
     .,  ppi20,ppi21,ppi22,ppi23,ppi24,ppi25,ppi26,ppi27,ppi28,ppi29
     .,  ppi30,ppi31,ppi32,ppi33,ppi34,ppi35,ppi36,ppi37,ppi38,ppi39
     .,  ppi40,ppi41,ppi42,ppi43,ppi44,ppi45,ppi46,ppi47,ppi48,ppi49
     .,  ppi50,ppi51,ppi52,ppi53,ppi54,ppi55,ppi56,ppi57,ppi58,ppi59
     .,  ppi60,ppi61,ppi62,ppi63
      dimension          ppi2(4) ,ppi3(4) ,ppi4(4)
     .,ppi5(4) ,ppi6(4) ,ppi7(4) ,ppi8(4) ,ppi9(4)
     .,ppi10(4),ppi11(4),ppi12(4),ppi13(4),ppi14(4)
     .,ppi15(4),ppi16(4),ppi17(4),ppi18(4),ppi19(4)
     .,ppi20(4),ppi21(4),ppi22(4),ppi23(4),ppi24(4)
     .,ppi25(4),ppi26(4),ppi27(4),ppi28(4),ppi29(4)
     .,ppi30(4),ppi31(4),ppi32(4),ppi33(4),ppi34(4)
     .,ppi35(4),ppi36(4),ppi37(4),ppi38(4),ppi39(4)
     .,ppi40(4),ppi41(4),ppi42(4),ppi43(4),ppi44(4)
     .,ppi45(4),ppi46(4),ppi47(4),ppi48(4),ppi49(4)
     .,ppi50(4),ppi51(4),ppi52(4),ppi53(4),ppi54(4)
     .,ppi55(4),ppi56(4),ppi57(4),ppi58(4),ppi59(4)
     .,ppi60(4),ppi61(4),ppi62(4),ppi63(4)
      common /kmmom2/pqs2 ,     pqs4 ,     pqs6 ,     pqs8       
     .,    pqs10,     pqs12,     pqs14,     pqs16,     pqs18      
     .,    pqs20,     pqs22,     pqs24,     pqs26,     pqs28      
     .,    pqs30,     pqs32,     pqs34,     pqs36,     pqs38      
     .,    pqs40,     pqs42,     pqs44,     pqs46,     pqs48      
     .,    pqs50,     pqs52,     pqs54,     pqs56,     pqs58      
     .,    pqs60,     pqs62     

*add 
*970419
      common/kmcntl/iresns(4),icos3,icosq3,icos5,isr,iswap,ident,iphi6
     .,ieeee,i34,itag,isym

*add
*970615
      common /kmcnt2/kimtyp,jit1,jit2,jncall
*     common /kinem1/s,w,fact
      common /cut001/coscut(2,4),engyct(2,4),amasct(2,6),aresns(2,4)
     .,opncut,swapm2
      parameter( MPROC = 76 )
      integer ars1md,ars2md,ars3md,ars4md
      common /ckindi/ 
     .  irs1d(0:MPROC),ars1md(0:MPROC),irs2d(0:MPROC),ars2md(0:MPROC),
     .  irs3d(0:MPROC),ars3md(0:MPROC),irs4d(0:MPROC),ars4md(0:MPROC),
     .  ics3d(0:MPROC),ics5d(0:MPROC),iph6d(0:MPROC),icq3d(0:MPROC),
     .  iswpd(0:MPROC),idntd(0:MPROC),jtgmd(0:MPROC),kinmt(0:MPROC),
     .  iit1(0:MPROC),iit2(0:MPROC),incal(0:MPROC),kclmb(0:MPROC),
     .  kqedps(0:MPROC)
      common /ckindr/ swpmd(0:MPROC)
      common /kgrc4f/ jkclmb,jktype
*----- inclpd.f ---------------------------------------------------
      parameter   ( MPROC  =  76 )
*     parameter   ( NGRAPH = 144 )
      integer      ngd(0:MPROC)
      character*16 kmpr_c(0:MPROC,6)
      integer      kmpr_l(0:MPROC,6)
      integer      amas_1(0:MPROC,6)
      integer      kcha_g(0:MPROC,6)
      integer      kfco_e(0:MPROC,6)
      real*8       cf_mtx(0:MPROC,0:1,0:1)
      integer      kmcb_s(0:MPROC)
      integer      kmcb_x(0:MPROC)
      integer      kmcs_r(0:MPROC,4,0:1)
      integer      kdiagr(0:MPROC,20,NGRAPH)

      common/cprdbi/ngd,kmpr_l,amas_1,kcha_g,kfco_e,
     &              kmcb_s,kmcb_x,kmcs_r,kdiagr
      common/cprdbd/cf_mtx
      common/cprdbc/kmpr_c
c----------------------------------------------
c     Initialzation table generated by grcpar
c----------------------------------------------
      parameter( maxact =  84 )
      parameter( maxdi4 =  27 )
      parameter( maxdr8 =  56 )
      parameter( maxdc8 =   1 )
       character*12 grcpky(0:maxact-1)
            integer i4data(0:maxdi4-1)
             real*8 r8data(0:maxdr8-1)
        character*8 c8data(0:maxdc8-1)
      common /cgrcky/ grcpky
      common /cgrci4/ i4data
      common /cgrcr8/ r8data
      common /cgrcc8/ c8data
      common /cgrcwk/ ikyadr(0:maxact-1),ikytyp(0:maxact-1),
     .                keytch(0:maxact-1)

C97/06/15:TI: seperate 2 routines (kinctc,kinctu)
C97/06/11:TI: replace ibase by knmhst
C97/06/09:TI: xhinit 1->NWILD
C97/05/06:TI: ibases
C97/04/19:TI: Entry name is changed  "kinit" --> "kinit0" (for ALEPH)
C97/04/19:TI: KMCNTL --> inclk.f
C96/01/27:TI:add Kimtyp=6 for eeeeee
C96/01/17:TI:debug
      SUBROUTINE kinit0(lun)
C---------------------------------------------------------------------
C   GRACE System Library File
C   KINEM No. : 4007
C   Date      : 1996.01.11  ; Modified from 4006 to fit for QEDPS
C   Author    : Y.Kurihara
C   Update    : 1996.02.05 YK TI, Commmon kinit both for sf and ps. 
C   Update    : 1996.02.14 YK ; put common/kinemf/ and check knmgvs.
C---------------------------------------------------------------------
      IMPLICIT REAL*8(A-H,O-Z)
 
* BASES100 
      PARAMETER ( MXDIM = 100 )
      COMMON / LOOP0 / LOOP
      COMMON / BPARM1 / XL(MXDIM),XU(MXDIM),NDIM,NWILD,
     &                 IG(MXDIM),NCALL
      COMMON / BPARM2 / ACC1,ACC2,ITMX1,ITMX2
      COMMON / BASE3 / SI,SI2,SWGT,SCHI,SCALLS,ATACC,NSU,IT,WGT
 
      include 'incl1.f'
      INCLUDE 'inclk.f'
      include 'inclpi.f'

      common / knmflg / knmgvs, knmhst, knmsph, knmisr
      common / knmfil / numfil
      common/ninfo/ nodeid, numnod
      data iprint/0/
      data lun6/6/
      CHARACTER XSTR*14
*-----------------------------------------------------------------------
      COMMON/KINEM1/S,W,FACT
*     common /kmcnt2/kimtyp,jit1,jit2,jncall
*     COMMON/CUT001/COSCUT(2,4),ENGYCT(2,4),AMASCT(2,6),ARESNS(2,4)
*    .,opncut,swapm2
*- QEDPS ---------------------------------------------------------------
      common/cutqp /ips,nobpho,cospho,ephoct,cosopn
      common/QPRNDM/xrnd(101),ipnt,irdmax
      COMMON/QEDPS1/NALP,NQED
     .,             Q2MAX,Q2MIN,PHMIN,Q02,Q02M
     .,             IBR,NPH,iradi(10)

*-----------------------------------------------------------------------
*     parsing  (Don't touch)
*-----------------------------------------------------------------------
            w = r8data(ikyadr( 26))
         eisr = r8data(ikyadr( 27))
         acc1 = r8data(ikyadr( 28))
         acc2 = r8data(ikyadr( 29))
*-----------------------------------------------------------------------
* 4-body kinematics :
*
*  Integration variables
*        q1**2, q2**2
*        cos(theq1), phiq1(=0)in p1-p2 CM frame
*        cos(thep3), phip3   in p3-p4 CM frame
*        cos(thep5), phip5             in p5-p6 CM frame
*
*
*
*       P1 \\              *------- P3
*           \\            / \\
*            \\          /   \\----  P4
*             \\  ****  /
*              >******<
*             /  ****  \\
*            /          \\   /-----P5
*           /            \\ /
*       P2 /              *------- P6
*
*--- 1. Initialize constants for kinematics.
* S = (P1+P2)**2
* W = SQRT(S)
*     W = 190.d0
*     if ( knmgvs .eq. 1 ) w = energy
      S = W*W
      totmas=amass1(3)+amass1(4)+amass1(5)+amass1(6)
      if(totmas.gt.w) then
	write(6,*)' KINEM:WARNING!!'
	write(6,*)
     .' CM energy is less than the sum of final particle masses.'
	stop
      endif
*---------------------------------------------------------------
* Experimental CUTS (angle,opening-angle,energy,invariant mass)
*---------------------------------------------------------------
      if( jcanon .eq. 1 ) then 
c...    canonical cut
          call kinctc
       else
c... No canonical cut
          call kinctu
       endif

*-----------------------------------------------------------------------
*    Defaults Flags/paramters are given by Database
*-----------------------------------------------------------------------
*******************************
* Q2 singularity treatment    *
*******************************
* no-singularity           : IRESNS= 0
* narrow resonance         : IRESNS= 1
* 1/Q2 singularity         : IRESNS=-1
* resonance+flat           : IRESNS= 2
* resonance+1/Q2           : IRESNS= 3
* Particle 3-4
*     IRESNS(1)  = 1

*     IF(IRESNS(1).GE.1) THEN
C If you want treat narrow resonance, you should set resonance mass
C and width.
*       ARESNS(1,1)=amw
*       ARESNS(2,1)=agw
*     END IF

* Particle 5-6
*     IRESNS(2)  = 1
*     IF(IRESNS(2).GE.1) THEN
C If you want treat narrow resonance, you should set resonance mass
C and width.
*       ARESNS(1,2)=amw
*       ARESNS(2,2)=agw
*     END IF

* Particle 3-6
*     IRESNS(3)  = 0
*     IF(IRESNS(3).GE.1) THEN
C If you want treat narrow resonance, you should set resonance mass
C and width.
*       ARESNS(1,3)=amz
*       ARESNS(2,3)=agz
*     END IF

* Particle 4-5
*     IRESNS(4)  = 0
*     IF(IRESNS(4).GE.1) THEN
C If you want treat narrow resonance, you should set resonance mass
C and width.
*       ARESNS(1,4)=amz
*       ARESNS(2,4)=agz
*     END IF

C

* treatment for P3
*  D=-(p3-p1)**2
*
*  ICOS3= 0   : no singularity 
*       = 1   : 1/D from p1
*       = 2   : for two-photon processes
*     -------
*     icos3=0
*     -------
* For the digrma as shown below,
*
*       P1 ----------------------- P3
*               |          
*               |----------------  P5 or P6
*               | 
*               |  t,u 
*               |----------------  P6 or P5
*               |           
*       P2 ----------------------  P4
* treatment for P5,P6
*  T=-(P1-P3-P5)**2
*  U=-(P1-P3-P6)**2
*
*  ICOS5= 0   : no singularity 
*       = 1   : 1/T     from P1-P3
*       = 2   : 1/T+1/U from P1-P3
*
*       = 3   : M45^2=(p4+p5)^2 : flat
*       = 4   : M45^2=(p4+p5)^2 : resonance
*       = 5   : M45^2=(p4+p5)^2 : resonance+1/q^2
*       = 6   : M45^2=(p4+p5)^2 : resonance+flat
* 
*     -------
*     icos5=0
*     -------
* 
*  IPHI6= 0   : no singularity
*       = 1   : M36^2=(p3+p6)^2 : flat
*       = 2   : M36^2=(p3+p6)^2 : resonance
*       = 3   : M36^2=(p3+p6)^2 : resonance+1/q^2
*       = 4   : M36^2=(p3+p6)^2 : resonance+flat
* 
*     -------
*     iphi6=0
*     -------
      if(icos5.lt.3 .and. iphi6.ne.0) then
         write(6,*)
     .   'WARNING: When IPHI6 is NOT zero, ICOS5 >= 3 ' 
         stop
      endif
* For the digrma as shown below,
*
*       P1 ----------------------- P3
*               |         \\
*               |           \\----  P4
*               | 
*               |  t = -T
*               | 
*               |           /-----P5
*               |          /
*       P2 ---------------------- P6
*
*  T is used as integration variables instead of cos(theq1).
*
*                 integration       singularity
*   ICOSQ3 = 0   : cos(theq)          non
*          = 1   : T                   1/T
*          = 2   : T,U                 1/T+1/D
*     ----------
*     icosq3 = 2
*     ----------
* Swaping two particles (particle 4 and 6)
*  iswap = 0  ; no swaping
*        = 1  ; swaping two particles
*     ---------
*     iswap = 0
*     ---------
*     ----------------
*     swapm2 = -999.d0
*     ----------------
* Identical particle (3-5 4-6)
*     ident = 0 : no identical particles
*           = 1 :    identical particles (devided by 4)
*           = 2 :    identical particles (E3<E5, E4>E6)
*           = 3 :    identical particles (E3>E5, E4>E6)
*     ---------
*     ident = 0
*     ---------
* for two-photon kinematics
*     
      if(kimtyp.eq.2 .or. kimtyp.eq.6) call k2nit(lun)
*-- Structure Function -----------------------------------------
*     if( jqedps .eq. 0) then
*         isr = iisr
*     else
*-- QEDPS ------------------------------------------------------
      if( jqedps .ne. 0) then
C QEDPS 
C  IPS = 0 : No radiative correction
C      = 1 : Initial state radiation
C      = 2 : Initial and final state radiation
*     ips=iips
*     print *,' ips @ kinit ',ips
C Particle # for final radiation.
      do 1500 i=3,6
       if( ips.eq.2 .and.
     .    (abs(kfcode(3)).eq.11 .or.
     .     abs(kfcode(3)).eq.13)     ) then
         iradi(i)=1
       else
         iradi(i)=0
       end if
1500  continue
C CUTS FOR RADIATED PHOTONS
C NUMBER OF OBSERVED PHOTON (-1 for no restriction)
      NOBPHO= -1
C If NOBPHO is not -1, cuts below are relivant.
C ANGULAR CUT FOR OBSERVED PHOTON
      COSPHO=cos(1.d0*rad)
C ENERGY CUT  FOR OBSERVED PHOTON
      EPHOCT=1.d-1
C PHOTON-final particles OPENING ANGLE
      ANGL=0.d0
      COSOPN=COS(ANGL*RAD)
      end if

*TI debug
* Anomalous coupling
*     if(jano3v.eq.1) then
*        ANKAa=aankaa
*        ANDKa=1.0d0-ANKAa
*        ANLMa=aanlma
*        ANKAz=aankaz
*        ANDKz=1.0d0-ANKAz
*        ANLMz=aanlmz
*     end if

      
*     if(iprint.eq.1.and.lun.gt.0) then
      if(iprint.eq.1.and.nodeid.eq.0) then
      WRITE(lun6,*)'*****************************'
      WRITE(lun6,*)'* Kinematics initialization *'
      WRITE(lun6,*)'*****************************'
      WRITE(lun6,*)'* particle mass ',amass1
      WRITE(lun6,*)'* CM Energy ',W
      WRITE(lun6,*)'* COS CUT '
      WRITE(lun6,'(2F10.3)')COSCUT
      WRITE(lun6,*)'* ENERGY CUT '
      WRITE(lun6,'(2F10.3)')ENGYCT
      WRITE(lun6,*)'* INVARIANT MASS CUT '
      WRITE(lun6,'(2F10.3)')AMASCT
       WRITE(lun6,*)'* IRESNS ',iresns
       WRITE(lun6,*)'* ARESNS 1 ',(aresns(k,1),k=1,2)
       WRITE(lun6,*)'* ARESNS 2 ',(aresns(k,2),k=1,2)
       WRITE(lun6,*)'* ARESNS 3 ',(aresns(k,3),k=1,2)
       WRITE(lun6,*)'* ARESNS 4 ',(aresns(k,4),k=1,2)
       WRITE(lun6,*)'* ICOS3 ',icos3
       WRITE(lun6,*)'* ICOS5 ',icos5
       WRITE(lun6,*)'* IPHI6 ',iphi6
       WRITE(lun6,*)'* ICOSQ3 ',icosq3
       WRITE(lun6,*)'* ISWAP ',iswap
       WRITE(lun6,*)'* swapm2 ',swapm2
       WRITE(lun6,*)'* IDENT ',ident
       WRITE(lun6,*)'*'
       if(jqedps.eq.1) then
       WRITE(lun6,*)'* QEDPS :',IPS
       WRITE(lun6,*)'* iradi = ',(iradi(jj),jj=3,6)
       WRITE(lun6,*)'*  Cuts for radiated photons '
       IF(NOBPHO.LT.0) THEN
         WRITE(lun6,*)'* No requirements for photons '
       ELSE
         WRITE(lun6,*)'* Required min. # of photons :',NOBPHO
         WRITE(lun6,*)'* COS(the) cut               :',COSPHO
         WRITE(lun6,*)'* Energy   cut               :',EPHOCT
       END IF
       WRITE(lun6,*)' *'
       end if
      end if
C-----------------------------------------------------------------------
C SET QEDPS PARAMETERS
      if(ips.ge.1)call qpinpt(lun6,iprint)
C Calculation of Sudakov form factor
      if(ips.ge.1)call qpprep(lun6,iprint)
C-----------------------------------------------------------------------
* Following flux factor is for a particle-antiparticle collision
* at s/m**2 >> 1. For an e-gamma collision or low energy interactions
* you should use appropriate formulae.
      VREL = 2
      FLUX = VREL*S
      FACT = GEVPB/FLUX
      if(jqcdcr.eq.1) then
        nqrk=0
        do 2000 I=3,6
         if(iabs(kcharg(i)).eq.1 .or. iabs(kcharg(i)).eq.2) nqrk=nqrk+1
* kchrg will be replaced by kfcode
2000    continue
        nqcdcr=nqrk/2
        FACT=FACT*(1.d0+nqcdcr*alphas/pi)
      end if
 
*----- BASES RELATED INITIALIZATIONS -----------------------------------
*--- 2. Dimension of integration variables.
      if(jqedps.eq.0) then
       if(isr.eq.0) then
          NDIM =   8
          NWILD=   8
       else
          NDIM =  10
          NWILD=  10
       end if
      else
          NDIM =   100
          NWILD=   8
          irdmax=ndim+1
      end if
 
*     print *,'jqedps,isr',jqedps,isr
C-----------------------------------------------------------------------
*--- 3. Region of integration.

        DO 1 I=1,NDIM
         XL(I)  =   0.D0
         XU(I)  =   1.D0
         IG(I)  =   0
1       CONTINUE

        DO 2 I=1,NWILD
         IG(I)  =   1
2       CONTINUE
C-----------------------------------------------------------------------
*--- 4. Number of iterations

       itmx1=jit1
       itmx2=jit2

       ncall=jncall 
 
*     acc1   =  aacc1
*     acc2   =  aacc2
 
*--- 5. Set MXREG : the maximum number of values which are returned
*       by FUNC for one phase space point
 
*     MXREG =   1
*     if(iphi6.ne.0)MXREG=2
*     if(kimtyp .eq. 3 ) MXREG=2
*     if(kimtyp .eq. 4 ) MXREG=2
*     if(kimtyp .eq. 5 ) MXREG=3
      MXREG = 6
 
*--- 6. Set histograms
      
      NX = 50
      numfil = NWILD
         if( knmhst .eq. 1 ) then

*        DO 1111 I=1,NDIM
         DO 1111 I=1,numfil
         WRITE(XSTR, 110) I
  110    FORMAT('X(',I2,') SPECTRUM')
            CALL XHINIT(I+30, 0.d0, 1.0d0, NX, XSTR )
 1111    CONTINUE

         CALL XHINIT(1, 0.d0, w, NX, 'Energy of Particle 3')
         CALL XHINIT(2, 0.d0, w, NX, 'Energy of Particle 4')
         CALL XHINIT(3, 0.d0, w, NX, 'Energy of Particle 5')
         CALL XHINIT(4, 0.d0, w, NX, 'Energy of Particle 6')
         CALL XHINIT(5,-1.d0,1.d0, NX, 'cos_the of Particle 3')
         CALL XHINIT(6,-1.d0,1.d0, NX, 'cos_the of Particle 4')
         CALL XHINIT(7,-1.d0,1.d0, NX, 'cos_the of Particle 5')
         CALL XHINIT(8,-1.d0,1.d0, NX, 'cos_the of Particle 6')
         CALL XHINIT(9, 0.d0, w, NX, 'Mass 3-4 ')
         CALL XHINIT(10, 0.d0, w, NX, 'Mass 5-6 ')
         CALL XHINIT(11, 0.d0, w, NX, 'Mass 3-6 ')
         CALL XHINIT(12, 0.d0, w, NX, 'Mass 4-5 ')
         qqmin=0.d0
         if(jqedps.eq.1 .or. isr.eq.1) then
         CALL XHINIT(13,qqmin,w, NX, 'ds/dQ')
         CALL XHINIT(14,-1.d2,+1.d2, 49, 'ds/dQz')
         end if
         if(jqedps.eq.1) then
         CALL XHINIT(15, 0.d0,30.d0, NX, 'ds/dQt')
         CALL XHINIT(16, 0.d0,30.d0 , NX, 'ds/dE(gamma)')
         CALL XHINIT(17, 0.d0,30.d0 , NX, 'ds/dPt(gamma)')
         end if
         call dhinit(25,0.d0,w,nx,0.d0,w,nx,' 34-36 ') 
         call dhinit(26,0.d0,w,nx,0.d0,w,nx,' 56-45 ')  

         endif

      RETURN
      END
*=======================================================================
*     SET  parameters for  CANONICAL CUT
*=======================================================================
      subroutine kinctc

      IMPLICIT REAL*8(A-H,O-Z)
      include 'inclk.f'
      COMMON/KINEM1/S,W,FACT
*******************************
* Angular cuts in Lab-frame.  *
*******************************
* Opening anglu cut between two charged leptons and
* between charged lepton and quarks.
       opncut     =  cos(5.d0*rad) 
*
      do 1000 ipart=3,6
       angcut= 0
       if(iabs(kcharg(ipart)).eq.3)angcut=10
* minimum cos  cut
       COSCUT(1,ipart-2)= -cos(angcut*rad)
* maximum cos  cut
       COSCUT(2,ipart-2)=  cos(angcut*rad)
*******************************
* Energy  cuts in Lab-frame.  *
*******************************
* minimum energy cut
       if(iabs(kcharg(ipart)).eq.0) then
       emin=0
      else if(iabs(kcharg(ipart)).eq.3) then
       emin=1.d0
      else
       emin=3.d0
      end if
      ENGYCT(1,ipart-2) = emin
* maximum energy cut
      ENGYCT(2,ipart-2) = W
1000  continue
 
*************************
* Cut on invariant mass *
*************************
* Particle 3-4
* minimum
      if( (iabs(kcharg(3)).eq.2.or.iabs(kcharg(3)).eq.1) .and.
     .    (iabs(kcharg(4)).eq.2.or.iabs(kcharg(4)).eq.1))then
       AMASCT(1,1)=   5.d0
      else
       AMASCT(1,1)=   AMASS1(3)+AMASS1(4)
      end if
* maximum
      AMASCT(2,1)= W-AMASS1(5)-AMASS1(6)
* Particle 5-6
* minimum
      if( (iabs(kcharg(5)).eq.2.or.iabs(kcharg(5)).eq.1) .and.
     .    (iabs(kcharg(6)).eq.2.or.iabs(kcharg(6)).eq.1))then
       AMASCT(1,2)=   5.d0
      else
       AMASCT(1,2)=   AMASS1(5)+AMASS1(6)
      end if
* maximum
      AMASCT(2,2)= W-AMASS1(3)-AMASS1(4)
* Particle 3-5
* minimum
      if( (iabs(kcharg(3)).eq.2.or.iabs(kcharg(3)).eq.1) .and.
     .    (iabs(kcharg(5)).eq.2.or.iabs(kcharg(5)).eq.1))then
       AMASCT(1,3)=   5.d0
      else
       AMASCT(1,3)=   AMASS1(3)+AMASS1(5)
      end if
* maximum
      AMASCT(2,3)= W-AMASS1(4)-AMASS1(6)
* Particle 4-6
* minimum
      if( (iabs(kcharg(4)).eq.2.or.iabs(kcharg(4)).eq.1) .and.
     .    (iabs(kcharg(6)).eq.2.or.iabs(kcharg(6)).eq.1))then
       AMASCT(1,4)=   5.d0
      else
       AMASCT(1,4)=   AMASS1(4)+AMASS1(6)
      end if
* maximum
      AMASCT(2,4)= W-AMASS1(3)-AMASS1(5)
* Particle 3-6
* minimum
      if( (iabs(kcharg(3)).eq.2.or.iabs(kcharg(3)).eq.1) .and.
     .    (iabs(kcharg(6)).eq.2.or.iabs(kcharg(6)).eq.1))then
       AMASCT(1,5)=   5.d0
      else
       AMASCT(1,5)=   AMASS1(3)+AMASS1(6)
      end if
* maximum
      AMASCT(2,5)= W-AMASS1(4)-AMASS1(5)
* Particle 4-5
* minimum
      if( (iabs(kcharg(4)).eq.2.or.iabs(kcharg(4)).eq.1) .and.
     .    (iabs(kcharg(5)).eq.2.or.iabs(kcharg(5)).eq.1))then
       AMASCT(1,6)=   5.d0
      else
       AMASCT(1,6)=   AMASS1(4)+AMASS1(5)
      end if
* maximum
       AMASCT(2,6)= W-AMASS1(3)-AMASS1(6)

      return
      end
*=======================================================================
*     SET  parameters for  User CUTS
*=======================================================================
      subroutine kinctu
      IMPLICIT REAL*8(A-H,O-Z)

      include 'inclk.f'
      include 'inclpi.f'
      COMMON/KINEM1/S,W,FACT
*-------------------------------------------------
*     parsing  (Don't touch)
*-------------------------------------------------
c----------------------------------------------
c     generated by grcpar
c----------------------------------------------
*d      itmx1 = i4data(ikyadr( 22))
*d      itmx2 = i4data(ikyadr( 23))
*d      ncall = i4data(ikyadr( 24))
*x      mxtry = i4data(ikyadr( 25))
*      opncut = r8data(ikyadr( 30))
       opncta = r8data(ikyadr( 30))
       thct31 = r8data(ikyadr( 31))
       thct32 = r8data(ikyadr( 32))
       thct41 = r8data(ikyadr( 33))
       thct42 = r8data(ikyadr( 34))
       thct51 = r8data(ikyadr( 35))
       thct52 = r8data(ikyadr( 36))
       thct61 = r8data(ikyadr( 37))
       thct62 = r8data(ikyadr( 38))
       enct31 = r8data(ikyadr( 39))
       enct32 = r8data(ikyadr( 40))
       enct41 = r8data(ikyadr( 41))
       enct42 = r8data(ikyadr( 42))
       enct51 = r8data(ikyadr( 43))
       enct52 = r8data(ikyadr( 44))
       enct61 = r8data(ikyadr( 45))
       enct62 = r8data(ikyadr( 46))
       vct341 = r8data(ikyadr( 47))
       vct342 = r8data(ikyadr( 48))
       vct561 = r8data(ikyadr( 49))
       vct562 = r8data(ikyadr( 50))
       vct351 = r8data(ikyadr( 51))
       vct352 = r8data(ikyadr( 52))
       vct461 = r8data(ikyadr( 53))
       vct462 = r8data(ikyadr( 54))
       vct361 = r8data(ikyadr( 55))
       vct362 = r8data(ikyadr( 56))
       vct451 = r8data(ikyadr( 57))
       vct452 = r8data(ikyadr( 58))
c----------------------------------------------
c     check by owner
c----------------------------------------------
C     nothing at this moment.
c----------------------------------------------
c     setting
c----------------------------------------------
      if( opncta .lt. 0.0d0 .or. opncta .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : opncut')
      endif
      opncut     =  cos(opncta*rad)

      if( thct31 .lt. 0.0d0 .or. thct31 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct31')
      endif
      if( thct32 .lt. 0.0d0 .or. thct32 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct32')
      endif
      if( thct32 .gt. thct31 ) then
          call grcerr(2,' Invaid parameter : thct32 > thct31')
      endif
      coscut(1,1)=  cos(thct31*rad)
      coscut(2,1)=  cos(thct32*rad)

      if( thct41 .lt. 0.0d0 .or. thct41 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct41')
      endif
      if( thct42 .lt. 0.0d0 .or. thct42 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct42')
      endif
      if( thct42 .gt. thct41 ) then
          call grcerr(2,' Invaid parameter : thct42 > thct41')
      endif
      coscut(1,2)=  cos(thct41*rad)
      coscut(2,2)=  cos(thct42*rad)

      if( thct51 .lt. 0.0d0 .or. thct51 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct51')
      endif
      if( thct52 .lt. 0.0d0 .or. thct52 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct52')
      endif
      if( thct52 .gt. thct51 ) then
          call grcerr(2,' Invaid parameter : thct52 > thct51')
      endif
      coscut(1,3)=  cos(thct51*rad)
      coscut(2,3)=  cos(thct52*rad)

      if( thct61 .lt. 0.0d0 .or. thct61 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct61')
      endif
      if( thct62 .lt. 0.0d0 .or. thct62 .gt. 180.0d0 ) then
          call grcerr(2,' Invaid parameter : thct62')
      endif
      if( thct62 .gt. thct61 ) then
          call grcerr(2,' Invaid parameter : thct62 > thct61')
      endif
      coscut(1,4)=  cos(thct61*rad)
      coscut(2,4)=  cos(thct62*rad)

      if( enct31 .lt. 0.0d0 ) then
          engyct(1,1) = amass1(3)
      else
          engyct(1,1) = enct31
      endif
      if( enct32 .lt. 0.0d0 ) then
          engyct(2,1) = w
      else
          engyct(2,1) = enct32
      endif
      if( engyct(1,1) .gt. engyct(2,1) ) then
          call grcerr(2,' Invaid parameter : enct31 > enct32')
      endif

      if( enct41 .lt. 0.0d0 ) then
          engyct(1,2) = amass1(4)
      else
          engyct(1,2) = enct41
      endif
      if( enct42 .lt. 0.0d0 ) then
          engyct(2,2) = w
      else
          engyct(2,2) = enct42
      endif
      if( engyct(1,2) .gt. engyct(2,2) ) then
          call grcerr(2,' Invaid parameter : enct41 > enct42')
      endif

      if( enct51 .lt. 0.0d0 ) then
          engyct(1,3) = amass1(5)
      else
          engyct(1,3) = enct51
      endif
      if( enct52 .lt. 0.0d0 ) then
          engyct(2,3) = w
      else
          engyct(2,3) = enct52
      endif
      if( engyct(1,3) .gt. engyct(2,3) ) then
          call grcerr(2,' Invaid parameter : enct51 > enct52')
      endif

      if( enct61 .lt. 0.0d0 ) then
          engyct(1,4) = amass1(6)
      else
          engyct(1,4) = enct61
      endif
      if( enct62 .lt. 0.0d0 ) then
          engyct(2,4) = w
      else
          engyct(2,4) = enct62
      endif
      if( engyct(1,4) .gt. engyct(2,4) ) then
          call grcerr(2,' Invaid parameter : enct61 > enct62')
      endif

      if( vct341 .lt. 0.0d0 ) then
          amasct(1,1) = amass1(3)+amass1(4)
      else
          amasct(1,1) = vct341
      endif
      if( vct342 .lt. 0.0d0 ) then
          amasct(2,1) = w - (amass1(5)+amass1(6))
      else
          amasct(2,1) = vct342
      endif
      if( amasct(1,1) .gt. amasct(2,1) ) then
          call grcerr(2,' Invaid parameter : vct341 > vct342')
      endif

      if( vct561 .lt. 0.0d0 ) then
          amasct(1,2) = amass1(5)+amass1(6)
      else
          amasct(1,2) = vct561
      endif
      if( vct562 .lt. 0.0d0 ) then
          amasct(2,2) = w - (amass1(3)+amass1(4))
      else
          amasct(2,2) = vct562
      endif
      if( amasct(1,2) .gt. amasct(2,2) ) then
          call grcerr(2,' Invaid parameter : vct561 > vct562')
      endif

      if( vct351 .lt. 0.0d0 ) then
          amasct(1,3) = amass1(3)+amass1(5)
      else
          amasct(1,3) = vct351
      endif
      if( vct352 .lt. 0.0d0 ) then
          amasct(2,3) = w - (amass1(4)+amass1(6))
      else
          amasct(2,3) = vct352
      endif
      if( amasct(1,3) .gt. amasct(2,3) ) then
          call grcerr(2,' Invaid parameter : vct351 > vct352')
      endif

      if( vct461 .lt. 0.0d0 ) then
          amasct(1,4) = amass1(4)+amass1(6)
      else
          amasct(1,4) = vct461
      endif
      if( vct462 .lt. 0.0d0 ) then
          amasct(2,4) = w - (amass1(3)+amass1(5))
      else
          amasct(2,4) = vct462
      endif
      if( amasct(1,4) .gt. amasct(2,4) ) then
          call grcerr(2,' Invaid parameter : vct461 > vct462')
      endif

      if( vct361 .lt. 0.0d0 ) then
          amasct(1,5) = amass1(3)+amass1(6)
      else
          amasct(1,5) = vct361
      endif
      if( vct362 .lt. 0.0d0 ) then
          amasct(2,5) = w - (amass1(4)+amass1(5))
      else
          amasct(2,5) = vct362
      endif
      if( amasct(1,5) .gt. amasct(2,5) ) then
          call grcerr(2,' Invaid parameter : vct361 > vct362')
      endif

      if( vct451 .lt. 0.0d0 ) then
          amasct(1,6) = amass1(4)+amass1(5)
      else
          amasct(1,6) = vct451
      endif
      if( vct452 .lt. 0.0d0 ) then
          amasct(2,6) = w - (amass1(3)+amass1(6))
      else
          amasct(2,6) = vct452
      endif
      if( amasct(1,6) .gt. amasct(2,6) ) then
          call grcerr(2,' Invaid parameter : vct451 > vct452')
      endif

      return
      end
C97/06/08:TI:add kqedps, jktype
C97/05/06:TI:move ngd to prcdb
C97/04/19:TI:del common/kmcntl/
C97/02/13:TI:remove 77th process
C97/01/27:TI:add kimtyp=6
C----- kinmdb.f ---------------------------------- 96/05/08 (TI) ---
      subroutine kinmdb( ithprc )
*---
*     depends on parsing program (see DON'T TOUCH)
*---
      implicit real*8(a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'
      include 'inclkd.f'
      include 'inclpi.f'

      iresns(1)   = irs1d(ithprc)
      if( iresns(1) .ge. 1 ) then
          aresns(1,1) = akmass(ars1md(ithprc))
          aresns(2,1) = akwdth(ars1md(ithprc))
      else
          aresns(1,1) = 0.0d0
          aresns(2,1) = 0.0d0
      endif
      iresns(2)   = irs2d(ithprc)
      if( iresns(2) .ge. 1 ) then
          aresns(1,2) = akmass(ars2md(ithprc))
          aresns(2,2) = akwdth(ars2md(ithprc))
      else
          aresns(1,2) = 0.0d0
          aresns(2,2) = 0.0d0
      endif
      iresns(3)   = irs3d(ithprc)
      if( iresns(3) .ge. 1 ) then
          aresns(1,3) = akmass(ars3md(ithprc))
          aresns(2,3) = akwdth(ars3md(ithprc))
      else
          aresns(1,3) = 0.0d0
          aresns(2,3) = 0.0d0
      endif
      iresns(4)   = irs4d(ithprc)
      if( iresns(4) .ge. 1 ) then
          aresns(1,4) = akmass(ars4md(ithprc))
          aresns(2,4) = akwdth(ars4md(ithprc))
      else
          aresns(1,4) = 0.0d0
          aresns(2,4) = 0.0d0
      endif

      icos3       = ics3d(ithprc)
      icos5       = ics5d(ithprc)
      iphi6       = iph6d(ithprc)
      icosq3      = icq3d(ithprc)
      iswap       = iswpd(ithprc)
      swapm2      = swpmd(ithprc)
      ident       = idntd(ithprc)
      jtgamm      = jtgmd(ithprc)
      kimtyp      = kinmt(ithprc)
      jit1        = iit1(ithprc)
      jit2        = iit2(ithprc)
      jncall      = incal(ithprc)
*
      jkclmb      = kclmb(ithprc)
      jktype      = kqedps(ithprc)

*==================================================================
*CHECK (jctype)
*     print *,'jctype jktype',jctype,jktype
      if( jctype .gt. jktype ) then
          if( jctype .eq. 2 ) then
              call grcerr(2,
     &  'Isrtype 2 (QEDPSi) cannot be selected for this process: ')

          else if( jctype .eq. 3 ) then
              call grcerr(2,
     &   'Isrtype 3 (QEDPSif) cannot be selected for this process: ')

          endif
      endif
*
      if( jcolmb .eq. 1 ) then
*KEK
       if( jkclmb .eq. 0 ) then
*PG    if( aresns(1,1).ne.amw.or.aresns(1,2).ne.amw) then
           call grcerr(1,
     .'Coulomb Correction parameter is ignored for this process')
        colmbf=0
*----------------------------------------
*KEK RESET flag forCoulomb correction.
        jcolmb=0
*----------------------------------------
        endif
      endif

*------------------------------------
*       Don't touch
*------------------------------------
        mitmx1 = i4data(ikyadr( 22))
        mitmx2 = i4data(ikyadr( 23))
        mncall = i4data(ikyadr( 24))
c----------------------------------------------
c     set   itmx1
c----------------------------------------------
      if(  mitmx1 .lt. 0 ) then
              call grcerr(1,' from Data BASE itmx1')
      else
              jit1 = mitmx1
      endif
c----------------------------------------------
c     set   itmx2
c----------------------------------------------
      if(  mitmx2 .lt. 0 ) then
              call grcerr(1,' from Data BASE itmx2')
      else
              jit2 = mitmx2
      endif
c----------------------------------------------
c     set   ncall
c----------------------------------------------
      if(  mncall .lt. 0 ) then
              call grcerr(1,' from Data BASE ncall')
      else
              jncall = mncall
      endif

*     print *,'jncall = ',jncall
*     print *,'mncall = ',mncall
      return
      end
C 1997/06/15: 1->76, --> 0->75
C 1997/06/08: add kqedps
C     Initilization of kinematics  (1997/03/05)
C     1997/04/02: "kclmb" array , 0(no permition of Coulmb cor.)
C                                 1(permition of Coulmb cor.)
C=======================================================================
C     Initialization of kinematics parameter (depends on energy ...)
C=======================================================================
*
      subroutine knmdbi
      implicit real*8(a-h,o-z)
      include 'inclkd.f'
*
C 1(old 77)  electron,positron,nu-e,nu-e-bar
*   irs[1-4]d(1) ... is dynamically defined in kinem.(04/02)
**    ngd(1)    = 56
*     irs1d(1) = 3
      irs1d(1) = 999
      ars1md(1) = 23
*     irs2d(1) = 4
      irs2d(1) = 999
      ars2md(1) = 23
*     irs3d(1) = 1
      irs3d(1) = 999
      ars3md(1) = 24
*     irs4d(1) = 1
      irs4d(1) = 999
      ars4md(1) = 24
      ics3d(1) = 2
      ics5d(1) = 2
      iph6d(1) = 0
      icq3d(1) = 2
      iswpd(1) = 0
      swpmd(1) = -999.
      idntd(1) = 0
      jtgmd(1) = 1
      kinmt(1) = 5
      iit1 (1) = 7
      iit2 (1) =15
      incal(1) = 80000
*
      kclmb(1) = 0
      kclmb(1) = 1
C 2  electron,nu-e-bar,anti-muon,nu-mu
C 3  electron,nu-e-bar,anti-tau,nu-tau
      do 1002 ip = 2, 3
**          ngd(ip) = 18
          irs1d(ip) = 1
         ars1md(ip) = 24
          irs2d(ip) = 1
         ars2md(ip) = 24
          kclmb(ip) = 1
          irs3d(ip) = -255
         ars3md(ip) = 0
          irs4d(ip) = -255
         ars4md(ip) = 0
          ics3d(ip) = 1
          ics5d(ip) = 0
          iph6d(ip) = 0
          icq3d(ip) = 2
          iswpd(ip) = 0
          swpmd(ip) = -999.
          idntd(ip) = 0
          jtgmd(ip) = 1
          kinmt(ip) = 1
           iit1(ip) = 7
           iit2(ip) = 15
          incal(ip) = 40000
 1002 continue

C 4  nu-mu,anti-muon,muon,nu-mu-bar
C 5  nu-tau,anti-tau,tau,nu-tau-bar
      do 1004 ip = 4, 5
**          ngd(ip) = 20
          irs1d(ip) = 1
         ars1md(ip) = 24
          irs2d(ip) = 1
         ars2md(ip) = 24
          kclmb(ip) = 1
          irs3d(ip) = 1
         ars3md(ip) = 23
          irs4d(ip) = 3
         ars4md(ip) = 23
          ics3d(ip) = 0
          ics5d(ip) = 5
          iph6d(ip) = -999
          icq3d(ip) = 2
          iswpd(ip) = 1
          swpmd(ip) = -999.
          idntd(ip) = 0
          jtgmd(ip) = 0
          kinmt(ip) = 4
           iit1(ip) = 7
           iit2(ip) = 15
          incal(ip) = 40000
 1004 continue

C 6  muon,nu-mu-bar,anti-tau,nu-tau
**    ngd( 6)    = 9
      irs1d( 6) = 1
      ars1md( 6) = 24
      irs2d( 6) = 1
      ars2md( 6) = 24
          kclmb(6) = 1
      irs3d( 6) = -255
      ars3md( 6) = 0
      irs4d( 6) = -255
      ars4md( 6) = 0
      ics3d( 6) = 0
      ics5d( 6) = 0
      iph6d( 6) = 0
      icq3d( 6) = 2
      iswpd( 6) = 0
      swpmd( 6) = -999.
      idntd( 6) = 0
      jtgmd( 6) = 0
      kinmt( 6) = 1
      iit1 ( 6) = 7
      iit2 ( 6) =15
      incal( 6) = 80000

C 7  electron,positron,electron,positron
**    ngd( 7)    = 144
      irs1d( 7) =  2
      ars1md( 7) = 23
      irs2d( 7) = 3
      ars2md( 7) = 23
          kclmb(7) = 0
      irs3d( 7) = -1
*     ars3md( 7) = amtq
      ars3md( 7) = 0
      irs4d( 7) = 0
      ars4md( 7) = 0
      ics3d( 7) = 2
      ics5d( 7) = 2
      iph6d( 7) = 0
      icq3d( 7) = 2
      iswpd( 7) = 0
      swpmd( 7) = -999.
      idntd( 7) = 0
      jtgmd( 7) = 1
      iit1 ( 7) = 7
      iit2 ( 7) =15
      incal( 7) = 80000
*     kinmt( 7) = 2
      kinmt( 7) = 6
*                 ^

C 8  electron,positron,muon,anti-muon
C 9  electron,positron,tau,anti-tau
      do 1008 ip = 8, 9

**    ngd(ip)    = 50
      irs1d(ip) = 2
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 2
      ics5d(ip) = 2
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 1
      kinmt(ip) = 2
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000
 1008 continue


C 10  muon,anti-muon,muon,anti-muon
C 11  tau,anti-tau,tau,anti-tau
      do 1010 ip = 10, 11

**    ngd(ip)    = 68
      irs1d(ip) = 3
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
*     irs3d(ip) = 4
      irs3d(ip) = 3
      ars3md(ip) = 23
*     irs4d(ip) = -1
      irs4d(ip) = 3
      ars4md(ip) = 23
      ics3d(ip) = 0
      ics5d(ip) = 3
      iph6d(ip) = -999
      icq3d(ip) = 2
      iswpd(ip) = 1
      swpmd(ip) = 3.
      idntd(ip) = 4
      jtgmd(ip) = 0
      kinmt(ip) = 3
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 80000
 1010 continue

C 12  muon,anti-muon,tau,anti-tau
**    ngd(12)    = 34
      irs1d(12) = 3
      ars1md(12) = 23
      irs2d(12) = 3
      ars2md(12) = 23
          kclmb(12) = 0
      irs3d(12) = -255
      ars3md(12) = 0
      irs4d(12) = -255
      ars4md(12) = 0
      ics3d(12) = 0
      ics5d(12) = 0
      iph6d(12) = 0
      icq3d(12) = 2
      iswpd(12) = 0
      swpmd(12) = -999.
      idntd(12) = 0
      jtgmd(12) = 0
      kinmt(12) = 1
      iit1 (12) = 7
      iit2 (12) =15
      incal(12) = 80000

C 13  electron,positron,nu-mu,nu-mu-bar
C 14  electron,positron,nu-tau,nu-tau-bar

      do 1013 ip = 13, 14

**    ngd(ip)    = 20
      irs1d(ip) = 3
      ars1md(ip) = 23
      irs2d(ip) = 1
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 2
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 1
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000

 1013 continue

C 15  nu-e,nu-e-bar,muon,anti-muon
C 16  nu-e,nu-e-bar,tau,anti-tau

      do 1015 ip = 15, 16

**    ngd(ip)    = 21
      irs1d(ip) = 1
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
       iit1(ip) = 7
       iit2(ip) = 15
      incal(ip) = 80000
 1015 continue

C 17  nu-tau,nu-tau-bar,muon,anti-muon
C 18  nu-mu,nu-mu-bar,tau,anti-tau
      do 1017 ip = 17, 18

**    ngd(ip)    = 11
      irs1d(ip) = 1
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 80000
 1017 continue

C 19  nu-e,nu-e-bar,nu-e,nu-e-bar
**    ngd(19)    = 36
      irs1d(19) = 1
      ars1md(19) = 23
      irs2d(19) = 1
      ars2md(19) = 23
          kclmb(19) = 0
      irs3d(19) = 1
      ars3md(19) = 23
      irs4d(19) = 1
      ars4md(19) = 23
      ics3d(19) = 0
      ics5d(19) = 4
      iph6d(19) = 0
      icq3d(19) = 0
      iswpd(19) = 1
      swpmd(19) = -999.
      idntd(19) = 2
      jtgmd(19) = 0
      kinmt(19) = 3
      iit1 (19) = 7
      iit2 (19) =15
      incal(19) = 80000

C 20  nu-e,nu-e-bar,nu-mu,nu-mu-bar
C 21  nu-e,nu-e-bar,nu-tau,nu-tau-bar

      do 1020 ip = 20, 21

**    ngd(ip)    = 12
      irs1d(ip) = 1
      ars1md(ip) = 23
      irs2d(ip) = 1
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 0
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000
 1020 continue

C 22  nu-mu,nu-mu-bar,nu-mu,nu-mu-bar
C 23  nu-tau,nu-tau-bar,nu-tau,nu-tau-bar
      do 1022 ip = 22, 23

**    ngd(ip)    = 12
      irs1d(ip) = 1
      ars1md(ip) = 23
      irs2d(ip) = 1
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = 1
      ars3md(ip) = 23
      irs4d(ip) = 1
      ars4md(ip) = 23
      ics3d(ip) = 0
      ics5d(ip) = 4
      iph6d(ip) = 0
      icq3d(ip) = 0
      iswpd(ip) = 1
      swpmd(ip) = -999.
      idntd(ip) = 2
      jtgmd(ip) = 0
      kinmt(ip) = 3
      iit1 (ip) = 7
      iit2 (ip) = 15
      incal(ip) = 40000
 1022 continue

C 24  nu-tau,nu-tau-bar,nu-mu,nu-mu-bar
**    ngd(24)    = 6
      irs1d(24) = 1
      ars1md(24) = 23
      irs2d(24) = 1
      ars2md(24) = 23
          kclmb(24) = 0
      irs3d(24) = -255
      ars3md(24) = 0
      irs4d(24) = -255
      ars4md(24) = 0
      ics3d(24) = 0
      ics5d(24) = 0
      iph6d(24) = 0
      icq3d(24) = 0
      iswpd(24) = 0
      swpmd(24) = -999.
      idntd(24) = 0
      jtgmd(24) = 0
      kinmt(24) = 1
      iit1 (24) = 7
      iit2 (24) =15
      incal(24) = 80000

C 25  electron,nu-e-bar,u,d-bar
C 26  electron,nu-e-bar,c,s-bar
      do 1025 ip = 25, 26

**    ngd(ip)    = 20
      irs1d(ip) = 1
      ars1md(ip) = 24
      irs2d(ip) = 1
      ars2md(ip) = 24
          kclmb(ip) = 1
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 1
      ics5d(ip) = 2
      iph6d(ip) = 0
      icq3d(ip) = 1
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 1
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) = 15
      incal(ip) = 40000
 1025 continue

C 27  muon,nu-mu-bar,u,d-bar
C 28  muon,nu-mu-bar,c,s-bar
C 29  tau,nu-tau-bar,u,d-bar
C 30  tau,nu-tau-bar,c,S-bar
      do 1027 ip = 27, 30

**    ngd(ip)    = 10
      irs1d(ip) = 1
      ars1md(ip) = 24
      irs2d(ip) = 1
      ars2md(ip) = 24
          kclmb(ip) = 1
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 1
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000
 1027 continue

C 31  electron,positron,u,u-bar
C 32  electron,positron,c,c-bar
C 33  electron,positron,d,d-bar
C 34  electron,positron,s,s-bar
C 35  electron,positron,b,b-bar
      do 1031 ip = 31, 35

**    ngd(ip)    = 50
      irs1d(ip) = 2
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 2
      ics5d(ip) = 2
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 1
      kinmt(ip) = 2
       iit1(ip) = 7
       iit2(ip) = 15
      incal(ip) = 40000

 1031 continue

C 36  muon,anti-muon,u,u-bar
C 37  muon,anti-muon,c,c-bar
C 38  tau,anti-tau,u,u-bar
C 39  tau,anti-tau,c,c-bar
C 40  muon,anti-muon,d,d-bar
C 41  muon,anti-muon,s,s-bar
C 42  muon,anti-muon,b,b-bar
C 43  tau,anti-tau,d,d-bar
C 44  tau,anti-tau,s,s-bar
C 45  tau,anti-tau,b,b-bar

      do 1036 ip = 36, 45

**    ngd(ip)    = 34
*     for CANON-CUT
*     irs1d(ip) = 1
*     for NO-CUT
*YK   irs1d(ip) = 3
      irs1d(ip) = 2
      ars1md(ip) = 23

*YK   irs2d(ip) = 3
      irs2d(ip) = 2
      ars2md(ip) = 23
          kclmb(ip) = 0
*YK 97/03/08
      if( ip .eq. 36 ) irs2d(ip) = 3
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000

 1036 continue

C 46  nu-e,nu-e-bar,u,u-bar
C 47  nu-e,nu-e-bar,c,c-bar
C 48  nu-e,nu-e-bar,d,d-bar
C 49  nu-e,nu-e-bar,s,s-bar
C 50  nu-e,nu-e-bar,b,b-bar

      do 1046 ip = 46, 50

**    ngd(ip)    = 21
      irs1d(ip) = 1
      ars1md(ip) = 23
      if( ip .le. 47 ) then
*         u,c
          irs2d(ip) = 3
      else
*         d,s,b
          irs2d(ip) = 2
      endif
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000

 1046 continue

C 51  nu-mu,nu-mu-bar,u,u-bar
C 52  nu-mu,nu-mu-bar,c,c-bar
C 53  nu-tau,nu-tau-bar,u,u-bar
C 54  nu-tau,nu-tau-bar,c,c-bar
C 55  nu-mu,nu-mu-bar,d,d-bar
C 56  nu-mu,nu-mu-bar,s,s-bar
C 57  nu-mu,nu-mu-bar,b,b-bar
C 58  nu-tau,nu-tau-bar,d,d-bar
C 59  nu-tau,nu-tau-bar,s,s-bar
C 60  nu-tau,nu-tau-bar,b,b-bar

      do 1051 ip = 51, 60

**    ngd(ip)    = 11
      irs1d(ip) = 1
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
*     icq3d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000

 1051 continue


C 61  u,d-bar,d,u-bar
C 62  c,s-bar,s,c-bar
      do 1061 ip = 61, 62
*
**    ngd(ip)    = 53
      irs1d(ip) = 1
      ars1md(ip) = 24
      irs2d(ip) = 1
      ars2md(ip) = 24
          kclmb(ip) = 1
      irs3d(ip) = 3
      ars3md(ip) = 23
      irs4d(ip) = 3
      ars4md(ip) = 23
      ics3d(ip) = 0
      ics5d(ip) = 999
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 1
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 4
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 40000
 1061 continue

C 63  u,d-bar,s,c-bar
**    ngd(63)    = 11
      irs1d(63) = 1
      ars1md(63) = 24
      irs2d(63) = 1
      ars2md(63) = 24
          kclmb(63) = 1
      irs3d(63) = -255
      ars3md(63) = 0
      irs4d(63) = -255
      ars4md(63) = 0
      ics3d(63) = 0
      ics5d(63) = 0
      iph6d(63) = 0
      icq3d(63) = 2
      iswpd(63) = 0
      swpmd(63) = -999.
      idntd(63) = 0
      jtgmd(63) = 0
      kinmt(63) = 1
      iit1 (63) = 7
      iit2 (63) =15
      incal(63) = 80000

C 64  u,u-bar,u,u-bar
C 65  c,c-bar,c,c-bar
C 66  d,d-bar,d,d-bar
C 67  s,s-bar,s,s-bar
C 68  b,b-bar,b,b-bar
      do 1064 ip = 64, 68
*
**    ngd(ip)    = 84
      irs1d(ip) = 3
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
*     irs3d(ip) = 4
      irs3d(ip) = 3
      ars3md(ip) = 23
*     irs4d(ip) = -1
      irs4d(ip) = 3
      ars4md(ip) = 23
      ics3d(ip) = 0
      ics5d(ip) = 3
      iph6d(ip) = -999
      icq3d(ip) = 2
      iswpd(ip) = 1
      swpmd(ip) = 3.
      idntd(ip) = 4
      jtgmd(ip) = 0
      kinmt(ip) = 3
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 80000

 1064 continue

C 69  u,u-bar,c,c-bar
C 70  u,u-bar,s,s-bar
C 71  u,u-bar,b,b-bar
C 72  c,c-bar,d,d-bar
C 73  c,c-bar,b,b-bar
C 74  d,d-bar,s,s-bar
C 75  d,d-bar,b,b-bar
C 76  s,s-bar,b,b-bar

      do 1069 ip = 69, 76
*
**    ngd(ip)    = 42
      irs1d(ip) = 3
      ars1md(ip) = 23
      irs2d(ip) = 3
      ars2md(ip) = 23
          kclmb(ip) = 0
      irs3d(ip) = -255
      ars3md(ip) = 0
      irs4d(ip) = -255
      ars4md(ip) = 0
      ics3d(ip) = 0
      ics5d(ip) = 0
      iph6d(ip) = 0
      icq3d(ip) = 2
      iswpd(ip) = 0
      swpmd(ip) = -999.
      idntd(ip) = 0
      jtgmd(ip) = 0
      kinmt(ip) = 1
      iit1 (ip) = 7
      iit2 (ip) =15
      incal(ip) = 80000

 1069 continue
*=======================================================================
*===========================
* Default NCALL
*===========================
          do 1100 j = 1, MPROC
             incal(j) = 40000
 1100     continue
          incal(35) = 80000
          incal(36) = 80000
          incal(46) = 80000
          incal(51) = 80000
          incal(53) = incal(51)
          incal(51) = 80000
          incal(58) = incal(55)
          incal(64) = 80000

*==========================================================
* Protection of QEDPS  [3]{Tree,ISR,QEDPS,QEDPSif}
*                      [2]{Tree,ISR,QEDPS},[1]={Tree,ISR}
*==========================================================
          do 1200 j = 1, MPROC
             kqedps(j) = 3
 1200     continue
          kqedps( 1) = 1
          kqedps( 2) = 1
          kqedps( 3) = 1
          kqedps( 7) = 1
          kqedps( 8) = 1
          kqedps( 9) = 1
          kqedps(31) = 1
          kqedps(32) = 1
          kqedps(33) = 1
          kqedps(34) = 1
          kqedps(35) = 1
*----------------------------------------
C======== end of k172db.f ==============================================
* move

      do 8000 i = 1 , MPROC
         irs1d(i-1) = irs1d(i)
        ars1md(i-1) = ars1md(i)
         irs2d(i-1) = irs2d(i)
        ars2md(i-1) = ars2md(i)
         irs3d(i-1) = irs3d(i)
        ars3md(i-1) = ars3md(i)
         irs4d(i-1) = irs4d(i)
        ars4md(i-1) = ars4md(i)
         ics3d(i-1) = ics3d(i)
         ics5d(i-1) = ics5d(i)
         iph6d(i-1) = iph6d(i)
         icq3d(i-1) = icq3d(i)
         iswpd(i-1) = iswpd(i)
         idntd(i-1) = idntd(i)
         jtgmd(i-1) = jtgmd(i)
         kinmt(i-1) = kinmt(i)
          iit1(i-1) = iit1(i)
          iit2(i-1) = iit2(i)
         incal(i-1) = incal(i)
         kclmb(i-1) = kclmb(i)
        kqedps(i-1) = kqedps(i)
         swpmd(i-1) = swpmd(i)
 8000 continue
      return
      end
* File mainsp.f generated by  "grc4f"
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
************************************************************************
* main program for SPRING 5.1
      implicit real*8(a-h,o-z)

      include 'inclk.f'
      common / knmflg / knmgvs, knmhst, knmsph, knmisr
      external func
      parameter (nextn  =6)
      common /sp4vec/ vec(4,nextn)
      real*4  p,v
      common/lujets/n,k(4000,5),p(4000,5),v(4000,5)

************************************************************************
*               DO NOT CHANGE following Flags.
      knmgvs = 1
      knmhst = 1
      knmsph = 0
      knmisr = 0
************************************************************************
*               initialization of BASES/SPRING 5.1
************************************************************************
*=======================================================================
*          initialization of bases by calling bsinit
*=======================================================================
*         -------------
           call bsinit
*         -------------
*=======================================================================
*          read the probability information from the file
*=======================================================================
           lun = 23
           open(lun,file='bases.data',status='old',form='unformatted')
*         -------------
           call bsread( lun )
*         -------------
           close( lun )

*=======================================================================
*      initialization of parameters
*          for kinematics and matrix elements
*      initialization of histograms
*=======================================================================
      lu     = 12

      open(lu,file='spring.result',status='unknown',form='formatted')

*         ------------------
           call userin( lu )
*         ------------------
*=======================================================================
*     Set parameters for LUND from GRACE
*=======================================================================
*         ---------------
           call gr2lnd
*         ---------------
*=======================================================================
*     initialization of additional histograms for spring
*=======================================================================

*=======================================================================
*     event generation
*=======================================================================

      mxtry  = 50

      mxevnt = 10

      call usersp(mxevnt,mxtry)

*     write(6,*)' number of events ? '

*     read(5,*) mxevnt

      do 100 nevnt = 1, mxevnt

         call spring( func, mxtry )

*-----------------------------------------------------------------------
*     Put common block /lujets/
*-----------------------------------------------------------------------
*         -----------------
           call sp2lnd
*         -----------------
*         -----------------
           call grc2sh
*         -----------------
  100 continue


      call spinfo( lu )

      call shplot( lu )

      close( lu )

      call grc2cl
      stop
      end

*970715:TI: add set 7(S-chanel) and set 8(T-chanel)
*970615:TI: 1->76 --> 0->75
*970608:TI: move kqedps to kxxx.f
*970506:TI: define ngd in prcdb
*970506:TI: add set 10 and 11 for 7-9,31-35
*------------------------------------------------------------------
      subroutine prcdbi
      implicit real*8 (a-h,o-z)
*------------------------------------------------------------------
*     Initilization of data base of processes
*------------------------------------------------------------------
      include 'incl1.f'
      include 'inclpd.f'
* number of graphs
C========  ngd.f ====================================================
      ngd(1)    = 56
      do 3002 ip = 2, 3
            ngd(ip) = 18
 3002 continue
      do 3004 ip = 4, 5
            ngd(ip) = 20
 3004 continue
      ngd( 6)    =   9
      ngd( 7)    = 144
      do 3008 ip = 8, 9
         ngd(ip)    = 50
 3008 continue
      do 3010 ip = 10, 11
         ngd(ip)    = 68
 3010 continue
      ngd(12)    = 34
      do 3013 ip = 13, 14
         ngd(ip)    = 20
 3013 continue
      do 3015 ip = 15, 16
         ngd(ip)    = 21
 3015 continue
      do 3017 ip = 17, 18
         ngd(ip)    = 11
 3017 continue
      ngd(19)    = 36
      do 3020 ip = 20, 21
         ngd(ip)    = 12
 3020 continue
      do 3022 ip = 22, 23
         ngd(ip)    = 12
 3022 continue
      ngd(24)    = 6
      do 3025 ip = 25, 26
         ngd(ip)    = 20
 3025 continue
      do 3027 ip = 27, 30
         ngd(ip)    = 10
 3027 continue
      do 3031 ip = 31, 35
         ngd(ip)    = 50
 3031 continue
      do 3036 ip = 36, 45
         ngd(ip)    = 34
 3036 continue
      do 3046 ip = 46, 50
         ngd(ip)    = 21
 3046 continue
      do 3051 ip = 51, 60
         ngd(ip)    = 11
 3051 continue
      do 3061 ip = 61, 62
         ngd(ip)    = 53
 3061 continue
      ngd(63)    = 11
      do 3064 ip = 64, 68
         ngd(ip)    = 84
 3064 continue
      do 3069 ip = 69, 76
         ngd(ip)    = 42
 3069 continue
C=======================================================================
* subset of graph for the category
* type = 1    (WW)
*     kdiagr(1,1,13)=1
*     kdiagr(1,1,14)=1
*     kdiagr(1,1,51)=1
* type = 2    (ZZ)
*     kdiagr(1,2,48)=1
*     kdiagr(1,2,50)=1
*
*     --> define sigmdb.f
*
*========= removed (see below 76)
* particle name
*     kmpr_c(1,1) = 'electron'
*     kmpr_l(1,1) = 8
*     kmpr_c(1,2) = 'positron'
*     kmpr_l(1,2) = 8
*     kmpr_c(1,3) = 'nu-e'
*     kmpr_l(1,3) = 4
*     kmpr_c(1,4) = 'positron'
*     kmpr_l(1,4) = 8
*     kmpr_c(1,5) = 'electron'
*     kmpr_l(1,5) = 8
*     kmpr_c(1,6) = 'nu-e-bar'
*     kmpr_l(1,6) = 8
* masses of external particles
*     amas_1(1,1) = 11
*     amas_1(1,2) = 11
*     amas_1(1,3) = 12
*     amas_1(1,4) = 11
*     amas_1(1,5) = 11
*     amas_1(1,6) = 12
*
* Charge*3
*     kcha_g(1,1) =  -3
*     kcha_g(1,2) =   3
*     kcha_g(1,3) =   0
*     kcha_g(1,4) =   3
*     kcha_g(1,5) =  -3
*     kcha_g(1,6) =   0
*
* KFcode
*     kfco_e(1,1) =  11
*     kfco_e(1,2) = -11
*     kfco_e(1,3) =  12
*     kfco_e(1,4) = -11
*     kfco_e(1,5) =  11
*     kfco_e(1,6) = -12
* weight for the color base (llll)
*     cf_mtx(1,0,0) = 1.d0
*
*     kmcb_s(1)    = 1
*     kmcb_x(1)    = 0

* particle name
      kmpr_c(2,1) = 'electron'
      kmpr_l(2,1) = 8
      kmpr_c(2,2) = 'positron'
      kmpr_l(2,2) = 8
      kmpr_c(2,3) = 'electron'
      kmpr_l(2,3) = 8
      kmpr_c(2,4) = 'nu-e-bar'
      kmpr_l(2,4) = 8
      kmpr_c(2,5) = 'anti-muon'
      kmpr_l(2,5) = 9
      kmpr_c(2,6) = 'nu-mu'
      kmpr_l(2,6) = 5
* masses of external particles
      amas_1(2,1) = 11
      amas_1(2,2) = 11
      amas_1(2,3) = 11
      amas_1(2,4) = 12
      amas_1(2,5) = 13
      amas_1(2,6) = 14

* Charge*3
      kcha_g(2,1) =  -3
      kcha_g(2,2) =   3
      kcha_g(2,3) =  -3
      kcha_g(2,4) =   0
      kcha_g(2,5) =   3
      kcha_g(2,6) =   0

* KFcode
      kfco_e(2,1) =  11
      kfco_e(2,2) = -11
      kfco_e(2,3) =  11
      kfco_e(2,4) = -12
      kfco_e(2,5) = -13
      kfco_e(2,6) =  14
* weight for the color base (llll)
      cf_mtx(2,0,0) = 1.d0

      kmcb_s(2)    = 1
      kmcb_x(2)    = 0

* particle name
      kmpr_c(3,1) = 'electron'
      kmpr_l(3,1) = 8
      kmpr_c(3,2) = 'positron'
      kmpr_l(3,2) = 8
      kmpr_c(3,3) = 'electron'
      kmpr_l(3,3) = 8
      kmpr_c(3,4) = 'nu-e-bar'
      kmpr_l(3,4) = 8
      kmpr_c(3,5) = 'anti-tau'
      kmpr_l(3,5) = 8
      kmpr_c(3,6) = 'nu-tau'
      kmpr_l(3,6) = 6
* masses of external particles
      amas_1(3,1) = 11
      amas_1(3,2) = 11
      amas_1(3,3) = 11
      amas_1(3,4) = 12
      amas_1(3,5) = 15
      amas_1(3,6) = 16

* Charge*3
      kcha_g(3,1) =  -3
      kcha_g(3,2) =   3
      kcha_g(3,3) =  -3
      kcha_g(3,4) =   0
      kcha_g(3,5) =   3
      kcha_g(3,6) =   0

* KFcode
      kfco_e(3,1) =  11
      kfco_e(3,2) = -11
      kfco_e(3,3) =  11
      kfco_e(3,4) = -12
      kfco_e(3,5) = -15
      kfco_e(3,6) =  16
* weight for the color base (llll)
      cf_mtx(3,0,0) = 1.d0

      kmcb_s(3)    = 1
      kmcb_x(3)    = 0

* particle name
      kmpr_c(4,1) = 'electron'
      kmpr_l(4,1) = 8
      kmpr_c(4,2) = 'positron'
      kmpr_l(4,2) = 8
      kmpr_c(4,3) = 'nu-mu'
      kmpr_l(4,3) = 5
      kmpr_c(4,4) = 'anti-muon'
      kmpr_l(4,4) = 9
      kmpr_c(4,5) = 'muon'
      kmpr_l(4,5) = 4
      kmpr_c(4,6) = 'nu-mu-bar'
      kmpr_l(4,6) = 9
* masses of external particles
      amas_1(4,1) = 11
      amas_1(4,2) = 11
      amas_1(4,3) = 14
      amas_1(4,4) = 13
      amas_1(4,5) = 13
      amas_1(4,6) = 14

* Charge*3
      kcha_g(4,1) =  -3
      kcha_g(4,2) =   3
      kcha_g(4,3) =   0
      kcha_g(4,4) =   3
      kcha_g(4,5) =  -3
      kcha_g(4,6) =   0

* KFcode
      kfco_e(4,1) =  11
      kfco_e(4,2) = -11
      kfco_e(4,3) =  14
      kfco_e(4,4) = -13
      kfco_e(4,5) =  13
      kfco_e(4,6) = -14
* weight for the color base (llll)
      cf_mtx(4,0,0) = 1.d0

      kmcb_s(4)    = 1
      kmcb_x(4)    = 0

* particle name
      kmpr_c(5,1) = 'electron'
      kmpr_l(5,1) = 8
      kmpr_c(5,2) = 'positron'
      kmpr_l(5,2) = 8
      kmpr_c(5,3) = 'nu-tau'
      kmpr_l(5,3) = 6
      kmpr_c(5,4) = 'anti-tau'
      kmpr_l(5,4) = 8
      kmpr_c(5,5) = 'tau'
      kmpr_l(5,5) = 3
      kmpr_c(5,6) = 'nu-tau-bar'
      kmpr_l(5,6) = 10
* masses of external particles
      amas_1(5,1) = 11
      amas_1(5,2) = 11
      amas_1(5,3) = 16
      amas_1(5,4) = 15
      amas_1(5,5) = 15
      amas_1(5,6) = 16

* Charge*3
      kcha_g(5,1) =  -3
      kcha_g(5,2) =   3
      kcha_g(5,3) =   0
      kcha_g(5,4) =   3
      kcha_g(5,5) =  -3
      kcha_g(5,6) =   0

* KFcode
      kfco_e(5,1) =  11
      kfco_e(5,2) = -11
      kfco_e(5,3) =  16
      kfco_e(5,4) = -15
      kfco_e(5,5) =  15
      kfco_e(5,6) = -16
* weight for the color base (llll)
      cf_mtx(5,0,0) = 1.d0

      kmcb_s(5)    = 1
      kmcb_x(5)    = 0

* particle name
      kmpr_c(6,1) = 'electron'
      kmpr_l(6,1) = 8
      kmpr_c(6,2) = 'positron'
      kmpr_l(6,2) = 8
      kmpr_c(6,3) = 'muon'
      kmpr_l(6,3) = 4
      kmpr_c(6,4) = 'nu-mu-bar'
      kmpr_l(6,4) = 9
      kmpr_c(6,5) = 'anti-tau'
      kmpr_l(6,5) = 8
      kmpr_c(6,6) = 'nu-tau'
      kmpr_l(6,6) = 6
* masses of external particles
      amas_1(6,1) = 11
      amas_1(6,2) = 11
      amas_1(6,3) = 13
      amas_1(6,4) = 14
      amas_1(6,5) = 15
      amas_1(6,6) = 16

* Charge*3
      kcha_g(6,1) =  -3
      kcha_g(6,2) =   3
      kcha_g(6,3) =  -3
      kcha_g(6,4) =   0
      kcha_g(6,5) =   3
      kcha_g(6,6) =   0

* KFcode
      kfco_e(6,1) =  11
      kfco_e(6,2) = -11
      kfco_e(6,3) =  13
      kfco_e(6,4) = -14
      kfco_e(6,5) = -15
      kfco_e(6,6) =  16
* weight for the color base (llll)
      cf_mtx(6,0,0) = 1.d0

      kmcb_s(6)    = 1
      kmcb_x(6)    = 0

* particle name
      kmpr_c(7,1) = 'electron'
      kmpr_l(7,1) = 8
      kmpr_c(7,2) = 'positron'
      kmpr_l(7,2) = 8
      kmpr_c(7,3) = 'electron'
      kmpr_l(7,3) = 8
      kmpr_c(7,4) = 'positron'
      kmpr_l(7,4) = 8
      kmpr_c(7,5) = 'electron'
      kmpr_l(7,5) = 8
      kmpr_c(7,6) = 'positron'
      kmpr_l(7,6) = 8
* masses of external particles
      amas_1(7,1) = 11
      amas_1(7,2) = 11
      amas_1(7,3) = 11
      amas_1(7,4) = 11
      amas_1(7,5) = 11
      amas_1(7,6) = 11

* Charge*3
      kcha_g(7,1) =  -3
      kcha_g(7,2) =   3
      kcha_g(7,3) =  -3
      kcha_g(7,4) =   3
      kcha_g(7,5) =  -3
      kcha_g(7,6) =   3

* KFcode
      kfco_e(7,1) =  11
      kfco_e(7,2) = -11
      kfco_e(7,3) =  11
      kfco_e(7,4) = -11
      kfco_e(7,5) =  11
      kfco_e(7,6) = -11
* weight for the color base (llll)
      cf_mtx(7,0,0) = 1.d0

      kmcb_s(7)    = 1
      kmcb_x(7)    = 0

* particle name
      kmpr_c(8,1) = 'electron'
      kmpr_l(8,1) = 8
      kmpr_c(8,2) = 'positron'
      kmpr_l(8,2) = 8
      kmpr_c(8,3) = 'electron'
      kmpr_l(8,3) = 8
      kmpr_c(8,4) = 'positron'
      kmpr_l(8,4) = 8
      kmpr_c(8,5) = 'muon'
      kmpr_l(8,5) = 4
      kmpr_c(8,6) = 'anti-muon'
      kmpr_l(8,6) = 9
* masses of external particles
      amas_1(8,1) = 11
      amas_1(8,2) = 11
      amas_1(8,3) = 11
      amas_1(8,4) = 11
      amas_1(8,5) = 13
      amas_1(8,6) = 13

* Charge*3
      kcha_g(8,1) =  -3
      kcha_g(8,2) =   3
      kcha_g(8,3) =  -3
      kcha_g(8,4) =   3
      kcha_g(8,5) =  -3
      kcha_g(8,6) =   3

* KFcode
      kfco_e(8,1) =  11
      kfco_e(8,2) = -11
      kfco_e(8,3) =  11
      kfco_e(8,4) = -11
      kfco_e(8,5) =  13
      kfco_e(8,6) = -13
* weight for the color base (llll)
      cf_mtx(8,0,0) = 1.d0

      kmcb_s(8)    = 1
      kmcb_x(8)    = 0

* particle name
      kmpr_c(9,1) = 'electron'
      kmpr_l(9,1) = 8
      kmpr_c(9,2) = 'positron'
      kmpr_l(9,2) = 8
      kmpr_c(9,3) = 'electron'
      kmpr_l(9,3) = 8
      kmpr_c(9,4) = 'positron'
      kmpr_l(9,4) = 8
      kmpr_c(9,5) = 'tau'
      kmpr_l(9,5) = 3
      kmpr_c(9,6) = 'anti-tau'
      kmpr_l(9,6) = 8
* masses of external particles
      amas_1(9,1) = 11
      amas_1(9,2) = 11
      amas_1(9,3) = 11
      amas_1(9,4) = 11
      amas_1(9,5) = 15
      amas_1(9,6) = 15

* Charge*3
      kcha_g(9,1) =  -3
      kcha_g(9,2) =   3
      kcha_g(9,3) =  -3
      kcha_g(9,4) =   3
      kcha_g(9,5) =  -3
      kcha_g(9,6) =   3

* KFcode
      kfco_e(9,1) =  11
      kfco_e(9,2) = -11
      kfco_e(9,3) =  11
      kfco_e(9,4) = -11
      kfco_e(9,5) =  15
      kfco_e(9,6) = -15
* weight for the color base (llll)
      cf_mtx(9,0,0) = 1.d0

      kmcb_s(9)    = 1
      kmcb_x(9)    = 0
      
* particle name
      kmpr_c(10,1) = 'electron'
      kmpr_l(10,1) = 8
      kmpr_c(10,2) = 'positron'
      kmpr_l(10,2) = 8
      kmpr_c(10,3) = 'muon'
      kmpr_l(10,3) = 4
      kmpr_c(10,4) = 'anti-muon'
      kmpr_l(10,4) = 9
      kmpr_c(10,5) = 'muon'
      kmpr_l(10,5) = 4
      kmpr_c(10,6) = 'anti-muon'
      kmpr_l(10,6) = 9
* masses of external particles
      amas_1(10,1) = 11
      amas_1(10,2) = 11
      amas_1(10,3) = 13
      amas_1(10,4) = 13
      amas_1(10,5) = 13
      amas_1(10,6) = 13

* Charge*3
      kcha_g(10,1) =  -3
      kcha_g(10,2) =   3
      kcha_g(10,3) =  -3
      kcha_g(10,4) =   3
      kcha_g(10,5) =  -3
      kcha_g(10,6) =   3

* KFcode
      kfco_e(10,1) =  11
      kfco_e(10,2) = -11
      kfco_e(10,3) =  13
      kfco_e(10,4) = -13
      kfco_e(10,5) =  13
      kfco_e(10,6) = -13
* weight for the color base (llll)
      cf_mtx(10,0,0) = 1.d0

      kmcb_s(10)    = 1
      kmcb_x(10)    = 0

* particle name
      kmpr_c(11,1) = 'electron'
      kmpr_l(11,1) = 8
      kmpr_c(11,2) = 'positron'
      kmpr_l(11,2) = 8
      kmpr_c(11,3) = 'tau'
      kmpr_l(11,3) = 3
      kmpr_c(11,4) = 'anti-tau'
      kmpr_l(11,4) = 8
      kmpr_c(11,5) = 'tau'
      kmpr_l(11,5) = 3
      kmpr_c(11,6) = 'anti-tau'
      kmpr_l(11,6) = 8
* masses of external particles
      amas_1(11,1) = 11
      amas_1(11,2) = 11
      amas_1(11,3) = 15
      amas_1(11,4) = 15
      amas_1(11,5) = 15
      amas_1(11,6) = 15

* Charge*3
      kcha_g(11,1) =  -3
      kcha_g(11,2) =   3
      kcha_g(11,3) =  -3
      kcha_g(11,4) =   3
      kcha_g(11,5) =  -3
      kcha_g(11,6) =   3

* KFcode
      kfco_e(11,1) =  11
      kfco_e(11,2) = -11
      kfco_e(11,3) =  15
      kfco_e(11,4) = -15
      kfco_e(11,5) =  15
      kfco_e(11,6) = -15
* weight for the color base (llll)
      cf_mtx(11,0,0) = 1.d0

      kmcb_s(11)    = 1
      kmcb_x(11)    = 0

* particle name
      kmpr_c(12,1) = 'electron'
      kmpr_l(12,1) = 8
      kmpr_c(12,2) = 'positron'
      kmpr_l(12,2) = 8
      kmpr_c(12,3) = 'muon'
      kmpr_l(12,3) = 4
      kmpr_c(12,4) = 'anti-muon'
      kmpr_l(12,4) = 9
      kmpr_c(12,5) = 'tau'
      kmpr_l(12,5) = 3
      kmpr_c(12,6) = 'anti-tau'
      kmpr_l(12,6) = 8
* masses of external particles
      amas_1(12,1) = 11
      amas_1(12,2) = 11
      amas_1(12,3) = 13
      amas_1(12,4) = 13
      amas_1(12,5) = 15
      amas_1(12,6) = 15

* Charge*3
      kcha_g(12,1) =  -3
      kcha_g(12,2) =   3
      kcha_g(12,3) =  -3
      kcha_g(12,4) =   3
      kcha_g(12,5) =  -3
      kcha_g(12,6) =   3

* KFcode
      kfco_e(12,1) =  11
      kfco_e(12,2) = -11
      kfco_e(12,3) =  13
      kfco_e(12,4) = -13
      kfco_e(12,5) =  15
      kfco_e(12,6) = -15
* weight for the color base (llll)
      cf_mtx(12,0,0) = 1.d0

      kmcb_s(12)    = 1
      kmcb_x(12)    = 0

* particle name
      kmpr_c(13,1) = 'electron'
      kmpr_l(13,1) = 8
      kmpr_c(13,2) = 'positron'
      kmpr_l(13,2) = 8
      kmpr_c(13,3) = 'electron'
      kmpr_l(13,3) = 8
      kmpr_c(13,4) = 'positron'
      kmpr_l(13,4) = 8
      kmpr_c(13,5) = 'nu-mu'
      kmpr_l(13,5) = 5
      kmpr_c(13,6) = 'nu-mu-bar'
      kmpr_l(13,6) = 9
* masses of external particles
      amas_1(13,1) = 11
      amas_1(13,2) = 11
      amas_1(13,3) = 11
      amas_1(13,4) = 11
      amas_1(13,5) = 14
      amas_1(13,6) = 14

* Charge*3
      kcha_g(13,1) =  -3
      kcha_g(13,2) =   3
      kcha_g(13,3) =  -3
      kcha_g(13,4) =   3
      kcha_g(13,5) =   0
      kcha_g(13,6) =   0

* KFcode
      kfco_e(13,1) =  11
      kfco_e(13,2) = -11
      kfco_e(13,3) =  11
      kfco_e(13,4) = -11
      kfco_e(13,5) =  14
      kfco_e(13,6) = -14
* weight for the color base (llll)
      cf_mtx(13,0,0) = 1.d0

      kmcb_s(13)    = 1
      kmcb_x(13)    = 0

* particle name
      kmpr_c(14,1) = 'electron'
      kmpr_l(14,1) = 8
      kmpr_c(14,2) = 'positron'
      kmpr_l(14,2) = 8
      kmpr_c(14,3) = 'electron'
      kmpr_l(14,3) = 8
      kmpr_c(14,4) = 'positron'
      kmpr_l(14,4) = 8
      kmpr_c(14,5) = 'nu-tau'
      kmpr_l(14,5) = 6
      kmpr_c(14,6) = 'nu-tau-bar'
      kmpr_l(14,6) = 10
* masses of external particles
      amas_1(14,1) = 11
      amas_1(14,2) = 11
      amas_1(14,3) = 11
      amas_1(14,4) = 11
      amas_1(14,5) = 16
      amas_1(14,6) = 16

* Charge*3
      kcha_g(14,1) =  -3
      kcha_g(14,2) =   3
      kcha_g(14,3) =  -3
      kcha_g(14,4) =   3
      kcha_g(14,5) =   0
      kcha_g(14,6) =   0

* KFcode
      kfco_e(14,1) =  11
      kfco_e(14,2) = -11
      kfco_e(14,3) =  11
      kfco_e(14,4) = -11
      kfco_e(14,5) =  16
      kfco_e(14,6) = -16
* weight for the color base (llll)
      cf_mtx(14,0,0) = 1.d0

      kmcb_s(14)    = 1
      kmcb_x(14)    = 0

* particle name
      kmpr_c(15,1) = 'electron'
      kmpr_l(15,1) = 8
      kmpr_c(15,2) = 'positron'
      kmpr_l(15,2) = 8
      kmpr_c(15,3) = 'nu-e'
      kmpr_l(15,3) = 4
      kmpr_c(15,4) = 'nu-e-bar'
      kmpr_l(15,4) = 8
      kmpr_c(15,5) = 'muon'
      kmpr_l(15,5) = 4
      kmpr_c(15,6) = 'anti-muon'
      kmpr_l(15,6) = 9
* masses of external particles
      amas_1(15,1) = 11
      amas_1(15,2) = 11
      amas_1(15,3) = 12
      amas_1(15,4) = 12
      amas_1(15,5) = 13
      amas_1(15,6) = 13

* Charge*3
      kcha_g(15,1) =  -3
      kcha_g(15,2) =   3
      kcha_g(15,3) =   0
      kcha_g(15,4) =   0
      kcha_g(15,5) =  -3
      kcha_g(15,6) =   3

* KFcode
      kfco_e(15,1) =  11
      kfco_e(15,2) = -11
      kfco_e(15,3) =  12
      kfco_e(15,4) = -12
      kfco_e(15,5) =  13
      kfco_e(15,6) = -13
* weight for the color base (llll)
      cf_mtx(15,0,0) = 1.d0

      kmcb_s(15)    = 1
      kmcb_x(15)    = 0

* particle name
      kmpr_c(16,1) = 'electron'
      kmpr_l(16,1) = 8
      kmpr_c(16,2) = 'positron'
      kmpr_l(16,2) = 8
      kmpr_c(16,3) = 'nu-e'
      kmpr_l(16,3) = 4
      kmpr_c(16,4) = 'nu-e-bar'
      kmpr_l(16,4) = 8
      kmpr_c(16,5) = 'tau'
      kmpr_l(16,5) = 3
      kmpr_c(16,6) = 'anti-tau'
      kmpr_l(16,6) = 8
* masses of external particles
      amas_1(16,1) = 11
      amas_1(16,2) = 11
      amas_1(16,3) = 12
      amas_1(16,4) = 12
      amas_1(16,5) = 15
      amas_1(16,6) = 15

* Charge*3
      kcha_g(16,1) =  -3
      kcha_g(16,2) =   3
      kcha_g(16,3) =   0
      kcha_g(16,4) =   0
      kcha_g(16,5) =  -3
      kcha_g(16,6) =   3

* KFcode
      kfco_e(16,1) =  11
      kfco_e(16,2) = -11
      kfco_e(16,3) =  12
      kfco_e(16,4) = -12
      kfco_e(16,5) =  15
      kfco_e(16,6) = -15
* weight for the color base (llll)
      cf_mtx(16,0,0) = 1.d0

      kmcb_s(16)    = 1
      kmcb_x(16)    = 0

* particle name
      kmpr_c(17,1) = 'electron'
      kmpr_l(17,1) = 8
      kmpr_c(17,2) = 'positron'
      kmpr_l(17,2) = 8
      kmpr_c(17,3) = 'nu-tau'
      kmpr_l(17,3) = 6
      kmpr_c(17,4) = 'nu-tau-bar'
      kmpr_l(17,4) = 10
      kmpr_c(17,5) = 'muon'
      kmpr_l(17,5) = 4
      kmpr_c(17,6) = 'anti-muon'
      kmpr_l(17,6) = 9
* masses of external particles
      amas_1(17,1) = 11
      amas_1(17,2) = 11
      amas_1(17,3) = 16
      amas_1(17,4) = 16
      amas_1(17,5) = 13
      amas_1(17,6) = 13

* Charge*3
      kcha_g(17,1) =  -3
      kcha_g(17,2) =   3
      kcha_g(17,3) =   0
      kcha_g(17,4) =   0
      kcha_g(17,5) =  -3
      kcha_g(17,6) =   3

* KFcode
      kfco_e(17,1) =  11
      kfco_e(17,2) = -11
      kfco_e(17,3) =  16
      kfco_e(17,4) = -16
      kfco_e(17,5) =  13
      kfco_e(17,6) = -13
* weight for the color base (llll)
      cf_mtx(17,0,0) = 1.d0

      kmcb_s(17)    = 1
      kmcb_x(17)    = 0

* particle name
      kmpr_c(18,1) = 'electron'
      kmpr_l(18,1) = 8
      kmpr_c(18,2) = 'positron'
      kmpr_l(18,2) = 8
      kmpr_c(18,3) = 'nu-mu'
      kmpr_l(18,3) = 5
      kmpr_c(18,4) = 'nu-mu-bar'
      kmpr_l(18,4) = 9
      kmpr_c(18,5) = 'tau'
      kmpr_l(18,5) = 3
      kmpr_c(18,6) = 'anti-tau'
      kmpr_l(18,6) = 8
* masses of external particles
      amas_1(18,1) = 11
      amas_1(18,2) = 11
      amas_1(18,3) = 14
      amas_1(18,4) = 14
      amas_1(18,5) = 15
      amas_1(18,6) = 15

* Charge*3
      kcha_g(18,1) =  -3
      kcha_g(18,2) =   3
      kcha_g(18,3) =   0
      kcha_g(18,4) =   0
      kcha_g(18,5) =  -3
      kcha_g(18,6) =   3

* KFcode
      kfco_e(18,1) =  11
      kfco_e(18,2) = -11
      kfco_e(18,3) =  14
      kfco_e(18,4) = -14
      kfco_e(18,5) =  15
      kfco_e(18,6) = -15
* weight for the color base (llll)
      cf_mtx(18,0,0) = 1.d0

      kmcb_s(18)    = 1
      kmcb_x(18)    = 0

* particle name
      kmpr_c(19,1) = 'electron'
      kmpr_l(19,1) = 8
      kmpr_c(19,2) = 'positron'
      kmpr_l(19,2) = 8
      kmpr_c(19,3) = 'nu-e'
      kmpr_l(19,3) = 4
      kmpr_c(19,4) = 'nu-e-bar'
      kmpr_l(19,4) = 8
      kmpr_c(19,5) = 'nu-e'
      kmpr_l(19,5) = 4
      kmpr_c(19,6) = 'nu-e-bar'
      kmpr_l(19,6) = 8
* masses of external particles
      amas_1(19,1) = 11
      amas_1(19,2) = 11
      amas_1(19,3) = 12
      amas_1(19,4) = 12
      amas_1(19,5) = 12
      amas_1(19,6) = 12

* Charge*3
      kcha_g(19,1) =  -3
      kcha_g(19,2) =   3
      kcha_g(19,3) =   0
      kcha_g(19,4) =   0
      kcha_g(19,5) =   0
      kcha_g(19,6) =   0

* KFcode
      kfco_e(19,1) =  11
      kfco_e(19,2) = -11
      kfco_e(19,3) =  12
      kfco_e(19,4) = -12
      kfco_e(19,5) =  12
      kfco_e(19,6) = -12
* weight for the color base (llll)
      cf_mtx(19,0,0) = 1.d0

      kmcb_s(19)    = 1
      kmcb_x(19)    = 0

* particle name
      kmpr_c(20,1) = 'electron'
      kmpr_l(20,1) = 8
      kmpr_c(20,2) = 'positron'
      kmpr_l(20,2) = 8
      kmpr_c(20,3) = 'nu-e'
      kmpr_l(20,3) = 4
      kmpr_c(20,4) = 'nu-e-bar'
      kmpr_l(20,4) = 8
      kmpr_c(20,5) = 'nu-mu'
      kmpr_l(20,5) = 5
      kmpr_c(20,6) = 'nu-mu-bar'
      kmpr_l(20,6) = 9
* masses of external particles
      amas_1(20,1) = 11
      amas_1(20,2) = 11
      amas_1(20,3) = 12
      amas_1(20,4) = 12
      amas_1(20,5) = 14
      amas_1(20,6) = 14

* Charge*3
      kcha_g(20,1) =  -3
      kcha_g(20,2) =   3
      kcha_g(20,3) =   0
      kcha_g(20,4) =   0
      kcha_g(20,5) =   0
      kcha_g(20,6) =   0

* KFcode
      kfco_e(20,1) =  11
      kfco_e(20,2) = -11
      kfco_e(20,3) =  12
      kfco_e(20,4) = -12
      kfco_e(20,5) =  14
      kfco_e(20,6) = -14
* weight for the color base (llll)
      cf_mtx(20,0,0) = 1.d0

      kmcb_s(20)    = 1
      kmcb_x(20)    = 0

* particle name
      kmpr_c(21,1) = 'electron'
      kmpr_l(21,1) = 8
      kmpr_c(21,2) = 'positron'
      kmpr_l(21,2) = 8
      kmpr_c(21,3) = 'nu-e'
      kmpr_l(21,3) = 4
      kmpr_c(21,4) = 'nu-e-bar'
      kmpr_l(21,4) = 8
      kmpr_c(21,5) = 'nu-tau'
      kmpr_l(21,5) = 6
      kmpr_c(21,6) = 'nu-tau-bar'
      kmpr_l(21,6) = 10
* masses of external particles
      amas_1(21,1) = 11
      amas_1(21,2) = 11
      amas_1(21,3) = 12
      amas_1(21,4) = 12
      amas_1(21,5) = 16
      amas_1(21,6) = 16

* Charge*3
      kcha_g(21,1) =  -3
      kcha_g(21,2) =   3
      kcha_g(21,3) =   0
      kcha_g(21,4) =   0
      kcha_g(21,5) =   0
      kcha_g(21,6) =   0

* KFcode
      kfco_e(21,1) =  11
      kfco_e(21,2) = -11
      kfco_e(21,3) =  12
      kfco_e(21,4) = -12
      kfco_e(21,5) =  16
      kfco_e(21,6) = -16
* weight for the color base (llll)
      cf_mtx(21,0,0) = 1.d0

      kmcb_s(21)    = 1
      kmcb_x(21)    = 0

* particle name
      kmpr_c(22,1) = 'electron'
      kmpr_l(22,1) = 8
      kmpr_c(22,2) = 'positron'
      kmpr_l(22,2) = 8
      kmpr_c(22,3) = 'nu-mu'
      kmpr_l(22,3) = 5
      kmpr_c(22,4) = 'nu-mu-bar'
      kmpr_l(22,4) = 9
      kmpr_c(22,5) = 'nu-mu'
      kmpr_l(22,5) = 5
      kmpr_c(22,6) = 'nu-mu-bar'
      kmpr_l(22,6) = 9
* masses of external particles
      amas_1(22,1) = 11
      amas_1(22,2) = 11
      amas_1(22,3) = 14
      amas_1(22,4) = 14
      amas_1(22,5) = 14
      amas_1(22,6) = 14

* Charge*3
      kcha_g(22,1) =  -3
      kcha_g(22,2) =   3
      kcha_g(22,3) =   0
      kcha_g(22,4) =   0
      kcha_g(22,5) =   0
      kcha_g(22,6) =   0

* KFcode
      kfco_e(22,1) =  11
      kfco_e(22,2) = -11
      kfco_e(22,3) =  14
      kfco_e(22,4) = -14
      kfco_e(22,5) =  14
      kfco_e(22,6) = -14
* weight for the color base (llll)
      cf_mtx(22,0,0) = 1.d0

      kmcb_s(22)    = 1
      kmcb_x(22)    = 0

* particle name
      kmpr_c(23,1) = 'electron'
      kmpr_l(23,1) = 8
      kmpr_c(23,2) = 'positron'
      kmpr_l(23,2) = 8
      kmpr_c(23,3) = 'nu-tau'
      kmpr_l(23,3) = 6
      kmpr_c(23,4) = 'nu-tau-bar'
      kmpr_l(23,4) = 10
      kmpr_c(23,5) = 'nu-tau'
      kmpr_l(23,5) = 6
      kmpr_c(23,6) = 'nu-tau-bar'
      kmpr_l(23,6) = 10
* masses of external particles
      amas_1(23,1) = 11
      amas_1(23,2) = 11
      amas_1(23,3) = 16
      amas_1(23,4) = 16
      amas_1(23,5) = 16
      amas_1(23,6) = 16

* Charge*3
      kcha_g(23,1) =  -3
      kcha_g(23,2) =   3
      kcha_g(23,3) =   0
      kcha_g(23,4) =   0
      kcha_g(23,5) =   0
      kcha_g(23,6) =   0

* KFcode
      kfco_e(23,1) =  11
      kfco_e(23,2) = -11
      kfco_e(23,3) =  16
      kfco_e(23,4) = -16
      kfco_e(23,5) =  16
      kfco_e(23,6) = -16
* weight for the color base (llll)
      cf_mtx(23,0,0) = 1.d0

      kmcb_s(23)    = 1
      kmcb_x(23)    = 0

* particle name
      kmpr_c(24,1) = 'electron'
      kmpr_l(24,1) = 8
      kmpr_c(24,2) = 'positron'
      kmpr_l(24,2) = 8
      kmpr_c(24,3) = 'nu-tau'
      kmpr_l(24,3) = 6
      kmpr_c(24,4) = 'nu-tau-bar'
      kmpr_l(24,4) = 10
      kmpr_c(24,5) = 'nu-mu'
      kmpr_l(24,5) = 5
      kmpr_c(24,6) = 'nu-mu-bar'
      kmpr_l(24,6) = 9
* masses of external particles
      amas_1(24,1) = 11
      amas_1(24,2) = 11
      amas_1(24,3) = 16
      amas_1(24,4) = 16
      amas_1(24,5) = 14
      amas_1(24,6) = 14

* Charge*3
      kcha_g(24,1) =  -3
      kcha_g(24,2) =   3
      kcha_g(24,3) =   0
      kcha_g(24,4) =   0
      kcha_g(24,5) =   0
      kcha_g(24,6) =   0

* KFcode
      kfco_e(24,1) =  11
      kfco_e(24,2) = -11
      kfco_e(24,3) =  16
      kfco_e(24,4) = -16
      kfco_e(24,5) =  14
      kfco_e(24,6) = -14
* weight for the color base (llll)
      cf_mtx(24,0,0) = 1.d0

      kmcb_s(24)    = 1
      kmcb_x(24)    = 0

* particle name
      kmpr_c(25,1) = 'electron'
      kmpr_l(25,1) = 8
      kmpr_c(25,2) = 'positron'
      kmpr_l(25,2) = 8
      kmpr_c(25,3) = 'electron'
      kmpr_l(25,3) = 8
      kmpr_c(25,4) = 'nu-e-bar'
      kmpr_l(25,4) = 8
      kmpr_c(25,5) = 'u'
      kmpr_l(25,5) = 1
      kmpr_c(25,6) = 'd-bar'
      kmpr_l(25,6) = 5
* masses of external particles
      amas_1(25,1) = 11
      amas_1(25,2) = 11
      amas_1(25,3) = 11
      amas_1(25,4) = 12
      amas_1(25,5) = 2
      amas_1(25,6) = 1

* Charge*3
      kcha_g(25,1) =  -3
      kcha_g(25,2) =   3
      kcha_g(25,3) =  -3
      kcha_g(25,4) =   0
      kcha_g(25,5) =   2
      kcha_g(25,6) =   1

* KFcode
      kfco_e(25,1) =  11
      kfco_e(25,2) = -11
      kfco_e(25,3) =  11
      kfco_e(25,4) = -12
      kfco_e(25,5) =   2
      kfco_e(25,6) =  -1
* weight for the color base (llqq)
      cf_mtx(25,0,0) = 3.d0

      kmcb_s(25)    = 1
      kmcb_x(25)    = 2
      kmcs_r(25,1,0) = 5
      kmcs_r(25,2,0) = 6

* particle name
      kmpr_c(26,1) = 'electron'
      kmpr_l(26,1) = 8
      kmpr_c(26,2) = 'positron'
      kmpr_l(26,2) = 8
      kmpr_c(26,3) = 'electron'
      kmpr_l(26,3) = 8
      kmpr_c(26,4) = 'nu-e-bar'
      kmpr_l(26,4) = 8
      kmpr_c(26,5) = 'c'
      kmpr_l(26,5) = 1
      kmpr_c(26,6) = 's-bar'
      kmpr_l(26,6) = 5
* masses of external particles
      amas_1(26,1) = 11
      amas_1(26,2) = 11
      amas_1(26,3) = 11
      amas_1(26,4) = 12
      amas_1(26,5) = 4
      amas_1(26,6) = 3

* Charge*3
      kcha_g(26,1) =  -3
      kcha_g(26,2) =   3
      kcha_g(26,3) =  -3
      kcha_g(26,4) =   0
      kcha_g(26,5) =   2
      kcha_g(26,6) =   1

* KFcode
      kfco_e(26,1) =  11
      kfco_e(26,2) = -11
      kfco_e(26,3) =  11
      kfco_e(26,4) = -12
      kfco_e(26,5) =   4
      kfco_e(26,6) =  -3
* weight for the color base (llqq)
      cf_mtx(26,0,0) = 3.d0

      kmcb_s(26)    = 1
      kmcb_x(26)    = 2
      kmcs_r(26,1,0) = 5
      kmcs_r(26,2,0) = 6

* particle name
      kmpr_c(27,1) = 'electron'
      kmpr_l(27,1) = 8
      kmpr_c(27,2) = 'positron'
      kmpr_l(27,2) = 8
      kmpr_c(27,3) = 'muon'
      kmpr_l(27,3) = 4
      kmpr_c(27,4) = 'nu-mu-bar'
      kmpr_l(27,4) = 9
      kmpr_c(27,5) = 'u'
      kmpr_l(27,5) = 1
      kmpr_c(27,6) = 'd-bar'
      kmpr_l(27,6) = 5
* masses of external particles
      amas_1(27,1) = 11
      amas_1(27,2) = 11
      amas_1(27,3) = 13
      amas_1(27,4) = 14
      amas_1(27,5) = 2
      amas_1(27,6) = 1

* Charge*3
      kcha_g(27,1) =  -3
      kcha_g(27,2) =   3
      kcha_g(27,3) =  -3
      kcha_g(27,4) =   0
      kcha_g(27,5) =   2
      kcha_g(27,6) =   1

* KFcode
      kfco_e(27,1) =  11
      kfco_e(27,2) = -11
      kfco_e(27,3) =  13
      kfco_e(27,4) = -14
      kfco_e(27,5) =   2
      kfco_e(27,6) =  -1
* weight for the color base (llqq)
      cf_mtx(27,0,0) = 3.d0

      kmcb_s(27)    = 1
      kmcb_x(27)    = 2
      kmcs_r(27,1,0) = 5
      kmcs_r(27,2,0) = 6

* particle name
      kmpr_c(28,1) = 'electron'
      kmpr_l(28,1) = 8
      kmpr_c(28,2) = 'positron'
      kmpr_l(28,2) = 8
      kmpr_c(28,3) = 'muon'
      kmpr_l(28,3) = 4
      kmpr_c(28,4) = 'nu-mu-bar'
      kmpr_l(28,4) = 9
      kmpr_c(28,5) = 'c'
      kmpr_l(28,5) = 1
      kmpr_c(28,6) = 's-bar'
      kmpr_l(28,6) = 5
* masses of external particles
      amas_1(28,1) = 11
      amas_1(28,2) = 11
      amas_1(28,3) = 13
      amas_1(28,4) = 14
      amas_1(28,5) = 4
      amas_1(28,6) = 3

* Charge*3
      kcha_g(28,1) =  -3
      kcha_g(28,2) =   3
      kcha_g(28,3) =  -3
      kcha_g(28,4) =   0
      kcha_g(28,5) =   2
      kcha_g(28,6) =   1

* KFcode
      kfco_e(28,1) =  11
      kfco_e(28,2) = -11
      kfco_e(28,3) =  13
      kfco_e(28,4) = -14
      kfco_e(28,5) =   4
      kfco_e(28,6) =  -3
* weight for the color base (llqq)
      cf_mtx(28,0,0) = 3.d0

      kmcb_s(28)    = 1
      kmcb_x(28)    = 2
      kmcs_r(28,1,0) = 5
      kmcs_r(28,2,0) = 6

* particle name
      kmpr_c(29,1) = 'electron'
      kmpr_l(29,1) = 8
      kmpr_c(29,2) = 'positron'
      kmpr_l(29,2) = 8
      kmpr_c(29,3) = 'tau'
      kmpr_l(29,3) = 3
      kmpr_c(29,4) = 'nu-tau-bar'
      kmpr_l(29,4) = 10
      kmpr_c(29,5) = 'u'
      kmpr_l(29,5) = 1
      kmpr_c(29,6) = 'd-bar'
      kmpr_l(29,6) = 5
* masses of external particles
      amas_1(29,1) = 11
      amas_1(29,2) = 11
      amas_1(29,3) = 15
      amas_1(29,4) = 16
      amas_1(29,5) = 2
      amas_1(29,6) = 1

* Charge*3
      kcha_g(29,1) =  -3
      kcha_g(29,2) =   3
      kcha_g(29,3) =  -3
      kcha_g(29,4) =   0
      kcha_g(29,5) =   2
      kcha_g(29,6) =   1

* KFcode
      kfco_e(29,1) =  11
      kfco_e(29,2) = -11
      kfco_e(29,3) =  15
      kfco_e(29,4) = -16
      kfco_e(29,5) =   2
      kfco_e(29,6) =  -1
* weight for the color base (llqq)
      cf_mtx(29,0,0) = 3.d0

      kmcb_s(29)    = 1
      kmcb_x(29)    = 2
      kmcs_r(29,1,0) = 5
      kmcs_r(29,2,0) = 6

* particle name
      kmpr_c(30,1) = 'electron'
      kmpr_l(30,1) = 8
      kmpr_c(30,2) = 'positron'
      kmpr_l(30,2) = 8
      kmpr_c(30,3) = 'tau'
      kmpr_l(30,3) = 3
      kmpr_c(30,4) = 'nu-tau-bar'
      kmpr_l(30,4) = 10
      kmpr_c(30,5) = 'c'
      kmpr_l(30,5) = 1
      kmpr_c(30,6) = 's-bar'
      kmpr_l(30,6) = 5
* masses of external particles
      amas_1(30,1) = 11
      amas_1(30,2) = 11
      amas_1(30,3) = 15
      amas_1(30,4) = 16
      amas_1(30,5) = 4
      amas_1(30,6) = 3

* Charge*3
      kcha_g(30,1) =  -3
      kcha_g(30,2) =   3
      kcha_g(30,3) =  -3
      kcha_g(30,4) =   0
      kcha_g(30,5) =   2
      kcha_g(30,6) =   1

* KFcode
      kfco_e(30,1) =  11
      kfco_e(30,2) = -11
      kfco_e(30,3) =  15
      kfco_e(30,4) = -16
      kfco_e(30,5) =   4
      kfco_e(30,6) =  -3
* weight for the color base (llqq)
      cf_mtx(30,0,0) = 3.d0

      kmcb_s(30)    = 1
      kmcb_x(30)    = 2
      kmcs_r(30,1,0) = 5
      kmcs_r(30,2,0) = 6

* particle name
      kmpr_c(31,1) = 'electron'
      kmpr_l(31,1) = 8
      kmpr_c(31,2) = 'positron'
      kmpr_l(31,2) = 8
      kmpr_c(31,3) = 'electron'
      kmpr_l(31,3) = 8
      kmpr_c(31,4) = 'positron'
      kmpr_l(31,4) = 8
      kmpr_c(31,5) = 'u'
      kmpr_l(31,5) = 1
      kmpr_c(31,6) = 'u-bar'
      kmpr_l(31,6) = 5
* masses of external particles
      amas_1(31,1) = 11
      amas_1(31,2) = 11
      amas_1(31,3) = 11
      amas_1(31,4) = 11
      amas_1(31,5) = 2
      amas_1(31,6) = 2

* Charge*3
      kcha_g(31,1) =  -3
      kcha_g(31,2) =   3
      kcha_g(31,3) =  -3
      kcha_g(31,4) =   3
      kcha_g(31,5) =   2
      kcha_g(31,6) =  -2

* KFcode
      kfco_e(31,1) =  11
      kfco_e(31,2) = -11
      kfco_e(31,3) =  11
      kfco_e(31,4) = -11
      kfco_e(31,5) =   2
      kfco_e(31,6) =  -2
* weight for the color base (llqq)
      cf_mtx(31,0,0) = 3.d0

      kmcb_s(31)    = 1
      kmcb_x(31)    = 2
      kmcs_r(31,1,0) = 5
      kmcs_r(31,2,0) = 6

* particle name
      kmpr_c(32,1) = 'electron'
      kmpr_l(32,1) = 8
      kmpr_c(32,2) = 'positron'
      kmpr_l(32,2) = 8
      kmpr_c(32,3) = 'electron'
      kmpr_l(32,3) = 8
      kmpr_c(32,4) = 'positron'
      kmpr_l(32,4) = 8
      kmpr_c(32,5) = 'c'
      kmpr_l(32,5) = 1
      kmpr_c(32,6) = 'c-bar'
      kmpr_l(32,6) = 5
* masses of external particles
      amas_1(32,1) = 11
      amas_1(32,2) = 11
      amas_1(32,3) = 11
      amas_1(32,4) = 11
      amas_1(32,5) = 4
      amas_1(32,6) = 4

* Charge*3
      kcha_g(32,1) =  -3
      kcha_g(32,2) =   3
      kcha_g(32,3) =  -3
      kcha_g(32,4) =   3
      kcha_g(32,5) =   2
      kcha_g(32,6) =  -2

* KFcode
      kfco_e(32,1) =  11
      kfco_e(32,2) = -11
      kfco_e(32,3) =  11
      kfco_e(32,4) = -11
      kfco_e(32,5) =   4
      kfco_e(32,6) =  -4
* weight for the color base (llqq)
      cf_mtx(32,0,0) = 3.d0

      kmcb_s(32)    = 1
      kmcb_x(32)    = 2
      kmcs_r(32,1,0) = 5
      kmcs_r(32,2,0) = 6

* particle name
      kmpr_c(33,1) = 'electron'
      kmpr_l(33,1) = 8
      kmpr_c(33,2) = 'positron'
      kmpr_l(33,2) = 8
      kmpr_c(33,3) = 'electron'
      kmpr_l(33,3) = 8
      kmpr_c(33,4) = 'positron'
      kmpr_l(33,4) = 8
      kmpr_c(33,5) = 'd'
      kmpr_l(33,5) = 1
      kmpr_c(33,6) = 'd-bar'
      kmpr_l(33,6) = 5
* masses of external particles
      amas_1(33,1) = 11
      amas_1(33,2) = 11
      amas_1(33,3) = 11
      amas_1(33,4) = 11
      amas_1(33,5) = 1
      amas_1(33,6) = 1

* Charge*3
      kcha_g(33,1) =  -3
      kcha_g(33,2) =   3
      kcha_g(33,3) =  -3
      kcha_g(33,4) =   3
      kcha_g(33,5) =  -1
      kcha_g(33,6) =   1

* KFcode
      kfco_e(33,1) =  11
      kfco_e(33,2) = -11
      kfco_e(33,3) =  11
      kfco_e(33,4) = -11
      kfco_e(33,5) =   1
      kfco_e(33,6) =  -1
* weight for the color base (llqq)
      cf_mtx(33,0,0) = 3.d0

      kmcb_s(33)    = 1
      kmcb_x(33)    = 2
      kmcs_r(33,1,0) = 5
      kmcs_r(33,2,0) = 6

* particle name
      kmpr_c(34,1) = 'electron'
      kmpr_l(34,1) = 8
      kmpr_c(34,2) = 'positron'
      kmpr_l(34,2) = 8
      kmpr_c(34,3) = 'electron'
      kmpr_l(34,3) = 8
      kmpr_c(34,4) = 'positron'
      kmpr_l(34,4) = 8
      kmpr_c(34,5) = 's'
      kmpr_l(34,5) = 1
      kmpr_c(34,6) = 's-bar'
      kmpr_l(34,6) = 5
* masses of external particles
      amas_1(34,1) = 11
      amas_1(34,2) = 11
      amas_1(34,3) = 11
      amas_1(34,4) = 11
      amas_1(34,5) = 3
      amas_1(34,6) = 3

* Charge*3
      kcha_g(34,1) =  -3
      kcha_g(34,2) =   3
      kcha_g(34,3) =  -3
      kcha_g(34,4) =   3
      kcha_g(34,5) =  -1
      kcha_g(34,6) =   1

* KFcode
      kfco_e(34,1) =  11
      kfco_e(34,2) = -11
      kfco_e(34,3) =  11
      kfco_e(34,4) = -11
      kfco_e(34,5) =   3
      kfco_e(34,6) =  -3
* weight for the color base (llqq)
      cf_mtx(34,0,0) = 3.d0

      kmcb_s(34)    = 1
      kmcb_x(34)    = 2
      kmcs_r(34,1,0) = 5
      kmcs_r(34,2,0) = 6

* particle name
      kmpr_c(35,1) = 'electron'
      kmpr_l(35,1) = 8
      kmpr_c(35,2) = 'positron'
      kmpr_l(35,2) = 8
      kmpr_c(35,3) = 'electron'
      kmpr_l(35,3) = 8
      kmpr_c(35,4) = 'positron'
      kmpr_l(35,4) = 8
      kmpr_c(35,5) = 'b'
      kmpr_l(35,5) = 1
      kmpr_c(35,6) = 'b-bar'
      kmpr_l(35,6) = 5
* masses of external particles
      amas_1(35,1) = 11
      amas_1(35,2) = 11
      amas_1(35,3) = 11
      amas_1(35,4) = 11
      amas_1(35,5) = 5
      amas_1(35,6) = 5

* Charge*3
      kcha_g(35,1) =  -3
      kcha_g(35,2) =   3
      kcha_g(35,3) =  -3
      kcha_g(35,4) =   3
      kcha_g(35,5) =  -1
      kcha_g(35,6) =   1

* KFcode
      kfco_e(35,1) =  11
      kfco_e(35,2) = -11
      kfco_e(35,3) =  11
      kfco_e(35,4) = -11
      kfco_e(35,5) =   5
      kfco_e(35,6) =  -5
* weight for the color base (llqq)
      cf_mtx(35,0,0) = 3.d0

      kmcb_s(35)    = 1
      kmcb_x(35)    = 2
      kmcs_r(35,1,0) = 5
      kmcs_r(35,2,0) = 6

* particle name
      kmpr_c(36,1) = 'electron'
      kmpr_l(36,1) = 8
      kmpr_c(36,2) = 'positron'
      kmpr_l(36,2) = 8
      kmpr_c(36,3) = 'muon'
      kmpr_l(36,3) = 4
      kmpr_c(36,4) = 'anti-muon'
      kmpr_l(36,4) = 9
      kmpr_c(36,5) = 'u'
      kmpr_l(36,5) = 1
      kmpr_c(36,6) = 'u-bar'
      kmpr_l(36,6) = 5
* masses of external particles
      amas_1(36,1) = 11
      amas_1(36,2) = 11
      amas_1(36,3) = 13
      amas_1(36,4) = 13
      amas_1(36,5) = 2
      amas_1(36,6) = 2

* Charge*3
      kcha_g(36,1) =  -3
      kcha_g(36,2) =   3
      kcha_g(36,3) =  -3
      kcha_g(36,4) =   3
      kcha_g(36,5) =   2
      kcha_g(36,6) =  -2

* KFcode
      kfco_e(36,1) =  11
      kfco_e(36,2) = -11
      kfco_e(36,3) =  13
      kfco_e(36,4) = -13
      kfco_e(36,5) =   2
      kfco_e(36,6) =  -2
* weight for the color base (llqq)
      cf_mtx(36,0,0) = 3.d0

      kmcb_s(36)    = 1
      kmcb_x(36)    = 2
      kmcs_r(36,1,0) = 5
      kmcs_r(36,2,0) = 6

* particle name
      kmpr_c(37,1) = 'electron'
      kmpr_l(37,1) = 8
      kmpr_c(37,2) = 'positron'
      kmpr_l(37,2) = 8
      kmpr_c(37,3) = 'muon'
      kmpr_l(37,3) = 4
      kmpr_c(37,4) = 'anti-muon'
      kmpr_l(37,4) = 9
      kmpr_c(37,5) = 'c'
      kmpr_l(37,5) = 1
      kmpr_c(37,6) = 'c-bar'
      kmpr_l(37,6) = 5
* masses of external particles
      amas_1(37,1) = 11
      amas_1(37,2) = 11
      amas_1(37,3) = 13
      amas_1(37,4) = 13
      amas_1(37,5) = 4
      amas_1(37,6) = 4

* Charge*3
      kcha_g(37,1) =  -3
      kcha_g(37,2) =   3
      kcha_g(37,3) =  -3
      kcha_g(37,4) =   3
      kcha_g(37,5) =   2
      kcha_g(37,6) =  -2

* KFcode
      kfco_e(37,1) =  11
      kfco_e(37,2) = -11
      kfco_e(37,3) =  13
      kfco_e(37,4) = -13
      kfco_e(37,5) =   4
      kfco_e(37,6) =  -4
* weight for the color base (llqq)
      cf_mtx(37,0,0) = 3.d0

      kmcb_s(37)    = 1
      kmcb_x(37)    = 2
      kmcs_r(37,1,0) = 5
      kmcs_r(37,2,0) = 6

* particle name
      kmpr_c(38,1) = 'electron'
      kmpr_l(38,1) = 8
      kmpr_c(38,2) = 'positron'
      kmpr_l(38,2) = 8
      kmpr_c(38,3) = 'tau'
      kmpr_l(38,3) = 3
      kmpr_c(38,4) = 'anti-tau'
      kmpr_l(38,4) = 8
      kmpr_c(38,5) = 'u'
      kmpr_l(38,5) = 1
      kmpr_c(38,6) = 'u-bar'
      kmpr_l(38,6) = 5
* masses of external particles
      amas_1(38,1) = 11
      amas_1(38,2) = 11
      amas_1(38,3) = 15
      amas_1(38,4) = 15
      amas_1(38,5) = 2
      amas_1(38,6) = 2

* Charge*3
      kcha_g(38,1) =  -3
      kcha_g(38,2) =   3
      kcha_g(38,3) =  -3
      kcha_g(38,4) =   3
      kcha_g(38,5) =   2
      kcha_g(38,6) =  -2

* KFcode
      kfco_e(38,1) =  11
      kfco_e(38,2) = -11
      kfco_e(38,3) =  15
      kfco_e(38,4) = -15
      kfco_e(38,5) =   2
      kfco_e(38,6) =  -2
* weight for the color base (llqq)
      cf_mtx(38,0,0) = 3.d0

      kmcb_s(38)    = 1
      kmcb_x(38)    = 2
      kmcs_r(38,1,0) = 5
      kmcs_r(38,2,0) = 6

* particle name
      kmpr_c(39,1) = 'electron'
      kmpr_l(39,1) = 8
      kmpr_c(39,2) = 'positron'
      kmpr_l(39,2) = 8
      kmpr_c(39,3) = 'tau'
      kmpr_l(39,3) = 3
      kmpr_c(39,4) = 'anti-tau'
      kmpr_l(39,4) = 8
      kmpr_c(39,5) = 'c'
      kmpr_l(39,5) = 1
      kmpr_c(39,6) = 'c-bar'
      kmpr_l(39,6) = 5
* masses of external particles
      amas_1(39,1) = 11
      amas_1(39,2) = 11
      amas_1(39,3) = 15
      amas_1(39,4) = 15
      amas_1(39,5) = 4
      amas_1(39,6) = 4

* Charge*3
      kcha_g(39,1) =  -3
      kcha_g(39,2) =   3
      kcha_g(39,3) =  -3
      kcha_g(39,4) =   3
      kcha_g(39,5) =   2
      kcha_g(39,6) =  -2

* KFcode
      kfco_e(39,1) =  11
      kfco_e(39,2) = -11
      kfco_e(39,3) =  15
      kfco_e(39,4) = -15
      kfco_e(39,5) =   4
      kfco_e(39,6) =  -4
* weight for the color base (llqq)
      cf_mtx(39,0,0) = 3.d0

      kmcb_s(39)    = 1
      kmcb_x(39)    = 2
      kmcs_r(39,1,0) = 5
      kmcs_r(39,2,0) = 6

* particle name
      kmpr_c(40,1) = 'electron'
      kmpr_l(40,1) = 8
      kmpr_c(40,2) = 'positron'
      kmpr_l(40,2) = 8
      kmpr_c(40,3) = 'muon'
      kmpr_l(40,3) = 4
      kmpr_c(40,4) = 'anti-muon'
      kmpr_l(40,4) = 9
      kmpr_c(40,5) = 'd'
      kmpr_l(40,5) = 1
      kmpr_c(40,6) = 'd-bar'
      kmpr_l(40,6) = 5
* masses of external particles
      amas_1(40,1) = 11
      amas_1(40,2) = 11
      amas_1(40,3) = 13
      amas_1(40,4) = 13
      amas_1(40,5) = 1
      amas_1(40,6) = 1

* Charge*3
      kcha_g(40,1) =  -3
      kcha_g(40,2) =   3
      kcha_g(40,3) =  -3
      kcha_g(40,4) =   3
      kcha_g(40,5) =  -1
      kcha_g(40,6) =   1

* KFcode
      kfco_e(40,1) =  11
      kfco_e(40,2) = -11
      kfco_e(40,3) =  13
      kfco_e(40,4) = -13
      kfco_e(40,5) =   1
      kfco_e(40,6) =  -1
* weight for the color base (llqq)
      cf_mtx(40,0,0) = 3.d0

      kmcb_s(40)    = 1
      kmcb_x(40)    = 2
      kmcs_r(40,1,0) = 5
      kmcs_r(40,2,0) = 6

* particle name
      kmpr_c(41,1) = 'electron'
      kmpr_l(41,1) = 8
      kmpr_c(41,2) = 'positron'
      kmpr_l(41,2) = 8
      kmpr_c(41,3) = 'muon'
      kmpr_l(41,3) = 4
      kmpr_c(41,4) = 'anti-muon'
      kmpr_l(41,4) = 9
      kmpr_c(41,5) = 's'
      kmpr_l(41,5) = 1
      kmpr_c(41,6) = 's-bar'
      kmpr_l(41,6) = 5
* masses of external particles
      amas_1(41,1) = 11
      amas_1(41,2) = 11
      amas_1(41,3) = 13
      amas_1(41,4) = 13
      amas_1(41,5) = 3
      amas_1(41,6) = 3

* Charge*3
      kcha_g(41,1) =  -3
      kcha_g(41,2) =   3
      kcha_g(41,3) =  -3
      kcha_g(41,4) =   3
      kcha_g(41,5) =  -1
      kcha_g(41,6) =   1

* KFcode
      kfco_e(41,1) =  11
      kfco_e(41,2) = -11
      kfco_e(41,3) =  13
      kfco_e(41,4) = -13
      kfco_e(41,5) =   3
      kfco_e(41,6) =  -3
* weight for the color base (llqq)
      cf_mtx(41,0,0) = 3.d0

      kmcb_s(41)    = 1
      kmcb_x(41)    = 2
      kmcs_r(41,1,0) = 5
      kmcs_r(41,2,0) = 6

* particle name
      kmpr_c(42,1) = 'electron'
      kmpr_l(42,1) = 8
      kmpr_c(42,2) = 'positron'
      kmpr_l(42,2) = 8
      kmpr_c(42,3) = 'muon'
      kmpr_l(42,3) = 4
      kmpr_c(42,4) = 'anti-muon'
      kmpr_l(42,4) = 9
      kmpr_c(42,5) = 'b'
      kmpr_l(42,5) = 1
      kmpr_c(42,6) = 'b-bar'
      kmpr_l(42,6) = 5
* masses of external particles
      amas_1(42,1) = 11
      amas_1(42,2) = 11
      amas_1(42,3) = 13
      amas_1(42,4) = 13
      amas_1(42,5) = 5
      amas_1(42,6) = 5

* Charge*3
      kcha_g(42,1) =  -3
      kcha_g(42,2) =   3
      kcha_g(42,3) =  -3
      kcha_g(42,4) =   3
      kcha_g(42,5) =  -1
      kcha_g(42,6) =   1

* KFcode
      kfco_e(42,1) =  11
      kfco_e(42,2) = -11
      kfco_e(42,3) =  13
      kfco_e(42,4) = -13
      kfco_e(42,5) =   5
      kfco_e(42,6) =  -5
* weight for the color base (llqq)
      cf_mtx(42,0,0) = 3.d0

      kmcb_s(42)    = 1
      kmcb_x(42)    = 2
      kmcs_r(42,1,0) = 5
      kmcs_r(42,2,0) = 6

* particle name
      kmpr_c(43,1) = 'electron'
      kmpr_l(43,1) = 8
      kmpr_c(43,2) = 'positron'
      kmpr_l(43,2) = 8
      kmpr_c(43,3) = 'tau'
      kmpr_l(43,3) = 3
      kmpr_c(43,4) = 'anti-tau'
      kmpr_l(43,4) = 8
      kmpr_c(43,5) = 'd'
      kmpr_l(43,5) = 1
      kmpr_c(43,6) = 'd-bar'
      kmpr_l(43,6) = 5
* masses of external particles
      amas_1(43,1) = 11
      amas_1(43,2) = 11
      amas_1(43,3) = 15
      amas_1(43,4) = 15
      amas_1(43,5) = 1
      amas_1(43,6) = 1

* Charge*3
      kcha_g(43,1) =  -3
      kcha_g(43,2) =   3
      kcha_g(43,3) =  -3
      kcha_g(43,4) =   3
      kcha_g(43,5) =  -1
      kcha_g(43,6) =   1

* KFcode
      kfco_e(43,1) =  11
      kfco_e(43,2) = -11
      kfco_e(43,3) =  15
      kfco_e(43,4) = -15
      kfco_e(43,5) =   1
      kfco_e(43,6) =  -1
* weight for the color base (llqq)
      cf_mtx(43,0,0) = 3.d0

      kmcb_s(43)    = 1
      kmcb_x(43)    = 2
      kmcs_r(43,1,0) = 5
      kmcs_r(43,2,0) = 6

* particle name
      kmpr_c(44,1) = 'electron'
      kmpr_l(44,1) = 8
      kmpr_c(44,2) = 'positron'
      kmpr_l(44,2) = 8
      kmpr_c(44,3) = 'tau'
      kmpr_l(44,3) = 3
      kmpr_c(44,4) = 'anti-tau'
      kmpr_l(44,4) = 8
      kmpr_c(44,5) = 's'
      kmpr_l(44,5) = 1
      kmpr_c(44,6) = 's-bar'
      kmpr_l(44,6) = 5
* masses of external particles
      amas_1(44,1) = 11
      amas_1(44,2) = 11
      amas_1(44,3) = 15
      amas_1(44,4) = 15
      amas_1(44,5) = 3
      amas_1(44,6) = 3

* Charge*3
      kcha_g(44,1) =  -3
      kcha_g(44,2) =   3
      kcha_g(44,3) =  -3
      kcha_g(44,4) =   3
      kcha_g(44,5) =  -1
      kcha_g(44,6) =   1

* KFcode
      kfco_e(44,1) =  11
      kfco_e(44,2) = -11
      kfco_e(44,3) =  15
      kfco_e(44,4) = -15
      kfco_e(44,5) =   3
      kfco_e(44,6) =  -3
* weight for the color base (llqq)
      cf_mtx(44,0,0) = 3.d0

      kmcb_s(44)    = 1
      kmcb_x(44)    = 2
      kmcs_r(44,1,0) = 5
      kmcs_r(44,2,0) = 6

* particle name
      kmpr_c(45,1) = 'electron'
      kmpr_l(45,1) = 8
      kmpr_c(45,2) = 'positron'
      kmpr_l(45,2) = 8
      kmpr_c(45,3) = 'tau'
      kmpr_l(45,3) = 3
      kmpr_c(45,4) = 'anti-tau'
      kmpr_l(45,4) = 8
      kmpr_c(45,5) = 'b'
      kmpr_l(45,5) = 1
      kmpr_c(45,6) = 'b-bar'
      kmpr_l(45,6) = 5
* masses of external particles
      amas_1(45,1) = 11
      amas_1(45,2) = 11
      amas_1(45,3) = 15
      amas_1(45,4) = 15
      amas_1(45,5) = 5
      amas_1(45,6) = 5

* Charge*3
      kcha_g(45,1) =  -3
      kcha_g(45,2) =   3
      kcha_g(45,3) =  -3
      kcha_g(45,4) =   3
      kcha_g(45,5) =  -1
      kcha_g(45,6) =   1

* KFcode
      kfco_e(45,1) =  11
      kfco_e(45,2) = -11
      kfco_e(45,3) =  15
      kfco_e(45,4) = -15
      kfco_e(45,5) =   5
      kfco_e(45,6) =  -5
* weight for the color base (llqq)
      cf_mtx(45,0,0) = 3.d0

      kmcb_s(45)    = 1
      kmcb_x(45)    = 2
      kmcs_r(45,1,0) = 5
      kmcs_r(45,2,0) = 6

* particle name
      kmpr_c(46,1) = 'electron'
      kmpr_l(46,1) = 8
      kmpr_c(46,2) = 'positron'
      kmpr_l(46,2) = 8
      kmpr_c(46,3) = 'nu-e'
      kmpr_l(46,3) = 4
      kmpr_c(46,4) = 'nu-e-bar'
      kmpr_l(46,4) = 8
      kmpr_c(46,5) = 'u'
      kmpr_l(46,5) = 1
      kmpr_c(46,6) = 'u-bar'
      kmpr_l(46,6) = 5
* masses of external particles
      amas_1(46,1) = 11
      amas_1(46,2) = 11
      amas_1(46,3) = 12
      amas_1(46,4) = 12
      amas_1(46,5) = 2
      amas_1(46,6) = 2

* Charge*3
      kcha_g(46,1) =  -3
      kcha_g(46,2) =   3
      kcha_g(46,3) =   0
      kcha_g(46,4) =   0
      kcha_g(46,5) =   2
      kcha_g(46,6) =  -2

* KFcode
      kfco_e(46,1) =  11
      kfco_e(46,2) = -11
      kfco_e(46,3) =  12
      kfco_e(46,4) = -12
      kfco_e(46,5) =   2
      kfco_e(46,6) =  -2
* weight for the color base (llqq)
      cf_mtx(46,0,0) = 3.d0

      kmcb_s(46)    = 1
      kmcb_x(46)    = 2
      kmcs_r(46,1,0) = 5
      kmcs_r(46,2,0) = 6

* particle name
      kmpr_c(47,1) = 'electron'
      kmpr_l(47,1) = 8
      kmpr_c(47,2) = 'positron'
      kmpr_l(47,2) = 8
      kmpr_c(47,3) = 'nu-e'
      kmpr_l(47,3) = 4
      kmpr_c(47,4) = 'nu-e-bar'
      kmpr_l(47,4) = 8
      kmpr_c(47,5) = 'c'
      kmpr_l(47,5) = 1
      kmpr_c(47,6) = 'c-bar'
      kmpr_l(47,6) = 5
* masses of external particles
      amas_1(47,1) = 11
      amas_1(47,2) = 11
      amas_1(47,3) = 12
      amas_1(47,4) = 12
      amas_1(47,5) = 4
      amas_1(47,6) = 4

* Charge*3
      kcha_g(47,1) =  -3
      kcha_g(47,2) =   3
      kcha_g(47,3) =   0
      kcha_g(47,4) =   0
      kcha_g(47,5) =   2
      kcha_g(47,6) =  -2

* KFcode
      kfco_e(47,1) =  11
      kfco_e(47,2) = -11
      kfco_e(47,3) =  12
      kfco_e(47,4) = -12
      kfco_e(47,5) =   4
      kfco_e(47,6) =  -4
* weight for the color base (llqq)
      cf_mtx(47,0,0) = 3.d0

      kmcb_s(47)    = 1
      kmcb_x(47)    = 2
      kmcs_r(47,1,0) = 5
      kmcs_r(47,2,0) = 6

* particle name
      kmpr_c(48,1) = 'electron'
      kmpr_l(48,1) = 8
      kmpr_c(48,2) = 'positron'
      kmpr_l(48,2) = 8
      kmpr_c(48,3) = 'nu-e'
      kmpr_l(48,3) = 4
      kmpr_c(48,4) = 'nu-e-bar'
      kmpr_l(48,4) = 8
      kmpr_c(48,5) = 'd'
      kmpr_l(48,5) = 1
      kmpr_c(48,6) = 'd-bar'
      kmpr_l(48,6) = 5
* masses of external particles
      amas_1(48,1) = 11
      amas_1(48,2) = 11
      amas_1(48,3) = 12
      amas_1(48,4) = 12
      amas_1(48,5) = 1
      amas_1(48,6) = 1

* Charge*3
      kcha_g(48,1) =  -3
      kcha_g(48,2) =   3
      kcha_g(48,3) =   0
      kcha_g(48,4) =   0
      kcha_g(48,5) =  -1
      kcha_g(48,6) =   1

* KFcode
      kfco_e(48,1) =  11
      kfco_e(48,2) = -11
      kfco_e(48,3) =  12
      kfco_e(48,4) = -12
      kfco_e(48,5) =   1
      kfco_e(48,6) =  -1
* weight for the color base (llqq)
      cf_mtx(48,0,0) = 3.d0

      kmcb_s(48)    = 1
      kmcb_x(48)    = 2
      kmcs_r(48,1,0) = 5
      kmcs_r(48,2,0) = 6

* particle name
      kmpr_c(49,1) = 'electron'
      kmpr_l(49,1) = 8
      kmpr_c(49,2) = 'positron'
      kmpr_l(49,2) = 8
      kmpr_c(49,3) = 'nu-e'
      kmpr_l(49,3) = 4
      kmpr_c(49,4) = 'nu-e-bar'
      kmpr_l(49,4) = 8
      kmpr_c(49,5) = 's'
      kmpr_l(49,5) = 1
      kmpr_c(49,6) = 's-bar'
      kmpr_l(49,6) = 5
* masses of external particles
      amas_1(49,1) = 11
      amas_1(49,2) = 11
      amas_1(49,3) = 12
      amas_1(49,4) = 12
      amas_1(49,5) = 3
      amas_1(49,6) = 3

* Charge*3
      kcha_g(49,1) =  -3
      kcha_g(49,2) =   3
      kcha_g(49,3) =   0
      kcha_g(49,4) =   0
      kcha_g(49,5) =  -1
      kcha_g(49,6) =   1

* KFcode
      kfco_e(49,1) =  11
      kfco_e(49,2) = -11
      kfco_e(49,3) =  12
      kfco_e(49,4) = -12
      kfco_e(49,5) =   3
      kfco_e(49,6) =  -3
* weight for the color base (llqq)
      cf_mtx(49,0,0) = 3.d0

      kmcb_s(49)    = 1
      kmcb_x(49)    = 2
      kmcs_r(49,1,0) = 5
      kmcs_r(49,2,0) = 6

* particle name
      kmpr_c(50,1) = 'electron'
      kmpr_l(50,1) = 8
      kmpr_c(50,2) = 'positron'
      kmpr_l(50,2) = 8
      kmpr_c(50,3) = 'nu-e'
      kmpr_l(50,3) = 4
      kmpr_c(50,4) = 'nu-e-bar'
      kmpr_l(50,4) = 8
      kmpr_c(50,5) = 'b'
      kmpr_l(50,5) = 1
      kmpr_c(50,6) = 'b-bar'
      kmpr_l(50,6) = 5
* masses of external particles
      amas_1(50,1) = 11
      amas_1(50,2) = 11
      amas_1(50,3) = 12
      amas_1(50,4) = 12
      amas_1(50,5) = 5
      amas_1(50,6) = 5

* Charge*3
      kcha_g(50,1) =  -3
      kcha_g(50,2) =   3
      kcha_g(50,3) =   0
      kcha_g(50,4) =   0
      kcha_g(50,5) =  -1
      kcha_g(50,6) =   1

* KFcode
      kfco_e(50,1) =  11
      kfco_e(50,2) = -11
      kfco_e(50,3) =  12
      kfco_e(50,4) = -12
      kfco_e(50,5) =   5
      kfco_e(50,6) =  -5
* weight for the color base (llqq)
      cf_mtx(50,0,0) = 3.d0

      kmcb_s(50)    = 1
      kmcb_x(50)    = 2
      kmcs_r(50,1,0) = 5
      kmcs_r(50,2,0) = 6

* particle name
      kmpr_c(51,1) = 'electron'
      kmpr_l(51,1) = 8
      kmpr_c(51,2) = 'positron'
      kmpr_l(51,2) = 8
      kmpr_c(51,3) = 'nu-mu'
      kmpr_l(51,3) = 5
      kmpr_c(51,4) = 'nu-mu-bar'
      kmpr_l(51,4) = 9
      kmpr_c(51,5) = 'u'
      kmpr_l(51,5) = 1
      kmpr_c(51,6) = 'u-bar'
      kmpr_l(51,6) = 5
* masses of external particles
      amas_1(51,1) = 11
      amas_1(51,2) = 11
      amas_1(51,3) = 14
      amas_1(51,4) = 14
      amas_1(51,5) = 2
      amas_1(51,6) = 2

* Charge*3
      kcha_g(51,1) =  -3
      kcha_g(51,2) =   3
      kcha_g(51,3) =   0
      kcha_g(51,4) =   0
      kcha_g(51,5) =   2
      kcha_g(51,6) =  -2

* KFcode
      kfco_e(51,1) =  11
      kfco_e(51,2) = -11
      kfco_e(51,3) =  14
      kfco_e(51,4) = -14
      kfco_e(51,5) =   2
      kfco_e(51,6) =  -2
* weight for the color base (llqq)
      cf_mtx(51,0,0) = 3.d0

      kmcb_s(51)    = 1
      kmcb_x(51)    = 2
      kmcs_r(51,1,0) = 5
      kmcs_r(51,2,0) = 6

* particle name
      kmpr_c(52,1) = 'electron'
      kmpr_l(52,1) = 8
      kmpr_c(52,2) = 'positron'
      kmpr_l(52,2) = 8
      kmpr_c(52,3) = 'nu-mu'
      kmpr_l(52,3) = 5
      kmpr_c(52,4) = 'nu-mu-bar'
      kmpr_l(52,4) = 9
      kmpr_c(52,5) = 'c'
      kmpr_l(52,5) = 1
      kmpr_c(52,6) = 'c-bar'
      kmpr_l(52,6) = 5
* masses of external particles
      amas_1(52,1) = 11
      amas_1(52,2) = 11
      amas_1(52,3) = 14
      amas_1(52,4) = 14
      amas_1(52,5) = 4
      amas_1(52,6) = 4

* Charge*3
      kcha_g(52,1) =  -3
      kcha_g(52,2) =   3
      kcha_g(52,3) =   0
      kcha_g(52,4) =   0
      kcha_g(52,5) =   2
      kcha_g(52,6) =  -2

* KFcode
      kfco_e(52,1) =  11
      kfco_e(52,2) = -11
      kfco_e(52,3) =  14
      kfco_e(52,4) = -14
      kfco_e(52,5) =   4
      kfco_e(52,6) =  -4
* weight for the color base (llqq)
      cf_mtx(52,0,0) = 3.d0

      kmcb_s(52)    = 1
      kmcb_x(52)    = 2
      kmcs_r(52,1,0) = 5
      kmcs_r(52,2,0) = 6

* particle name
      kmpr_c(53,1) = 'electron'
      kmpr_l(53,1) = 8
      kmpr_c(53,2) = 'positron'
      kmpr_l(53,2) = 8
      kmpr_c(53,3) = 'nu-tau'
      kmpr_l(53,3) = 6
      kmpr_c(53,4) = 'nu-tau-bar'
      kmpr_l(53,4) = 10
      kmpr_c(53,5) = 'u'
      kmpr_l(53,5) = 1
      kmpr_c(53,6) = 'u-bar'
      kmpr_l(53,6) = 5
* masses of external particles
      amas_1(53,1) = 11
      amas_1(53,2) = 11
      amas_1(53,3) = 16
      amas_1(53,4) = 16
      amas_1(53,5) = 2
      amas_1(53,6) = 2

* Charge*3
      kcha_g(53,1) =  -3
      kcha_g(53,2) =   3
      kcha_g(53,3) =   0
      kcha_g(53,4) =   0
      kcha_g(53,5) =   2
      kcha_g(53,6) =  -2

* KFcode
      kfco_e(53,1) =  11
      kfco_e(53,2) = -11
      kfco_e(53,3) =  16
      kfco_e(53,4) = -16
      kfco_e(53,5) =   2
      kfco_e(53,6) =  -2
* weight for the color base (llqq)
      cf_mtx(53,0,0) = 3.d0

      kmcb_s(53)    = 1
      kmcb_x(53)    = 2
      kmcs_r(53,1,0) = 5
      kmcs_r(53,2,0) = 6

* particle name
      kmpr_c(54,1) = 'electron'
      kmpr_l(54,1) = 8
      kmpr_c(54,2) = 'positron'
      kmpr_l(54,2) = 8
      kmpr_c(54,3) = 'nu-tau'
      kmpr_l(54,3) = 6
      kmpr_c(54,4) = 'nu-tau-bar'
      kmpr_l(54,4) = 10
      kmpr_c(54,5) = 'c'
      kmpr_l(54,5) = 1
      kmpr_c(54,6) = 'c-bar'
      kmpr_l(54,6) = 5
* masses of external particles
      amas_1(54,1) = 11
      amas_1(54,2) = 11
      amas_1(54,3) = 16
      amas_1(54,4) = 16
      amas_1(54,5) = 4
      amas_1(54,6) = 4

* Charge*3
      kcha_g(54,1) =  -3
      kcha_g(54,2) =   3
      kcha_g(54,3) =   0
      kcha_g(54,4) =   0
      kcha_g(54,5) =   2
      kcha_g(54,6) =  -2

* KFcode
      kfco_e(54,1) =  11
      kfco_e(54,2) = -11
      kfco_e(54,3) =  16
      kfco_e(54,4) = -16
      kfco_e(54,5) =   4
      kfco_e(54,6) =  -4
* weight for the color base (llqq)
      cf_mtx(54,0,0) = 3.d0

      kmcb_s(54)    = 1
      kmcb_x(54)    = 2
      kmcs_r(54,1,0) = 5
      kmcs_r(54,2,0) = 6

* particle name
      kmpr_c(55,1) = 'electron'
      kmpr_l(55,1) = 8
      kmpr_c(55,2) = 'positron'
      kmpr_l(55,2) = 8
      kmpr_c(55,3) = 'nu-mu'
      kmpr_l(55,3) = 5
      kmpr_c(55,4) = 'nu-mu-bar'
      kmpr_l(55,4) = 9
      kmpr_c(55,5) = 'd'
      kmpr_l(55,5) = 1
      kmpr_c(55,6) = 'd-bar'
      kmpr_l(55,6) = 5
* masses of external particles
      amas_1(55,1) = 11
      amas_1(55,2) = 11
      amas_1(55,3) = 14
      amas_1(55,4) = 14
      amas_1(55,5) = 1
      amas_1(55,6) = 1

* Charge*3
      kcha_g(55,1) =  -3
      kcha_g(55,2) =   3
      kcha_g(55,3) =   0
      kcha_g(55,4) =   0
      kcha_g(55,5) =  -1
      kcha_g(55,6) =   1

* KFcode
      kfco_e(55,1) =  11
      kfco_e(55,2) = -11
      kfco_e(55,3) =  14
      kfco_e(55,4) = -14
      kfco_e(55,5) =   1
      kfco_e(55,6) =  -1
* weight for the color base (llqq)
      cf_mtx(55,0,0) = 3.d0

      kmcb_s(55)    = 1
      kmcb_x(55)    = 2
      kmcs_r(55,1,0) = 5
      kmcs_r(55,2,0) = 6

* particle name
      kmpr_c(56,1) = 'electron'
      kmpr_l(56,1) = 8
      kmpr_c(56,2) = 'positron'
      kmpr_l(56,2) = 8
      kmpr_c(56,3) = 'nu-mu'
      kmpr_l(56,3) = 5
      kmpr_c(56,4) = 'nu-mu-bar'
      kmpr_l(56,4) = 9
      kmpr_c(56,5) = 's'
      kmpr_l(56,5) = 1
      kmpr_c(56,6) = 's-bar'
      kmpr_l(56,6) = 5
* masses of external particles
      amas_1(56,1) = 11
      amas_1(56,2) = 11
      amas_1(56,3) = 14
      amas_1(56,4) = 14
      amas_1(56,5) = 3
      amas_1(56,6) = 3

* Charge*3
      kcha_g(56,1) =  -3
      kcha_g(56,2) =   3
      kcha_g(56,3) =   0
      kcha_g(56,4) =   0
      kcha_g(56,5) =  -1
      kcha_g(56,6) =   1

* KFcode
      kfco_e(56,1) =  11
      kfco_e(56,2) = -11
      kfco_e(56,3) =  14
      kfco_e(56,4) = -14
      kfco_e(56,5) =   3
      kfco_e(56,6) =  -3
* weight for the color base (llqq)
      cf_mtx(56,0,0) = 3.d0

      kmcb_s(56)    = 1
      kmcb_x(56)    = 2
      kmcs_r(56,1,0) = 5
      kmcs_r(56,2,0) = 6

* particle name
      kmpr_c(57,1) = 'electron'
      kmpr_l(57,1) = 8
      kmpr_c(57,2) = 'positron'
      kmpr_l(57,2) = 8
      kmpr_c(57,3) = 'nu-mu'
      kmpr_l(57,3) = 5
      kmpr_c(57,4) = 'nu-mu-bar'
      kmpr_l(57,4) = 9
      kmpr_c(57,5) = 'b'
      kmpr_l(57,5) = 1
      kmpr_c(57,6) = 'b-bar'
      kmpr_l(57,6) = 5
* masses of external particles
      amas_1(57,1) = 11
      amas_1(57,2) = 11
      amas_1(57,3) = 14
      amas_1(57,4) = 14
      amas_1(57,5) = 5
      amas_1(57,6) = 5

* Charge*3
      kcha_g(57,1) =  -3
      kcha_g(57,2) =   3
      kcha_g(57,3) =   0
      kcha_g(57,4) =   0
      kcha_g(57,5) =  -1
      kcha_g(57,6) =   1

* KFcode
      kfco_e(57,1) =  11
      kfco_e(57,2) = -11
      kfco_e(57,3) =  14
      kfco_e(57,4) = -14
      kfco_e(57,5) =   5
      kfco_e(57,6) =  -5
* weight for the color base (llqq)
      cf_mtx(57,0,0) = 3.d0

      kmcb_s(57)    = 1
      kmcb_x(57)    = 2
      kmcs_r(57,1,0) = 5
      kmcs_r(57,2,0) = 6

* particle name
      kmpr_c(58,1) = 'electron'
      kmpr_l(58,1) = 8
      kmpr_c(58,2) = 'positron'
      kmpr_l(58,2) = 8
      kmpr_c(58,3) = 'nu-tau'
      kmpr_l(58,3) = 6
      kmpr_c(58,4) = 'nu-tau-bar'
      kmpr_l(58,4) = 10
      kmpr_c(58,5) = 'd'
      kmpr_l(58,5) = 1
      kmpr_c(58,6) = 'd-bar'
      kmpr_l(58,6) = 5
* masses of external particles
      amas_1(58,1) = 11
      amas_1(58,2) = 11
      amas_1(58,3) = 16
      amas_1(58,4) = 16
      amas_1(58,5) = 1
      amas_1(58,6) = 1

* Charge*3
      kcha_g(58,1) =  -3
      kcha_g(58,2) =   3
      kcha_g(58,3) =   0
      kcha_g(58,4) =   0
      kcha_g(58,5) =  -1
      kcha_g(58,6) =   1

* KFcode
      kfco_e(58,1) =  11
      kfco_e(58,2) = -11
      kfco_e(58,3) =  16
      kfco_e(58,4) = -16
      kfco_e(58,5) =   1
      kfco_e(58,6) =  -1
* weight for the color base (llqq)
      cf_mtx(58,0,0) = 3.d0

      kmcb_s(58)    = 1
      kmcb_x(58)    = 2
      kmcs_r(58,1,0) = 5
      kmcs_r(58,2,0) = 6

* particle name
      kmpr_c(59,1) = 'electron'
      kmpr_l(59,1) = 8
      kmpr_c(59,2) = 'positron'
      kmpr_l(59,2) = 8
      kmpr_c(59,3) = 'nu-tau'
      kmpr_l(59,3) = 6
      kmpr_c(59,4) = 'nu-tau-bar'
      kmpr_l(59,4) = 10
      kmpr_c(59,5) = 's'
      kmpr_l(59,5) = 1
      kmpr_c(59,6) = 's-bar'
      kmpr_l(59,6) = 5
* masses of external particles
      amas_1(59,1) = 11
      amas_1(59,2) = 11
      amas_1(59,3) = 16
      amas_1(59,4) = 16
      amas_1(59,5) = 3
      amas_1(59,6) = 3

* Charge*3
      kcha_g(59,1) =  -3
      kcha_g(59,2) =   3
      kcha_g(59,3) =   0
      kcha_g(59,4) =   0
      kcha_g(59,5) =  -1
      kcha_g(59,6) =   1

* KFcode
      kfco_e(59,1) =  11
      kfco_e(59,2) = -11
      kfco_e(59,3) =  16
      kfco_e(59,4) = -16
      kfco_e(59,5) =   3
      kfco_e(59,6) =  -3
* weight for the color base (llqq)
      cf_mtx(59,0,0) = 3.d0

      kmcb_s(59)    = 1
      kmcb_x(59)    = 2
      kmcs_r(59,1,0) = 5
      kmcs_r(59,2,0) = 6

* particle name
      kmpr_c(60,1) = 'electron'
      kmpr_l(60,1) = 8
      kmpr_c(60,2) = 'positron'
      kmpr_l(60,2) = 8
      kmpr_c(60,3) = 'nu-tau'
      kmpr_l(60,3) = 6
      kmpr_c(60,4) = 'nu-tau-bar'
      kmpr_l(60,4) = 10
      kmpr_c(60,5) = 'b'
      kmpr_l(60,5) = 1
      kmpr_c(60,6) = 'b-bar'
      kmpr_l(60,6) = 5
* masses of external particles
      amas_1(60,1) = 11
      amas_1(60,2) = 11
      amas_1(60,3) = 16
      amas_1(60,4) = 16
      amas_1(60,5) = 5
      amas_1(60,6) = 5

* Charge*3
      kcha_g(60,1) =  -3
      kcha_g(60,2) =   3
      kcha_g(60,3) =   0
      kcha_g(60,4) =   0
      kcha_g(60,5) =  -1
      kcha_g(60,6) =   1

* KFcode
      kfco_e(60,1) =  11
      kfco_e(60,2) = -11
      kfco_e(60,3) =  16
      kfco_e(60,4) = -16
      kfco_e(60,5) =   5
      kfco_e(60,6) =  -5
* weight for the color base (llqq)
      cf_mtx(60,0,0) = 3.d0

      kmcb_s(60)    = 1
      kmcb_x(60)    = 2
      kmcs_r(60,1,0) = 5
      kmcs_r(60,2,0) = 6

* particle name
      kmpr_c(61,1) = 'electron'
      kmpr_l(61,1) = 8
      kmpr_c(61,2) = 'positron'
      kmpr_l(61,2) = 8
      kmpr_c(61,3) = 'u'
      kmpr_l(61,3) = 1
      kmpr_c(61,4) = 'd-bar'
      kmpr_l(61,4) = 5
      kmpr_c(61,5) = 'd'
      kmpr_l(61,5) = 1
      kmpr_c(61,6) = 'u-bar'
      kmpr_l(61,6) = 5
* masses of external particles
      amas_1(61,1) = 11
      amas_1(61,2) = 11
      amas_1(61,3) = 2
      amas_1(61,4) = 1
      amas_1(61,5) = 1
      amas_1(61,6) = 2

* Charge*3
      kcha_g(61,1) =  -3
      kcha_g(61,2) =   3
      kcha_g(61,3) =   2
      kcha_g(61,4) =   1
      kcha_g(61,5) =  -1
      kcha_g(61,6) =  -2

* KFcode
      kfco_e(61,1) =  11
      kfco_e(61,2) = -11
      kfco_e(61,3) =   2
      kfco_e(61,4) =  -1
      kfco_e(61,5) =   1
      kfco_e(61,6) =  -2
* weight for the color base (qqqq)
      cf_mtx(61,0,0)= 9.d0
      cf_mtx(61,0,1)= 3.d0
      cf_mtx(61,1,0)= 3.d0
      cf_mtx(61,1,1)= 9.d0

      kmcb_s(61)    = 2
      kmcb_x(61)    = 4
      kmcs_r(61,1,0) = 3
      kmcs_r(61,2,0) = 4
      kmcs_r(61,3,0) = 5
      kmcs_r(61,4,0) = 6
      kmcs_r(61,1,1) = 3
      kmcs_r(61,2,1) = 6
      kmcs_r(61,3,1) = 4
      kmcs_r(61,4,1) = 5

* particle name
      kmpr_c(62,1) = 'electron'
      kmpr_l(62,1) = 8
      kmpr_c(62,2) = 'positron'
      kmpr_l(62,2) = 8
      kmpr_c(62,3) = 'c'
      kmpr_l(62,3) = 1
      kmpr_c(62,4) = 's-bar'
      kmpr_l(62,4) = 5
      kmpr_c(62,5) = 's'
      kmpr_l(62,5) = 1
      kmpr_c(62,6) = 'c-bar'
      kmpr_l(62,6) = 5
* masses of external particles
      amas_1(62,1) = 11
      amas_1(62,2) = 11
      amas_1(62,3) = 4
      amas_1(62,4) = 3
      amas_1(62,5) = 3
      amas_1(62,6) = 4

* Charge*3
      kcha_g(62,1) =  -3
      kcha_g(62,2) =   3
      kcha_g(62,3) =   2
      kcha_g(62,4) =   1
      kcha_g(62,5) =  -1
      kcha_g(62,6) =  -2

* KFcode
      kfco_e(62,1) =  11
      kfco_e(62,2) = -11
      kfco_e(62,3) =   4
      kfco_e(62,4) =  -3
      kfco_e(62,5) =   3
      kfco_e(62,6) =  -4
* weight for the color base (qqqq)
      cf_mtx(62,0,0)= 9.d0
      cf_mtx(62,0,1)= 3.d0
      cf_mtx(62,1,0)= 3.d0
      cf_mtx(62,1,1)= 9.d0

      kmcb_s(62)    = 2
      kmcb_x(62)    = 4
      kmcs_r(62,1,0) = 3
      kmcs_r(62,2,0) = 4
      kmcs_r(62,3,0) = 5
      kmcs_r(62,4,0) = 6
      kmcs_r(62,1,1) = 3
      kmcs_r(62,2,1) = 6
      kmcs_r(62,3,1) = 4
      kmcs_r(62,4,1) = 5

* particle name
      kmpr_c(63,1) = 'electron'
      kmpr_l(63,1) = 8
      kmpr_c(63,2) = 'positron'
      kmpr_l(63,2) = 8
      kmpr_c(63,3) = 'u'
      kmpr_l(63,3) = 1
      kmpr_c(63,4) = 'd-bar'
      kmpr_l(63,4) = 5
      kmpr_c(63,5) = 's'
      kmpr_l(63,5) = 1
      kmpr_c(63,6) = 'c-bar'
      kmpr_l(63,6) = 5
* masses of external particles
      amas_1(63,1) = 11
      amas_1(63,2) = 11
      amas_1(63,3) = 2
      amas_1(63,4) = 1
      amas_1(63,5) = 3
      amas_1(63,6) = 4

* Charge*3
      kcha_g(63,1) =  -3
      kcha_g(63,2) =   3
      kcha_g(63,3) =   2
      kcha_g(63,4) =   1
      kcha_g(63,5) =  -1
      kcha_g(63,6) =  -2

* KFcode
      kfco_e(63,1) =  11
      kfco_e(63,2) = -11
      kfco_e(63,3) =   2
      kfco_e(63,4) =  -1
      kfco_e(63,5) =   3
      kfco_e(63,6) =  -4
* weight for the color base (qqqq)
      cf_mtx(63,0,0)= 9.d0
      cf_mtx(63,0,1)= 3.d0
      cf_mtx(63,1,0)= 3.d0
      cf_mtx(63,1,1)= 9.d0

      kmcb_s(63)    = 2
      kmcb_x(63)    = 4
      kmcs_r(63,1,0) = 3
      kmcs_r(63,2,0) = 4
      kmcs_r(63,3,0) = 5
      kmcs_r(63,4,0) = 6
      kmcs_r(63,1,1) = 3
      kmcs_r(63,2,1) = 6
      kmcs_r(63,3,1) = 4
      kmcs_r(63,4,1) = 5

* particle name
      kmpr_c(64,1) = 'electron'
      kmpr_l(64,1) = 8
      kmpr_c(64,2) = 'positron'
      kmpr_l(64,2) = 8
      kmpr_c(64,3) = 'u'
      kmpr_l(64,3) = 1
      kmpr_c(64,4) = 'u-bar'
      kmpr_l(64,4) = 5
      kmpr_c(64,5) = 'u'
      kmpr_l(64,5) = 1
      kmpr_c(64,6) = 'u-bar'
      kmpr_l(64,6) = 5
* masses of external particles
      amas_1(64,1) = 11
      amas_1(64,2) = 11
      amas_1(64,3) = 2
      amas_1(64,4) = 2
      amas_1(64,5) = 2
      amas_1(64,6) = 2

* Charge*3
      kcha_g(64,1) =  -3
      kcha_g(64,2) =   3
      kcha_g(64,3) =   2
      kcha_g(64,4) =  -2
      kcha_g(64,5) =   2
      kcha_g(64,6) =  -2

* KFcode
      kfco_e(64,1) =  11
      kfco_e(64,2) = -11
      kfco_e(64,3) =   2
      kfco_e(64,4) =  -2
      kfco_e(64,5) =   2
      kfco_e(64,6) =  -2
* weight for the color base (qqqq)
      cf_mtx(64,0,0)= 9.d0
      cf_mtx(64,0,1)= 3.d0
      cf_mtx(64,1,0)= 3.d0
      cf_mtx(64,1,1)= 9.d0

      kmcb_s(64)    = 2
      kmcb_x(64)    = 4
      kmcs_r(64,1,0) = 3
      kmcs_r(64,2,0) = 4
      kmcs_r(64,3,0) = 5
      kmcs_r(64,4,0) = 6
      kmcs_r(64,1,1) = 3
      kmcs_r(64,2,1) = 6
      kmcs_r(64,3,1) = 4
      kmcs_r(64,4,1) = 5

* particle name
      kmpr_c(65,1) = 'electron'
      kmpr_l(65,1) = 8
      kmpr_c(65,2) = 'positron'
      kmpr_l(65,2) = 8
      kmpr_c(65,3) = 'c'
      kmpr_l(65,3) = 1
      kmpr_c(65,4) = 'c-bar'
      kmpr_l(65,4) = 5
      kmpr_c(65,5) = 'c'
      kmpr_l(65,5) = 1
      kmpr_c(65,6) = 'c-bar'
      kmpr_l(65,6) = 5
* masses of external particles
      amas_1(65,1) = 11
      amas_1(65,2) = 11
      amas_1(65,3) = 4
      amas_1(65,4) = 4
      amas_1(65,5) = 4
      amas_1(65,6) = 4

* Charge*3
      kcha_g(65,1) =  -3
      kcha_g(65,2) =   3
      kcha_g(65,3) =   2
      kcha_g(65,4) =  -2
      kcha_g(65,5) =   2
      kcha_g(65,6) =  -2

* KFcode
      kfco_e(65,1) =  11
      kfco_e(65,2) = -11
      kfco_e(65,3) =   4
      kfco_e(65,4) =  -4
      kfco_e(65,5) =   4
      kfco_e(65,6) =  -4
* weight for the color base (qqqq)
      cf_mtx(65,0,0)= 9.d0
      cf_mtx(65,0,1)= 3.d0
      cf_mtx(65,1,0)= 3.d0
      cf_mtx(65,1,1)= 9.d0

      kmcb_s(65)    = 2
      kmcb_x(65)    = 4
      kmcs_r(65,1,0) = 3
      kmcs_r(65,2,0) = 4
      kmcs_r(65,3,0) = 5
      kmcs_r(65,4,0) = 6
      kmcs_r(65,1,1) = 3
      kmcs_r(65,2,1) = 6
      kmcs_r(65,3,1) = 4
      kmcs_r(65,4,1) = 5

* particle name
      kmpr_c(66,1) = 'electron'
      kmpr_l(66,1) = 8
      kmpr_c(66,2) = 'positron'
      kmpr_l(66,2) = 8
      kmpr_c(66,3) = 'd'
      kmpr_l(66,3) = 1
      kmpr_c(66,4) = 'd-bar'
      kmpr_l(66,4) = 5
      kmpr_c(66,5) = 'd'
      kmpr_l(66,5) = 1
      kmpr_c(66,6) = 'd-bar'
      kmpr_l(66,6) = 5
* masses of external particles
      amas_1(66,1) = 11
      amas_1(66,2) = 11
      amas_1(66,3) = 1
      amas_1(66,4) = 1
      amas_1(66,5) = 1
      amas_1(66,6) = 1

* Charge*3
      kcha_g(66,1) =  -3
      kcha_g(66,2) =   3
      kcha_g(66,3) =  -1
      kcha_g(66,4) =   1
      kcha_g(66,5) =  -1
      kcha_g(66,6) =   1

* KFcode
      kfco_e(66,1) =  11
      kfco_e(66,2) = -11
      kfco_e(66,3) =   1
      kfco_e(66,4) =  -1
      kfco_e(66,5) =   1
      kfco_e(66,6) =  -1
* weight for the color base (qqqq)
      cf_mtx(66,0,0)= 9.d0
      cf_mtx(66,0,1)= 3.d0
      cf_mtx(66,1,0)= 3.d0
      cf_mtx(66,1,1)= 9.d0

      kmcb_s(66)    = 2
      kmcb_x(66)    = 4
      kmcs_r(66,1,0) = 3
      kmcs_r(66,2,0) = 4
      kmcs_r(66,3,0) = 5
      kmcs_r(66,4,0) = 6
      kmcs_r(66,1,1) = 3
      kmcs_r(66,2,1) = 6
      kmcs_r(66,3,1) = 4
      kmcs_r(66,4,1) = 5

* particle name
      kmpr_c(67,1) = 'electron'
      kmpr_l(67,1) = 8
      kmpr_c(67,2) = 'positron'
      kmpr_l(67,2) = 8
      kmpr_c(67,3) = 's'
      kmpr_l(67,3) = 1
      kmpr_c(67,4) = 's-bar'
      kmpr_l(67,4) = 5
      kmpr_c(67,5) = 's'
      kmpr_l(67,5) = 1
      kmpr_c(67,6) = 's-bar'
      kmpr_l(67,6) = 5
* masses of external particles
      amas_1(67,1) = 11
      amas_1(67,2) = 11
      amas_1(67,3) = 3
      amas_1(67,4) = 3
      amas_1(67,5) = 3
      amas_1(67,6) = 3

* Charge*3
      kcha_g(67,1) =  -3
      kcha_g(67,2) =   3
      kcha_g(67,3) =  -1
      kcha_g(67,4) =   1
      kcha_g(67,5) =  -1
      kcha_g(67,6) =   1

* KFcode
      kfco_e(67,1) =  11
      kfco_e(67,2) = -11
      kfco_e(67,3) =   3
      kfco_e(67,4) =  -3
      kfco_e(67,5) =   3
      kfco_e(67,6) =  -3
* weight for the color base (qqqq)
      cf_mtx(67,0,0)= 9.d0
      cf_mtx(67,0,1)= 3.d0
      cf_mtx(67,1,0)= 3.d0
      cf_mtx(67,1,1)= 9.d0

      kmcb_s(67)    = 2
      kmcb_x(67)    = 4
      kmcs_r(67,1,0) = 3
      kmcs_r(67,2,0) = 4
      kmcs_r(67,3,0) = 5
      kmcs_r(67,4,0) = 6
      kmcs_r(67,1,1) = 3
      kmcs_r(67,2,1) = 6
      kmcs_r(67,3,1) = 4
      kmcs_r(67,4,1) = 5

* particle name
      kmpr_c(68,1) = 'electron'
      kmpr_l(68,1) = 8
      kmpr_c(68,2) = 'positron'
      kmpr_l(68,2) = 8
      kmpr_c(68,3) = 'b'
      kmpr_l(68,3) = 1
      kmpr_c(68,4) = 'b-bar'
      kmpr_l(68,4) = 5
      kmpr_c(68,5) = 'b'
      kmpr_l(68,5) = 1
      kmpr_c(68,6) = 'b-bar'
      kmpr_l(68,6) = 5
* masses of external particles
      amas_1(68,1) = 11
      amas_1(68,2) = 11
      amas_1(68,3) = 5
      amas_1(68,4) = 5
      amas_1(68,5) = 5
      amas_1(68,6) = 5

* Charge*3
      kcha_g(68,1) =  -3
      kcha_g(68,2) =   3
      kcha_g(68,3) =  -1
      kcha_g(68,4) =   1
      kcha_g(68,5) =  -1
      kcha_g(68,6) =   1

* KFcode
      kfco_e(68,1) =  11
      kfco_e(68,2) = -11
      kfco_e(68,3) =   5
      kfco_e(68,4) =  -5
      kfco_e(68,5) =   5
      kfco_e(68,6) =  -5
* weight for the color base (qqqq)
      cf_mtx(68,0,0)= 9.d0
      cf_mtx(68,0,1)= 3.d0
      cf_mtx(68,1,0)= 3.d0
      cf_mtx(68,1,1)= 9.d0

      kmcb_s(68)    = 2
      kmcb_x(68)    = 4
      kmcs_r(68,1,0) = 3
      kmcs_r(68,2,0) = 4
      kmcs_r(68,3,0) = 5
      kmcs_r(68,4,0) = 6
      kmcs_r(68,1,1) = 3
      kmcs_r(68,2,1) = 6
      kmcs_r(68,3,1) = 4
      kmcs_r(68,4,1) = 5

* particle name
      kmpr_c(69,1) = 'electron'
      kmpr_l(69,1) = 8
      kmpr_c(69,2) = 'positron'
      kmpr_l(69,2) = 8
      kmpr_c(69,3) = 'u'
      kmpr_l(69,3) = 1
      kmpr_c(69,4) = 'u-bar'
      kmpr_l(69,4) = 5
      kmpr_c(69,5) = 'c'
      kmpr_l(69,5) = 1
      kmpr_c(69,6) = 'c-bar'
      kmpr_l(69,6) = 5
* masses of external particles
      amas_1(69,1) = 11
      amas_1(69,2) = 11
      amas_1(69,3) = 2
      amas_1(69,4) = 2
      amas_1(69,5) = 4
      amas_1(69,6) = 4

* Charge*3
      kcha_g(69,1) =  -3
      kcha_g(69,2) =   3
      kcha_g(69,3) =   2
      kcha_g(69,4) =  -2
      kcha_g(69,5) =   2
      kcha_g(69,6) =  -2

* KFcode
      kfco_e(69,1) =  11
      kfco_e(69,2) = -11
      kfco_e(69,3) =   2
      kfco_e(69,4) =  -2
      kfco_e(69,5) =   4
      kfco_e(69,6) =  -4
* weight for the color base (qqqq)
      cf_mtx(69,0,0)= 9.d0
      cf_mtx(69,0,1)= 3.d0
      cf_mtx(69,1,0)= 3.d0
      cf_mtx(69,1,1)= 9.d0

      kmcb_s(69)    = 2
      kmcb_x(69)    = 4
      kmcs_r(69,1,0) = 3
      kmcs_r(69,2,0) = 4
      kmcs_r(69,3,0) = 5
      kmcs_r(69,4,0) = 6
      kmcs_r(69,1,1) = 3
      kmcs_r(69,2,1) = 6
      kmcs_r(69,3,1) = 4
      kmcs_r(69,4,1) = 5

* particle name
      kmpr_c(70,1) = 'electron'
      kmpr_l(70,1) = 8
      kmpr_c(70,2) = 'positron'
      kmpr_l(70,2) = 8
      kmpr_c(70,3) = 'u'
      kmpr_l(70,3) = 1
      kmpr_c(70,4) = 'u-bar'
      kmpr_l(70,4) = 5
      kmpr_c(70,5) = 's'
      kmpr_l(70,5) = 1
      kmpr_c(70,6) = 's-bar'
      kmpr_l(70,6) = 5
* masses of external particles
      amas_1(70,1) = 11
      amas_1(70,2) = 11
      amas_1(70,3) = 2
      amas_1(70,4) = 2
      amas_1(70,5) = 3
      amas_1(70,6) = 3

* Charge*3
      kcha_g(70,1) =  -3
      kcha_g(70,2) =   3
      kcha_g(70,3) =   2
      kcha_g(70,4) =  -2
      kcha_g(70,5) =  -1
      kcha_g(70,6) =   1

* KFcode
      kfco_e(70,1) =  11
      kfco_e(70,2) = -11
      kfco_e(70,3) =   2
      kfco_e(70,4) =  -2
      kfco_e(70,5) =   3
      kfco_e(70,6) =  -3
* weight for the color base (qqqq)
      cf_mtx(70,0,0)= 9.d0
      cf_mtx(70,0,1)= 3.d0
      cf_mtx(70,1,0)= 3.d0
      cf_mtx(70,1,1)= 9.d0

      kmcb_s(70)    = 2
      kmcb_x(70)    = 4
      kmcs_r(70,1,0) = 3
      kmcs_r(70,2,0) = 4
      kmcs_r(70,3,0) = 5
      kmcs_r(70,4,0) = 6
      kmcs_r(70,1,1) = 3
      kmcs_r(70,2,1) = 6
      kmcs_r(70,3,1) = 4
      kmcs_r(70,4,1) = 5

* particle name
      kmpr_c(71,1) = 'electron'
      kmpr_l(71,1) = 8
      kmpr_c(71,2) = 'positron'
      kmpr_l(71,2) = 8
      kmpr_c(71,3) = 'u'
      kmpr_l(71,3) = 1
      kmpr_c(71,4) = 'u-bar'
      kmpr_l(71,4) = 5
      kmpr_c(71,5) = 'b'
      kmpr_l(71,5) = 1
      kmpr_c(71,6) = 'b-bar'
      kmpr_l(71,6) = 5
* masses of external particles
      amas_1(71,1) = 11
      amas_1(71,2) = 11
      amas_1(71,3) = 2
      amas_1(71,4) = 2
      amas_1(71,5) = 5
      amas_1(71,6) = 5

* Charge*3
      kcha_g(71,1) =  -3
      kcha_g(71,2) =   3
      kcha_g(71,3) =   2
      kcha_g(71,4) =  -2
      kcha_g(71,5) =  -1
      kcha_g(71,6) =   1

* KFcode
      kfco_e(71,1) =  11
      kfco_e(71,2) = -11
      kfco_e(71,3) =   2
      kfco_e(71,4) =  -2
      kfco_e(71,5) =   5
      kfco_e(71,6) =  -5
* weight for the color base (qqqq)
      cf_mtx(71,0,0)= 9.d0
      cf_mtx(71,0,1)= 3.d0
      cf_mtx(71,1,0)= 3.d0
      cf_mtx(71,1,1)= 9.d0

      kmcb_s(71)    = 2
      kmcb_x(71)    = 4
      kmcs_r(71,1,0) = 3
      kmcs_r(71,2,0) = 4
      kmcs_r(71,3,0) = 5
      kmcs_r(71,4,0) = 6
      kmcs_r(71,1,1) = 3
      kmcs_r(71,2,1) = 6
      kmcs_r(71,3,1) = 4
      kmcs_r(71,4,1) = 5

* particle name
      kmpr_c(72,1) = 'electron'
      kmpr_l(72,1) = 8
      kmpr_c(72,2) = 'positron'
      kmpr_l(72,2) = 8
      kmpr_c(72,3) = 'c'
      kmpr_l(72,3) = 1
      kmpr_c(72,4) = 'c-bar'
      kmpr_l(72,4) = 5
      kmpr_c(72,5) = 'd'
      kmpr_l(72,5) = 1
      kmpr_c(72,6) = 'd-bar'
      kmpr_l(72,6) = 5
* masses of external particles
      amas_1(72,1) = 11
      amas_1(72,2) = 11
      amas_1(72,3) = 4
      amas_1(72,4) = 4
      amas_1(72,5) = 1
      amas_1(72,6) = 1

* Charge*3
      kcha_g(72,1) =  -3
      kcha_g(72,2) =   3
      kcha_g(72,3) =   2
      kcha_g(72,4) =  -2
      kcha_g(72,5) =  -1
      kcha_g(72,6) =   1

* KFcode
      kfco_e(72,1) =  11
      kfco_e(72,2) = -11
      kfco_e(72,3) =   4
      kfco_e(72,4) =  -4
      kfco_e(72,5) =   1
      kfco_e(72,6) =  -1
* weight for the color base (qqqq)
      cf_mtx(72,0,0)= 9.d0
      cf_mtx(72,0,1)= 3.d0
      cf_mtx(72,1,0)= 3.d0
      cf_mtx(72,1,1)= 9.d0

      kmcb_s(72)    = 2
      kmcb_x(72)    = 4
      kmcs_r(72,1,0) = 3
      kmcs_r(72,2,0) = 4
      kmcs_r(72,3,0) = 5
      kmcs_r(72,4,0) = 6
      kmcs_r(72,1,1) = 3
      kmcs_r(72,2,1) = 6
      kmcs_r(72,3,1) = 4
      kmcs_r(72,4,1) = 5

* particle name
      kmpr_c(73,1) = 'electron'
      kmpr_l(73,1) = 8
      kmpr_c(73,2) = 'positron'
      kmpr_l(73,2) = 8
      kmpr_c(73,3) = 'c'
      kmpr_l(73,3) = 1
      kmpr_c(73,4) = 'c-bar'
      kmpr_l(73,4) = 5
      kmpr_c(73,5) = 'b'
      kmpr_l(73,5) = 1
      kmpr_c(73,6) = 'b-bar'
      kmpr_l(73,6) = 5
* masses of external particles
      amas_1(73,1) = 11
      amas_1(73,2) = 11
      amas_1(73,3) = 4
      amas_1(73,4) = 4
      amas_1(73,5) = 5
      amas_1(73,6) = 5

* Charge*3
      kcha_g(73,1) =  -3
      kcha_g(73,2) =   3
      kcha_g(73,3) =   2
      kcha_g(73,4) =  -2
      kcha_g(73,5) =  -1
      kcha_g(73,6) =   1

* KFcode
      kfco_e(73,1) =  11
      kfco_e(73,2) = -11
      kfco_e(73,3) =   4
      kfco_e(73,4) =  -4
      kfco_e(73,5) =   5
      kfco_e(73,6) =  -5
* weight for the color base (qqqq)
      cf_mtx(73,0,0)= 9.d0
      cf_mtx(73,0,1)= 3.d0
      cf_mtx(73,1,0)= 3.d0
      cf_mtx(73,1,1)= 9.d0

      kmcb_s(73)    = 2
      kmcb_x(73)    = 4
      kmcs_r(73,1,0) = 3
      kmcs_r(73,2,0) = 4
      kmcs_r(73,3,0) = 5
      kmcs_r(73,4,0) = 6
      kmcs_r(73,1,1) = 3
      kmcs_r(73,2,1) = 6
      kmcs_r(73,3,1) = 4
      kmcs_r(73,4,1) = 5

* particle name
      kmpr_c(74,1) = 'electron'
      kmpr_l(74,1) = 8
      kmpr_c(74,2) = 'positron'
      kmpr_l(74,2) = 8
      kmpr_c(74,3) = 'd'
      kmpr_l(74,3) = 1
      kmpr_c(74,4) = 'd-bar'
      kmpr_l(74,4) = 5
      kmpr_c(74,5) = 's'
      kmpr_l(74,5) = 1
      kmpr_c(74,6) = 's-bar'
      kmpr_l(74,6) = 5
* masses of external particles
      amas_1(74,1) = 11
      amas_1(74,2) = 11
      amas_1(74,3) = 1
      amas_1(74,4) = 1
      amas_1(74,5) = 3
      amas_1(74,6) = 3

* Charge*3
      kcha_g(74,1) =  -3
      kcha_g(74,2) =   3
      kcha_g(74,3) =  -1
      kcha_g(74,4) =   1
      kcha_g(74,5) =  -1
      kcha_g(74,6) =   1

* KFcode
      kfco_e(74,1) =  11
      kfco_e(74,2) = -11
      kfco_e(74,3) =   1
      kfco_e(74,4) =  -1
      kfco_e(74,5) =   3
      kfco_e(74,6) =  -3
* weight for the color base (qqqq)
      cf_mtx(74,0,0)= 9.d0
      cf_mtx(74,0,1)= 3.d0
      cf_mtx(74,1,0)= 3.d0
      cf_mtx(74,1,1)= 9.d0

      kmcb_s(74)    = 2
      kmcb_x(74)    = 4
      kmcs_r(74,1,0) = 3
      kmcs_r(74,2,0) = 4
      kmcs_r(74,3,0) = 5
      kmcs_r(74,4,0) = 6
      kmcs_r(74,1,1) = 3
      kmcs_r(74,2,1) = 6
      kmcs_r(74,3,1) = 4
      kmcs_r(74,4,1) = 5

* particle name
      kmpr_c(75,1) = 'electron'
      kmpr_l(75,1) = 8
      kmpr_c(75,2) = 'positron'
      kmpr_l(75,2) = 8
      kmpr_c(75,3) = 'd'
      kmpr_l(75,3) = 1
      kmpr_c(75,4) = 'd-bar'
      kmpr_l(75,4) = 5
      kmpr_c(75,5) = 'b'
      kmpr_l(75,5) = 1
      kmpr_c(75,6) = 'b-bar'
      kmpr_l(75,6) = 5
* masses of external particles
      amas_1(75,1) = 11
      amas_1(75,2) = 11
      amas_1(75,3) = 1
      amas_1(75,4) = 1
      amas_1(75,5) = 5
      amas_1(75,6) = 5

* Charge*3
      kcha_g(75,1) =  -3
      kcha_g(75,2) =   3
      kcha_g(75,3) =  -1
      kcha_g(75,4) =   1
      kcha_g(75,5) =  -1
      kcha_g(75,6) =   1

* KFcode
      kfco_e(75,1) =  11
      kfco_e(75,2) = -11
      kfco_e(75,3) =   1
      kfco_e(75,4) =  -1
      kfco_e(75,5) =   5
      kfco_e(75,6) =  -5
* weight for the color base (qqqq)
      cf_mtx(75,0,0)= 9.d0
      cf_mtx(75,0,1)= 3.d0
      cf_mtx(75,1,0)= 3.d0
      cf_mtx(75,1,1)= 9.d0

      kmcb_s(75)    = 2
      kmcb_x(75)    = 4
      kmcs_r(75,1,0) = 3
      kmcs_r(75,2,0) = 4
      kmcs_r(75,3,0) = 5
      kmcs_r(75,4,0) = 6
      kmcs_r(75,1,1) = 3
      kmcs_r(75,2,1) = 6
      kmcs_r(75,3,1) = 4
      kmcs_r(75,4,1) = 5

* particle name
      kmpr_c(76,1) = 'electron'
      kmpr_l(76,1) = 8
      kmpr_c(76,2) = 'positron'
      kmpr_l(76,2) = 8
      kmpr_c(76,3) = 's'
      kmpr_l(76,3) = 1
      kmpr_c(76,4) = 's-bar'
      kmpr_l(76,4) = 5
      kmpr_c(76,5) = 'b'
      kmpr_l(76,5) = 1
      kmpr_c(76,6) = 'b-bar'
      kmpr_l(76,6) = 5
* masses of external particles
      amas_1(76,1) = 11
      amas_1(76,2) = 11
      amas_1(76,3) = 3
      amas_1(76,4) = 3
      amas_1(76,5) = 5
      amas_1(76,6) = 5

* Charge*3
      kcha_g(76,1) =  -3
      kcha_g(76,2) =   3
      kcha_g(76,3) =  -1
      kcha_g(76,4) =   1
      kcha_g(76,5) =  -1
      kcha_g(76,6) =   1

* KFcode
      kfco_e(76,1) =  11
      kfco_e(76,2) = -11
      kfco_e(76,3) =   3
      kfco_e(76,4) =  -3
      kfco_e(76,5) =   5
      kfco_e(76,6) =  -5
* weight for the color base (qqqq)
      cf_mtx(76,0,0)= 9.d0
      cf_mtx(76,0,1)= 3.d0
      cf_mtx(76,1,0)= 3.d0
      cf_mtx(76,1,1)= 9.d0

      kmcb_s(76)    = 2
      kmcb_x(76)    = 4
      kmcs_r(76,1,0) = 3
      kmcs_r(76,2,0) = 4
      kmcs_r(76,3,0) = 5
      kmcs_r(76,4,0) = 6
      kmcs_r(76,1,1) = 3
      kmcs_r(76,2,1) = 6
      kmcs_r(76,3,1) = 4
      kmcs_r(76,4,1) = 5
 
* particle name
      kmpr_c(1,1) = 'electron'
      kmpr_l(1,1) = 8
      kmpr_c(1,2) = 'positron'
      kmpr_l(1,2) = 8
      kmpr_c(1,3) = 'electron'
      kmpr_l(1,3) = 8
      kmpr_c(1,4) = 'positron'
      kmpr_l(1,4) = 8
      kmpr_c(1,5) = 'nu-e'
      kmpr_l(1,5) = 4
      kmpr_c(1,6) = 'nu-e-bar'
      kmpr_l(1,6) = 8
* masses of external particles
      amas_1(1,1) = 11
      amas_1(1,2) = 11
      amas_1(1,3) = 11
      amas_1(1,4) = 11
      amas_1(1,5) = 12
      amas_1(1,6) = 12

* Charge*3
      kcha_g(1,1) =  -3
      kcha_g(1,2) =   3
      kcha_g(1,3) =  -3
      kcha_g(1,4) =   3
      kcha_g(1,5) =   0
      kcha_g(1,6) =   0

* KFcode
      kfco_e(1,1) =  11
      kfco_e(1,2) = -11
      kfco_e(1,3) =  11
      kfco_e(1,4) = -11
      kfco_e(1,5) =  12
      kfco_e(1,6) = -12
* weight for the color base (llll)
      cf_mtx(1,0,0) = 1.d0

      kmcb_s(1)    = 1
      kmcb_x(1)    = 0

*========
      do 999   ip = 1 , MPROC
      do 999 iset = 1 , 20
      do 999   ig = 1 , NGRAPH
         kdiagr(ip,iset,ig) = 0
  999 continue

C      kdiagr( p, 1, g) .... WW
C      kdiagr( p, 2, g) .... ZZ
C  1  [56] electron,positron,nu-e,nu-e-bar
          kdiagr( 1, 1,13) = 1
          kdiagr( 1, 1,14) = 1
          kdiagr( 1, 1,49) = 1
          kdiagr( 1, 2,48) = 1
          kdiagr( 1, 2,51) = 1
C  2  [18] electron,nu-e-bar,anti-muon,nu-mu
C  3  [18] electron,nu-e-bar,anti-tau,nu-tau (same as #2)
      do 1002 ip = 2 , 3
         kdiagr(ip, 1, 7) = 1
         kdiagr(ip, 1, 8) = 1
         kdiagr(ip, 1,18) = 1
 1002 continue
C  4  [20] nu-mu,anti-muon,muon,nu-mu-bar
C  5  [20] nu-tau,anti-tau,tau,nu-tau-bar (same as #4)
      do 1004 ip = 4 , 5
         kdiagr(ip, 1,13) = 1
         kdiagr(ip, 1,14) = 1
         kdiagr(ip, 1,20) = 1
         kdiagr(ip, 2,17) = 1
         kdiagr(ip, 2,19) = 1
 1004 continue
C  6  [ 9] muon,nu-mu-bar,anti-tau,nu-tau
         kdiagr( 6, 1, 7) = 1
         kdiagr( 6, 1, 8) = 1
         kdiagr( 6, 1, 9) = 1
C  7 [144] electron,positron,electron,positron
         kdiagr( 7, 2,116) = 1
         kdiagr( 7, 2,120) = 1
         kdiagr( 7, 2,124) = 1
         kdiagr( 7, 2,128) = 1

         kdiagr( 7, 6,113) = 1
         kdiagr( 7, 6,117) = 1
         kdiagr( 7, 6,121) = 1
         kdiagr( 7, 6,125) = 1

         kdiagr( 7, 9, 33) = 1
         kdiagr( 7, 9, 37) = 1
         kdiagr( 7, 9, 41) = 1
         kdiagr( 7, 9, 45) = 1
         kdiagr( 7, 9, 49) = 1
         kdiagr( 7, 9, 53) = 1
         kdiagr( 7, 9, 57) = 1
         kdiagr( 7, 9, 61) = 1
         kdiagr( 7, 9, 65) = 1
         kdiagr( 7, 9, 69) = 1
         kdiagr( 7, 9, 73) = 1
         kdiagr( 7, 9, 77) = 1
         kdiagr( 7, 9, 81) = 1
         kdiagr( 7, 9, 85) = 1
         kdiagr( 7, 9, 89) = 1
         kdiagr( 7, 9, 93) = 1
         kdiagr( 7, 9, 97) = 1
         kdiagr( 7, 9,101) = 1
         kdiagr( 7, 9,105) = 1
         kdiagr( 7, 9,109) = 1
         kdiagr( 7, 9,129) = 1
         kdiagr( 7, 9,133) = 1
         kdiagr( 7, 9,137) = 1
         kdiagr( 7, 9,141) = 1

         kdiagr( 7,10, 45) = 1
         kdiagr( 7,10, 49) = 1
         kdiagr( 7,10, 53) = 1
         kdiagr( 7,10, 61) = 1
         kdiagr( 7,10, 73) = 1
         kdiagr( 7,10, 77) = 1
         kdiagr( 7,10, 85) = 1
         kdiagr( 7,10, 93) = 1

C  8  [50] electron,positron,muon,anti-muon
C  9  [50] electron,positron,tau,anti-tau (sam as #8)
      do 1008 ip = 8 , 9
         kdiagr(ip, 2,42) = 1
         kdiagr(ip, 2,46) = 1
         kdiagr(ip, 6,39) = 1
         kdiagr(ip, 6,43) = 1

         kdiagr(ip, 9,18) = 1
         kdiagr(ip, 9,22) = 1
         kdiagr(ip, 9,26) = 1
         kdiagr(ip, 9,30) = 1
         kdiagr(ip, 9,35) = 1
         kdiagr(ip, 9,47) = 1

         kdiagr(ip,10,26) = 1
         kdiagr(ip,10,30) = 1
 1008 continue

C 10  [68] muon,anti-muon,muon,anti-muon
C 11  [68] tau,anti-tau,tau,anti-tau
      do 1010 ip = 10 , 11
         kdiagr(ip, 2,56) = 1
         kdiagr(ip, 2,60) = 1
         kdiagr(ip, 2,64) = 1
         kdiagr(ip, 2,68) = 1
         kdiagr(ip, 6,53) = 1
         kdiagr(ip, 6,57) = 1
         kdiagr(ip, 6,61) = 1
         kdiagr(ip, 6,65) = 1
 1010 continue
C 12  [34] muon,anti-muon,tau,anti-tau
         kdiagr(12, 2,30) = 1
         kdiagr(12, 2,34) = 1
         kdiagr(12, 6,27) = 1
         kdiagr(12, 6,31) = 1
C 13  [20] electron,positron,nu-mu,nu-mu-bar
C 14  [20] electron,positron,nu-tau,nu-tau-bar
      do 1013 ip = 13 , 14
         kdiagr(ip, 2,16) = 1
         kdiagr(ip, 2,18) = 1
 1013 continue
C 15  [21] nu-e,nu-e-bar,muon,anti-muon
C 16  [21] nu-e,nu-e-bar,tau,anti-tau
      do 1015 ip = 15 , 16
         kdiagr(ip, 2,17) = 1
         kdiagr(ip, 2,19) = 1
 1015 continue
C 17  [11] nu-tau,nu-tau-bar,muon,anti-muon
C 18  [11] nu-mu,nu-mu-bar,tau,anti-tau
      do 1017 ip = 15 , 16
         kdiagr(ip, 2, 9) = 1
         kdiagr(ip, 2,11) = 1
 1017 continue
C 19  [36] nu-e,nu-e-bar,nu-e,nu-e-bar
         kdiagr(19, 2,29) = 1
         kdiagr(19, 2,30) = 1
         kdiagr(19, 2,31) = 1
         kdiagr(19, 2,32) = 1
C 20  [12] nu-e,nu-e-bar,nu-mu,nu-mu-bar
C 21  [12] nu-e,nu-e-bar,nu-tau,nu-tau-bar
C 22  [12] nu-mu,nu-mu-bar,nu-mu,nu-mu-bar
C 23  [12] nu-tau,nu-tau-bar,nu-tau,nu-tau-bar
      do 1020 ip = 20 , 23
         kdiagr(ip, 2,10) = 1
         kdiagr(ip, 2,11) = 1
 1020 continue
C 24   [6] nu-tau,nu-tau-bar,nu-mu,nu-mu-bar
         kdiagr(24, 2, 5) = 1
         kdiagr(24, 2, 6) = 1
C 25  [20] electron,nu-e-bar,u,d-bar
C 26  [20] electron,nu-e-bar,c,s-bar
      do 1025 ip = 25 , 26
         kdiagr(ip, 1, 8) = 1
         kdiagr(ip, 1, 9) = 1
         kdiagr(ip, 1,20) = 1
 1025 continue
C 27  [10] muon,nu-mu-bar,u,d-bar
C 28  [10] muon,nu-mu-bar,c,s-bar
C 29  [10] tau,nu-tau-bar,u,d-bar
C 30  [10] tau,nu-tau-bar,c,S-bar
      do 1027 ip = 27 , 30
         kdiagr(ip, 1, 8) = 1
         kdiagr(ip, 1, 9) = 1
         kdiagr(ip, 1,10) = 1
 1027 continue
C 31  [50] electron,positron,u,u-bar
C 32  [50] electron,positron,c,c-bar
C 33  [50] electron,positron,d,d-bar
C 34  [50] electron,positron,s,s-bar
C 35  [50] electron,positron,b,b-bar
      do 1031 ip = 31 , 35
         kdiagr(ip, 2,42) = 1
         kdiagr(ip, 2,46) = 1
         kdiagr(ip, 6,39) = 1
         kdiagr(ip, 6,43) = 1

         kdiagr(ip, 9,18) = 1
         kdiagr(ip, 9,22) = 1
         kdiagr(ip, 9,26) = 1
         kdiagr(ip, 9,30) = 1
         kdiagr(ip, 9,35) = 1
         kdiagr(ip, 9,47) = 1

         kdiagr(ip,10,26) = 1
         kdiagr(ip,10,30) = 1
 1031 continue
C 36  [34] muon,anti-muon,u,u-bar
C 37  [34] muon,anti-muon,c,c-bar
C 38  [34] tau,anti-tau,u,u-bar
C 39  [34] tau,anti-tau,c,c-bar
C 40  [34] muon,anti-muon,d,d-bar
C 41  [34] muon,anti-muon,s,s-bar
C 42  [34] muon,anti-muon,b,b-bar
C 43  [34] tau,anti-tau,d,d-bar
C 44  [34] tau,anti-tau,s,s-bar
C 45  [34] tau,anti-tau,b,b-bar
      do 1036 ip = 36 , 45
         kdiagr(ip, 2,30) = 1
         kdiagr(ip, 2,34) = 1
         kdiagr(ip, 6,27) = 1
         kdiagr(ip, 6,31) = 1
 1036 continue
C 46  [21] nu-e,nu-e-bar,u,u-bar
C 47  [21] nu-e,nu-e-bar,c,c-bar
C 48  [21] nu-e,nu-e-bar,d,d-bar
C 49  [21] nu-e,nu-e-bar,s,s-bar
C 50  [21] nu-e,nu-e-bar,b,b-bar
      do 1046 ip = 46 , 50
         kdiagr(ip, 2,17) = 1
         kdiagr(ip, 2,19) = 1
 1046 continue
C 51  [11] nu-mu,nu-mu-bar,u,u-bar
C 52  [11] nu-mu,nu-mu-bar,c,c-bar
C 53  [11] nu-tau,nu-tau-bar,u,u-bar
C 54  [11] nu-tau,nu-tau-bar,c,c-bar
C 55  [11] nu-mu,nu-mu-bar,d,d-bar
C 56  [11] nu-mu,nu-mu-bar,s,s-bar
C 57  [11] nu-mu,nu-mu-bar,b,b-bar
C 58  [11] nu-tau,nu-tau-bar,d,d-bar
C 59  [11] nu-tau,nu-tau-bar,s,s-bar
C 60  [11] nu-tau,nu-tau-bar,b,b-bar
      do 1051 ip = 51 , 60
         kdiagr(ip, 2, 9) = 1
         kdiagr(ip, 2,11) = 1
 1051 continue
C 61  [53] u,d-bar,d,u-bar
C 62  [53] c,s-bar,s,c-bar
      do 1061 ip = 61 , 62
         kdiagr(ip, 1,41) = 1
         kdiagr(ip, 1,42) = 1
         kdiagr(ip, 1,53) = 1
         kdiagr(ip, 2,48) = 1
         kdiagr(ip, 2,52) = 1
         kdiagr(ip, 6,45) = 1
         kdiagr(ip, 6,49) = 1
 1061 continue
C 63  [11] u,d-bar,s,c-bar
      do 1063 ip = 63 , 63
         kdiagr(ip, 1, 9) = 1
         kdiagr(ip, 1,10) = 1
         kdiagr(ip, 1,11) = 1
 1063 continue
C 64  [84] u,u-bar,u,u-bar
C 65  [84] c,c-bar,c,c-bar
C 66  [84] d,d-bar,d,d-bar
C 67  [84] s,s-bar,s,s-bar
C 68  [84] b,b-bar,b,b-bar
      do 1064 ip = 64 , 68
         kdiagr(ip, 2,72) = 1
         kdiagr(ip, 2,76) = 1
         kdiagr(ip, 2,80) = 1
         kdiagr(ip, 2,84) = 1
         kdiagr(ip, 6,69) = 1
         kdiagr(ip, 6,73) = 1
         kdiagr(ip, 6,77) = 1
         kdiagr(ip, 6,81) = 1
 1064 continue
C 69  [42] u,u-bar,c,c-bar
C 70  [42] u,u-bar,s,s-bar
C 71  [42] u,u-bar,b,b-bar
C 72  [42] c,c-bar,d,d-bar
C 73  [42] c,c-bar,b,b-bar
C 74  [42] d,d-bar,s,s-bar
C 75  [42] d,d-bar,b,b-bar
C 76  [42] s,s-bar,b,b-bar
      do 1069 ip = 69 , 76
         kdiagr(ip, 2,38) = 1
         kdiagr(ip, 2,42) = 1
         kdiagr(ip, 6,35) = 1
         kdiagr(ip, 6,39) = 1
 1069 continue

*    def 11
* 11 : 10 -> 0    others -> 1
      do 1100 ip = 7 , 9
*        print *,'ngd',ip,ngd(ip)
         do 1100 ig = 1 , ngd(ip)
             if( kdiagr(ip,10,ig) .eq. 1 ) then
                 kdiagr(ip,11,ig) = 0
             else 
                 kdiagr(ip,11,ig) = 1
             endif
 1100 continue

      do 1110 ip = 31, 35
*        print *,'ngd',ip,ngd(ip)
         do 1110 ig = 1 , ngd(ip)
             if( kdiagr(ip,10,ig) .eq. 1 ) then
                 kdiagr(ip,11,ig) = 0
             else 
                 kdiagr(ip,11,ig) = 1
             endif
 1110 continue

C      kdiagr( p, 7, g) .... S chanel
C      kdiagr( p, 8, g) .... T chanel
      do 1200 ip = 1 , 76
      do 1200 ig = 1 , ngd(ip)
         kdiagr(ip, 7, ig) = 1
         kdiagr(ip, 8, ig) = 0
 1200 continue
      do 1201 ig = 15, 46
         kdiagr( 1, 7, ig) = 0
         kdiagr( 1, 8, ig) = 1
 1201 continue
      do 1202 ig = 51, 56
         kdiagr( 1, 7, ig) = 0
         kdiagr( 1, 8, ig) = 1
 1202 continue
      do 1203 ip = 2 , 3
      do 1203 ig = 9, 17
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1203 continue
      do 1204 ig = 33, 112
         kdiagr( 7, 7, ig) = 0
         kdiagr( 7, 8, ig) = 1
 1204 continue
      do 1205 ig = 129, 144
         kdiagr( 7, 7, ig) = 0
         kdiagr( 7, 8, ig) = 1
 1205 continue
      do 1208 ip = 8 , 9
      do 1206 ig =18, 38
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1206 continue
      do 1207 ig =47, 50
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1207 continue
 1208 continue
      do 1212 ip =13 ,14
      do 1210 ig = 7, 14
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1210 continue
      do 1211 ig =19, 20
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1211 continue
 1212 continue
      do 1215 ip =15 ,16
      do 1213 ig = 8, 15
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1213 continue
      do 1214 ig =20, 21
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1214 continue
 1215 continue
      do 1216 ig = 9, 28
         kdiagr(19, 7, ig) = 0
         kdiagr(19, 8, ig) = 1
 1216 continue
      do 1217 ig = 33,36
         kdiagr(19, 7, ig) = 0
         kdiagr(19, 8, ig) = 1
 1217 continue
      do 1220 ip =20 ,21
      do 1218 ig = 5,  9
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1218 continue
      do 1219 ig =12, 12
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1219 continue
 1220 continue

      do 1222 ip =25 ,26
      do 1221 ig =10, 19
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1221 continue
 1222 continue
      do 1225 ip =31, 35
      do 1223 ig =18, 38
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1223 continue
      do 1224 ig =47, 50
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1224 continue
 1225 continue
      do 1228 ip =46, 50
      do 1226 ig = 8, 15
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1226 continue
      do 1227 ig =20, 21
         kdiagr(ip, 7, ig) = 0
         kdiagr(ip, 8, ig) = 1
 1227 continue
 1228 continue
*****************
*   count from 0
*****************
      do 8900 i = 1, MPROC
         ngd(i-1) =  ngd(i)
         do 8100 j = 1 , 6
            kmpr_c(i-1,j) = kmpr_c(i,j)
            kmpr_l(i-1,j) = kmpr_l(i,j)
            amas_1(i-1,j) = amas_1(i,j)
            kcha_g(i-1,j) = kcha_g(i,j)
            kfco_e(i-1,j) = kfco_e(i,j)
 8100    continue
         do 8200 j = 0 , 1
         do 8200 k = 0 , 1
             cf_mtx(i-1,j,k) = cf_mtx(i,j,k)
 8200    continue
         kmcb_s(i-1) =  kmcb_s(i)
         kmcb_x(i-1) =  kmcb_x(i)
         do 8300 j = 1 , 4
         do 8300 k = 0 , 1
            kmcs_r(i-1,j,k) =  kmcs_r(i,j,k)
 8300    continue
         do 8400 j = 1 , 20
         do 8400 k = 1 , NGRAPH
            kdiagr(i-1,j,k) = kdiagr(i,j,k)
 8400    continue
 8900 continue

      return
      end
C------------------------------------------------------------
      subroutine procdb( ithprc )
C------------------------------------------------------------
      implicit real*8 (a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'

      include 'inclpd.f'
      do 110 i = 1, 6
      kmprtc(i) = kmpr_c(ithprc,i)
      kmprtl(i) = kmpr_l(ithprc,i)
      kcharg(i) = kcha_g(ithprc,i)
      kfcode(i) = kfco_e(ithprc,i)
*     print *,'amass1(i)',i,amass1(i)
 110  continue
*
      do 120 i = 1, 6
      amass1(i) = akmass(amas_1(ithprc,i))
      amass2(i) = amass1(i)**2
 120  continue
      kmcbas = kmcb_s(ithprc)
      kmcbmx = kmcb_x(ithprc)
*
      if( kmcbmx .eq. 2 ) then
          kmcstr(1,0) = kmcs_r(ithprc,1,0)
          kmcstr(2,0) = kmcs_r(ithprc,2,0)
      else if( kmcbmx .eq. 4 ) then
          do 200 i = 0, 1
          do 200 j = 1, 4
             kmcstr(j,i) = kmcs_r(ithprc,j,i)
 200      continue
      endif

      if( kmcbas .lt. 2 ) then
          cfmtx(0,0) = cf_mtx(ithprc,0,0)
      else
          do 300 i = 0, 1
          do 300 j = 0, 1
             cfmtx(j,i) = cf_mtx(ithprc,j,i)
 300      continue
      endif

      return
      end
* File setmas.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
*     depends on "parser program"
*-----------------------------------------------------------------------
************************************************************************
      subroutine setmas( ithprc , iprint )
      implicit real*8(a-h,o-z)

      include 'incl1.f'
      include 'inclk.f'
      include 'inclpi.f'
c----------------------------------------------
c     generated by grcpar (Don't touch)
c----------------------------------------------
        jhel1 = i4data(ikyadr(  0))
        jhel2 = i4data(ikyadr(  1))
        jhel3 = i4data(ikyadr(  2))
        jhel4 = i4data(ikyadr(  3))
        jhel5 = i4data(ikyadr(  4))
        jhel6 = i4data(ikyadr(  5))
        igset = i4data(ikyadr(  6))
          amw = r8data(ikyadr( 65))
          agw = r8data(ikyadr( 66))
          amz = r8data(ikyadr( 67))
          agz = r8data(ikyadr( 68))
          amh = r8data(ikyadr( 69))
         amel = r8data(ikyadr( 70))
         ammu = r8data(ikyadr( 71))
         amta = r8data(ikyadr( 72))
         amuq = r8data(ikyadr( 73))
         amcq = r8data(ikyadr( 74))
         amtq = r8data(ikyadr( 75))
         amdq = r8data(ikyadr( 76))
         amsq = r8data(ikyadr( 77))
         ambq = r8data(ikyadr( 78))
          agh = r8data(ikyadr( 79))
        alpha = r8data(ikyadr( 80))
       alphas = r8data(ikyadr( 81))
c----------------------------------------------
c     check by owner
c----------------------------------------------
c----------------------------------------------
c     set   jhel1
c----------------------------------------------
      if(  jhel1 .lt. 0 . or.
     .     jhel1 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel1')
      endif
c----------------------------------------------
c     set   jhel2
c----------------------------------------------
      if(  jhel2 .lt. 0 . or.
     .     jhel2 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel2')
      endif
c----------------------------------------------
c     set   jhel3
c----------------------------------------------
      if(  jhel3 .lt. 0 . or.
     .     jhel3 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel3')
      endif
c----------------------------------------------
c     set   jhel4
c----------------------------------------------
      if(  jhel4 .lt. 0 . or.
     .     jhel4 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel4')
      endif
c----------------------------------------------
c     set   jhel5
c----------------------------------------------
      if(  jhel5 .lt. 0 . or.
     .     jhel5 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel5')
      endif
c----------------------------------------------
c     set   jhel6
c----------------------------------------------
      if(  jhel6 .lt. 0 . or.
     .     jhel6 .gt. 1 ) then
              call grcerr(2,' invalid parm: jhel6')
      endif
c----------------------------------------------
c     set   igset
c----------------------------------------------
      if(    igset .lt. 0 . or.
     .       igset .gt. 20 ) then
              call grcerr(2,' invalid parm: set')
      endif
c----------------------------------------------
c     set   amw
c----------------------------------------------
c     if(    amw .lt. 0 . or.
c    .       amw .gt. 1 ) then
c             call grcerr(2,' invalid parm: amw')
c     endif
c----------------------------------------------
c     set   agw
c----------------------------------------------
c     if(    agw .lt. 0 . or.
c    .       agw .gt. 1 ) then
c             call grcerr(2,' invalid parm: agw')
c     endif
c----------------------------------------------
c     set   amz
c----------------------------------------------
c     if(    amz .lt. 0 . or.
c    .       amz .gt. 1 ) then
c             call grcerr(2,' invalid parm: amz')
c     endif
c----------------------------------------------
c     set   agz
c----------------------------------------------
c     if(    agz .lt. 0 . or.
c    .       agz .gt. 1 ) then
c             call grcerr(2,' invalid parm: agz')
c     endif
c----------------------------------------------
c     set   amh
c----------------------------------------------
c     if(    amh .lt. 0 . or.
c    .       amh .gt. 1 ) then
c             call grcerr(2,' invalid parm: amh')
c     endif
c----------------------------------------------
c     set   amel
c----------------------------------------------
c     if(   amel .lt. 0 . or.
c    .      amel .gt. 1 ) then
c             call grcerr(2,' invalid parm: amel')
c     endif
c----------------------------------------------
c     set   ammu
c----------------------------------------------
c     if(   ammu .lt. 0 . or.
c    .      ammu .gt. 1 ) then
c             call grcerr(2,' invalid parm: ammu')
c     endif
c----------------------------------------------
c     set   amta
c----------------------------------------------
c     if(   amta .lt. 0 . or.
c    .      amta .gt. 1 ) then
c             call grcerr(2,' invalid parm: amta')
c     endif
c----------------------------------------------
c     set   amuq
c----------------------------------------------
c     if(   amuq .lt. 0 . or.
c    .      amuq .gt. 1 ) then
c             call grcerr(2,' invalid parm: amuq')
c     endif
c----------------------------------------------
c     set   amcq
c----------------------------------------------
c     if(   amcq .lt. 0 . or.
c    .      amcq .gt. 1 ) then
c             call grcerr(2,' invalid parm: amcq')
c     endif
c----------------------------------------------
c     set   amtq
c----------------------------------------------
c     if(   amtq .lt. 0 . or.
c    .      amtq .gt. 1 ) then
c             call grcerr(2,' invalid parm: amtq')
c     endif
c----------------------------------------------
c     set   amdq
c----------------------------------------------
c     if(   amdq .lt. 0 . or.
c    .      amdq .gt. 1 ) then
c             call grcerr(2,' invalid parm: amdq')
c     endif
c----------------------------------------------
c     set   amsq
c----------------------------------------------
c     if(   amsq .lt. 0 . or.
c    .      amsq .gt. 1 ) then
c             call grcerr(2,' invalid parm: amsq')
c     endif
c----------------------------------------------
c     set   ambq
c----------------------------------------------
c     if(   ambq .lt. 0 . or.
c    .      ambq .gt. 1 ) then
c             call grcerr(2,' invalid parm: ambq')
c     endif
c----------------------------------------------
c     set   agh
c----------------------------------------------
c     if(    agh .lt. 0 . or.
c    .       agh .gt. 1 ) then
c             call grcerr(2,' invalid parm: agh')
c     endif
c----------------------------------------------
c     set   alpha
c----------------------------------------------
c     if(  alpha .lt. 0 . or.
c    .     alpha .gt. 1 ) then
c             call grcerr(2,' invalid parm: alpha')
c     endif
c----------------------------------------------
c     set   alphas
c----------------------------------------------
c     if( alphas .lt. 0 . or.
c    .    alphas .gt. 1 ) then
c             call grcerr(2,' invalid parm: alphas')
c     endif
*-----------------------------------------------------------------------
* constants
      pi    = acos(- 1.0d0 )
      pi2   = pi * pi
      rad   = pi / 180.0d0
      gevpb = 0.38937966d9
**    alpha = 1.0d0/128.07d0
      alpha0= 1.0d0/137.0359895d0
**    alphas= 0.12d0


*-----------------------------------------------------------------------
* graph selection
*-----------------------------------------------------------------------
      do 10 n1 = 1, ngraph
        jselg(n1) = 1
   10 continue

      call grcpgs(ithprc,igset,iprint,ngraph,jselg)

      jgraph = 0

*-----------------------------------------------------------------------
* mass
*
**       amw = 80.23D0
**       amz = 91.1888D0
         ama = 0.0D0
         amg = 0.0D0
**       amh = 10000.0D0
         amx = AMW
         amy = AMZ
        amne = 0.0D0
        amnm = 0.0D0
        amnt = 0.0D0
**      amel = 0.51099906D-3
**      ammu = 105.658389D-3
**      amta = 1.7771D0
**      amuq = 5.0D-3
**      amcq = 1.3
**      amtq = 170.0D0
**      amdq = 10.0D-3
**      amsq = 200.0D-3
**      ambq = 4.3D0
        amcp = AMW
        amcm = AMW
        amcz = AMZ
        amca = AMA
        amcg = AMG

* set quark mass = 1.d-5
*
      if( jqmass .eq. 0 )then
            amuq = 1.0d-5
            amcq = 1.0d-5
            amtq = 1.0d-5
            amdq = 1.0d-5
            amsq = 1.0d-5
            ambq = 1.0d-5
      endif
*
      if( jlmass .eq. 0 )then
            ammu = 1.0d-5
            amta = 1.0d-5
      endif

* width

**       agw = 2.03367033062746D0
**       agz = 2.4974D0
**       agh = 0.0D0
         agx = AGW
         agy = AGZ
        agcq = 0.0D0
        agtq = 0.0D0
        agsq = 0.0D0
        agbq = 0.0D0
        agcp = AGW
        agcm = AGW
        agcz = AGZ

* Gauge parametes (default is unitary gauge)
      igauab = 0
      igauwb = 0
      igauzb = 0
      igaugb = 0
      agauge(igauab) = 1.0d0
      agauge(igauwb) = 1.0d0
      agauge(igauzb) = 1.0d0
      agauge(igaugb) = 1.0d0
      agauge(igau00) = 1.0d0

*---------------------------------------
* Spin average
*---------------------------------------
      aspin = 1.0d0

*     1: initial electron mass=amel
      if( jhel1 .eq. -1 ) then
          jhs(1) = 0
          jhe(1) = 0
      else if( jhel1 .eq. 1 ) then
          jhs(1) = 1
          jhe(1) = 1
      else
          jhs(1) = 0
          jhe(1) = lextrn - 1
      endif
      aspin = aspin/dble(jhe(1) - jhs(1)+1)

*     2: initial positron mass=amel
      if( jhel2 .eq. -1 ) then
          jhs(2) = 0
          jhe(2) = 0
      else if( jhel2 .eq. 1 ) then
          jhs(2) = 1
          jhe(2) = 1
      else
          jhs(2) = 0
          jhe(2) = lextrn - 1
      endif
      aspin = aspin/dble(jhe(2) - jhs(2)+1)

*     3: final fermion
      if( jhel3 .eq. -1 ) then
          jhs(3) = 0
          jhe(3) = 0
      else if( jhel3 .eq. 1 ) then
          jhs(3) = 1
          jhe(3) = 1
      else
          jhs(3) = 0
          jhe(3) = lextrn - 1
      endif

*     4: final fermion
      if( jhel4 .eq. -1 ) then
          jhs(4) = 0
          jhe(4) = 0
      else if( jhel4 .eq. 1 ) then
          jhs(4) = 1
          jhe(4) = 1
      else
          jhs(4) = 0
          jhe(4) = lextrn - 1
      endif

*     5: final fermion
      if( jhel5 .eq. -1 ) then
          jhs(5) = 0
          jhe(5) = 0
      else if( jhel5 .eq. 1 ) then
          jhs(5) = 1
          jhe(5) = 1
      else
          jhs(5) = 0
          jhe(5) = lextrn - 1
      endif

*     6: final fermion
      if( jhel6 .eq. -1 ) then
          jhs(6) = 0
          jhe(6) = 0
      else if( jhel6 .eq. 1 ) then
          jhs(6) = 1
          jhe(6) = 1
      else
          jhs(6) = 0
          jhe(6) = lextrn - 1
      endif
      return
      end
*970626:YK:mod the shower
*970509:TI:mod the origin of photon FOR ISR
*970506:TI:mod Charge conjugate for ISR
*970419:TI:del /common/KMCNTL
* File sp2lnd.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
*      for llll,llqq,qqqq 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      subroutine sp2lnd
*  Inteface of SPRING to JETSET.
*  1996.03.13 YK: put initial e+e- information.
      implicit real*8 (a-h,o-z)
*     include 'incpar.f'
      include 'incl1.f'
      include 'inclk.f'
      dimension ijoin(2)
      integer jp(2)
      real*4 xp(2,5),xbeam,x
      real*4  p,v
      common/lujets/n,k(4000,5),p(4000,5),v(4000,5)
      integer lect
      common/helicity/lect(4000)

      common /sp4vec/ vec(4,nextn)
      real*4  rqmax
      common /kinem1/ s,w,fact
*-----------------------------------------------------------------------
*     For only QEDPS
*-----------------------------------------------------------------------
      common /qplist/plptn(10,1000),nlptn(10,1000),ntop
*-----------------------------------------------------------------------
      include 'inclgi.f'
      common / grcspc / jmxtry, jchrgc
      common / grc4fs / nthprc
*-----------------------------------------------------------------------
      if( jqedps .eq. 0 ) then
* Tree level only no initial state radiation
       kc = 0
       do 10 j = 1 , nextn
        kc  = kc + 1

        p(kc,1) = real(vec(1,j))
        p(kc,2) = real(vec(2,j))
        p(kc,3) = real(vec(3,j))
        p(kc,4) = real(vec(4,j))
        p(kc,5) = real(amass1(j))

        k(kc,1) = 1
        k(kc,2) = kfcode(j)
        k(kc,3) = 1
        k(kc,4) = 0
        k(kc,5) = 0
        if( j .le. 2 ) then
         k(kc,1) = 21
         k(kc,3)=0
        endif

        v(kc,1) = 0.0
        v(kc,2) = 0.0
        v(kc,3) = 0.0
        v(kc,4) = 0.0
        v(kc,5) = 0.0
   10  continue

       n = kc
*-----------------------------------------------------------------------
      else
*-ISRTYPE can be 1 or 2 or 3
       k0 = nextn
* ntop number of QEDPS photons can be 0
       do 11 j = 1 , ntop
        if(nlptn(3,j).ne.0) goto 11
* YK:1996.03.13
*       if(nlptn(1,j).ge.3) then
        if(nlptn(1,j).ge.1) then
         kc     = nlptn(1,j)
         p(kc,1) = real(plptn(4,j))
         p(kc,2) = real(plptn(5,j))
         p(kc,3) = real(plptn(6,j))
         p(kc,4) = real(plptn(7,j))
* YK:1996.03.13
*        p(kc,5) = real(amass1(j))
         p(kc,5) = real(amass1(kc))

         k(kc,1) = 1
         k(kc,2) = kfcode(kc)
         k(kc,3) = 1
         k(kc,4) = 0
         k(kc,5) = 0
c         lect(kc)=999
*           Assume number of initial partile is 2.(Toriaezu)
         if( kc .le. 2 ) then
          k(kc,1) = 21
          k(kc,3) = 0
         endif
         v(kc,1) = 0.0
         v(kc,2) = 0.0
         v(kc,3) = 0.0
         v(kc,4) = 0.0
         v(kc,5) = 0.0
        else
         k0      = k0 + 1
         p(k0,1) = real(plptn(4,j))
         p(k0,2) = real(plptn(5,j))
         p(k0,3) = real(plptn(6,j))
         p(k0,4) = real(plptn(7,j))
         p(k0,5) = 0.0
         k(k0,1) = 1
         k(k0,2) = 22
         k(k0,3) = 1
         k(k0,4) = 0
         k(k0,5) = 0
         v(k0,1) = 0.0
         v(k0,2) = 0.0
         v(k0,3) = 0.0
         v(k0,4) = 0.0
         v(k0,5) = 0.0
         lect(k0)= 999
        endif
   11  continue
       n = k0
      endif

c generate 1 or 2  photon for the isr=1 case
      nisr=0
      if( isr.eq.1) then
         xbeam=sngl(w/2.d0)
         do 1020 i=1,2
            jp(i)=0
            do 1010 ik=1,5
               xp(i,ik)=0.
 1010       continue
            x=xbeam-p(i,4)
*       print *,'xbeam eisr nisr i p(i,4) x ',
*    &             xbeam,eisr,nisr,i,p(i,4),x
            if(x.gt.sngl(eisr)) then
               nisr=nisr+1
               jp(nisr)=i
               xp(i,3)=sign(x,p(i,3))
               xp(i,4)=x
               p(i,1)=0.
               p(i,2)=0.  
               p(i,3)=sign(sqrt(xbeam**2-p(i,5)**2),p(i,3))
               p(i,4)=xbeam  
             endif
 1020     continue
c         do 1030 i=1,20
c            print *,lect(i)
c1030     continue
c         print *,n,nisr

          if(nisr.ne.0) then                          
             do 1050 i=n,3,-1
                l=i+nisr
                lect(l)=lect(i) 
                do 1040 j=1,5
                   k(l,j)=k(i,j)
                   p(l,j)=p(i,j)
                   v(l,j)=v(i,j)
 1040           continue
 1050        continue
             n=n+nisr
             do 1070 i=1,nisr
                do 1060 m=1,5
                   p(2+i,m)=xp(jp(i),m)
                   v(2+i,m)=0.
 1060           continue
                k(2+i,1)=1
                k(2+i,2)=22
                k(2+i,3)=jp(i)
                lect(2+i)=999
 1070        continue
          endif
          j=0
          do 1080 i=3,n
             if( lect(i).ne.999.and.lect(i).ne.-999)then
                 j=j+lect(i)
             endif
 1080     continue
          if(j.ne.-4.and.j.ne.-2.and.j.ne.0.and.j.ne.2.and.j.ne.4)then
             print*,'sp2lnd n,nisr: ',n,nisr
             do 1090 i=1,n
                print *,lect(i)
 1090        continue
          endif
      endif  
*-----------------------------------------------------------------------
c Charge conjugate
*     print *,'<<sp2lnd>>'
*     print *,' chgcjpr ',chgcjpr
      if (jchrgc.eq.1) then
*-------------------
* check
*-------------------
       if( iprc(nthprc-1,2) .gt.1 .and. drn(idum) .gt. 0.5d0 ) then
*-------------------
*         print *,' chrgconj ',nthprc,iprc(nthprc-1,2)
          do 5010 l=3,n
             if( k(l,2) .eq. 22 ) then
                 if( k(l,3) .eq. 1 ) then
                     k(l,3) = 2
                 else if( k(l,3) .eq. 2 ) then
                     k(l,3) = 1
                 endif
             endif
             if(lucomp(-k(l,2)).ne.0) k(l,2)=-k(l,2)
             p(l,1)=-p(l,1)
             p(l,2)=-p(l,2)
             p(l,3)=-p(l,3)
             if(lect(l).ne.999.and.lect(l).ne.-999)lect(l)=-lect(l)
 5010     continue
        endif 
      endif 
*-----------------------------------------------------------------------
*     String Join
*-----------------------------------------------------------------------
      do 20 i = 1, kmcbmx, 2
         if( kmcstr(i,icolst) .ne. 0 ) then
* YK:1996.03.13
* YK         ijoin(1) = kmcstr( i ,icolst) - 2
             ijoin(1) = kmcstr( i ,icolst) + nisr
* YK         ijoin(2) = kmcstr(i+1,icolst) - 2
             ijoin(2) = kmcstr(i+1,icolst) +nisr
*            call lujoin(2,ijoin)
             k(ijoin(1),1) = 3
             if( k(ijoin(1),2) .gt. 0 ) then
                 k(ijoin(1),4) = ijoin(2)*10000
             else
                 k(ijoin(1),5) = ijoin(2)*10000
             endif
             k(ijoin(2),1) = 3
             if( k(ijoin(2),2) .gt. 0 ) then
                 k(ijoin(2),4) = ijoin(1)*10000
             else
                 k(ijoin(2),5) = ijoin(1)*10000
             endif
         endif
   20 continue

********************************************************************
*      'rqmax '  This q-maximum
*has to be the maximum of q-q-bar system, NOT a initial e+e- system.
********************************************************************
c     rqmax = real(w)

*     print *,'before shower',jshowr
*     call lulist(1)
      if( jshowr .eq.1 ) then
         do 21 i=1,kmcbmx,2
         if(kmcstr(i,icolst) .ne.0) then
          kk1=kmcstr(i  ,icolst)+nisr
          kk2=kmcstr(i+1,icolst)+nisr
          rqmax=sqrt( (p(kk1,4)+p(kk2,4))**2
     .-               (p(kk1,1)+p(kk2,1))**2
     .-               (p(kk1,2)+p(kk2,2))**2
     .-               (p(kk1,3)+p(kk2,3))**2 )
c         call lushow(kmcstr(i,icolst),kmcstr(i+1,icolst),rqmax)
          call lushow(   kk1          ,   kk2            ,rqmax)
         endif
 21      continue
*        print *,'after shower'
*        call lulist(1)
      endif
      return
      end
* File spdetc.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      subroutine spdetc
*-----------------------------------------------------------------------
*     Selection of Color State for llll,llqq,qqqq
*        output:icolst (0->ncbase-1)
*-----------------------------------------------------------------------
      implicit real*8 (a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'
      dimension asum(0:ncbase-1),cratio(0:ncbase-1)
      external drn
      if( kmcbas .eq. 1 ) then
          icolst = 0
      else
*-----------------------------------------------------------------------
*        Calcul amplitutes squared.
*-----------------------------------------------------------------------
      do 120 ic = 0 , ncbase-1
      asum(ic) = 0.0d0
      do 110 ih = 0, lag-1
         asum(ic) = asum(ic) + dble(agc(ih,ic))**2 + imag(agc(ih,ic))**2
  110 continue
      asum(ic) = asum(ic)*cfmtx(ic,ic)
  120 continue
*-----------------------------------------------------------------------
*        Search maximum.
*-----------------------------------------------------------------------
      allsum = 0.0d0
      do 130 ic = 0, ncbase-1
         allsum = allsum + asum(ic)
  130 continue
      tmpsum = 0.0d0
      do 140 ic = 0, ncbase-1
         tmpsum = tmpsum + asum(ic)
         cratio(ic) = tmpsum/allsum
  140 continue

      cran = drn(idummy)

      do 150 ic = 0, ncbase-1
         if( cratio(ic) .gt. cran ) then
             icolst = ic
             goto 160
         endif
  150 continue
  160 continue
      endif
      return
      end
* File spdeth.f generated by GRACE Ver. 2.00(35)        1997/02/13/15:33
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      subroutine spdeth
*-----------------------------------------------------------------------
*     Selection of helicity State 
*        output:ihlinf
*         ihlinf=ih1+ih2*2+ih3*2**2+ih4*2**3+ih5*2**4+ih6*2**5
* ih1=0or1: helicity state of particle 1
* ih2=0or1: helicity state of particle 2
* ih3=0or1: helicity state of particle 3
* ih4=0or1: helicity state of particle 4
* ih5=0or1: helicity state of particle 5
* ih6=0or1: helicity state of particle 6
*-----------------------------------------------------------------------
      implicit real*8 (a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'
      dimension asum(0:lag-1),cratio(0:lag-1)
      integer  ihp(nextn)
      integer lect
      common/helicity/lect(4000)
      external drn
c...
      do 1 i=1,4000
       lect(i)=-999
 1    continue
*-----------------------------------------------------------------------
*        Calcul amplitutes squared.
*-----------------------------------------------------------------------
      jall = 1
      do 10 i = 1 , nextn
         jall = jall *(jhe(i)-jhs(i)+1)
   10 continue
c      print *,'jall: lag ',jall,lag
c      print *,'kmcbas: ncbase ',kmcbas,ncbase
c      do i=0,lag-1
c      do j=0,ncbase-1
c      print *,i,j,agc(i,j),cfmtx(j,j)
c      enddo
c      enddo
      do 120 ih = 0, jall-1
       asum(ih) = 0.0d0
      do 110 ic = 0 , kmcbas-1
         asum(ih) = asum(ih) 
     .+ (dble(agc(ih,ic))**2 + imag(agc(ih,ic))**2)*cfmtx(ic,ic)
c        print *,'agc,cfmtx asum',ih,ic,agc(ih,ic),cfmtx(ic,ic),asum(ih)
  110 continue
  120 continue
*-----------------------------------------------------------------------
*        Search maximum.
*-----------------------------------------------------------------------
      allsum = 0.0d0
      do 130 ih = 0, jall-1
         allsum = allsum + asum(ih)
c        print *,' ih ',ih,asum(ih),allsum
  130 continue
      if( allsum .eq. 0.0d0 ) stop
      tmpsum = 0.0d0
      do 140 ih = 0, jall-1
         tmpsum = tmpsum + asum(ih)
         cratio(ih) = tmpsum/allsum
c         print *,'cratio: ',ih,cratio(ih)
  140 continue

      cran = dble(drn(idummy))
c      print *,'cran: ',cran

      do 150 ih = 0, jall-1
         if( cratio(ih) .gt. cran ) then
             ihelst = ih
c             print *,'ihelst: ',ihelst
             goto 160
         endif
  150 continue
  160 continue
      
      ihlinf=ih
c      print *,'ihlinf: ',ihlinf

*=== sample (how to get helicity state)
      m = ihlinf
      do 200 i =  1 , nextn
         ihp(i) = mod(m,jhe(i)-jhs(i)+1)+jhs(i)
         m  = m/(jhe(i)-jhs(i)+1)
c      print *,'i, m,jhe(i),jhs(i)',i, m,jhe(i),jhs(i)
c      print *,'helicity ',ihp(i)
      lect(i)=ihp(i)*2-1
  200 continue

      return
      end
* File spdeth.f generated by GRACE Ver. 2.00(35)        1997/02/13/15:33
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
      subroutine spdeth
*-----------------------------------------------------------------------
*     Selection of helicity State 
*        output:ihlinf
*         ihlinf=ih1+ih2*2+ih3*2**2+ih4*2**3+ih5*2**4+ih6*2**5
* ih1=0or1: helicity state of partice 1
* ih2=0or1: helicity state of partice 2
* ih3=0or1: helicity state of partice 3
* ih4=0or1: helicity state of partice 4
* ih5=0or1: helicity state of partice 5
* ih6=0or1: helicity state of partice 6
*-----------------------------------------------------------------------
*     Initial average
*-----------------------------------------------------------------------
      implicit real*8 (a-h,o-z)
      include 'incl1.f'
      include 'inclk.f'
      dimension asum(0:lag-1),cratio(0:lag-1)
      integer  ihp(nextn)
      external drn
*-----------------------------------------------------------------------
*        Calcul amplitutes squared.
*-----------------------------------------------------------------------
      jiall = 1
      do 10 i = 1 , 2
         jiall = jiall *(jhe(i)-jhs(i)+1)
   10 continue

      jfall = 1
      do 11 i = 3 , nextn
         jfall = jfall *(jhe(i)-jhs(i)+1)
   11 continue

      do 120 ihf = 0, jfall-1
      asum(ihf) = 0.0d0
      do 115 ihi = 0 , jiall-1
         ih = ihi + jiall*ihf
      do 110 ic = 0 , kmcbas-1
         asum(ihf) = asum(ihf) 
     .+ (dble(agc(ih,ic))**2 + imag(agc(ih,ic))**2)*cfmtx(ic,ic)
  110 continue
  120 continue
*-----------------------------------------------------------------------
*        Search maximum.
*-----------------------------------------------------------------------
      allsum = 0.0d0
      do 130 ihf = 0, jfall-1
         allsum = allsum + asum(ihf)
*        print *,' ihf,asum ',ihf,asum(ihf)
  130 continue
*     print *,'allsum ',allsum
      if( allsum .eq. 0.0d0 ) stop
      tmpsum = 0.0d0
      do 140 ihf = 0, jfall-1
         tmpsum = tmpsum + asum(ihf)
         cratio(ihf) = tmpsum/allsum
  140 continue

      cran = drn(idummy)

      do 150 ihf = 0, jfall-1
         if( cratio(ihf) .gt. cran ) then
             ihelst = ihf
             goto 160
         endif
  150 continue
  160 continue
      ihlinf=ihf

*=== sample (how to get helicity state)
      m = ihlinf
      ihp(1) = -999
      ihp(2) = -999
      do 200 i =  3 , nextn
         ihp(i) = mod(m,jhe(i)-jhs(i)+1)+jhs(i)
         m  = m/(jhe(i)-jhs(i)+1)
  200 continue

*     print *,'helicity ',ihp

      return
      end
* File userin.f generated by GRACE Ver. 2.00(35)        1996/03/24/15:33
* 
*          Fortran source code generator
*     (c)copyright 1990-1996 Minami-Tateya Group, Japan
*-----------------------------------------------------------------------
************************************************************************
      subroutine userin( lun , ithprc )
      implicit real*8(a-h,o-z)

      include 'incl1.f'

* Spin average factor

*=======================================================================
*          parameters for amplitude calculation
*=======================================================================

*         ============= Set global parameters
           call usrprm( ithprc )
*         =============

           iprint = 1
*         ============= default mass and width
           call setmas( ithprc , iprint )
*         =============

*         ============= modification of mass and width
*          call modmas
*         =============

*         ============= select process
           call procdb( ithprc )
*         =============

*         ============= set kinematics parameters
           call kinmdb( ithprc )
*         =============

*         ============= coupling constants
           call amparm
*         =============

*=======================================================================
*          initialization of kinematics
*=======================================================================

*         ================= 
           call kinit0( lun )
*         =================
*=======================================================================
*          initialization of summary table
*=======================================================================

*=======================================================================
*          Message output 
*=======================================================================
      if(lun.ne.0)call grc4fm( lun )
      call grc4fm( 6 )

      return
      end
* File usrprm.f generated by  "grc4f" for grc4f v 2.1
************************************************************************
      subroutine usrprm( ithprc )
      implicit real*8(a-h,o-z)

      include 'incl1.f'
      include 'inclk.f'
      include 'inclpi.f'
      common /chcntl/ jwidth
      common /grc4fs/ nthprc
      common/cutqp /ips,nobpho,cospho,ephoct,cosopn
*-----------------------------------------------------------------------
* 
* Set global parameters.
* 
*     Process No.
      nthprc = ithprc+1
*-----------------------------------------------------------------------
c----------------------------------------------
c     generated by grcpar (Don't touch)
c----------------------------------------------
       jctype = i4data(ikyadr(  7))
       jcanon = i4data(ikyadr(  8))
       jqmass = i4data(ikyadr(  9))
       jlmass = i4data(ikyadr( 10))
       jwidth = i4data(ikyadr( 11))
       jcolmb = i4data(ikyadr( 12))
       jqcdcr = i4data(ikyadr( 13))
       jgluon = i4data(ikyadr( 14))
       jshowr = i4data(ikyadr( 15))
       jhadrn = i4data(ikyadr( 16))
       jschem = i4data(ikyadr( 17))
        jseed = i4data(ikyadr( 18))
       lubsdt = i4data(ikyadr( 19))
       lubsrl = i4data(ikyadr( 20))
       lusprl = i4data(ikyadr( 21))
        ang1a = r8data(ikyadr( 59))
        ankaa = r8data(ikyadr( 60))
        anlma = r8data(ikyadr( 61))
        ang1z = r8data(ikyadr( 62))
        ankaz = r8data(ikyadr( 63))
        anlmz = r8data(ikyadr( 64))
c----------------------------------------------
c     check by ower
c----------------------------------------------
c----------------------------------------------
c     set   jctype (0:tree / 1:sf / 2: qedpsi / 3: qedpsif)
c----------------------------------------------
      if( jctype .lt. 0 . or.
     .    jctype .gt. 3 ) then
              call grcerr(2,' invalid parm: isrtype')
      endif
      if( jctype .eq. 0 ) then
          jqedps = 0
          isr = 0
          ips = 0
      else if( jctype .eq. 1 ) then
          jqedps = 0
          isr = 1
          ips = 0
      else if( jctype .eq. 2 ) then
          jqedps = 1
          isr = 0
          ips = 1
      else if( jctype .eq. 3 ) then
          jqedps = 1
          isr = 0
          ips = 2
      endif
*     print *,'usrprm : jqedps ',jqedps
*     print *,'usrprm : isr    ',isr
*     print *,'usrprm : ips    ',ips
c----------------------------------------------
c     set   jcanon (1:on / 0:off)
c----------------------------------------------
      if( jcanon .lt. 0 . or.
     .    jcanon .gt. 1 ) then
              call grcerr(2,' invalid parm: jcanon')
      endif
c----------------------------------------------
c     set   jqmass (1:massive quark / 0:massless quark)
c----------------------------------------------
      if( jqmass .lt. 0 . or.
     .    jqmass .gt. 1 ) then
              call grcerr(2,' invalid parm: jqmass')
      endif
c----------------------------------------------
c     set   jlmass (1:massive lepton / 0:massless lepton)
c----------------------------------------------
      if( jlmass .lt. 0 . or.
     .    jlmass .gt. 1 ) then
              call grcerr(2,' invalid parm: jlmass')
      endif
c----------------------------------------------
c     set   jwidth (1:fixed / 0:run)
c----------------------------------------------
      if( jwidth .lt. 0 . or.
     .    jwidth .gt. 1 ) then
              call grcerr(2,' invalid parm: jwidth')
      endif
c----------------------------------------------
c     set   jcolmb (0:no ,1: , 2: )
c----------------------------------------------
      if( jcolmb .lt. 0 . or.
     .    jcolmb .gt. 2 ) then
              call grcerr(2,' invalid parm: jcolmb')
      endif
c----------------------------------------------
c     set   jqcdcr (0:no ,1:yes)
c----------------------------------------------
      if( jqcdcr .lt. 0 . or.
     .    jqcdcr .gt. 1 ) then
              call grcerr(2,' invalid parm: jqcdcr')
      endif
c----------------------------------------------
c     set   jgluon (0:no ,1:yes)
c----------------------------------------------
      if( jgluon .lt. 0 . or.
     .    jgluon .gt. 1 ) then
              call grcerr(2,' invalid parm: jgluon')
      endif
c----------------------------------------------
c     set   jshowr (0:no ,1:yes)
c----------------------------------------------
      if( jshowr .lt. 0 . or.
     .    jshowr .gt. 1 ) then
              call grcerr(2,' invalid parm: jshowr')
      endif
c----------------------------------------------
c     set   jhadrn (0:no ,1:yes)
c----------------------------------------------
      if( jhadrn .lt. 0 . or.
     .    jhadrn .gt. 1 ) then
              call grcerr(2,' invalid parm: jhadrn')
      endif
c----------------------------------------------
c     set   jschem (1:gmu / 0:onshell)
c----------------------------------------------
      if( jschem .lt. 0 . or.
     .    jschem .gt. 1 ) then
              call grcerr(2,' invalid parm: jschem')
      endif
c----------------------------------------------
c     set   jseed (
c----------------------------------------------
      if(  mod(jseed,2) .eq. 0 ) then
              call grcerr(2,' invalid parm: jseed')
      endif
c----------------------------------------------
c     set   lubsdt (logical unit for bases.data)
c----------------------------------------------
      if( lubsdt .lt. 0 . or.
     .    lubsdt .gt. 99 ) then
              call grcerr(2,' invalid parm: lubsdt')
      endif
c----------------------------------------------
c     set   lubsrl (logical unit for spring.result)
c----------------------------------------------
      if( lubsrl .lt. 0 . or.
     .    lubsrl .gt. 99 ) then
              call grcerr(2,' invalid parm: lubsrl')
      endif
c----------------------------------------------
c     set   lusprl (logical unit for spring.result)
c----------------------------------------------
      if( lusprl .lt. 0 . or.
     .    lusprl .gt. 99 ) then
              call grcerr(2,' invalid parm: lusprl')
      endif
c----------------------------------------------
      jano3v = 0
c----------------------------------------------
c     set   ang1a
c----------------------------------------------
*     print *,'ano(gamma)',ang1a,ankaa,anlma
*     print *,'ano(Z)    ',ang1z,ankaz,anlmz
      if(  ang1a .ne. 1.0d0 ) then
              jano3v = 1
      endif
c----------------------------------------------
c     set   ankaa
c----------------------------------------------
      if(  ankaa .ne. 1.0d0 ) then
              jano3v = 1
      endif
c----------------------------------------------
c     set   anlma
c----------------------------------------------
      if(  anlma .ne. 0.0d0 )then
              jano3v = 1
      endif
c----------------------------------------------
c     set   ang1z
c----------------------------------------------
      if(  ang1z .ne. 1.0d0 ) then
              jano3v = 1
      endif
c----------------------------------------------
c     set   ankaz
c----------------------------------------------
      if(  ankaz .ne. 1.0d0 ) then
              jano3v = 1
      endif
c----------------------------------------------
c     set   anlmz
c----------------------------------------------
      if(  anlmz .ne. 0.0d0 ) then
              jano3v = 1
      endif

      if(jano3v.eq.1) then
         andka=1.0d0-ankaa
         andkz=1.0d0-ankaz
*        print *,'andka = ',andka
*        print *,'andkz = ',andkz
      end if

      return
      end
