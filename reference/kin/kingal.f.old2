      PROGRAM KINGAL
C--------------------------------------------------------------------
C - B. Bloch-Devaux sept. 87                     F.Ranjard - 871116
C - B. Bloch-Devaux june  88
C - B. Bloch-Devaux feb.  89
C - B. Bloch-Devaux april 89   NEW cards TIME and HSTO
C - B. Bloch-Devaux May   91   NEW cards GSCL,GSCE
C - B. Bloch-Devaux Decem.91   Third number on TRIG card for number of
C                              accepted triggers ( optionnal)
C - B. Bloch-Devaux January 92 Maximum run number set to 1999
C - B. Bloch-Devaux March   92 No Cumul option for histos in Escan
C - B. Bloch-Devaux August  92 Cross-section Histos in the scan mode
C - B. Bloch-Devaux Septemb 92 NEW KINIT to get bank KREF from Data Base
C                              and handle user's extra cards
C - B. Bloch-Devaux March   98 create banks KRAN and KMAR to keep track of
C                              several RANMAR sequences
C! Main program to run KINGAL in a stand alone mode
C
C   The program calls 3 interface routines to be provided by the user
C     -ASKUSI    at initialisation step
C     -ASKUSE    at event process step
C     -USCJOB    at end of job step
C   The program calls eventually 2 more interface routines to be
C    provided by the user  in case of Energy scan option used
C    those are XKSECT function to return Cross-section in nb
C              USKRIN to reinitialize generator
C
C--------------------------------------------------------------------
      PARAMETER (LMHLEN=2, LMHROW=2, LMHCOL=1)
      PARAMETER (LBCS=100000,LCHAR=4)
      COMMON/BCS/ IW(LBCS)
      REAL RW(LBCS)
      EQUIVALENCE (RW(1),IW(1))
C
      PARAMETER (LHB=3000000)
      COMMON /PAWC/ HB(LHB)
      CHARACTER*80 FNAME,ATYPE,DTYPE,FFNAM
      EXTERNAL KMRUNH,KMKRUN,NAMIND,NLINK,IUCOMP,ALRLEP,AMARSET,ALKMAR
      INTEGER KMRUNH,KMKRUN ,NAMIND,NLINK,IUCOMP,ALRLEP,ALKMAR,ALKRAN
      PARAMETER ( IGEN = 10)
      DIMENSION LSTRN(3),LSTRN2(3),LISTL(IGEN),LISTE(IGEN) 
C   NMXMC : MAXIMUM Run # for MC, NRINC : increment for run # in E scan
      PARAMETER ( NMXMC=1999 , NRINC = 10 )
      DIMENSION IS(4)     !   Random seeds at start of job
C
C  INITIALIZATION            *********************
C
C 1. General facilities initialization
C
C   LBASE = data base logical unit # ( 4 is the default DAF unit )
C   LCARD = data card logical unit # (= 0 means "no data card")
C                                       7 is default
C   LOUT  = printout logical unit # ( = 0 means "no printout")
C                                       6 is default
C   LWRT  = BOS write logical unit # ( = 0 means "no file written")
C                                       0 is default
C   FMT   = BOS write format ('EPIO' means "EPIO format")
C                            ( ' '  means NATIVE format )
C
      PARAMETER (LCTIT=48, LWTIT=LCTIT/4)
      CHARACTER*48 NTIT
      CHARACTER*22 NTIT2
      CHARACTER*4 FMT,CHAINT,CNAME,DMODE,FDEVI
C*CA KIPARA
      PARAMETER (LHKIN=3, LPKIN=5, LKVX=2, LHVER=3, LPVER=5, LVKI=50)
      PARAMETER (LGDCA=32)
      PARAMETER (LRPART=200, LCKLIN=1)
      PARAMETER (LRECL=0, LRUN=1, LEXP=1001, LRTYP=1000)
      CHARACTER*60 LTITL
      PARAMETER (LUCOD=0, LNOTRK=100, LTITL='KINGAL run')
      PARAMETER (LUTRK=350)
      PARAMETER (BFIEL=15., CFIEL=BFIEL*3.E-4)
C*IF DOC
C*CC KIPARA
      PARAMETER ( BIG = 10000.)
      DATA IDPR,WEIT /0,1./
      DATA LBASE,LCARD,LOUT,LWRT /4,7,6,0/
      DATA FMT /' '/
      DATA LSTRN,LSTRN2/3*0,3*0/
      DATA CNAME/'HSTO'/
      DATA DTYPE / 'HIS       '/, DMODE / 'A   '/
C  Here are the codes of the generators which support the GSCL option
      DATA LISTL/1000,
     $           2000,
     $           3000,
     $           4000,
     $           5011,5014,
     $           6000,
     $           7006,7015,
     $           8000
     $ /
C ----------------------------------------------------------------------
C  Here are the codes of the generators which support the GSCE option
      DATA LISTE/1000,
     $           2000,
     $           3000,
     $           4000,
     $           5011,5014,
     $           6000,
     $           7006,7015,
     $           8000
     $ /
      TLIM=5.*3600.
      TLIM=999999.
      CALL TIMeST(TLIM)
      CALL TIMeX(TIME1)
C   First call to KINIT   : Steering cards are then available
      CALL KINIT (LBCS,LBASE,LCARD,LOUT,LWRT,FMT)
C
C   Initialise Hbook Package
C
      CALL HLIMIT(LHB)
C
C 2. Run's specific parameters initialization
C
C   BANK RUNH and KRUN
C   NRUN = run #
C   NEXP = experiment # (mandatory 1001 for monte carlo)
C   NRTP = run type (10000 - 99999 for user needs)
C   IGCOD = generator code (has to be the same as the generator code
C                          number given in the library)
C   NOTR  = notracking marking word (the default value has to be taken)
C   NTIT  = run title
C
C      suggested RUN card ( as GALEPH ) RUN  NRUN  'TITLE'
C
      NRUN = LRUN
      NEXP = LEXP
      NOTR = LNOTRK
      NTIT = LTITL
      IGCOD = LUCOD
      JRUN = NLINK('RUN ',0)
      IF(JRUN.NE.0) THEN
         NRUN = IW(JRUN+1)
         NKAR = IW(JRUN)-1
         J=1
         NKMAX = MIN(LWTIT,NKAR)
         DO 10 I=1,NKMAX
            NTIT(J:J+3) = CHAINT(IW(JRUN+1+I))
            J=J+4
   10    CONTINUE
      ENDIF
C  TRIG        n1    n2    n3
C    Suggested data card ( n1 First trigger# , n2 last , n3 optionnal)
C
      IEV1 = 1
      IEV2 = 100
      NEV3 = 0
      JTRIG = NLINK('TRIG',0)
      IF(JTRIG.NE.0) THEN
         IEV1 = IW(JTRIG+1)
         IEV2 = IW(JTRIG+2)
         IF ( IW(JTRIG).GE.3) NEV3 = IW(JTRIG+3)
      ENDIF
      IEV3 = NEV3
C  DEBUG lout / ndeb1  ndeb2
      IDB1 = 0
      IDB2 = 0
      NADEB = NAMIND('DEBU')
      JDEBU = IW(NADEB)
      IF(JDEBU.NE.0) THEN
         IDB1 = IW(JDEBU+1)
         IDB2 = IW(JDEBU+2)
         LOUT = IW(JDEBU-2)
      ENDIF
C  TIME      timleft
      TIMLFT = 20.
      NATIM = NAMIND('TIME')
      JTIME = IW(NATIM)
      IF(JTIME.NE.0) THEN
         TIMLFT=IW(JTIME+1)
         IF (TIMLFT.LT.1.) TIMLFT = RW(JTIME+1)
      ENDIF
C  SAVE lwrt / fmt          is now obsolete
C      NASAV = NAMIND('SAVE')
C      JSAVE = IW(NASAV)
C      IF(JSAVE.NE.0) THEN
C         LWRT = IW(JSAVE-2)
C         FMT = CHAINT(IW(JSAVE+1))
C      ENDIF
C  suggested HSTO card to store Histos on a disk file
C       HSTO  'file name specifications '
      IER = 0
      JHSTO= NLINK('HSTO',0)
      IF(JHSTO.NE.0 ) THEN
         CALL ACDARG(CNAME,DTYPE,DMODE,FNAME,ATYPE,FDEVI,IER)
         FFNAM(1:3) = 'E01'
         FFNAM(4:80) = FNAME(4:80)
      ENDIF
C  suggested HNOC card to store Histos on a disk file and print them
C  out after each energy run of the scan HNOC
      JHNOC= NLINK('HNOC',0)
C
C  If data cards have been read, recall KINIT
C   It will load generator specific cards ( PRODUCTION mode)or nothing
      IF(LCARD.GT.0) CALL KINIT (LBCS,LBASE,LCARD,LOUT,LWRT,FMT)
C
C  RNDM  inrn      Initialise random number RNDM
C  the standard init will use RMAR ( or RINI) card
         INRN = 12345
         CALL RDMIN(INRN)
C
C  GSCE   E1  frac1   E2  frac2........En fracn
      NASCE = NAMIND('GSCE')
      JGSCE = IW(NASCE)
C  GSCL   E1  lum1    E2  lum2 ........En lumn
      NASCA = NAMIND('GSCL')
      JGSCA = IW(NASCA)
      IF (JGSCE.GT.0 .AND. JGSCA.GT.0) THEN
         WRITE(IW(6),1002)
         WRITE(IW(6),'(''   PLEASE , CHOOSE YOUR ENERGY SCAN OPTION :
     $   LUMINOSITY ( GSCL) OR FRACTION OF EVENTS ( GSCE)   '')')
         WRITE(IW(6),1002)
         CALL EXIT
      ENDIF
      IF(JGSCA.GT.0 .OR. JGSCE.GT.0 ) THEN
         WRITE(IW(6),1002)
         IF(JGSCA.GT.0 ) THEN
            NSCA = IW(JGSCA)/2
            EMIN = BIG
            EMAX = 0.
            DO 2 JE = 1,NSCA
               EI   = RW(JGSCA+(JE-1)*2+1)
               IF ( EI.GT.EMAX) EMAX = EI
               IF ( EI.LT.EMIN) EMIN = EI
 2          CONTINUE
            EMIN = MAX( 0.,EMIN-1.)
            EMAX = MAX( 0.,EMAX+1.)
            CALL HBOOK1(9000,'Cross-section vs Energy ( Gev)',2*NSCA,
     $      EMIN,EMAX,0.)
            CALL HBOOK1(9001,'Generated Luminosity vs Energy ( Gev)',
     $      2*NSCA,EMIN,EMAX,0.)
         ELSEIF(JGSCE.GT.0 ) THEN
            NSCA = IW(JGSCE)/2
            NTOTE = IEV2-IEV1+1
            EMIN = BIG
            EMAX = 0.
            DO 3 JE = 1,NSCA
               EI   = RW(JGSCE+(JE-1)*2+1)
               IF ( EI.GT.EMAX) EMAX = EI
               IF ( EI.LT.EMIN) EMIN = EI
 3          CONTINUE
            EMIN = MAX( 0.,EMIN-1.)
            EMAX = MAX( 0.,EMAX+1.)
         ENDIF
         CALL HBOOK1(9002,'Generated events vs Energy ( Gev)',2*NSCA,
     $   EMIN,EMAX,0.)
         IF ( NEV3.GT.0)
     $   CALL HBOOK1(9003,'Accepted  events vs Energy ( Gev)',2*NSCA,
     $   EMIN,EMAX,0.)
         CALL HIDOPT(0,'STAR')
         WRITE(IW(6),'(''   KINGAL  SCAN requested for'',I10,'' energy
     $   points'')') NSCA
         WRITE(IW(6),1002)
         NTIT2(1:20) = 'ENERGY SCAN POINT # '
         NRUNO = NRUN
         IF (NRUNO+NRINC*(NSCA-1).GT.NMXMC) THEN
            NRUNO = NMXMC- NRINC*(NSCA-1)
            WRITE(IW(6),1001) NRUN,NRUNO
         ENDIF
      ELSE
         NSCA = 1
         NTIT2 = ' '
         IF (NRUN.GT.NMXMC) THEN
            WRITE(IW(6),1001) NRUN,NMXMC
            NRUN = MIN ( NRUN , NMXMC)
         ENDIF
      ENDIF
C
C 3. Generator initialization
C
      JKREF  = IW(NAMIND('KREF'))
      NREF = 0
      IF ( JKREF.GT.0) NREF = IW(JKREF-2)
      CALL ASKUSI(IGCOD)
      NRTP = IGCOD+10000
      IGCOD = IGCOD + 10000*NREF
C
C    Check that this generator supports the E scan option
C
      ISCAN = 1
      IF(JGSCA.GT.0 .AND. IUCOMP(IGCOD,LISTL,IGEN).LE.0) THEN
         ISCAN = 0
      ENDIF
      IF(JGSCE.GT.0 .AND. IUCOMP(IGCOD,LISTE,IGEN).LE.0) THEN
         ISCAN = 0
      ENDIF
      IF ( ISCAN .EQ. 0) THEN
         WRITE(IW(6),1002)
         WRITE(IW(6),'(''   THIS GENERATOR IS NOT SUPPORTING THE ENERGY
     $   SCAN OPTION YET !!!!!!  CONTACT B.BLOCH TO VOLUNTEER'')')
         WRITE(IW(6),1002)
         CALL EXIT
      ENDIF
C
C 4. LOOP on energy scan points if needed
C
      DO 11 ISC = 1,NSCA
      JGSCA = IW(NASCA)
      JGSCE = IW(NASCE)
      IF(JGSCA+JGSCE.GT.0 ) THEN
         WRITE(IW(6),1002)
         IF(JGSCA.GT.0 ) THEN
            EI   = RW(JGSCA+(ISC-1)*2+1)
            ULMI = RW(JGSCA+(ISC-1)*2+2)
            XSECT = XKSECT(EI)
            IF ( XSECT.GT.0.) IEV2 = NINT(ULMI*XSECT)+IEV1-1
            IF ( XSECT.GT.0. .AND. NEV3.GT.0) IEV3 = NINT(ULMI*XSECT)
            WRITE(IW(6),'('' KINGAL  ENERGY SCAN  : POINT # '',I5,F10.3,
     $  '' Gev '','' X-SECTION '',E10.3,'' Luminosity '',E10.3,''nb-1 ''
     $ ,'' Events to be generated from'',I8,'' to'',I8,'' accepted'',I8)
     $ ') ISC,EI,XSECT,ULMI,IEV1,IEV2,IEV3
         ELSEIF(JGSCE.GT.0 ) THEN
            EI   = RW(JGSCE+(ISC-1)*2+1)
            FRAC = RW(JGSCE+(ISC-1)*2+2)
            IEV2 = NINT(NTOTE*FRAC)+IEV1-1
            IF ( NEV3.GT.0) IEV3 = NINT(NEV3*FRAC)
            WRITE(IW(6),'('' KINGAL  ENERGY SCAN  : POINT # '',I5,F10.3,
     $    '' Gev '','' FRACTION  '',E10.3,
     $    '' Events to be generated from'',I8,'' to'',I8,'' accepted'',
     $    I8)')ISC,EI,FRAC,IEV1,IEV2,IEV3
         ENDIF
         WRITE(IW(6),1002)
         WRITE(NTIT2(21:22),'(I2)') ISC
         IF ( JHNOC.GT.0) CALL HRESET(0,' ')
         NRUN = NRUNO+NRINC*(ISC-1)
         NTIT = NTIT2
         WRITE(IW(6),'(A50,'' RUN # '',I8)') NTIT,NRUN
C Restore header banks list , update RLEP
         CALL BLIST(IW,'C=','RUNRRUNHKRUNKRANKJOBPARTKLINRLEPKLUN')
         IEBEAM = NINT(EI*500.)
         JRLEP= ALRLEP(IEBEAM,'    ',0,0,0)
         CALL PRTABL('RLEP',0)
C
C 4.1 Generator initialization with specific energy
C
         CALL USKRIN(EI)
      ENDIF
C
C  REDEFINE SOME RUNH AND KRUN PARAMETERS
C
      AMAR = AMARSET(0)
      NBK = KMRUNH (NRUN,NEXP,NRTP)
      NBK = KMKRUN (IGCOD,NOTR,NTIT)
      call alseed(irgen,iseed1,iseed2)
      AMAR = AMARSET(1)
      call alseed(irgen,iseed3,iseed4) 
      nseq = 2
C      WRITE (IW(6),'(/1X,'' seeds for KRAN '',4i10)') 
C     $                             iseed1,iseed2,iseed3,iseed4
      is(1) = iseed1
      is(2) = iseed2
      is(3) = iseed3
      is(4) = iseed4
      JKRAN = ALKRAN(nseq,is)
      IF (JKRAN .LE. 0) THEN
C     error in filling KRAN bank - STOP
        WRITE (IW(6),'(/1X,''not enough space for KRAN - STOP'')')
        CALL EXIT
      ENDIF
C
C  PERFORM GARBAGE COLLECTION
C
      CALL BGARB(IW)
      CALL TIMeX(TIME2)
C
C 4.2 EVENT GENERATION          *********************
C
      NGEN = IEV2-IEV1+1
      MGEN = 0
      IACC = 0
      IEVT = IEV1 -1
C     DO 20 IEVT = IEV1,IEV2
 18   CONTINUE
      IF ( NEV3.GT.0) THEN
         IF ( IACC.GE.IEV3) GO TO 20
         IF (IACC.EQ.IEV3-1) CALL UGTSEC
      ELSE IF ( NEV3.LE.0) THEN
         IF ( MGEN.GE.NGEN) GO TO 20
         IF ( MGEN.EQ.NGEN-1) CALL UGTSEC
      ENDIF
C     current trigger number
         IEVT = IEVT +1
         IEV2 = IEVT
         CALL TIMeL(TIM)
         IF (TIM.LT.TIMLFT) GO TO 55
C    first ranmar sequence at begin of event
         amar = amarset(0)
         CALL ASKUSE (IDPR,ISTA,NTRK,NVRT,ECMS,WEIT)
         MGEN = MGEN + 1
C
C  if DEBUG required
         IF(IEVT.GE.IDB1 .AND. IEVT.LE. IDB2) THEN
            WRITE(IW(6),'(/1X,''IEVT,IDPR,ISTA,NTRK,NVRT,ECMS,WEIT'',
     +       5I10,F10.4,3X,E12.5)') IEVT,IDPR,ISTA,NTRK,NVRT,ECMS,WEIT
      IF (ISTA.EQ.0 ) THEN
            CALL PRKINE
            JKPOL = NLINK ('KPOL',0)
            IF ( JKPOL.GT.0) CALL PRTABL('KPOL',0)
            JKHIS = NLINK ('KHIS',0)
            IF (JKHIS.GT.0) THEN
             WRITE (LOUT,'(/1X,''+++KINGAL+++ KHIS bank print out'')')
             NROW = IW(JKHIS+LMHROW)
             M1 = 1
 19          M2 = MIN (M1+9,NROW)
             WRITE (LOUT,'(/1X,10I10)') (LLL,LLL=M1,M2)
             WRITE (LOUT,'(1X ,10I10)') (IW(JKHIS+LMHLEN+LLL),LLL=M1,M2)
             M1 = M1+10
             IF (M1.LE.NROW) GOTO 19
            ENDIF
            JKZFR = NLINK ('KZFR',0)
            IF (JKZFR.GT.0) THEN
             WRITE (LOUT,'(/1X,''+++KINGAL+++ KZFR bank print out'')')
             NROW = IW(JKZFR+LMHROW)
             M1 = 1
 21          M2 = MIN (M1+9,NROW)
             WRITE (LOUT,'(/1X,10I10)') (LLL,LLL=M1,M2)
           WRITE (LOUT,'(1X ,10F10.3)') (RW(JKZFR+LMHLEN+LLL),LLL=M1,M2)
             M1 = M1+10
             IF (M1.LE.NROW) GOTO 21
            ENDIF
            JKXME = NLINK ('KXME',0)
            IF (JKXME.GT.0) CALL PRTABL('KXME',0)
            JKWTK = NLINK ('KWTK',0)
            IF (JKWTK.GT.0) CALL PRTABL('KWTK',0)
            JKWGT = NLINK ('KWGT',0)
            IF (JKWGT.GT.0) CALL PRTABL('KWGT',0)
            JKSHO = NLINK ('KSHO',0)
            IF (JKSHO.GT.0) CALL PRTABL('KSHO',0)
         ENDIF
      ENDIF
C       creates KMAR bank with initial seeds of the 2 sequences
         amar = amarset(1)
         call rdmout(lstrn2)
         amar = amarset(0)
         call rdmout(lstrn)
         nseq = 2
         jkmar = alkmar(nseq,lstrn,lstrn2 ) 
         if ( jkmar.le.0) ista = 10
C
         MSTAT = 0
         IF(ISTA.EQ.0) THEN
            MSTAT = 1
            IACC = IACC +1
         ENDIF
         CALL KEEVT(IEVT,MSTAT,NVRT,NTRK,WEIT,IDPR,ECMS,LWRT)
         GO TO 18
C
   20 CONTINUE
C
C 4.3  END OF GENERATION         *********************
C
      ITLIM = 0
      GO TO 56
 55   IEV2 = IEVT-1
      WRITE (LOUT,'(/,1X,''********END RUN BY TIME LIMIT AFTER EVENT #
     $ '',I10)') IEV2
      ITLIM = 1
 56   CONTINUE
      amar = amarset(1)
      CALL RDMOUT(LSTRN2)
      amar = amarset(0)
      CALL RDMOUT(LSTRN)
      CALL TIMeX(TIME3)
      CALL USCJOB
      IF(JGSCA+JGSCE.GT.0 ) THEN
         CALL HFILL(9002,EI,DUM,FLOAT(MGEN))
         IF ( NEV3.GT.0) CALL HFILL(9003,EI,DUM,FLOAT(IACC))
         IF(JGSCA.GT.0 ) THEN
            CALL HFILL(9000,EI,DUM,XSECT)
            CALL HFILL(9001,EI,DUM,ULMI)
         ENDIF
      ENDIF
C     printout histos if non cumulative option
      IF ( JHNOC.GT.0) THEN
         CALL HPHST(0)
         IF (JHSTO.GT.0 .AND. IER.EQ.0) THEN
            WRITE(FFNAM(2:3),'(I2)') ISC
            IF ( FFNAM(2:2).EQ.' ') FFNAM(2:2) = '0'
            CALL HRPUT(0,FFNAM,'N')
            WRITE(LOUT,'(/,1X,''******** HISTOGRAMS WRITTEN TO DISK FILE
     $ '',A80)') FFNAM
         ENDIF
      ENDIF
C
C  4.5 KINGAL END OF JOB
C
      NEVT = IEV2 - IEV1 + 1
      IF ( ISC.EQ.NSCA) CALL KEJOB(LWRT,NEVT)
      CALL ACLOSE(0,IER)
      CALL TIMeX(TIME4)
      WRITE(IW(6),1000) (TIME2-TIME1),NEVT,(TIME3-TIME2)/NEVT,
     $                                IACC,(TIME3-TIME2)/IACC,
     $                  (TIME4-TIME3),(TIME4-TIME1),LSTRN,LSTRN2
 1000 FORMAT (1X,'**************RUNNING TIME STATISTICS****************'
     &,/,1X,'*  INIT Time spend           :   ',F10.3,
     & /,1X,'*  Number of generated events:   ',I10  ,
     & /,1X,'*  Time per generated event  :   ',F10.3,
     & /,1X,'*  Number of accepted  events:   ',I10  ,
     & /,1X,'*  Time per accepted  event  :   ',F10.3,
     & /,1X,'*  END OF JOB Time spend     :   ',F10.3,
     & /,1X,'*  TOTAL Time spend          :   ',F10.3,
     & /,1X,'*  LAST RANDOM NUMBER USED #1:  ',3I20  ,
     & /,1X,'*  LAST RANDOM NUMBER USED #2:  ',3I20  ,
     & /,1X,'*****************************************************')
C
      IF ( ITLIM.EQ.1 ) GO TO  30
  11  CONTINUE
  30  CONTINUE
C If CUMUL required , printout ( and store) histos at the end
      IF ( JHNOC.LE.0) THEN
         CALL HPHST(0)
         IF (JHSTO.GT.0 .AND. IER.EQ.0) THEN
            CALL HRPUT(0,FNAME,'N')
            WRITE(LOUT,'(/,1X,''********HISTOGRAMS WRITTEN TO DISK FILE
     $ '',A80)') FNAME
         ENDIF
      ENDIF
C
 1001 FORMAT ('   ++++++++++++++++++++++++++++++++++++ ',/,
     $        '   ++++++++++++++++++++++++++++++++++++ ',/,
     $        '   KINGAL  requested  with too large MC run #' ,I10,
     $        ' will be set to ',I10,/,
     $        '   ++++++++++++++++++++++++++++++++++++ ',/,
     $        '   ++++++++++++++++++++++++++++++++++++ ',/)
 1002 FORMAT ('   ++++++++++++++++++++++++++++++++++++ ',/,
     $        '   ++++++++++++++++++++++++++++++++++++ ',/)
      STOP
      END
C*DK KINIT
      SUBROUTINE KINIT (LBCS,LBASE,LCARD,LOUT,LWRT,FMT)
C -----------------------------------------------------------------
C - F.Ranjard - 870504    modified 870924 B.Bloch for Data Base
C - Modified JULY88 B.Bloch for Data Base access and KJOB Bank
C - Modified Sept92 B.Bloch for Data Base access of KREF bank and
C                           handling of user's extra cards
C! Initialize event interface package
CKEY KINE KINGAL INIT  /   INTERNAL
C  called by KINGAL   AT LEAST once per job
C  can be called a 2nd times if the user has modified some parameters
C  by data cards.
C  if 1st entry then
C     initialize the BOS array with LBCS words
C     define formats and output lists
C     if LCARD.ne.0 then read data cards ,
C     read the data base from LBASE unit to get PART bank
C     stop if no PART bank
C     loads default input set KREF from Dbase
C     if LOUT.ne.0 then set BOS output unit = LOUT
C     if LWRT.ne.0 then initialize BOS writing unit LWRT  ( SAVE and
C        FILO cards)
C     book and fill RUNH and KRUN banks with default values
C     expand KREF  bank and swap input from KREF to temporary banks
C  endif
C  if 2nd entry and KREF was read in then
C     read USER's extra cards
C     supersede defaults from KREF by user input
C  endif
C  if 3rd entry then STOP
C
C - structure: SUBROUTINE subprogram
C              User Entry Name: KINIT
C              External References: BOS/BKFMT/BLIST/BREADC/BUNIT(BOS77)
C                                   ACDARG/AFILOU/AOPDBS/AOPEN/AOPENW/
C                                   ADBVER/JUNIDB/
C                                   BKINJB/
C                                   ALRUNH/ALKRUN/ALKJOB(ALEPHLIB)
C              Comdecks referenced: BCS, KIPARA,BMACRO
C
C - usage  : CALL KINIT (LBCS,LBASE,LCARD,LOUT,LWRT,FMT)
C - Input  : LBCS   = BOS array length (at least 10000 words)
C            LBASE  = data base logical unit (not used)
C            LCARD  = data card log. unit ( 0 means no data card)
C            LOUT   = print out unit      ( 0 means no printout)
C            LWRT   = output file unit    ( 0 means no output file)
C            FMT    = output file format    ( 'EPIO' or ' '='NATI')
C            LOUT, LWRT, FMT could be overwritten by data card
C
C*IF .NOT.DOC  -----------------------------------------------------
      SAVE
      DIMENSION LSTRN(2) 
      CHARACTER*(*) FMT
      CHARACTER FNAME*120
      CHARACTER*60  TITLE
      CHARACTER     TFNAM*60,TATYP*60,TDEVI*60
      CHARACTER*4 CHAINT
      INTEGER ALKJOB,ALRUNH,ALKRUN,ALRUNR
      INTEGER ALGTDB
      EXTERNAL ALGTDB,AMARSET
      PARAMETER ( LNAM= 500)
C*CA BCS
      INTEGER LMHLEN, LMHCOL, LMHROW
      PARAMETER (LMHLEN=2, LMHCOL=1, LMHROW=2)
C
      COMMON/BCS/ IW(100000)
      INTEGER IW
      REAL RW(100000)
      EQUIVALENCE (RW(1),IW(1))
C
C*CC BCS
C*CA KIPARA
CKEY KINE KINGAL DEFAULT
      PARAMETER (LHKIN=3, LPKIN=5, LKVX=2, LHVER=3, LPVER=5, LVKI=50)
      PARAMETER (LGDCA=32)
      PARAMETER (LRPART=200, LCKLIN=1)
      PARAMETER (LRECL=16020, LRUN=1, LEXP=1001, LRTYP=1000)
      CHARACTER*60 LTITL
      PARAMETER (LUCOD=0, LNOTRK=100, LTITL='KINGAL run')
      PARAMETER (LUTRK=350)
      PARAMETER (BFIEL=15., CFIEL=BFIEL*3.E-4)
C*IF DOC
C*CC KIPARA
      PARAMETER ( IRMX = 1999)
      DATA IFI /0/
C*CA BMACRO
C!    set of intrinsic functions to handle BOS banks
C - # of words/row in bank with index ID
      LCOLS(ID) = IW(ID+1)
C - # of rows in bank with index ID
      LROWS(ID) = IW(ID+2)
C - index of next row in the bank with index ID
      KNEXT(ID) = ID + LMHLEN + IW(ID+1)*IW(ID+2)
C - index of row # NRBOS in the bank with index ID
      KROW(ID,NRBOS) = ID + LMHLEN + IW(ID+1)*(NRBOS-1)
C - # of free words in the bank with index ID
      LFRWRD(ID) = ID + IW(ID) - KNEXT(ID)
C - # of free rows in the bank with index ID
      LFRROW(ID) = LFRWRD(ID) / LCOLS(ID)
C - Lth integer element of the NRBOSth row of the bank with index ID
      ITABL(ID,NRBOS,L) = IW(ID+LMHLEN+(NRBOS-1)*IW(ID+1)+L)
C - Lth real element of the NRBOSth row of the bank with index ID
      RTABL(ID,NRBOS,L) = RW(ID+LMHLEN+(NRBOS-1)*IW(ID+1)+L)
C
C*IF1 ETA
C*CC BMACRO
C -------------------------------------------------------------------
      IFI = IFI + 1
      IF (IFI-2) 1,2,3
    1 CONTINUE
C - BOS initialization
C
      CALL BNAMES (LNAM)
      CALL BOS (IW,LBCS)
      IF (LCARD .GT. 0) IW(5) = LCARD
C
C - Read DATA CARD
C
      FNAME = ' '
      CALL GETENVF ('KINGALCARDS',FNAME)
      IF (FNAME.NE.' ') CALL AOPEN(LCARD,FNAME,'CARD','DISK',IER)
C
      CALL BKFMT ('VERT','3I,4F,(I)')
      CALL BKFMT ('KINE','3I,4F,(I)')
C
      CALL BLIST (IW,'C=','RUNRRUNHKRUNKRANKJOBPARTKCARRLEPKLUN')
      CALL BLIST (IW,'E=','EVEHKEVHKMARVERTKINE')
C
C - Get ALEPHLIB version #
      CALL ALVERS (ALEFV)
C
C - Initialize default values
C
      IRUN = LRUN
      IEXP = LEXP
      IRTYP = LRTYP
      IUCOD = LUCOD
      NOTRK = LNOTRK
      TITLE = LTITL
C
C - Read data cards if required
C
      IF (LCARD .GT.0) THEN
        CALL BREADC
      ENDIF
C  Look if Production mode ( NREF card ) or not ( no NREF card)
      JREF  = IW(NAMIND('NREF'))
      NREF = IRMX
      IF(JREF .NE.0) NREF = IW(JREF+1 )
C  look if multiple read necessary
      IF ( NREF.GE.96 .and. NREF.lt.200) NREF = NREF*100
      IF ( JREF.EQ.0 ) THEN
C   Expand KCAR bank if defined
         CALL BCALLC(IW,'KCAR',0)
      ENDIF
C
C - Read the data base to get the 'PART' bank
C
      LBAS = JUNIDB(0)
C
C   Open DAF once for all
      CALL AOPDBS ('   ',IRETD)
      IF (IRETD.NE.0) THEN
         WRITE (IW(6),'(/1X,''KINIT: NO data base (AOPDBS) - STOP'')')
         CALL EXIT
      ENDIF
C   Get ADBSCONS DAF version # and date of last change
      CALL ADBVER (IVERS,IDATE)
C
C   Get PART bank from the DAF
      IREDB=MDARD(IW,LBAS,'PART',0)
      IF (IREDB.LE.0) GO TO 998
      IF (LCOLS(IREDB).EQ.8) THEN
         CALL BKFMT('PART','2I,(I,3A,I,3F)')
      ELSEIF (LCOLS(IREDB).EQ.10) THEN
         CALL BKFMT ('PART','2I,(I,3A,I,4F,I)')
      ENDIF
C   Get KREF bank from the DAF ,print it if requested  by NREF
      NREF0 = 0
      NREF1 = 0
      IF ( JREF.GT.0 ) THEN
         WRITE (IW(6),100) NREF
         if ( NREF.GE.9600) NREF1 = MOD(NREF,100)
         NREF0 = 100*(NREF/100)
         IF ( NREF1.NE .0 ) then
            WRITE ( IW(6),*) ' Accessing NREF  ',NREF0
C            IREDB=ALGTDB(LBAS,'KREF',NREF0)
            IREDB=MDARD(IW,LBAS,'KREF',NREF0)
            IF (IREDB.EQ.0) GO TO 998
C           IF (IREDB.LE.0) GO TO 998
            WRITE ( IW(6),*) ' Accessing NREF  ',NREF0, '   success '
            call bcallc(iw,'KREF',NREF0)
         ENDIF
         IF ( NREF.ne.0 )  then
            WRITE ( IW(6),*) ' Accessing NREF  ',NREF
C            IREDB=ALGTDB(LBAS,'KREF',NREF)
C            IF (IREDB.EQ.0) GO TO 998
            IREDB=MDARD(IW,LBAS,'KREF',NREF)
            IF (IREDB.EQ.0) GO TO 998
            WRITE ( IW(6),*) ' Accessing NREF  ',NREF, '   success '
         ENDIF
C         JKREF = IW(NAMIND('KREF'))
C         NREF = IW(JKREF-2)
         IF (IW(NAMIND('PREF')).NE.0) THEN
            IF ( NREF1.NE .0 ) IND = NPRNT('KREF',NREF0)
            IND = NPRNT('KREF',NREF)
         ENDIF
      ENDIF
C
      JDEBU = IW(NAMIND('DEBU'))
      IF(JDEBU.NE.0) LOUT = IW(JDEBU-2)
C      JSAVE = IW(NAMIND('SAVE'))     ! obsolete
C      IF(JSAVE.NE.0) THEN
C         LWRT = IW(JSAVE-2)
C         FMT = CHAINT(IW(JSAVE+1))
C      ENDIF
C
C - Set logical units according to data cards if any
C
      IF (LOUT  .GT. 0) IW(6) = LOUT
C
C - Initialize output file LWRT
      JFILO = IW(NAMIND('FILO'))
      IF (JFILO .NE. 0) THEN
        CALL AFILOU (TFNAM,TATYP,TDEVI,IRET)
        IF (IRET.NE.0) THEN
           WRITE (IW(6),'(/1X,''KINIT: wrong output file name'',
     &      '' (AFILOU) - STOP'',I4)') IRET
           CALL EXIT
        ENDIF
        IF (LWRT .EQ. 0) LWRT = 2
C
C Open the output file :
        CALL AOPENW (LWRT,TFNAM,TATYP,TDEVI,IRET)
        IF (IRET.NE.0) THEN
           WRITE (IW(6),'(/1X,''KINIT: cannot open output file'',
     &        '' (AFILOU) - STOP'',I4)') IRET
           CALL EXIT
        ENDIF
C      ELSE      ! obsolete SAVE card
C        LREC = LRECL
C        IF (FMT .NE. 'EPIO') LREC = LRECL/2
C        CALL BUNIT (LWRT,FMT,LREC)
      ENDIF
C
C - Fill RUNR, RUNH and KRUN banks with default values
C
      IRUNR = ALRUNR (IEXP,IRUN)
      IF (IRUNR .LE. 0) THEN
C     error in filling RUNR bank - STOP
        WRITE (IW(6),'(/1X,''not enough space for RUNR - STOP'')')
        CALL EXIT
      ENDIF
      IRUNH = ALRUNH (IRUN,IEXP,IRTYP)
      IF (IRUNH .LE. 0) THEN
C     error in filling RUNH bank - STOP
        WRITE (IW(6),'(/1X,''not enough space for RUNH - STOP'')')
        CALL EXIT
      ENDIF
      AMAR = AMARSET(0)
      IKRUN = ALKRUN (IUCOD,NOTRK,TITLE)
      IF (IKRUN .LE. 0) THEN
C     error in filling KRUN bank - STOP
        WRITE (IW(6),'(/1X,''not enough space for KRUN - STOP'')')
        CALL EXIT
      ENDIF
      IKJOB = ALKJOB (IVERS,IDATE)
      IF (IKJOB .LE. 0) THEN
C     error in filling KJOB bank - STOP
        WRITE (IW(6),'(/1X,''not enough space for KJOB - STOP'')')
        CALL EXIT
      ENDIF
C  Expand content of data card KREF if any
      IF ( JREF.GT.0 ) THEN
C         IF ( NREF1.NE. 0 ) CALL BCALLC(IW,'KREF',NREF0)
         CALL BCALLC(IW,'KREF',NREF)
         CALL KSWAP
      ENDIF
      GO TO 999
 2    CONTINUE
      JREF  = IW(NAMIND('NREF'))
      IF ( JREF.GT.0 ) THEN
C  Read now user's data cards for generator IN PRODUCTION Mode
C  otherwise nothing
         CALL BREADC
C  Expand content of data card KCAR if any
         CALL BCALLC(IW,'KCAR',0)
C  Clean up banks overwritten by user's cards
         CALL KCLEAN(IOK)
         IF (IOK.NE.0 ) GO TO 997
      ENDIF
      GOTO 999
C
    3 CONTINUE
      WRITE (IW(6),'(/1X,''too many entries in KINIT - STOP'')')
      CALL EXIT
C
 997     WRITE (IW(6),'(/1X,''error superseding reference set by user in
     $put...STOP'',I3)') IOK
         CALL EXIT
C     error in reading data base - STOP
 998     WRITE (IW(6),'(/1X,''error in reading data base - STOP'',
     &                      I3)') IREDB
         CALL EXIT
  999 RETURN
 100  FORMAT (/1X,'KINIT - accessing Data Base for KREF NR = ',I5)
      END
C#endif

      SUBROUTINE KXP6CO(LUPAR)
C -----------------------------------------------------------------
C - Modified for Pythia 6.1
C                           B.Bloch   - 980112
C - Modified November 2000 to allow usage of NREF cards : ie give
C   the proper offset to MDM1 cards concerned and proper KF code when
C   modified from verion 7.3x to 6.1y
C
C! Set LUND parameters by data cards
CKEY KINE KINGAL LUND7 DECAY  /  USER INTERNAL
C  Every PYTHIA parameter is a BOS data card keyword,the index of
C  the parameter is the bank number.
C
C  the list of keywords with their format is given below:
C
C 'MSTU'(I),'PARU'(F),'MSTJ'(I),'PARJ'(F),
C 'KCH1'(I),'KCH2'(I),'KCH3'(I),'KCH4'(I),
C 'PMA1'(F),'PMA2'(F),'PMA3'(F),'PMA4'(F),
C 'PARF'(F),'CHA1'(I),'CHA2'(I),
C 'MDC1'(I),'MDC2'(I),'MDC3'(I),'MDM1'(I),'MDM2'(I),'BRAT'(F),
C 'KFD1'(I),'KFD2'(I),'KFD3'(I),'KFD4'(I),'KFD5'(I),
C 'MSEL'(I),'MSUB'(I),'CKIN'(F),'MSTP'(I),'PARP'(F),
C 'MSTI'(I),'PARI'(F),'IMSS'(I),'RMSS'(F)
C
C
C    KEY  i  /  ival     ====>  KEY(i)=ival
C    RKEY i  /  value    ====>  RKEY(i)=value
C
C - structure: SUBROUTINE subprogram
C              User Entry Name: KXP6CO
C              External References: NAMIND/BKFMT/BLIST(BOS77)
C                                   KXP6BR (this Lib)
C              Comdecks referenced: BCS,LUNDCOM
C
C - usage    : CALL KXP6CO(LUPAR)
C - input    : LUPAR=No. of read data cards
C
C  Note that, if a particle mass(PMA1), width(PMA2) or life-time(PMA4)
C  is modified, the PART bank entry is changed accordingly.
C
C#ifndef DOC
C#include "pyt6com.h"
C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER PYK,PYCHGE,PYCOMP
C...Commonblocks.
      PARAMETER (L1MST=200, L1PAR=200)
      PARAMETER (L2PAR=500, L2PARF=2000 )
      PARAMETER (LJNPAR=4000)

      COMMON/PYJETS/N7LU,NPAD,K7LU(LJNPAR,5),P7LU(LJNPAR,5),
     $              V7LU(LJNPAR,5)
      COMMON/PYDAT1/MSTU(L1MST),PARU(L1PAR),MSTJ(L1MST),PARJ(L1PAR)
      COMMON/PYDAT2/KCHG(L2PAR,4),PMAS(L2PAR,4),PARF(L2PARF),VCKM(4,4)
      COMMON /PYDAT3/MDCY(L2PAR,3),MDME(LJNPAR,2),BRAT(LJNPAR),
     &               KFDP(LJNPAR,5)
      COMMON/PYDAT4/CHAF(L2PAR,2)
      CHARACTER CHAF*16
C
      COMMON/PYSUBS/MSEL,MSELPD,MSUB(500),KFIN(2,-40:40),CKIN(200)
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
      COMMON/PYINT1/MINT(400),VINT(400)
      COMMON/PYINT2/ISET(500),KFPR(500,2),COEF(500,20),ICOL(40,4,2)
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)
      COMMON/PYINT4/MWID(500),WIDS(500,5)
      COMMON/PYINT5/NGENPD,NGEN(0:500,3),XSEC(0:500,3)
      COMMON/PYINT6/PROC(0:500)
      CHARACTER PROC*28
      COMMON/PYMSSM/IMSS(0:99),RMSS(0:99)

      SAVE /PYJETS/
      SAVE /PYDAT1/,/PYDAT2/,/PYDAT3/,/PYDAT4/,/PYSUBS/,
     &/PYPARS/,/PYINT1/,/PYINT2/,/PYINT3/,/PYINT4/,/PYINT5/,
     &/PYINT6/,/PYMSSM/
C
C#include "bcs.h"
*CD bcs
      INTEGER LMHLEN, LMHCOL, LMHROW
      PARAMETER (LMHLEN=2, LMHCOL=1, LMHROW=2)
C
      COMMON /BCS/   IW(1000)
      INTEGER IW
      REAL RW(1000)
      EQUIVALENCE (RW(1),IW(1))
C
      LOGICAL LREF
      PARAMETER (JMIN=144,JMAX=191)    ! This is MDM(j,1) gamma,Z0,W+-
      LOGICAL OLDKF
      PARAMETER (KFOPSIP=30443 ,KFOUPSP=30553) ! new codes offset by 70000
C
      PARAMETER (LKEYS=35)
      CHARACTER*4 KEY(LKEYS),CHAINT
      CHARACTER*1 FMT(LKEYS)
      DATA KEY / 'MSTU','PARU','MSTJ','PARJ',
     &           'KCH1','KCH2','KCH3','KCH4',
     &           'PMA1','PMA2','PMA3','PMA4',
     &           'PARF',       'CHA1','CHA2',
     &           'MDC1','MDC2','MDC3','MDM1',
     &           'MDM2','BRAT','KFD1','KFD2',
     +           'KFD3','KFD4','KFD5','MSEL',
     $           'MSUB','CKIN','MSTP','PARP',
     &           'MSTI','PARI','IMSS','RMSS'/
      DATA FMT /'I','F','I','F',
     &          'I','I','I','I',
     &          'F','F','F','F',
     &          'I',    'I','I',
     &          'I','F','I','I',
     &          'I','I','I','I',
     &          'I','I','I','I',
     &          'I','F','I','I',
     &          'I','F','I','F'/
      DATA NAPAR/0/
      OLDKF(k) = (k.eq.KFOPSIP).or.(k.eq.KFOUPSP)
C --------------------------------------------------
      IF (NAPAR .EQ. 0) NAPAR = NAMIND ('PART')
      LUPAR=0
      iut = iw(6)
C look if NREF card was there
      LREF = IW(NAMIND('KREF')).GT.0
      WRITE(iut,1)
 1    FORMAT(//
     .20X,' YOU ARE RUNNING PYTHIA 6.1 INSIDE THE                 '//
     .20X,'     K I N G A L  - PACKAGE                            '//
     .20X,'      for commentS  SEND MAIL TO :                     '/
     .20X,'         Brigitte.BLOCH@cern.ch                        '//
     .20X,'                                                       '/
     .15X,'-------------------------------------------------------'///
     .20X,' You set up the following PYTHIA parameters            '//)
 2    FORMAT(20X,' KEY : ',A4,'  =  ',I8)
 3    FORMAT(20X,' KEY : ',A4,'  =  ',F8.4)
 4    FORMAT(20X,' KEY : ',A4,'(',I3,')  =  ',I8)
 5    FORMAT(20X,' KEY : ',A4,'(',I8,')  =  ',E10.4)
 6    FORMAT(20X,' KEY : ',A4,'(',I3,')  =  ',A4)
      DO 150 I=1,LKEYS
         NAMI=NAMIND(KEY(I))
         IF (IW(NAMI).EQ.0) GOTO 150
         KIND=NAMI+1
   15    KIND=IW(KIND-1)
         IF (KIND.EQ.0) GOTO 149
         LUPAR = LUPAR+1
         J = IW(KIND-2)
C Look for old psi' and Upsilon' codes
         ioff =0
         If (oldkf(j)) ioff = 70000
C NREF was there , offset if neccessary
         joff = 0
         IF (LREF.and.(j.ge.JMIN).and.(j.le.jmax)) joff =18
         GOTO (21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,
     +37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55) I
   21    MSTU(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MSTU(J)
       GOTO 15
   22    PARU(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,PARU(J)
       GOTO 15
   23    MSTJ(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MSTJ(J)
       GOTO 15
   24    PARJ(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,PARJ(J)
       GOTO 15
   25    KC = PYCOMP(J)
         KCHG(KC,1) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KCHG(KC,1)
       GOTO 15
   26    KC = PYCOMP(J)
         KCHG(KC,2) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KCHG(KC,2)
       GOTO 15
   27    KC = PYCOMP(J)
         KCHG(KC,3) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KCHG(KC,3)
       GOTO  15
   28    KC = PYCOMP(J)
         KCHG(KC,4) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KCHG(KC,4)
       GOTO  15
   29    KC = PYCOMP(J+ioff)
         PMAS(KC,1) = RW(KIND+1)
         IOF = 6
         WRITE(iut,5)KEY(I),J+ioff,PMAS(KC,1)
       GOTO 115
   30    KC = PYCOMP(J+ioff)
         PMAS(KC,2) = RW(KIND+1)
         IOF = 9
         WRITE(iut,5)KEY(I),J+ioff,PMAS(KC,2)
       GOTO 115
   31    KC = PYCOMP(J+ioff)
         PMAS(KC,3) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J+ioff,PMAS(KC,3)
       GOTO 15
   32    KC = PYCOMP(J+ioff)
         PMAS(KC,4) = RW(KIND+1)/3.33E-12
         IOF = 8
         WRITE(iut,5)KEY(I),J+ioff,PMAS(KC,4)
       GOTO 115
   33    PARF(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,PARF(j)
       GOTO 15
   34    KC = PYCOMP(J)
         CHAF(KC,1) = CHAINT(IW(KIND+1))
         WRITE(iut,6)KEY(I),J,CHAF(KC,1)
       GOTO 15
   35    KC = PYCOMP(J)
         CHAF(KC,2) = CHAINT(IW(KIND+1))
         WRITE(iut,6)KEY(I),J,CHAF(KC,2)
       GOTO 15
   36    KC = PYCOMP(J)
         MDCY(KC,1) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MDCY(KC,1)
       GOTO 15
   37    KC = PYCOMP(J)
         MDCY(KC,2) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MDCY(KC,2)
       GOTO 15
   38    KC = PYCOMP(J)
         MDCY(KC,3) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MDCY(KC,3)
       GOTO 15
   39    MDME(J+joff,1) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J+joff,MDME(J+joff,1)
       GOTO 15
   40    MDME(J+joff,2) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J+joff,MDME(J+off,2)
       GOTO 15
   41    BRAT(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,BRAT(j)
       GOTO 15
   42    KFDP(J,1) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KFDP(j,1)
       GOTO 15
   43    KFDP(J,2) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KFDP(j,2)
       GOTO 15
   44    KFDP(J,3) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KFDP(j,3)
       GOTO 15
   45    KFDP(J,4) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KFDP(j,4)
       GOTO 15
   46    KFDP(J,5) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,KFDP(j,5)
       GOTO 15
   47    MSEL = IW(KIND+1)
         WRITE(iut,2)KEY(I),MSEL
       GOTO 15
   48    MSUB(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MSUB(J)
       GOTO 15
   49    CKIN(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,CKIN(J)
       GOTO 15
   50    MSTP(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MSTP(J)
       GOTO 15
   51    PARP(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,PARP(J)
       GOTO 15
   52    MSTI(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,MSTI(J)
       GOTO 15
   53    PARI(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,PARI(J)
       GOTO 15
   54    IMSS(J) = IW(KIND+1)
         WRITE(iut,4)KEY(I),J,IMSS(J)
       GOTO 15
   55    RMSS(J) = RW(KIND+1)
         WRITE(iut,5)KEY(I),J,RMSS(J)
       GOTO 15
 149  CONTINUE
         CALL BKFMT (KEY(I),FMT(I))
         CALL BLIST (IW,'C+',KEY(I))
       GOTO 150
 115  CONTINUE
      IPART = KGPART(J)
      JPART = IW(NAPAR)
      IF (IPART.GT.0) THEN
        RW(JPART+LMHLEN+(IPART-1)*IW(JPART+1)+IOF)= RW(KIND+1)
        IANTI = IW(JPART+LMHLEN+(IPART-1)*IW(JPART+1)+10)
        IF (IANTI.NE.IPART) RW(JPART+LMHLEN+(IANTI-1)*IW(JPART+1)+IOF)=
     $                      RW(KIND+1)
      ENDIF
      GOTO 15
 150  CONTINUE
      WRITE(iut,7)
 7    FORMAT(/,/,15X,
     .'--------------------------------------------------------'//)

C
C      Look for more modifications of decay parameters
C
      CALL KXP6BR
      RETURN
      END
C#endif
      SUBROUTINE KXP6BR
C------------------------------------------------------------------
C          B.Bloch-Devaux -980112
C! Modify decay scheme inside PYTHIA 6.1 for requested particles
CKEY KINE KINGAL LUND7 DECAY  /  INTERNAL
C  Bos data cards are used with the following convention:
C  GADM : define new decay channel for given particle in LUND
C  GRPL : replace a final state by another one
C  GMOB : defines the branching ratios of a LUND particle
C
C  GADM KF MXEL KDP1 KDP2 KDP3 KDP4  KDP5
C       KF Refers to the Lund7 particle code
C       MXEL is the matrix element to be used for that decay
C       KDP1-KDP5 Refer to the lund7 code of the 5 particles final state
C        to be added at the end of the list of decay modes.
C       (if less than 5 particles needed, fill others with 0  )
C        include matrix element code in MXEL, if MXEL=101  5 more
C        positions can be filled for the same decay chain
C  GRPL KF  II  MSWI  MXEL KDP1 KDP2 KDP3 KDP4  KDP5
C       KF Refers to the Lund particle code
C       II Refers to the decay mode number in the list for particle KF
C       MSWI is the switch to be used for that decay ( 0,-1,1,....5)
C       MXEL is the matrix element to be used for that decay
C       KDP1-KDP5 Refer to the lund code of the 5 particles final state
C       (if less than 5 particles needed, fill others with 0  )
C  GMOB KF  BR(1)..................BR(n)
C       KF Refers to the Lund particle code
C       BR(1)...BR(n) are the non-cumulated branching fractions
C       of the n decay modes defined for particle KF
C
C  you may have as many GADM as you want as long as you do not overfill
C  the PYDAT3 array (dimension 2000)otherwise an error message is issued
C  and the process is stopped.
C  NOTE: all GADM cards with the same KF must follow each other !!
C ------
C  GRPL cards are treated in sequence as they appear.
C  GMOB cards should define as many Branching fractions as decay modes
C  including those added through GADM cards.If not, a message is issued
C  and no modification is done.When modified a printout of the resulting
C  decay modes and branching ratios for the particle is issued.
C
C - Modified B.Bloch November 2000 : to allow usage of NREF cards ...
C   one must chcek the KF codes which have change ( mainly Psi' and Upsilon '
C   from 30443/30553 to 100443/100553)
C
C - structure : SUBROUTINE
C               User entry name :KXP6BR
C               External references:NAMIND/BKFMT/BLIST(BOS77)
C                                   KXP6ST( this library)
C                                   PYCOMP(Pythia 6.1)
C               Comdecks refenced :BCS,LUN7COM
C
C - usage : CALL KXP6BR
C------------------------------------------------------------------
C#ifndef DOC
C#include "pyt6com.h"
C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER PYK,PYCHGE,PYCOMP
C...Commonblocks.
      PARAMETER (L1MST=200, L1PAR=200)
      PARAMETER (L2PAR=500, L2PARF=2000 )
      PARAMETER (LJNPAR=4000)

      COMMON/PYJETS/N7LU,NPAD,K7LU(LJNPAR,5),P7LU(LJNPAR,5),
     $              V7LU(LJNPAR,5)
      COMMON/PYDAT1/MSTU(L1MST),PARU(L1PAR),MSTJ(L1MST),PARJ(L1PAR)
      COMMON/PYDAT2/KCHG(L2PAR,4),PMAS(L2PAR,4),PARF(L2PARF),VCKM(4,4)
      COMMON /PYDAT3/MDCY(L2PAR,3),MDME(LJNPAR,2),BRAT(LJNPAR),
     &               KFDP(LJNPAR,5)
      COMMON/PYDAT4/CHAF(L2PAR,2)
      CHARACTER CHAF*16
C
      COMMON/PYSUBS/MSEL,MSELPD,MSUB(500),KFIN(2,-40:40),CKIN(200)
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
      COMMON/PYINT1/MINT(400),VINT(400)
      COMMON/PYINT2/ISET(500),KFPR(500,2),COEF(500,20),ICOL(40,4,2)
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)
      COMMON/PYINT4/MWID(500),WIDS(500,5)
      COMMON/PYINT5/NGENPD,NGEN(0:500,3),XSEC(0:500,3)
      COMMON/PYINT6/PROC(0:500)
      CHARACTER PROC*28
      COMMON/PYMSSM/IMSS(0:99),RMSS(0:99)

      SAVE /PYJETS/
      SAVE /PYDAT1/,/PYDAT2/,/PYDAT3/,/PYDAT4/,/PYSUBS/,
     &/PYPARS/,/PYINT1/,/PYINT2/,/PYINT3/,/PYINT4/,/PYINT5/,
     &/PYINT6/,/PYMSSM/
C
C#include "bcs.h"
*CD bcs
      INTEGER LMHLEN, LMHCOL, LMHROW
      PARAMETER (LMHLEN=2, LMHCOL=1, LMHROW=2)
C
      COMMON /BCS/   IW(1000)
      INTEGER IW
      REAL RW(1000)
      EQUIVALENCE (RW(1),IW(1))
C
      LOGICAL OLDKF
      PARAMETER (KFOPSIP=30443 ,KFOUPSP=30553) ! new codes offset by 70000
      OLDKF(k) = (k.eq.KFOPSIP).or.(k.eq.KFOUPSP)
C ----------------------------------------------------------------
      DATA NKF0/-1/
      NAMI =NAMIND('GADM')
      IF (IW(NAMI ).EQ.0) GO TO 96
      JGADM=NAMI +1
 100  JGADM=IW(JGADM-1)
      IF(JGADM.EQ.0) GOTO 97
C
C Create a new line in the original LUND particle data table
C for the particule NKF1 after copying the existing ones at the end of
C the array
C
      NKF1=IW(JGADM+1)
C look for changes
      INKF = NKF1
      ioff =0
      If (oldkf(inkf)) ioff = 70000
      nkf1 = nkf1+ioff
C  get compressed code  for particle
      KC = PYCOMP(NKF1)
      IF ( KC.GT.0) THEN
         NOLD = MDCY(KC,3)
C  Find a new free location to translate the decay tables
         IF (NKF1.NE.NKF0) THEN
            NKF0 = NKF1
            DO 200 K=LJNPAR,1,-1
            DO 300 J = 1,5
               IF(KFDP(K,J).NE.0 )GO TO 400
  300       CONTINUE
  200       CONTINUE
            GO TO 1000
  400       IFREE = K+1
C   copy old modes to the new location
            IOLD = MDCY(KC,2)
            IF(NOLD.GT.0 .AND. IOLD.GT.0) THEN
               DO 401 J=1,NOLD
                  BRAT(IFREE+J-1)=BRAT(IOLD+J-1)
                  MDME(IFREE+J-1,1)=MDME(IOLD+J-1,1)
                  MDME(IFREE+J-1,2)=MDME(IOLD+J-1,2)
                  DO 402 K=1,5
                     KFDP(IFREE+J-1,K)=KFDP(IOLD+J-1,K)
  402             CONTINUE
  401          CONTINUE
            ENDIF
C   Update with new mode
            MDCY(KC,1) = 1
            MDCY(KC,2) = IFREE
         ENDIF
         MDCY(KC,3) = NOLD+1
C
C define the final state of the new entry
C
         MDME(IFREE+NOLD,1)= 1
         MDME(IFREE+NOLD,2)= IW(JGADM+2)
         DO J = 1,5
C look for changes
            INKF = IW(JGADM+2+J)
            ioff =0
            If (oldkf(inkf)) ioff = 70000
            IW(JGADM+2+J) = IW(JGADM+2+J) +ioff
C
            KFDP(IFREE+NOLD,J)= IW(JGADM+2+J)
          ENDDO
C         KFDP(IFREE+NOLD,2)= IW(JGADM+4)
C         KFDP(IFREE+NOLD,3)= IW(JGADM+5)
C         KFDP(IFREE+NOLD,4)= IW(JGADM+6)
C         KFDP(IFREE+NOLD,5)= IW(JGADM+7)
         MSTU(20) = 0
      ENDIF
      GOTO 100
 97   CONTINUE
C store the card on the C list
      CALL BKFMT('GADM','I')
      CALL BLIST(IW,'C+','GADM')
  96  CONTINUE
      NAMI =NAMIND('GRPL')
      IF (IW(NAMI ).EQ.0) GO TO 94
      JGRPL=NAMI +1
C
C Replace decay mode by a new definition
C
 102  JGRPL=IW(JGRPL-1)
      IF(JGRPL.EQ.0)GOTO 99
      NKF3=IW(JGRPL+1)
C look for changes
      INKF = NKF3
      ioff =0
      If (oldkf(inkf)) ioff = 70000
      nkf3 = nkf3 + ioff
C  get compressed code  for particle
      KC = PYCOMP(NKF3)
      IF ( KC.GT.0) THEN
        NBR = MDCY(KC,3)
        IK = IW(JGRPL+2)
        IF ( IK .GT. NBR) THEN
          IF (IW(6).GT.0) WRITE(IW(6),1001) IK,NBR
 1001       FORMAT('===KXP6BR ====you try to modify a non existant',
     $       ' line',I8,' maximum is ',I10)
          GO TO 102
        ENDIF
        IENTRY = MDCY(KC,2)+IK-1
C
C replace final state IK by another one for the particle NKF3
C
        MDME(IENTRY,1) = IW(JGRPL+3)
        MDME(IENTRY,2) = IW(JGRPL+4)
        DO 110 J= 1,5
C look for changes
          INKF = IW(JGRPL+4+J)
          ioff =0
          If (oldkf(inkf)) ioff = 70000
          IW(JGRPL+4+J) = IW(JGRPL+4+J) + ioff
          KFDP(IENTRY,J)=IW(JGRPL+4+J)
 110    CONTINUE
      ENDIF
      GOTO 102
   99 CONTINUE
C store the card on the C list
      CALL BKFMT('GRPL','I')
      CALL BLIST(IW,'C+','GRPL')
  94  CONTINUE
C
C  Update the individual branching ratios
C
      NAMI =NAMIND('GMOB')
      IF (IW(NAMI ).EQ.0) GO TO 95
      JGMOB=NAMI +1
 101  JGMOB=IW(JGMOB-1)
      IF(JGMOB.EQ.0)GOTO 98
C define the branching ratios of the particle NKF2
      NKF2=IW(JGMOB+1)
C look for changes
      INKF = NKF2
      ioff =0
      If (oldkf(inkf)) ioff = 70000
      nkf2 = nkf2+ioff
C  get compressed code  for particle
      KC = PYCOMP(NKF2)
      IF ( KC.GT.0) THEN
        NBR = MDCY(KC,3)
        IF ( NBR .NE. IW(JGMOB)-1) THEN
          IF (IW(6).GT.0) WRITE(IW(6),1002) NFK2,NBR
 1002        FORMAT('===KXP6BR ==== BR numbers do not agree for',
     $           ' part ',I8,' should be ',I10)
          GO TO 101
        ENDIF
        IENTRY = MDCY(KC,2)
        DO 500 JJ=1,NBR
            BRAT(IENTRY+JJ-1)=RW(JGMOB+1+JJ)
 500    CONTINUE
        CALL KXP6ST(NKF2)
      ENDIF
      GOTO 101
 98   CONTINUE
C store the card on the C list
      CALL BKFMT('GMOB','I,(F)')
      CALL BLIST(IW,'C+','GMOB')
  95  CONTINUE
      RETURN
 1000 IF (IW(6).GT.0) WRITE (IW(6),550) NKF1,K
  550 FORMAT(1X,'++++++KXP6BR+++++++ cannot extend decay list for',
     $ ' particle',I10,'Pointer MDCE was',I10)
      END
C#endif
