C----------------------------------------------------------------------
C    Modifications : B.Bloch/F.Martin Dec 1999
C  0-  on Vax/VMS need /extend in the compiler
C  1-  include statements should use ' not " ( GPS.h)
C  2-  PseuMar_MakeVec/PseuMar_Initialize/PseuMar_Out now calling
C      RANMAR         /RMARIN            /RMARUT
C      original routines renamed to OPseu......
C  3-  YFSini2_Make : vmax is undefined
C  4-  QED3_Make    : disi11 is undefined
C  5-  Hepevt_fill  : interface to jetset reviewed
C      Hepevt_getphotbst
C      Hepevt_getphotfin
C      Hepevt_getphotini
C      Hepevt_hadronize
C----------------------------------------------------------------------
      SUBROUTINE KK2F_DEFAULT(XPAR)
       INTEGER    IMAX
       PARAMETER (IMAX = 10000)               ! length ox xpar
       REAL*8       XPAR(IMAX)
********************************************************************************
********************************************************************************
**                                                                            **
**                   DEAFAULT INPUT DATA for KK Monte Carlo                   **
**                  >>>>> Never edit this file directly <<<<<                 **
**            Your actual input data should be in a separate file.            **
**            The defaults will then be overwriten,  if necessary.            **
**                                                                            **
**                           !!!!IMPORTANT!!!!                                **
** The data marked with  \\\\\\ are for special tests or dip-switches tuning  **
** the Monte Carlo integrations, they SHOULD BE NEVER CHANGED by the user,    **
** without consulting the author of the program.                              **
** Changing them may lead to nonsense  results.                               **
**                                                                            **
********************************************************************************
********************************************************************************
*     Generalities of the Monte-Carlo (low level)
*indx_____data______ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
*     Center-of-mass energy [GeV]
      XPAR(1) =  100.0D0  !cmsene =xpar( 1) Average Center of mass energy [GeV]
      XPAR(2) =  0.000D0  !DelEne =xpar( 2)  Beam energy spread [GeV]
      XPAR(3) =  5        !ninp   =xpar( 5)  Input  unit number (not used)
      XPAR(4) =  6        !nout   =xpar( 6)  Output unit number
*     PrintOut from generator
      XPAR(5) =  0        !LevPri =xpar( 5)  PrintOut Level 0,1,2
      XPAR(6) =  1        !Ie1Pri =xpar( 6)  PrintOut Start point
      XPAR(7) =  1        !Ie2Pri =xpar( 7)  PrintOut End   point
*     At present all internal monitoring fits into (idyfs+1,idyfs+100)
      XPAR(8) =  600      !\\\\\\IdYFS\\\\\\\\\\\\\pointer for internal histos\\\\\\\\\
*indx______data_____ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
      XPAR(9) =  1.0d0    !WtMax =xpar( 9)   Maximum weight for rejection
*     KeyWgt=0 we get constant and for KeyWgt=1 variable weight events
      XPAR(10) =  0        !KeyWgt=xpar(10) Deafault is 0
*     IdeWgt IDENT of the EEX principal weight, not for CEEX! NEVER TOUCH IT!
      XPAR(11) =  74       !\\\\\\IdeWgt\\\\\\\\\\Deafault is 74, for O(alf3) M.E.\\\\\\
*     KeyELW=0,1 Type of Elewctroweak corrections, KeyElw=0 only for tests
      XPAR(12) = 1         !KeyELW=xpar(12) Deafault is 1, for Dizet
*     Minimum and maximum v, where v = 1-sprim/s, v=1 alowed
      XPAR(16) =  1D-5     !vvmin =xpar(16)  may  be put to  vvmin < 1d-5
** IMPORTANT: vmax is the cut on v=1-s'/s where s' is not the mass^2 of the 
** final state ffbar mass^2 but of the virtual object after ISR emission,
** and before FSR emission. It is obviously unphysical cut due to ISR*FSR interf.
      XPAR(17) =  1D0       !vvmax =xpar(17) if 1d0 then reduced inside program
      XPAR(18) =  1d-3      !\\\\\\delfac\\\\\\\\\\\FSR cut eps=vvmin*delfac\\\\\\\\\\\\\
      XPAR(19) =  100       !\\\\\\hard-wired maximum photon multiplicity\\\\\\\\\\\\\\\\
********************************************************************************
**    EQD/EW bremsstrahlung flags/data
      XPAR(20) =  1         !KeyISR=xpar(20)  Default is  1, for beams |<<<<|
      XPAR(21) =  1         !KeyFSR=xpar(21)  Default is  1, for all final fermions
*indx_____data______ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
**\\\\KeyPia = 0, NO   removal of FSR photons below emin=Ene*delta in CMS\\\\\\\
**\\\\KeyPia = 1, WITH removal of FSR photons below emin=Ene*delta in CMS\\\\\\\
      XPAR(22) =  1         !\\\\\\KeyPia\\\\\\\\\\\Default is  1\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\SPECIAL tests: fixed ISR multiplicity\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(23) =  0         !\\\\\\mltISR\\\\\\\\\\\Default is  0\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\SPECIAL tests: fixed FSR multiplicity\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(24) =  0         !\\\\\\mltFSR\\\\\\\\\\\Default is  0\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\SPECIAL tests: fixed v=vmax\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(25) =  0         !KeyFix Type of ISR, =0,1ormal, =2 beamsstrahlung
*(\\\\SPECIAL tests: mass terms in crude MC photon distrib.\\\\\\\\\\\\\\\\\\\\\
      XPAR(26) =  0         !\\\\\\KeyWtm\\\\\\\\\\ Default is  0\\\\\\\\\\\\\\\\\\\\\\\\
**    Interference ISR/FSR to be ON/OFF
      XPAR(27) =  2         !KeyINT=xpar(27)  Default is  2
**    New exponentiation CEEX is now default, at least for leptons, see vmaxGPS
**    which overrules KeyGPS for each type of final fermion
      XPAR(28) =  1         !KeyGPS=xpar(28)  Default is  1
**    Photon emission from final QUARKS
      XPAR(29) =  1         !KeyQSR=xpar(29)  Default is  1
**    Coupling constants etc.
      XPAR(30) =  137.0359895d0      !alfinv=xpar(30)  Inverse of alpha_QED
      XPAR(31) =  389.37966d3        !gnanob=xpar(31)  GeV^(-2)  --> NanoBarn conversion
      XPAR(32) =  1.16639d-5         !Gfermi=xpar(32)  Fermi coupling ( 1.16639d-5  [GeV^(-2)])
********************************************************************************
**     Technical cuts and internal parameters
**\\\\\\\\\\\\\\\Enhancement factor for Crude photon multiplicity\\\\\\\\\\\\\\\
      XPAR(40) =  1.25d0    !\\\\\\Xenph =xpar(40)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(41) =  1.d-9     !vcut1 =xpar(41)\\Techn.cut: \\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(42) =  5.d-2     !vcut2 =xpar(42)\\Techn.cut: \\\\\\\\\\\\\\\\\\\\\\\\\\
      XPAR(43) =  0d0       !vcut3 =xpar(43)\\Techn.cut: unused\\\\\\\\\\\\\\\\\\\\
********************************************************************************
**     QCD flags/data
**     Hardonization/showering flag, KeyHad=0,1 => hadronization OFF,ON.
      XPAR(50) =  1         !KeyHad=xpar(50)  Default is  1
**     Minimum mass [GeV] for hadronization/showering
      XPAR(51) =  0.200d0   !HadMin=xpar(51)
**
      XPAR(52) =  0.118d0   !alfQCD=xpar(52)  alpha_QCD
********************************************************************************
** Note that for beam polariz. being active the CEEX has to be ON, see vmaxGPS and KeyGPS
** Beam polarization may require adjustment of WtWax, check overweighted events in output
      XPAR(61) =  0d0      !spin1x  polarization vector beam 1
      XPAR(62) =  0d0      !spin1y  polarization vector beam 1
      XPAR(63) =  0d0      !spin1z  polarization vector beam 1
      XPAR(64) =  0d0      !spin1x  polarization vector beam 2
      XPAR(65) =  0d0      !spin1y  polarization vector beam 2
      XPAR(66) =  0d0      !spin1z  polarization vector beam 2
********************************************************************************
* Beamstrahlung parameters for Thorsten Ohl's package CIRCE 
      XPAR(71) =  350d0    !IRCroots   sqrt(s) [GeV] discrete values 350,500,800GeV
      XPAR(72) =  3d0      !IRCacc     
      XPAR(73) =  5d0      !IRCver     version
      XPAR(74) =  19980505d0      !IRCdat     date
      XPAR(75) =  1d0             !IRCxchat   printout level
**\\\\\writing vegas grid on the disk, KeyGrid=-1 create and dump, =+1 read\\\\\
      XPAR(76) =  0d0             !KeyGrid=0 create, not read, default\\\\\\\\\\\\\\\\\\\\\\\
********************************************************************************
*indx_____data______ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
**     Define process
**     Beam flavour code
      XPAR(400) = 11       !KFini = xpar(400) dont change it                |<<<<|
**     LIST of Final state flavours to be generated randomly according
**     to QED corrected x-sections, at least one line/item should be present.
**     (Remember that electron has incomplete M.E. and top might be too heavy.)
*  401              1      KFfin, d
*  402              1      KFfin, u
*  403              1      KFfin, s
*  404              1      KFfin, c
*  405              1      KFfin, b
***406              1      KFfin, t quark !!! do not use it!!!!
*  411              1      KFfin, electron
*  412              1      KFfin, neutrino electron
*  413              1      KFfin, muon
*  414              1      KFfin, neutrino muon
*  415              1      KFfin, tau
*  414              1      KFfin, neutrino tau
********************************************************************************
**                   Input for matrix element
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
**\\\\\KeyZet = 0, pure QED\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\\KeyZet = 1, Z-boson and gamma are ON\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\\KeyZet =-1, Z width Gamma is constant (only for CEEX)\\\\\\\\\\\\\\\\\\\\
**\\\\\KeyZet = 9, pure Z exchange\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
**\\\\\KeyZet =-2, Artificial constant x-section for SPECIAL test runs\\\\\\\\\\
      XPAR(501) = 1          !\\\\\\KeyZet=xpar(501)  default is 1\\\\\\\\\
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
** Mass and width of Z-boson [GeV]
      XPAR(502) =  91.187D0     !amaz  =xpar(502)  PDG 1996
**     sin(thetaW)**2 where thetaW is electroweak mixing angle
      XPAR(503) =  .22276773D0  !swsq  =xpar(503) sin_squared of EW angle, from Dizet
      XPAR(504) =  2.50072032D0 !gammz =xpar(504) Z width, from Dizet
      XPAR(505) =  100D0        !amh   =xpar(505) Higgs mass, input for Dizet
      XPAR(506) =  175D0        !amtop =xpar(506) Top mass,   input for Dizet
      XPAR(510) =  1D-60        !MasPhot=xpar(510) photon mass, IR regulator 
********************************************************************************
**     PROPERTIES of Quarks and Leptons
**     i-th position  in xpar(i) according to i = 500+10*KFlavour +j
****** d-quark
      XPAR(511) =  1         !KFlavour
      XPAR(512) =  3         !NColor
      XPAR(513) = -1         !3*Q   =3*charge
      XPAR(514) = -1         !2*T3L =2*Isospin for Left component
      XPAR(515) =  0         !2*helicity, 0 for unpolarized
      XPAR(516) =  0.010d0   !mass [GeV] (5-15MeV in PDG)
      XPAR(516) =  0.100d0   !Constituent mass, for comparison with KoralZ !!!
      XPAR(517) =  5.0d0     !WtMax Maximum weight for rejection d-quark
      XPAR(518) =  0.99d0    !auxiliary parameter vmaxGPS d-quark
****** u-quark
      XPAR(521) =  2         !KFlavour
      XPAR(522) =  3         !NColor
      XPAR(523) =  2         !3*Q   =3*charge
      XPAR(524) =  1         !2*T3L =2*Isospin for Left component
      XPAR(525) =  0         !2*helicity, 0 for unpolarized
      XPAR(526) =  0.005d0   !mass [GeV] (2-8MeV in PDG)
      XPAR(526) =  0.100d0   !Constituent mass, for comparison with KoralZ !!!!
      XPAR(527) =  5.0d0     !WtMax Maximum weight for rejection u-quark
      XPAR(528) =  0.99d0    !auxiliary parameter vmaxGPS u-quark
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
****** s-quark
      XPAR(531) =  3         !KFlavour
      XPAR(532) =  3         !NColor
      XPAR(533) = -1         !3*Q   =3*charge
      XPAR(534) = -1         !2*T3L =2*Isospin for Left component
      XPAR(535) =  0         !2*helicity, 0 for unpolarized
      XPAR(536) =  0.200d0   !mass [GeV] (100-300MeV in PDG)
      XPAR(537) =  5.0d0     !WtMax Maximum weight for rejection s-quark
      XPAR(538) =  0.99d0    !auxiliary parameter vmaxGPS s-quark
****** c-quark
      XPAR(541) =  4         !KFlavour
      XPAR(542) =  3         !NColor
      XPAR(543) =  2         !3*Q   =3*charge
      XPAR(544) =  1         !2*T3L =2*Isospin for Left component
      XPAR(545) =  0         !2*helicity, 0 for unpolarized
      XPAR(546) =  1.300d0   !mass [GeV] (1.0-1.6 GeV in PDG)
      XPAR(547) =  5.0d0     !WtMax Maximum weight for rejection c-quark
      XPAR(548) =  0.99d0    !auxiliary parameter vmaxGPS c-quark
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
****** b-quark
      XPAR(551) =  5         !KFlavour
      XPAR(552) =  3         !NColor
      XPAR(553) = -1         !3*Q   =3*charge
      XPAR(554) = -1         !2*T3L =2*Isospin for Left component
      XPAR(555) =  0         !2*helicity, 0 for unpolarized
      XPAR(556) =  4.200d0   !mass [GeV] (4.1-4.5 GeV in PDG)
      XPAR(556) =  4.500d0   !for comparison with KoarlZ
      XPAR(557) =  5.0d0     !WtMax Maximum weight for rejection b-quark
      XPAR(558) =  0.99d0    !auxiliary parameter vmaxGPS b-quark
****** t-quark
      XPAR(561) =  6         !KFlavour
      XPAR(562) =  3         !NColor
      XPAR(563) =  2         !3*Q   =3*charge
      XPAR(564) =  1         !2*T3L =2*Isospin for Left component
      XPAR(565) =  0         !2*helicity, 0 for unpolarized
      XPAR(566) =  175.0d0   !mass [GeV] (170-190GeV in PDG)
      XPAR(567) =  5.0d0     !WtMax Maximum weight for rejection t-quark
      XPAR(568) =  0.99d0    !auxiliary parameter vmaxGPS t-quark
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
****** electron
      XPAR(611) =  11           !KFlavour
      XPAR(612) =  1            !NColor
      XPAR(613) = -3            !3*Q   =3*charge
      XPAR(614) = -1            !2*T3L =2*Isospin for Left component
      XPAR(615) =  0            !2*helicity
      XPAR(616) =  0.510999d-3  !mass [GeV]   (0.51099907 MeV)
      XPAR(617) =  8.0d0        !WtMax Maximum weight for rejection electron
      XPAR(618) =  0.99d0       !auxiliary parameter vmaxGPS
****** neutrino electron
      XPAR(621) =  12   !KFlavour
      XPAR(622) =  1    !NColor
      XPAR(623) =  0    !3*Q   =3*charge
      XPAR(624) =  1    !2*T3L =2*Isospin for Left component
      XPAR(625) =  0    !2*helicity
      XPAR(626) = 1d-30 !mass [GeV]
      XPAR(627) = 3.5d0 !WtMax Maximum weight for rejection neutrino electron
      XPAR(628) = 0.0d0 !auxiliary parameter vmaxGPS
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
****** muon
      XPAR(631) =  13          !KFlavour
      XPAR(632) =  1           !NColor
      XPAR(633) = -3           !3*Q   =3*charge
      XPAR(634) = -1           !2*T3L =2*Isospin for Left component
      XPAR(635) =  0           !2*helicity
      XPAR(636) =  0.1056583d0 !mass [GeV]   (0.1056583 GeV)
      XPAR(637) =  8.0d0       !WtMax Maximum weight for rejection muon
      XPAR(638) =  0.999d0     !auxiliary parameter vmaxGPS, CEEX up to a point
****** neutrino muon
      XPAR(641) =  14        !KFlavour
      XPAR(642) =  1         !NColor
      XPAR(643) =  0         !3*Q   =3*charge
      XPAR(644) =  1         !2*T3L =2*Isospin for Left component
      XPAR(645) =  0         !2*helicity
      XPAR(646) =  1d-30     !mass [GeV]
      XPAR(647) =  3.5d0     !WtMax Maximum weight for rejection neutrino muon
      XPAR(648) =  0.0d0     !auxiliary parameter vmaxGPS
*indx_______________ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0ccccccccc0
****** tau
      XPAR(651) =  15        !KFlavour
      XPAR(652) =  1         !NColor
      XPAR(653) = -3         !3*Q   =3*charge
      XPAR(654) = -1         !2*T3L =2*Isospin for Left component
      XPAR(655) =  0         !2*helicity
      XPAR(656) =  1.777d0   !mass [GeV]   (1.777 GeV)
      XPAR(657) =  8.0d0     !WtMax Maximum weight for rejection tau
      XPAR(658) =  1.0d0     !auxiliary parameter vmaxGPS, CEEX always on
****** neutrino tau
      XPAR(661) =  16        !KFlavour
      XPAR(662) =  1         !NColor
      XPAR(663) =  0         !3*Q   =3*charge
      XPAR(664) =  1         !2*T3L =2*Isospin for Left component
      XPAR(665) =  0         !2*helicity
      XPAR(666) =  1d-30     ! mass [GeV]
      XPAR(667) =  3.5d0     ! WtMax Maximum weight for rejection neutrino tau
      XPAR(668) =  0.0d0     ! auxiliary parameter vmaxGPS
********************************************************************************
*****                                                                       ****
*****                Entries 2000-2999 reserved for Tauola                  ****
*****                                                                       ****
********************************************************************************
**  Jak=-1       No decay
**  Jak=0        Inclusive, 1.e. Jak=1,2,3,4,5,6,7,8...
**  Jak=1,2,3    electron,mu,pi  decays
**  Jak=4,5,6,7  rho,a1,K,K*     decays
**  Jak=8...     see list of branchings below
      XPAR(2001) =  0d0     !Jak1   =xpar(71)  First  Tau decay mask
      XPAR(2002) =  0d0     !Jak2   =xpar(72)  Second Tau decay mask
      XPAR(2003) =  15d0    !idff   =xpar(72)  PDG ident of the first tau
      XPAR(2004) =  1d0     !itdkRC =xpar(74) QED rad.switch in leptonic decays
      XPAR(2005) =  0.001d0 !xk0dec =xpar(75) IR-cut for QED rad. in leptonic decays
      XPAR(2006) =  1d0     !KeyA1  =xpar(76)  Type of a1 current
      XPAR(2007) =  0.975d0 !\\\\\\Cosine of  Cabibo angle, dont change it\\\\\
      XPAR(2008) =  1d0     !GV in tau decay
      XPAR(2009) =  -1d0    !GA in tau decay
**  Coefficients to fix ratio of:
**    BRA1  -- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
**    BRKS  -- PROBABILITY OF K0 TO BE KS
**    BRK0  -- PROBABILITY OF K0B TO BE KS
**    BRK0B -- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
**  All coefficents should be in the range (0.0,1.0)
**  They meaning is probability of the first choice only if one
**  neglects mass-phase space effects
      XPAR(2010) =  0.5d0    !BRA1 in 3 pion tau dec. BR of PI+PI-PI- (vs PI-PI0PI0
      XPAR(2011) =  0.6667d0 !BRKS   in K* tau dec. BR of BR of K+PI0 (vs PI+K0
      XPAR(2012) =  0.5d0    !BRK0   Probability of K0 to be KS
      XPAR(2013) =  0.5d0    !BRK0B  Probability of K0B to be KS
**  Tau branching ratios for selection of decay chanel in MC series.
**  Data below are from PDG July 1998. 
**  They do not need to summ up to unity. MC corrects for this.
**  !!! WARNING!!!  They do not match the model actually used in the present version of Tauola, 
**                  however, for many applications they might be sufficiently good.
**  !!! IMPORTANT HINT !!!!
**           Entry 2101 set smaller than -1d0 will activate internal defaults of Tauola.
**           In such a case all input from 2008-2122 will be IGNORED
      XPAR(2101) =  17.810d-2    !TAU-  -->   E-               
      XPAR(2102) =  17.370d-2    !TAU-  -->  MU-               
      XPAR(2103) =  11.080d-2    !TAU-  -->  PI-
      XPAR(2104) =  25.320d-2    !TAU-  -->  PI-, PI0
      XPAR(2105) =  18.380d-2    !TAU-  -->  A1-(two subch: 2PI-PI+= 9.23%, PI-2PI0=9.15%)
      XPAR(2106) =  0.710d-2     !TAU-  -->   K-
      XPAR(2107) =  1.350d-2     !TAU-  -->  K*- (two subch:  K-PI0= 0.52%, K0PI- =0.83%)
      XPAR(2108) =  4.350d-2     !TAU-  --> 2PI-,  PI0,  PI+   
      XPAR(2109) =  1.110d-2     !TAU-  --> 3PI0,        PI-   
      XPAR(2110) =  0.011d-2     !TAU-  --> 2PI-,  PI+, 2PI0   
      XPAR(2111) =  0.075d-2     !TAU-  --> 3PI-, 2PI+,        
      XPAR(2112) =  0.022d-2     !TAU-  --> 3PI-, 2PI+,  PI0   
      XPAR(2113) =  0.029d-2     !TAU-  --> 2PI-,  PI+, 3PI0   
      XPAR(2114) =  0.161d-2     !TAU-  -->  K-, PI-,  K+      
      XPAR(2115) =  0.121d-2     !TAU-  -->  K0, PI-, K0B      
      XPAR(2116) =  0.151d-2     !TAU-  -->  K-,  K0, PI0      
      XPAR(2117) =  0.080d-2     !TAU-  --> PI0, PI0,  K-      
      XPAR(2118) =  0.180d-2     !TAU-  -->  K-, PI-, PI+      
      XPAR(2119) =  0.390d-2     !TAU-  --> PI-, K0B, PI0      
      XPAR(2120) =  0.174d-2     !TAU-  --> ETA, PI-, PI0      
      XPAR(2121) =  0.050d-2     !TAU-  --> PI-, PI0, GAM      ???? from MC
      XPAR(2122) =  0.159d-2     !TAU-  -->  K-,  K0           
        
********************************************************************************
*****                   End of data for Tauola                              ****
********************************************************************************
      RETURN
      END


      DOUBLE PRECISION  FUNCTION BornV_Crude(vv)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*// This routine calculates CRUDE total Born cross section  SUMMED OVER KF.   //
*// It exploits the fact that born x. section = a + b*c + d*c**2              //
*// Hidden input is m_XXXene                                                  //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
*
      INTEGER KFf
      DOUBLE PRECISION   vv, svar1
      DOUBLE PRECISION   BornV_Differential
      DOUBLE PRECISION   Born, sum
* for brancher
      DOUBLE PRECISION   WMList(200),XsList(200)
      INTEGER j, KFlist(200), Nbranch
*-----------------------------------------------------------------------
      svar1  = (1-vv)*m_XXXene**2
* get from brancher list of KF's and of enhancement factors
      CALL MBrA_GetKFlist(Nbranch,KFlist)
      CALL MBrA_GetWMList(Nbranch,WMList)

      sum = 0d0
      DO j=1,Nbranch
         Born =0d0
         KFf=KFlist(j)
*///////////////////////////////////////////////////////////////////////////////
         Born= BornV_Differential( 0, Kff, svar1, 0.d0, 0.d0,0.d0, 0.d0,0.d0 )
*///////////////////////////////////////////////////////////////////////////////
* For light quarks u,d,s, special cut on mass (just in case)
         IF( (ABS(KFf) .GE. 1) .AND. (ABS(KFf) .LE. 3)) THEN
            IF( svar1 .LE. m_HadMin**2) Born=0d0
         ENDIF
* The amplification factor WM goes into crude normalization
* It is countered later on by the weight from MBrA_GenKF

         sum = sum +Born*WMList(j)
         XsList(j) = Born              !<---  WtMax=WMList(j) NOT included!!!
      ENDDO
* send back to bracher xsections for generation of KF
      CALL MBrA_SetXSList(XsList)
*------
      BornV_Crude =sum                 !<---  WtMax=WMList(j) IS included!!!
      END

      DOUBLE PRECISION  FUNCTION BornV_Differential(Mode,KFf,svar,CosThe,eps1,eps2,ta,tb)
*///////////////////////////////////////////////////////////////////////////////
*// Mode=0 it is CRUDE version for pure Born, no spin, no EW corrs.           //
*//                                                                           //
*// Mode=1 full result with electroweak corrs. spin etc. added.               //
*//        used in QED3 and all kind of tests                                 //
*//                                                                           //
*// Mode=3 for tests of pretabulation, GSW(s,theta) has to be provided from   //
*//        outside with help of BornV_SetGSW                                  //
*//                                                                           //
*// Note that in the test mode KeyEwl=0 and Mode=1 we use BornV_Simple        //
*// which perhaps will have to be changed in future besause lack of spin eff. //
*// At this stage however we are bound to use it because the KeyZet etc.      //
*// are implemented only in BornV_Simple and not in BornV_Dizet.              //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE

      INTEGER Mode
      DOUBLE PRECISION   svar,CosThe,eps1,eps2,ta,tb
      INTEGER KFf
      INCLUDE 'BornV.h'
      SAVE
      DOUBLE PRECISION   Born
      DOUBLE PRECISION   BornV_Dizet, BornV_Simple
*-----------------------------------------------------------------------------
      IF(     Mode .EQ. 1 ) THEN
         IF( m_KeyElw .EQ. 0 ) THEN
            Born= BornV_Simple( m_KFini,KFf,svar,CosThe)
         ELSE
*           Linear interpolation from tables, only for Mode=1 
            CALL BornV_InterpoGSW( ABS(KFf),  svar, CosThe)
            Born= BornV_Dizet( 1,m_KFini,KFf, svar, CosThe, eps1,eps2,ta,tb)
         ENDIF
      ELSEIF( Mode .EQ. 3 ) THEN
*           For test of pretabulation, BornV_SetGSW has to be invoked prior
            Born= BornV_Dizet( 1,m_KFini,KFf, svar, CosThe, eps1,eps2,ta,tb)
      ELSEIF( Mode .EQ. 0 ) THEN
         Born= BornV_Simple( m_KFini,KFf,svar,CosThe)
*        Another potential possibility, with a different threshold behavior is:
*        Born= BornV_Dizet( 0,m_KFini,KFf,svar,CosThe,0d0,0d0,0d0,0d0)
      ELSE
         WRITE(*,*) 'STOP in BornV_Differential: Mode =',Mode
         STOP
      ENDIF
      BornV_Differential = Born
      END



      DOUBLE PRECISION FUNCTION BornV_Dizet(Mode,KFi,KFf,svar,CosThe,eps1,eps2,ta,tb)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Calculates differential born cross section.                            //
*//   For Mode=0 pure Born and for Mode=1 electroweak corrs. are added.      //
*//   KFi,KFf can be also negative for antiparticle, in this case it is      //
*//   important to produce tables with correct input KFini, KFfin !!!        //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER          Mode,KFi,KFf
      DOUBLE PRECISION svar,CosThe,eps1,eps2,ta,tb
*-------------------------------------------------------------------------------------
      DOUBLE PRECISION  pi
      PARAMETER( pi =3.141592653589793238462643d0 )
      INTEGER    nneut
      PARAMETER( nneut = 3)
*-------------------------------------------------------------------------------------
      DOUBLE PRECISION 
     $  xupgi(2),                   ! Left/Right coupling gamma initial
     $  xupzi(2),                   ! Left/Right coupling Z     initial
     $  xupgf(2),                   ! Left/Right coupling gamma final
     $  xupzf(2)                    ! Left/Right coupling Z     final
*-------------------------------------------------------------------------------------
      DOUBLE PRECISION 
     $  t3e,                        ! Left izospin initial
     $  qe,                         ! Charge       initial
     $  t3f,                        ! Left izospin final
     $  qf                          ! Charge       final
      INTEGER
     $  kolor                       ! Color final fermion
*-------------------------------------------------------------------------------------
      DOUBLE COMPLEX   aborn(2,2),aphot(2,2),azett(2,2)
      DOUBLE COMPLEX   xupzfp(2),xupzip(2)
      DOUBLE COMPLEX   abornm(2,2),aphotm(2,2),azettm(2,2)
      DOUBLE COMPLEX   propa,propz
      DOUBLE COMPLEX   xr,xi,propw,aw(2,2)
      DOUBLE COMPLEX   xupf,xupi,xff(4),xfem,xfota,xrho,xke,xkf,xkef
      DOUBLE COMPLEX   xthing,xve,xvf,xvef
*
      INTEGER          j,i,ivini,kdumm,kff0,mode0,ivfin
      DOUBLE PRECISION xm2,xp2,xmw,regulm,regula,del1,xef,del0,factom,factor,thresh
      DOUBLE PRECISION xm3,helit,polar2,polar1,helic,born,amin,aizor,xgw,cost0,svar0
      DOUBLE PRECISION qem,qfm,xf,xe,beta,amfin,aizol,sinthe,xcoup
*-------------------------------------------------------------------------------------
      INTEGER    icont
      DATA       icont /0/
*/////////////////////////////////////////////////////////////////////////////
* Translation table KF-->IV
      INTEGER IV(-16:16)
      DATA IV / -1, -2, -1, -2, -1, -2, 4*0, -3, -4, -3, -4, -3, -4,  0,  
     $           4,  3,  4,  3,  4,  3, 4*0,  2,  1,  2,  1,  2,  1    /
*/////////////////////////////////////////////////////////////////////////////
*
      DATA xi/(0.d0,1.d0)/,xr/(1.d0,0.d0)/
      DATA xgw/2.5d0/
*
* To be sure that initialization starts properly
      DATA Mode0,svar0,cost0,KFf0 /-155,-155.d0,-156.d0,-99/
*-------------------------------------------------------------------------------------

*////////////////////////////////////////////////////////////////////////
*//    Save CPU for the same svar, CosThe  and varying spins ta, tb    //
*////////////////////////////////////////////////////////////////////////
      IF (Mode.NE.Mode0 .OR. svar.NE.svar0 .OR. CosThe.NE.cost0 
     $                  .OR. KFf.NE.KFf0  ) THEN
         Mode0  = Mode
         svar0  = svar
         cost0  = CosThe
         KFf0   = KFf
*////////////////////////////////////////////////////////////////////////
*//               Coupling constants                                   //
*////////////////////////////////////////////////////////////////////////
c[[[[[[[[[[[[[[[[[[[[[[!!!!!!!!!!!!!!!!!!!!!!
c      icont=icont+1
c      IF(icont.LE.20) THEN
c         write(*,*) '|||||||||||||||||||||BornV|||||||||||||||||||||||||||||||||||||'
c         write(*,'(8g22.14)') 'svar,costhe=',svar,costhe
c      ENDIF
c]]]]]]]]]]]]]]]]]]]]]]!!!!!!!!!!!!!!!!!!!!!!
         amin  = m_amferm(ABS(KFi))
         IVini = IV(KFi)
         CALL BornV_givizo( IVini, 1,aizor,qe,kdumm)
         CALL BornV_givizo( IVini,-1,aizol,qe,kdumm)
         xupgi(1)=qe
         xupgi(2)=qe
         t3e    = aizol+aizor
         xupzi(1)=(aizor-qe*m_swsq)/sqrt(m_swsq*(1-m_swsq))
         xupzi(2)=(aizol-qe*m_swsq)/sqrt(m_swsq*(1-m_swsq))
*
         amfin = m_amferm(ABS( KFf ))
         IVfin = IV( KFf )
         CALL BornV_givizo( IVfin, 1,aizor,qf,kolor)
         CALL BornV_givizo( IVfin,-1,aizol,qf,kolor)
         xupgf(1)=qf
         xupgf(2)=qf
         t3f    =  aizol+aizor
         xupzf(1)=(aizor -qf*m_swsq)/sqrt(m_swsq*(1-m_swsq))
         xupzf(2)=(aizol -qf*m_swsq)/sqrt(m_swsq*(1-m_swsq))
*
         sinthe = sqrt(1.d0-CosThe**2)
         beta   = SQRT(MAX(0d0,1d0-4d0*amfin**2/svar))
c[[[[[!!!!!!!!!!!!!!!!!!!!!!!
ccc         beta=1d0
c]]]]]!!!!!!!!!!!!!!!!!!!!!!!

* Multiply axial coupling by beta factor.
         xupzfp(1)= 0.5d0*(xupzf(1)+xupzf(2))+0.5*beta*(xupzf(1)-xupzf(2))
         xupzfp(2)= 0.5d0*(xupzf(1)+xupzf(2))-0.5*beta*(xupzf(1)-xupzf(2))
         xupzip(1)= 0.5d0*(xupzi(1)+xupzi(2))     +0.5*(xupzi(1)-xupzi(2))
         xupzip(2)= 0.5d0*(xupzi(1)+xupzi(2))     -0.5*(xupzi(1)-xupzi(2))
* Final state vector coupling
         xupf     = 0.5d0*(xupzf(1)+xupzf(2))
         xupi     = 0.5d0*(xupzi(1)+xupzi(2))
         xthing   = 0d0
*////////////////////////////////////////////////////////////////////////
*                          Propagators                                 //
*////////////////////////////////////////////////////////////////////////
         IF (Mode .EQ. 0 ) THEN
            propa =1d0/svar
            propz =1d0/dcmplx( svar -m_MZ**2, svar/m_MZ *m_gammz )
         ELSE
* Multiply axial coupling by beta factor. 
* Add formfactors initialisation of s-dependent electro-weak form factors and
* photonic vacuum polarisation 
* (electro-weak box contributions left out here, they depend on acos)
            xff(1)=m_GSW(1)
            xff(2)=m_GSW(2)
            xff(3)=m_GSW(3)
            xff(4)=m_GSW(4)
***         xffa  =UNDEFINED !!!!
            xfem  =m_GSW(6)
            xfota =m_GSW(7)
*-------------------------------------------------
            xrho =xff(1)
            xke  =xff(2)
            xkf  =xff(3)
            xkef =xff(4)
            qfm =dabs(qf)
            qem =dabs(qe)
            xe   =  1.d0 -4.d0*m_swsq*qem
            xf   =  1.d0 -4.d0*m_swsq*qfm
            xef  = -1.d0 +xe +xf +16.d0*qem*qfm*m_swsq*m_swsq ! xef=xe*xf !!!
            xve  =  1.d0 -4.d0*m_swsq*qem*xke
            xvf  =  1.d0 -4.d0*m_swsq*qfm*xkf
            xvef = -1.d0 +xve +xvf +16.d0*qem*qfm*m_swsq*m_swsq*xkef
* Multiply axial  coupling by beta factor.
* Multiply vector coupling by form-factor.
            xupzfp(1)=0.5d0*(xupzf(1)+xupzf(2))*xvf/xf +0.5*beta*(xupzf(1)-xupzf(2))
            xupzfp(2)=0.5d0*(xupzf(1)+xupzf(2))*xvf/xf -0.5*beta*(xupzf(1)-xupzf(2))
            xupzip(1)=0.5d0*(xupzi(1)+xupzi(2))*xve/xe      +0.5*(xupzi(1)-xupzi(2))
            xupzip(2)=0.5d0*(xupzi(1)+xupzi(2))*xve/xe      -0.5*(xupzi(1)-xupzi(2))
* Final state vector coupling
            xupf     =0.5d0*(xupzf(1)+xupzf(2))*xvf/xf
* Double vector formfactor thing
            xthing=0.25d0*(xupzf(1)+xupzf(2))*(xupzi(1)+xupzi(2))*(xvef/xef-xvf*xve/xe/xf)
            propa =1d0/svar/(2d0-xfem)
            propz =1d0/dcmplx(svar-m_MZ**2,svar/m_MZ*m_gammz)
* Replace Born normalization of Z propagator by the better one
            del1 =m_Gmu *m_MZ**2 *m_AlfInv/(DSQRT(2.d0)*8.d0*pi)
            del0 =1.d0/(m_swsq*(1.d0-m_swsq))/16.d0
            propz = propz*del1/del0*xrho
c[[[[[[[[[[[[[
c      IF(icont.LE.20) THEN
c         write(*,'(a,5g22.14)') '   propa= ', propa
c         write(*,'(a,5g22.14)') '   propz= ', propz
c         write(*,'(a,5g22.14)') '   xrho = ', xrho
c         write(*,'(a,5g22.14)') '   xke  = ', xke
c         write(*,'(a,5g22.14)') '   xkf  = ', xkf
c         WRITE(*,'(a,5g22.14)') '   xkef = ', xkef/(xke*xkf)
c         write(*,'(a,5g22.14)') '    swsq= ', m_swsq
c      ENDIF
c]]]]]]]]]]]]]
         ENDIF ! (Mode .EQ. 0)
*////////////////////////////////////////////////////////////////////////
*//             Additional Spin amplitudes in neutrino case            //
*////////////////////////////////////////////////////////////////////////
         DO i=1,2
            DO j=1,2
               aw(i,j)=(0.d0,0.d0)
            ENDDO
         ENDDO
         IF (iabs(IVfin) .EQ. 1) THEN
            IF(Mode .EQ. 0) THEN
               xmw=m_MZ*dsqrt(1d0-m_swsq)
               xcoup=1.d0/2.d0/m_swsq
               IF (IVini .LT. 0) THEN
                  aw(2,1)= -DCMPLX(xcoup*(1.d0-CosThe))/xmw/xmw
               ELSE
                  aw(1,2)= -DCMPLX(xcoup*(1.d0-CosThe))/xmw/xmw
               ENDIF
            ELSE
               xmw=m_MZ*dsqrt(1d0-m_swsq)
               xp2=(svar*(1.d0+CosThe)/2.+xmw*xmw)**2+(xmw*xgw)**2
               propw=dcmplx(-(svar*(1.d0+CosThe)/2+xmw*xmw)/xp2)
               propw=propw-xi*dcmplx(xmw*xgw/xp2)
               xcoup=1.d0/2.d0/m_swsq
               IF (IVini .LT. 0) THEN
                  aw(2,1)= propw*dcmplx(xcoup*(1.d0-CosThe))
               ELSE
                  aw(1,2)= propw*dcmplx(xcoup*(1.d0-CosThe))
               ENDIF
            ENDIF
         ENDIF
*////////////////////////////////////////////////////////////////////////
*//             Spin amplitudes   Z+gamma case                         //
*////////////////////////////////////////////////////////////////////////
         DO i=1,2
            DO j=1,2
               regula= (3-2*i)*(3-2*j) + CosThe
               regulm=-(3-2*i)*(3-2*j) * sinthe *2.d0*amfin/sqrt(svar)
               aphot(i,j)=propa*(xupgi(i) *xupgf(j)*regula)
               azett(i,j)=propz*(xupzip(i)*xupzfp(j)+xthing)*regula
               aborn(i,j)=aphot(i,j)+azett(i,j)+aw(i,j)
               aphotm(i,j)= propa*dcmplx(0d0,1d0)  *xupgi(i)*xupgf(j)    *regulm
               azettm(i,j)= propz*dcmplx(0d0,1d0)*(xupzip(i)*xupf+xthing)*regulm
               abornm(i,j)=aphotm(i,j)+azettm(i,j)
c[[[[[[[[[[[[[
c               IF(icont.LE.20) THEN
c                  write(*,'(a,2i5,5g22.14)') 'amplit= ',i,j, 
c     $                 propa*xupgi(i) *xupgf(j) + propz*(xupzip(i)*xupzfp(j)+xthing)
c               ENDIF
c]]]]]]]]]]]]]
            ENDDO
         ENDDO
      ENDIF
*////////////////////////////////////////////////////////////////////////
*//    Saving CPU trick ENDs here                                      //
*////////////////////////////////////////////////////////////////////////
*////////////////////////////////////////////////////////////////////////
*//           Differential X-section out of spin amplituds             //
*//  Helicity conservation explicitly obeyed:                          //
*//  Only diagonal elements of the spin density matrices.              //
*//  (Only longitudinal polarizations)                                 //
*////////////////////////////////////////////////////////////////////////
      polar1 =  (eps1)
      polar2 = (-eps2)
      Born   =  0d0
      DO i=1,2
         helic= 3-2*i
         DO j=1,2
            helit=3-2*j
            factor=kolor*(1d0+helic*polar1)*(1d0-helic*polar2)/4d0
            factom=factor*(1+helit*ta)*(1-helit*tb)
            factor=factor*(1+helit*ta)*(1+helit*tb)
            IF(iabs(IVfin) .NE. 1) THEN
*     Normal case
*     (mass terms included in Born. is it better ??????)
               Born=Born+cdabs(aborn(i,j))**2*factor
               IF (Mode .NE. 0) THEN
                  Born=Born+CDABS(abornm(i,j))**2*factom
               ENDIF
            ELSE
*     Neutrino case
               xm2=cdabs( aborn(i,j))**2   +(nneut-1)*cdabs(azett(i,j))**2
               xm3=cdabs(abornm(i,j))**2  +(nneut-1)*cdabs(azettm(i,j))**2
               Born=Born+(xm2+xm3)*factor
            ENDIF
         ENDDO
      ENDDO
* phase space threshold factor, and multiply by svar**2 to get R-units!
      IF (svar .GT. 4d0*amfin**2) THEN
         thresh=sqrt(1-4d0*amfin**2/svar)
         Born = Born*svar**2*thresh
      ELSE
         Born=0.d0
      ENDIF
* Note that BornV_InterpoGSW is not called for Mode=1  !!
      IF(Mode .NE. 0) Born=Born*(1d0 +m_QCDcor)
      BornV_Dizet = Born
      END

      SUBROUTINE BornV_GetAlfInv(AlfInv)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  AlfInv
*------------------
      AlfInv = m_AlfInv
      END

      DOUBLE PRECISION  FUNCTION BornV_GetAuxPar(KFferm)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KFferm
*------
      BornV_GetAuxPar = m_AuxPar(ABS(KFferm))
      END ! BornV_GetAuxPar

      SUBROUTINE BornV_GetAvMult(AvMult)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION    AvMult
*------------------
      AvMult = m_AvMult
      END

      DOUBLE PRECISION  FUNCTION BornV_GetCharge(KFferm)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KFferm
*------
      BornV_GetCharge = m_Qf(ABS(KFferm))
      END ! BornV_GetCharge

      INTEGER FUNCTION BornV_GetColor(KFferm)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KFferm
*------
      BornV_GetColor = m_NCf(ABS(KFferm))
      END ! BornV_GetColor

      SUBROUTINE BornV_GetGammZ(GammZ)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  GammZ
*------------------
      GammZ = m_GammZ
      END

      SUBROUTINE BornV_GetGmu(Gmu)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  Gmu
*------------------
      Gmu = m_Gmu
      END

      SUBROUTINE BornV_GetGSW(GSW)
*//////////////////////////////////////////////////////////////////////////
*//
*//  Exports  GSW formfactors, called in GPS/CEEX
*//  BornV_InterpoGSW has to be called before
*//
*//////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE COMPLEX    GSW(*)
      INTEGER      k
*     ---------------------------------------------------------------------
      DO k=1,7
         GSW(k) = m_GSW(k)
      ENDDO
      END

      SUBROUTINE BornV_GetKeyElw(KeyElw)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KeyElw
*
      KeyElw = m_KeyElw
      END

      SUBROUTINE BornV_GetKeyZet(KeyZet)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KeyZet
*
      KeyZet = m_KeyZet
      END

      DOUBLE PRECISION  FUNCTION BornV_GetMass(KFferm)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KFferm
*------
      BornV_GetMass = m_amferm(ABS(KFferm))
      END ! BornV_GetMass

      SUBROUTINE BornV_GetMZ(MZ)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  MZ
*------------------
      MZ = m_MZ
      END

*//////////////////////////////////////////////////////////////////////////////
*//                  Getters and setters                                     //
*//////////////////////////////////////////////////////////////////////////////

      SUBROUTINE BornV_GetParticle(KFferm, mass, Qf, T3f, NCf)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
*
      INTEGER KFferm, NCf
      DOUBLE PRECISION   mass, Qf, T3f
      INTEGER KF
*--------
      KF = ABS(KFferm)
      mass  = m_amferm( KF)
      Qf    = m_Qf(     KF)
      T3f   = m_T3f(    KF)
      NCf   = m_NCf(    KF)

      END

      SUBROUTINE BornV_GetQCDcor(QCDcor)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Get QCD correction factor, provided by Dizet                           //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION    QCDcor
*------------------
      QCDcor = m_QCDcor
      END

      SUBROUTINE BornV_GetSwsq(Swsq)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  Swsq
*------------------
      Swsq = m_swsq
      END

      SUBROUTINE BornV_GetVV(vv)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  vv
*
      vv = m_vv
      END ! BornV_GetVV

      SUBROUTINE BornV_GetVXX(vv,x1,x2)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  vv,x1,x2
*
      vv = m_vv
      x1 = m_x1
      x2 = m_x2
      END ! BornV_GetVXX

      SUBROUTINE BornV_GetYFS_IR(YFS_IR)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Get IR (cut-off dependend) part of ISR YFS form-factor                 //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION    YFS_IR
*------------------
      YFS_IR = m_YFS_IR

      END

      SUBROUTINE BornV_GetYFSkon(YFSkon)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Get finite part of YFS form-factor                                     //
*//   Used in QED3.f                                                         //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION    YFSkon
*------------------
      YFSkon = m_YFSkon
      END


      SUBROUTINE BornV_givizo(idferm,ihelic,sizo3,charge,kolor)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Provides electric charge and weak izospin of a family fermion where      //
*// idferm =           1,        2,        3,         4,                     //
*// denotes:    neutrino,   lepton,       up,      down   (quark)            //
*// negative idferm=-1,-2,-3,-4, denotes corresponding antiparticle          //
*// ihelic =     +1,  -1   denotes  right and left handednes ( chirality)    //
*// sizo3 is third projection of weak izospin (plus minus half)              //
*// and charge is electric charge in units of electron charge                //
*// kolor is a qcd colour, 1 for lepton, 3 for quarks                        //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER          idferm,ihelic,kolor
      DOUBLE PRECISION sizo3,charge
*
      INTEGER          lepqua,iupdow,ic,ih,idtype
*------------------------------------------------------------------------------
      IF(idferm  .EQ.  0  .OR.  iabs(idferm)  .GT.  4) GOTO 901
      IF(iabs(ihelic)  .NE.  1)                GOTO 901
      ih  =ihelic
      idtype =iabs(idferm)
      ic  =idferm/idtype
      lepqua=INT(idtype*0.4999999d0)
      iupdow=idtype-2*lepqua-1
      charge  =(-iupdow+2d0/3d0*lepqua)*ic
      sizo3   =0.25d0*(ic-ih)*(1-2*iupdow)
      kolor=1+2*lepqua
* note that conventionaly z0 coupling is
* xoupz=(sizo3-charge*swsq)/sqrt(swsq*(1-swsq))
      RETURN
 901  print *,' STOP in BornV_givizo: wrong params.'
      STOP
      END
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//          END of Pseudoclass BStra                                                //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Pseudo-CLASS  BornV                                  //
*//                                                                          //
*//  Purpose:                                                                //
*//  Provide Born angular distribution and integrated x-section              //
*//  as a function of s.                                                     //
*//                                                                          //
*//  NOTES:                                                                  //
*//  How to eliminate nneut? This will come in a natural way                 //
*//  when neutrino type is generated.                                        //
*//  NB. Zbyszek says that weight dispersion might worsen!                   //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*
      SUBROUTINE BornV_Initialize(xpar_input)
*//////////////////////////////////////////////////////////////////////////////
*//                    Class initializator                                   //
*// Notes:                                                                   //
*// This initializator should be called before any other routine of the class//
*// It defines (mostly static) class members using input from xpar matrix    //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  xpar_input(*)
*
      INCLUDE 'BXformat.h'
      INCLUDE 'BornV.h'
      SAVE
*
      DOUBLE PRECISION    amuon
      INTEGER  j,kxpa,KF
      DOUBLE PRECISION    vvmax
*
*------------------------------------------------------------------------------
      m_QCDcor = 0d0
      m_CMSene = xpar_input( 1)         ! Central value of CMS energy, do not change!
      m_XXXene = m_CMSene               ! Just initialization only
      m_KFini = xpar_input( 400)        ! KFcode of beam, POSITIVE!!!
*                      <<<  ff-pair spectrum >>>
      m_vvmin  = xpar_input(16)         ! minimum v, infrared cut
      vvmax    = xpar_input(17)         ! maximum v
      amuon  = 0.1056583d0
      m_vvmax  = min(vvmax, 1d0-(2*amuon/m_CMSene)**2)
      m_HadMin = xpar_input(51)         ! minimum hadronization mass
*                        <<< Basic QED >>>
      m_AlfInv = xpar_input(30)         ! Alpha_QED at Thomson limit
      m_alfpi  = 1d0/m_pi/m_AlfInv
*                  <<< Electroweak parameters >>>
      m_Gmu    = xpar_input(32)         ! Fermi constant
      m_MZ     = xpar_input(502)        ! Z mass [GeV]
      m_amh    = xpar_input(505)        ! Higgs mass, Input for Dizet
      m_amtop  = xpar_input(506)        ! Top mass,   Input for Dizet
* Note that gammz and swsq will be redefined in the case of EW corrs. are on
      m_swsq   = xpar_input(503)        ! Electroweak mixing angle
      m_gammz  = xpar_input(504)        ! Z width

*               <<< Static Table of ALL fermion parameters >>>
      DO j=1,20
         m_IsGenerated(j) = xpar_input(400+j)   ! Generation flag
         kxpa = 500+10*j
         m_KFferm(j)= xpar_input(kxpa+1)        ! fermion flavour code
         m_NCf(j)   = xpar_input(kxpa+2)        ! number of colours
         m_Qf(j)    = xpar_input(kxpa+3)/3d0    ! electric charge
         m_T3f(j)   = xpar_input(kxpa+4)/2d0    ! isospin, L-hand component
         m_helic(j) = xpar_input(kxpa+5)        ! helicity, polarization
         m_amferm(j)= xpar_input(kxpa+6)        ! fermion mass
         m_AuxPar(j)= xpar_input(kxpa+8)        ! auxiliary parameter
      ENDDO
*                       <<< Test switches >>>
      m_KeyElw = xpar_input(12)         ! ElectroWeak library on/off
      m_KeyZet = xpar_input(501)        ! Z-boson on/off
      m_KeyWtm = xpar_input(26)         ! Photon emission without mass terms
*                       <<<  Other        >>>
      m_KeyINT = xpar_input(27)         ! This is realy copy from KK2f
      m_Xenph  = xpar_input(40)         ! This is realy copy from KK2f
      IF(m_KeyINT .EQ. 0)  m_Xenph  = 1D0
*                       <<< Miscelaneous >>>
      m_gnanob = xpar_input(31)         ! GeV^(-2) to nanobarns
*
      m_out    = xpar_input(4)
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  BornV  Initializator                '
      WRITE(m_out,bxl1f) m_MZ    ,   'Z mass     [GeV]   ','amz   ','a1'
      WRITE(m_out,bxl1f) m_amh   ,   'Higgs mass [GeV]   ','amh   ','a2'
      WRITE(m_out,bxl1f) m_amtop ,   'Top mass   [GeV]   ','amtop ','a3'
      WRITE(m_out,bxl1f) m_gammz,    'Z width    [GeV]   ','gammz ','a4'
      WRITE(m_out,bxl1f) m_swsq,     'sin(theta_w)**2    ','sinw2 ','a5'
      WRITE(m_out,bxl1f) m_AlfInv,   '1/alfa_QED  at  Q=0','AlfInv','a6'
      WRITE(m_out,bxl1f) m_HadMin,   'MassCut light qqbar','HadMin','a6'
      WRITE(m_out,bxl1i) m_KFini ,   'KF code of beam    ','KFini ','a7'
      WRITE(m_out,bxl1g) vvmax,      'Input vvmax        ','vvmax ','a8'
      WRITE(m_out,bxl1g) m_vvmax,    'reduced vvmax in MC','vvmax ','a9'
      WRITE(m_out,bxtxt) 'Test switches:                         '
      WRITE(m_out,bxl1i) m_KeyElw,   'Electroweak lib.   ','KeyElw','10'
      WRITE(m_out,bxl1i) m_KeyZet,   'Z on/off   switch  ','KeyZet','11'
      WRITE(m_out,bxl1i) m_KeyWtm,   'mass terms on/off  ','KeyWtm','12'
      WRITE(m_out,bxclo)

      IF( m_KeyElw .NE. 0 ) CALL BornV_ReadAll(m_MZ,m_amh,m_amtop)

      END

      DOUBLE PRECISION  FUNCTION BornV_Integrated(KFfin,svar)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   !!!!!!!!!!!!!! USED ONLY IN SEMIANALYTICAL programs!!!!!!!!!!           //
*//                                                                           //
*// This routine calculates total Born cross section.                         //
*// It is NOT used in MC any more                                             //
*//                                                                           //
*// It exploits the fact that born x. section = a + b*c + d*c**2              //
*//                                                                           //
*// For KFfin = 0 we sum over all alowed flavours, otherwise,                 //
*// for KFfin.NE.0 we calculate xsect for the actual value of m_KFfin         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
*
      INTEGER KFfin
      DOUBLE PRECISION   svar
      DOUBLE PRECISION   BornV_Differential
      DOUBLE PRECISION   Born,Sum
      INTEGER KFf
*-----------------------------------------------------------------------
* Selective Inclusive/Exclusive Loop over all final fermions
      Sum = 0d0
      DO KFf=1,20
         Born =0d0
         IF( m_IsGenerated(KFf) .NE.  0) THEN
            IF((KFfin .EQ. 0  )  .OR. ! Inclusive
     $         (KFfin .EQ. KFf)) THEN ! Exclusive
               Born= BornV_Differential( 0,Kff,svar, 0.d0, 0.d0,0.d0, 0.d0,0.d0 )
            ENDIF
         ENDIF
         Sum = Sum +Born
      ENDDO
      BornV_Integrated =Sum
      END


      SUBROUTINE BornV_InterpoGSW(KFf,svar,CosThe)
*//////////////////////////////////////////////////////////////////////////
*//
*//  Calculates GSW formfactors from tables using linear interpolation
*//
*//////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION   svar,CosThe
      DOUBLE COMPLEX     xff(4),xfem,xfota
      INTEGER            kk,i,j, KFf
      DOUBLE PRECISION   x,h,h1,ww
*----------------------------------------------------------------------------
      ww = SQRT(svar)
      m_WminZ = m_MZ-2d0*m_gammz
      m_WmaxZ = m_MZ+2d0*m_gammz

      IF(  (ww.GE.m_WminLEP1) .AND. (ww.LE.m_WmaxLEP1) ) THEN
         IF(  (ww.GE.m_WminZ) .AND. (ww.LE.m_WmaxZ)    ) THEN
* LEP1 near Z0 resonance
            x= (ww-m_WminZ)/(m_WmaxZ-m_WminZ)
            i= INT(m_poin2*x)+1
            h= x*m_poin2-DFLOAT(i-1)
            DO kk=1,7
               m_GSW(kk)= m_czz(  i,kk,KFf)*(1-h)
     $                   +m_czz(i+1,kk,KFf)*h
            ENDDO
            m_QCDcor    = m_szz(  i,KFf)*(1-h)
     $                   +m_szz(i+1,KFf)*h
         ELSE
* LEP1 outside Z0 and low energies
            x= LOG( ww/m_WminLEP1) / LOG(m_WmaxLEP1/m_WminLEP1)
            i= INT(m_poin1*x)+1
            h= x*m_poin1-DFLOAT(i-1)
            DO kk=1,7
               m_GSW(kk)= m_cyy(  i,kk,KFf)*(1-h)
     $                   +m_cyy(i+1,kk,KFf)*h
            ENDDO
            m_QCDcor    = m_syy(  i,KFf)*(1-h)
     $                   +m_syy(i+1,KFf)*h
         ENDIF
      ELSEIF(  (ww.GE.m_WmaxLEP1) .AND. (ww.LE.m_WmaxLEP2) ) THEN
* in the LEP2 region
         x= (ww-m_WmaxLEP1)/(m_WmaxLEP2-m_WmaxLEP1)
         i= INT(m_poin3*x)+1
         i= MIN( i, m_poin3)      ! corr. stj ????? out of range !!!!
         h= x*m_poin3-DFLOAT(i-1)
         x= (1d0+CosThe)/2d0
         j= INT(m_poinT*x)+1
         j= MIN( j, m_poinT)      ! corr. stj ?????
         h1= x*m_poinT-DFLOAT(j-1)
* EW complex form-factors
         DO  kk=1,7
            m_GSW(kk)=
     $            (  m_ctt(i,  j  ,kk,KFf)*(1-h)
     $              +m_ctt(i+1,j  ,kk,KFf)*h     )*(1d0-h1)
     $           +(  m_ctt(i,  j+1,kk,KFf)*(1-h)
     $              +m_ctt(i+1,j+1,kk,KFf)*h     )*h1
         ENDDO
* QCD correction
         m_QCDcor=
     $            (  m_stt(i,  j  ,KFf)*(1-h)
     $              +m_stt(i+1,j  ,KFf)*h     )*(1d0-h1)
     $           +(  m_stt(i,  j+1,KFf)*(1-h)
     $              +m_stt(i+1,j+1,KFf)*h     )*h1
      ELSEIF(  (ww.GE.m_WmaxLEP2) .AND. (ww.LE.m_WmaxNLC) ) THEN
* in the NLC region
         x= (ww-m_WmaxLEP2)/(m_WmaxNLC-m_WmaxLEP2)
         i= INT(m_poin4*x)+1
         i= MIN( i, m_poin4)      ! corr. stj ????? out of range !!!!
         h= x*m_poin4-DFLOAT(i-1)
         x= (1d0+CosThe)/2d0
         j= INT(m_poinT*x)+1
         j= MIN( j, m_poinT)      ! corr. stj ?????
         h1= x*m_poinT-DFLOAT(j-1)
* EW complex form-factors
         DO  kk=1,7
            m_GSW(kk)=
     $            (  m_clc(i,  j  ,kk,KFf)*(1-h)
     $              +m_clc(i+1,j  ,kk,KFf)*h     )*(1d0-h1)
     $           +(  m_clc(i,  j+1,kk,KFf)*(1-h)
     $              +m_clc(i+1,j+1,kk,KFf)*h     )*h1
         ENDDO
* QCD correction
         m_QCDcor=
     $            (  m_slc(i,  j  ,KFf)*(1-h)
     $              +m_slc(i+1,j  ,KFf)*h     )*(1d0-h1)
     $           +(  m_slc(i,  j+1,KFf)*(1-h)
     $              +m_slc(i+1,j+1,KFf)*h     )*h1
      ELSE
         PRINT *,'STOP in BornV_InterpoGSW: s out of predefined range, ww=', ww
         STOP
      ENDIF
      END                        !BornV_GetGSW

      SUBROUTINE BornV_MakeGami(CMSene,gamiCR,gami)
*//////////////////////////////////////////////////////////////////////////////
*//   Crude Gami as a function of CMSene                                     //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  CMSene, gamiCR, gami
      DOUBLE PRECISION  amel, svar, am2, beta
      INTEGER           KFbeam
*---------------------------------
      KFbeam = 11           ! KF=11 is electron
      amel   = m_amferm(KFbeam)
      am2  = (2d0*amel/CMSene)**2
      IF( am2 .GT. 1d0 ) GOTO 800
      beta = SQRT(1d0-am2)
      gami    = 2d0*m_alfpi *( DLOG((1+beta)**2/am2) -1d0)
      gamiCR  = 2d0*m_alfpi *  DLOG((1+beta)**2/am2)
      gamiCR  = gamiCR *m_Xenph         !!! enhancement of crude photon multiplicity
      IF(m_KeyWtm .EQ. 1) gamiCR=gami   !!! new, for very special tests
*-------------
      RETURN
 800  CONTINUE
      gamiCR = 0d0
      gami   = 0d0
      END

      SUBROUTINE BornV_MakeISR(Rho)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   This procedure is tightly related to ISR photon generation in Karlud   //
*//   It calculates Rho(m_vv, m_XXXene) QED crude Structure Function         //
*//                                                                          //
*//   m_AvMult is later used in KarLud_YFSini                                //
*//   m_YFSkon ,m_YFS_IR are later used in GPS_Make  and QED3_Make           //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION   Rho
      DOUBLE PRECISION   gami,  gamiCR,  BornV_Crude
      DOUBLE PRECISION   xBorn, DilJac0, beta, VoluMC
*-----------------------------
      CALL BornV_MakeGami(m_XXXene,gamiCR,gami)
      IF(m_vv .GT. m_vvmin) THEN
         DilJac0   = (1d0+1d0/SQRT(1d0-m_vv))/2d0
         m_AvMult  = gamiCR*DLOG(m_vv/m_vvmin)
         VoluMC    = gamiCR/m_vv *EXP( m_AvMult )    !!! Phase space Volume CRUDE
         m_YFS_IR  = -gami*DLOG(1d0/m_vvmin)         !!! IR part of YFS formfactor
         Rho       = VoluMC *EXP(m_YFS_IR)
      ELSE
         DilJac0   = 1d0
         m_AvMult  = 0d0
         VoluMC    = 1d0
* IMPORTANT:     The integral over Rho(v<vvmin) = YFS_IR = EXP(-gami*LOG(1/vvmin))
         m_YFS_IR  = -gami*DLOG(1d0/m_vvmin)         !!! IR part of YFS formfactor
         Rho       = 1d0/m_vv *gami*m_vv**gami
      ENDIF
      Rho =  Rho * DilJac0
* YFS formfactor, finite part, YFS_form_Factor = EXP(YFS_IR + YFSkon)
* YFSkon is delegated/exported to QED3 and GPS (not used here).
      m_YFSkon =  EXP(1/4d0 *gami + m_alfpi*( -.5d0  +m_pi**2/3d0) )
      m_YFS_IR =  EXP(m_YFS_IR)
      END

      SUBROUTINE BornV_MakeRho(R,Rho)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   This function is tightly related to ISR photon generation in Karlud    //
*//   It calculates Rho(vv) QED crude Structure Function at XXXene           //
*//   Translates R into m_vv                                                 //
*//                                                                          //
*//   m_vv is used in Karlud and other places                                //
*//   m_AvMult is later used in KarLud_YFSini                                //
*//   m_YFSkon ,m_YFS_IR are later used in GPS_Make  and QED3_Make           //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION   R,Rho
      DOUBLE PRECISION   gami,  gamiCR,  BornV_Crude
      DOUBLE PRECISION   xBorn, DilJac0, beta, RJac,  VoluMC
*-----------------------------
      CALL BornV_MakeGami(m_XXXene,gamiCR,gami)
      IF( gamiCR .LE. 0d0 ) GOTO 800
*     Mapping  r => vv change  to improve on efficiency
      beta = -0.5d0
      CALL BornV_ReBin1(R,gamiCR,beta,m_vvmax,m_vv,RJac)
      IF(m_vv .GT. m_vvmin) THEN
         DilJac0   = (1d0+1d0/SQRT(1d0-m_vv))/2d0
         m_AvMult  = gamiCR*DLOG(m_vv/m_vvmin)
         VoluMC    = gamiCR/m_vv *EXP( m_AvMult )    !!! Phase space Volume CRUDE
         m_YFS_IR  = -gami*DLOG(1d0/m_vvmin)         !!! IR part of YFS formfactor
         Rho       = VoluMC *EXP(m_YFS_IR)
      ELSE
         DilJac0   = 1d0
         m_AvMult  = 0d0
         VoluMC    = 1d0
* IMPORTANT:     The integral over Rho(v<vvmin) = YFS_IR = EXP(-gami*LOG(1/vvmin))
         m_YFS_IR  = -gami*DLOG(1d0/m_vvmin)         !!! IR part of YFS formfactor
         Rho       = 1d0/m_vv *gami*m_vv**gami
      ENDIF
      Rho =  Rho * DilJac0*RJac
* YFS formfactor, finite part, YFS_form_Factor = EXP(YFS_IR + YFSkon)
* YFSkon is delegated/exported to QED3 and GPS (not used here).
      m_YFSkon =  EXP(1/4d0 *gami + m_alfpi*( -.5d0  +m_pi**2/3d0) )
      m_YFS_IR =  EXP(m_YFS_IR)
      RETURN
 800  CONTINUE
      Rho  = 0d0
      m_vv = 0d0
      END


      SUBROUTINE BornV_ReadAll(amz, amh, amtop)
*///////////////////////////////////////////////////////////////////
*//            Reading from disk  all pretabulations              //
*//  all quarks, muon and tau                                     //
*///////////////////////////////////////////////////////////////////
      IMPLICIT NONE

      DOUBLE PRECISION   amz, amh, amtop
      INTEGER KFdown, KFup, KFstran, KFcharm, KFbotom, KFtop
      PARAMETER( 
     $     KFdown  = 1,   KFup    = 2,
     $     KFstran = 3,   KFcharm = 4,
     $     KFbotom = 5,   KFtop   = 6)
      INTEGER KFel,KFelnu,KFmu,KFmunu,KFtau,KFtaunu
      PARAMETER(
     $     KFel    = 11,  KFelnu  = 12,
     $     KFmu    = 13,  KFmunu  = 14,
     $     KFtau   = 15,  KFtaunu = 16)

      INTEGER KFfin,ifl
      CHARACTER*40 fname
*----------------------------------------------------------------------
C 29/11: In TABINI, all tables are done at the beginning of the job
C WARNING: i don't produce the same events (but tables are different...)
C note: even with jadach makefile (make tables) i don't produce the same tables
C 30/11: i have re-done the tables: GammZ and GammW are different...
C 1/12:  IT'S OK. DIZET correctly initialized
      CALL TABINI(amz, amh, amtop)

C last test, do only one table (ie we must produce events by flavour)
C takes a lot of time !! why ??
C       ifl = 3
C       CALL TABINI2(amz, amh, amtop, ifl)

C this was after i have put KK2f tables in a common with UNIX code
C Tables are the old provided with the code...
C tables could be done at the beginning with TABINI
C but i don't produced the same events !
C-      TableFile= '../../dizet/table.down.340pt'
C      CALL DOWN(amz, amh, amtop)
C      KFfin = KFdown
C      fname = 'down.f'
C      CALL BornV_ReadFile(fname,KFfin,amz, amh, amtop)


      RETURN
      END


      SUBROUTINE BornV_ReadFile(fname,KFfin,amz, amh, amtop)
*///////////////////////////////////////////////////////////////////
*//            Reading from disk  single file                     //
*///////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'BornV.h'
      CHARACTER*(*) fname
      INTEGER KFfin, KFf,iuout

      SAVE

      CHARACTER*1 chr
      INTEGER i,j,k,ndisk,n,n1,n2
      DOUBLE PRECISION   amz, amh, amtop
      DOUBLE PRECISION   ww,cosi,gammw

      KFf = ABS(KFfin)
      IF( KFf.LT.1 .OR. KFf.GT.16 ) GOTO 900

      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'BornV  Reading from file:         '
      WRITE(m_out,bxtxt) fname
      WRITE(m_out,bxl1f)   amz   ,   'Z mass             ','amz   ','a1'
      WRITE(m_out,bxl1f)   amh   ,   'Higgs mass         ','amh   ','a2'
      WRITE(m_out,bxl1f)   amtop ,   'Top mass           ','amtop ','a3'
      WRITE(m_out,bxl1f) m_swsq  ,   'sin**2(thetaW)     ','swsq  ','a3'
      WRITE(m_out,bxl1f) m_gammz ,   'Z width            ','gammz ','a3'
      WRITE(m_out,bxl1f) m_amw   ,   'W mass             ','amw   ','a3'
      WRITE(m_out,bxl1f) m_gammw ,   'W width            ','gammw ','a3'
      WRITE(m_out,bxclo)

* Check if tables on disk were produced with the same input params!!!
      IF( amz.EQ.0d0  .OR. amh.EQ.0d0  .OR. amtop.EQ.0d0  .OR.
     $     ABS(1-m_MZ/amz)      .GT. 1d-5  .OR.
     $     ABS(1-m_amh/amh)     .GT. 1d-5  .OR.
     $     ABS(1-m_amtop/amtop) .GT. 1d-5  ) THEN
         WRITE(    *,*)  '+++ STOP in BornV_ReadFile: CHECK mz,mh,mtop'
         WRITE(m_out,*)  '+++ STOP in BornV_ReadFile: CHECK mz,mh,mtop'
         STOP
      ENDIF

      RETURN

 900  WRITE(m_out,*) '+++ BornV_ReadFile: wrong KFf= ', KFf
      WRITE(    6,*) '+++ BornV_ReadFile: wrong KFf= ', KFf
      END

      SUBROUTINE BornV_ReBin1(RR,alf,bet,xmax,x,djac)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  This mapps variable r into x.                                           //
*//  to be employed in the integration (either ordinary or Monte Carlo)      //
*//  of distributions resambling                                             //
*//  the binomial distribution x**(alf-1)*(1-x)**(bet-1)                     //
*//  with alf > 0 and  bet arbitrary.                                        //
*//  variable r is in (0,1) range and x is within (0,xmax) range.            //
*//  djac is jacobian factor d(x)/d(r).                                      //
*//  mapping is such that 1/djac is very CLOSE to                            //
*//  binomial distribution x**(alf-1)*(1-x)**(bet-1).                        //
*//  WARNING: mapping may fail very CLOSE to r=0. Practically, one is        //
*//  recommended to obey: fleps**alf < r, where fleps = 1d-100.              //
*//  problems may also arise for very small xmax ( below 1.d-12 ).           //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION RR,R,alf,bet,xmax,x,djac
      DOUBLE PRECISION x0,dist,r1,p1,q1,q2
*------------------------------------------------------------------------------
      IF( alf .LE. 0d0 ) GOTO 900
      R = MAX(RR,m_fleps**alf)
      x0=(alf-1d0)/(alf+bet-2d0)
      IF(x0 .GT. xmax) x0=xmax
      x0= max(x0, 0d0)
      q1= 1d0/alf *x0**alf  *(1d0-x0)**(bet-1d0)
      q2= x0**(alf-1d0)     *1d0/bet *( (1d0-x0)**bet -(1d0-xmax)**bet )
      p1= q1/(q1+q2)
      IF( r .LE. p1 ) THEN
         x     = x0*(r/p1)**(1d0/alf)
         dist  = x**(alf-1d0)  *(1d0-x0)**(bet-1d0)
      ELSE
         r1    = (1d0-r)/(1d0-p1)
         x     = (1d0-xmax)**bet + ((1d0-x0)**bet-(1d0-xmax)**bet)*r1
         x     = 1d0 - x**(1d0/bet)
         dist  = x0**(alf-1d0) *(1d0-x)**(bet-1d0)
      ENDIF
      djac=(q1+q2)/dist
      RETURN
  900 WRITE(*,*) ' ========= STOP in BornV_ReBin1: wrong params'
      STOP
      END

      SUBROUTINE BornV_ReBin1a(RR,alf,bet,xmax,x,djac)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   the same as BornV_ReBin1 but pole approximation used                   //
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION RR,R,alf,bet,xmax,x,djac
      DOUBLE PRECISION x0,dist,r1,p1,q1,q2
*------------------------------------------------------------------------------
      IF( alf .LE. 0d0 ) GOTO 900
      R = MAX(RR,m_fleps**alf)
      x0=(alf-1d0)/(alf+bet-2d0)
      IF(x0 .GT. xmax) x0=xmax
      x0= max(x0, 0d0)
      q1= 1d0/alf *x0**alf
      q2= 1d0/bet *( (1d0-x0)**bet -(1d0-xmax)**bet )
      p1= q1/(q1+q2)
      IF( r .LE. p1 ) THEN
         x     = x0*(r/p1)**(1d0/alf)
         dist  = x**(alf-1d0)
      ELSE
         r1    = (1d0-r)/(1d0-p1)
         x     = (1d0-xmax)**bet + ((1d0-x0)**bet-(1d0-xmax)**bet)*r1
         x     = 1d0 - x**(1d0/bet)
         dist  = (1d0-x)**(bet-1d0)
      ENDIF
      djac=(q1+q2)/dist
      RETURN
  900 WRITE(*,*) ' ========= STOP in BornV_ReBin1: wrong params'
      STOP
      END

      SUBROUTINE BornV_ReBin2(RR,alf,bet,x,xm1,djac)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  This mapps variable r into x. xm1=1-x kept because of rounding errors   //
*//  The same as BornV_ReBin1, but xmax=1 and bet>0                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION RR,R,alf,bet,x,xm1,djac
      DOUBLE PRECISION x0,dist,r1,p1,q1,q2
*------------------------------------------------------------------------------
      IF( alf .LE. 0d0 ) GOTO 900
      IF( bet .LE. 0d0 ) GOTO 900
      R = MAX(RR,m_fleps**alf)
      x0=(alf-1d0)/(alf+bet-2d0)
      IF( (x0 .GT. 1d0) .OR. (x0 .LT. 0d0) ) GOTO 900
      x0= max(x0, 0d0)
      q1= 1d0/alf *x0**alf  *(1d0-x0)**(bet-1d0)
      q2= x0**(alf-1d0)     *1d0/bet *(1d0-x0)**bet
      p1= q1/(q1+q2)
      IF( r .LE. p1 ) THEN
         x    = x0*(r/p1)**(1d0/alf)
         dist = x**(alf-1d0)  *(1d0-x0)**(bet-1d0)
         xm1  = 1d0-x
      ELSE
         r1   = (1d0-r)/(1d0-p1)
         r1   = MAX(r1,m_fleps**bet)
         xm1  =(1d0-x0) *r1**(1d0/bet)
         dist = x0**(alf-1d0) *xm1**(bet-1d0)
         x    = 1d0-xm1
      ENDIF
      djac=(q1+q2)/dist
      RETURN
  900 WRITE(*,*) ' ========= STOP in BornV_ReBin2: wrong params'
      STOP
      END

      SUBROUTINE BornV_ReBin2a(RR,alf,bet,x,xm1,djac)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  This mapps variable r into x. xm1=1-x kept because of rounding errors   //
*//  The same as BornV_ReBin2, but xmax=1 and bet>0                          //
*//  and pole approximation is used for crude/simplified distribution.       //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION RR,R,alf,bet,x,xm1,djac
      DOUBLE PRECISION x0,dist,r1,p1,q1,q2
*------------------------------------------------------------------------------
      IF( alf .LE. 0d0 ) GOTO 900
      IF( bet .LE. 0d0 ) GOTO 900
      R = MAX(RR,m_fleps**alf)
      x0=(alf-1d0)/(alf+bet-2d0)
      IF( (x0 .GT. 1d0) .OR. (x0 .LT. 0d0) ) GOTO 900
      x0= max(x0, 0d0)
      q1= 1d0/alf *x0**alf
      q2= 1d0/bet *(1d0-x0)**bet
      p1= q1/(q1+q2)
      IF( r .LE. p1 ) THEN
         x    = x0*(r/p1)**(1d0/alf)
         dist = x**(alf-1d0)
         xm1  = 1d0-x
      ELSE
         r1   = (1d0-r)/(1d0-p1)
         r1   = MAX(r1,m_fleps**bet)
         xm1  = (1d0-x0) *r1**(1d0/bet)
         dist = xm1**(bet-1d0)
         x    = 1d0-xm1
      ENDIF
      djac=(q1+q2)/dist
      RETURN
  900 WRITE(*,*) ' ========= STOP in BornV_ReBin2a: wrong params'
      STOP
      END


      DOUBLE PRECISION FUNCTION BornV_RhoFoamA(xarg)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Integrand for FoamA in 1-dim mode beamstrahlung off/on                     //
*//   !!! DEFINES m_vv !!!!                                                      //
*//                                                                              //
*//   Remember that BornV_Crude and BornV_MakeRho use hidden input  m_XXXene!!   //
*//   BornV_Crude is in R-units (poitnlike xsection at  sqrt(s)=m_XXXene!        //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  xarg(10)
      DOUBLE PRECISION  R
      DOUBLE PRECISION  Rho,BornV_Crude
      DOUBLE PRECISION  gamiCR, gami, beta, RJac
      DOUBLE PRECISION  IRC_circee
*----------------------------------------
      R  = xarg(1)
      m_x1 = 0d0
      m_x2 = 0d0
*-----------------------------------------------
      m_XXXene =  m_CMSene        ! hidden input for BornV_Crude
      CALL BornV_MakeGami(m_XXXene,gamiCR,gami)
      IF( gamiCR .LE. 0d0 ) GOTO 800
*     Mapping  r => vv change  to improve on efficiency
      m_vv  = R**(1d0/gamiCR)*m_vvmax
      RJac  = m_vv/R/gamiCR*m_vvmax
      CALL BornV_MakeISR(Rho)                  !<-- uses m_XXXene and m_vv
      Rho = Rho*RJac
*----------------------------------------
      Rho = Rho *IRC_circee(1d0,1d0)           !<-- implicit factor from circee 
*----------------------------------------
* Born Xsection at s' = m_XXXene**2 *(1-vv)
      IF(m_KeyZet .EQ. -2) THEN   ! Artificial constant x-section for test runs
         BornV_RhoFoamA = Rho* BornV_Crude(0d0)
      ELSE                        ! 1/(1-vv) because BornV_Crude is in R-units
         BornV_RhoFoamA = Rho* BornV_Crude(m_vv)/(1d0-m_vv)
      ENDIF
      RETURN
 800  CONTINUE
      BornV_RhoFoamA =0d0
      END

      DOUBLE PRECISION FUNCTION BornV_RhoFoamB(xarg)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Integrand for FoamB in 2-dim mode for beamstrahlung                        //
*//                                                                              //
*//   Remember that BornV_Crude and BornV_MakeRho use hidden input  m_XXXene!!   //
*//   BornV_Crude is in R-units (poitnlike xsection at  sqrt(s)=m_XXXene!        //
*//                                                                              //
*//                                                                              //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  xarg(10)
      DOUBLE PRECISION  R,r1
      DOUBLE PRECISION  Rho,BornV_Crude,IRC_circee
      DOUBLE PRECISION  gamiCR, gami, beta, RJac0, RJac1, RJacS
      DOUBLE PRECISION  alpha,  alpha2,  eps,  eps2
      DOUBLE PRECISION  GamBig, RhoISR, SF1, XX, yisr, ybms, z1, aa
      DOUBLE PRECISION  anor, xnor
      DOUBLE PRECISION  Par(0:3)
      INTEGER Option
      INTEGER           Icont
      DATA              Icont/0/
      Icont = Icont+1
*//////////////////////////////////////////////////////////////////////////////////////
*//  gamiCR, alpha, beta are dummy parameters in variable transformations
*//  they can be varied by 25% or so and weight distribution will be exactly the same!
*//  grid will absorb their variations.
      CALL IRC_GetParamee (Par) ! dee(z) = Par(1) *z1**Par(2)  *(1-z1)**Par(3), z1=1-x1
****  IF(Icont.LE.1) WRITE(*,*) ' Par(i)= ', Par(0), Par(1),Par(2),Par(3)
      alpha =  0.40d0           ! beamsstrahl: x1**(alpha-1), alpha manualy adjusted
      alpha =  Par(3)+1d0
      beta  = -0.50d0           ! ISR crude is as (1-vv)**(-1.5)=(1-vv)**(beta-1)
*//////////////////////////////////////////////////////////////////////////////////////
      R    = xarg(1)
      r1   = xarg(2)
      m_x2 = 0d0
      Rho  = 1d0
      Option = 3                ! Option = 3 for tests of normalization only
      Option = 1                ! Option = 1 not so good as it may seem
      Option = 2                ! Option = 2 the best!!
      IF( Option .EQ. 1 ) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   (over)complicated analytical importance sampling transformations
*//   R --> XX,   ZZ=1-XX=(1-vv)*(1-x1)= total loss factor, ISR and beamsstrahlung
         CALL BornV_MakeGami(m_CMSene,gamiCR,gami)          ! make gamiCR at CMSene
         IF( gamiCR .LE. 0d0 ) GOTO 800
         GamBig = gami+alpha                                ! total singularity at XX=0
         CALL BornV_ReBin1a(R,GamBig,beta,m_vvmax,XX,RJac0) ! Mapping  R => XX
         Rho = Rho *RJac0
*//   r1 --> m_vv
         IF( gamiCR .LE. 0d0 ) GOTO 800
         CALL BornV_ReBin2a(r1, gami, alpha, yisr, ybms, RJac1) ! Mapping  r1 => m_vv
         m_vv =  yisr* XX
         m_x1 =  ybms* XX/(1d0-yisr*XX)
         Rho  =  Rho  *XX/(1d0-yisr*XX) *RJac1
         IF( m_x1 .GE. 1d0) GOTO 900
*//////////////////////////////////////////////////////////////////////////////////////
*//   simplified analytical importance sampling transformations
      ELSEIF( Option .EQ. 2 ) THEN
         CALL BornV_MakeGami(m_CMSene,gamiCR,gami)           ! make gamiCR at CMSene
         IF( gamiCR .LE. 0d0 ) GOTO 800
         m_vv  = R**(1d0/gamiCR)*m_vvmax
         Rho   = Rho* m_vv/R/gamiCR*m_vvmax
         m_x1  = r1**(1d0/alpha)                             ! Mapping  r1 => x1
         Rho   = Rho *m_x1/r1/alpha
         IF( (1d0-m_vv)*(1d0-m_x1) .LT. (1d0-m_vvmax) ) GOTO 800
      ELSEIF( Option .EQ. 3 ) THEN
*//   primitive test options, usefull for checking normalization
         m_vv = R*m_vvmax
         Rho = Rho *m_vvmax
         m_x1  = r1
         IF( (1d0-m_vv)*(1d0-m_x1) .LT. (1d0-m_vvmax) ) GOTO 800
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//   Calculate ISR crude structure function (the same as in Karlud)
      m_XXXene =  m_CMSene*SQRT(1d0-m_x1)              ! hidden input for BornV_Crude
      CALL BornV_MakeISR(RhoISR)                       !<-- uses m_XXXene and m_vv
      Rho = Rho *RhoISR
*//////////////////////////////////////////////////////////////////////////////////////
*//   Beamsstrahlung structure function, singular as m_x1**(alpha-1)
      z1 = 1d0-m_x1
      IF( (z1.EQ.1d0) .OR. (m_x1.EQ.0d0) ) THEN ! rounding errors may cause problems
         SF1 = 0d0
      ELSE
*****    SF1 = 2d0 *IRC_circee( z1, 1d0 )   ! factor 2 due to implicit symmetrization x1<-->x2
*****    SF1 = 2d0 *Par(0) *Par(1) *m_x1**Par(3)               ! truncated
         SF1 = 2d0 *Par(0) *Par(1) *m_x1**Par(3) *z1**Par(2)   ! the same as circee
      ENDIF
      Rho = Rho *SF1
*//////////////////////////////////////////////////////////////////////////////////////
*//   Born Xsection at s' =m_XXXene**2 *(1-vv) =m_CMSene**2 *(1-XX)
      BornV_RhoFoamB = Rho* BornV_Crude(m_vv)/(1d0-m_vv)
      RETURN
 800  CONTINUE
      BornV_RhoFoamB =0d0
      RETURN
 900  CONTINUE
      WRITE(*,*) ' STOP in BornV_RhoFoamB, m_x1 = ', m_x1
      WRITE(*,*) ' XX, m_vv= ', XX, m_vv
      STOP
      END                       ! BornV_RhoFoamB

      DOUBLE PRECISION FUNCTION BornV_RhoFoamC(xarg)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Integrand for FoamC in 3-dim mode for beamstrahlung                        //
*//                                                                              //
*//   Remember that BornV_Crude and BornV_MakeRho use hidden input  m_XXXene!!   //
*//   BornV_Crude is in R-units (poitnlike xsection at  sqrt(s)=m_XXXene!        //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  xarg(10)
      DOUBLE PRECISION  R,r1,r2
      DOUBLE PRECISION  Power,Jacob,sf12
      DOUBLE PRECISION  Rho,BornV_Crude,IRC_circee
      DOUBLE PRECISION  z1, z2, XX, RhoISR, gamiCR, gami, beta, GamBig, alpha, alpha2
      DOUBLE PRECISION  Rjac0, Rjac1, Rjac2
      DOUBLE PRECISION  zbms, zisr, y1,y2, ybms,yisr, xbms,xisr
      DOUBLE PRECISION  Par(0:3)
      INTEGER Option
      INTEGER           Icont
      DATA              Icont/0/
      Icont = Icont+1
*//////////////////////////////////////////////////////////////////////////////////////
*//  gamiCR, alpha, beta are dummy parameters in variable transformations
*//  they can be varied by 25% or so and weight distribution will be exactly the same!
*//  grid will absorb their variations.
      CALL IRC_GetParamee (Par) ! dee(z) = Par(1) *z1**Par(2)  *(1-z1)**Par(3), z1=1-x1
****  IF(Icont.LE.1) WRITE(*,*) ' Par(i)= ', Par(0), Par(1),Par(2),Par(3)
      alpha =  0.40d0           ! beamsstrahl: x1**(alpha-1), alpha manualy adjusted
      alpha =  Par(3)+1d0
      beta  = -0.50d0           ! ISR crude is as (1-vv)**(-1.5)=(1-vv)**(beta-1)
*//////////////////////////////////////////////////////////////////////////////////////
      R    = xarg(1)
      r1   = xarg(2)
      r2   = xarg(3)
      Rho  = 1d0
      Option = 1                ! Option = 1, not so good as it may seem!!!
      Option = 2                ! Option = 2 the best
      IF( Option .EQ. 1 ) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   R --> XX,   ZZ=1-XX=(1-vv)*(1-x1)= total loss factor, ISR and beamsstrahlung
         CALL BornV_MakeGami(m_CMSene,gamiCR,gami)          ! make gamiCR at CMSene
         IF( gamiCR .LE. 0d0 ) GOTO 800
         GamBig = gami+2d0*alpha                            ! total singularity at XX=0
         CALL BornV_ReBin1a(R,GamBig,beta,m_vvmax,XX,RJac0) ! Mapping  R => XX=1-ZZ
         Rho = Rho *RJac0
*//   r1 --> m_vv
         alpha2 = 2d0*alpha
         CALL BornV_ReBin2a(r1, gami, alpha2, yisr, ybms, RJac1) ! Mapping  r1 => m_vv
         xisr = yisr *XX
         xbms = ybms *XX/(1d0-yisr*XX)
         Rho  = Rho  *XX/(1d0-yisr*XX) *RJac1
         zisr = 1d0-xisr
         zbms = 1d0-xbms
         m_vv = xisr
*//   r2 --> m_x2
         CALL BornV_ReBin2a(r2, alpha, alpha, y1, y2, RJac2) ! Mapping  r2 => m_x2
         m_x1 =   y1*xbms
         m_x2 =   y2*xbms/(1d0-y1*xbms)
         Rho  = Rho *xbms/(1d0-y1*xbms) *RJac2 
*//////////////////////////////////////////////////////////////////////////////////////
*//   simplified analytical importance sampling transformations
      ELSEIF( Option .EQ. 2 ) THEN
         CALL BornV_MakeGami(m_CMSene,gamiCR,gami)           ! make gamiCR at CMSene
         IF( gamiCR .LE. 0d0 ) GOTO 800
cc         CALL BornV_ReBin1a(R,gamiCR,beta,m_vvmax,m_vv,RJac0) ! Mapping  R => vv
cc         Rho = Rho *RJac0
         m_vv  = R**(1d0/gamiCR)*m_vvmax
         Rho   = Rho* m_vv/R/gamiCR*m_vvmax
         m_x1  = r1**(1d0/alpha)                             ! Mapping  r1 => x1
         Rho   = Rho   *m_x1/r1/alpha
         m_x2  = r2**(1d0/alpha)                             ! Mapping  r2 => x2
         Rho = Rho   *m_x2/r2/alpha
         IF( (1d0-m_vv)*(1d0-m_x1)*(1d0-m_x2) .LT. (1d0-m_vvmax) ) GOTO 800
      ENDIF
      z1 = 1d0-m_x1
      z2 = 1d0-m_x2
*//////////////////////////////////////////////////////////////////////////////////////
*//   Calculate ISR crude structure function (the same as in Karlud)
      m_XXXene =  m_CMSene*SQRT(z1*z2)                   ! hidden input for BornV_Crude
      CALL BornV_MakeISR(RhoISR)                         !<-- uses m_XXXene and m_vv
      Rho = Rho *RhoISR
*//////////////////////////////////////////////////////////////////////////////////////
*//   Beamsstrahlung structure function, singular as m_x1**(alpha-1)
      IF( (z1.EQ.1d0) .OR. (z2.EQ.1d0) ) THEN ! rounding errors may cause problems
         SF12 = 0d0
      ELSE
***      SF12 = IRC_circee( z1, z2 )
         SF12 = Par(1) *m_x1**Par(3) *z1**Par(2)   *Par(1) *m_x2**Par(3) *z2**Par(2)
***      SF12 = Par(1) *m_x1**Par(3)               *Par(1) *m_x2**Par(3)    ! Truncated
      ENDIF
      Rho = Rho *SF12

* Born Xsection at s' = m_XXXene**2 *(1-vv)
      BornV_RhoFoamC = Rho*BornV_Crude(m_vv)/(1d0-m_vv)
      RETURN
 800  CONTINUE
      BornV_RhoFoamC =0d0
      RETURN
 900  CONTINUE
      WRITE(*,*) ' STOP in BornV_RhoFoamC, m_x1 = ', m_x1
      WRITE(*,*) ' XX, m_vv= ', XX, m_vv
      STOP
      END

      DOUBLE PRECISION  FUNCTION BornV_RhoVesko1(R)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Integrand of Vesko, dSigma/dV(V)*Jacobians function of R                   //
*//   !!!! DEFINES m_vv !!!!                                                     //
*//                                                                              //
*//   Remember that BornV_Crude and BornV_MakeRho use hidden input  m_XXXene!!   //
*//   BornV_Crude is in R-units (poitnlike xsection at  sqrt(s)=m_XXXene!        //
*//                                                                              //
*//   In  the case of beamsstrahlung additional normalization                    //
*//   factor circee(1d0,1d0) is added in BStra_Initialize                        //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION   R,Rho, BornV_Crude
      DOUBLE PRECISION   gamiCR, gami, beta, RJac
*-----------------------------------------------
      m_XXXene =  m_CMSene                 ! hidden input for BornV_Crude
*-----------------------------------------------
      CALL BornV_MakeGami(m_XXXene,gamiCR,gami)
      IF( gamiCR .LE. 0d0 ) GOTO 800
*     Mapping  r => vv change  to improve on efficiency
      beta = -0.5d0
      CALL BornV_ReBin1(R,gamiCR,beta,m_vvmax,m_vv,RJac)
      CALL BornV_MakeISR(Rho)              ! uses m_XXXene and m_vv
      Rho = Rho*RJac
*-----------------------------------------------
* Translate R into m_vv and get QED (crude) density Rho
***** CALL BornV_MakeRho(R,Rho)
*-----------------------------------------------
* Born Xsection at s' = m_XXXene**2 *(1-vv)
      IF(m_KeyZet .EQ. -2) THEN   ! Artificial constant x-section for test runs
         BornV_RhoVesko1 = Rho* BornV_Crude(0d0)
      ELSE                        ! 1/(1-vv) because BornV_Crude is in R-units
         BornV_RhoVesko1 = Rho* BornV_Crude(m_vv)/(1d0-m_vv)
      ENDIF
      RETURN
 800  CONTINUE
      BornV_RhoVesko1 =0d0
      END

      SUBROUTINE BornV_SetCMSene(CMSene)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  CMSene
*
      m_CMSene = CMSene
      END

      SUBROUTINE BornV_SetGSW(GSW)
*//////////////////////////////////////////////////////////////////////////
*//
*//  For special tests of pretabulation GSW values can be set form outside
*//
*//////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE COMPLEX    GSW(*)
      INTEGER      k
*     ---------------------------------------------------------------------
      DO k=1,7
          m_GSW(k) =GSW(k)
      ENDDO
      END


      SUBROUTINE BornV_SetKeyElw(KeyElw)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KeyElw
*
      m_KeyElw = KeyElw
      END

      SUBROUTINE BornV_SetKeyZet(KeyZet)
*//////////////////////////////////////////////////////////////////////////////
*//   for tests only                                                         //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      INTEGER KeyZet
*
      m_KeyZet = KeyZet
      END

      SUBROUTINE BornV_SetMZ(MZ)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION  MZ
*------------------
      m_MZ = MZ
      END

      SUBROUTINE BornV_SetQCDcor(QCDcor)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Set QCD correction factor, for tests of pretabulation                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION    QCDcor
*------------------
      m_QCDcor = QCDcor
      END


      DOUBLE PRECISION  FUNCTION BornV_Sig0nb(CMSene)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  provides pointlike muon x-section in nanobarns                          //
*//  for normalization purpose                                               //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
      DOUBLE PRECISION   pi
      PARAMETER (pi =3.1415926535897932d0)
      DOUBLE PRECISION  CMSene
*---------------------------------
      BornV_Sig0nb =  4d0*pi/(m_AlfInv**2*3d0*CMSene**2)*m_gnanob
      END ! BornV_Sig0nb


      DOUBLE PRECISION  FUNCTION BornV_Simple(KFi,KFf,svar,costhe)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*// This routine provides unsophisticated Born differential cross section     //
*// at the crude x-section level, with Z and gamma s-chanel exchange.         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BornV.h'
*
      INTEGER KFi,KFf
      DOUBLE PRECISION   svar,costhe
*
      DOUBLE PRECISION   ss,T3e,Qe,deno,Ve,Ae
      DOUBLE PRECISION   ye,yf,xf,rechi,xe,amx2
      DOUBLE PRECISION   thresh,ff0,ff1,chi2
      DOUBLE PRECISION   t3f,amfin,af,vf,born,sum,qf
      DOUBLE PRECISION   BWD
      INTEGER NCF
*----------------------
      ss = svar
* Z and gamma couplings to beams (electrons)
      T3e = m_T3f(KFi)  ! isospin, L-hand component
      Qe  = m_Qf( KFi)  ! electric charge

      deno= 4d0*sqrt(m_swsq*(1d0-m_swsq))
      Ve  = (2*T3e -4*Qe*m_swsq)/deno
      Ae  =  2*T3e              /deno

      NCf   = m_NCf(KFf)        ! number of colours
      T3f   = m_T3f(KFf)        ! isospin, L-hand component
      Qf    = m_Qf( KFf)        ! electric charge
      deno  = 4d0*sqrt(m_swsq*(1d0-m_swsq))
      Vf    = (2*T3f -4*Qf*m_swsq)/deno
      Af    =  2*T3f              /deno
* Switch off Z or gamma
      IF(m_KeyZet .EQ. 0) THEN
         Ve=0d0
         Ae=0d0
      ENDIF
      IF(m_KeyZet .EQ. 9) THEN
         Qe=0d0
         Qf=0d0
      ENDIF
c[[   BWD = (ss-m_MZ**2)**2 + (m_gammz*m_MZ)**2   !!! <-- old
      BWD = (ss-m_MZ**2)**2 + (m_gammz*ss/m_MZ)**2
      chi2 = ss**2          /BWD
      rechi=(ss-m_MZ**2)*ss /BWD
      xe= Ve**2 +Ae**2
      xf= Vf**2 +Af**2
      ye= 2*Ve*Ae
      yf= 2*Vf*Af
      ff0= qe**2*qf**2 +2*rechi*qe*qf*Ve*Vf +chi2*xe*xf
      ff1=             +2*rechi*qe*qf*Ae*Af +chi2*ye*yf
      Born    = (1d0+ costhe**2)*ff0 +2d0*costhe*ff1
*     Colour factor
      Born = NCf*Born
      IF( ABS(costhe) .GT. 1d0) WRITE(*,*) '----> BornV: costhe=',costhe
* This is a bit crude method of introducing threshold behaviour
* cos(theta) depencence incorrect!!!
      amfin = m_amferm(KFf)     ! mass
      IF(    svar .LE.  4d0*amfin**2) THEN
         thresh=0d0
      ELSEIF(svar .LE. 16d0*amfin**2) THEN
         amx2=4d0*amfin**2/svar
         thresh=sqrt(1d0-amx2)*(1d0+amx2/2d0)
      ELSE
         thresh=1d0
      ENDIF
      Born= Born*thresh
      BornV_Simple = Born
      END

      SUBROUTINE BStra_Finalize(Integ,Errel)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Provides Crude integral at the end of MC generation based on <wt>      //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION     Integ,Errel
      DOUBLE PRECISION     IntegMC,ErrelMC
      DOUBLE PRECISION     AverWt, WtSup
*-----------------------------------------------------------------------------
      CALL MBrB_MgetAve(AverWt, ErRelMC, WtSup)
      IntegMC= m_XCrude*AverWt
      Integ  = IntegMC
      ErRel  = ErRelMC
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  BStra  Finalize MC results     '
      WRITE(m_out,bxl1g) IntegMC,   'MC integral   ','IntegMC','**'
      WRITE(m_out,bxl1f) ErRelMC,   'relat. error  ','ErRelMC','**'
      WRITE(m_out,bxl1f) WtSup,     'maximum wt    ','WtSup  ','**'
      WRITE(m_out,bxtxt) '  From grid building (initializ.)'  
      WRITE(m_out,bxl1g) m_XGridB,   'XGridB  total.    ','XGridB','**'
      WRITE(m_out,bxl1f) m_EGridB,   'EGridB, rel. total','EGridB','**'
      WRITE(m_out,bxclo)
* Print more on the main weight
      CALL MBrB_Print0
* Print even more on the weight in each branch!
      CALL MBrB_Print1
      END       ! BStra_Finalize

      SUBROUTINE BStra_GetAveWt(AveWt,RatWt)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      DOUBLE PRECISION     AveWt,RatWt
      DOUBLE PRECISION     AverWt, ErRela, WtSup
*-----------------------------------------------------------------------------
      CALL MBrB_MgetAve(AverWt, ErRela, WtSup)
      AveWt = AverWt
      RatWt = AverWt/WtSup
      END

      SUBROUTINE BStra_GetIntegMC(IntegMC,ErRelMC)
*//////////////////////////////////////////////////////////////////////////////////////
*//   Get TRUE Monte Carlo run Integral and errors                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      DOUBLE PRECISION     IntegMC,ErRelMC
      DOUBLE PRECISION     AverWt,WtSup
      CALL MBrB_MgetAve(AverWt, ErRelMC, WtSup)
      IntegMC= m_XCrude*AverWt
      END                       ! BStra_GetIntegMC

      SUBROUTINE BStra_GetXCrude(XCrude)
*//////////////////////////////////////////////////////////////////////////////////////
*//   Get TRUE crude integraml                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      DOUBLE PRECISION   XCrude
      XCrude   = m_XCrude
      END                       ! BStra_GetXCrude

      SUBROUTINE BStra_GetXGridB(XGridB,EGridB)
*//////////////////////////////////////////////////////////////////////////////////////
*//   Get TRUE crude integram                                                        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      DOUBLE PRECISION     XGridB,EGridB
      XGridB   = m_XGridB
      EGridB   = m_EGridB
      END                       ! BStra_GetXGridB




*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                End  Pseudo-CLASS  Mathlib                                //
*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//          Pseudoclass BStra                                                       //
*//                                                                                  //
*//                                                                                  //
*//   Foam is now the basic MC sampler for beamstrahlung and ISR.                    //
*//   Switching among Foam and Vegas done with KeyGrid, KeyFix and Mode.             //
*//   Vegas is obsolete. Most probably it will be remooved in future.                //
*//   Vegas is about factor 10 less effective than Foam.                             //
*//                                                                                  //
*//   Notes on Vegas:                                                                //
*//   Initialization of 3 copies of Vegas for beamsstrahlung is rather slow.         //
*//   so there is an option of writing grid in local directory.                      //
*//   This is essentialy only for tests when one needs to do many short runs.        //
*//   Variable m_Mode manages this option.                                           //
*//   m_Mode =  0 is default, grid is created and used, no dumping on disk           //
*//   m_Mode = -1 grid is created and dumped in local directory                      //
*//   m_Mode = +1 grid is read from local directory                                  //
*//   WARNING: m_Mode .NE. 0 is usefull but dangerous, use it with care!!!           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE BStra_Initialize(KeyGrid,Xcrude)
*//////////////////////////////////////////////////////////////////////////////////////
*//   Initialization phase                                                           //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      INCLUDE 'BXformat.h'
      INTEGER            KeyGrid
      DOUBLE PRECISION   XCrude
      INTEGER  k,j
      DOUBLE PRECISION   XsCru(10), WMList(10)
      DOUBLE PRECISION   XsectA, XsectB,  XsectC
      DOUBLE PRECISION   ErrelA,  ErrelB,  ErrelC
      DOUBLE PRECISION   BornV_RhoFoamA, BornV_RhoFoamB, BornV_RhoFoamC
      EXTERNAL           BornV_RhoFoamA, BornV_RhoFoamB, BornV_RhoFoamC
      DOUBLE PRECISION   XXXene, vvmax
      INTEGER            nCallsA,  nCallsB,  nCallsC
      INTEGER            IterMaxA, IterMaxB, IterMaxC,  Idyfs,  IdBra, Nbin
*-------------------------------
      m_out     = 6
      m_Nevgen  =  0
*//////////////////////////////////////////////////////////////////////////////////////
*//            Creating 3 grids with 3 copies of Vegas                               //
*// Mode=-1 creation+dump, =+1 reading, =0 creation without dump (default)           //
*//////////////////////////////////////////////////////////////////////////////////////
      m_ModeA  =   KeyGrid
      m_ModeB  =   KeyGrid
      m_ModeC  =   KeyGrid
*
***      m_ModeA  =  1            ! test, vegas
***      m_ModeB  =  1            ! test, vegas
***      m_ModeC  =  1            ! test, vegas
*
      CALL KarLud_GetXXXene(XXXene)
      IF(     XXXene. LT. 250d0) THEN    ! Vegas; 200 GeV, vvmax = 0.9999
         WMList(1) = 1.5d0
         WMList(2) =  20d0
         WMList(3) =  30d0
      ELSEIF( XXXene. LT. 600d0) THEN    ! Vegas; 350 Gev and 500GeV, vvmax = 0.9999
         WMList(1) = 1.5d0
         WMList(2) =  25d0
         WMList(3) =  50d0
      ELSE                               ! Vegas; 800 GeV, vvmax = 0.9999
         WMList(1) = 1.5d0
         WMList(2) =  25d0
         WMList(3) =  50d0
      ENDIF
*
      IF(m_ModeA.EQ.2) WMList(1) = 1.00d0
      IF(m_ModeB.EQ.2) WMList(2) = 1.00d0
      IF(m_ModeC.EQ.2) WMList(3) = 1.00d0
*
      CALL KarLud_Getvvmax(vvmax)
      IF( XXXene.GT.1d3 ) THEN
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '**** BStra_Initialize: WARNING,  adjust WMList manualy !!!  ****'
         WRITE(*,*) '*****************************************************************'
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
      XsectA   = 1d-100
      XsectB   = 1d-100
      XsectC   = 1d-100
      ErrelA   = 1d0
      ErrelB   = 1d0
      ErrelC   = 1d0
*//////////////////////////////////////////////////////////////////////////////////////
*//   1-dimensional case                                                             //
*//////////////////////////////////////////////////////////////////////////////////////
      IF( m_ModeA .LE. 0) THEN
         WRITE(*,*) '  '
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT VEGAS CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '****** ............. BStra_Initialize: Creating grid A  *********'
         WRITE(*,*) '*****************************************************************'
         CALL VegasA_Initialize            ! basic initialization
         CALL VegasA_SetnDim(     1)       ! redefine nDim
*****    CALL VegasA_SetPriLev(  -1)       ! printout level
         nCallsA  =  100000                ! No of calls for VegasA
         IterMaxA = 4                      ! No of iterations
         CALL VegasA_SetnCall(    nCallsA) ! maximum number of function calls
         CALL VegasA_SetIterMax( IterMaxA) ! maximum iterations
         CALL VegasA_SetAccur(   0d0)      ! requested accuracy
         CALL VegasA_Make(BornV_RhoFoamA)  ! make grid and calculate integral
*   In special cases we require writing grid into disk
         IF( m_ModeA .EQ. -1) THEN
            WRITE(*,*) '|||||||----||||||||  BStra_Initialize: dumping VegasA.grid '
            OPEN(11,FILE='./VegasA.grid')
            CALL VegasA_Dump(11)
            CLOSE(11)
            WRITE(m_out,bxtxt) '   VegasA.grid Written into disk   '
         ENDIF
*     In special cases we require reading grid from disk
      ELSEIF( m_ModeA .EQ. 1) THEN
         WRITE(*,*) '|||||||++++||||||||  BStra_Initialize: Reading VegasA.grid '
         OPEN(11,FILE='./VegasA.grid')
         CALL VegasA_Restore(11)
         CLOSE(11)
         WRITE(m_out,bxtxt) '   VegasA.grid Read form disk      '
      ELSEIF( m_ModeA .EQ. 2) THEN
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT FoamA CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '*****************************************************************'
         CALL FoamA_SetNdim(       1) ! No of dimensions<5
         CALL FoamA_SetIterat(     0) ! No. of iterations, =0 alowed
         CALL FoamA_SetnBuf(    2000) ! Length of buffer<5000,  =Maximum No. of cells
         CALL FoamA_SetnSampl(   200) ! No. of MC sampling inside single cell, default=100
         CALL FoamA_SetOptEdge(    1) ! OptEdge excludes vertices
         CALL FoamA_SetChat(       1) ! printout level =0,1,2
         CALL FoamA_Initialize(BornV_RhoFoamA)
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//   2-dimensional case                                                             //
*//////////////////////////////////////////////////////////////////////////////////////
      IF( m_ModeB .LE. 0) THEN
         WRITE(*,*) '  '
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT VEGAS CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '****** ............. BStra_Initialize: Creating grid B  *********'
         WRITE(*,*) '*****************************************************************'
         CALL VegasB_Initialize            ! basic initialization
         CALL VegasB_SetnDim(     2)       ! redefine nDim
*****    CALL VegasB_SetPriLev(  -1)       ! printout level
         nCallsB  =  400000                ! No of calls for VegasB (4min)
         IterMaxB = 4                      ! No of iterations
         CALL VegasB_SetnCall(    nCallsB) ! maximum number of function calls
         CALL VegasB_SetIterMax( IterMaxB) ! maximum iterations
*****    CALL VegasB_SetnBinReq( 100)
         CALL VegasB_SetAccur(   0d0)      ! requested accuracy
         CALL VegasB_Make(BornV_RhoFoamB)  ! make grid and calculate integral
*   In special cases we require writing grid into disk
         IF( m_ModeB .EQ. -1) THEN
            WRITE(*,*) '|||||||----||||||||  BStra_Initialize: dumping VegasB.grid '
            OPEN(11,FILE='./VegasB.grid')
            CALL VegasB_Dump(11)
            CLOSE(11)
            WRITE(m_out,bxtxt) '   VegasB.grid Written into disk   '
         ENDIF
      ELSEIF( m_ModeB .EQ. 1) THEN
         WRITE(*,*) '|||||||++++||||||||  BStra_Initialize: Reading VegasB.grid '
         OPEN(11,FILE='./VegasB.grid')
         CALL VegasB_Restore(11)
         CLOSE(11)
         WRITE(m_out,bxtxt) '   VegasB.grid Read form disk      '
      ELSEIF( m_ModeB .EQ. 2) THEN
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT FoamB CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '*****************************************************************'
         CALL FoamB_SetNdim(       2) ! No of dimensions<5
         CALL FoamB_SetIterat(     0) ! No. of iterations, =0 alowed
         CALL FoamB_SetnBuf(    5000) ! Length of buffer<5000,  =Maximum No. of cells
         CALL FoamB_SetnSampl(  1000) ! No. of MC sampling inside single cell, default=100
         CALL FoamB_SetOptEdge(    1) ! OptEdge excludes vertices
         CALL FoamB_SetChat(       1) ! printout level =0,1,2
         CALL FoamA_SetOptBeta(    2) ! type of Cell division, default=0, 2 is also OK
         CALL FoamB_Initialize(BornV_RhoFoamB)
* Debug plotting; nbuf=250 is maximum for ploting cell boundries
         CALL FoamB_PltBegin
         CALL FoamB_PltVert(16)
c         CALL FoamB_PltCell(16) ! nbuf<250
         CALL FoamB_PltEnd
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//   3-dimensional case                                                             //
*//////////////////////////////////////////////////////////////////////////////////////
      IF( m_ModeC .LE. 0) THEN
         WRITE(*,*) '  '
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT VEGAS CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '****** ............. BStra_Initialize: Creating grid C  *********'
         WRITE(*,*) '*****************************************************************'
         CALL VegasC_Initialize            ! basic initialization
         CALL VegasC_SetnDim(     3)       ! redefine nDim
*****    CALL VegasC_SetPriLev(  -1)       ! printout level
         nCallsC  = 1600000                ! No of calls for VegasC (14min)
         IterMaxC = 3                      ! No of Iterations
         CALL VegasC_SetnCall(    nCallsC) ! maximum number of function calls
         CALL VegasC_SetIterMax( IterMaxC) ! maximum iterations
         CALL VegasC_SetAccur(  0d0)       ! requested accuracy
         CALL VegasC_Make(BornV_RhoFoamC) ! make grid and calculate integral
*   In special cases we require writing grid into disk
         IF( m_ModeC .EQ. -1) THEN
            WRITE(*,*) '|||||||----||||||||  BStra_Initialize: dumping VegasC.grid '
            OPEN(11,FILE='./VegasC.grid')
            CALL VegasC_Dump(11)
            CLOSE(11)
            WRITE(m_out,bxtxt) '   VegasC.grid Written into disk   '
         ENDIF
      ELSEIF( m_ModeC .EQ. 1) THEN
         WRITE(*,*) '|||||||++++||||||||  BStra_Initialize: Reading VegasC.grid '
         OPEN(11,FILE='./VegasC.grid')
         CALL VegasC_Restore(11)
         CLOSE(11)
         WRITE(m_out,bxtxt) '   VegasC.grid Read form disk      '
      ELSEIF( m_ModeC .EQ. 2) THEN
         WRITE(*,*) '*****************************************************************'
         WRITE(*,*) '****** BE PATIENT FoamC CREATING GRID FOR BEAMSTRAHLUNG *********'
         WRITE(*,*) '*****************************************************************'
         CALL FoamC_SetNdim(       3) ! No. of dimensions<5
         CALL FoamC_SetIterat(     0) ! No. of iterations, =0 alowed
         CALL FoamC_SetnBuf(    5000) ! Length of buffer<5000,  =Maximum No. of cells
         CALL FoamC_SetnSampl(  1000) ! No. of MC sampling inside single cell, default=100
         CALL FoamC_SetOptEdge(    1) ! OptEdge excludes vertices
         CALL FoamC_SetChat(       1) ! printout level =0,1,2
         CALL FoamA_SetOptBeta(    2) ! type of Cell division, default=0, 2 is also OK
         CALL FoamC_Initialize(BornV_RhoFoamC)
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//   The best Vegas Integral estimators from initialization (grid building) phase   //
*//////////////////////////////////////////////////////////////////////////////////////
      IF(     m_ModeA .LE. 1) THEN
         CALL VegasA_GetIntegral(XsectA,ErrelA) ! best integral value from Initialization
         ErrelA  = ErrelA/XsectA
      ELSEIF( m_ModeA .EQ. 2) THEN
         CALL FoamA_GetIntegral( XsectA,ErrelA) ! Integral estimate from Initialization
         ErrelA  = ErrelA/XsectA
      ENDIF
      IF(     m_ModeB .LE. 1) THEN
         CALL VegasB_GetIntegral(XsectB,ErrelB) ! get best integral value
         ErrelB  = ErrelB/XsectB
      ELSEIF( m_ModeB .EQ. 2) THEN
         CALL FoamB_GetIntegral( XsectB,ErrelB) ! Integral estimate from Initialization
         ErrelB  = ErrelB/XsectB
      ENDIF
      IF(     m_ModeC .LE. 1) THEN
         CALL VegasC_GetIntegral(XsectC,ErrelC) ! get best integral value
         ErrelC  = ErrelC/XsectC
      ELSEIF( m_ModeC .EQ. 2) THEN
         CALL FoamC_GetIntegral( XsectC,ErrelC) ! Integral estimate from Initialization
         ErrelC  = ErrelC/XsectC
      ENDIF
      m_XGridB =  XsectA+XsectB+XsectC
      m_EGridB =  DSQRT( (ErrelA*XsectA)**2 +(ErrelB*XsectB)**2 +(ErrelC*XsectC)**2)
      m_EGridB =  m_EGridB/m_XGridB
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  BStra  Initializator                '
      WRITE(m_out,bxtxt) '  Grid initialization finished        '
      WRITE(m_out,bxl1g) XsectA ,    'XsectA  1-dimen.  ','XsectA','**'
      WRITE(m_out,bxl1g) XsectB ,    'XsectB  2-dimen.  ','XsectB','**'
      WRITE(m_out,bxl1g) XsectC ,    'XsectC  3-dimen.  ','XsectC','**'
      WRITE(m_out,bxl1f) ErrelA  ,   'ErrelA  1-dimen.  ','ErrelA','**'
      WRITE(m_out,bxl1f) ErrelB  ,   'ErrelB  2-dimen.  ','ErrelB','**'
      WRITE(m_out,bxl1f) ErrelC  ,   'ErrelC  3-dimen.  ','ErrelC','**'
      WRITE(m_out,bxl1g) m_XGridB,   'XGridB  total.    ','XGridB','**'
      WRITE(m_out,bxl1f) m_EGridB,   'EGridB, rel. total','EGridB','**'
      WRITE(m_out,bxclo)
*//////////////////////////////////////////////////////////////////////////////////////
*//            Prepare MC simulation                                                 //
*//     Calculate Crude Xcru(i), i=1,2,3,  branch per branch                         //
*//////////////////////////////////////////////////////////////////////////////////////
      WRITE(*,*) '<<<<<<<oooo>>>>>>>>  BStra_Initialize: Prepare simulation '
      IF( m_ModeA .LE. 1) THEN
         CALL VegasA_PreGenerate           ! prepare generation
         CALL VegasA_GetIntCrude(XsCru(1)) ! get crude normalization for MC
      ELSEIF( m_ModeA .EQ. 2) THEN
         CALL FoamA_GetCrude(XsCru(1))     ! get crude normalization for MC
      ENDIF
      IF( m_ModeB .LE. 1) THEN
         CALL VegasB_PreGenerate           ! prepare generation
         CALL VegasB_GetIntCrude(XsCru(2)) ! get crude normalization for MC
      ELSEIF( m_ModeB .EQ. 2) THEN
         CALL FoamB_GetCrude(XsCru(2))     ! get crude normalization for MC
      ENDIF
      IF( m_ModeC .LE. 1) THEN
         CALL VegasC_PreGenerate           ! prepare generation
         CALL VegasC_GetIntCrude(XsCru(3)) ! get crude normalization for MC
      ELSEIF( m_ModeC .EQ. 2) THEN
         CALL FoamC_GetCrude(XsCru(3))     ! get crude normalization for MC
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//   Initialization of MBrB, the own copy of a brancher                             //
*//////////////////////////////////////////////////////////////////////////////////////
      CALL KK2f_GetIdyfs(Idyfs)
      IdBra = Idyfs+200
      CALL MBrB_Initialize(m_out,IdBra,50, 1d0, 'MBrB: Bstra main weight$')
      Nbin  = 500
      CALL MBrB_AddBranch(1, Nbin, WMList(1), 'MBrB: next branch A  !!! $')
      CALL MBrB_AddBranch(2, Nbin, WMList(2), 'MBrB: next branch B  !!! $')
      CALL MBrB_AddBranch(3, Nbin, WMList(3), 'MBrB: next branch C  !!! $')
      CALL MBrB_SetXSList(XsCru)
      CALL MBrB_GetXCrude(m_XCrude)
*//////////////////////////////////////////////////////////////////////////////////////
*// Because in Bstra we have internal rejection loop we send to Karlud and KK2f      //
*// the best estimator of integral we have at this moment                            // 
*// It will be used for histogram normalization (sometimes)                          // 
*// Note that xsection from KK2f_finalize uses m_XCrude*<wt)> or m_XGridB            //
*//////////////////////////////////////////////////////////////////////////////////////
      XCrude   = m_XGridB
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  BStra  Initializator, PreGeneration '
      WRITE(m_out,bxl1g) XsCru(1) ,   'XsCru(1)  1-dimen.  ','XsCru(1) ','**'
      WRITE(m_out,bxl1g) XsCru(2) ,   'XsCru(2)  2-dimen.  ','XsCru(2) ','**'
      WRITE(m_out,bxl1g) XsCru(3) ,   'XsCru(3)  3-dimen.  ','XsCru(3) ','**'
      WRITE(m_out,bxl1f) WMlist(1) ,  'WMlist(1) 1-dimen.  ','WMlist(1)','**'
      WRITE(m_out,bxl1f) WMlist(2) ,  'WMlist(2) 2-dimen.  ','WMlist(2)','**'
      WRITE(m_out,bxl1f) WMlist(3) ,  'WMlist(3) 3-dimen.  ','WMlist(3)','**'
      WRITE(m_out,bxl1g) m_XCrude ,   'XCrude   total      ','XCrude   ','**'
      WRITE(m_out,bxclo)
      END

      SUBROUTINE BStra_Make(vv, x1, x2, MCwt)
*//////////////////////////////////////////////////////////////////////////////////////
*//   Genearete set of 3 ISR variables for beamsstrahlung ISR                        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BStra.h'
      DOUBLE PRECISION  vv, x1, x2, MCwt, x, Wt_KF
      DOUBLE PRECISION  BornV_RhoFoamA, BornV_RhoFoamB, BornV_RhoFoamC
      EXTERNAL          BornV_RhoFoamA, BornV_RhoFoamB, BornV_RhoFoamC
      REAL              Qrand(10)        ! for PseuMar
      INTEGER           Itype
      DOUBLE PRECISION  rand
*-------------------------------------------------------------------------------
 100  CONTINUE
      m_Nevgen  =  m_Nevgen +1
      CALL MBrB_GenKF(Itype, Wt_KF)
      IF(     Itype .EQ. 1 ) THEN
         IF( m_ModeA .LE. 1) THEN
            CALL VegasA_Generate(BornV_RhoFoamA)
            CALL VegasA_GetMCwt( MCwt)
         ELSE
            CALL FoamA_MakeEvent(BornV_RhoFoamA) ! generate MC event
            CALL FoamA_GetMCwt(  MCwt)             ! get MC weight
         ENDIF
      ELSEIF( Itype .EQ. 2 ) THEN
         IF( m_ModeB .LE. 1) THEN
            CALL VegasB_Generate(BornV_RhoFoamB)
            CALL VegasB_GetMCwt( MCwt)
         ELSE
            CALL FoamB_MakeEvent(BornV_RhoFoamB) ! generate MC event
            CALL FoamB_GetMCwt(  MCwt)             ! get MC weight
         ENDIF
      ELSEIF( Itype .EQ. 3 ) THEN
         IF( m_ModeC .LE. 1) THEN
            CALL VegasC_Generate(BornV_RhoFoamC)
            CALL VegasC_GetMCwt( MCwt)
         ELSE
            CALL FoamC_MakeEvent(BornV_RhoFoamC) ! generate MC event
            CALL FoamC_GetMCwt(  MCwt)             ! get MC weight
         ENDIF
      ELSE
         WRITE(m_out,*) '+++++ STOP in BStra_Make '
         WRITE(    *,*) '+++++ STOP in BStra_Make '
         STOP 
      ENDIF
      CALL BornV_GetVXX(vv,x1,x2)
* random swap, necessary because FoamB integrand is asymmetric
      CALL PseuMar_MakeVec(Qrand,2)
      IF( Qrand(1) .LT. 0.5d0 ) THEN
         x  = x1
         x1 = x2
         x2 = x
      ENDIF
      MCwt = MCwt *Wt_KF
* Rejection
      rand = Qrand(2)
      CALL MBrB_Fill(MCwt   ,rand)
      IF(rand .GT. MCwt) GOTO 100
      MCwt = 1d0
      END                       ! BStra_Make

      DOUBLE PRECISION  FUNCTION BVR_A(p1p2,Mas1,Mas2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Function A(p1,p2) real version appropriate for B-tilde calculation                    //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION     p1p2,Mas1,Mas2
      DOUBLE PRECISION     Mas12,xlam
*----------
      Mas12 = Mas1*Mas2
      IF ( (p1p2-Mas12) .LT. 1d-10) THEN
         BVR_A=0d0
         WRITE(*,*) '+++++++ BVR_A:: WARNING, p1p2 = ',p1p2
         RETURN
      ENDIF
      xlam = SQRT( (p1p2 - Mas12)*(p1p2 + Mas12) )
      BVR_A  = 1/xlam *LOG( (p1p2 + xlam)/Mas12 )
      END

      DOUBLE PRECISION   FUNCTION BVR_A4(p1p2,En1,En2,xm1,xm2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//! This function provides an analytical result for the integral         !                 //
*//! A4(p1,p2) being a part of the YFS IR function B-tilde.               !                 //
*//! Note: This is a general case without any approximation!              !                 //
*//! INPUT: p1p2    - scalar product of the 4-momenta p1 and p2;          !                 //
*//!        E1,E2   - particles energies;                                 !                 //
*//!        xm1,xm2 - particles masses;                                   !                 //
*//!----------------------------------------------------------------------!                 //
*//! Written by:  Wieslaw Placzek                Knoxville, January  1996 !                 //
*//! Last update: 30.01.1996                by: W.P.                      !                 //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION     p1p2,En1,En2,xm1,xm2
      DOUBLE PRECISION     E1,E2,Mas1,Mas2,p1s,p2s,p2,Ep,Em,sm,dm,Q2,xl,xq,qp,qm
      DOUBLE PRECISION     et0,et1,vet0,vet1,Eln,y1,y2,y3,y4
      DOUBLE PRECISION     BVR_Yijeta
! Statement function
      DOUBLE PRECISION     etaln,x1,x2,x3,x4,z
      etaln(x1,x2,x3,x4,z) = LOG(ABS( (z-x1)*(z-x2)/(z-x3)/(z-x4) ))
*-----------
! Some auxiliary variables
      E1 = En1
      E2 = En2
      Mas1 = xm1
      Mas2 = xm2
      p1s = E1**2 - Mas1**2
      p2s = E2**2 - Mas2**2
      IF (p1s.lt.p2s) THEN
        Mas1 = xm2
        Mas2 = xm1
        E1 = En2
        E2 = En1
      ENDIF
      Ep  = E1 + E2
      Em  = E1 - E2
      sm  = Mas1 + Mas2 
      dm  = Mas1 - Mas2
      Q2  = 2*p1p2 - Mas1**2 - Mas2**2
      xl  = SQRT( (Q2 + sm**2)*(Q2 + dm**2) )
      xq  = SQRT(Q2 + Em**2)
      qp = xq + Em
      qm = xq - Em
      et0 = SQRT(E2**2 - Mas2**2)
      IF (p1p2.gt.E1*E2) et0 = -et0
      et1 = SQRT(E1**2 - Mas1**2) + xq
      y1  = 0.5d0*( (xq - Ep) + (sm*dm + xl)/qp )
      y2  = y1 - xl/qp
      y3  = 0.5d0*( (xq + Ep) + (sm*dm + xl)/qm )
      y4  = y3 - xl/qm       
! Some auxiliary functions
      IF (ABS(Em).gt.1d-10) THEN
        Eln = LOG(ABS(qm/qp))*( etaln(y1,y4,y2,y3,et1) 
     &                        - etaln(y1,y4,y2,y3,et0) )
      ELSE
        Eln = 0
      ENDIF
      Vet0 = BVR_Yijeta(y1,y4,et0) + BVR_Yijeta(y2,y1,et0)
     &     + BVR_Yijeta(y3,y2,et0) - BVR_Yijeta(y3,y4,et0)
     &     + 0.5d0*etaln(y1,y2,y3,y4,et0)*etaln(y2,y3,y1,y4,et0)
      Vet1 = BVR_Yijeta(y1,y4,et1) + BVR_Yijeta(y2,y1,et1)
     &     + BVR_Yijeta(y3,y2,et1) - BVR_Yijeta(y3,y4,et1)
     &     + 0.5d0*etaln(y1,y2,y3,y4,et1)*etaln(y2,y3,y1,y4,et1)
! Function A4(p1,p2) 
      BVR_A4 = 1/xl*(Eln + Vet1 - Vet0 )
      END

      DOUBLE PRECISION   FUNCTION BVR_A4sng(E1,Mas1)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Function (p1*p1)*A4(p1,p1) equal argument momenta.                                      //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION   E1,Mas1
      DOUBLE PRECISION   bet1,b1ln
*-------
      bet1 = SQRT(1-Mas1**2/E1**2)
      b1ln = 2*LOG( (1+bet1)*E1/Mas1 )
      BVR_A4sng = -1/Mas1**2/bet1 *b1ln
      END


      DOUBLE PRECISION   FUNCTION BVR_Btilda(alfpi,p1p2,E1,E2,Mas1,Mas2,Kmax,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//  Full/Complete/exact 2-particle Btilde function.                                        //
*//  Exact treatment of masses, numericaly stable in high energy limit.                     //
*//  Equivalent of routine Btilde programmed by W. Placzek (S.J.)                           //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    alfpi,p1p2,E1,E2,Mas1,Mas2,Kmax,MasPhot
      DOUBLE PRECISION    BVR_A, BVR_A4, BVR_A4sng
*-------------
      BVR_Btilda = alfpi*(
     $     (p1p2*BVR_A( p1p2,Mas1,Mas2) -1 )*2*LOG(2*Kmax/MasPhot)
     $     +p1p2*BVR_A4(p1p2,E1,E2,Mas1,Mas2)
     $     -0.5d0*Mas1**2*BVR_A4sng(E1,Mas1)
     $     -0.5d0*Mas2**2*BVR_A4sng(E2,Mas2)
     $     )
      END


      DOUBLE PRECISION    FUNCTION BVR_Btildc(alfpi,p1p2,E1,E2,Mas1,Mas2,Kmax,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Crude/Truncated (crude MC) 2-particle Btilde equivalent S.J.                            //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    alfpi,p1p2,E1,E2,Mas1,Mas2,Kmax,MasPhot
      DOUBLE PRECISION    BVR_A, BVR_A4
*-------------
      BVR_Btildc = alfpi*(
     $      p1p2*BVR_A( p1p2      ,Mas1,Mas2)*2*LOG(2*Kmax/MasPhot)
     $     +p1p2*BVR_A4(p1p2,E1,E2,Mas1,Mas2)
     $     )
      END



      DOUBLE PRECISION FUNCTION BVR_Btilde(alfinv,p1,p2,am1,am2,aKmax,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//  UNUSED!!!, Btilde is replaced by the equivalent function Btildf                        //
*//                                                                                         //
*//  !----------------------------------------------------------------------!               //
*//  ! This function provides a value of YFS real photon IR function        !               //
*//  ! B-tilde for any pair of charged particles.                           !               //
*//  ! INPUT: p1,p2   - particles 4-momenta;                                !               //
*//  !        am1,am2 - particles masses;                                   !               //
*//  !        MasPhot   - 'photon mass' (IR regulator)                      !               //
*//  !        aKmax   - maximum soft photon energy [GeV]                    !               //
*//  !----------------------------------------------------------------------!               //
*//  ! Written by:  Wieslaw Placzek                Knoxville, January  1996 !               //
*//  ! Last update: 30.01.1996                by: W.P.                      !               //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      DOUBLE PRECISION pi
      PARAMETER ( pi = 3.1415926535897932D0)
      DOUBLE PRECISION  p1(4),p2(4)
      DOUBLE PRECISION  BVR_A4
      DOUBLE PRECISION  alfpi,bet1,bet2,xlam,a,a4,btian,b1ln,b2ln,p1p2
      DOUBLE PRECISION  am2,akmax,alfinv,am1,e2,am12,masphot,e1
*---------------------------------------------------------------------------------------------
      alfpi = 1/alfinv/pi
      BVR_Btilde = 0
      E1 = p1(4)
      E2 = p2(4)
      am12 = am1*am2
      p1p2 = p1(4)*p2(4) - p1(3)*p2(3) - p1(2)*p2(2) - p1(1)*p2(1)
      IF (p1p2-am12.lt.1d-10) RETURN
      xlam = SQRT( (p1p2 - am12)*(p1p2 + am12) )
! Function A(p1,p2)
      A  = 1/xlam *LOG( (p1p2 + xlam)/am12 )
      bet1 = SQRT(1-am1**2/E1**2)
      bet2 = SQRT(1-am2**2/E2**2)
      b1ln = 2*LOG( (1+bet1)*E1/am1 )
      b2ln = 2*LOG( (1+bet2)*E2/am2 )
! Function A4(p1,p2)
      A4 = BVR_A4(p1p2,E1,E2,am1,am2)
! B-tilde(p1,p2;aKmax,MasPhot)
      Btian = (p1p2*A - 1) *2*LOG(2*aKmax/MasPhot)
     &       + p1p2*A4 + 0.5/bet1*b1ln + 0.5/bet2*b2ln
      BVR_Btilde = alfpi*Btian
      END

      DOUBLE COMPLEX  FUNCTION BVR_CBoxGG(MasPhot,s,t,u)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Box Gamma-Gamma, taken from   KORAZ/KORALB programs                                   //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      MasPhot,s,t,u
      DOUBLE COMPLEX  MG,Eps,SS,TT,UU,CiPi,Clnt
      DOUBLE COMPLEX  BVR_Spence,BVR_CDLN
*---------
      Eps = DCMPLX(-1.D0,0.D0)
      MG  = DCMPLX(MasPhot, 0d0)
      SS  = DCMPLX(s, 0d0)
      TT  = DCMPLX(t, 0d0)
      UU  = DCMPLX(u, 0d0)
      CiPi = DCMPLX(0d0, m_pi)
      Clnt = BVR_CDLN( (-TT/SS) ,Eps)
      BVR_CBoxGG= 
     $     BVR_CDLN( (TT/UU) ,Eps) *(BVR_CDLN( MG**2/SS ,Eps) +CiPi) !!!   <-- Infrared part
     $     +DCMPLX(0.5d0)*SS*(UU-TT)/UU**2 *( DCMPLX(0.5d0)*Clnt**2 +CiPi*Clnt)
     $     -DCMPLX(0.5d0)*SS/UU*( Clnt +Cipi)
      END

      DOUBLE COMPLEX  FUNCTION BVR_CBoxGZ(MasPhot,MassZ,GammZ,s,t,u)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Box Gamma-Z, From W. Brown, R. Decker, E. Pashos, Phys. Rev. Lett., 52 (1984), 1192     //
*// Programmed similarly as in KORALZ                                                       //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      MasPhot,MassZ,GammZ,s,t,u
      DOUBLE COMPLEX  MZ2,MG2,Eps,SS,TT,UU
      DOUBLE COMPLEX  BVR_Spence,BVR_CDLN
*
      Eps = DCMPLX(-1.D0,0.D0)
      MZ2  = DCMPLX(MassZ**2, -MassZ*GammZ)
      MG2  = DCMPLX(MasPhot**2, 0d0)
      SS  = DCMPLX(s, 0d0)
      TT  = DCMPLX(t, 0d0)
      UU  = DCMPLX(u, 0d0)
      BVR_CBoxGZ = 
     $        BVR_CDLN( (TT/UU) ,Eps) *BVR_CDLN( MG2/CDSQRT(TT*UU) ,Eps) !!!<-- Infrared part
     $     -2*BVR_CDLN( (TT/UU) ,Eps) *BVR_CDLN( ((MZ2-SS)/MZ2 )   ,Eps)
     $     +BVR_Spence( ((MZ2+UU)/MZ2) ,Eps)
     $     -BVR_Spence( ((MZ2+TT)/MZ2) ,Eps)
     $     +(MZ2-SS)*(UU-TT-MZ2)/UU/UU *(
     $              BVR_CDLN( (-TT/SS) ,Eps) *BVR_CDLN( ((MZ2-SS)/MZ2) ,Eps)
     $             +BVR_Spence( ((MZ2+TT)/MZ2) ,Eps)  
     $             -BVR_Spence( ((MZ2-SS)/MZ2) ,Eps)  )
     $     +(MZ2-SS)*(MZ2-SS)/UU/SS *BVR_CDLN( ((MZ2-SS)/MZ2) ,Eps) 
     $     +(MZ2-SS)/UU             *BVR_CDLN( (-TT/MZ2)      ,Eps)
      END

      DOUBLE COMPLEX  FUNCTION BVR_CDLN(X,A)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//  Complex functions that take account of the I*Epsilon prescription                      //
*//  Complex logarithm of X+I*REAL(A) where a is an infinitesimal                           //
*//  Programmed probably by R. Stuart                                                       //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE COMPLEX  A,X
      DOUBLE COMPLEX  PI
*--------
      PI=(3.141592653589793238462643D0,0.D0)
      IF(DIMAG(X) .EQ. 0.D0 .AND. DREAL(X) .LE. 0.D0) THEN
         BVR_CDLN =CDLOG(-X) +(0.D0,1.D0)*PI*DSIGN(1.D0,DREAL(A))
      ELSE
         BVR_CDLN =CDLOG(X)
      END IF
      IF(DIMAG(BVR_CDLN).GT.DREAL(PI) ) BVR_CDLN =BVR_CDLN -(0.D0,1.D0)*PI
      IF(DIMAG(BVR_CDLN).LT.DREAL(-PI)) BVR_CDLN =BVR_CDLN +(0.D0,1.D0)*PI
      RETURN
      END

      DOUBLE COMPLEX  FUNCTION BVR_CnuA(Svar,Mas1,Mas2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Function nu*A(nu) Complex version appropriate for s and t-chanels.                    //
*//   No small mass approximation.                                                          //
*//                                                                                         //
*//       s-chanel:  Nu = (-s+m1**2+m2**2)/2 = -p1p2 < 0   p1 and p2 incoming or outgoing   //
*//       t-chanel:  Nu = (-t+m1**2+m2**2)/2 =  p1p2 > 0   p1 incoming p2 outgoing          //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      Svar,Mas1,Mas2
      DOUBLE COMPLEX        Eps,Nu,Mas12,xlam,z
      DOUBLE COMPLEX        BVR_CDLN
*----------
      Eps = DCMPLX( +1d0,0.d0)   ! plus was adjusted empiricaly
      IF( DABS(Mas1*Mas2) .LT. 1d-10 ) GOTO 900
      Mas12 = DCMPLX(Mas1*Mas2)
      Nu    = DCMPLX( (-Svar +Mas1**2+Mas2**2)/2d0 )
      xlam  = CDSQRT( ( Nu - Mas12)*( Nu + Mas12) )
* take care of numerical stability
      IF( svar .GT. 0d0) THEN
         z = Mas12/(Nu-xlam)
      ELSE
         z = (Nu + xlam)/Mas12
      ENDIF
      BVR_CnuA  = Nu/xlam *BVR_CDLN( z ,Eps)
      RETURN
 900  CONTINUE
      WRITE(*,*) '++++++ BVR_CnuA: STOP due to zero mass: ',Mas1,Mas2
      STOP
      END



      DOUBLE PRECISION FUNCTION BVR_Dilog(x)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// dilogarithm FUNCTION: dilog(x)=int( -ln(1-z)/z ) , 0 < z < x .                          //
*// this is the cernlib version.                                                            //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  x
*
      DOUBLE PRECISION  a,b,y,s,t,z
*---------------------------------------------------------------------------------------------
      z=-1.644934066848226d0
      IF(x  .LT. -1.d0) GOTO 1
      IF(x  .LE.  0.5d0) GOTO 2
      IF(x  .EQ.  1.d0) GOTO 3
      IF(x  .LE.  2.d0) GOTO 4
      z=3.289868133696453d0
    1 t=1.d0/x
      s=-0.5d0
      z=z-0.5d0*dlog(dabs(x))**2
      GOTO 5
    2 t=x
      s=0.5d0
      z=0.d0
      GOTO 5
    3 BVR_Dilog=1.644934066848226d0
      RETURN
    4 t=1.d0-x
      s=-0.5d0
      z=1.644934066848226d0-dlog(x)*dlog(dabs(t))
    5 y=2.666666666666667d0*t+0.666666666666667d0
      b=      0.000000000000001d0
      a=y*b  +0.000000000000004d0
      b=y*a-b+0.000000000000011d0
      a=y*b-a+0.000000000000037d0
      b=y*a-b+0.000000000000121d0
      a=y*b-a+0.000000000000398d0
      b=y*a-b+0.000000000001312d0
      a=y*b-a+0.000000000004342d0
      b=y*a-b+0.000000000014437d0
      a=y*b-a+0.000000000048274d0
      b=y*a-b+0.000000000162421d0
      a=y*b-a+0.000000000550291d0
      b=y*a-b+0.000000001879117d0
      a=y*b-a+0.000000006474338d0
      b=y*a-b+0.000000022536705d0
      a=y*b-a+0.000000079387055d0
      b=y*a-b+0.000000283575385d0
      a=y*b-a+0.000001029904264d0
      b=y*a-b+0.000003816329463d0
      a=y*b-a+0.000014496300557d0
      b=y*a-b+0.000056817822718d0
      a=y*b-a+0.000232002196094d0
      b=y*a-b+0.001001627496164d0
      a=y*b-a+0.004686361959447d0
      b=y*a-b+0.024879322924228d0
      a=y*b-a+0.166073032927855d0
      a=y*a-b+1.935064300869969d0
      BVR_Dilog=s*t*(a-b)+z
      END


      DOUBLE COMPLEX  FUNCTION BVR_IntIR(MasPhot,s,t,u)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Virtual 2*(B(t)-B(u)) Intereference IR part to be subtracted from boxes               //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      MasPhot,s,t,u
      DOUBLE COMPLEX  BVR_CDLN,Eps,MG2,TT,UU
*-------
      Eps = DCMPLX(-1.D0,0.D0)
      MG2 = DCMPLX(MasPhot**2, 0d0)
      TT  = DCMPLX(t, 0d0)
      UU  = DCMPLX(u, 0d0)
      BVR_IntIR =
     $      BVR_CDLN( (TT/UU) ,Eps) *BVR_CDLN( (MG2/CDSQRT(TT*UU)) ,Eps)
     $     +DCMPLX(0.5d0)*BVR_CDLN( (TT/UU) ,Eps)
      END


      DOUBLE COMPLEX  FUNCTION BVR_IntReson(MasPhot,MassZ,GammZ,s,t,u)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Resonant part of virtual formfactor                                                   //
*//   Needed for Greco-Pancheri-Srivastava exponentiation                                   //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      MasPhot,MassZ,GammZ,s,t,u
      DOUBLE COMPLEX  MZ2,MG2,Eps,SS,TT,UU
      DOUBLE COMPLEX  BVR_Spence,BVR_CDLN
*
      Eps = DCMPLX(-1.D0,0.D0)
      MZ2  = DCMPLX(MassZ**2, -MassZ*GammZ)
      MG2  = DCMPLX(MasPhot**2, 0d0)
      SS  = DCMPLX(s, 0d0)
      TT  = DCMPLX(t, 0d0)
      UU  = DCMPLX(u, 0d0)
      BVR_IntReson = 
     $     -2*BVR_CDLN( (TT/UU) ,Eps) *BVR_CDLN( ((MZ2-SS)/MZ2 )   ,Eps)
ccc     $    +BVR_CDLN( (TT/UU) ,Eps) *BVR_CDLN( MG2/CDSQRT(TT*UU) ,Eps)
ccc     $     +BVR_Spence( ((MZ2+UU)/MZ2) ,Eps)
ccc     $     -BVR_Spence( ((MZ2+TT)/MZ2) ,Eps)
      END

      SUBROUTINE  BVR_MakeF1fin(Svar,Mas1,Mas2,Alfpi,Q,F1_1,F1_2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Final state vertex correction, second order                                           //
*//   finite mass  only for first order part                                                //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION   Svar,Mas1,Mas2,Alfpi,Q
      DOUBLE COMPLEX     F1_1,F1_2,cL
      DOUBLE COMPLEX     BVR_CnuA
*
      cL = BVR_CnuA(Svar,Mas1,Mas2) - DCMPLX(1d0)       !!! <-- this is just ln(s/m**2)-i*pi -1
***   cL = DCMPLX( DLOG(Svar/Mas1/Mas2)-1d0, -1d0 )

      F1_1 = (Alfpi*Q**2)   *0.5d0*cL
      F1_2 = F1_1
     $     +(Alfpi*Q**2)**2 *(
     $              +cL**2/8d0 
     $              +cL*( 3d0/32 -3d0/4*m_zeta2 +3d0/2*m_zeta3 ) 
     $     )
      END

      SUBROUTINE  BVR_MakeF1ini(Svar,Mas1,Mas2,Alfpi,Q,F1_1,F1_2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Initial state vertex correction, IR subtracted, in small mass approximation.          //
*//   Second order LL+NLL is included.                                                      //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION   Svar, Mas1,Mas2, Alfpi, Q
      DOUBLE COMPLEX     F1_1, F1_2, cL
      DOUBLE COMPLEX     BVR_CnuA
*
      cL = BVR_CnuA(Svar,Mas1,Mas2) - DCMPLX(1d0)         !!! <-- this is just ln(s/m**2)-i*pi -1
***   cL = DCMPLX( DLOG(Svar/Mas1/Mas2)-1d0, -1d0 )

      F1_1 = (Alfpi*Q**2)   *0.5d0*cL
      F1_2 = F1_1
     $     +(Alfpi*Q**2)**2 *(
     $              +cL**2/8d0 
     $              +cL*( 3d0/32 -3d0/4*m_zeta2 +3d0/2*m_zeta3 ) 
     $     )
*------------------------------------------------------------
* Subleading terms from Berends, Burgers, Van Neerveen
* Cooked up by S.J. long time ago (1989?)
*      dels2 =  charg2**2*alfpi**2  *0.5d0*bilg**2
*     $     +charg2**2*alfpi**2*(
*     $     -(13d0/16d0 +1.5d0*zet2 -3d0*zet3)*bilg
*     $     -16d0/5d0*zet2*zet2 +51d0/8d0*zet2 +13d0/4d0
*     $     -4.5d0*zet3 -6d0*zet2*log(2d0) )
*------------------------------------------------------------
      END

      SUBROUTINE  BVR_MakeVfin(Alfpi,Q,p3,m3,p4,m4,ph, V1,V2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Final state virtual correction to single bremsstrahlung                               //
*//   IR subtracted, in small mass approximation.                                           //
*//   Second order LL  (+NLL???) is included                                                //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION   Alfpi,Q,m3,m4,p3(4),p4(4),ph(4)
      DOUBLE COMPLEX     V1,V2, cL, V2a
      DOUBLE COMPLEX     BVR_CnuA
      DOUBLE PRECISION   p3p4,Svar,r1,r2,zz,s1,s2
      DOUBLE PRECISION   BVR_Dilog
*
      p3p4  =  p3(4)*p4(4) -p3(3)*p4(3) -p3(2)*p4(2) -p3(1)*p4(1)
      Svar  = 2*p3p4 +m3**2+m4**2
      s1 = (p3(4)*ph(4)-p3(3)*ph(3)-p3(2)*ph(2)-p3(1)*ph(1))/p3p4
      s2 = (p4(4)*ph(4)-p4(3)*ph(3)-p4(2)*ph(2)-p4(1)*ph(1))/p3p4
* normal definition as in O(alf1) single-photon case
      r1 = s1/( 1d0 +s1 +s2 )
      r2 = s2/( 1d0 +s1 +s2 )

      cL = BVR_CnuA(Svar,m3,m4)-1d0                 !! <-- this is just ln(s/m**2)-i*pi -1
***   cL = DCMPLX( DLOG(Svar/m3/m4)-1d0, -1d0 )

      V1 = (Alfpi*Q**2) *0.5d0*cL                   !! constant LL part

      V2= (Alfpi*Q**2) *( -0.25d0*cL*DLOG((1d0-r1)*(1d0-r2)) )  !! LL formula averaged over r1,r2
      V2= V2+ (Alfpi*Q**2) *( +0.50d0*cL*DLOG((1d0-r1)*(1d0-r2)) ) !! corr. due YFS formfactor

* this ISR formula is to be replaced
cc      V2 = (Alfpi*Q**2) *0.5d0*(
cc     $     +DLOG(r1)*DLOG(1-r2)  +DLOG(r2)*DLOG(1-r1)         !! LL part
cc     $     +BVR_Dilog(r1)        +BVR_Dilog(r2)               !! NLL this and all the rest
cc     $     -1d0/2*DLOG(1-r1)**2  -1d0/2*DLOG(1-r2)**2
cc     $     +3d0/2*DLOG(1-r1)     +3d0/2*DLOG(1-r2)
cc     $     +1d0/2*r1*(1-r1)/(1+(1-r1)**2)
cc     $     +1d0/2*r2*(1-r2)/(1+(1-r2)**2)
cc     $     )
cc      V2= V2-(Alfpi*Q**2) *( -0.50d0*cL*DLOG((1d0-r1)*(1d0-r2)) )

      END

*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//                      End of Class  KK2f                                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//                                                                                         //
*//                               Pseudo-CLASS  BVR                                         //
*//                                                                                         //
*//             B-functions Real and Virtual and YFS form-factors                           //
*//                                                                                         //
*//                                                                                         //
*//    WARNIG:  !!!!!!!!!!!!!!!!!!!!!!![[[[[[[[]]]]]]]!!!!!!!!!!!!!!!                       //
*//    Function BVR_SBvirt modified temporarily to avoid problem with pi**2/beta            //
*//    WARNIG:  !!!!!!!!!!!!!!!!!!!!!!![[[[[[[[]]]]]]]!!!!!!!!!!!!!!!                       //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE  BVR_MakeVini(Alfpi,Q,p1,m1,p2,m2,ph, V1,V2)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Initial state virtual correction to single bremsstrahlung                             //
*//   IR subtracted, in small mass approximation.                                           //
*//   Second order LL  (+NLL???) is included                                                //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION   Alfpi,Q,m1,m2,p1(4),p2(4),ph(4)
      DOUBLE COMPLEX     V1,V2, cL, V2a
      DOUBLE COMPLEX     BVR_CnuA
      DOUBLE PRECISION   p1p2,Svar,r1,r2,zz
      DOUBLE PRECISION   BVR_Dilog
*
      p1p2  =  p1(4)*p2(4) -p1(3)*p2(3) -p1(2)*p2(2) -p1(1)*p2(1)
      Svar  = 2*p1p2 +m1**2+m2**2
      r1 = (p1(4)*ph(4)-p1(3)*ph(3)-p1(2)*ph(2)-p1(1)*ph(1))/p1p2
      r2 = (p2(4)*ph(4)-p2(3)*ph(3)-p2(2)*ph(2)-p2(1)*ph(1))/p1p2

      cL = BVR_CnuA(Svar,m1,m2)-1d0                 !! <-- this is just ln(s/m**2)-i*pi -1
***   cL = DCMPLX( DLOG(Svar/m1/m2)-1d0, -1d0 )

      V1 = (Alfpi*Q**2) *0.5d0*cL                   !! constant LL part

      V2a= (Alfpi*Q**2) *( -0.25d0*cL*DLOG((1d0-r1)*(1d0-r2)) ) !! LL formula averaged over r1,r2

      V2 = (Alfpi*Q**2) *0.5d0*(
     $     +DLOG(r1)*DLOG(1-r2)  +DLOG(r2)*DLOG(1-r1)           !! LL part
     $     +BVR_Dilog(r1)        +BVR_Dilog(r2)                 !! NLL this and all the rest
     $     -1d0/2*DLOG(1-r1)**2  -1d0/2*DLOG(1-r2)**2
     $     +3d0/2*DLOG(1-r1)     +3d0/2*DLOG(1-r2)
     $     +1d0/2*r1*(1-r1)/(1+(1-r1)**2)
     $     +1d0/2*r2*(1-r2)/(1+(1-r2)**2)
     $     )
      END


      SUBROUTINE BVR_RBoxGG(MasPhot,s,t,u,ReBox,ImBox,ReIR,DelBox)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//   Box Gamma-Gamma, TEST version, no use of COMPLEX                                      //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION      MasPhot,s,t,u,ReBox,ImBox,ReIR,DelBox
      DOUBLE PRECISION      ct,cp,cm,lcm,lcp
*------
      cm = ABS(t/s)
      cp = ABS(u/s)
      ct = cp-cm
      lcm = DLOG(cm)
      lcp = DLOG(cp)
      ReBox = DLOG(cm/cp)*DLOG(MasPhot**2/s) -ct/(2*cp*cp)*0.5d0*lcm**2  +lcm /(2*cp)
      ImBox = DLOG(cm/cp)*m_pi               -ct/(2*cp*cp)*m_pi *lcm     +m_pi/(2*cp)
      ReIR  = DLOG(cm/cp)*DLOG(MasPhot**2/DSQRT(u*t)) +DLOG(cm/cp)/2d0
      DelBox = 
     $     2*DLOG(cm/cp)*DLOG(MasPhot**2/s)
     $    +1/(1+ct*ct)*(2*cp*lcm - 2*cm*lcp -ct*lcm**2 -ct*lcp**2)
      DelBox = DelBox - 2*ReIR
      END


      DOUBLE PRECISION   FUNCTION BVR_SBvirt(alfpic,p1p2,m1,m2,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Real part of B-VIRTUAL S-CHANNEL, Exact.                                              //
*//   Present version according to eq.(12) in uthep-95-0801                                 //
*//   Notation: mu->Nu, mu*(1+rho)->nu+xlam, rho=xlam/nu                                    //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION    alfpic,p1p2,m1,m2,MasPhot
*
      DOUBLE PRECISION     BVR_Dilog,xlam,Nu,s
*-----
      IF( p1p2 .LE. m1*m2 ) GOTO 900
      Nu = p1p2
      s = 2d0*p1p2 +m1*m1 +m2*m2
      xlam = SQRT( Nu**2 -(m1*m2)**2 )
      BVR_SBvirt = alfpic*(
     $      (Nu/xlam *LOG((Nu+xlam)/m1/m2) -1d0) *LOG(MasPhot**2/m1/m2)
     $     +xlam/s *LOG((Nu+xlam)/m1/m2)
     $     +(m1**2-m2**2)/(2d0*s) *LOG(m1/m2)
*###################################################[[[[[[[[[[[[[[[[[[[[[[[[[
ccc     $     +Nu/xlam* m_pi**2                    !!!<---  Important pi**2/beta of Schwinger
     $     +m_pi**2                    !!!<--- temporary solution for the coulomb problem
*###################################################]]]]]]]]]]]]]]]]]]]]]]]]]
     $     +Nu/xlam*( 
     $         -0.5d0*LOG((Nu+xlam)/m1**2) *LOG((Nu+xlam)/m2**2)
     $         -0.5d0 *LOG( (m1*m1 +(Nu+xlam))/(m2*m2 + Nu+xlam) )**2
     $         -BVR_Dilog( 2d0*xlam/(m1*m1 +Nu+xlam) )
     $         -BVR_Dilog( 2d0*xlam/(m2*m2 +Nu+xlam) )
     $     -1d0)
     $     )
      RETURN
 900  CONTINUE
c{{{{{
ccc      CALL  KK2f_Print1(6)
c}}}}}}
      WRITE(*,'(a,5g20.12)') '##### STOP in BVR_SBvirt: p1p2,m1,m2 = ', p1p2,m1,m2
      STOP
      END                       !!!BVR_SBvirt!!!

      DOUBLE PRECISION  FUNCTION  BVR_SForFac(alfpic, p1,m1, p2,m2, Emin, MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   s-channel YFS formfactor for  acollinear fermion pair.                                //
*//   Mass effects are eaxct.                                                               //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
*
      DOUBLE PRECISION    alfpic, p1(4),m1, p2(4),m2, Emin, MasPhot
      DOUBLE PRECISION    Breal, Bvirt, p1p2
      DOUBLE PRECISION    BVR_Btilda, BVR_SBvirt
*----------
      p1p2  =  p1(4)*p2(4) -p1(3)*p2(3) -p1(2)*p2(2) -p1(1)*p2(1)
      Breal = BVR_Btilda( alfpic, p1p2, p1(4),p2(4), m1, m2,  Emin, MasPhot) !! Exact
      Bvirt = BVR_SBvirt( alfpic, p1p2, m1, m2, MasPhot)                     !! Exact
      BVR_SForFac = EXP( Breal + Bvirt)
      END                       !!! BVR_SForFac !!!

      DOUBLE COMPLEX  FUNCTION BVR_Spence(Y,E)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//  Spence function of y+i*REAL(E) where E is an infinitesimal                             //
*//  Programmed probably by R. Stuart                                                       //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      DOUBLE COMPLEX  Y,E
      DOUBLE PRECISION  B(9),FACT
      DOUBLE COMPLEX  A,CLN,PISQ6,PROD,TERM,X,Z,ZSQ
      DOUBLE COMPLEX  BVR_CDLN
      INTEGER    j,i1,i2
*---------------------------------------------------------------------------------------------
      B(1)=1.D0/6.D0
      B(2)=-1.D0/30.D0
      B(3)=1.D0/42.D0
      B(4)=B(2)
      B(5)=5.D0/66.D0
      B(6)=-691.D0/2730.D0
      B(7)=7.D0/6.D0
      B(8)=-3617.D0/510.D0
      B(9)=43867.D0/798.D0
      PISQ6=(1.6449340668482264D0,0.D0)
      I1=0
      I2=0
      X=Y
      A=E
      IF(X.EQ.(0.D0,0.D0))THEN
        BVR_Spence=(0.D0,0.D0)
        RETURN
      ENDIF
      IF(X.EQ.(1.D0,0.D0))THEN
        BVR_Spence=PISQ6
        RETURN
      ENDIF
C  IF X LIES OUTSIDE THE UNIT CIRCLE THEN EVALUATE BVR_Spence(1/X)
      IF(CDABS(X).GT.1.D0)THEN
        X=1.D0/X
        A=-A
        I1=1
      ENDIF
C  IF REAL(X)>1/2 THEN EVALUATE BVR_Spence(1-X)
      IF(DREAL(X).GT.0.5D0)THEN
        X=1.D0-X
        A=-A
        I2=1
      ENDIF
C  EVALUATE SERIES FOR BVR_Spence(X)
      Z=-BVR_CDLN(1.D0-X,-A)
      ZSQ=Z*Z
      BVR_Spence=Z-ZSQ/4.D0
      PROD=Z
      FACT=1.D0
      DO 10 J=2,18,2
      FACT=FACT*DCMPLX(DBLE((J+1)*J))
      PROD=PROD*ZSQ
      TERM=B(J/2)/FACT*PROD
      BVR_Spence=BVR_Spence+TERM
      IF(CDABS(TERM/BVR_Spence).LT.1.D-20) GOTO 20
10    CONTINUE
C  ADD APPROPRIATE LOGS TO OBTAIN SPENCE FUNCTION OF ORIGINAL ARGUEMENT
20    IF(I2.EQ.1)THEN
        BVR_Spence=-BVR_Spence+PISQ6-BVR_CDLN(X,A)*BVR_CDLN(1.D0-X,-A)
        X=1.D0-X
        A=-A
      ENDIF
      IF(I1.EQ.1)THEN
        CLN=BVR_CDLN(-X,-A)
        BVR_Spence=-BVR_Spence-PISQ6-CLN*CLN/2.D0
      ENDIF
      RETURN
      END


      DOUBLE PRECISION   FUNCTION BVR_TBvirt(alfpic,p1p2,m1,m2,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   Real part of B-VIRTUAL T-CHANNEL  m1 is assumed to be very small.                     //
*//   Present version according to eq.(14) in uthep-95-0801 with COSMETIC changes.          //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION    alfpic,p1p2,m1,m2,MasPhot
*
      DOUBLE PRECISION    t,ta,zeta,BVR_Dilog

      t  = m1*m1 +m2*m2 -2d0*p1p2
      ta = ABS(t)
      zeta = 1+ m2**2/ta
      BVR_TBvirt = alfpic*(
     $     (DLOG(2d0*p1p2/(m1*m2)) -1d0)*DLOG(MasPhot**2/(m1*m2))
     $     +0.5d0*zeta*DLOG(ta*zeta/(m1*m2))
     $     -0.5d0*DLOG(ta/m1**2)*DLOG(ta/m2**2)
     $     +BVR_Dilog(1/zeta) -1d0
     $     +0.5d0*(zeta -1d0)*DLOG(m1/m2)
     $     -DLOG(zeta)*(DLOG(ta/(m1*m2)) +0.5d0*DLOG(zeta))
     $     )
      END                       !!! BVR_TBvirt !!!


      DOUBLE PRECISION   FUNCTION BVR_TBvirt2(alfpic,p1p2,m1,m2,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   B-virtual t-channel  m1 is assumed to be very small.                                  //
*//   Present version according to eq.(14) in uthep-95-0801                                 //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION    alfpic,p1p2,m1,m2,MasPhot
*
      DOUBLE PRECISION    t,ta,zeta,BVR_Dilog

      t  = m1*m1 +m2*m2 -2d0*p1p2
      ta = ABS(t)
      zeta = 1+ m2**2/ta
      BVR_TBvirt2 = alfpic*(
     $     (DLOG(ta/(m1*m2)) + DLOG(zeta) -1d0)*DLOG(MasPhot**2/m1**2)
     $     +0.5d0*zeta*(DLOG(ta/(m1*m2)) + DLOG(zeta))
     $     -0.5d0*DLOG(ta/m1**2)*DLOG(ta/m2**2)
     $     -DLOG(m2/m1)*(DLOG(ta/(m1*m2)) +DLOG(zeta) +.5d0*zeta -1.5d0)
     $     -DLOG(zeta)*(DLOG(ta/(m1*m2)) +0.5d0*DLOG(zeta))
     $     +BVR_Dilog(1/zeta) -1d0
     $     )
      END                       !!! BVR_TBvirt2 !!!


      DOUBLE PRECISION   FUNCTION BVR_TBvirtExact(alfpic,p1p2,m1,m2,MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   B-virtual t-channel, masses treated exactly.                                          //
*//   Based on 1986 internal note by SJ.                                                    //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
      DOUBLE PRECISION    alfpic,p1p2,m1,m2,MasPhot
*
      DOUBLE PRECISION    BVR_Dilog,nu,xlam,w1,w2,A,A1,A3,ta
*------------
      nu  = p1p2
      ta  = 2d0*nu -m1*m1 -m2*m2
      xlam = DSQRT((nu-m1*m2)*(nu+m1*m2))
      w1  =  m1**2/(xlam+nu-m1**2)
      w2  =  m2**2/(xlam+nu-m2**2)
      A   =  1d0/xlam *DLOG((nu+xlam)/(m1*m2))
      A1  = -2d0  +(m1*m1 -m2*m2)/(-ta)*DLOG(m1/m2)
     $            -2d0*xlam**2/(-ta)*A
      A3  = DLOG(ta/(m1*m2))*A
     $     +0.5d0/xlam*( -0.5d0*DLOG(w1)**2 +0.5d0*DLOG(1d0+w1)**2
     $                   -DLOG(1d0+w1+w2)*DLOG(w1/(1d0+w1))
     $                   -BVR_Dilog((1d0+w1)/(1d0+w1+w2)) +BVR_Dilog(w1/(1d0+w1+w2)) )
     $     +0.5d0/xlam*( -0.5d0*DLOG(w2)**2 +0.5d0*DLOG(1d0+w2)**2
     $                   -DLOG(1d0+w1+w2)*DLOG(w2/(1d0+w2))
     $                   -BVR_Dilog((1d0+w2)/(1d0+w1+w2)) +BVR_Dilog(w2/(1d0+w1+w2)) )
*
      BVR_TBvirtExact = alfpic*( (nu*A-1d0)*DLOG(MasPhot**2/(m1*m2)) -nu*A3 +0.5d0*A1 )
      END                       !!! BVR_TBvirtExact !!!


      DOUBLE PRECISION  FUNCTION BVR_TForFac(alfpic, p1,m1, p2,m2, Emin, MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//   T-channel YFS formfactor for acollinear fermion pair.                                 //
*//   m1 is assumed to be small, m2 can be finite.                                          //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BVR.h'
*
      DOUBLE PRECISION    alfpic, p1(4),m1, p2(4),m2, Emin, MasPhot, FormFac
      DOUBLE PRECISION    Breal, Bvirt, t, p1p2
      DOUBLE PRECISION    BVR_Btilda, BVR_TBvirt
*----------
      p1p2  =  p1(4)*p2(4) -p1(3)*p2(3) -p1(2)*p2(2) -p1(1)*p2(1)
      t     = -2*p1p2 +m1**2 +m2**2
      Breal   = BVR_Btilda( alfpic, p1p2, p1(4),p2(4), m1, m2,  Emin, MasPhot) !! Exact!!!
      Bvirt   = BVR_TBvirt( alfpic, p1p2, m1, m2, MasPhot) !!!! m1<<m2 approximation here!!!
      BVR_TForFac = EXP( Breal + Bvirt)
      END                       !!! BVR_TForFac !!!

      SUBROUTINE BVR_wform( CMSene,alfinv,q1,q2,amf,delta,eps,dyfs)
*/////////////////////////////////////////////////////////////////////////////////////////////
*// UNUSED, kept for some future tests, small mass approx.                                  //
*// Yennie-Frautschi-Suura formfactors for the final state ferm. pair                       //
*// S.J. 1987                                                                               //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION CMSene,alfinv,q1(4),q2(4),amf,delta,eps,dyfs

      DOUBLE PRECISION pi
      PARAMETER (pi=3.1415926535897932d0)
      DOUBLE PRECISION alf1,q1q2,em,ep,remn,dl,e1,e2,ene,svar,delb,gamf2
      DOUBLE PRECISION bvr_dilog
*---------------------------------------------------------------------------------------------
      alf1=1/alfinv/pi
      svar  = cmsene**2
      ene= cmsene/2
* momenta q1,q2 should be in cms
      e1 = q1(4)
      e2 = q2(4)
      gamf2 = 2*alf1* dlog(svar /amf**2)
      DelB  = gamf2*dlog(ene/SQRT(e1*e2)*eps/delta)
      ep    = e1+e2
      em    = e1-e2
      q1q2  = q1(4)*q2(4)-q1(3)*q2(3)-q1(2)*q2(2)-q1(1)*q2(1)
      dl    = SQRT( 2*q1q2 +em**2 )
      remn  = pi**2/2
     $        -0.50d0*dlog(e1/e2)**2
     $        -0.25d0*dlog((dl+em)**2/(4*e1*e2))**2
     $        -0.25d0*dlog((dl-em)**2/(4*e1*e2))**2
     $        - BVR_Dilog((dl+ep)/(dl+em)) -BVR_Dilog((dl-ep)/(dl-em))
     $        - BVR_Dilog((dl-ep)/(dl+em)) -BVR_Dilog((dl+ep)/(dl-em))
      dyfs  = exp( DelB +alf1*remn )
      END

      DOUBLE PRECISION   FUNCTION BVR_Yijeta(yi,yj,eta)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*/ !----------------------------------------------------------------------!                 //
*/ ! Some auxiliary function (combination of Logs and Dilogs) used in     !                 //
*/ ! the function A4anal for A4(p1,p2).                                   !                 //
*/ !----------------------------------------------------------------------!                 //
*/ ! Written by:  Wieslaw Placzek                Knoxville, January  1996 !                 //
*/ ! Last update: 30.01.1996                by: W.P.                      !                 //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    yi,yj,eta
      DOUBLE PRECISION    BVR_Dilog
*-----
      BVR_Yijeta = 2*BVR_Dilog( ( yj-yi)/(eta-yi) ) 
     &         + 0.5d0*LOG(ABS( (eta-yi)/(eta-yj) ))**2
      END

      SUBROUTINE CHOICE(MNUM,RR,ICHAN,PROB1,PROB2,PROB3,
     $            AMRX,GAMRX,AMRA,GAMRA,AMRB,GAMRB)
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      AMROP=1.1
      GAMROP=0.36
      AMOM=.782
      GAMOM=0.0084
*     XXXXA CORRESPOND TO S2 CHANNEL !
      IF(MNUM.EQ.0) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =AMA1
         GAMRX=GAMA1
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.1) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.57
         GAMRX=0.9
         AMRB =AMKST
         GAMRB=GAMKST
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.2) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.57
         GAMRX=0.9
         AMRB =AMKST
         GAMRB=GAMKST
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.3) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.4) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.5) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.6) THEN
         PROB1=0.4
         PROB2=0.4
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.7) THEN
         PROB1=0.0
         PROB2=1.0
         AMRX =1.27
         GAMRX=0.9
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.8) THEN
         PROB1=0.0
         PROB2=1.0
         AMRX =AMROP
         GAMRX=GAMROP
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.101) THEN
         PROB1=.35
         PROB2=.35
         AMRX =1.2
         GAMRX=.46
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMOM
         GAMRA=GAMOM
      ELSEIF(MNUM.EQ.102) THEN
         PROB1=0.0
         PROB2=0.0
         AMRX =1.4
         GAMRX=.6
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMOM
         GAMRA=GAMOM
      ELSE
         PROB1=0.0
         PROB2=0.0
         AMRX =AMA1
         GAMRX=GAMA1
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ENDIF
*
      IF    (RR.LE.PROB1) THEN
         ICHAN=1
      ELSEIF(RR.LE.(PROB1+PROB2)) THEN
         ICHAN=2
         AX   =AMRA
         GX   =GAMRA
         AMRA =AMRB
         GAMRA=GAMRB
         AMRB =AX
         GAMRB=GX
         PX   =PROB1
         PROB1=PROB2
         PROB2=PX
      ELSE
         ICHAN=3
      ENDIF
*
      PROB3=1.0-PROB1-PROB2
      END

      FUNCTION DCDMAS(IDENT)
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      IF      (IDENT.EQ. 1) THEN
        APKMAS=AMPI
      ELSEIF  (IDENT.EQ.-1) THEN
        APKMAS=AMPI
      ELSEIF  (IDENT.EQ. 2) THEN
        APKMAS=AMPIZ
      ELSEIF  (IDENT.EQ.-2) THEN
        APKMAS=AMPIZ
      ELSEIF  (IDENT.EQ. 3) THEN
        APKMAS=AMK
      ELSEIF  (IDENT.EQ.-3) THEN
        APKMAS=AMK
      ELSEIF  (IDENT.EQ. 4) THEN
        APKMAS=AMKZ
      ELSEIF  (IDENT.EQ.-4) THEN
        APKMAS=AMKZ
      ELSEIF  (IDENT.EQ. 8) THEN
        APKMAS=0.0001
      ELSEIF  (IDENT.EQ.-8) THEN
        APKMAS=0.0001
      ELSEIF  (IDENT.EQ. 9) THEN
        APKMAS=0.5488
      ELSEIF  (IDENT.EQ.-9) THEN
        APKMAS=0.5488
      ELSE
        PRINT *, 'STOP IN APKMAS, WRONG IDENT=',IDENT
        STOP
      ENDIF
      DCDMAS=APKMAS
      END


      SUBROUTINE FILHEP(N,IST,ID,JMO1,JMO2,JDA1,JDA2,P4,PINV,PHFLAG)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  FILHEP of TAUOLA must be in single precission but double precision             // 
*//  HepEvt_Fil1 is its functional copy                                             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      LOGICAL PHFLAG
      DOUBLE PRECISION  PINVD,P4D(4)
      REAL P4(4)
      DO k=1,4
        P4D(k)=P4(k)
      ENDDO
      PINVD=PINV
      CALL HepEvt_Fil1(N,IST,ID,JMO1,JMO2,JDA1,JDA2,P4D,PINVD,PHFLAG)
      END


      SUBROUTINE FoamA_ActUpda    
C !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER   iCell,Dau1,Dau2
      INTEGER   i
*     ---------------------------------------------------
      m_LastAc=0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            m_LastAc=m_LastAc+1
            IF(m_LastAc .EQ. m_cMax) GOTO 950
            m_ActC(m_LastAc) = iCell
         ENDIF
      ENDDO
      RETURN
 900  WRITE(*,*) '### STOP in FoamA_ActUpda: not found iCell=', iCell
      STOP
 950  WRITE(*,*) '### STOP in FoamA_ActUpda: list of active cells too short'
      STOP
      END                       ! FoamA_ActUpda



      SUBROUTINE FoamA_BufActPrint(mout)    
C !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Active cells only                                                              //
*//   Side=1 indicates that this cell is "side leaf" sticking out of main branch     //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            iCell,mout,active,Side,Pare,j
      DOUBLE PRECISION   VolRat,CruRat,VoluSum,CrudSum,RatMax,RatMin,Fact,WtMin,WtMax
      DOUBLE PRECISION   AveWt, Sigma, Nentry
*     ----------------------------------------------------------------
      WRITE(mout,'(3a)') '==================================================', ' ACTIVE CELLS ',
     $                   '=================================================='
      VoluSum =0d0
      CrudSum =0d0
      RatMin  =  1d60
      RatMax  = -1d60
      WtMin   =  1d60
      WtMax   = -1d60
      active  =0
      WRITE(mout,'(2a)') ' iCell Stat Pare Dau1 Dau2 Side',
     $                   '     WtMin      WtMax        <w>    Sig/<w>      Crude    VolTrue   Ver1  Ver2 ...'
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            side=0
            Pare = m_CePare(iCell)
            IF( m_CeStat(m_CeDau1(Pare))*m_CeStat(m_CeDau2(Pare)) .EQ. 0  ) Side=1
            VolRat = m_CeIntg(iCell)* m_LastAc/m_CeCrud(1)
            CruRat = m_CeCrud(iCell)* m_LastAc/m_CeCrud(1)
            RatMin = Min(RatMin,VolRat)
            RatMax = Max(RatMax,VolRat)
            Nentry = m_CeSum(iCell,3)
            AveWt  = m_CeSum(iCell,1)/m_CeSum(iCell,3)
            Sigma  = DSQRT(  ABS(m_CeSum(iCell,2)/Nentry - AveWt**2))
            IF(AveWt.NE.0d0) WtMin = Min( WtMin, m_CeSum(iCell,4)/AveWt)
            IF(AveWt.NE.0d0) WtMax = Max( WtMax, m_CeSum(iCell,5)/AveWt)
            IF(AveWt.NE.0d0) Sigma = Sigma/AveWt
            WRITE(mout,'(6i5, 6f11.5 ,10i5)') 
     $           iCell, m_CeStat(iCell),  m_CePare(iCell),  m_CeDau1(iCell),m_CeDau2(iCell),  side,
     $           m_CeSum(iCell,4)/(m_CeCrud(iCell)+1d-100), ! minWt/AveWt
     $           m_CeSum(iCell,5)/(m_CeCrud(iCell)+1d-100), ! maxWt/AveWt
     $           m_CeIntg(iCell) /(m_CeCrud(iCell)+1d-100), ! average weight
     $           Sigma,                  ! sigma/AveWt
     $           CruRat,                 ! Crude/CruTot*Ncell
     $           VolRat,                 ! TrueVolu/VolTot*Ncell
     $           (m_CeVert(iCell,j), j=1,m_Ndim+1) ! vertices
            VoluSum = VoluSum +m_CeIntg(iCell)
            CrudSum = CrudSum +m_CeCrud(iCell)
            active  = active +1
         ENDIF
      ENDDO
      WRITE(mout,'(a,i6,a,2i6)') 'All cells: ',m_LastCe, '      Active: ', active, m_LastAc
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Volume/Tot*nCell  = ',RatMin,RatMax
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Weight/<Wt>       = ',WtMin,WtMax
      WRITE(mout,'(a,2g20.13)')  'Total True  Volume in active cells = ', VoluSum, m_CeIntg(1)
      WRITE(mout,'(a,2g20.13)')  'Total Crude Volume in active cells = ', CrudSum, m_CeCrud(1)
      WRITE(mout,'(a,f12.5)')   'True/Crude = ', VoluSum/CrudSum
      END                       !! FoamA_BufActPrint




      SUBROUTINE FoamA_BufPrint(mout)     
C!# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all cells                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            iCell,mout,active,j
*     ----------------------------------------------------------------
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
      END                       !! FoamA_BufPrint


      SUBROUTINE FoamA_Check(mout,level)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Checks all pointers, this is necessary autodiagnostic because of the complicated//
*//  collapse algorithm.                                                             //
*//                                                                                  //
*//  level=0, no printout, failures causes STOP                                      //
*//  level=1, printout, failures lead to WARNINGS only                               //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER       mout,level
      INTEGER       nFailures, iCell, Dau1,Dau2, Pare, NoRefs(m_vMax), iVe,n
      INTEGER       NoEmpty
*     ---------------------------------------------------------
      nFailures=0
      IF(level.EQ.1) WRITE(mout,*)
     $'//////////////////////////////////////// FoamA_Checks /////////////////////////////////////////////'
      DO iCell = 1,m_LastCe
         Dau1 = m_CeDau1(iCell)
         Dau2 = m_CeDau2(iCell)
         Pare = m_CePare(iCell)
* checking on parents
         IF(iCell.GT.1) THEN
            IF(Pare.GT.m_LastCe) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Parent out of range = ',Pare
            ENDIF
         ENDIF
         IF(iCell.GT.1) THEN
            IF(  (Pare.NE.1) .AND. (m_CeDau1(Pare).NE.iCell) .AND. (m_CeDau2(Pare).NE.iCell)  ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Parent not pointing to this daughter Pare= ',Pare
            ENDIF
         ENDIF
* checking on daughters
         IF( Dau1 .GT. m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter out of range Dau1= ',Dau1
         ENDIF
         IF( Dau2 .GT.m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter out of range Dau2= ',Dau2
         ENDIF
         IF( Dau1.GE.1 .AND. Dau1.LE. m_LastCe) THEN
            IF( m_CePare(Dau1).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter not pointing to parent Dau1= ',Dau1
            ENDIF
         ENDIF
         IF( Dau2.GE.1 .AND. Dau2.LE. m_LastCe) THEN
            IF( m_CePare(Dau2).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter not pointing to parent Dau2= ',Dau2
            ENDIF
         ENDIF 
      ENDDO
* check on vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO n=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,n) ) NoRefs(iVe) =1
            ENDDO
         ENDDO
      ENDDO
      DO iVe = 1, m_LastVe
         IF(NoRefs(iVe).EQ.0 .AND.  level.EQ.1) WRITE(mout,*) '***** Vertex no. ',iVe, '  NOT referenced!'
      ENDDO
* Check for empty cells
      NoEmpty = 0d0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            IF( m_CeCrud(iCell) .EQ. 0d0) NoEmpty = NoEmpty +1
         ENDIF
      ENDDO
      IF( NoEmpty.GT.0) THEN
         WRITE(mout,*) '++++++++++ FoamA_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
         WRITE(   *,*) '++++++++++ FoamA_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
      ENDIF
* summary
      IF(level.EQ.1) WRITE(mout,*) '++++++++++ FoamA_Check has found total ', nFailures, ' failures '
      IF(level.EQ.1) WRITE(mout,*)
     $'///////////////////////////////////////////////////////////////////////////////////////////////////'
      IF(level.EQ.0 .AND. nFailures.GT.0 ) THEN
         WRITE(mout,*) '++++++++++ STOP in FoamA_Check, found total ', nFailures, ' failures '
         STOP
      ENDIF
      END                       ! FoamA_Check


      SUBROUTINE FoamA_Collapse    !# Initialization
*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//   This routine remooves unsuccesfull cells which have collected too litle "Volume"    //
*//   before the new round of divisions                                                   //
*//                                                                                       //
*//   The procedure is the following:                                                     //
*//   1. find most succesfull (the sweetest) active cell and find its VoluMax             //
*//   2. Scan entire buffer/tree from top to bottom, inactive cells                       //
*//   3. Activate every nonactive cell with Vol<VoluMax*KilFac and kill its pending tree  //
*//   4. Collapse all storage, list of cells, vertices etc. to make room for new iteration//
*//                                                                                       //
*//   Remooving "dead cells" and "unreferenced vertives" is the hardes part of the task   //
*//   I have found that this can be done most easily with special "mask matrices"         //
*//                                                                                       //
*///////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION  CrudMax,CrudOrig,Crud
      INTEGER           MaskV(m_vMax),    LinkV(m_vMax), kVer, kSum, iStart
      INTEGER           MaskC(m_nBufMax), LinkC(m_nBufMax)
      INTEGER           iCell, kCell, Pare, Stat, Dau1,Dau2, k, i, parent
*     -------------------------------------------------------
* Find richest ACTIVE cell
      CrudMax = 0d0
      DO iCell = 1,m_LastCe
         Stat= m_CeStat(iCell)
         IF(Stat .EQ.1 ) CrudMax= Max(CrudMax, m_CeCrud(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Find nonactive celles which are poorer than richest asctive (with CrudMax)    //
*// redefine them as active and kill trailing branch.                             //
*// Cells scheduled for remooval taged with Stat=-3                               //
*// We start with first Cell which is true daughter, iCell=iStart                 //
*///////////////////////////////////////////////////////////////////////////////////
      iStart = m_CeDau2(1)+1
***** WRITE(*,*) ' CrudMax,iStart =',CrudMax,iStart
      DO iCell = iStart ,m_LastCe
         Stat= m_CeStat(iCell)
         Dau1=m_CeDau1(iCell)
         Dau2=m_CeDau2(iCell)
*     let us first check if we are on the dead branch, if yes then shcedule daughters for remooval
         IF(Stat .EQ. -3 ) THEN
*****       WRITE(*,*) ' we are on the dead branch, iCell =',iCell,'Daughters to be killed',Dau1,Dau2
            IF(Dau1.NE.-1) m_CeStat(Dau1) = -3
            IF(Dau2.NE.-1) m_CeStat(Dau2) = -3
            m_CeDau1(iCell) = -1
            m_CeDau2(iCell) = -1
         ELSEIF( Stat .EQ. 0 ) THEN ! otherwise if it is normal inactive cell
*     reproduce original Crude as in Explore (may be this thould be memorized in Explore?)
            IF(     m_OptCrude.EQ.0 ) THEN
               CrudOrig  =  m_CeIntg(iCell) ! true volume
            ELSEIF( m_OptCrude.EQ.1 ) THEN
               CrudOrig  =  DSQRT(m_CeSum(iCell,2)/m_nSampl) ! Sqrt( <w>**2 + sigma**2 )
            ELSEIF( m_OptCrude.EQ.2 ) THEN
               CrudOrig    =  m_CeSum(iCell,5) ! wtmax
            ELSE
               WRITE(m_out,*) ' ++++ STOP in FoamA_Explore, wrong m_OptCrude =',m_OptCrude
               STOP
            ENDIF
            Crud= m_CeCrud(iCell)
*****       WRITE(*,*) ' Normal inactive iCell =',iCell,'CrudOrig,Crud=',CrudOrig,Crud
            IF(CrudOrig .LT. CrudMax*m_KillFac ) THEN     ! and if it is poor in sugar, make it active
               m_CeStat(iCell) = 1                        ! REVIVE, reset status as ACTIVE
               m_CeStat(Dau1) = -3                        ! and kill both daugters
               m_CeStat(Dau2) = -3               
               m_CeDau1(iCell) = -1
               m_CeDau2(iCell) = -1
*****          WRITE(*,*) ' poor cell, iCell,Stat =',iCell,Stat,'killed Daughters',Dau1,Dau2
*     Go back to original Crude in this cell and correct in all parent cells to the top of the tree
               m_CeCrud(iCell) = CrudOrig
               parent = m_CePare(iCell)
               DO i = 1,m_nBuf
                  IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
                  m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -Crud)
                  parent=m_CePare(parent)
               ENDDO
 100           CONTINUE
            ENDIF
         ENDIF      
      ENDDO
***** WRITE(*,*) '########## Now cells scheduled for remooval have status -3 !!!  '
***** CALL FoamA_BufPrint(6)
*///////////////////////////////////////////////////////////////////////////////////
*// Remoove inactive cells. Quite nontrivial task.                                //      
*// First find out which cell is dead, result is stored in MaskC                  //
*///////////////////////////////////////////////////////////////////////////////////
      DO iCell =1,m_LastCe
         MaskC(iCell)=0
      ENDDO
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell) .NE. -3 ) MaskC( iCell ) =1
      ENDDO
* MaskC turned into step-function LinkC, used in translation of pointers in cells
      kSum =0
      DO iCell = 1,m_LastCe
         kSum         = kSum +MaskC(iCell)
         LinkC(iCell) = kSum
      ENDDO
***** DO iCell = 1,m_LastCe
***** WRITE(*,*) 'iCell, MaskC, LinkC ====>', iCell, MaskC(iCell),LinkC(iCell)
***** ENDDO
* Collapse buffer by shifting downwards all cells
      DO iCell = 1,m_LastCe
         IF(MaskC(iCell).NE.0 ) THEN
            m_CeStat( LinkC(iCell) ) = m_CeStat( iCell )
            m_CePare( LinkC(iCell) ) = m_CePare( iCell )
            m_CeDau1( LinkC(iCell) ) = m_CeDau1( iCell )
            m_CeDau2( LinkC(iCell) ) = m_CeDau2( iCell )
            DO k=1,m_Ndim+1
               m_CeVert( LinkC(iCell),k ) = m_CeVert( iCell ,k)
            ENDDO
            m_CeIntg( LinkC(iCell) ) = m_CeIntg( iCell )
            m_CeCrud( LinkC(iCell) ) = m_CeCrud( iCell )
            m_CeVolu( LinkC(iCell) ) = m_CeVolu( iCell )
            m_CeXave( LinkC(iCell) ) = m_CeXave( iCell )
            m_CeBest( LinkC(iCell) ) = m_CeBest( iCell )
            DO k=1,m_sMax
               m_CeSum( LinkC(iCell),k ) = m_CeSum( iCell,k )
            ENDDO
         ENDIF
      ENDDO
      m_LastCe = kSum
* pointers to parents and daughters have to be also translated/updated
      DO iCell = 1,m_LastCe
         IF(m_CePare(iCell).GE.1 ) m_CePare(iCell) = LinkC( m_CePare(iCell) )
         IF(m_CeDau1(iCell).GE.1 ) m_CeDau1(iCell) = LinkC( m_CeDau1(iCell) )
         IF(m_CeDau2(iCell).GE.1 ) m_CeDau2(iCell) = LinkC( m_CeDau2(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Reconstruction of list of vertices. Kick out unreferced vertices.             //
*// First we construct MaskV which tells us which vertex is still in use          //
*///////////////////////////////////////////////////////////////////////////////////
***** CALL FoamA_BufPrint(   6)
***** CALL FoamA_VertPrint(  6)
      DO kVer =1,m_LastVe
         MaskV(kVer)=0
      ENDDO
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            MaskV( m_CeVert(iCell,k) )=1
         ENDDO
      ENDDO
***** DO kVer =1,m_LastVe
*****   WRITE(*,*) 'kVer, MaskV ====>', kVer, MaskV(kVer),(m_VerX(kVer,k),k=1,m_Ndim)
***** ENDDO
* MaskV turned into step-function LinkV, used in translation of pointers in cells
      kSum =0
      DO kVer =1,m_LastVe
         kSum         = kSum +MaskV(kVer)
         LinkV(kVer) = kSum
      ENDDO
* Translate pointers in Cells
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            m_CeVert(iCell,k) = LinkV( m_CeVert(iCell,k) )
         ENDDO
      ENDDO
* And reorganize list of vertices as well !!!
      DO kVer =1,m_LastVe
         IF(MaskV(kVer).NE.0 ) THEN
            DO k=1,m_Ndim
               m_VerX( LinkV(kVer), k )=m_VerX( kVer, k )
            ENDDO
         ENDIF
      ENDDO
      m_LastVe = kSum

***** CALL FoamA_VertPrint(   6)
***** WRITE(*,*) '######################### FoamA_Collapse  is complete #####################'
***** CALL FoamA_BufPrint(    6)
***** CALL FoamA_BufActPrint( 6)

* Update list of active cells, only for internal tests
      CALL FoamA_ActUpda
      CALL FoamA_Check(6,0)     ! Check if Collapseion result is OK
*
      END                       ! FoamA_Collapse


      SUBROUTINE FoamA_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)   
C !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create new (daughter) cell and append it at the very end of the buffer         //
*//   iCeNew is pointer of the new cell                                              //
*//   Note clever trick: volume of this daughter is assigned initialy half volume    //
*//   of the parent, if parent exists.                                               //
*//   In Explore this value is used to update all parents such that                  //
*//   in the entrire tree parents have volume being sum of all daughter volumes.     //
*//   This summation discipline is useful for MC generation of an active cell by     //
*//   going randomly from top to bottom of the tree.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            Stat,Pare,Dau1,Dau2,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
*     ------------------------------------------------------------------
      IF( m_LastCe .EQ. m_nBuf) THEN
         WRITE(*,*) ' STOP in FoamA_DefNewCell: something wrong with m_nBuf '
         STOP
      ENDIF
      m_LastCe = m_LastCe+1
      iCeNew   = m_LastCe
      m_CeStat(iCeNew)= Stat                    ! status code, =0 inactive, =1 active
      m_CePare(iCeNew)= Pare                    ! parent cell pointer
      m_CeDau1(iCeNew)= Dau1                    ! daughter1 cell pointer
      m_CeDau2(iCeNew)= Dau2                    ! daughter2 cell pointer
      m_CeBest(iCeNew)= -1                      ! pointer for planning division of the cell
      m_CeXave(iCeNew)= 0.5d0                   ! factor for division
      DO k=1,m_NdiMax+1
         m_CeVert(iCeNew,k)= Vertex(k)
      ENDDO
c      m_CeVert(iCeNew,1)= Ver1                  ! 1-st vertex pointer
c      m_CeVert(iCeNew,2)= Ver2                  ! 2-nd vertex pointer
c      m_CeVert(iCeNew,3)= Ver3                  ! 3-rd vertex pointer
c      m_CeVert(iCeNew,4)= Ver4                  ! 4-th vertex pointer
      IF(Pare.NE.-1) THEN
         m_CeIntg(iCeNew)= m_CeIntg(Pare)/2d0   ! integr. half of parent
         m_CeCrud(iCeNew)= m_CeCrud(Pare)/2d0   ! integr. half of parent
      ELSE
         m_CeIntg(iCeNew)= 0d0
         m_CeCrud(iCeNew)= 0d0
      ENDIF
      m_CeVolu(iCeNew)= 0d0                     ! cartesian Volume   
      END                       ! FoamA_DefCell

      SUBROUTINE FoamA_DefNewCell(Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   obsolete!!!!                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
      Vertex(1) = Ver1
      Vertex(2) = Ver2
      Vertex(3) = Ver3
      Vertex(4) = Ver4
      CALL FoamA_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
      END                       !!!FoamA_DefNewCell

      DOUBLE PRECISION FUNCTION FoamA_Det2Lapl(R,i1,i2)    
C!# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      INTEGER  i1,i2
*     ------------------------------------------------------------
      FoamA_Det2Lapl= R(1,i1)*R(2,i2) - R(1,i2)*R(2,i1)
      END


      DOUBLE PRECISION FUNCTION FoamA_Det3Lapl(R,i1,i2,i3)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamA_Det2Lapl
      INTEGER  i1,i2,i3
*     ------------------------------------------------------------
      FoamA_Det3Lapl=+R(3,i1) *FoamA_Det2Lapl(R,i2,i3)
     $               -R(3,i2) *FoamA_Det2Lapl(R,i1,i3)
     $               +R(3,i3) *FoamA_Det2Lapl(R,i1,i2)
      END

      DOUBLE PRECISION FUNCTION FoamA_Det4Lapl(R,i1,i2,i3,i4)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamA_Det3Lapl
      INTEGER  i1,i2,i3,i4
*     ------------------------------------------------------------
      FoamA_Det4Lapl=-R(4,i1) *FoamA_Det3Lapl(R,i2,i3,i4)
     $               +R(4,i2) *FoamA_Det3Lapl(R,i1,i3,i4)
     $               -R(4,i3) *FoamA_Det3Lapl(R,i1,i2,i4)
     $               +R(4,i4) *FoamA_Det3Lapl(R,i1,i2,i3)
      END

      DOUBLE PRECISION FUNCTION FoamA_Det5Lapl(R,i1,i2,i3,i4,i5)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax), Det, FoamA_Det4Lapl
      INTEGER  i1,i2,i3,i4,i5
*     ------------------------------------------------------------
      FoamA_Det5Lapl=+R(4,i1) *FoamA_Det4Lapl(R,i2,i3,i4,i5)
     $               -R(4,i2) *FoamA_Det4Lapl(R,i1,i3,i4,i5)
     $               +R(4,i3) *FoamA_Det4Lapl(R,i1,i2,i4,i5)
     $               -R(4,i4) *FoamA_Det4Lapl(R,i1,i2,i3,i5)
     $               +R(4,i5) *FoamA_Det4Lapl(R,i1,i2,i3,i4)
      END


      SUBROUTINE FoamA_Determinant(R,Det)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Calculates determinant of matrix R                                             //
*//   Use of Laplace formula should be perhaps replaced with something faster        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      DOUBLE PRECISION   FoamA_Det2Lapl, FoamA_Det3Lapl,FoamA_Det4Lapl,FoamA_Det5Lapl
*     -------------------------------------------------
      IF(        m_Ndim .EQ. 1) THEN
         Det= R(1,1)
      ELSEIF(    m_Ndim .EQ. 2) THEN
         Det= FoamA_Det2Lapl(R, 1,2)
      ELSEIF(    m_Ndim .EQ. 3) THEN
         Det= FoamA_Det3Lapl(R, 1,2,3)
      ELSEIF(    m_Ndim .EQ. 4) THEN
         Det= FoamA_Det4Lapl(R, 1,2,3,4)
      ELSEIF(    m_Ndim .EQ. 5) THEN
         Det= FoamA_Det5Lapl(R, 1,2,3,4,5)
      ELSE
         WRITE(*,*) '####FoamA_Determinant: STOP, m_Ndim =',m_Ndim
         STOP
      ENDIF
      END                       ! FoamA_Determinant


      SUBROUTINE FoamA_Divide(iCell,funW,RC)     
C!# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Divide cell iCell into two daughter cells                                      //
*//   The iCell is retained and taged as inactive, daughter cells are appended       //
*//   at the end of the buffer.                                                      //
*//   New vertex is added to list of vertice.                                        //
*//   List of active cells is updated, iCell remooved, two daughters added           //
*//   and their properties set with help of MC sampling (FoamA_Explore)              //
*//   Return Code RC=-1 of buffer limit is reached,  m_LastCe=m_nBuf                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            iCell,RC
      INTEGER            Dau1, Dau2, kVer1(m_NdiMax+1), kVer2(m_NdiMax+1),p1,p2
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            Old1,Old2,j,k,jv,iv,kBest,nPairs
      DOUBLE PRECISION   Xave
*--------------------------------------------------------------------------------------
      RC = 0
      IF( m_LastCe+2 .GT. m_nBuf) GOTO 990 !! abort if no space in buffer
* reset cell as inactive
      m_CeStat(iCell) = 0
*------------------------------------------------------------------------------------
* add new vertex to the list
      m_LastVe=m_LastVe+1
      IF(m_LastVe.GT.m_vMax) GOTO 980
      Xave  = m_CeXave(iCell)
      kBest = m_CeBest(iCell)
      nPairs=0
      DO jv=1,m_Ndim+1
         DO iv=jv+1,m_Ndim+1
            nPairs=nPairs+1
            IF( nPairs.EQ.kBest) THEN
               p1 =  m_CeVert(iCell,jv)
               p2 =  m_CeVert(iCell,iv)
               DO j=1,m_Ndim
                  m_VerX(m_LastVe,j) = Xave*m_VerX(p1,j) + (1d0-Xave)*m_VerX(p2,j)
               ENDDO
               Old1=jv
               Old2=iv
               GOTO 100
            ENDIF
         ENDDO
      ENDDO
 100  CONTINUE
c[[[[[
c      WRITE(*,'(a,6f12.6)') 'FoamA_Divide: new vertex =',(m_VerX(m_LastVe,k), k=1,m_Ndim)
c]]]]]
*------------------------------------------------------------------------------------
* define lists of vertices for daughters, one old vertex replaced by new one
      DO jv=1,m_Ndim+1
         kVer1(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old1) kVer1(jv)=m_LastVe
         kVer2(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old2) kVer2(jv)=m_LastVe
      ENDDO
* define two daughter cells (active)
*   ----------------------- Stat, Pare, Dau1,Dau2,  Vertex,  iCeNew)
      CALL FoamA_DefCell(      1, iCell,  -1,  -1,   kVer1,  Dau1)
      CALL FoamA_DefCell(      1, iCell,  -1,  -1,   kVer2,  Dau2)
      m_CeDau1(iCell) = Dau1
      m_CeDau2(iCell) = Dau2
      CALL FoamA_Explore(Dau1,funW)
      CALL FoamA_Explore(Dau2,funW)
* Update list of active cells, only for internal tests
      CALL FoamA_ActUpda
      RETURN
 990  RC=-1                     !!buffer limit is reached,  m_LastCe=m_nBuf
      RETURN
 980  WRITE(*,*) ' ### STOP in FoamA_Divide: too short list of vertices '
      STOP
      END                       ! FoamA_Divide


      SUBROUTINE FoamA_Explore(iCell,funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Explore newly defined cell with help of special short MC sampling              //
*//   As a result, estimetes of true and crude volume will be defined                //
*//   Average and dispersion of the weight distribution will be found along each     //
*//   edge and the best edge (minimum dispersion) is memorized for future use.       //
*//   Axerage x for eventual future cell division is also defined.                   //
*//   Recorded are aso minimum and maximu weight etc.                                //
*//   The volume estimate in all (inactive) parent cells is updated                  //
*//   Note that links to parents and initial volume = 1/2 parent has to be           //
*//   already defined prior to calling this routine.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            i,j,k,parent,iCell,iv,jv,nPairs,pBest,kBest
      DOUBLE PRECISION   x,x1,x2,Dx,Dxx,Wt,Vsum,SumWt,Sum
      DOUBLE PRECISION   Xave,Xdisp,DispMin
      DOUBLE PRECISION   Beta(m_NpairMax),BetaMax
      DOUBLE PRECISION   VolOld, CruOld, XrSum,Factorial
      DOUBLE PRECISION   Vec(m_NdiMax+1,m_NdiMax), Xre(m_NdiMax,m_NdiMax), Yre(m_NdiMax,m_NdiMax)
      DOUBLE PRECISION   Vrand(m_NdiMax)
      DOUBLE PRECISION   Lambda(m_NdiMax),VolPart(m_NdiMax+1)
      DOUBLE PRECISION   Xdivi(m_NpairMax),Xsu1(m_NpairMax),Xsu2(m_NpairMax)
      INTEGER            nBin,iBin
      PARAMETER          (nBin=25)
      DOUBLE PRECISION   Histo(m_NpairMax,nBin),Bins(nBin)
      DOUBLE PRECISION   funW
      EXTERNAL           funW
*-----------------------------------------------------------------------
      Factorial=1
      DO i=1,m_Ndim
         Factorial=Factorial*i
      ENDDO
* memorize old values, will be needed for correcting parent cells
      VolOld = m_CeIntg(iCell)
      CruOld = m_CeCrud(iCell)
* Estimate volume and find out average value of x
* decode vertex vectors
      DO iv=1,m_Ndim+1
         DO j=1,m_Ndim
            Vec(iv,j) = m_VerX( m_CeVert(iCell,iv) ,j)
         ENDDO
      ENDDO
* relative last vertex
      DO iv=1,m_Ndim
         DO j=1,m_Ndim
            Xre(iv,j) = Vec(iv,j)-Vec(m_Ndim+1,j)
         ENDDO
      ENDDO
      CALL FoamA_Determinant(Xre,Dx)
      Dx = ABS(Dx)/Factorial    ! Cartesian volume of the Cell
      m_CeVolu(iCell)  = Dx
c[[[[[
c      DO iv=1,m_Ndim
c          WRITE(*,'(a,9f10.5)') '### Xre=',(Xre(iv,j),j=1,m_Ndim)
c      ENDDO
c      WRITE(*,'(a,f12.6)') 'FoamA_Explore: Cartesian volume Dx =',Dx
c]]]]]
*/////////////////////////////////////////////////////
*//    Special Short MC sampling to probe cell      //
*/////////////////////////////////////////////////////
      m_CeSum(iCell,1) =  0
      m_CeSum(iCell,2) =  0
      m_CeSum(iCell,3) =  0
      m_CeSum(iCell,4) =  1d90  ! wtmin
      m_CeSum(iCell,5) = -1d90  ! wtmax
      DO k=1,m_NpairMax
         Xsu1(k)=0d0
         Xsu2(k)=0d0
         Beta(k)=0d0
         DO iBin=1,nBin
            Histo(k,iBin)=0d0
         ENDDO
      ENDDO
* here we do additional scan over vertices in order to improve max/min weights
      IF( m_OptEdge .EQ. 1 ) THEN
         DO iv=1,m_Ndim+1
            DO j=1,m_Ndim
               Vrand(j) = m_VerX( m_CeVert(iCell,iv) ,j)
            ENDDO
            Wt =funW(Vrand)*Dx  ! weight average normalised to integral over the cell
            m_nCalls = m_nCalls+1
            m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
            m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
         ENDDO
      ENDIF
*/////////////////////////////////////////////////////
      DO i=1,m_nSampl
*     generate randomly/uniformly vector Vrand inside this simplex
         CALL FoamA_MakeLambda(Lambda)
         DO j=1,m_Ndim
            Vrand(j) = Vec(m_Ndim+1,j)
            DO iv=1,m_Ndim
               Vrand(j) = Vrand(j) +Lambda(iv)*Xre(iv,j)
            ENDDO
         ENDDO
****     WRITE(*,'(a,6f12.6)') ' Lambda    =',(Lambda(k),k=1,m_Ndim)
****     WRITE(*,'(a,6f12.6)') ' Vrand     =',(Vrand(k), k=1,m_Ndim)
*---------------------------------------------------------------------------------
* calculate partial volumes, raw material for planning future divion of the cell
* vertex jv will be replaced with the random vertex
         Vsum=0d0
         DO jv=1,m_Ndim+1
* all vertices relative to random vector, jv is omitted
            k=0
            DO iv=1,m_Ndim+1
               IF(iv.NE.jv) THEN
                  k=k+1
                  DO j=1,m_Ndim
                     Yre(k,j) = Vec(iv,j)-Vrand(j)
                  ENDDO
               ENDIF
            ENDDO
            CALL FoamA_Determinant(Yre,Dxx)
            VolPart(jv) = ABS(Dxx)/Factorial
            Vsum=Vsum + VolPart(jv)
         ENDDO
         IF( ABS(Vsum-DX) .GT. 1d-6) GOTO 950
*------------------------------------------------------------------------------------
         nPairs=0
         DO jv=1,m_Ndim+1
            DO iv=jv+1,m_Ndim+1
               nPairs=nPairs+1
               Xdivi(nPairs) = VolPart(jv)/(VolPart(jv)+VolPart(iv))
            ENDDO
         ENDDO
*------------------------------------------------------------------------------------
         Wt =funW(Vrand)*Dx        ! weight average normalised to integral over the cell
         m_nCalls = m_nCalls+1
         m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt         ! sum of weights
         m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt      ! sum of weights squared
         m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0        ! sum of 1
         m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt)    ! minium weight
         m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt)    ! maximu weight
* Search for the best edge candidate for future cell division, prepare MC material
         DO k=1,nPairs
            Xsu1(k)=Xsu1(k) +Xdivi(k)*Wt                 ! averages for all Xdivi
            Xsu2(k)=Xsu2(k) +Xdivi(k)**2*Wt
            iBin = INT(Xdivi(k)*nBin)+1d0
            iBin = MIN(MAX(iBin,0),nBin)
            Histo(k,iBin) = Histo(k,iBin)+Wt             ! fill histo for each edge
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.9) THEN
c               CALL GLK_Fil1(1200+k, Xdivi(k),Wt)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ENDDO
      ENDDO
*///////////////////////////////////////////////////////
*//   End of Special Short MC sampling to probe cell  //
*///////////////////////////////////////////////////////
*
* Determine the best edge candidate for future cell division, using MC  material
      pBest =0
      kBest =0
      DispMin =  1d150
      BetaMax = -1d150
      DO k=1,nPairs
         SumWt  = m_CeSum(iCell,1)
         IF( SumWt .NE. 0d0) THEN
            Beta(k) = 0d0
            Xave  = Xsu1(k)/SumWt             ! average lambda
            Xdisp = Xsu2(k)/SumWt  -Xave**2   ! dispersion of lambda
            Sum =0d0
            DO iBin=1,nBin
               Sum = Sum + Histo(k,iBin)/SumWt
               Beta(k) = Beta(k) +ABS((Sum*nBin-iBin)/nBin)
               Bins(iBin) = Sum               ! cumulative (for tests)
            ENDDO
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.20) THEN
c               CALL GLK_Pak(  1200+k,Bins)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ELSE
            Beta(k) = 1d0
            Xave  = 0.5d0
            Xdisp = 0.5d0
         ENDIF
c         IF( Xdisp.LT.0d0 ) THEN
c            WRITE(*,*) ' FoamA_Explore: Dispersion negative Xdisp,Xave=',Xdisp,Xave !
c         ENDIF
         IF( (Xave.LT.0d0) .OR. (Xave.GT.1d0) ) THEN
            WRITE(*,*) ' FoamA_Explore: Xave out of range   Xdisp,Xave=',Xdisp,Xave !
         ENDIF
         Xsu1(k) = Xave
         Xsu2(k) = SQRT(ABS(Xdisp))
         IF(Xsu2(k).LT.DispMin) THEN
            pBest=k
            DispMin = Xsu2(k)
         ENDIF
         IF(Beta(k).GT.BetaMax) THEN
            kBest=k
            BetaMax = Beta(k)
         ENDIF
      ENDDO
      IF(pBest .EQ. 0) GOTO 960
      IF(kBest .EQ. 0) GOTO 960
*
* Some test variants, do nothing for default m_OptBeta=0
      IF(     m_OptBeta .EQ. 1) THEN
         kBest = pBest                 ! pBest based on dispersion is generally less effective
      ELSEIF( m_OptBeta .EQ. 2) THEN
         CALL  FoamA_RanDiscr(Beta, nPairs, m_BetaPower, kBest) ! sometimes profitable
      ENDIF
***** WRITE(*,'(a,6f12.6)') ' Xdivi average   =',(Xsu1(k), k=1,nPairs)
***** WRITE(*,'(a,6f12.6)') ' Xdivi dispersion=',(Xsu2(k), k=1,nPairs)
***** WRITE(*,*) 'pBest, DispMin =',pBest, DispMin
*[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
c      WRITE(*,'(a,5I5)') '=======>>>>> FoamA_Explore: iCell,kBest,pBest = ',iCell,kBest,pBest
c      k=0
c      DO jv=1,m_Ndim+1
c         DO iv=jv+1,m_Ndim+1
c            k=k+1
c            WRITE(*,'(a,3I5,4f12.6)') 'k,jv,iv,Xave,Xdisp,Beta= ',
c     $           k,m_CeVert(iCell,iv),m_CeVert(iCell,jv),Xsu1(k),Xsu2(k),Beta(k) !
c         ENDDO
c      ENDDO
*]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

      IF( m_CeSum(iCell,1) .LT.0d0) GOTO 920
      m_CeXave(iCell)  = Xsu1(kBest)
      m_CeBest(iCell)  = kBest
      m_CeIntg(iCell)  = m_CeSum(iCell,1)/m_nSampl        ! estimator of the true integral
*     !!!!!!!!!  CRUDE volume for MC generation purpose !!!!!!!!!!
      IF(     m_OptCrude.EQ.0 ) THEN
         m_CeCrud(iCell)  =  m_CeIntg(iCell)                   ! true integral
      ELSEIF( m_OptCrude.EQ.1 ) THEN
         m_CeCrud(iCell)  =  DSQRT(m_CeSum(iCell,2)/m_nSampl)  ! Sqrt( <w>**2 + sigma**2 )
      ELSEIF( m_OptCrude.EQ.2 ) THEN
         m_CeCrud(iCell)  =  m_CeSum(iCell,5)                  ! wtmax
      ELSE
         WRITE(m_out,*) ' ++++ STOP in FoamA_Explore, wrong m_OptCrude =',m_OptCrude
         WRITE(    *,*) ' ++++ STOP in FoamA_Explore, wrong m_OptCrude =',m_OptCrude
         STOP
      ENDIF
* correct volume and crude in all parent cells to the top of the tree
      parent = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         m_CeIntg(parent)  = m_CeIntg(parent)  +( m_CeIntg(iCell)  -VolOld)
         m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -CruOld)
         parent=m_CePare(parent)
      ENDDO
 100  CONTINUE
      RETURN
 920  WRITE(*,*) ' ### STOP in FoamA_Explore: something wrong with integrand '
      STOP
 950  WRITE(*,*) ' ### STOP in FoamA_Explore: something wrong with volume calculation '
      STOP
 960  WRITE(*,*) ' ### STOP in FoamA_Explore: something wrong with best pair pointer =',kBest
      STOP
      END                       ! FoamA_Explore



      SUBROUTINE FoamA_Finalize(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   After MC run is completed it calculates integral and its error         //
*//   Also prints some information/statistics on the MC run                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
*
      DOUBLE PRECISION     MCresult,MCerror,MCerelat
      DOUBLE PRECISION     Vtot,Verr,VerRela
*-----------------------------------------------------------------------------
      MCresult =0d0
      MCerelat =1d0
      IF(m_NevGen .GT. 0) MCresult = m_Crude *m_SumWt/m_NevGen
      IF(m_NevGen .GT. 0) MCerelat = SQRT( m_SumWt2/m_SumWt**2 -1d0/m_NevGen )
      MCerror = MCresult*MCerelat
* some test printouts
      WRITE(m_Out,'(3a)') '============================================================================='
      WRITE(m_Out,'(3a)') '==============================', ' FoamA_Finalize ',
     $                    '=============================='
      WRITE(m_Out,'(a,2g18.9,f11.7)')               'MCresult, MCerror, Errela= ',MCresult,MCerror,MCerelat
      WRITE(m_Out,'(a,2f11.5)')                     'Minimum maximum weight   = ',m_WtMin,m_WtMax
      IF(m_NevGen .GT. 0) WRITE(m_Out,'(a,2f11.5)') 'Average weight           = ',m_SumWt/m_NevGen
      WRITE(m_Out,'(a,i15)')                        'Total number of function calls =',m_nCalls
      WRITE(m_Out,'(a,i15)')                        'Number of vertices = ', m_LastVe
* Total integral from cell statistics, including initialization + MC generation
      CALL FoamA_GetIntegral(Vtot,Verr)
      VerRela = Verr/Vtot
      WRITE(m_Out,'(3a)') '-----------------------------------------------------------------------------'
      WRITE(m_Out,'(3a)') 'Still better final results using information accumulated in initialization'
      WRITE(m_Out,'(a,2g18.9,f11.7)')                'Vtot, Verr, Errela       = ',  Vtot,Verr, VerRela
      WRITE(m_Out,'(3a)') '============================================================================='
      END       ! FoamA_Finalize


      SUBROUTINE FoamA_GetCrude(Crude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION     Crude
      Crude = m_Crude
      END


      SUBROUTINE FoamA_GetIntegral(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION     MCresult,MCerror
      DOUBLE PRECISION     Vtot,Verr,Nent,AveWt,Sig2
      INTEGER              iCell
*
      Vtot =0d0
      Verr =0d0
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            Nent  = m_CeSum(iCell,3)
            AveWt = m_CeSum(iCell,1)/Nent
            Sig2  = m_CeSum(iCell,2)/Nent - AveWt**2
            Vtot = Vtot +AveWt
            Verr = Verr +Sig2/Nent
         ENDIF
      ENDDO
      Verr = SQRT(Verr)
      MCresult = Vtot
      MCerror  = Verr
      END


      SUBROUTINE FoamA_GetMCvector(MCvector)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_Ndim
         MCvector(k)    = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE FoamA_GetMCwt(MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE FoamA_GetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      Ndim
*     -------------------------------------------------
      Ndim = m_Ndim
      END                       !!! FoamA_SetNdim


      SUBROUTINE FoamA_Grow(funW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Grow new cells by division                                                     //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,RC,iCell
*---------------------------------------------
* Final division
      DO i=1,100000
         IF(  m_OptPeek .EQ. 0 ) THEN
            CALL FoamA_PeekMax(iCell)         ! peek up cell with maximum crude
         ELSE
            CALL FoamA_Peek(   iCell)         ! peek up randomly one cell
         ENDIF
         CALL FoamA_Divide( iCell,funW,RC)    ! and divide it into two
c[[[[
c         CALL FoamA_BufPrint(    m_Out)
c         CALL FoamA_VertPrint(  6)
c]]]]
         IF(RC.EQ.-1) GOTO 300
      ENDDO
 300  CONTINUE
      CALL FoamA_Check(6,0)
      END                       ! FoamA_Grow

      SUBROUTINE FoamA_InitCells    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first n-factorial cells inside original cube                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER       k1,k2,k3,k4,k5
      INTEGER       perm(m_NdiMax),mask
      INTEGER       iCe,i,j,k,iVe,Vert(m_NdiMax),digit(m_NdiMax),factorial
*     -----------------------------------------------------------------------------
      factorial=1
      DO k = 1,m_Ndim
         factorial = factorial*k
      ENDDO
      DO iVe=1,m_Ndim+1
         Vert(iVe) =0
      ENDDO
*     -------------------- Stat,Pare, Dau1,        Dau2, VertexList, iCeNew)
      CALL FoamA_DefCell(    -1,  -1,    2, factorial+1,       Vert,      k) ! Master cell Inactive
    
      iCe=0
* The most primitive loop over permutations in the world!
      DO k5 = m_Ndim,1,-1
         DO k4 = m_Ndim,1,-1
            DO k3 = m_Ndim,1,-1
               DO k2 = m_Ndim,1,-1
                  DO k1 = m_Ndim,1,-1
                     perm(1)=k1
                     perm(2)=k2
                     perm(3)=k3
                     perm(4)=k4
                     perm(5)=k5
                     Mask=1
                     DO i=1,m_Ndim
                        DO j=i+1,m_Ndim
                           IF( perm(i).EQ.perm(j) ) Mask=0
                        ENDDO
                     ENDDO
                     IF(Mask.EQ.1) THEN
                        iCe=iCe+1
*                       WRITE(*,*) '########>>>>>>> iCe=',iCe, 'permut= ',(perm(i),i=1,m_Ndim)
                        DO iVe=1,m_Ndim+1
*                          digit represtents just one basic simplex,
*                          the actual one is obtained by permuting dimensions
                           DO k=1,m_Ndim
                              digit(k)=0
                              IF(k.LT.iVe) digit(k)=1
                           ENDDO
*                          translation from "binary" digit to serial pointer of a given vertex
                           j=0
                           DO k=1,m_Ndim
                              j=j+  digit(perm(k)) *2**(k-1)
                           ENDDO
                           Vert(iVe)=j+1
                        ENDDO
*                       WRITE(*,*) '###>>>> Vert= ',(vert(i),i=1,m_Ndim+1)
*                       ----------------- Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
                        CALL FoamA_DefCell(  1,   1,  -1,  -1,  Vert,     k) ! active
                        IF( iCe.EQ.factorial) GOTO 100
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !!!FoamA_InitCells

      SUBROUTINE FoamA_Initialize(FunW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Basic initialization, create "foam of cells"                                   //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iter,i,j,k,iCell
*---------------------------------------------
*
      CALL FoamA_PreInitialize
*
      IF( m_nBuf .GT. m_nBufMax) THEN
         WRITE(*,    *) ' ### STOP in FoamA_Initialize, to big m_nBuf =',m_nBuf
         WRITE(m_Out,*) ' ### STOP in FoamA_Initialize, to big m_nBuf =',m_nBuf
         STOP
      ENDIF

* Initialize list of vertices
      DO i=1,m_vMax
         DO j=1,m_Ndim
            m_VerX(i,j) = 0d0     ! vertices
         ENDDO
      ENDDO

* First  cells are the n-factorial simplexes from division of the basic unit cube
      m_LastCe = 0
      CALL FoamA_InitVertices
      CALL FoamA_InitCells
***************************************************************************************************
* Obsolete old method
*      IF(    m_Ndim .EQ. 2) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamA_DefNewCell( -1,  -1,   2,   3,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 4, 2, 0,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 4, 3, 0,     k) ! active
*      ELSEIF(m_Ndim .EQ. 3) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamA_DefNewCell( -1,  -1,   2,   7,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 2, 4, 8,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 3, 4, 8,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 2, 6, 8,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 3, 7, 8,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 5, 6, 8,     k) ! active
*         CALL FoamA_DefNewCell(  1,   1,  -1,  -1,   1, 5, 7, 8,     k) ! active
*      ENDIF
***************************************************************************************************
      DO iCell = 2,m_LastCe
         CALL FoamA_Explore(iCell,funW) ! Initial MC sampling
      ENDDO
***** CALL FoamA_VertPrint(6)
***** CALL FoamA_BufPrint(    m_Out)

* Life sets on: series of grows and collapss leads to an effective 
* coverage of the integration area with the the cell-foam
      DO iter=1,m_Iterat
         CALL  FoamA_Grow(funW)
*        ------------------------
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamA_BufPrint(    m_Out)
            CALL FoamA_BufActPrint( m_Out)
            CALL FoamA_VertPrint(   m_Out)
         ENDIF
* Kill unsuccesfull cells to make room for another growth
         CALL FoamA_Collapse   ! Collaps
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize<<COLLAPSE Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamA_BufPrint(    m_Out)
            CALL FoamA_BufActPrint( m_Out)
            CALL FoamA_VertPrint(   m_Out)
         ENDIF
      ENDDO
* Final growth
      CALL  FoamA_Grow(funW)
*     -----------------------
      IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
      ENDIF
      IF( m_Chat.EQ.2) THEN
         CALL FoamA_BufPrint(    m_Out)
         CALL FoamA_BufActPrint( m_Out)
         CALL FoamA_VertPrint(   m_Out)
      ENDIF
* Initializations for M.C. generation
      m_Crude  = m_CeCrud(1)  ! M.C. generation Crude value of integral
      m_SumWt  = 0d0          ! M.C. generation sum of Wt
      m_SumWt2 = 0d0          ! M.C. generation sum of Wt**2
      m_NevGen  = 0d0         ! M.C. generation sum of 1d0
      m_WtMax  = -1d99        ! M.C. generation maximum wt
      m_WtMin  =  1d99        ! M.C. generation minimum wt
      m_VolTot = m_CeIntg(1)  ! Estimate of integral tot. without error
      m_MCresult = m_VolTot   ! M.C. generation Final value of ITEGRAL, temporary asignment
      m_MCerror  = m_VolTot   ! M.C. generation Final walue of ERROR  , temporary asignment
*
      END                       ! FoamA_Initialize

      SUBROUTINE FoamA_InitVertices    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first 2^n vertices at corners of basic cube                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER       iVe,k1,k2,k3,k4,k5
*     
      m_LastVe = 2**m_Ndim
      iVe=0
      DO k5 = 0,1
         DO k4 = 0,1
            DO k3 = 0,1
               DO k2 = 0,1
                  DO k1 = 0,1
                     iVe=iVe+1
                     m_VerX(iVe,1) = k1
                     m_VerX(iVe,2) = k2
                     m_VerX(iVe,3) = k3
                     m_VerX(iVe,4) = k4
                     m_VerX(iVe,5) = k5
                     IF( iVe .EQ. m_LastVe ) GOTO 100
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !! FoamA_InitVertices



      SUBROUTINE FoamA_MakeEvent(funW)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates point/vector Xrand with the weight MCwt                              //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCell,i,j,iv
      DOUBLE PRECISION   Wt,x1,x2,Dx,MCwt
      DOUBLE PRECISION   Lambda(m_NdiMax)
*     -----------------------------------------------------------------
*     choose randomly one cell
      CALL  FoamA_Peek(iCell)
*     generate randomly/uniformly vector Vrand inside this simplex
      CALL FoamA_MakeLambda(Lambda)
      DO j=1,m_Ndim
         m_MCvector(j) = m_VerX( m_CeVert(iCell,m_Ndim+1) ,j)
         DO iv=1,m_Ndim
            m_MCvector(j) = m_MCvector(j) 
     $           +Lambda(iv)*( m_VerX( m_CeVert(iCell,iv) ,j) -m_VerX( m_CeVert(iCell,m_Ndim+1) ,j) )
         ENDDO
      ENDDO
      Dx = m_CeVolu(iCell)      ! Cartesian volume of the Cell
* weight average normalised to Crude integral over the cell
      MCwt =funW(m_MCvector)*Dx/m_CeCrud(iCell)
      m_nCalls =  m_nCalls+1
      m_MCwt   =  MCwt
* accumulation of statistics for the main MC weight
      m_SumWt  =  m_SumWt+MCwt           ! sum of Wt
      m_SumWt2 =  m_SumWt+MCWt*Mcwt      ! sum of Wt**2
      m_NevGen =  m_NevGen+1d0           ! sum of 1d0
      m_WtMax  =  MAX(m_WtMax,MCwt)      ! maximum wt
      m_WtMin  =  MIN(m_WtMin,MCwt)      ! minimum wt
* update also weight sums in the cell,
* note weights here are normalized absolutely, eg. to the value of the integral
      Wt = MCwt*m_CeCrud(iCell)
      m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt      ! sum of weights
      m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt   ! sum of weights squared
      m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0     ! sum of 1
      m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
      m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
      END                       ! FoamA_MakeEvent


      SUBROUTINE FoamA_MakeLambda(Lambda)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Lambda such that Sum Lamba(i) < 1, with uniform probab.     //
*//   This  vector is used to populate uniformly the interior of a simplex.              //
*//   The method is: generate point inside cube, order components (maping into simplex)  //
*//   and take differences of Lambda(i+1) - Lambda(i)                                    //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            i,k
      DOUBLE PRECISION   Lambda(m_NdiMax), y
      REAL               Qrand( m_NdiMax)        ! from PseuMar
      REAL               x
*     --------------------------------------------------------
      CALL PseuMar_MakeVec(Qrand,m_Ndim)
* order components (maping into simplex)
      DO i =m_Ndim,1,-1
         DO k =2,i
            IF( Qrand(k).LT.Qrand(k-1)) THEN
               x            = Qrand(k)
               Qrand(k)    = Qrand(k-1)
               Qrand(k-1)  = x
            ENDIF
         ENDDO
      ENDDO
      Lambda(1)=Qrand(1)
      DO k =2,m_Ndim
         Lambda(k)=Qrand(k)-Qrand(k-1)
      ENDDO
      END                       ! MakeLambda

      SUBROUTINE FoamA_MCgenerate(funW,MCvector,MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Obsolete                                                                       //
*//   Generates point/vector MCvector with the weight MCwt                           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   MCvector(*),MCwt
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            j
*     ---------------------------------------------------------------
      CALL FoamA_MakeEvent(funW)
      MCwt = m_MCwt
      DO j=1,m_Ndim
         MCvector(j) =m_MCvector(j)
      ENDDO
      END                       !!FoamA_MCgenerate


      SUBROUTINE FoamA_Peek(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly pointer iCell of an active cell                           //
*//                                                                                  //
*// We walk randomly from top of tree downwards until we find active cell m_CeStat=1 //
*// At each step one of daugters cells is choosen randomly according                 //
*// to their volume estimates.                                                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,p1,volu1,volu2,volu,TotCru,sum
      REAL               Qrand(10)        ! from PseuMar
*     ----------------------------------------------------------------
* first cell is special because it has Ndim-factorial daughters, istead of just 2
      kCell = 1
      Dau1  = m_CeDau1(kCell)
      Dau2  = m_CeDau2(kCell)
      TotCru   = 0d0
      DO iCell= Dau1,Dau2
         TotCru = TotCru+m_CeCrud( iCell )
      ENDDO
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iDau  = -1
      sum   = 0d0
      DO iCell= Dau1,Dau2
         iDau  = iCell
         sum = sum+m_CeCrud( iCell )
         IF( random .LT. sum/TotCru ) GOTO 100
      ENDDO
      IF(iDau.EQ.-1) GOTO 990
 100  kCell=iDau
c[[[[
cc      WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamA_Peek: top daughter =',kCell
c]]]]
      IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
* now the other standard cells with 2 daughters
      DO i=1,10000000
         IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
         volu1= m_CeCrud( m_CeDau1(kCell) )
         volu2= m_CeCrud( m_CeDau2(kCell) )
         p1 = volu1/(volu1+volu2)
         CALL PseuMar_MakeVec(Qrand,1)
         random = Qrand(1)
         IF( random .LT. p1 ) THEN
            kCell = m_CeDau1(kCell)
         ELSE
            kCell = m_CeDau2(kCell)
         ENDIF
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamA_Peek: normal daughter =',kCell
c]]]
      ENDDO
      GOTO 990
 300  CONTINUE
      iCell=kCell
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamA_Peek: choosen cell =',kCell
c]]]
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamA_Peek, something went wrong !!!!'
      STOP
      END                       !!! FoamA_Peek

      SUBROUTINE FoamA_PeekMax(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER   iCell
      INTEGER   i
      DOUBLE PRECISION  CrudMax, Crud
*     ---------------------------------------------------
      iCell = 0
      CrudMax = -1d150
      DO i = 1,m_LastCe
         IF( m_CeStat(i).EQ.1 ) THEN
            Crud=  ABS(m_CeCrud(i))
            IF(Crud .GT. CrudMax) THEN
               CrudMax = Crud
               iCell = i
            ENDIF
         ENDIF
      ENDDO
****  WRITE(*,*) '###>>> FoamA_PeekMax: iCell=',iCell
      IF(iCell.EQ.0) THEN
         WRITE(*,*) '### STOP in FoamA_PeekMax: not found iCell=', iCell
         STOP
      ENDIF
      END                       ! FoamA_PeekMax



      SUBROUTINE FoamA_PltBegin     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Initialization, write header of TeX file                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER id,kax,kay
*---------------------------------------------------
      DOUBLE PRECISION    dxl,dxu,xl,xu,yl,yu
      CHARACTER*8  chxfmt,chyfmt
      INTEGER      icont
      DATA         icont /0/
*---------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      icont=icont+1
*
      IF(icont .GE. 1) THEN
         chxfmt =  'f8.4'
         chyfmt =  'f8.4'
         m_ltx  = 11
         OPEN(m_ltx, FILE='map.tex')
         WRITE(m_ltx,'(2A)') '\\newpage'
      ENDIF
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') '\\documentclass[12pt]{article}'
      WRITE(m_ltx,'(A)') '\\usepackage{color}' !<-for colors!!!
      WRITE(m_ltx,'(A)') '\\usepackage{epic}'  !<-for extended ploting
      WRITE(m_ltx,'(A)') '\\textwidth  = 16cm'
      WRITE(m_ltx,'(A)') '\\textheight = 18cm'
      WRITE(m_ltx,'(A)') '\\pagestyle{empty}'
      WRITE(m_ltx,'(A)') '\\begin{document}'
      WRITE(m_ltx,'(A)') '  '
*------------------------------!
      WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'!
      WRITE(m_ltx,'(A)') '\\begin{figure}[!ht]'
      WRITE(m_ltx,'(A)') '\\centering'
*------------------------------!
* Frames and labels
*------------------------------!
      WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
      WRITE(m_ltx,'(A)') '\\setlength{\\unitlength}{0.1mm}'
      WRITE(m_ltx,'(A)') '\\begin{picture}(1600,1600)'
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox(1600,1600){ }}'

      END


      SUBROUTINE FoamA_PltCell(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all cells                                                                 //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            iCell,mout,active,j
      INTEGER            iV1,iV2,iV3
      INTEGER            kx1,ky1,kx2,ky2,kx3,ky3,kx,ky
*     ----------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
c[[[
c      WRITE(m_ltx,'(A)') '\\put(80,80){\\color{blue}\\dashbox{7}( 1440,1440){ }}' ! 5% edge band
c]]]
      DO iCell = 2, m_LastCe
         iV1=m_CeVert(iCell,1)
         iV2=m_CeVert(iCell,2)
         iV3=m_CeVert(iCell,3)
         kx1 = m_VerX(iV1,1)*1600
         ky1 = m_VerX(iV1,2)*1600
         kx2 = m_VerX(iV2,1)*1600
         ky2 = m_VerX(iV2,2)*1600
         kx3 = m_VerX(iV3,1)*1600
         ky3 = m_VerX(iV3,2)*1600
         kx= (kx1+kx2+kx3)/3
         ky= (ky1+ky2+ky3)/3
         IF(m_CeStat(iCell).EQ.1) THEN
***         WRITE(*,*) iCell,iV1,iV2,iV3
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx1,',',ky1,')(',kx2,',',ky2,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx2,',',ky2,')(',kx3,',',ky3,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx3,',',ky3,')(',kx1,',',ky1,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $           '\\put(',kx,',',ky,'){\\makebox(0,0)[b]{\\hbox{\\small\\color{magenta} ',iCell,' }}}' !
         ENDIF
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! FoamA_BufPrint

      SUBROUTINE FoamA_PltEnd     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Close Tex file with plot                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
*
      IF(m_nDim.NE.2) RETURN
      WRITE(m_ltx,'(A)') '\\end{picture}'
      WRITE(m_ltx,'(A)') '\\end{figure}'
      WRITE(m_ltx,'(A)') '\\end{document}'
      CLOSE(m_ltx)
      END

      SUBROUTINE FoamA_PltVert(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all vertices                                                              //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*------------------------------------------------------------------------------
*     Mark plots for plots
      CHARACTER*62 star,diamond,circle,ring,times,disc,plus,box,dot
      PARAMETER (diamond ='\\makebox(0,0){\\Large $\\diamond$}')
      PARAMETER (star    ='\\makebox(0,0){\\Large\\color{red} $\\star$}')
      PARAMETER (circle  ='\\circle{30}')
      PARAMETER (ring    ='\\circle{20}')
      PARAMETER (times   ='\\makebox(0,0){\\Large $\\times$}')
      PARAMETER (disc    ='\\circle*{20}')
      PARAMETER (plus    ='\\makebox(0,0){\\Large $+$}')
      PARAMETER (box     ='\\makebox(0,0){\\Large $\\Box$}') !!! does not work???
      PARAMETER (dot     ='\\circle*{10}')
*------------------------------------------------------------------------------
      CHARACTER*62  chmark
      INTEGER       kx,ky
*---------------------------------------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
* Count references of vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1 !
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1 !
               ENDIF
            ENDDO
         ENDDO
      ENDDO
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox( 1600,1600){ }}' !
* Plotting symbol
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VD}[2]{\\put(#1,#2){',disc,'}}'!
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VS}[2]{\\put(#1,#2){',star,'}}'!
      WRITE(m_ltx,'(10A)') 
     $     '\\newcommand{\\VN}[3]{\\put(#1,#2){\\makebox(0,0)[b]{\\hbox{\\small\\color{red} #3}}}}' !
      DO iVe = 1, m_LastVe
         kx = m_VerX(iVe,1)*1600
         ky = m_VerX(iVe,2)*1600
cc         WRITE(*,*) NoRefs(iVe),NoRefsAc(iVe)
         IF( NoRefsAc(iVe).LE.2 ) THEN
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VD{',kx,'}{',ky,'}'
         ELSE
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VS{',kx,'}{',ky,'}'
         ENDIF            
         WRITE(   m_ltx,'(A,I5,A,I5,A,I5,A)') '\\VN{',kx-8,'}{',ky+12,'}{',iVe,'}' !
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! VertPrint
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  BornV                                 //
*//////////////////////////////////////////////////////////////////////////////

*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//             Foam Version 1.01                                                         //
*//             August 1999                                                               //
*//                                                                                       //
*//  N-dimensional general purpose Monte Carlo sampler with self-adapting simplectic grid //
*//                                                                                       //
*//             Author:   Stanislaw JADACH                                                //
*//             Address:  INP Cracow                                                      //
*//             Email:    S.Jadach@cern.ch, S.Jadach@ifj.edu.pl                           //
*//             HomePage: http://home.cern.ch/~jadach/                                    //
*//                                                                                       //
*//  First version 1.00 written by S.J. in May 1999 during visit in DESY                  //
*///////////////////////////////////////////////////////////////////////////////////////////

*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//          Pseudoclass Foam                                                                          //
*//                                                                                                    //
*//                                                                                                    //
*//                      Initialization of the grid                                                    //
*//  FoamA_PreInitialize                 : Pre-initialization, set all default values (constructor?)   //
*//  FoamA_Initialize(FunW)              : Initialization of the grid etc.                             //
*//  FoamA_InitVertices                  : Initializes first vertices of the basic cube                //
*//  FoamA_InitCells                     : Initializes first n-factorial cells inside original cube    //
*//  FoamA_DefCell                       : Create new (daughter) cell and append at end of the buffer  //
*//  FoamA_Explore(iCell,funW)           : Short MC sampling in iCell, determine <wt>, wtMax etc.      //
*//  FoamA_RanDiscr(Crud,nTot,Power,iRand) : Random choice of cell division direction                  //
*//  FoamA_MakeLambda(Lambda)            : auxiliary procedure for FoamA_Explore                       //
*//  FoamA_Determinant(R,Det)            : determinant of matrix R                                     //
*//  FoamA_Det2Lapl(R,i1,i2)             : Laplace formula for 1-dim. determinant                      //
*//  FoamA_Det3Lapl(R,i1,i2,i3)          : Laplace formula for 2-dim. determinant                      //
*//  FoamA_Det4Lapl(R,i1,i2,i3,i4)       : Laplace formula for 3-dim. determinant                      //
*//  FoamA_Det5Lapl(R,i1,i2,i3,i4,i5)    : Laplace formula for 4-dim. determinant                      //
*//  FoamA_Grow(funW)              : grow cells until buffer is full                                   //
*//  FoamA_PeekMax(iCell)          : choose randomly one cell, used also in MC generation              //
*//  FoamA_Peek(iCell)             : Generates randomly one (active) cell pointer iCell                //
*//  FoamA_Divide(iCell,funW,RC)   :Divide iCell into two daughters; iCell retained, taged as inactive //
*//  FoamA_Collapse                :Finds and remooves unsuccesfull cells, some nonactive cells revived//
*//                     Generation                                                                     //
*//  FoamA_MakeEvent(Density)      : Generates point/vector Xrand with the weight MCwt                 //
*//  FoamA_GetMCvector(MCvector)   : Provides point/vector MCvector generated by  MakeEvent            //
*//  FoamA_GetMCwt(MCwt)           : Provides MCwt, MC weight calculated by MakeEvent                  //
*//  FoamA_MCgenerate(funW,X,MCwt) : Alternative entry, Generates point X with the weight MCwt         //
*//                     Finalization                                                                   //
*//  FoamA_Finalize(MCresult,MCerror)    : Calculates integral and its error after (only from) MC run  //
*//  FoamA_GetIntegral(MCresult,MCerror) : Integral estimate from Initialization + MC generation       //
*//                     Other Getters and Setters                                                      //
*//  FoamA_GetCrude(Crude)         :Provides Crude used in MC generation                               //
*//  FoamA_SetNdim(Ndim)           :Sets Ndim= no. of dimensions  (to be called before Initialize)     //
*//  FoamA_GetNdim(Ndim)           :Provides Ndim, miscelaneous, for tests                             //
*//  FoamA_SetnBuf(nBuf)           :Sets nBuf, working area in buffer                                  //
*//  FoamA_SetIterat(Iterat)       :Sets Iterat=no. of iterations (to be called before Initialize)     //
*//  FoamA_SetOut(Out)             :Sets output unit number                                            //
*//  FoamA_SetChat(Chat)           :Sets chat level; Chat=0,1,2 chat level in output, Chat=1 normal    //
*//  FoamA_SetnSampl(nSampl)       :Sets nSampl; No of MC sampling before dividing cell                //
*//  FoamA_SetOptCrude(OptCrude)   :Sets OptCrude; type of Crude =0,1,2 for True,Sigma,WtMax           //
*//  FoamA_SetOptBeta(OptBeta)     :Sets type of method in cell division                               //
*//  FoamA_SetOptPeek              :Sets type of method in cell division                               //
*//  FoamA_SetOptEdge(OptEdge)     :Sets OptEdge; decides whether vertices are included in the sampling//
*//  FoamA_SetKillFac(KillFac)     :Sets KillFac; kill factor for poor cells                           //
*//                    Debugging and miscelaneous                                                      //
*//  FoamA_Check(mout,level)       :Checks all pointers (after comression) debuging!                   //
*//  FoamA_ActUpda                 :Miscelaneous, Creates list of active cells (pointers)              //
*//  FoamA_BufPrint(mout)          :Prints all cells, debugging                                        //
*//  FoamA_BufActPrint(mout)       :Prints all active cells, debugging                                 //
*//  FoamA_VertPrint(mout)         :Prints all vertices,  debugging                                    //
*//  FoamA_PltBegin                :Ploting 2-dim. cells and vertices                                  //
*//  FoamA_PltVert(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamA_PltCell(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamA_PltEnd                  :Ploting 2-dim. cells and vertices                                  //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//  Input parameters:                                                                                 //
*//    nDim     number of dimensions in the problem, for the moment nDim=1-5 in this version,          //
*//             n>5 requires re-writing FoamA__Determinant,                                            //
*//             for n=1 alternatively Foam1A may be used, could be factor 2 faster!                    //
*//    nBuf     Actual dynamic lenth of the buffer m_nBuf<m_nBufMax. For strongly peaked distribution  //
*//             nBuf should be as large as possible, this will increase CPU time in initialization     //
*//             MC generation is weakly affected by increasing nBuf                                    //
*//    nSampl   No of sampling when dividing cell, nSampl=10-100 is OK, further increase improves      //
*//             costs CPU time and apparently does not increase grid efficiency too much.              //
*//             This should be checked however for every new distribution.                             //
*//    Iterat   No of iterations in consolidation, Iterat=0 is OK in may cases, but for very sharp     //
*//             peaks grid may expand in areas where there is litle of integrated propability.         //
*//             Additinal iteration Iterat>0 corrects for this.                                        //
*//    KillFac  kill factor for poor cells. Parameter for iteration. Default KillFac=1 seems to be OK  //
*//             For certain distribution it may be profitable to adjust it within 0.5<KillFac<2.0      //
*//    OptCrude Type of Crude =0,1,2 for TrueInt,Sigma,WtMax,  Crude=WtMax is the best if we aim       //
*//             at rejection leading to wt=1 events. If not then Crude=TrueInt iswiser choice leading  //
*//             to save of CPU time.                                                                   //
*//    OptEdge  decides whether vertices are included in the sampling. Default  OptEdge=1 causes that  //
*//             vertices at the edge of simplex cells are included always in MC exploration            //
*//             of the cell. In the case of density distrib. with weak integrable singularities        //
*//             at the edges it may be not possible and OptEdge=0 may help.                            //
*//    Out      Miscelaneous. Output unit number.                                                      //
*//    Chat     Miscelaneous. Chat=0,1,2 chat level in output, Chat=1 normal level.                    //
*//                                                                                                    //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//  Terminology:                                                                                      //
*//    "Active cells" are these which did not divide and are eligible for division                     //
*//  Remarks:                                                                                          //
*//    List of active cells is not realy necessary, but let us keep it for possible                    //
*//    future developements or tests.                                                                  //
*////////////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE FoamA_PreInitialize     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Presets certain defaults for switches and other and regualtory parameters.     //
*//   They Can be reset with setters                                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
*     -------------------------------------------------
      IF(m_Magic .EQ. 0 ) RETURN
      m_nBuf     = 500               ! Actual dynamic lenth of the buffer m_nBuf<m_nBufMax
      m_Iterat   = 10                ! No of iterations in consolidation
      m_KillFac  = 1d0               ! kill factor for poor cells
      m_Out      = 6                 ! Output unit
      m_Chat     = 1                 ! Chat=0,1,2 chat level in output, Chat=1 normal level
      m_nSampl   = 100               ! No of sampling when dividing cell
      m_OptCrude = 2                 ! type of Crude =0,1,2 for TrueVol,Sigma,WtMax
      m_OptPeek  = 0                 ! type of Peek =0,1 for maximum, random
      m_OptEdge  = 1                 ! decides whether vertices are included in the sampling
      m_nCalls   = 0                 ! No of function calls
      m_OptBeta  = 0                 ! type of choice of edge in the division of the cell, 0,1,2
      m_BetaPower=1d0                ! Power in case of m_OptBeta  = 2
      m_nDim     = 2                 ! dimension
*
      m_Magic = 0
      END


      SUBROUTINE FoamA_RanDiscr(Crud,nTot,Power,iRand)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates iRand in (1,nTot) acconding to discrete un-normalized probab. Crud   //
*//   Power is normaly =1, can be useful for special purposes                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION   Crud(*),Power
      INTEGER            nTot,iRand
      INTEGER            i
      DOUBLE PRECISION   random,sum,Total
      REAL               Qrand(10)        ! from PseuMar
*
      Total   = 0d0
      DO i= 1,nTot
         Total = Total +Crud( i)**Power
      ENDDO
      IF(Total .EQ. 0d0) GOTO 990
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iRand  = -1
      sum   = 0d0
      DO i= 1,nTot
         iRand  = i
         sum = sum +Crud( i)**Power
         IF( random .LT. sum/Total ) GOTO 100
      ENDDO
      IF(iRand .EQ. -1) GOTO 990
 100  CONTINUE
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamA_RanDiscr, something went wrong !!!!'
      STOP
      END

      SUBROUTINE FoamA_SetChat(Chat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      Chat
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_Chat = Chat
      END                       !!! FoamA_SetChat

      SUBROUTINE FoamA_SetIterat(Iterat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      Iterat
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_Iterat = Iterat
      END                       !!! FoamA_SetIterat

      SUBROUTINE FoamA_SetKillFac(KillFac)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      DOUBLE PRECISION   KillFac
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_KillFac = KillFac
      END                       !!! FoamA_SetKillFac

      SUBROUTINE FoamA_SetnBuf(nBuf)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      nBuf
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_nBuf = nBuf
      END                       !!! FoamA_SetnBuf


      SUBROUTINE FoamA_SetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      Ndim
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_Ndim = Ndim
      END                       !!! FoamA_SetNdim

      SUBROUTINE FoamA_SetnSampl(nSampl)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      nSampl
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_nSampl = nSampl
      END                       !!! FoamA_SetnSampl

      SUBROUTINE FoamA_SetOptBeta(OptBeta)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      OptBeta
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_OptBeta = OptBeta
      END                       !!! FoamA_SetOptBeta

      SUBROUTINE FoamA_SetOptCrude(OptCrude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      OptCrude
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_OptCrude = OptCrude
      END                       !!! FoamA_SetOptCrude

      SUBROUTINE FoamA_SetOptEdge(OptEdge)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      OptEdge
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_OptEdge = OptEdge
      END                       !!! FoamA_SetOptEdge

      SUBROUTINE FoamA_SetOptPeek(OptPeek)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      OptPeek
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_OptPeek = OptPeek
      END                       !!! FoamA_SetOptPeek

      SUBROUTINE FoamA_SetOut(Out)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER      Out
*     -------------------------------------------------
      CALL FoamA_PreInitialize
      m_Out = Out
      END                       !!! FoamA_SetOut


      SUBROUTINE FoamA_VertPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all vertices                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamA.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*     ----------------------------------------------------------------
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      WRITE(mout,*) '=====================all vertices==================================='
      WRITE(mout,*) ' iVert   NoRefs  NoRefsAc       Vertex     Componets    '
      DO iVe = 1, m_LastVe
         WRITE(mout,'(i6,2i10,5f17.10)') iVe,NoRefs(iVe),NoRefsAc(iVe), (m_VerX(iVe,j),j=1,m_Ndim)
      ENDDO
      END                       !! VertPrint


      SUBROUTINE FoamB_ActUpda    
C !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER   iCell,Dau1,Dau2
      INTEGER   i
*     ---------------------------------------------------
      m_LastAc=0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            m_LastAc=m_LastAc+1
            IF(m_LastAc .EQ. m_cMax) GOTO 950
            m_ActC(m_LastAc) = iCell
         ENDIF
      ENDDO
      RETURN
 900  WRITE(*,*) '### STOP in FoamB_ActUpda: not found iCell=', iCell
      STOP
 950  WRITE(*,*) '### STOP in FoamB_ActUpda: list of active cells too short'
      STOP
      END                       ! FoamB_ActUpda



      SUBROUTINE FoamB_BufActPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Active cells only                                                              //
*//   Side=1 indicates that this cell is "side leaf" sticking out of main branch     //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            iCell,mout,active,Side,Pare,j
      DOUBLE PRECISION   VolRat,CruRat,VoluSum,CrudSum,RatMax,RatMin,Fact,WtMin,WtMax
      DOUBLE PRECISION   AveWt, Sigma, Nentry
*     ----------------------------------------------------------------
      WRITE(mout,'(3a)') '==================================================', ' ACTIVE CELLS ',
     $                   '=================================================='
      VoluSum =0d0
      CrudSum =0d0
      RatMin  =  1d60
      RatMax  = -1d60
      WtMin   =  1d60
      WtMax   = -1d60
      active  =0
      WRITE(mout,'(2a)') ' iCell Stat Pare Dau1 Dau2 Side',
     $                   '     WtMin      WtMax        <w>    Sig/<w>      Crude    VolTrue   Ver1  Ver2 ...'
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            side=0
            Pare = m_CePare(iCell)
            IF( m_CeStat(m_CeDau1(Pare))*m_CeStat(m_CeDau2(Pare)) .EQ. 0  ) Side=1
            VolRat = m_CeIntg(iCell)* m_LastAc/m_CeCrud(1)
            CruRat = m_CeCrud(iCell)* m_LastAc/m_CeCrud(1)
            RatMin = Min(RatMin,VolRat)
            RatMax = Max(RatMax,VolRat)
            Nentry = m_CeSum(iCell,3)
            AveWt  = m_CeSum(iCell,1)/m_CeSum(iCell,3)
            Sigma  = DSQRT(  ABS(m_CeSum(iCell,2)/Nentry - AveWt**2))
            IF(AveWt.NE.0d0) WtMin = Min( WtMin, m_CeSum(iCell,4)/AveWt)
            IF(AveWt.NE.0d0) WtMax = Max( WtMax, m_CeSum(iCell,5)/AveWt)
            IF(AveWt.NE.0d0) Sigma = Sigma/AveWt
            WRITE(mout,'(6i5, 6f11.5 ,10i5)') 
     $           iCell, m_CeStat(iCell),  m_CePare(iCell),  m_CeDau1(iCell),m_CeDau2(iCell),  side,
     $           m_CeSum(iCell,4)/(m_CeCrud(iCell)+1d-100), ! minWt/AveWt
     $           m_CeSum(iCell,5)/(m_CeCrud(iCell)+1d-100), ! maxWt/AveWt
     $           m_CeIntg(iCell) /(m_CeCrud(iCell)+1d-100), ! average weight
     $           Sigma,                  ! sigma/AveWt
     $           CruRat,                 ! Crude/CruTot*Ncell
     $           VolRat,                 ! TrueVolu/VolTot*Ncell
     $           (m_CeVert(iCell,j), j=1,m_Ndim+1) ! vertices
            VoluSum = VoluSum +m_CeIntg(iCell)
            CrudSum = CrudSum +m_CeCrud(iCell)
            active  = active +1
         ENDIF
      ENDDO
      WRITE(mout,'(a,i6,a,2i6)') 'All cells: ',m_LastCe, '      Active: ', active, m_LastAc
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Volume/Tot*nCell  = ',RatMin,RatMax
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Weight/<Wt>       = ',WtMin,WtMax
      WRITE(mout,'(a,2g20.13)')  'Total True  Volume in active cells = ', VoluSum, m_CeIntg(1)
      WRITE(mout,'(a,2g20.13)')  'Total Crude Volume in active cells = ', CrudSum, m_CeCrud(1)
      WRITE(mout,'(a,f12.5)')   'True/Crude = ', VoluSum/CrudSum
      END                       !! FoamB_BufActPrint




      SUBROUTINE FoamB_BufPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all cells                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            iCell,mout,active,j
*     ----------------------------------------------------------------
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
      END                       !! FoamB_BufPrint


      SUBROUTINE FoamB_Check(mout,level)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Checks all pointers, this is necessary autodiagnostic because of the complicated//
*//  collapse algorithm.                                                             //
*//                                                                                  //
*//  level=0, no printout, failures causes STOP                                      //
*//  level=1, printout, failures lead to WARNINGS only                               //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER       mout,level
      INTEGER       nFailures, iCell, Dau1,Dau2, Pare, NoRefs(m_vMax), iVe,n
      INTEGER       NoEmpty
*     ---------------------------------------------------------
      nFailures=0
      IF(level.EQ.1) WRITE(mout,*)
     $'//////////////////////////////////////// FoamB_Checks /////////////////////////////////////////////'
      DO iCell = 1,m_LastCe
         Dau1 = m_CeDau1(iCell)
         Dau2 = m_CeDau2(iCell)
         Pare = m_CePare(iCell)
* checking on parents
         IF(iCell.GT.1) THEN
            IF(Pare.GT.m_LastCe) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Parent out of range = ',Pare
            ENDIF
         ENDIF
         IF(iCell.GT.1) THEN
            IF(  (Pare.NE.1) .AND. (m_CeDau1(Pare).NE.iCell) .AND. (m_CeDau2(Pare).NE.iCell)  ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Parent not pointing to this daughter Pare= ',Pare
            ENDIF
         ENDIF
* checking on daughters
         IF( Dau1 .GT. m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter out of range Dau1= ',Dau1
         ENDIF
         IF( Dau2 .GT.m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter out of range Dau2= ',Dau2
         ENDIF
         IF( Dau1.GE.1 .AND. Dau1.LE. m_LastCe) THEN
            IF( m_CePare(Dau1).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter not pointing to parent Dau1= ',Dau1
            ENDIF
         ENDIF
         IF( Dau2.GE.1 .AND. Dau2.LE. m_LastCe) THEN
            IF( m_CePare(Dau2).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter not pointing to parent Dau2= ',Dau2
            ENDIF
         ENDIF 
      ENDDO
* check on vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO n=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,n) ) NoRefs(iVe) =1
            ENDDO
         ENDDO
      ENDDO
      DO iVe = 1, m_LastVe
         IF(NoRefs(iVe).EQ.0 .AND.  level.EQ.1) WRITE(mout,*) '***** Vertex no. ',iVe, '  NOT referenced!'
      ENDDO
* Check for empty cells
      NoEmpty = 0d0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            IF( m_CeCrud(iCell) .EQ. 0d0) NoEmpty = NoEmpty +1
         ENDIF
      ENDDO
      IF( NoEmpty.GT.0) THEN
         WRITE(mout,*) '++++++++++ FoamB_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
         WRITE(   *,*) '++++++++++ FoamB_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
      ENDIF
* summary
      IF(level.EQ.1) WRITE(mout,*) '++++++++++ FoamB_Check has found total ', nFailures, ' failures '
      IF(level.EQ.1) WRITE(mout,*)
     $'///////////////////////////////////////////////////////////////////////////////////////////////////'
      IF(level.EQ.0 .AND. nFailures.GT.0 ) THEN
         WRITE(mout,*) '++++++++++ STOP in FoamB_Check, found total ', nFailures, ' failures '
         STOP
      ENDIF
      END                       ! FoamB_Check


      SUBROUTINE FoamB_Collapse    !# Initialization
*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//   This routine remooves unsuccesfull cells which have collected too litle "Volume"    //
*//   before the new round of divisions                                                   //
*//                                                                                       //
*//   The procedure is the following:                                                     //
*//   1. find most succesfull (the sweetest) active cell and find its VoluMax             //
*//   2. Scan entire buffer/tree from top to bottom, inactive cells                       //
*//   3. Activate every nonactive cell with Vol<VoluMax*KilFac and kill its pending tree  //
*//   4. Collapse all storage, list of cells, vertices etc. to make room for new iteration//
*//                                                                                       //
*//   Remooving "dead cells" and "unreferenced vertives" is the hardes part of the task   //
*//   I have found that this can be done most easily with special "mask matrices"         //
*//                                                                                       //
*///////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION  CrudMax,CrudOrig,Crud
      INTEGER           MaskV(m_vMax),    LinkV(m_vMax), kVer, kSum, iStart
      INTEGER           MaskC(m_nBufMax), LinkC(m_nBufMax)
      INTEGER           iCell, kCell, Pare, Stat, Dau1,Dau2, k, i, parent
*     -------------------------------------------------------
* Find richest ACTIVE cell
      CrudMax = 0d0
      DO iCell = 1,m_LastCe
         Stat= m_CeStat(iCell)
         IF(Stat .EQ.1 ) CrudMax= Max(CrudMax, m_CeCrud(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Find nonactive celles which are poorer than richest asctive (with CrudMax)    //
*// redefine them as active and kill trailing branch.                             //
*// Cells scheduled for remooval taged with Stat=-3                               //
*// We start with first Cell which is true daughter, iCell=iStart                 //
*///////////////////////////////////////////////////////////////////////////////////
      iStart = m_CeDau2(1)+1
***** WRITE(*,*) ' CrudMax,iStart =',CrudMax,iStart
      DO iCell = iStart ,m_LastCe
         Stat= m_CeStat(iCell)
         Dau1=m_CeDau1(iCell)
         Dau2=m_CeDau2(iCell)
*     let us first check if we are on the dead branch, if yes then shcedule daughters for remooval
         IF(Stat .EQ. -3 ) THEN
*****       WRITE(*,*) ' we are on the dead branch, iCell =',iCell,'Daughters to be killed',Dau1,Dau2
            IF(Dau1.NE.-1) m_CeStat(Dau1) = -3
            IF(Dau2.NE.-1) m_CeStat(Dau2) = -3
            m_CeDau1(iCell) = -1
            m_CeDau2(iCell) = -1
         ELSEIF( Stat .EQ. 0 ) THEN ! otherwise if it is normal inactive cell
*     reproduce original Crude as in Explore (may be this thould be memorized in Explore?)
            IF(     m_OptCrude.EQ.0 ) THEN
               CrudOrig  =  m_CeIntg(iCell) ! true volume
            ELSEIF( m_OptCrude.EQ.1 ) THEN
               CrudOrig  =  DSQRT(m_CeSum(iCell,2)/m_nSampl) ! Sqrt( <w>**2 + sigma**2 )
            ELSEIF( m_OptCrude.EQ.2 ) THEN
               CrudOrig    =  m_CeSum(iCell,5) ! wtmax
            ELSE
               WRITE(m_out,*) ' ++++ STOP in FoamB_Explore, wrong m_OptCrude =',m_OptCrude
               STOP
            ENDIF
            Crud= m_CeCrud(iCell)
*****       WRITE(*,*) ' Normal inactive iCell =',iCell,'CrudOrig,Crud=',CrudOrig,Crud
            IF(CrudOrig .LT. CrudMax*m_KillFac ) THEN     ! and if it is poor in sugar, make it active
               m_CeStat(iCell) = 1                        ! REVIVE, reset status as ACTIVE
               m_CeStat(Dau1) = -3                        ! and kill both daugters
               m_CeStat(Dau2) = -3               
               m_CeDau1(iCell) = -1
               m_CeDau2(iCell) = -1
*****          WRITE(*,*) ' poor cell, iCell,Stat =',iCell,Stat,'killed Daughters',Dau1,Dau2
*     Go back to original Crude in this cell and correct in all parent cells to the top of the tree
               m_CeCrud(iCell) = CrudOrig
               parent = m_CePare(iCell)
               DO i = 1,m_nBuf
                  IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
                  m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -Crud)
                  parent=m_CePare(parent)
               ENDDO
 100           CONTINUE
            ENDIF
         ENDIF      
      ENDDO
***** WRITE(*,*) '########## Now cells scheduled for remooval have status -3 !!!  '
***** CALL FoamB_BufPrint(6)
*///////////////////////////////////////////////////////////////////////////////////
*// Remoove inactive cells. Quite nontrivial task.                                //      
*// First find out which cell is dead, result is stored in MaskC                  //
*///////////////////////////////////////////////////////////////////////////////////
      DO iCell =1,m_LastCe
         MaskC(iCell)=0
      ENDDO
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell) .NE. -3 ) MaskC( iCell ) =1
      ENDDO
* MaskC turned into step-function LinkC, used in translation of pointers in cells
      kSum =0
      DO iCell = 1,m_LastCe
         kSum         = kSum +MaskC(iCell)
         LinkC(iCell) = kSum
      ENDDO
***** DO iCell = 1,m_LastCe
***** WRITE(*,*) 'iCell, MaskC, LinkC ====>', iCell, MaskC(iCell),LinkC(iCell)
***** ENDDO
* Collapse buffer by shifting downwards all cells
      DO iCell = 1,m_LastCe
         IF(MaskC(iCell).NE.0 ) THEN
            m_CeStat( LinkC(iCell) ) = m_CeStat( iCell )
            m_CePare( LinkC(iCell) ) = m_CePare( iCell )
            m_CeDau1( LinkC(iCell) ) = m_CeDau1( iCell )
            m_CeDau2( LinkC(iCell) ) = m_CeDau2( iCell )
            DO k=1,m_Ndim+1
               m_CeVert( LinkC(iCell),k ) = m_CeVert( iCell ,k)
            ENDDO
            m_CeIntg( LinkC(iCell) ) = m_CeIntg( iCell )
            m_CeCrud( LinkC(iCell) ) = m_CeCrud( iCell )
            m_CeVolu( LinkC(iCell) ) = m_CeVolu( iCell )
            m_CeXave( LinkC(iCell) ) = m_CeXave( iCell )
            m_CeBest( LinkC(iCell) ) = m_CeBest( iCell )
            DO k=1,m_sMax
               m_CeSum( LinkC(iCell),k ) = m_CeSum( iCell,k )
            ENDDO
         ENDIF
      ENDDO
      m_LastCe = kSum
* pointers to parents and daughters have to be also translated/updated
      DO iCell = 1,m_LastCe
         IF(m_CePare(iCell).GE.1 ) m_CePare(iCell) = LinkC( m_CePare(iCell) )
         IF(m_CeDau1(iCell).GE.1 ) m_CeDau1(iCell) = LinkC( m_CeDau1(iCell) )
         IF(m_CeDau2(iCell).GE.1 ) m_CeDau2(iCell) = LinkC( m_CeDau2(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Reconstruction of list of vertices. Kick out unreferced vertices.             //
*// First we construct MaskV which tells us which vertex is still in use          //
*///////////////////////////////////////////////////////////////////////////////////
***** CALL FoamB_BufPrint(   6)
***** CALL FoamB_VertPrint(  6)
      DO kVer =1,m_LastVe
         MaskV(kVer)=0
      ENDDO
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            MaskV( m_CeVert(iCell,k) )=1
         ENDDO
      ENDDO
***** DO kVer =1,m_LastVe
*****   WRITE(*,*) 'kVer, MaskV ====>', kVer, MaskV(kVer),(m_VerX(kVer,k),k=1,m_Ndim)
***** ENDDO
* MaskV turned into step-function LinkV, used in translation of pointers in cells
      kSum =0
      DO kVer =1,m_LastVe
         kSum         = kSum +MaskV(kVer)
         LinkV(kVer) = kSum
      ENDDO
* Translate pointers in Cells
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            m_CeVert(iCell,k) = LinkV( m_CeVert(iCell,k) )
         ENDDO
      ENDDO
* And reorganize list of vertices as well !!!
      DO kVer =1,m_LastVe
         IF(MaskV(kVer).NE.0 ) THEN
            DO k=1,m_Ndim
               m_VerX( LinkV(kVer), k )=m_VerX( kVer, k )
            ENDDO
         ENDIF
      ENDDO
      m_LastVe = kSum

***** CALL FoamB_VertPrint(   6)
***** WRITE(*,*) '######################### FoamB_Collapse  is complete #####################'
***** CALL FoamB_BufPrint(    6)
***** CALL FoamB_BufActPrint( 6)

* Update list of active cells, only for internal tests
      CALL FoamB_ActUpda
      CALL FoamB_Check(6,0)     ! Check if Collapseion result is OK
*
      END                       ! FoamB_Collapse


      SUBROUTINE FoamB_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create new (daughter) cell and append it at the very end of the buffer         //
*//   iCeNew is pointer of the new cell                                              //
*//   Note clever trick: volume of this daughter is assigned initialy half volume    //
*//   of the parent, if parent exists.                                               //
*//   In Explore this value is used to update all parents such that                  //
*//   in the entrire tree parents have volume being sum of all daughter volumes.     //
*//   This summation discipline is useful for MC generation of an active cell by     //
*//   going randomly from top to bottom of the tree.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            Stat,Pare,Dau1,Dau2,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
*     ------------------------------------------------------------------
      IF( m_LastCe .EQ. m_nBuf) THEN
         WRITE(*,*) ' STOP in FoamB_DefNewCell: something wrong with m_nBuf '
         STOP
      ENDIF
      m_LastCe = m_LastCe+1
      iCeNew   = m_LastCe
      m_CeStat(iCeNew)= Stat                    ! status code, =0 inactive, =1 active
      m_CePare(iCeNew)= Pare                    ! parent cell pointer
      m_CeDau1(iCeNew)= Dau1                    ! daughter1 cell pointer
      m_CeDau2(iCeNew)= Dau2                    ! daughter2 cell pointer
      m_CeBest(iCeNew)= -1                      ! pointer for planning division of the cell
      m_CeXave(iCeNew)= 0.5d0                   ! factor for division
      DO k=1,m_NdiMax+1
         m_CeVert(iCeNew,k)= Vertex(k)
      ENDDO
c      m_CeVert(iCeNew,1)= Ver1                  ! 1-st vertex pointer
c      m_CeVert(iCeNew,2)= Ver2                  ! 2-nd vertex pointer
c      m_CeVert(iCeNew,3)= Ver3                  ! 3-rd vertex pointer
c      m_CeVert(iCeNew,4)= Ver4                  ! 4-th vertex pointer
      IF(Pare.NE.-1) THEN
         m_CeIntg(iCeNew)= m_CeIntg(Pare)/2d0   ! integr. half of parent
         m_CeCrud(iCeNew)= m_CeCrud(Pare)/2d0   ! integr. half of parent
      ELSE
         m_CeIntg(iCeNew)= 0d0
         m_CeCrud(iCeNew)= 0d0
      ENDIF
      m_CeVolu(iCeNew)= 0d0                     ! cartesian Volume   
      END                       ! FoamB_DefCell

      SUBROUTINE FoamB_DefNewCell(Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   obsolete!!!!                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
      Vertex(1) = Ver1
      Vertex(2) = Ver2
      Vertex(3) = Ver3
      Vertex(4) = Ver4
      CALL FoamB_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
      END                       !!!FoamB_DefNewCell

      DOUBLE PRECISION FUNCTION FoamB_Det2Lapl(R,i1,i2)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      INTEGER  i1,i2
*     ------------------------------------------------------------
      FoamB_Det2Lapl= R(1,i1)*R(2,i2) - R(1,i2)*R(2,i1)
      END


      DOUBLE PRECISION FUNCTION FoamB_Det3Lapl(R,i1,i2,i3)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamB_Det2Lapl
      INTEGER  i1,i2,i3
*     ------------------------------------------------------------
      FoamB_Det3Lapl=+R(3,i1) *FoamB_Det2Lapl(R,i2,i3)
     $               -R(3,i2) *FoamB_Det2Lapl(R,i1,i3)
     $               +R(3,i3) *FoamB_Det2Lapl(R,i1,i2)
      END

      DOUBLE PRECISION FUNCTION FoamB_Det4Lapl(R,i1,i2,i3,i4)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamB_Det3Lapl
      INTEGER  i1,i2,i3,i4
*     ------------------------------------------------------------
      FoamB_Det4Lapl=-R(4,i1) *FoamB_Det3Lapl(R,i2,i3,i4)
     $               +R(4,i2) *FoamB_Det3Lapl(R,i1,i3,i4)
     $               -R(4,i3) *FoamB_Det3Lapl(R,i1,i2,i4)
     $               +R(4,i4) *FoamB_Det3Lapl(R,i1,i2,i3)
      END

      DOUBLE PRECISION FUNCTION FoamB_Det5Lapl(R,i1,i2,i3,i4,i5)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax), Det, FoamB_Det4Lapl
      INTEGER  i1,i2,i3,i4,i5
*     ------------------------------------------------------------
      FoamB_Det5Lapl=+R(4,i1) *FoamB_Det4Lapl(R,i2,i3,i4,i5)
     $               -R(4,i2) *FoamB_Det4Lapl(R,i1,i3,i4,i5)
     $               +R(4,i3) *FoamB_Det4Lapl(R,i1,i2,i4,i5)
     $               -R(4,i4) *FoamB_Det4Lapl(R,i1,i2,i3,i5)
     $               +R(4,i5) *FoamB_Det4Lapl(R,i1,i2,i3,i4)
      END


      SUBROUTINE FoamB_Determinant(R,Det)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Calculates determinant of matrix R                                             //
*//   Use of Laplace formula should be perhaps replaced with something faster        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      DOUBLE PRECISION   FoamB_Det2Lapl, FoamB_Det3Lapl,FoamB_Det4Lapl,FoamB_Det5Lapl
*     -------------------------------------------------
      IF(        m_Ndim .EQ. 1) THEN
         Det= R(1,1)
      ELSEIF(    m_Ndim .EQ. 2) THEN
         Det= FoamB_Det2Lapl(R, 1,2)
      ELSEIF(    m_Ndim .EQ. 3) THEN
         Det= FoamB_Det3Lapl(R, 1,2,3)
      ELSEIF(    m_Ndim .EQ. 4) THEN
         Det= FoamB_Det4Lapl(R, 1,2,3,4)
      ELSEIF(    m_Ndim .EQ. 5) THEN
         Det= FoamB_Det5Lapl(R, 1,2,3,4,5)
      ELSE
         WRITE(*,*) '####FoamB_Determinant: STOP, m_Ndim =',m_Ndim
         STOP
      ENDIF
      END                       ! FoamB_Determinant


      SUBROUTINE FoamB_Divide(iCell,funW,RC)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Divide cell iCell into two daughter cells                                      //
*//   The iCell is retained and taged as inactive, daughter cells are appended       //
*//   at the end of the buffer.                                                      //
*//   New vertex is added to list of vertice.                                        //
*//   List of active cells is updated, iCell remooved, two daughters added           //
*//   and their properties set with help of MC sampling (FoamB_Explore)              //
*//   Return Code RC=-1 of buffer limit is reached,  m_LastCe=m_nBuf                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            iCell,RC
      INTEGER            Dau1, Dau2, kVer1(m_NdiMax+1), kVer2(m_NdiMax+1),p1,p2
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            Old1,Old2,j,k,jv,iv,kBest,nPairs
      DOUBLE PRECISION   Xave
*--------------------------------------------------------------------------------------
      RC = 0
      IF( m_LastCe+2 .GT. m_nBuf) GOTO 990 !! abort if no space in buffer
* reset cell as inactive
      m_CeStat(iCell) = 0
*------------------------------------------------------------------------------------
* add new vertex to the list
      m_LastVe=m_LastVe+1
      IF(m_LastVe.GT.m_vMax) GOTO 980
      Xave  = m_CeXave(iCell)
      kBest = m_CeBest(iCell)
      nPairs=0
      DO jv=1,m_Ndim+1
         DO iv=jv+1,m_Ndim+1
            nPairs=nPairs+1
            IF( nPairs.EQ.kBest) THEN
               p1 =  m_CeVert(iCell,jv)
               p2 =  m_CeVert(iCell,iv)
               DO j=1,m_Ndim
                  m_VerX(m_LastVe,j) = Xave*m_VerX(p1,j) + (1d0-Xave)*m_VerX(p2,j)
               ENDDO
               Old1=jv
               Old2=iv
               GOTO 100
            ENDIF
         ENDDO
      ENDDO
 100  CONTINUE
c[[[[[
c      WRITE(*,'(a,6f12.6)') 'FoamB_Divide: new vertex =',(m_VerX(m_LastVe,k), k=1,m_Ndim)
c]]]]]
*------------------------------------------------------------------------------------
* define lists of vertices for daughters, one old vertex replaced by new one
      DO jv=1,m_Ndim+1
         kVer1(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old1) kVer1(jv)=m_LastVe
         kVer2(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old2) kVer2(jv)=m_LastVe
      ENDDO
* define two daughter cells (active)
*   ----------------------- Stat, Pare, Dau1,Dau2,  Vertex,  iCeNew)
      CALL FoamB_DefCell(      1, iCell,  -1,  -1,   kVer1,  Dau1)
      CALL FoamB_DefCell(      1, iCell,  -1,  -1,   kVer2,  Dau2)
      m_CeDau1(iCell) = Dau1
      m_CeDau2(iCell) = Dau2
      CALL FoamB_Explore(Dau1,funW)
      CALL FoamB_Explore(Dau2,funW)
* Update list of active cells, only for internal tests
      CALL FoamB_ActUpda
      RETURN
 990  RC=-1                     !!buffer limit is reached,  m_LastCe=m_nBuf
      RETURN
 980  WRITE(*,*) ' ### STOP in FoamB_Divide: too short list of vertices '
      STOP
      END                       ! FoamB_Divide


      SUBROUTINE FoamB_Explore(iCell,funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Explore newly defined cell with help of special short MC sampling              //
*//   As a result, estimetes of true and crude volume will be defined                //
*//   Average and dispersion of the weight distribution will be found along each     //
*//   edge and the best edge (minimum dispersion) is memorized for future use.       //
*//   Axerage x for eventual future cell division is also defined.                   //
*//   Recorded are aso minimum and maximu weight etc.                                //
*//   The volume estimate in all (inactive) parent cells is updated                  //
*//   Note that links to parents and initial volume = 1/2 parent has to be           //
*//   already defined prior to calling this routine.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            i,j,k,parent,iCell,iv,jv,nPairs,pBest,kBest
      DOUBLE PRECISION   x,x1,x2,Dx,Dxx,Wt,Vsum,SumWt,Sum
      DOUBLE PRECISION   Xave,Xdisp,DispMin
      DOUBLE PRECISION   Beta(m_NpairMax),BetaMax
      DOUBLE PRECISION   VolOld, CruOld, XrSum,Factorial
      DOUBLE PRECISION   Vec(m_NdiMax+1,m_NdiMax), Xre(m_NdiMax,m_NdiMax), Yre(m_NdiMax,m_NdiMax)
      DOUBLE PRECISION   Vrand(m_NdiMax)
      DOUBLE PRECISION   Lambda(m_NdiMax),VolPart(m_NdiMax+1)
      DOUBLE PRECISION   Xdivi(m_NpairMax),Xsu1(m_NpairMax),Xsu2(m_NpairMax)
      INTEGER            nBin,iBin
      PARAMETER          (nBin=25)
      DOUBLE PRECISION   Histo(m_NpairMax,nBin),Bins(nBin)
      DOUBLE PRECISION   funW
      EXTERNAL           funW
*-----------------------------------------------------------------------
      Factorial=1
      DO i=1,m_Ndim
         Factorial=Factorial*i
      ENDDO
* memorize old values, will be needed for correcting parent cells
      VolOld = m_CeIntg(iCell)
      CruOld = m_CeCrud(iCell)
* Estimate volume and find out average value of x
* decode vertex vectors
      DO iv=1,m_Ndim+1
         DO j=1,m_Ndim
            Vec(iv,j) = m_VerX( m_CeVert(iCell,iv) ,j)
         ENDDO
      ENDDO
* relative last vertex
      DO iv=1,m_Ndim
         DO j=1,m_Ndim
            Xre(iv,j) = Vec(iv,j)-Vec(m_Ndim+1,j)
         ENDDO
      ENDDO
      CALL FoamB_Determinant(Xre,Dx)
      Dx = ABS(Dx)/Factorial    ! Cartesian volume of the Cell
      m_CeVolu(iCell)  = Dx
c[[[[[
c      DO iv=1,m_Ndim
c          WRITE(*,'(a,9f10.5)') '### Xre=',(Xre(iv,j),j=1,m_Ndim)
c      ENDDO
c      WRITE(*,'(a,f12.6)') 'FoamB_Explore: Cartesian volume Dx =',Dx
c]]]]]
*/////////////////////////////////////////////////////
*//    Special Short MC sampling to probe cell      //
*/////////////////////////////////////////////////////
      m_CeSum(iCell,1) =  0
      m_CeSum(iCell,2) =  0
      m_CeSum(iCell,3) =  0
      m_CeSum(iCell,4) =  1d90  ! wtmin
      m_CeSum(iCell,5) = -1d90  ! wtmax
      DO k=1,m_NpairMax
         Xsu1(k)=0d0
         Xsu2(k)=0d0
         Beta(k)=0d0
         DO iBin=1,nBin
            Histo(k,iBin)=0d0
         ENDDO
      ENDDO
* here we do additional scan over vertices in order to improve max/min weights
      IF( m_OptEdge .EQ. 1 ) THEN
         DO iv=1,m_Ndim+1
            DO j=1,m_Ndim
               Vrand(j) = m_VerX( m_CeVert(iCell,iv) ,j)
            ENDDO
            Wt =funW(Vrand)*Dx  ! weight average normalised to integral over the cell
            m_nCalls = m_nCalls+1
            m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
            m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
         ENDDO
      ENDIF
*/////////////////////////////////////////////////////
      DO i=1,m_nSampl
*     generate randomly/uniformly vector Vrand inside this simplex
         CALL FoamB_MakeLambda(Lambda)
         DO j=1,m_Ndim
            Vrand(j) = Vec(m_Ndim+1,j)
            DO iv=1,m_Ndim
               Vrand(j) = Vrand(j) +Lambda(iv)*Xre(iv,j)
            ENDDO
         ENDDO
****     WRITE(*,'(a,6f12.6)') ' Lambda    =',(Lambda(k),k=1,m_Ndim)
****     WRITE(*,'(a,6f12.6)') ' Vrand     =',(Vrand(k), k=1,m_Ndim)
*---------------------------------------------------------------------------------
* calculate partial volumes, raw material for planning future divion of the cell
* vertex jv will be replaced with the random vertex
         Vsum=0d0
         DO jv=1,m_Ndim+1
* all vertices relative to random vector, jv is omitted
            k=0
            DO iv=1,m_Ndim+1
               IF(iv.NE.jv) THEN
                  k=k+1
                  DO j=1,m_Ndim
                     Yre(k,j) = Vec(iv,j)-Vrand(j)
                  ENDDO
               ENDIF
            ENDDO
            CALL FoamB_Determinant(Yre,Dxx)
            VolPart(jv) = ABS(Dxx)/Factorial
            Vsum=Vsum + VolPart(jv)
         ENDDO
         IF( ABS(Vsum-DX) .GT. 1d-6) GOTO 950
*------------------------------------------------------------------------------------
         nPairs=0
         DO jv=1,m_Ndim+1
            DO iv=jv+1,m_Ndim+1
               nPairs=nPairs+1
               Xdivi(nPairs) = VolPart(jv)/(VolPart(jv)+VolPart(iv))
            ENDDO
         ENDDO
*------------------------------------------------------------------------------------
         Wt =funW(Vrand)*Dx        ! weight average normalised to integral over the cell
         m_nCalls = m_nCalls+1
         m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt         ! sum of weights
         m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt      ! sum of weights squared
         m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0        ! sum of 1
         m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt)    ! minium weight
         m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt)    ! maximu weight
* Search for the best edge candidate for future cell division, prepare MC material
         DO k=1,nPairs
            Xsu1(k)=Xsu1(k) +Xdivi(k)*Wt                 ! averages for all Xdivi
            Xsu2(k)=Xsu2(k) +Xdivi(k)**2*Wt
            iBin = INT(Xdivi(k)*nBin)+1d0
            iBin = MIN(MAX(iBin,0),nBin)
            Histo(k,iBin) = Histo(k,iBin)+Wt             ! fill histo for each edge
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.9) THEN
c               CALL GLK_Fil1(1200+k, Xdivi(k),Wt)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ENDDO
      ENDDO
*///////////////////////////////////////////////////////
*//   End of Special Short MC sampling to probe cell  //
*///////////////////////////////////////////////////////
*
* Determine the best edge candidate for future cell division, using MC  material
      pBest =0
      kBest =0
      DispMin =  1d150
      BetaMax = -1d150
      DO k=1,nPairs
         SumWt  = m_CeSum(iCell,1)
         IF( SumWt .NE. 0d0) THEN
            Beta(k) = 0d0
            Xave  = Xsu1(k)/SumWt             ! average lambda
            Xdisp = Xsu2(k)/SumWt  -Xave**2   ! dispersion of lambda
            Sum =0d0
            DO iBin=1,nBin
               Sum = Sum + Histo(k,iBin)/SumWt
               Beta(k) = Beta(k) +ABS((Sum*nBin-iBin)/nBin)
               Bins(iBin) = Sum               ! cumulative (for tests)
            ENDDO
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.20) THEN
c               CALL GLK_Pak(  1200+k,Bins)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ELSE
            Beta(k) = 1d0
            Xave  = 0.5d0
            Xdisp = 0.5d0
         ENDIF
c         IF( Xdisp.LT.0d0 ) THEN
c            WRITE(*,*) ' FoamB_Explore: Dispersion negative Xdisp,Xave=',Xdisp,Xave !
c         ENDIF
         IF( (Xave.LT.0d0) .OR. (Xave.GT.1d0) ) THEN
            WRITE(*,*) ' FoamB_Explore: Xave out of range   Xdisp,Xave=',Xdisp,Xave !
         ENDIF
         Xsu1(k) = Xave
         Xsu2(k) = SQRT(ABS(Xdisp))
         IF(Xsu2(k).LT.DispMin) THEN
            pBest=k
            DispMin = Xsu2(k)
         ENDIF
         IF(Beta(k).GT.BetaMax) THEN
            kBest=k
            BetaMax = Beta(k)
         ENDIF
      ENDDO
      IF(pBest .EQ. 0) GOTO 960
      IF(kBest .EQ. 0) GOTO 960
*
* Some test variants, do nothing for default m_OptBeta=0
      IF(     m_OptBeta .EQ. 1) THEN
         kBest = pBest                 ! pBest based on dispersion is generally less effective
      ELSEIF( m_OptBeta .EQ. 2) THEN
         CALL  FoamB_RanDiscr(Beta, nPairs, m_BetaPower, kBest) ! sometimes profitable
      ENDIF
***** WRITE(*,'(a,6f12.6)') ' Xdivi average   =',(Xsu1(k), k=1,nPairs)
***** WRITE(*,'(a,6f12.6)') ' Xdivi dispersion=',(Xsu2(k), k=1,nPairs)
***** WRITE(*,*) 'pBest, DispMin =',pBest, DispMin
*[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
c      WRITE(*,'(a,5I5)') '=======>>>>> FoamB_Explore: iCell,kBest,pBest = ',iCell,kBest,pBest
c      k=0
c      DO jv=1,m_Ndim+1
c         DO iv=jv+1,m_Ndim+1
c            k=k+1
c            WRITE(*,'(a,3I5,4f12.6)') 'k,jv,iv,Xave,Xdisp,Beta= ',
c     $           k,m_CeVert(iCell,iv),m_CeVert(iCell,jv),Xsu1(k),Xsu2(k),Beta(k) !
c         ENDDO
c      ENDDO
*]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

      IF( m_CeSum(iCell,1) .LT.0d0) GOTO 920
      m_CeXave(iCell)  = Xsu1(kBest)
      m_CeBest(iCell)  = kBest
      m_CeIntg(iCell)  = m_CeSum(iCell,1)/m_nSampl        ! estimator of the true integral
*     !!!!!!!!!  CRUDE volume for MC generation purpose !!!!!!!!!!
      IF(     m_OptCrude.EQ.0 ) THEN
         m_CeCrud(iCell)  =  m_CeIntg(iCell)                   ! true integral
      ELSEIF( m_OptCrude.EQ.1 ) THEN
         m_CeCrud(iCell)  =  DSQRT(m_CeSum(iCell,2)/m_nSampl)  ! Sqrt( <w>**2 + sigma**2 )
      ELSEIF( m_OptCrude.EQ.2 ) THEN
         m_CeCrud(iCell)  =  m_CeSum(iCell,5)                  ! wtmax
      ELSE
         WRITE(m_out,*) ' ++++ STOP in FoamB_Explore, wrong m_OptCrude =',m_OptCrude
         WRITE(    *,*) ' ++++ STOP in FoamB_Explore, wrong m_OptCrude =',m_OptCrude
         STOP
      ENDIF
* correct volume and crude in all parent cells to the top of the tree
      parent = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         m_CeIntg(parent)  = m_CeIntg(parent)  +( m_CeIntg(iCell)  -VolOld)
         m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -CruOld)
         parent=m_CePare(parent)
      ENDDO
 100  CONTINUE
      RETURN
 920  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with integrand '
      STOP
 950  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with volume calculation '
      STOP
 960  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with best pair pointer =',kBest
      STOP
      END                       ! FoamB_Explore



      SUBROUTINE FoamB_Finalize(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   After MC run is completed it calculates integral and its error         //
*//   Also prints some information/statistics on the MC run                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
*
      DOUBLE PRECISION     MCresult,MCerror,MCerelat
      DOUBLE PRECISION     Vtot,Verr,VerRela
*-----------------------------------------------------------------------------
      MCresult =0d0
      MCerelat =1d0
      IF(m_NevGen .GT. 0) MCresult = m_Crude *m_SumWt/m_NevGen
      IF(m_NevGen .GT. 0) MCerelat = SQRT( m_SumWt2/m_SumWt**2 -1d0/m_NevGen )
      MCerror = MCresult*MCerelat
* some test printouts
      WRITE(m_Out,'(3a)') '============================================================================='
      WRITE(m_Out,'(3a)') '==============================', ' FoamB_Finalize ',
     $                    '=============================='
      WRITE(m_Out,'(a,2g18.9,f11.7)')               'MCresult, MCerror, Errela= ',MCresult,MCerror,MCerelat
      WRITE(m_Out,'(a,2f11.5)')                     'Minimum maximum weight   = ',m_WtMin,m_WtMax
      IF(m_NevGen .GT. 0) WRITE(m_Out,'(a,2f11.5)') 'Average weight           = ',m_SumWt/m_NevGen
      WRITE(m_Out,'(a,i15)')                        'Total number of function calls =',m_nCalls
      WRITE(m_Out,'(a,i15)')                        'Number of vertices = ', m_LastVe
* Total integral from cell statistics, including initialization + MC generation
      CALL FoamB_GetIntegral(Vtot,Verr)
      VerRela = Verr/Vtot
      WRITE(m_Out,'(3a)') '-----------------------------------------------------------------------------'
      WRITE(m_Out,'(3a)') 'Still better final results using information accumulated in initialization'
      WRITE(m_Out,'(a,2g18.9,f11.7)')                'Vtot, Verr, Errela       = ',  Vtot,Verr, VerRela
      WRITE(m_Out,'(3a)') '============================================================================='
      END       ! FoamB_Finalize


      SUBROUTINE FoamB_GetCrude(Crude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION     Crude
      Crude = m_Crude
      END


      SUBROUTINE FoamB_GetIntegral(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION     MCresult,MCerror
      DOUBLE PRECISION     Vtot,Verr,Nent,AveWt,Sig2
      INTEGER              iCell
*
      Vtot =0d0
      Verr =0d0
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            Nent  = m_CeSum(iCell,3)
            AveWt = m_CeSum(iCell,1)/Nent
            Sig2  = m_CeSum(iCell,2)/Nent - AveWt**2
            Vtot = Vtot +AveWt
            Verr = Verr +Sig2/Nent
         ENDIF
      ENDDO
      Verr = SQRT(Verr)
      MCresult = Vtot
      MCerror  = Verr
      END


      SUBROUTINE FoamB_GetMCvector(MCvector)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_Ndim
         MCvector(k)    = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE FoamB_GetMCwt(MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE FoamB_GetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      Ndim
*     -------------------------------------------------
      Ndim = m_Ndim
      END                       !!! FoamB_SetNdim


      SUBROUTINE FoamB_Grow(funW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Grow new cells by division                                                     //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,RC,iCell
*---------------------------------------------
* Final division
      DO i=1,100000
         IF(  m_OptPeek .EQ. 0 ) THEN
            CALL FoamB_PeekMax(iCell)         ! peek up cell with maximum crude
         ELSE
            CALL FoamB_Peek(   iCell)         ! peek up randomly one cell
         ENDIF
         CALL FoamB_Divide( iCell,funW,RC)    ! and divide it into two
c[[[[
c         CALL FoamB_BufPrint(    m_Out)
c         CALL FoamB_VertPrint(  6)
c]]]]
         IF(RC.EQ.-1) GOTO 300
      ENDDO
 300  CONTINUE
      CALL FoamB_Check(6,0)
      END                       ! FoamB_Grow

      SUBROUTINE FoamB_InitCells    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first n-factorial cells inside original cube                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER       k1,k2,k3,k4,k5
      INTEGER       perm(m_NdiMax),mask
      INTEGER       iCe,i,j,k,iVe,Vert(m_NdiMax),digit(m_NdiMax),factorial
*     -----------------------------------------------------------------------------
      factorial=1
      DO k = 1,m_Ndim
         factorial = factorial*k
      ENDDO
      DO iVe=1,m_Ndim+1
         Vert(iVe) =0
      ENDDO
*     -------------------- Stat,Pare, Dau1,        Dau2, VertexList, iCeNew)
      CALL FoamB_DefCell(    -1,  -1,    2, factorial+1,       Vert,      k) ! Master cell Inactive
    
      iCe=0
* The most primitive loop over permutations in the world!
      DO k5 = m_Ndim,1,-1
         DO k4 = m_Ndim,1,-1
            DO k3 = m_Ndim,1,-1
               DO k2 = m_Ndim,1,-1
                  DO k1 = m_Ndim,1,-1
                     perm(1)=k1
                     perm(2)=k2
                     perm(3)=k3
                     perm(4)=k4
                     perm(5)=k5
                     Mask=1
                     DO i=1,m_Ndim
                        DO j=i+1,m_Ndim
                           IF( perm(i).EQ.perm(j) ) Mask=0
                        ENDDO
                     ENDDO
                     IF(Mask.EQ.1) THEN
                        iCe=iCe+1
*                       WRITE(*,*) '########>>>>>>> iCe=',iCe, 'permut= ',(perm(i),i=1,m_Ndim)
                        DO iVe=1,m_Ndim+1
*                          digit represtents just one basic simplex,
*                          the actual one is obtained by permuting dimensions
                           DO k=1,m_Ndim
                              digit(k)=0
                              IF(k.LT.iVe) digit(k)=1
                           ENDDO
*                          translation from "binary" digit to serial pointer of a given vertex
                           j=0
                           DO k=1,m_Ndim
                              j=j+  digit(perm(k)) *2**(k-1)
                           ENDDO
                           Vert(iVe)=j+1
                        ENDDO
*                       WRITE(*,*) '###>>>> Vert= ',(vert(i),i=1,m_Ndim+1)
*                       ----------------- Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
                        CALL FoamB_DefCell(  1,   1,  -1,  -1,  Vert,     k) ! active
                        IF( iCe.EQ.factorial) GOTO 100
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !!!FoamB_InitCells

      SUBROUTINE FoamB_Initialize(FunW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Basic initialization, create "foam of cells"                                   //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iter,i,j,k,iCell
*---------------------------------------------
*
      CALL FoamB_PreInitialize
*
      IF( m_nBuf .GT. m_nBufMax) THEN
         WRITE(*,    *) ' ### STOP in FoamB_Initialize, to big m_nBuf =',m_nBuf
         WRITE(m_Out,*) ' ### STOP in FoamB_Initialize, to big m_nBuf =',m_nBuf
         STOP
      ENDIF

* Initialize list of vertices
      DO i=1,m_vMax
         DO j=1,m_Ndim
            m_VerX(i,j) = 0d0     ! vertices
         ENDDO
      ENDDO

* First  cells are the n-factorial simplexes from division of the basic unit cube
      m_LastCe = 0
      CALL FoamB_InitVertices
      CALL FoamB_InitCells
***************************************************************************************************
* Obsolete old method
*      IF(    m_Ndim .EQ. 2) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamB_DefNewCell( -1,  -1,   2,   3,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 4, 2, 0,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 4, 3, 0,     k) ! active
*      ELSEIF(m_Ndim .EQ. 3) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamB_DefNewCell( -1,  -1,   2,   7,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 2, 4, 8,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 3, 4, 8,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 2, 6, 8,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 3, 7, 8,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 5, 6, 8,     k) ! active
*         CALL FoamB_DefNewCell(  1,   1,  -1,  -1,   1, 5, 7, 8,     k) ! active
*      ENDIF
***************************************************************************************************
      DO iCell = 2,m_LastCe
         CALL FoamB_Explore(iCell,funW) ! Initial MC sampling
      ENDDO
***** CALL FoamB_VertPrint(6)
***** CALL FoamB_BufPrint(    m_Out)

* Life sets on: series of grows and collapss leads to an effective 
* coverage of the integration area with the the cell-foam
      DO iter=1,m_Iterat
         CALL  FoamB_Grow(funW)
*        ------------------------
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamB_BufPrint(    m_Out)
            CALL FoamB_BufActPrint( m_Out)
            CALL FoamB_VertPrint(   m_Out)
         ENDIF
* Kill unsuccesfull cells to make room for another growth
         CALL FoamB_Collapse   ! Collaps
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize<<COLLAPSE Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamB_BufPrint(    m_Out)
            CALL FoamB_BufActPrint( m_Out)
            CALL FoamB_VertPrint(   m_Out)
         ENDIF
      ENDDO
* Final growth
      CALL  FoamB_Grow(funW)
*     -----------------------
      IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
      ENDIF
      IF( m_Chat.EQ.2) THEN
         CALL FoamB_BufPrint(    m_Out)
         CALL FoamB_BufActPrint( m_Out)
         CALL FoamB_VertPrint(   m_Out)
      ENDIF
* Initializations for M.C. generation
      m_Crude  = m_CeCrud(1)  ! M.C. generation Crude value of integral
      m_SumWt  = 0d0          ! M.C. generation sum of Wt
      m_SumWt2 = 0d0          ! M.C. generation sum of Wt**2
      m_NevGen  = 0d0         ! M.C. generation sum of 1d0
      m_WtMax  = -1d99        ! M.C. generation maximum wt
      m_WtMin  =  1d99        ! M.C. generation minimum wt
      m_VolTot = m_CeIntg(1)  ! Estimate of integral tot. without error
      m_MCresult = m_VolTot   ! M.C. generation Final value of ITEGRAL, temporary asignment
      m_MCerror  = m_VolTot   ! M.C. generation Final walue of ERROR  , temporary asignment
*
      END                       ! FoamB_Initialize

      SUBROUTINE FoamB_InitVertices    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first 2^n vertices at corners of basic cube                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER       iVe,k1,k2,k3,k4,k5
*     
      m_LastVe = 2**m_Ndim
      iVe=0
      DO k5 = 0,1
         DO k4 = 0,1
            DO k3 = 0,1
               DO k2 = 0,1
                  DO k1 = 0,1
                     iVe=iVe+1
                     m_VerX(iVe,1) = k1
                     m_VerX(iVe,2) = k2
                     m_VerX(iVe,3) = k3
                     m_VerX(iVe,4) = k4
                     m_VerX(iVe,5) = k5
                     IF( iVe .EQ. m_LastVe ) GOTO 100
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !! FoamB_InitVertices



      SUBROUTINE FoamB_MakeEvent(funW)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates point/vector Xrand with the weight MCwt                              //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCell,i,j,iv
      DOUBLE PRECISION   Wt,x1,x2,Dx,MCwt
      DOUBLE PRECISION   Lambda(m_NdiMax)
*     -----------------------------------------------------------------
*     choose randomly one cell
      CALL  FoamB_Peek(iCell)
*     generate randomly/uniformly vector Vrand inside this simplex
      CALL FoamB_MakeLambda(Lambda)
      DO j=1,m_Ndim
         m_MCvector(j) = m_VerX( m_CeVert(iCell,m_Ndim+1) ,j)
         DO iv=1,m_Ndim
            m_MCvector(j) = m_MCvector(j) 
     $           +Lambda(iv)*( m_VerX( m_CeVert(iCell,iv) ,j) -m_VerX( m_CeVert(iCell,m_Ndim+1) ,j) )
         ENDDO
      ENDDO
      Dx = m_CeVolu(iCell)      ! Cartesian volume of the Cell
* weight average normalised to Crude integral over the cell
      MCwt =funW(m_MCvector)*Dx/m_CeCrud(iCell)
      m_nCalls =  m_nCalls+1
      m_MCwt   =  MCwt
* accumulation of statistics for the main MC weight
      m_SumWt  =  m_SumWt+MCwt           ! sum of Wt
      m_SumWt2 =  m_SumWt+MCWt*Mcwt      ! sum of Wt**2
      m_NevGen =  m_NevGen+1d0           ! sum of 1d0
      m_WtMax  =  MAX(m_WtMax,MCwt)      ! maximum wt
      m_WtMin  =  MIN(m_WtMin,MCwt)      ! minimum wt
* update also weight sums in the cell,
* note weights here are normalized absolutely, eg. to the value of the integral
      Wt = MCwt*m_CeCrud(iCell)
      m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt      ! sum of weights
      m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt   ! sum of weights squared
      m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0     ! sum of 1
      m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
      m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
      END                       ! FoamB_MakeEvent


      SUBROUTINE FoamB_MakeLambda(Lambda)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Lambda such that Sum Lamba(i) < 1, with uniform probab.     //
*//   This  vector is used to populate uniformly the interior of a simplex.              //
*//   The method is: generate point inside cube, order components (maping into simplex)  //
*//   and take differences of Lambda(i+1) - Lambda(i)                                    //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            i,k
      DOUBLE PRECISION   Lambda(m_NdiMax), y
      REAL               Qrand( m_NdiMax)        ! from PseuMar
      REAL               x
*     --------------------------------------------------------
      CALL PseuMar_MakeVec(Qrand,m_Ndim)
* order components (maping into simplex)
      DO i =m_Ndim,1,-1
         DO k =2,i
            IF( Qrand(k).LT.Qrand(k-1)) THEN
               x            = Qrand(k)
               Qrand(k)    = Qrand(k-1)
               Qrand(k-1)  = x
            ENDIF
         ENDDO
      ENDDO
      Lambda(1)=Qrand(1)
      DO k =2,m_Ndim
         Lambda(k)=Qrand(k)-Qrand(k-1)
      ENDDO
      END                       ! MakeLambda

      SUBROUTINE FoamB_MCgenerate(funW,MCvector,MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Obsolete                                                                       //
*//   Generates point/vector MCvector with the weight MCwt                           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   MCvector(*),MCwt
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            j
*     ---------------------------------------------------------------
      CALL FoamB_MakeEvent(funW)
      MCwt = m_MCwt
      DO j=1,m_Ndim
         MCvector(j) =m_MCvector(j)
      ENDDO
      END                       !!FoamB_MCgenerate


      SUBROUTINE FoamB_Peek(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly pointer iCell of an active cell                           //
*//                                                                                  //
*// We walk randomly from top of tree downwards until we find active cell m_CeStat=1 //
*// At each step one of daugters cells is choosen randomly according                 //
*// to their volume estimates.                                                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,p1,volu1,volu2,volu,TotCru,sum
      REAL               Qrand(10)        ! from PseuMar
*     ----------------------------------------------------------------
* first cell is special because it has Ndim-factorial daughters, istead of just 2
      kCell = 1
      Dau1  = m_CeDau1(kCell)
      Dau2  = m_CeDau2(kCell)
      TotCru   = 0d0
      DO iCell= Dau1,Dau2
         TotCru = TotCru+m_CeCrud( iCell )
      ENDDO
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iDau  = -1
      sum   = 0d0
      DO iCell= Dau1,Dau2
         iDau  = iCell
         sum = sum+m_CeCrud( iCell )
         IF( random .LT. sum/TotCru ) GOTO 100
      ENDDO
      IF(iDau.EQ.-1) GOTO 990
 100  kCell=iDau
c[[[[
cc      WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_Peek: top daughter =',kCell
c]]]]
      IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
* now the other standard cells with 2 daughters
      DO i=1,10000000
         IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
         volu1= m_CeCrud( m_CeDau1(kCell) )
         volu2= m_CeCrud( m_CeDau2(kCell) )
         p1 = volu1/(volu1+volu2)
         CALL PseuMar_MakeVec(Qrand,1)
         random = Qrand(1)
         IF( random .LT. p1 ) THEN
            kCell = m_CeDau1(kCell)
         ELSE
            kCell = m_CeDau2(kCell)
         ENDIF
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_Peek: normal daughter =',kCell
c]]]
      ENDDO
      GOTO 990
 300  CONTINUE
      iCell=kCell
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_Peek: choosen cell =',kCell
c]]]
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamB_Peek, something went wrong !!!!'
      STOP
      END                       !!! FoamB_Peek

      SUBROUTINE FoamB_PeekMax(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER   iCell
      INTEGER   i
      DOUBLE PRECISION  CrudMax, Crud
*     ---------------------------------------------------
      iCell = 0
      CrudMax = -1d150
      DO i = 1,m_LastCe
         IF( m_CeStat(i).EQ.1 ) THEN
            Crud=  ABS(m_CeCrud(i))
            IF(Crud .GT. CrudMax) THEN
               CrudMax = Crud
               iCell = i
            ENDIF
         ENDIF
      ENDDO
****  WRITE(*,*) '###>>> FoamB_PeekMax: iCell=',iCell
      IF(iCell.EQ.0) THEN
         WRITE(*,*) '### STOP in FoamB_PeekMax: not found iCell=', iCell
         STOP
      ENDIF
      END                       ! FoamB_PeekMax



      SUBROUTINE FoamB_PltBegin     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Initialization, write header of TeX file                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER id,kax,kay
*---------------------------------------------------
      DOUBLE PRECISION    dxl,dxu,xl,xu,yl,yu
      CHARACTER*8  chxfmt,chyfmt
      INTEGER      icont
      DATA         icont /0/
*---------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      icont=icont+1
*
      IF(icont .GE. 1) THEN
         chxfmt =  'f8.4'
         chyfmt =  'f8.4'
         m_ltx  = 11
         OPEN(m_ltx, FILE='map.tex')
         WRITE(m_ltx,'(2A)') '\\newpage'
      ENDIF
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') '\\documentclass[12pt]{article}'
      WRITE(m_ltx,'(A)') '\\usepackage{color}' !<-for colors!!!
      WRITE(m_ltx,'(A)') '\\usepackage{epic}'  !<-for extended ploting
      WRITE(m_ltx,'(A)') '\\textwidth  = 16cm'
      WRITE(m_ltx,'(A)') '\\textheight = 18cm'
      WRITE(m_ltx,'(A)') '\\pagestyle{empty}'
      WRITE(m_ltx,'(A)') '\\begin{document}'
      WRITE(m_ltx,'(A)') '  '
*------------------------------!
      WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'!
      WRITE(m_ltx,'(A)') '\\begin{figure}[!ht]'
      WRITE(m_ltx,'(A)') '\\centering'
*------------------------------!
* Frames and labels
*------------------------------!
      WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
      WRITE(m_ltx,'(A)') '\\setlength{\\unitlength}{0.1mm}'
      WRITE(m_ltx,'(A)') '\\begin{picture}(1600,1600)'
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox(1600,1600){ }}'

      END


      SUBROUTINE FoamB_PltCell(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all cells                                                                 //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            iCell,mout,active,j
      INTEGER            iV1,iV2,iV3
      INTEGER            kx1,ky1,kx2,ky2,kx3,ky3,kx,ky
*     ----------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
c[[[
c      WRITE(m_ltx,'(A)') '\\put(80,80){\\color{blue}\\dashbox{7}( 1440,1440){ }}' ! 5% edge band
c]]]
      DO iCell = 2, m_LastCe
         iV1=m_CeVert(iCell,1)
         iV2=m_CeVert(iCell,2)
         iV3=m_CeVert(iCell,3)
         kx1 = m_VerX(iV1,1)*1600
         ky1 = m_VerX(iV1,2)*1600
         kx2 = m_VerX(iV2,1)*1600
         ky2 = m_VerX(iV2,2)*1600
         kx3 = m_VerX(iV3,1)*1600
         ky3 = m_VerX(iV3,2)*1600
         kx= (kx1+kx2+kx3)/3
         ky= (ky1+ky2+ky3)/3
         IF(m_CeStat(iCell).EQ.1) THEN
***         WRITE(*,*) iCell,iV1,iV2,iV3
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx1,',',ky1,')(',kx2,',',ky2,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx2,',',ky2,')(',kx3,',',ky3,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx3,',',ky3,')(',kx1,',',ky1,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $           '\\put(',kx,',',ky,'){\\makebox(0,0)[b]{\\hbox{\\small\\color{magenta} ',iCell,' }}}' !
         ENDIF
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! FoamB_BufPrint

      SUBROUTINE FoamB_PltEnd     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Close Tex file with plot                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
*
      IF(m_nDim.NE.2) RETURN
      WRITE(m_ltx,'(A)') '\\end{picture}'
      WRITE(m_ltx,'(A)') '\\end{figure}'
      WRITE(m_ltx,'(A)') '\\end{document}'
      CLOSE(m_ltx)
      END

      SUBROUTINE FoamB_PltVert(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all vertices                                                              //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*------------------------------------------------------------------------------
*     Mark plots for plots
      CHARACTER*62 star,diamond,circle,ring,times,disc,plus,box,dot
      PARAMETER (diamond ='\\makebox(0,0){\\Large $\\diamond$}')
      PARAMETER (star    ='\\makebox(0,0){\\Large\\color{red} $\\star$}')
      PARAMETER (circle  ='\\circle{30}')
      PARAMETER (ring    ='\\circle{20}')
      PARAMETER (times   ='\\makebox(0,0){\\Large $\\times$}')
      PARAMETER (disc    ='\\circle*{20}')
      PARAMETER (plus    ='\\makebox(0,0){\\Large $+$}')
      PARAMETER (box     ='\\makebox(0,0){\\Large $\\Box$}') !!! does not work???
      PARAMETER (dot     ='\\circle*{10}')
*------------------------------------------------------------------------------
      CHARACTER*62  chmark
      INTEGER       kx,ky
*---------------------------------------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
* Count references of vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1 !
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1 !
               ENDIF
            ENDDO
         ENDDO
      ENDDO
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox( 1600,1600){ }}' !
* Plotting symbol
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VD}[2]{\\put(#1,#2){',disc,'}}'!
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VS}[2]{\\put(#1,#2){',star,'}}'!
      WRITE(m_ltx,'(10A)') 
     $     '\\newcommand{\\VN}[3]{\\put(#1,#2){\\makebox(0,0)[b]{\\hbox{\\small\\color{red} #3}}}}' !
      DO iVe = 1, m_LastVe
         kx = m_VerX(iVe,1)*1600
         ky = m_VerX(iVe,2)*1600
cc         WRITE(*,*) NoRefs(iVe),NoRefsAc(iVe)
         IF( NoRefsAc(iVe).LE.2 ) THEN
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VD{',kx,'}{',ky,'}'
         ELSE
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VS{',kx,'}{',ky,'}'
         ENDIF            
         WRITE(   m_ltx,'(A,I5,A,I5,A,I5,A)') '\\VN{',kx-8,'}{',ky+12,'}{',iVe,'}' !
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! VertPrint



*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//             Foam Version 1.01                                                         //
*//             August 1999                                                               //
*//                                                                                       //
*//  N-dimensional general purpose Monte Carlo sampler with self-adapting simplectic grid //
*//                                                                                       //
*//             Author:   Stanislaw JADACH                                                //
*//             Address:  INP Cracow                                                      //
*//             Email:    S.Jadach@cern.ch, S.Jadach@ifj.edu.pl                           //
*//             HomePage: http://home.cern.ch/~jadach/                                    //
*//                                                                                       //
*//  First version 1.00 written by S.J. in May 1999 during visit in DESY                  //
*///////////////////////////////////////////////////////////////////////////////////////////

*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//          Pseudoclass Foam                                                                          //
*//                                                                                                    //
*//                                                                                                    //
*//                      Initialization of the grid                                                    //
*//  FoamB_PreInitialize                 : Pre-initialization, set all default values (constructor?)   //
*//  FoamB_Initialize(FunW)              : Initialization of the grid etc.                             //
*//  FoamB_InitVertices                  : Initializes first vertices of the basic cube                //
*//  FoamB_InitCells                     : Initializes first n-factorial cells inside original cube    //
*//  FoamB_DefCell                       : Create new (daughter) cell and append at end of the buffer  //
*//  FoamB_Explore(iCell,funW)           : Short MC sampling in iCell, determine <wt>, wtMax etc.      //
*//  FoamB_RanDiscr(Crud,nTot,Power,iRand) : Random choice of cell division direction                  //
*//  FoamB_MakeLambda(Lambda)            : auxiliary procedure for FoamB_Explore                       //
*//  FoamB_Determinant(R,Det)            : determinant of matrix R                                     //
*//  FoamB_Det2Lapl(R,i1,i2)             : Laplace formula for 1-dim. determinant                      //
*//  FoamB_Det3Lapl(R,i1,i2,i3)          : Laplace formula for 2-dim. determinant                      //
*//  FoamB_Det4Lapl(R,i1,i2,i3,i4)       : Laplace formula for 3-dim. determinant                      //
*//  FoamB_Det5Lapl(R,i1,i2,i3,i4,i5)    : Laplace formula for 4-dim. determinant                      //
*//  FoamB_Grow(funW)              : grow cells until buffer is full                                   //
*//  FoamB_PeekMax(iCell)          : choose randomly one cell, used also in MC generation              //
*//  FoamB_Peek(iCell)             : Generates randomly one (active) cell pointer iCell                //
*//  FoamB_Divide(iCell,funW,RC)   :Divide iCell into two daughters; iCell retained, taged as inactive //
*//  FoamB_Collapse                :Finds and remooves unsuccesfull cells, some nonactive cells revived//
*//                     Generation                                                                     //
*//  FoamB_MakeEvent(Density)      : Generates point/vector Xrand with the weight MCwt                 //
*//  FoamB_GetMCvector(MCvector)   : Provides point/vector MCvector generated by  MakeEvent            //
*//  FoamB_GetMCwt(MCwt)           : Provides MCwt, MC weight calculated by MakeEvent                  //
*//  FoamB_MCgenerate(funW,X,MCwt) : Alternative entry, Generates point X with the weight MCwt         //
*//                     Finalization                                                                   //
*//  FoamB_Finalize(MCresult,MCerror)    : Calculates integral and its error after (only from) MC run  //
*//  FoamB_GetIntegral(MCresult,MCerror) : Integral estimate from Initialization + MC generation       //
*//                     Other Getters and Setters                                                      //
*//  FoamB_GetCrude(Crude)         :Provides Crude used in MC generation                               //
*//  FoamB_SetNdim(Ndim)           :Sets Ndim= no. of dimensions  (to be called before Initialize)     //
*//  FoamB_GetNdim(Ndim)           :Provides Ndim, miscelaneous, for tests                             //
*//  FoamB_SetnBuf(nBuf)           :Sets nBuf, working area in buffer                                  //
*//  FoamB_SetIterat(Iterat)       :Sets Iterat=no. of iterations (to be called before Initialize)     //
*//  FoamB_SetOut(Out)             :Sets output unit number                                            //
*//  FoamB_SetChat(Chat)           :Sets chat level; Chat=0,1,2 chat level in output, Chat=1 normal    //
*//  FoamB_SetnSampl(nSampl)       :Sets nSampl; No of MC sampling before dividing cell                //
*//  FoamB_SetOptCrude(OptCrude)   :Sets OptCrude; type of Crude =0,1,2 for True,Sigma,WtMax           //
*//  FoamB_SetOptBeta(OptBeta)     :Sets type of method in cell division                               //
*//  FoamB_SetOptPeek              :Sets type of method in cell division                               //
*//  FoamB_SetOptEdge(OptEdge)     :Sets OptEdge; decides whether vertices are included in the sampling//
*//  FoamB_SetKillFac(KillFac)     :Sets KillFac; kill factor for poor cells                           //
*//                    Debugging and miscelaneous                                                      //
*//  FoamB_Check(mout,level)       :Checks all pointers (after comression) debuging!                   //
*//  FoamB_ActUpda                 :Miscelaneous, Creates list of active cells (pointers)              //
*//  FoamB_BufPrint(mout)          :Prints all cells, debugging                                        //
*//  FoamB_BufActPrint(mout)       :Prints all active cells, debugging                                 //
*//  FoamB_VertPrint(mout)         :Prints all vertices,  debugging                                    //
*//  FoamB_PltBegin                :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltVert(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltCell(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltEnd                  :Ploting 2-dim. cells and vertices                                  //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//  Input parameters:                                                                                 //
*//    nDim     number of dimensions in the problem, for the moment nDim=1-5 in this version,          //
*//             n>5 requires re-writing FoamB__Determinant,                                            //
*//             for n=1 alternatively Foam1A may be used, could be factor 2 faster!                    //
*//    nBuf     Actual dynamic lenth of the buffer m_nBuf<m_nBufMax. For strongly peaked distribution  //
*//             nBuf should be as large as possible, this will increase CPU time in initialization     //
*//             MC generation is weakly affected by increasing nBuf                                    //
*//    nSampl   No of sampling when dividing cell, nSampl=10-100 is OK, further increase improves      //
*//             costs CPU time and apparently does not increase grid efficiency too much.              //
*//             This should be checked however for every new distribution.                             //
*//    Iterat   No of iterations in consolidation, Iterat=0 is OK in may cases, but for very sharp     //
*//             peaks grid may expand in areas where there is litle of integrated propability.         //
*//             Additinal iteration Iterat>0 corrects for this.                                        //
*//    KillFac  kill factor for poor cells. Parameter for iteration. Default KillFac=1 seems to be OK  //
*//             For certain distribution it may be profitable to adjust it within 0.5<KillFac<2.0      //
*//    OptCrude Type of Crude =0,1,2 for TrueInt,Sigma,WtMax,  Crude=WtMax is the best if we aim       //
*//             at rejection leading to wt=1 events. If not then Crude=TrueInt iswiser choice leading  //
*//             to save of CPU time.                                                                   //
*//    OptEdge  decides whether vertices are included in the sampling. Default  OptEdge=1 causes that  //
*//             vertices at the edge of simplex cells are included always in MC exploration            //
*//             of the cell. In the case of density distrib. with weak integrable singularities        //
*//             at the edges it may be not possible and OptEdge=0 may help.                            //
*//    Out      Miscelaneous. Output unit number.                                                      //
*//    Chat     Miscelaneous. Chat=0,1,2 chat level in output, Chat=1 normal level.                    //
*//                                                                                                    //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//  Terminology:                                                                                      //
*//    "Active cells" are these which did not divide and are eligible for division                     //
*//  Remarks:                                                                                          //
*//    List of active cells is not realy necessary, but let us keep it for possible                    //
*//    future developements or tests.                                                                  //
*////////////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE FoamB_PreInitialize     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Presets certain defaults for switches and other and regualtory parameters.     //
*//   They Can be reset with setters                                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
*     -------------------------------------------------
      IF(m_Magic .EQ. 0 ) RETURN
      m_nBuf     = 500               ! Actual dynamic lenth of the buffer m_nBuf<m_nBufMax
      m_Iterat   = 10                ! No of iterations in consolidation
      m_KillFac  = 1d0               ! kill factor for poor cells
      m_Out      = 6                 ! Output unit
      m_Chat     = 1                 ! Chat=0,1,2 chat level in output, Chat=1 normal level
      m_nSampl   = 100               ! No of sampling when dividing cell
      m_OptCrude = 2                 ! type of Crude =0,1,2 for TrueVol,Sigma,WtMax
      m_OptPeek  = 0                 ! type of Peek =0,1 for maximum, random
      m_OptEdge  = 1                 ! decides whether vertices are included in the sampling
      m_nCalls   = 0                 ! No of function calls
      m_OptBeta  = 0                 ! type of choice of edge in the division of the cell, 0,1,2
      m_BetaPower=1d0                ! Power in case of m_OptBeta  = 2
      m_nDim     = 2                 ! dimension
*
      m_Magic = 0
      END


      SUBROUTINE FoamB_RanDiscr(Crud,nTot,Power,iRand)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates iRand in (1,nTot) acconding to discrete un-normalized probab. Crud   //
*//   Power is normaly =1, can be useful for special purposes                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION   Crud(*),Power
      INTEGER            nTot,iRand
      INTEGER            i
      DOUBLE PRECISION   random,sum,Total
      REAL               Qrand(10)        ! from PseuMar
*
      Total   = 0d0
      DO i= 1,nTot
         Total = Total +Crud( i)**Power
      ENDDO
      IF(Total .EQ. 0d0) GOTO 990
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iRand  = -1
      sum   = 0d0
      DO i= 1,nTot
         iRand  = i
         sum = sum +Crud( i)**Power
         IF( random .LT. sum/Total ) GOTO 100
      ENDDO
      IF(iRand .EQ. -1) GOTO 990
 100  CONTINUE
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamB_RanDiscr, something went wrong !!!!'
      STOP
      END

      SUBROUTINE FoamB_SetChat(Chat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      Chat
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Chat = Chat
      END                       !!! FoamB_SetChat

      SUBROUTINE FoamB_SetIterat(Iterat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      Iterat
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Iterat = Iterat
      END                       !!! FoamB_SetIterat

      SUBROUTINE FoamB_SetKillFac(KillFac)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      DOUBLE PRECISION   KillFac
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_KillFac = KillFac
      END                       !!! FoamB_SetKillFac

      SUBROUTINE FoamB_SetnBuf(nBuf)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      nBuf
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nBuf = nBuf
      END                       !!! FoamB_SetnBuf


      SUBROUTINE FoamB_SetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      Ndim
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Ndim = Ndim
      END                       !!! FoamB_SetNdim

      SUBROUTINE FoamB_SetnSampl(nSampl)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      nSampl
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nSampl = nSampl
      END                       !!! FoamB_SetnSampl

      SUBROUTINE FoamB_SetOptBeta(OptBeta)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      OptBeta
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptBeta = OptBeta
      END                       !!! FoamB_SetOptBeta

      SUBROUTINE FoamB_SetOptCrude(OptCrude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      OptCrude
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptCrude = OptCrude
      END                       !!! FoamB_SetOptCrude

      SUBROUTINE FoamB_SetOptEdge(OptEdge)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      OptEdge
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptEdge = OptEdge
      END                       !!! FoamB_SetOptEdge

      SUBROUTINE FoamB_SetOptPeek(OptPeek)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      OptPeek
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptPeek = OptPeek
      END                       !!! FoamB_SetOptPeek

      SUBROUTINE FoamB_SetOut(Out)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER      Out
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Out = Out
      END                       !!! FoamB_SetOut


      SUBROUTINE FoamB_VertPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all vertices                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*     ----------------------------------------------------------------
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      WRITE(mout,*) '=====================all vertices==================================='
      WRITE(mout,*) ' iVert   NoRefs  NoRefsAc       Vertex     Componets    '
      DO iVe = 1, m_LastVe
         WRITE(mout,'(i6,2i10,5f17.10)') iVe,NoRefs(iVe),NoRefsAc(iVe), (m_VerX(iVe,j),j=1,m_Ndim)
      ENDDO
      END                       !! VertPrint


      SUBROUTINE FoamC_ActUpda     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER   iCell,Dau1,Dau2
      INTEGER   i
*     ---------------------------------------------------
      m_LastAc=0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            m_LastAc=m_LastAc+1
            IF(m_LastAc .EQ. m_cMax) GOTO 950
            m_ActC(m_LastAc) = iCell
         ENDIF
      ENDDO
      RETURN
 900  WRITE(*,*) '### STOP in FoamC_ActUpda: not found iCell=', iCell
      STOP
 950  WRITE(*,*) '### STOP in FoamC_ActUpda: list of active cells too short'
      STOP
      END                       ! FoamC_ActUpda



      SUBROUTINE FoamC_BufActPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Active cells only                                                              //
*//   Side=1 indicates that this cell is "side leaf" sticking out of main branch     //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            iCell,mout,active,Side,Pare,j
      DOUBLE PRECISION   VolRat,CruRat,VoluSum,CrudSum,RatMax,RatMin,Fact,WtMin,WtMax
      DOUBLE PRECISION   AveWt, Sigma, Nentry
*     ----------------------------------------------------------------
      WRITE(mout,'(3a)') '==================================================', ' ACTIVE CELLS ',
     $                   '=================================================='
      VoluSum =0d0
      CrudSum =0d0
      RatMin  =  1d60
      RatMax  = -1d60
      WtMin   =  1d60
      WtMax   = -1d60
      active  =0
      WRITE(mout,'(2a)') ' iCell Stat Pare Dau1 Dau2 Side',
     $                   '     WtMin      WtMax        <w>    Sig/<w>      Crude    VolTrue   Ver1  Ver2 ...'
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            side=0
            Pare = m_CePare(iCell)
            IF( m_CeStat(m_CeDau1(Pare))*m_CeStat(m_CeDau2(Pare)) .EQ. 0  ) Side=1
            VolRat = m_CeIntg(iCell)* m_LastAc/m_CeCrud(1)
            CruRat = m_CeCrud(iCell)* m_LastAc/m_CeCrud(1)
            RatMin = Min(RatMin,VolRat)
            RatMax = Max(RatMax,VolRat)
            Nentry = m_CeSum(iCell,3)
            AveWt  = m_CeSum(iCell,1)/m_CeSum(iCell,3)
            Sigma  = DSQRT(  ABS(m_CeSum(iCell,2)/Nentry - AveWt**2))
            IF(AveWt.NE.0d0) WtMin = Min( WtMin, m_CeSum(iCell,4)/AveWt)
            IF(AveWt.NE.0d0) WtMax = Max( WtMax, m_CeSum(iCell,5)/AveWt)
            IF(AveWt.NE.0d0) Sigma = Sigma/AveWt
            WRITE(mout,'(6i5, 6f11.5 ,10i5)') 
     $           iCell, m_CeStat(iCell),  m_CePare(iCell),  m_CeDau1(iCell),m_CeDau2(iCell),  side,
     $           m_CeSum(iCell,4)/(m_CeCrud(iCell)+1d-100), ! minWt/AveWt
     $           m_CeSum(iCell,5)/(m_CeCrud(iCell)+1d-100), ! maxWt/AveWt
     $           m_CeIntg(iCell) /(m_CeCrud(iCell)+1d-100), ! average weight
     $           Sigma,                  ! sigma/AveWt
     $           CruRat,                 ! Crude/CruTot*Ncell
     $           VolRat,                 ! TrueVolu/VolTot*Ncell
     $           (m_CeVert(iCell,j), j=1,m_Ndim+1) ! vertices
            VoluSum = VoluSum +m_CeIntg(iCell)
            CrudSum = CrudSum +m_CeCrud(iCell)
            active  = active +1
         ENDIF
      ENDDO
      WRITE(mout,'(a,i6,a,2i6)') 'All cells: ',m_LastCe, '      Active: ', active, m_LastAc
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Volume/Tot*nCell  = ',RatMin,RatMax
      WRITE(mout,'(a,2f12.5)')  'Minimum and Maximum Weight/<Wt>       = ',WtMin,WtMax
      WRITE(mout,'(a,2g20.13)')  'Total True  Volume in active cells = ', VoluSum, m_CeIntg(1)
      WRITE(mout,'(a,2g20.13)')  'Total Crude Volume in active cells = ', CrudSum, m_CeCrud(1)
      WRITE(mout,'(a,f12.5)')   'True/Crude = ', VoluSum/CrudSum
      END                       !! FoamC_BufActPrint




      SUBROUTINE FoamC_BufPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all cells                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            iCell,mout,active,j
*     ----------------------------------------------------------------
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
      END                       !! FoamC_BufPrint


      SUBROUTINE FoamC_Check(mout,level)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Checks all pointers, this is necessary autodiagnostic because of the complicated//
*//  collapse algorithm.                                                             //
*//                                                                                  //
*//  level=0, no printout, failures causes STOP                                      //
*//  level=1, printout, failures lead to WARNINGS only                               //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER       mout,level
      INTEGER       nFailures, iCell, Dau1,Dau2, Pare, NoRefs(m_vMax), iVe,n
      INTEGER       NoEmpty
*     ---------------------------------------------------------
      nFailures=0
      IF(level.EQ.1) WRITE(mout,*)
     $'//////////////////////////////////////// FoamC_Checks /////////////////////////////////////////////'
      DO iCell = 1,m_LastCe
         Dau1 = m_CeDau1(iCell)
         Dau2 = m_CeDau2(iCell)
         Pare = m_CePare(iCell)
* checking on parents
         IF(iCell.GT.1) THEN
            IF(Pare.GT.m_LastCe) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Parent out of range = ',Pare
            ENDIF
         ENDIF
         IF(iCell.GT.1) THEN
            IF(  (Pare.NE.1) .AND. (m_CeDau1(Pare).NE.iCell) .AND. (m_CeDau2(Pare).NE.iCell)  ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Parent not pointing to this daughter Pare= ',Pare
            ENDIF
         ENDIF
* checking on daughters
         IF( Dau1 .GT. m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter out of range Dau1= ',Dau1
         ENDIF
         IF( Dau2 .GT.m_LastCe ) THEN
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter out of range Dau2= ',Dau2
         ENDIF
         IF( Dau1.GE.1 .AND. Dau1.LE. m_LastCe) THEN
            IF( m_CePare(Dau1).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter not pointing to parent Dau1= ',Dau1
            ENDIF
         ENDIF
         IF( Dau2.GE.1 .AND. Dau2.LE. m_LastCe) THEN
            IF( m_CePare(Dau2).NE.iCell ) THEN
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter not pointing to parent Dau2= ',Dau2
            ENDIF
         ENDIF 
      ENDDO
* check on vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO n=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,n) ) NoRefs(iVe) =1
            ENDDO
         ENDDO
      ENDDO
      DO iVe = 1, m_LastVe
         IF(NoRefs(iVe).EQ.0 .AND.  level.EQ.1) WRITE(mout,*) '***** Vertex no. ',iVe, '  NOT referenced!'
      ENDDO
* Check for empty cells
      NoEmpty = 0d0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            IF( m_CeCrud(iCell) .EQ. 0d0) NoEmpty = NoEmpty +1
         ENDIF
      ENDDO
      IF( NoEmpty.GT.0) THEN
         WRITE(mout,*) '++++++++++ FoamC_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
         WRITE(   *,*) '++++++++++ FoamC_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty
      ENDIF
* summary
      IF(level.EQ.1) WRITE(mout,*) '++++++++++ FoamC_Check has found total ', nFailures, ' failures '
      IF(level.EQ.1) WRITE(mout,*)
     $'///////////////////////////////////////////////////////////////////////////////////////////////////'
      IF(level.EQ.0 .AND. nFailures.GT.0 ) THEN
         WRITE(mout,*) '++++++++++ STOP in FoamC_Check, found total ', nFailures, ' failures '
         STOP
      ENDIF
      END                       ! FoamC_Check


      SUBROUTINE FoamC_Collapse    !# Initialization
*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//   This routine remooves unsuccesfull cells which have collected too litle "Volume"    //
*//   before the new round of divisions                                                   //
*//                                                                                       //
*//   The procedure is the following:                                                     //
*//   1. find most succesfull (the sweetest) active cell and find its VoluMax             //
*//   2. Scan entire buffer/tree from top to bottom, inactive cells                       //
*//   3. Activate every nonactive cell with Vol<VoluMax*KilFac and kill its pending tree  //
*//   4. Collapse all storage, list of cells, vertices etc. to make room for new iteration//
*//                                                                                       //
*//   Remooving "dead cells" and "unreferenced vertives" is the hardes part of the task   //
*//   I have found that this can be done most easily with special "mask matrices"         //
*//                                                                                       //
*///////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION  CrudMax,CrudOrig,Crud
      INTEGER           MaskV(m_vMax),    LinkV(m_vMax), kVer, kSum, iStart
      INTEGER           MaskC(m_nBufMax), LinkC(m_nBufMax)
      INTEGER           iCell, kCell, Pare, Stat, Dau1,Dau2, k, i, parent
*     -------------------------------------------------------
* Find richest ACTIVE cell
      CrudMax = 0d0
      DO iCell = 1,m_LastCe
         Stat= m_CeStat(iCell)
         IF(Stat .EQ.1 ) CrudMax= Max(CrudMax, m_CeCrud(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Find nonactive celles which are poorer than richest asctive (with CrudMax)    //
*// redefine them as active and kill trailing branch.                             //
*// Cells scheduled for remooval taged with Stat=-3                               //
*// We start with first Cell which is true daughter, iCell=iStart                 //
*///////////////////////////////////////////////////////////////////////////////////
      iStart = m_CeDau2(1)+1
***** WRITE(*,*) ' CrudMax,iStart =',CrudMax,iStart
      DO iCell = iStart ,m_LastCe
         Stat= m_CeStat(iCell)
         Dau1=m_CeDau1(iCell)
         Dau2=m_CeDau2(iCell)
*     let us first check if we are on the dead branch, if yes then shcedule daughters for remooval
         IF(Stat .EQ. -3 ) THEN
*****       WRITE(*,*) ' we are on the dead branch, iCell =',iCell,'Daughters to be killed',Dau1,Dau2
            IF(Dau1.NE.-1) m_CeStat(Dau1) = -3
            IF(Dau2.NE.-1) m_CeStat(Dau2) = -3
            m_CeDau1(iCell) = -1
            m_CeDau2(iCell) = -1
         ELSEIF( Stat .EQ. 0 ) THEN ! otherwise if it is normal inactive cell
*     reproduce original Crude as in Explore (may be this thould be memorized in Explore?)
            IF(     m_OptCrude.EQ.0 ) THEN
               CrudOrig  =  m_CeIntg(iCell) ! true volume
            ELSEIF( m_OptCrude.EQ.1 ) THEN
               CrudOrig  =  DSQRT(m_CeSum(iCell,2)/m_nSampl) ! Sqrt( <w>**2 + sigma**2 )
            ELSEIF( m_OptCrude.EQ.2 ) THEN
               CrudOrig    =  m_CeSum(iCell,5) ! wtmax
            ELSE
               WRITE(m_out,*) ' ++++ STOP in FoamC_Explore, wrong m_OptCrude =',m_OptCrude
               STOP
            ENDIF
            Crud= m_CeCrud(iCell)
*****       WRITE(*,*) ' Normal inactive iCell =',iCell,'CrudOrig,Crud=',CrudOrig,Crud
            IF(CrudOrig .LT. CrudMax*m_KillFac ) THEN     ! and if it is poor in sugar, make it active
               m_CeStat(iCell) = 1                        ! REVIVE, reset status as ACTIVE
               m_CeStat(Dau1) = -3                        ! and kill both daugters
               m_CeStat(Dau2) = -3               
               m_CeDau1(iCell) = -1
               m_CeDau2(iCell) = -1
*****          WRITE(*,*) ' poor cell, iCell,Stat =',iCell,Stat,'killed Daughters',Dau1,Dau2
*     Go back to original Crude in this cell and correct in all parent cells to the top of the tree
               m_CeCrud(iCell) = CrudOrig
               parent = m_CePare(iCell)
               DO i = 1,m_nBuf
                  IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
                  m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -Crud)
                  parent=m_CePare(parent)
               ENDDO
 100           CONTINUE
            ENDIF
         ENDIF      
      ENDDO
***** WRITE(*,*) '########## Now cells scheduled for remooval have status -3 !!!  '
***** CALL FoamC_BufPrint(6)
*///////////////////////////////////////////////////////////////////////////////////
*// Remoove inactive cells. Quite nontrivial task.                                //      
*// First find out which cell is dead, result is stored in MaskC                  //
*///////////////////////////////////////////////////////////////////////////////////
      DO iCell =1,m_LastCe
         MaskC(iCell)=0
      ENDDO
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell) .NE. -3 ) MaskC( iCell ) =1
      ENDDO
* MaskC turned into step-function LinkC, used in translation of pointers in cells
      kSum =0
      DO iCell = 1,m_LastCe
         kSum         = kSum +MaskC(iCell)
         LinkC(iCell) = kSum
      ENDDO
***** DO iCell = 1,m_LastCe
***** WRITE(*,*) 'iCell, MaskC, LinkC ====>', iCell, MaskC(iCell),LinkC(iCell)
***** ENDDO
* Collapse buffer by shifting downwards all cells
      DO iCell = 1,m_LastCe
         IF(MaskC(iCell).NE.0 ) THEN
            m_CeStat( LinkC(iCell) ) = m_CeStat( iCell )
            m_CePare( LinkC(iCell) ) = m_CePare( iCell )
            m_CeDau1( LinkC(iCell) ) = m_CeDau1( iCell )
            m_CeDau2( LinkC(iCell) ) = m_CeDau2( iCell )
            DO k=1,m_Ndim+1
               m_CeVert( LinkC(iCell),k ) = m_CeVert( iCell ,k)
            ENDDO
            m_CeIntg( LinkC(iCell) ) = m_CeIntg( iCell )
            m_CeCrud( LinkC(iCell) ) = m_CeCrud( iCell )
            m_CeVolu( LinkC(iCell) ) = m_CeVolu( iCell )
            m_CeXave( LinkC(iCell) ) = m_CeXave( iCell )
            m_CeBest( LinkC(iCell) ) = m_CeBest( iCell )
            DO k=1,m_sMax
               m_CeSum( LinkC(iCell),k ) = m_CeSum( iCell,k )
            ENDDO
         ENDIF
      ENDDO
      m_LastCe = kSum
* pointers to parents and daughters have to be also translated/updated
      DO iCell = 1,m_LastCe
         IF(m_CePare(iCell).GE.1 ) m_CePare(iCell) = LinkC( m_CePare(iCell) )
         IF(m_CeDau1(iCell).GE.1 ) m_CeDau1(iCell) = LinkC( m_CeDau1(iCell) )
         IF(m_CeDau2(iCell).GE.1 ) m_CeDau2(iCell) = LinkC( m_CeDau2(iCell) )
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*// Reconstruction of list of vertices. Kick out unreferced vertices.             //
*// First we construct MaskV which tells us which vertex is still in use          //
*///////////////////////////////////////////////////////////////////////////////////
***** CALL FoamC_BufPrint(   6)
***** CALL FoamC_VertPrint(  6)
      DO kVer =1,m_LastVe
         MaskV(kVer)=0
      ENDDO
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            MaskV( m_CeVert(iCell,k) )=1
         ENDDO
      ENDDO
***** DO kVer =1,m_LastVe
*****   WRITE(*,*) 'kVer, MaskV ====>', kVer, MaskV(kVer),(m_VerX(kVer,k),k=1,m_Ndim)
***** ENDDO
* MaskV turned into step-function LinkV, used in translation of pointers in cells
      kSum =0
      DO kVer =1,m_LastVe
         kSum         = kSum +MaskV(kVer)
         LinkV(kVer) = kSum
      ENDDO
* Translate pointers in Cells
      DO iCell = 2,m_LastCe
         DO k=1,m_Ndim+1
            m_CeVert(iCell,k) = LinkV( m_CeVert(iCell,k) )
         ENDDO
      ENDDO
* And reorganize list of vertices as well !!!
      DO kVer =1,m_LastVe
         IF(MaskV(kVer).NE.0 ) THEN
            DO k=1,m_Ndim
               m_VerX( LinkV(kVer), k )=m_VerX( kVer, k )
            ENDDO
         ENDIF
      ENDDO
      m_LastVe = kSum

***** CALL FoamC_VertPrint(   6)
***** WRITE(*,*) '######################### FoamC_Collapse  is complete #####################'
***** CALL FoamC_BufPrint(    6)
***** CALL FoamC_BufActPrint( 6)

* Update list of active cells, only for internal tests
      CALL FoamC_ActUpda
      CALL FoamC_Check(6,0)     ! Check if Collapseion result is OK
*
      END                       ! FoamC_Collapse


      SUBROUTINE FoamC_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create new (daughter) cell and append it at the very end of the buffer         //
*//   iCeNew is pointer of the new cell                                              //
*//   Note clever trick: volume of this daughter is assigned initialy half volume    //
*//   of the parent, if parent exists.                                               //
*//   In Explore this value is used to update all parents such that                  //
*//   in the entrire tree parents have volume being sum of all daughter volumes.     //
*//   This summation discipline is useful for MC generation of an active cell by     //
*//   going randomly from top to bottom of the tree.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            Stat,Pare,Dau1,Dau2,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
*     ------------------------------------------------------------------
      IF( m_LastCe .EQ. m_nBuf) THEN
         WRITE(*,*) ' STOP in FoamC_DefNewCell: something wrong with m_nBuf '
         STOP
      ENDIF
      m_LastCe = m_LastCe+1
      iCeNew   = m_LastCe
      m_CeStat(iCeNew)= Stat                    ! status code, =0 inactive, =1 active
      m_CePare(iCeNew)= Pare                    ! parent cell pointer
      m_CeDau1(iCeNew)= Dau1                    ! daughter1 cell pointer
      m_CeDau2(iCeNew)= Dau2                    ! daughter2 cell pointer
      m_CeBest(iCeNew)= -1                      ! pointer for planning division of the cell
      m_CeXave(iCeNew)= 0.5d0                   ! factor for division
      DO k=1,m_NdiMax+1
         m_CeVert(iCeNew,k)= Vertex(k)
      ENDDO
c      m_CeVert(iCeNew,1)= Ver1                  ! 1-st vertex pointer
c      m_CeVert(iCeNew,2)= Ver2                  ! 2-nd vertex pointer
c      m_CeVert(iCeNew,3)= Ver3                  ! 3-rd vertex pointer
c      m_CeVert(iCeNew,4)= Ver4                  ! 4-th vertex pointer
      IF(Pare.NE.-1) THEN
         m_CeIntg(iCeNew)= m_CeIntg(Pare)/2d0   ! integr. half of parent
         m_CeCrud(iCeNew)= m_CeCrud(Pare)/2d0   ! integr. half of parent
      ELSE
         m_CeIntg(iCeNew)= 0d0
         m_CeCrud(iCeNew)= 0d0
      ENDIF
      m_CeVolu(iCeNew)= 0d0                     ! cartesian Volume   
      END                       ! FoamC_DefCell

      SUBROUTINE FoamC_DefNewCell(Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   obsolete!!!!                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew,k
      INTEGER            Vertex(m_NdiMax+1)
      Vertex(1) = Ver1
      Vertex(2) = Ver2
      Vertex(3) = Ver3
      Vertex(4) = Ver4
      CALL FoamC_DefCell(Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
      END                       !!!FoamC_DefNewCell

      DOUBLE PRECISION FUNCTION FoamC_Det2Lapl(R,i1,i2)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      INTEGER  i1,i2
*     ------------------------------------------------------------
      FoamC_Det2Lapl= R(1,i1)*R(2,i2) - R(1,i2)*R(2,i1)
      END


      DOUBLE PRECISION FUNCTION FoamC_Det3Lapl(R,i1,i2,i3)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamC_Det2Lapl
      INTEGER  i1,i2,i3
*     ------------------------------------------------------------
      FoamC_Det3Lapl=+R(3,i1) *FoamC_Det2Lapl(R,i2,i3)
     $               -R(3,i2) *FoamC_Det2Lapl(R,i1,i3)
     $               +R(3,i3) *FoamC_Det2Lapl(R,i1,i2)
      END

      DOUBLE PRECISION FUNCTION FoamC_Det4Lapl(R,i1,i2,i3,i4)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamC_Det3Lapl
      INTEGER  i1,i2,i3,i4
*     ------------------------------------------------------------
      FoamC_Det4Lapl=-R(4,i1) *FoamC_Det3Lapl(R,i2,i3,i4)
     $               +R(4,i2) *FoamC_Det3Lapl(R,i1,i3,i4)
     $               -R(4,i3) *FoamC_Det3Lapl(R,i1,i2,i4)
     $               +R(4,i4) *FoamC_Det3Lapl(R,i1,i2,i3)
      END

      DOUBLE PRECISION FUNCTION FoamC_Det5Lapl(R,i1,i2,i3,i4,i5)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax), Det, FoamC_Det4Lapl
      INTEGER  i1,i2,i3,i4,i5
*     ------------------------------------------------------------
      FoamC_Det5Lapl=+R(4,i1) *FoamC_Det4Lapl(R,i2,i3,i4,i5)
     $               -R(4,i2) *FoamC_Det4Lapl(R,i1,i3,i4,i5)
     $               +R(4,i3) *FoamC_Det4Lapl(R,i1,i2,i4,i5)
     $               -R(4,i4) *FoamC_Det4Lapl(R,i1,i2,i3,i5)
     $               +R(4,i5) *FoamC_Det4Lapl(R,i1,i2,i3,i4)
      END


      SUBROUTINE FoamC_Determinant(R,Det)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Calculates determinant of matrix R                                             //
*//   Use of Laplace formula should be perhaps replaced with something faster        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      DOUBLE PRECISION   FoamC_Det2Lapl, FoamC_Det3Lapl,FoamC_Det4Lapl,FoamC_Det5Lapl
*     -------------------------------------------------
      IF(        m_Ndim .EQ. 1) THEN
         Det= R(1,1)
      ELSEIF(    m_Ndim .EQ. 2) THEN
         Det= FoamC_Det2Lapl(R, 1,2)
      ELSEIF(    m_Ndim .EQ. 3) THEN
         Det= FoamC_Det3Lapl(R, 1,2,3)
      ELSEIF(    m_Ndim .EQ. 4) THEN
         Det= FoamC_Det4Lapl(R, 1,2,3,4)
      ELSEIF(    m_Ndim .EQ. 5) THEN
         Det= FoamC_Det5Lapl(R, 1,2,3,4,5)
      ELSE
         WRITE(*,*) '####FoamC_Determinant: STOP, m_Ndim =',m_Ndim
         STOP
      ENDIF
      END                       ! FoamC_Determinant


      SUBROUTINE FoamC_Divide(iCell,funW,RC)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Divide cell iCell into two daughter cells                                      //
*//   The iCell is retained and taged as inactive, daughter cells are appended       //
*//   at the end of the buffer.                                                      //
*//   New vertex is added to list of vertice.                                        //
*//   List of active cells is updated, iCell remooved, two daughters added           //
*//   and their properties set with help of MC sampling (FoamC_Explore)              //
*//   Return Code RC=-1 of buffer limit is reached,  m_LastCe=m_nBuf                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            iCell,RC
      INTEGER            Dau1, Dau2, kVer1(m_NdiMax+1), kVer2(m_NdiMax+1),p1,p2
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            Old1,Old2,j,k,jv,iv,kBest,nPairs
      DOUBLE PRECISION   Xave
*--------------------------------------------------------------------------------------
      RC = 0
      IF( m_LastCe+2 .GT. m_nBuf) GOTO 990 !! abort if no space in buffer
* reset cell as inactive
      m_CeStat(iCell) = 0
*------------------------------------------------------------------------------------
* add new vertex to the list
      m_LastVe=m_LastVe+1
      IF(m_LastVe.GT.m_vMax) GOTO 980
      Xave  = m_CeXave(iCell)
      kBest = m_CeBest(iCell)
      nPairs=0
      DO jv=1,m_Ndim+1
         DO iv=jv+1,m_Ndim+1
            nPairs=nPairs+1
            IF( nPairs.EQ.kBest) THEN
               p1 =  m_CeVert(iCell,jv)
               p2 =  m_CeVert(iCell,iv)
               DO j=1,m_Ndim
                  m_VerX(m_LastVe,j) = Xave*m_VerX(p1,j) + (1d0-Xave)*m_VerX(p2,j)
               ENDDO
               Old1=jv
               Old2=iv
               GOTO 100
            ENDIF
         ENDDO
      ENDDO
 100  CONTINUE
c[[[[[
c      WRITE(*,'(a,6f12.6)') 'FoamC_Divide: new vertex =',(m_VerX(m_LastVe,k), k=1,m_Ndim)
c]]]]]
*------------------------------------------------------------------------------------
* define lists of vertices for daughters, one old vertex replaced by new one
      DO jv=1,m_Ndim+1
         kVer1(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old1) kVer1(jv)=m_LastVe
         kVer2(jv) = m_CeVert(iCell,jv)
         IF(jv.EQ.Old2) kVer2(jv)=m_LastVe
      ENDDO
* define two daughter cells (active)
*   ----------------------- Stat, Pare, Dau1,Dau2,  Vertex,  iCeNew)
      CALL FoamC_DefCell(      1, iCell,  -1,  -1,   kVer1,  Dau1)
      CALL FoamC_DefCell(      1, iCell,  -1,  -1,   kVer2,  Dau2)
      m_CeDau1(iCell) = Dau1
      m_CeDau2(iCell) = Dau2
      CALL FoamC_Explore(Dau1,funW)
      CALL FoamC_Explore(Dau2,funW)
* Update list of active cells, only for internal tests
      CALL FoamC_ActUpda
      RETURN
 990  RC=-1                     !!buffer limit is reached,  m_LastCe=m_nBuf
      RETURN
 980  WRITE(*,*) ' ### STOP in FoamC_Divide: too short list of vertices '
      STOP
      END                       ! FoamC_Divide


      SUBROUTINE FoamC_Explore(iCell,funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Explore newly defined cell with help of special short MC sampling              //
*//   As a result, estimetes of true and crude volume will be defined                //
*//   Average and dispersion of the weight distribution will be found along each     //
*//   edge and the best edge (minimum dispersion) is memorized for future use.       //
*//   Axerage x for eventual future cell division is also defined.                   //
*//   Recorded are aso minimum and maximu weight etc.                                //
*//   The volume estimate in all (inactive) parent cells is updated                  //
*//   Note that links to parents and initial volume = 1/2 parent has to be           //
*//   already defined prior to calling this routine.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            i,j,k,parent,iCell,iv,jv,nPairs,pBest,kBest
      DOUBLE PRECISION   x,x1,x2,Dx,Dxx,Wt,Vsum,SumWt,Sum
      DOUBLE PRECISION   Xave,Xdisp,DispMin
      DOUBLE PRECISION   Beta(m_NpairMax),BetaMax
      DOUBLE PRECISION   VolOld, CruOld, XrSum,Factorial
      DOUBLE PRECISION   Vec(m_NdiMax+1,m_NdiMax), Xre(m_NdiMax,m_NdiMax), Yre(m_NdiMax,m_NdiMax)
      DOUBLE PRECISION   Vrand(m_NdiMax)
      DOUBLE PRECISION   Lambda(m_NdiMax),VolPart(m_NdiMax+1)
      DOUBLE PRECISION   Xdivi(m_NpairMax),Xsu1(m_NpairMax),Xsu2(m_NpairMax)
      INTEGER            nBin,iBin
      PARAMETER          (nBin=25)
      DOUBLE PRECISION   Histo(m_NpairMax,nBin),Bins(nBin)
      DOUBLE PRECISION   funW
      EXTERNAL           funW
*-----------------------------------------------------------------------
      Factorial=1
      DO i=1,m_Ndim
         Factorial=Factorial*i
      ENDDO
* memorize old values, will be needed for correcting parent cells
      VolOld = m_CeIntg(iCell)
      CruOld = m_CeCrud(iCell)
* Estimate volume and find out average value of x
* decode vertex vectors
      DO iv=1,m_Ndim+1
         DO j=1,m_Ndim
            Vec(iv,j) = m_VerX( m_CeVert(iCell,iv) ,j)
         ENDDO
      ENDDO
* relative last vertex
      DO iv=1,m_Ndim
         DO j=1,m_Ndim
            Xre(iv,j) = Vec(iv,j)-Vec(m_Ndim+1,j)
         ENDDO
      ENDDO
      CALL FoamC_Determinant(Xre,Dx)
      Dx = ABS(Dx)/Factorial    ! Cartesian volume of the Cell
      m_CeVolu(iCell)  = Dx
c[[[[[
c      DO iv=1,m_Ndim
c          WRITE(*,'(a,9f10.5)') '### Xre=',(Xre(iv,j),j=1,m_Ndim)
c      ENDDO
c      WRITE(*,'(a,f12.6)') 'FoamC_Explore: Cartesian volume Dx =',Dx
c]]]]]
*/////////////////////////////////////////////////////
*//    Special Short MC sampling to probe cell      //
*/////////////////////////////////////////////////////
      m_CeSum(iCell,1) =  0
      m_CeSum(iCell,2) =  0
      m_CeSum(iCell,3) =  0
      m_CeSum(iCell,4) =  1d90  ! wtmin
      m_CeSum(iCell,5) = -1d90  ! wtmax
      DO k=1,m_NpairMax
         Xsu1(k)=0d0
         Xsu2(k)=0d0
         Beta(k)=0d0
         DO iBin=1,nBin
            Histo(k,iBin)=0d0
         ENDDO
      ENDDO
* here we do additional scan over vertices in order to improve max/min weights
      IF( m_OptEdge .EQ. 1 ) THEN
         DO iv=1,m_Ndim+1
            DO j=1,m_Ndim
               Vrand(j) = m_VerX( m_CeVert(iCell,iv) ,j)
            ENDDO
            Wt =funW(Vrand)*Dx  ! weight average normalised to integral over the cell
            m_nCalls = m_nCalls+1
            m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
            m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
         ENDDO
      ENDIF
*/////////////////////////////////////////////////////
      DO i=1,m_nSampl
*     generate randomly/uniformly vector Vrand inside this simplex
         CALL FoamC_MakeLambda(Lambda)
         DO j=1,m_Ndim
            Vrand(j) = Vec(m_Ndim+1,j)
            DO iv=1,m_Ndim
               Vrand(j) = Vrand(j) +Lambda(iv)*Xre(iv,j)
            ENDDO
         ENDDO
****     WRITE(*,'(a,6f12.6)') ' Lambda    =',(Lambda(k),k=1,m_Ndim)
****     WRITE(*,'(a,6f12.6)') ' Vrand     =',(Vrand(k), k=1,m_Ndim)
*---------------------------------------------------------------------------------
* calculate partial volumes, raw material for planning future divion of the cell
* vertex jv will be replaced with the random vertex
         Vsum=0d0
         DO jv=1,m_Ndim+1
* all vertices relative to random vector, jv is omitted
            k=0
            DO iv=1,m_Ndim+1
               IF(iv.NE.jv) THEN
                  k=k+1
                  DO j=1,m_Ndim
                     Yre(k,j) = Vec(iv,j)-Vrand(j)
                  ENDDO
               ENDIF
            ENDDO
            CALL FoamC_Determinant(Yre,Dxx)
            VolPart(jv) = ABS(Dxx)/Factorial
            Vsum=Vsum + VolPart(jv)
         ENDDO
         IF( ABS(Vsum-DX) .GT. 1d-6) GOTO 950
*------------------------------------------------------------------------------------
         nPairs=0
         DO jv=1,m_Ndim+1
            DO iv=jv+1,m_Ndim+1
               nPairs=nPairs+1
               Xdivi(nPairs) = VolPart(jv)/(VolPart(jv)+VolPart(iv))
            ENDDO
         ENDDO
*------------------------------------------------------------------------------------
         Wt =funW(Vrand)*Dx        ! weight average normalised to integral over the cell
         m_nCalls = m_nCalls+1
         m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt         ! sum of weights
         m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt      ! sum of weights squared
         m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0        ! sum of 1
         m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt)    ! minium weight
         m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt)    ! maximu weight
* Search for the best edge candidate for future cell division, prepare MC material
         DO k=1,nPairs
            Xsu1(k)=Xsu1(k) +Xdivi(k)*Wt                 ! averages for all Xdivi
            Xsu2(k)=Xsu2(k) +Xdivi(k)**2*Wt
            iBin = INT(Xdivi(k)*nBin)+1d0
            iBin = MIN(MAX(iBin,0),nBin)
            Histo(k,iBin) = Histo(k,iBin)+Wt             ! fill histo for each edge
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.9) THEN
c               CALL GLK_Fil1(1200+k, Xdivi(k),Wt)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ENDDO
      ENDDO
*///////////////////////////////////////////////////////
*//   End of Special Short MC sampling to probe cell  //
*///////////////////////////////////////////////////////
*
* Determine the best edge candidate for future cell division, using MC  material
      pBest =0
      kBest =0
      DispMin =  1d150
      BetaMax = -1d150
      DO k=1,nPairs
         SumWt  = m_CeSum(iCell,1)
         IF( SumWt .NE. 0d0) THEN
            Beta(k) = 0d0
            Xave  = Xsu1(k)/SumWt             ! average lambda
            Xdisp = Xsu2(k)/SumWt  -Xave**2   ! dispersion of lambda
            Sum =0d0
            DO iBin=1,nBin
               Sum = Sum + Histo(k,iBin)/SumWt
               Beta(k) = Beta(k) +ABS((Sum*nBin-iBin)/nBin)
               Bins(iBin) = Sum               ! cumulative (for tests)
            ENDDO
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.20) THEN
c               CALL GLK_Pak(  1200+k,Bins)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ELSE
            Beta(k) = 1d0
            Xave  = 0.5d0
            Xdisp = 0.5d0
         ENDIF
c         IF( Xdisp.LT.0d0 ) THEN
c            WRITE(*,*) ' FoamC_Explore: Dispersion negative Xdisp,Xave=',Xdisp,Xave !
c         ENDIF
         IF( (Xave.LT.0d0) .OR. (Xave.GT.1d0) ) THEN
            WRITE(*,*) ' FoamC_Explore: Xave out of range   Xdisp,Xave=',Xdisp,Xave !
         ENDIF
         Xsu1(k) = Xave
         Xsu2(k) = SQRT(ABS(Xdisp))
         IF(Xsu2(k).LT.DispMin) THEN
            pBest=k
            DispMin = Xsu2(k)
         ENDIF
         IF(Beta(k).GT.BetaMax) THEN
            kBest=k
            BetaMax = Beta(k)
         ENDIF
      ENDDO
      IF(pBest .EQ. 0) GOTO 960
      IF(kBest .EQ. 0) GOTO 960
*
* Some test variants, do nothing for default m_OptBeta=0
      IF(     m_OptBeta .EQ. 1) THEN
         kBest = pBest                 ! pBest based on dispersion is generally less effective
      ELSEIF( m_OptBeta .EQ. 2) THEN
         CALL  FoamC_RanDiscr(Beta, nPairs, m_BetaPower, kBest) ! sometimes profitable
      ENDIF
***** WRITE(*,'(a,6f12.6)') ' Xdivi average   =',(Xsu1(k), k=1,nPairs)
***** WRITE(*,'(a,6f12.6)') ' Xdivi dispersion=',(Xsu2(k), k=1,nPairs)
***** WRITE(*,*) 'pBest, DispMin =',pBest, DispMin
*[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
c      WRITE(*,'(a,5I5)') '=======>>>>> FoamC_Explore: iCell,kBest,pBest = ',iCell,kBest,pBest
c      k=0
c      DO jv=1,m_Ndim+1
c         DO iv=jv+1,m_Ndim+1
c            k=k+1
c            WRITE(*,'(a,3I5,4f12.6)') 'k,jv,iv,Xave,Xdisp,Beta= ',
c     $           k,m_CeVert(iCell,iv),m_CeVert(iCell,jv),Xsu1(k),Xsu2(k),Beta(k) !
c         ENDDO
c      ENDDO
*]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

      IF( m_CeSum(iCell,1) .LT.0d0) GOTO 920
      m_CeXave(iCell)  = Xsu1(kBest)
      m_CeBest(iCell)  = kBest
      m_CeIntg(iCell)  = m_CeSum(iCell,1)/m_nSampl        ! estimator of the true integral
*     !!!!!!!!!  CRUDE volume for MC generation purpose !!!!!!!!!!
      IF(     m_OptCrude.EQ.0 ) THEN
         m_CeCrud(iCell)  =  m_CeIntg(iCell)                   ! true integral
      ELSEIF( m_OptCrude.EQ.1 ) THEN
         m_CeCrud(iCell)  =  DSQRT(m_CeSum(iCell,2)/m_nSampl)  ! Sqrt( <w>**2 + sigma**2 )
      ELSEIF( m_OptCrude.EQ.2 ) THEN
         m_CeCrud(iCell)  =  m_CeSum(iCell,5)                  ! wtmax
      ELSE
         WRITE(m_out,*) ' ++++ STOP in FoamC_Explore, wrong m_OptCrude =',m_OptCrude
         WRITE(    *,*) ' ++++ STOP in FoamC_Explore, wrong m_OptCrude =',m_OptCrude
         STOP
      ENDIF
* correct volume and crude in all parent cells to the top of the tree
      parent = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         m_CeIntg(parent)  = m_CeIntg(parent)  +( m_CeIntg(iCell)  -VolOld)
         m_CeCrud(parent)  = m_CeCrud(parent)  +( m_CeCrud(iCell)  -CruOld)
         parent=m_CePare(parent)
      ENDDO
 100  CONTINUE
      RETURN
 920  WRITE(*,*) ' ### STOP in FoamC_Explore: something wrong with integrand '
      STOP
 950  WRITE(*,*) ' ### STOP in FoamC_Explore: something wrong with volume calculation '
      STOP
 960  WRITE(*,*) ' ### STOP in FoamC_Explore: something wrong with best pair pointer =',kBest
      STOP
      END                       ! FoamC_Explore



      SUBROUTINE FoamC_Finalize(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   After MC run is completed it calculates integral and its error         //
*//   Also prints some information/statistics on the MC run                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
*
      DOUBLE PRECISION     MCresult,MCerror,MCerelat
      DOUBLE PRECISION     Vtot,Verr,VerRela
*-----------------------------------------------------------------------------
      MCresult =0d0
      MCerelat =1d0
      IF(m_NevGen .GT. 0) MCresult = m_Crude *m_SumWt/m_NevGen
      IF(m_NevGen .GT. 0) MCerelat = SQRT( m_SumWt2/m_SumWt**2 -1d0/m_NevGen )
      MCerror = MCresult*MCerelat
* some test printouts
      WRITE(m_Out,'(3a)') '============================================================================='
      WRITE(m_Out,'(3a)') '==============================', ' FoamC_Finalize ',
     $                    '=============================='
      WRITE(m_Out,'(a,2g18.9,f11.7)')               'MCresult, MCerror, Errela= ',MCresult,MCerror,MCerelat
      WRITE(m_Out,'(a,2f11.5)')                     'Minimum maximum weight   = ',m_WtMin,m_WtMax
      IF(m_NevGen .GT. 0) WRITE(m_Out,'(a,2f11.5)') 'Average weight           = ',m_SumWt/m_NevGen
      WRITE(m_Out,'(a,i15)')                        'Total number of function calls =',m_nCalls
      WRITE(m_Out,'(a,i15)')                        'Number of vertices = ', m_LastVe
* Total integral from cell statistics, including initialization + MC generation
      CALL FoamC_GetIntegral(Vtot,Verr)
      VerRela = Verr/Vtot
      WRITE(m_Out,'(3a)') '-----------------------------------------------------------------------------'
      WRITE(m_Out,'(3a)') 'Still better final results using information accumulated in initialization'
      WRITE(m_Out,'(a,2g18.9,f11.7)')                'Vtot, Verr, Errela       = ',  Vtot,Verr, VerRela
      WRITE(m_Out,'(3a)') '============================================================================='
      END       ! FoamC_Finalize


      SUBROUTINE FoamC_GetCrude(Crude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION     Crude
      Crude = m_Crude
      END


      SUBROUTINE FoamC_GetIntegral(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION     MCresult,MCerror
      DOUBLE PRECISION     Vtot,Verr,Nent,AveWt,Sig2
      INTEGER              iCell
*
      Vtot =0d0
      Verr =0d0
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            Nent  = m_CeSum(iCell,3)
            AveWt = m_CeSum(iCell,1)/Nent
            Sig2  = m_CeSum(iCell,2)/Nent - AveWt**2
            Vtot = Vtot +AveWt
            Verr = Verr +Sig2/Nent
         ENDIF
      ENDDO
      Verr = SQRT(Verr)
      MCresult = Vtot
      MCerror  = Verr
      END


      SUBROUTINE FoamC_GetMCvector(MCvector)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_Ndim
         MCvector(k)    = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE FoamC_GetMCwt(MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE FoamC_GetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      Ndim
*     -------------------------------------------------
      Ndim = m_Ndim
      END                       !!! FoamC_SetNdim


      SUBROUTINE FoamC_Grow(funW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Grow new cells by division                                                     //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,RC,iCell
*---------------------------------------------
* Final division
      DO i=1,100000
         IF(  m_OptPeek .EQ. 0 ) THEN
            CALL FoamC_PeekMax(iCell)         ! peek up cell with maximum crude
         ELSE
            CALL FoamC_Peek(   iCell)         ! peek up randomly one cell
         ENDIF
         CALL FoamC_Divide( iCell,funW,RC)    ! and divide it into two
c[[[[
c         CALL FoamC_BufPrint(    m_Out)
c         CALL FoamC_VertPrint(  6)
c]]]]
         IF(RC.EQ.-1) GOTO 300
      ENDDO
 300  CONTINUE
      CALL FoamC_Check(6,0)
      END                       ! FoamC_Grow

      SUBROUTINE FoamC_InitCells    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first n-factorial cells inside original cube                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER       k1,k2,k3,k4,k5
      INTEGER       perm(m_NdiMax),mask
      INTEGER       iCe,i,j,k,iVe,Vert(m_NdiMax),digit(m_NdiMax),factorial
*     -----------------------------------------------------------------------------
      factorial=1
      DO k = 1,m_Ndim
         factorial = factorial*k
      ENDDO
      DO iVe=1,m_Ndim+1
         Vert(iVe) =0
      ENDDO
*     -------------------- Stat,Pare, Dau1,        Dau2, VertexList, iCeNew)
      CALL FoamC_DefCell(    -1,  -1,    2, factorial+1,       Vert,      k) ! Master cell Inactive
    
      iCe=0
* The most primitive loop over permutations in the world!
      DO k5 = m_Ndim,1,-1
         DO k4 = m_Ndim,1,-1
            DO k3 = m_Ndim,1,-1
               DO k2 = m_Ndim,1,-1
                  DO k1 = m_Ndim,1,-1
                     perm(1)=k1
                     perm(2)=k2
                     perm(3)=k3
                     perm(4)=k4
                     perm(5)=k5
                     Mask=1
                     DO i=1,m_Ndim
                        DO j=i+1,m_Ndim
                           IF( perm(i).EQ.perm(j) ) Mask=0
                        ENDDO
                     ENDDO
                     IF(Mask.EQ.1) THEN
                        iCe=iCe+1
*                       WRITE(*,*) '########>>>>>>> iCe=',iCe, 'permut= ',(perm(i),i=1,m_Ndim)
                        DO iVe=1,m_Ndim+1
*                          digit represtents just one basic simplex,
*                          the actual one is obtained by permuting dimensions
                           DO k=1,m_Ndim
                              digit(k)=0
                              IF(k.LT.iVe) digit(k)=1
                           ENDDO
*                          translation from "binary" digit to serial pointer of a given vertex
                           j=0
                           DO k=1,m_Ndim
                              j=j+  digit(perm(k)) *2**(k-1)
                           ENDDO
                           Vert(iVe)=j+1
                        ENDDO
*                       WRITE(*,*) '###>>>> Vert= ',(vert(i),i=1,m_Ndim+1)
*                       ----------------- Stat,Pare,Dau1,Dau2,Vertex,iCeNew)
                        CALL FoamC_DefCell(  1,   1,  -1,  -1,  Vert,     k) ! active
                        IF( iCe.EQ.factorial) GOTO 100
                     ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !!!FoamC_InitCells

      SUBROUTINE FoamC_Initialize(FunW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Basic initialization, create "foam of cells"                                   //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iter,i,j,k,iCell
*---------------------------------------------
*
      CALL FoamC_PreInitialize
*
      IF( m_nBuf .GT. m_nBufMax) THEN
         WRITE(*,    *) ' ### STOP in FoamC_Initialize, to big m_nBuf =',m_nBuf
         WRITE(m_Out,*) ' ### STOP in FoamC_Initialize, to big m_nBuf =',m_nBuf
         STOP
      ENDIF

* Initialize list of vertices
      DO i=1,m_vMax
         DO j=1,m_Ndim
            m_VerX(i,j) = 0d0     ! vertices
         ENDDO
      ENDDO

* First  cells are the n-factorial simplexes from division of the basic unit cube
      m_LastCe = 0
      CALL FoamC_InitVertices
      CALL FoamC_InitCells
***************************************************************************************************
* Obsolete old method
*      IF(    m_Ndim .EQ. 2) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamC_DefNewCell( -1,  -1,   2,   3,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 4, 2, 0,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 4, 3, 0,     k) ! active
*      ELSEIF(m_Ndim .EQ. 3) THEN
**        -------------------- Stat,Pare,Dau1,Dau2,Ver1,Ver2,Ver3,Ver4,iCeNew)
*         CALL FoamC_DefNewCell( -1,  -1,   2,   7,   0, 0, 0, 0,     k) ! Master cell Inactive
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 2, 4, 8,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 3, 4, 8,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 2, 6, 8,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 3, 7, 8,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 5, 6, 8,     k) ! active
*         CALL FoamC_DefNewCell(  1,   1,  -1,  -1,   1, 5, 7, 8,     k) ! active
*      ENDIF
***************************************************************************************************
      DO iCell = 2,m_LastCe
         CALL FoamC_Explore(iCell,funW) ! Initial MC sampling
      ENDDO
***** CALL FoamC_VertPrint(6)
***** CALL FoamC_BufPrint(    m_Out)

* Life sets on: series of grows and collapss leads to an effective 
* coverage of the integration area with the the cell-foam
      DO iter=1,m_Iterat
         CALL  FoamC_Grow(funW)
*        ------------------------
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamC_BufPrint(    m_Out)
            CALL FoamC_BufActPrint( m_Out)
            CALL FoamC_VertPrint(   m_Out)
         ENDIF
* Kill unsuccesfull cells to make room for another growth
         CALL FoamC_Collapse   ! Collaps
         IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize<<COLLAPSE Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
         ENDIF
         IF( m_Chat.EQ.2) THEN
            CALL FoamC_BufPrint(    m_Out)
            CALL FoamC_BufActPrint( m_Out)
            CALL FoamC_VertPrint(   m_Out)
         ENDIF
      ENDDO
* Final growth
      CALL  FoamC_Grow(funW)
*     -----------------------
      IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 4(a,i4), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Iter=',iter,' Cells:',m_LastCe,' Active:',m_LastAc, ' Vertices:' ,m_LastVe,
     $           ' Integral:',m_CeIntg(1),' Crude:',m_CeCrud(1)
      ENDIF
      IF( m_Chat.EQ.2) THEN
         CALL FoamC_BufPrint(    m_Out)
         CALL FoamC_BufActPrint( m_Out)
         CALL FoamC_VertPrint(   m_Out)
      ENDIF
* Initializations for M.C. generation
      m_Crude  = m_CeCrud(1)  ! M.C. generation Crude value of integral
      m_SumWt  = 0d0          ! M.C. generation sum of Wt
      m_SumWt2 = 0d0          ! M.C. generation sum of Wt**2
      m_NevGen  = 0d0         ! M.C. generation sum of 1d0
      m_WtMax  = -1d99        ! M.C. generation maximum wt
      m_WtMin  =  1d99        ! M.C. generation minimum wt
      m_VolTot = m_CeIntg(1)  ! Estimate of integral tot. without error
      m_MCresult = m_VolTot   ! M.C. generation Final value of ITEGRAL, temporary asignment
      m_MCerror  = m_VolTot   ! M.C. generation Final walue of ERROR  , temporary asignment
*
      END                       ! FoamC_Initialize

      SUBROUTINE FoamC_InitVertices    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initiallize first 2^n vertices at corners of basic cube                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER       iVe,k1,k2,k3,k4,k5
*     
      m_LastVe = 2**m_Ndim
      iVe=0
      DO k5 = 0,1
         DO k4 = 0,1
            DO k3 = 0,1
               DO k2 = 0,1
                  DO k1 = 0,1
                     iVe=iVe+1
                     m_VerX(iVe,1) = k1
                     m_VerX(iVe,2) = k2
                     m_VerX(iVe,3) = k3
                     m_VerX(iVe,4) = k4
                     m_VerX(iVe,5) = k5
                     IF( iVe .EQ. m_LastVe ) GOTO 100
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
 100  CONTINUE
      END                       !! FoamC_InitVertices



      SUBROUTINE FoamC_MakeEvent(funW)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates point/vector Xrand with the weight MCwt                              //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCell,i,j,iv
      DOUBLE PRECISION   Wt,x1,x2,Dx,MCwt
      DOUBLE PRECISION   Lambda(m_NdiMax)
*     -----------------------------------------------------------------
*     choose randomly one cell
      CALL  FoamC_Peek(iCell)
*     generate randomly/uniformly vector Vrand inside this simplex
      CALL FoamC_MakeLambda(Lambda)
      DO j=1,m_Ndim
         m_MCvector(j) = m_VerX( m_CeVert(iCell,m_Ndim+1) ,j)
         DO iv=1,m_Ndim
            m_MCvector(j) = m_MCvector(j) 
     $           +Lambda(iv)*( m_VerX( m_CeVert(iCell,iv) ,j) -m_VerX( m_CeVert(iCell,m_Ndim+1) ,j) )
         ENDDO
      ENDDO
      Dx = m_CeVolu(iCell)      ! Cartesian volume of the Cell
* weight average normalised to Crude integral over the cell
      MCwt =funW(m_MCvector)*Dx/m_CeCrud(iCell)
      m_nCalls =  m_nCalls+1
      m_MCwt   =  MCwt
* accumulation of statistics for the main MC weight
      m_SumWt  =  m_SumWt+MCwt           ! sum of Wt
      m_SumWt2 =  m_SumWt+MCWt*Mcwt      ! sum of Wt**2
      m_NevGen =  m_NevGen+1d0           ! sum of 1d0
      m_WtMax  =  MAX(m_WtMax,MCwt)      ! maximum wt
      m_WtMin  =  MIN(m_WtMin,MCwt)      ! minimum wt
* update also weight sums in the cell,
* note weights here are normalized absolutely, eg. to the value of the integral
      Wt = MCwt*m_CeCrud(iCell)
      m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt      ! sum of weights
      m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt   ! sum of weights squared
      m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0     ! sum of 1
      m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
      m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
      END                       ! FoamC_MakeEvent


      SUBROUTINE FoamC_MakeLambda(Lambda)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Lambda such that Sum Lamba(i) < 1, with uniform probab.     //
*//   This  vector is used to populate uniformly the interior of a simplex.              //
*//   The method is: generate point inside cube, order components (maping into simplex)  //
*//   and take differences of Lambda(i+1) - Lambda(i)                                    //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            i,k
      DOUBLE PRECISION   Lambda(m_NdiMax), y
      REAL               Qrand( m_NdiMax)        ! from PseuMar
      REAL               x
*     --------------------------------------------------------
      CALL PseuMar_MakeVec(Qrand,m_Ndim)
* order components (maping into simplex)
      DO i =m_Ndim,1,-1
         DO k =2,i
            IF( Qrand(k).LT.Qrand(k-1)) THEN
               x            = Qrand(k)
               Qrand(k)    = Qrand(k-1)
               Qrand(k-1)  = x
            ENDIF
         ENDDO
      ENDDO
      Lambda(1)=Qrand(1)
      DO k =2,m_Ndim
         Lambda(k)=Qrand(k)-Qrand(k-1)
      ENDDO
      END                       ! MakeLambda

      SUBROUTINE FoamC_MCgenerate(funW,MCvector,MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Obsolete                                                                       //
*//   Generates point/vector MCvector with the weight MCwt                           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   MCvector(*),MCwt
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            j
*     ---------------------------------------------------------------
      CALL FoamC_MakeEvent(funW)
      MCwt = m_MCwt
      DO j=1,m_Ndim
         MCvector(j) =m_MCvector(j)
      ENDDO
      END                       !!FoamC_MCgenerate


      SUBROUTINE FoamC_Peek(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly pointer iCell of an active cell                           //
*//                                                                                  //
*// We walk randomly from top of tree downwards until we find active cell m_CeStat=1 //
*// At each step one of daugters cells is choosen randomly according                 //
*// to their volume estimates.                                                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,p1,volu1,volu2,volu,TotCru,sum
      REAL               Qrand(10)        ! from PseuMar
*     ----------------------------------------------------------------
* first cell is special because it has Ndim-factorial daughters, istead of just 2
      kCell = 1
      Dau1  = m_CeDau1(kCell)
      Dau2  = m_CeDau2(kCell)
      TotCru   = 0d0
      DO iCell= Dau1,Dau2
         TotCru = TotCru+m_CeCrud( iCell )
      ENDDO
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iDau  = -1
      sum   = 0d0
      DO iCell= Dau1,Dau2
         iDau  = iCell
         sum = sum+m_CeCrud( iCell )
         IF( random .LT. sum/TotCru ) GOTO 100
      ENDDO
      IF(iDau.EQ.-1) GOTO 990
 100  kCell=iDau
c[[[[
cc      WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamC_Peek: top daughter =',kCell
c]]]]
      IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
* now the other standard cells with 2 daughters
      DO i=1,10000000
         IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
         volu1= m_CeCrud( m_CeDau1(kCell) )
         volu2= m_CeCrud( m_CeDau2(kCell) )
         p1 = volu1/(volu1+volu2)
         CALL PseuMar_MakeVec(Qrand,1)
         random = Qrand(1)
         IF( random .LT. p1 ) THEN
            kCell = m_CeDau1(kCell)
         ELSE
            kCell = m_CeDau2(kCell)
         ENDIF
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamC_Peek: normal daughter =',kCell
c]]]
      ENDDO
      GOTO 990
 300  CONTINUE
      iCell=kCell
c[[[[
cc         WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamC_Peek: choosen cell =',kCell
c]]]
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamC_Peek, something went wrong !!!!'
      STOP
      END                       !!! FoamC_Peek

      SUBROUTINE FoamC_PeekMax(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER   iCell
      INTEGER   i
      DOUBLE PRECISION  CrudMax, Crud
*     ---------------------------------------------------
      iCell = 0
      CrudMax = -1d150
      DO i = 1,m_LastCe
         IF( m_CeStat(i).EQ.1 ) THEN
            Crud=  ABS(m_CeCrud(i))
            IF(Crud .GT. CrudMax) THEN
               CrudMax = Crud
               iCell = i
            ENDIF
         ENDIF
      ENDDO
****  WRITE(*,*) '###>>> FoamC_PeekMax: iCell=',iCell
      IF(iCell.EQ.0) THEN
         WRITE(*,*) '### STOP in FoamC_PeekMax: not found iCell=', iCell
         STOP
      ENDIF
      END                       ! FoamC_PeekMax



      SUBROUTINE FoamC_PltBegin     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Initialization, write header of TeX file                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER id,kax,kay
*---------------------------------------------------
      DOUBLE PRECISION    dxl,dxu,xl,xu,yl,yu
      CHARACTER*8  chxfmt,chyfmt
      INTEGER      icont
      DATA         icont /0/
*---------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      icont=icont+1
*
      IF(icont .GE. 1) THEN
         chxfmt =  'f8.4'
         chyfmt =  'f8.4'
         m_ltx  = 11
         OPEN(m_ltx, FILE='map.tex')
         WRITE(m_ltx,'(2A)') '\\newpage'
      ENDIF
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') '\\documentclass[12pt]{article}'
      WRITE(m_ltx,'(A)') '\\usepackage{color}' !<-for colors!!!
      WRITE(m_ltx,'(A)') '\\usepackage{epic}'  !<-for extended ploting
      WRITE(m_ltx,'(A)') '\\textwidth  = 16cm'
      WRITE(m_ltx,'(A)') '\\textheight = 18cm'
      WRITE(m_ltx,'(A)') '\\pagestyle{empty}'
      WRITE(m_ltx,'(A)') '\\begin{document}'
      WRITE(m_ltx,'(A)') '  '
*------------------------------!
      WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'!
      WRITE(m_ltx,'(A)') '\\begin{figure}[!ht]'
      WRITE(m_ltx,'(A)') '\\centering'
*------------------------------!
* Frames and labels
*------------------------------!
      WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
      WRITE(m_ltx,'(A)') '\\setlength{\\unitlength}{0.1mm}'
      WRITE(m_ltx,'(A)') '\\begin{picture}(1600,1600)'
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox(1600,1600){ }}'

      END


      SUBROUTINE FoamC_PltCell(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all cells                                                                 //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            iCell,mout,active,j
      INTEGER            iV1,iV2,iV3
      INTEGER            kx1,ky1,kx2,ky2,kx3,ky3,kx,ky
*     ----------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Crude   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,2f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell),
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeCrud(iCell),                          ! Crude 
     $        (m_CeVert(iCell,j), j=1,m_Ndim+1)         ! vertices
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
c[[[
c      WRITE(m_ltx,'(A)') '\\put(80,80){\\color{blue}\\dashbox{7}( 1440,1440){ }}' ! 5% edge band
c]]]
      DO iCell = 2, m_LastCe
         iV1=m_CeVert(iCell,1)
         iV2=m_CeVert(iCell,2)
         iV3=m_CeVert(iCell,3)
         kx1 = m_VerX(iV1,1)*1600
         ky1 = m_VerX(iV1,2)*1600
         kx2 = m_VerX(iV2,1)*1600
         ky2 = m_VerX(iV2,2)*1600
         kx3 = m_VerX(iV3,1)*1600
         ky3 = m_VerX(iV3,2)*1600
         kx= (kx1+kx2+kx3)/3
         ky= (ky1+ky2+ky3)/3
         IF(m_CeStat(iCell).EQ.1) THEN
***         WRITE(*,*) iCell,iV1,iV2,iV3
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx1,',',ky1,')(',kx2,',',ky2,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx2,',',ky2,')(',kx3,',',ky3,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx3,',',ky3,')(',kx1,',',ky1,')' !
            WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $           '\\put(',kx,',',ky,'){\\makebox(0,0)[b]{\\hbox{\\small\\color{magenta} ',iCell,' }}}' !
         ENDIF
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! FoamC_BufPrint

      SUBROUTINE FoamC_PltEnd     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Close Tex file with plot                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
*
      IF(m_nDim.NE.2) RETURN
      WRITE(m_ltx,'(A)') '\\end{picture}'
      WRITE(m_ltx,'(A)') '\\end{figure}'
      WRITE(m_ltx,'(A)') '\\end{document}'
      CLOSE(m_ltx)
      END

      SUBROUTINE FoamC_PltVert(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all vertices                                                              //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*------------------------------------------------------------------------------
*     Mark plots for plots
      CHARACTER*62 star,diamond,circle,ring,times,disc,plus,box,dot
      PARAMETER (diamond ='\\makebox(0,0){\\Large $\\diamond$}')
      PARAMETER (star    ='\\makebox(0,0){\\Large\\color{red} $\\star$}')
      PARAMETER (circle  ='\\circle{30}')
      PARAMETER (ring    ='\\circle{20}')
      PARAMETER (times   ='\\makebox(0,0){\\Large $\\times$}')
      PARAMETER (disc    ='\\circle*{20}')
      PARAMETER (plus    ='\\makebox(0,0){\\Large $+$}')
      PARAMETER (box     ='\\makebox(0,0){\\Large $\\Box$}') !!! does not work???
      PARAMETER (dot     ='\\circle*{10}')
*------------------------------------------------------------------------------
      CHARACTER*62  chmark
      INTEGER       kx,ky
*---------------------------------------------------------------------------------------------
      IF(m_nDim.NE.2) RETURN
* Count references of vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1 !
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1 !
               ENDIF
            ENDDO
         ENDDO
      ENDDO
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
* Begin frame
      WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
      WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
      WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox( 1600,1600){ }}' !
* Plotting symbol
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VD}[2]{\\put(#1,#2){',disc,'}}'!
      WRITE(m_ltx,'(10A)') '\\newcommand{\\VS}[2]{\\put(#1,#2){',star,'}}'!
      WRITE(m_ltx,'(10A)') 
     $     '\\newcommand{\\VN}[3]{\\put(#1,#2){\\makebox(0,0)[b]{\\hbox{\\small\\color{red} #3}}}}' !
      DO iVe = 1, m_LastVe
         kx = m_VerX(iVe,1)*1600
         ky = m_VerX(iVe,2)*1600
cc         WRITE(*,*) NoRefs(iVe),NoRefsAc(iVe)
         IF( NoRefsAc(iVe).LE.2 ) THEN
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VD{',kx,'}{',ky,'}'
         ELSE
            WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VS{',kx,'}{',ky,'}'
         ENDIF            
         WRITE(   m_ltx,'(A,I5,A,I5,A,I5,A)') '\\VN{',kx-8,'}{',ky+12,'}{',iVe,'}' !
      ENDDO
* Close frame
      WRITE(m_ltx,'(A)') '\\end{picture}}'
      WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
*---------------------------------------------------------------------------------------------
*---------------------------------------------------------------------------------------------
      END                       !! VertPrint



*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//             Foam Version 1.01                                                         //
*//             August 1999                                                               //
*//                                                                                       //
*//  N-dimensional general purpose Monte Carlo sampler with self-adapting simplectic grid //
*//                                                                                       //
*//             Author:   Stanislaw JADACH                                                //
*//             Address:  INP Cracow                                                      //
*//             Email:    S.Jadach@cern.ch, S.Jadach@ifj.edu.pl                           //
*//             HomePage: http://home.cern.ch/~jadach/                                    //
*//                                                                                       //
*//  First version 1.00 written by S.J. in May 1999 during visit in DESY                  //
*///////////////////////////////////////////////////////////////////////////////////////////

*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//          Pseudoclass Foam                                                                          //
*//                                                                                                    //
*//                                                                                                    //
*//                      Initialization of the grid                                                    //
*//  FoamC_PreInitialize                 : Pre-initialization, set all default values (constructor?)   //
*//  FoamC_Initialize(FunW)              : Initialization of the grid etc.                             //
*//  FoamC_InitVertices                  : Initializes first vertices of the basic cube                //
*//  FoamC_InitCells                     : Initializes first n-factorial cells inside original cube    //
*//  FoamC_DefCell                       : Create new (daughter) cell and append at end of the buffer  //
*//  FoamC_Explore(iCell,funW)           : Short MC sampling in iCell, determine <wt>, wtMax etc.      //
*//  FoamC_RanDiscr(Crud,nTot,Power,iRand) : Random choice of cell division direction                  //
*//  FoamC_MakeLambda(Lambda)            : auxiliary procedure for FoamC_Explore                       //
*//  FoamC_Determinant(R,Det)            : determinant of matrix R                                     //
*//  FoamC_Det2Lapl(R,i1,i2)             : Laplace formula for 1-dim. determinant                      //
*//  FoamC_Det3Lapl(R,i1,i2,i3)          : Laplace formula for 2-dim. determinant                      //
*//  FoamC_Det4Lapl(R,i1,i2,i3,i4)       : Laplace formula for 3-dim. determinant                      //
*//  FoamC_Det5Lapl(R,i1,i2,i3,i4,i5)    : Laplace formula for 4-dim. determinant                      //
*//  FoamC_Grow(funW)              : grow cells until buffer is full                                   //
*//  FoamC_PeekMax(iCell)          : choose randomly one cell, used also in MC generation              //
*//  FoamC_Peek(iCell)             : Generates randomly one (active) cell pointer iCell                //
*//  FoamC_Divide(iCell,funW,RC)   :Divide iCell into two daughters; iCell retained, taged as inactive //
*//  FoamC_Collapse                :Finds and remooves unsuccesfull cells, some nonactive cells revived//
*//                     Generation                                                                     //
*//  FoamC_MakeEvent(Density)      : Generates point/vector Xrand with the weight MCwt                 //
*//  FoamC_GetMCvector(MCvector)   : Provides point/vector MCvector generated by  MakeEvent            //
*//  FoamC_GetMCwt(MCwt)           : Provides MCwt, MC weight calculated by MakeEvent                  //
*//  FoamC_MCgenerate(funW,X,MCwt) : Alternative entry, Generates point X with the weight MCwt         //
*//                     Finalization                                                                   //
*//  FoamC_Finalize(MCresult,MCerror)    : Calculates integral and its error after (only from) MC run  //
*//  FoamC_GetIntegral(MCresult,MCerror) : Integral estimate from Initialization + MC generation       //
*//                     Other Getters and Setters                                                      //
*//  FoamC_GetCrude(Crude)         :Provides Crude used in MC generation                               //
*//  FoamC_SetNdim(Ndim)           :Sets Ndim= no. of dimensions  (to be called before Initialize)     //
*//  FoamC_GetNdim(Ndim)           :Provides Ndim, miscelaneous, for tests                             //
*//  FoamC_SetnBuf(nBuf)           :Sets nBuf, working area in buffer                                  //
*//  FoamC_SetIterat(Iterat)       :Sets Iterat=no. of iterations (to be called before Initialize)     //
*//  FoamC_SetOut(Out)             :Sets output unit number                                            //
*//  FoamC_SetChat(Chat)           :Sets chat level; Chat=0,1,2 chat level in output, Chat=1 normal    //
*//  FoamC_SetnSampl(nSampl)       :Sets nSampl; No of MC sampling before dividing cell                //
*//  FoamC_SetOptCrude(OptCrude)   :Sets OptCrude; type of Crude =0,1,2 for True,Sigma,WtMax           //
*//  FoamC_SetOptBeta(OptBeta)     :Sets type of method in cell division                               //
*//  FoamC_SetOptPeek              :Sets type of method in cell division                               //
*//  FoamC_SetOptEdge(OptEdge)     :Sets OptEdge; decides whether vertices are included in the sampling//
*//  FoamC_SetKillFac(KillFac)     :Sets KillFac; kill factor for poor cells                           //
*//                    Debugging and miscelaneous                                                      //
*//  FoamC_Check(mout,level)       :Checks all pointers (after comression) debuging!                   //
*//  FoamC_ActUpda                 :Miscelaneous, Creates list of active cells (pointers)              //
*//  FoamC_BufPrint(mout)          :Prints all cells, debugging                                        //
*//  FoamC_BufActPrint(mout)       :Prints all active cells, debugging                                 //
*//  FoamC_VertPrint(mout)         :Prints all vertices,  debugging                                    //
*//  FoamC_PltBegin                :Ploting 2-dim. cells and vertices                                  //
*//  FoamC_PltVert(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamC_PltCell(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamC_PltEnd                  :Ploting 2-dim. cells and vertices                                  //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//  Input parameters:                                                                                 //
*//    nDim     number of dimensions in the problem, for the moment nDim=1-5 in this version,          //
*//             n>5 requires re-writing FoamC__Determinant,                                            //
*//             for n=1 alternatively Foam1A may be used, could be factor 2 faster!                    //
*//    nBuf     Actual dynamic lenth of the buffer m_nBuf<m_nBufMax. For strongly peaked distribution  //
*//             nBuf should be as large as possible, this will increase CPU time in initialization     //
*//             MC generation is weakly affected by increasing nBuf                                    //
*//    nSampl   No of sampling when dividing cell, nSampl=10-100 is OK, further increase improves      //
*//             costs CPU time and apparently does not increase grid efficiency too much.              //
*//             This should be checked however for every new distribution.                             //
*//    Iterat   No of iterations in consolidation, Iterat=0 is OK in may cases, but for very sharp     //
*//             peaks grid may expand in areas where there is litle of integrated propability.         //
*//             Additinal iteration Iterat>0 corrects for this.                                        //
*//    KillFac  kill factor for poor cells. Parameter for iteration. Default KillFac=1 seems to be OK  //
*//             For certain distribution it may be profitable to adjust it within 0.5<KillFac<2.0      //
*//    OptCrude Type of Crude =0,1,2 for TrueInt,Sigma,WtMax,  Crude=WtMax is the best if we aim       //
*//             at rejection leading to wt=1 events. If not then Crude=TrueInt iswiser choice leading  //
*//             to save of CPU time.                                                                   //
*//    OptEdge  decides whether vertices are included in the sampling. Default  OptEdge=1 causes that  //
*//             vertices at the edge of simplex cells are included always in MC exploration            //
*//             of the cell. In the case of density distrib. with weak integrable singularities        //
*//             at the edges it may be not possible and OptEdge=0 may help.                            //
*//    Out      Miscelaneous. Output unit number.                                                      //
*//    Chat     Miscelaneous. Chat=0,1,2 chat level in output, Chat=1 normal level.                    //
*//                                                                                                    //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//  Terminology:                                                                                      //
*//    "Active cells" are these which did not divide and are eligible for division                     //
*//  Remarks:                                                                                          //
*//    List of active cells is not realy necessary, but let us keep it for possible                    //
*//    future developements or tests.                                                                  //
*////////////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE FoamC_PreInitialize     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Presets certain defaults for switches and other and regualtory parameters.     //
*//   They Can be reset with setters                                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
*     -------------------------------------------------
      IF(m_Magic .EQ. 0 ) RETURN
      m_nBuf     = 500               ! Actual dynamic lenth of the buffer m_nBuf<m_nBufMax
      m_Iterat   = 10                ! No of iterations in consolidation
      m_KillFac  = 1d0               ! kill factor for poor cells
      m_Out      = 6                 ! Output unit
      m_Chat     = 1                 ! Chat=0,1,2 chat level in output, Chat=1 normal level
      m_nSampl   = 100               ! No of sampling when dividing cell
      m_OptCrude = 2                 ! type of Crude =0,1,2 for TrueVol,Sigma,WtMax
      m_OptPeek  = 0                 ! type of Peek =0,1 for maximum, random
      m_OptEdge  = 1                 ! decides whether vertices are included in the sampling
      m_nCalls   = 0                 ! No of function calls
      m_OptBeta  = 0                 ! type of choice of edge in the division of the cell, 0,1,2
      m_BetaPower=1d0                ! Power in case of m_OptBeta  = 2
      m_nDim     = 2                 ! dimension
*
      m_Magic = 0
      END


      SUBROUTINE FoamC_RanDiscr(Crud,nTot,Power,iRand)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates iRand in (1,nTot) acconding to discrete un-normalized probab. Crud   //
*//   Power is normaly =1, can be useful for special purposes                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION   Crud(*),Power
      INTEGER            nTot,iRand
      INTEGER            i
      DOUBLE PRECISION   random,sum,Total
      REAL               Qrand(10)        ! from PseuMar
*
      Total   = 0d0
      DO i= 1,nTot
         Total = Total +Crud( i)**Power
      ENDDO
      IF(Total .EQ. 0d0) GOTO 990
      CALL PseuMar_MakeVec(Qrand,1)
      random = Qrand(1)
      iRand  = -1
      sum   = 0d0
      DO i= 1,nTot
         iRand  = i
         sum = sum +Crud( i)**Power
         IF( random .LT. sum/Total ) GOTO 100
      ENDDO
      IF(iRand .EQ. -1) GOTO 990
 100  CONTINUE
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamC_RanDiscr, something went wrong !!!!'
      STOP
      END

      SUBROUTINE FoamC_SetChat(Chat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      Chat
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_Chat = Chat
      END                       !!! FoamC_SetChat

      SUBROUTINE FoamC_SetIterat(Iterat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      Iterat
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_Iterat = Iterat
      END                       !!! FoamC_SetIterat

      SUBROUTINE FoamC_SetKillFac(KillFac)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      DOUBLE PRECISION   KillFac
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_KillFac = KillFac
      END                       !!! FoamC_SetKillFac

      SUBROUTINE FoamC_SetnBuf(nBuf)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      nBuf
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_nBuf = nBuf
      END                       !!! FoamC_SetnBuf


      SUBROUTINE FoamC_SetNdim(Ndim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      Ndim
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_Ndim = Ndim
      END                       !!! FoamC_SetNdim

      SUBROUTINE FoamC_SetnSampl(nSampl)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      nSampl
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_nSampl = nSampl
      END                       !!! FoamC_SetnSampl

      SUBROUTINE FoamC_SetOptBeta(OptBeta)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      OptBeta
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_OptBeta = OptBeta
      END                       !!! FoamC_SetOptBeta

      SUBROUTINE FoamC_SetOptCrude(OptCrude)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      OptCrude
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_OptCrude = OptCrude
      END                       !!! FoamC_SetOptCrude

      SUBROUTINE FoamC_SetOptEdge(OptEdge)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      OptEdge
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_OptEdge = OptEdge
      END                       !!! FoamC_SetOptEdge

      SUBROUTINE FoamC_SetOptPeek(OptPeek)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      OptPeek
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_OptPeek = OptPeek
      END                       !!! FoamC_SetOptPeek

      SUBROUTINE FoamC_SetOut(Out)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER      Out
*     -------------------------------------------------
      CALL FoamC_PreInitialize
      m_Out = Out
      END                       !!! FoamC_SetOut


      SUBROUTINE FoamC_VertPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all vertices                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamC.h'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*     ----------------------------------------------------------------
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_Ndim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      WRITE(mout,*) '=====================all vertices==================================='
      WRITE(mout,*) ' iVert   NoRefs  NoRefsAc       Vertex     Componets    '
      DO iVe = 1, m_LastVe
         WRITE(mout,'(i6,2i10,5f17.10)') iVe,NoRefs(iVe),NoRefsAc(iVe), (m_VerX(iVe,j),j=1,m_Ndim)
      ENDDO
      END                       !! VertPrint

      SUBROUTINE fort_close(nout)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Interface used by c++ programs                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER  nout,nout2
*-------------------------------------------------------------------------------------
      nout2 = nout
      CLOSE(nout2)
      END

*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//              End of Pseudo-CLASS  QED3                                          //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE fort_open(nout,fname)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Interface used by c++ programs                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT  NONE
      CHARACTER fname*(*)
      INTEGER   nout,nout2
*-------------------------------------------------------------------------------------
      nout2 = nout
      OPEN(nout2,file=fname)
**      WRITE(6,'(A,A20,A)')    '======>',filename,'<========='
**      WRITE(nout,'(A,A20,A)') '======>',filename,'<========='
      END

      DOUBLE PRECISION  FUNCTION GLK_AproF(px,nch,yy)
*     ************************************************
* PX is a continuous extension of the m_index in array YY
      IMPLICIT NONE
      INTEGER           nch,ip
      DOUBLE PRECISION  px,yy(*),X,p
*-----------------------------------------------------
      X=PX
      IF(X .LT. 0.0.OR.X .GT. FLOAT(NCH+1)) THEN
        GLK_AproF= -1E-20
        RETURN
      ENDIF
      IP=INT(X)
      IF(IP .LT. 2)     IP=2
      IF(IP .GT. NCH-2) IP=NCH-2
      P=X-IP
      GLK_AproF =
     $     -(1./6.)*P*(P-1)*(P-2)  *YY(IP-1)
     $     +(1./2.)*(P*P-1)*(P-2)  *YY(IP  )
     $     -(1./2.)*P*(P+1)*(P-2)  *YY(IP+1)
     $     +(1./6.)*P*(P*P-1)      *YY(IP+2)
      END

      SUBROUTINE GLK_AxisX(kay,yl,yu,chxfmt)
*     ***************************************
* plotting x-axis with long and short tips
      IMPLICIT NONE
      INTEGER  kay
      DOUBLE PRECISION    yl,yu
      CHARACTER chxfmt*16
      INCLUDE 'GLK.h'
      SAVE
*-------------------------------------------------------
      CHARACTER*64 fmt1,fmt2
      PARAMETER (fmt1 = '(2A,F8.2,A,F8.2,A,I4,3A)')
      PARAMETER (fmt2 = '(2A,F8.2,A,I4,A,F8.2,A,I4,3A)')
      DOUBLE PRECISION   dy,ddy,ddyl,yy0l,ddys,yy0s,p0s,pds,scmx,p0l,pdl
      INTEGER ly,jy,nlt,nts,lex,k,n
      DOUBLE PRECISION  tipsy(20)
*-------------------------------------------------------
      dy= ABS(yu-yl)
      ly = NINT( LOG10(dy) -0.4999999d0 )
      jy = NINT(dy/10d0**ly)
      ddyl = dy*10d0**(-ly)
      IF( jy .EQ. 1)                 ddyl = 10d0**ly*0.25d0
      IF( jy .GE. 2 .AND. jy .LE. 3) ddyl = 10d0**ly*0.5d0
      IF( jy .GE. 4 .AND. jy .LE. 6) ddyl = 10d0**ly*1.0d0
      IF( jy .GE. 7)                 ddyl = 10d0**ly*2.0d0
      WRITE(m_ltx,'(A)') '% -------GLK_AxisX---- '
      WRITE(m_ltx,'(A,I4)') '%  JY= ',JY
*-------
      nlt = INT(dy/ddyl)
      nlt = MAX0(MIN0(nlt,20),1)+1
      yy0l = NINT(yl/ddyl+0.5d0)*ddyl
      ddys = ddyl/10d0
      yy0s = NINT(yl/ddys+0.4999999d0)*ddys
      p0l = kay*(yy0l-yl)/(yu-yl)
      pdl = kay*ddyl/(yu-yl)
      p0s = kay*(yy0s-yl)/(yu-yl)
      pds = kay*ddys/(yu-yl)
      nlt = INT(ABS(yu-yy0l)/ddyl+0.0000001d0)+1
      nts = INT(abs(yu-yy0s)/ddys+0.0000001d0)+1
      DO n=1,nlt
         tipsy(n) =yy0l+ ddyl*(n-1)
      ENDDO
      WRITE(m_ltx,fmt1)
     $ m_BS,'multiput('  ,P0L,  ',0)('  ,PDL,  ',0){'  ,NLT,  '}{',
     $ m_BS,'line(0,1){25}}',
     $ m_BS,'multiput('  ,P0S,  ',0)('  ,PDS,  ',0){'  ,NTS,  '}{',
     $ m_BS,'line(0,1){10}}'
      WRITE(m_ltx,fmt2)
     $ m_BS,'multiput('  ,P0L,  ','  ,kay,  ')('  ,PDL,  ',0){'  ,NLT,
     $ '}{'  ,m_BS,  'line(0,-1){25}}',
     $ m_BS,'multiput('  ,P0S,  ','  ,kay,  ')('  ,PDS,  ',0){'  ,NTS,
     $ '}{'  ,m_BS,  'line(0,-1){10}}'
* ...labeling of axis
      scmx = DMAX1(DABS(yl),DABS(YU))
      lex  = NINT( LOG10(scmx) -0.50001)
      DO n=1,nlt
         k = nint(kay*(tipsy(n)-yl)/(yu-yl))
         IF(lex .LE. 3 .AND. lex .GE. -3) THEN
* ...without exponent
           WRITE(m_ltx,'(2A,I4,5A,'//chxfmt//',A)')
     $     m_BS,'put(',K,',-25){',m_BS,'makebox(0,0)[t]{',
     $           m_BS,'Large $ ', TIPSY(N), ' $}}'
         ELSE
* ...with exponent
           WRITE(m_ltx,'(2A,I4,5A,'//chxfmt//',2A,I4,A)')
     $     m_BS,'put('  ,K,  ',-25){',m_BS,'makebox(0,0)[t]{',
     $     m_BS,'Large $ ',
     $     TIPSY(N)/(10d0**LEX),m_BS,'cdot 10^{',LEX,'} $}}'
         ENDIF
      ENDDO
      END

      SUBROUTINE GLK_AxisY(kay,yl,yu,chyfmt)
*     ***************************************
* plotting y-axis with long and short tips
      IMPLICIT NONE
      INTEGER  kay
      DOUBLE PRECISION    yl,yu
      CHARACTER chyfmt*16
      INCLUDE 'GLK.h'
      SAVE
      DOUBLE PRECISION  tipsy(20)
*------------------------------------------------------------------
      CHARACTER*64 fmt1,fmt2
      PARAMETER (fmt1 = '(2A,F8.2,A,F8.2,A,I4,3A)')
      PARAMETER (fmt2 = '(2A,I4,A,F8.2,A,F8.2,A,I4,3A)')
      INTEGER ly,jy,nlt,nts,lex,n,k
      DOUBLE PRECISION   ddyl,dy,yy0l,p0l,pdl,pds,scmx,z0l,p0s,yy0s,ddys
*------------------------------------------------------------------
      dy= ABS(yu-yl)
      ly = NINT( log10(dy) -0.49999999d0 )
      jy = NINT(dy/10d0**ly)
      ddyl = dy*10d0**(-ly)
      IF( jy .EQ. 1)                 ddyl = 10d0**ly*0.25d0
      IF( jy .GE. 2 .AND. jy .LE. 3) ddyl = 10d0**ly*0.5d0
      IF( jy .GE. 4 .AND. jy .LE. 6) ddyl = 10d0**ly*1.0d0
      IF( jy .GE. 7)                 ddyl = 10d0**ly*2.0d0
      WRITE(m_ltx,'(A)') '% --------GLK_SAxisY------- '
      WRITE(m_ltx,'(A,I4)') '%  JY= ',JY
*-------
      nlt = INT(dy/ddyl)
      nlt = MAX0(MIN0(nlt,20),1)+1
      yy0l = NINT(yl/ddyl+0.4999999d0)*ddyl
      ddys = ddyl/10d0
      yy0s = nint(yl/ddys+0.5d0)*ddys
      p0l = kay*(yy0l-yl)/(yu-yl)
      pdl = kay*ddyl/(yu-yl)
      p0s = kay*(yy0s-yl)/(yu-yl)
      pds = kay*ddys/(yu-yl)
      nlt= INT(ABS(yu-yy0l)/ddyl+0.0000001d0) +1
      nts= INT(ABS(yu-yy0s)/ddys+0.0000001d0) +1
      DO N=1,NLT
         tipsy(n) =yy0l+ ddyl*(n-1)
      ENDDO
* plotting tics on vertical axis
      WRITE(m_ltx,fmt1)
     $ m_BS,'multiput(0,'  ,P0L,  ')(0,'  ,PDL  ,'){'  ,NLT,  '}{', m_BS,'line(1,0){25}}',
     $ m_BS,'multiput(0,'  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,  '}{', m_BS,'line(1,0){10}}'
      WRITE(m_ltx,fmt2)
     $ m_BS,'multiput('  ,kay,  ','  ,P0L,  ')(0,'  ,PDL,  '){'  ,NLT,
     $ '}{',m_BS,'line(-1,0){25}}',
     $ m_BS,'multiput('  ,kay,  ','  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,
     $ '}{',m_BS,'line(-1,0){10}}'
* ...Zero line if necessary
      Z0L = kay*(-YL)/(YU-YL)
      IF( (Z0L .GT. 0D0) .AND. (Z0L .LT. FLOAT(kay)) )
     $ WRITE(m_ltx,'(2A,F8.2,3A,I4,A)') m_BS,'put(0,'  ,Z0L,  '){',m_BS,'line(1,0){'  ,kay,  '}}'
* ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001d0)
      DO n=1,nlt
         k = nint(kay*(tipsy(n)-yl)/(yu-yl))
         IF(lex .LE. 3 .AND. lex .GE. -3) THEN
* ...without exponent
            WRITE(m_ltx,'(2A,I4,5A,'//chyfmt//',A)')
     $           m_BS,'put(-25,'  ,K,  '){',m_BS,'makebox(0,0)[r]{',
     $           m_BS,'Large $ '  ,TIPSY(N),  ' $}}'
         ELSE
* ...with exponent
            WRITE(m_ltx,'(2A,I4,5A,'//chyfmt//',2A,I4,A)')
     $           m_BS,'put(-25,'  ,K,  '){',m_BS,'makebox(0,0)[r]{',
     $           m_BS,'Large $ ',
     $           TIPSY(N)/(10d0**LEX),  m_BS,'cdot 10^{'  ,LEX,  '} $}}'
      ENDIF
      ENDDO
      END

      SUBROUTINE GLK_Book1(id,title,nnchx,xxl,xxu)
*     ********************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER          id
      DOUBLE PRECISION xxl,xxu
      CHARACTER*80 title
* locals
      DOUBLE PRECISION xl,xu,ddx
      INTEGER          ist,nchx,ioplog,iopsla,ioperb,iflag2,ityphi,iflag1
      INTEGER          ist3,ist2,lengt2,lact,nnchx,iopsc2,iopsc1,j
      LOGICAL GLK_Exist
*-------------------------------------------------
      CALL GLK_Initialize
      IF(GLK_Exist(id)) goto 900
      ist=m_length
      CALL GLK_hadres(0,lact)
* Check if there is a free entry in the m_index
      IF(lact .EQ. 0)
     $     CALL GLK_Stop1('GLK_Book1: to many histos !!!!!,   id= ',id)
      m_index(lact,1)=id
      m_index(lact,2)=m_length
      m_index(lact,3)=0
* -------
      CALL GLK_Copch(title,m_titlc(lact))
      nchx =nnchx
      IF(nchx .GT. m_MaxNb)
     $     CALL GLK_Stop1(' GLK_Book1: To many bins requested,id= ',id)
      xl   =xxl
      xu   =xxu
* ---------- title and bin content ----------
      lengt2 = m_length +2*nchx +m_buf1+1
      IF(lengt2 .GE. m_LenmB)
     $  CALL GLK_Stop1('GLK_Book1:too litle storage, m_LenmB= ',m_LenmB)
*
      DO j=m_length+1,lengt2+1
         m_b(j) = 0d0
      ENDDO
      m_length=lengt2
*... default flags
      ioplog   = 1
      iopsla   = 1
      ioperb   = 1
      iopsc1   = 1
      iopsc2   = 1
      iflag1   =
     $ ioplog+10*iopsla+100*ioperb+1000*iopsc1+10000*iopsc2
      ityphi   = 1
      iflag2   = ityphi
* examples of decoding flags
*      id       = nint(m_b(ist+2)-9d0-9d12)/10
*      iflag1   = nint(m_b(ist+3)-9d0-9d12)/10
*      ioplog = mod(iflag1,10)
*      iopsla = mod(iflag1,100)/10
*      ioperb = mod(iflag1,1000)/100
*      iopsc1 = mod(iflag1,10000)/1000
*      iopsc2 = mod(iflag1,100000)/10000
*      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
*      ityphi = mod(iflag2,10)
*--------- buffer -----------------
* header
      m_b(ist +1)  = 9999999999999d0
      m_b(ist +2)  = 9d12 +     id*10 +9d0
      m_b(ist +3)  = 9d12 + iflag1*10 +9d0
      m_b(ist +4)  = 9d12 + iflag2*10 +9d0
* dummy vertical scale
      m_b(ist +5)  =  -100d0
      m_b(ist +6)  =   100d0
* pointer used to speed up search of histogram address
      m_b(ist +7)  =   0d0
* information on binning
      ist2         = ist+7
      m_b(ist2 +1) = nchx
      m_b(ist2 +2) = xl
      m_b(ist2 +3) = xu
      ddx = xu-xl
      IF(ddx .EQ. 0d0) CALL GLK_Stop1('+++GLK_Book1: xl=xu,  id= ',id)
      m_b(ist2 +4) = DFLOAT(nchx)/ddx
*
* under/over-flow etc.
      ist3       = ist+11
      DO j=1,13
         m_b(ist3 +j)=0d0
      ENDDO
      RETURN
*----------------
 900  CALL GLK_Retu1(' WARNING GLK_Book1: already exists id= ', id)
      END



      SUBROUTINE GLK_Book2(ID,TITLE,NCHX,XL,XU,NCHY,YL,YU)
*     ***************************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           ID,NCHX,NCHY
      DOUBLE PRECISION  XL,XU,YL,YU
      CHARACTER*80 TITLE
*
      INTEGER   ist,lact,lengt2,j,nnchx,nnchy
      LOGICAL GLK_EXIST
*-------------------------------------------------------------------------
      CALL GLK_Initialize
      IF(GLK_EXIST(ID)) GOTO 900
      ist=m_length
      CALL GLK_hadres(0,lact)
      IF(LACT .EQ. 0) GOTO 901
      m_index(LACT,1)=ID
      m_index(LACT,2)=m_length
      CALL GLK_COPCH(TITLE,M_TITLC(LACT))
      nnchx=NCHX
      nnchy=NCHY
      LENGT2 = M_LENGTH  +44+nnchx*nnchy
      IF(LENGT2 .GE. m_LenmB) GOTO 902
      DO 10 J=M_LENGTH+1,LENGT2+1
   10 m_b(J) = 0D0
      M_LENGTH=LENGT2
      m_b(ist+1)=nnchx
      m_b(ist+2)=XL
      m_b(ist+3)=XU
      m_b(ist+4)=float(nnchx)/(m_b(ist+3)-m_b(ist+2))
      m_b(ist+5)=nnchy
      m_b(ist+6)=YL
      m_b(ist+7)=YU
      m_b(ist+8)=float(nnchy)/(m_b(ist+7)-m_b(ist+6))
      RETURN
  900 CALL GLK_Retu1('GLK_Book2: histo already exists!!!! id=',id)
      RETURN
  901 CALL GLK_Stop1('GLK_Book2: too many histos !!!!! lact= ',LACT)
      RETURN
  902 CALL GLK_Stop1('GLK_Book2: too litle storage, m_LenmB=',m_LenmB)
      RETURN
      END


      SUBROUTINE GLK_BookFun1(id,title,nchx,xmin,xmax,func)
*/////////////////////////////////////////////////////////////////////////
*//   fills histogram with function func(x)                             //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  xmin,xmax,func
      CHARACTER*80 title
*
      DOUBLE PRECISION  yy(m_MaxNb)
      EXTERNAL func
      LOGICAL GLK_Exist
      INTEGER           ib,nchx
      DOUBLE PRECISION  xl,xu,x
*---------------------------------------------------------------------
      CALL GLK_Initialize
      IF(GLK_Exist(id)) GOTO 900
 15   xl=xmin
      xu=xmax
      CALL GLK_Book1(id,title,nchx,xl,xu)
*...slanted line in plotting
      CALL GLK_idopt(id,'SLAN')
      IF(nchx .GT. 200) goto 901
      DO ib=1,nchx
         x= xmin +(xmax-xmin)/nchx*(ib-0.5d0)
         yy(ib) = func(x)
      ENDDO
      CALL GLK_Pak(id,yy)
      RETURN
 900  CALL GLK_Retu1('+++GLK_BookFun1: already exists id=',id)
      CALL GLK_Delet(id)
      GOTO 15
 901  CALL GLK_Stop1('+++GLK_BookFun1: to many bins, id=',id)
      END

      SUBROUTINE GLK_BookFun1I(id,title,nchx,xmin,xmax,func)
*/////////////////////////////////////////////////////////////////////////
*//   Fills histogram with function func(x)                             //
*//   Gauss integration over each bin is done, can be slow.             //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  xmin,xmax,func
      CHARACTER*80 title
*
      DOUBLE PRECISION  yy(m_MaxNb)
      EXTERNAL func
      LOGICAL GLK_Exist
      INTEGER           ib,nchx
      DOUBLE PRECISION  xl,xu,x
      DOUBLE PRECISION  GLK_Gauss,a,b,Eeps,dx
*---------------------------------------------------------------------
      CALL GLK_Initialize
      IF(GLK_Exist(id)) GOTO 900
 15   xl=xmin
      xu=xmax
      CALL GLK_Book1(id,title,nchx,xl,xu)
      IF(nchx .GT. 200) goto 901
      Eeps = -0.01d0             !!! relat. precision requirement not very demanding
      dx = (xmax-xmin)/nchx
      DO ib=1,nchx
         a= xmin +dx*(ib-1)
         b= xmin +dx*ib
         yy(ib) = GLK_Gauss(func,a,b,Eeps)/dx   !! 16-point Gauss integration over bin
      ENDDO
      CALL GLK_Pak(id,yy)
      RETURN
 900  CALL GLK_Retu1('+++GLK_BookFun1I: already exists id=',id)
      CALL GLK_Delet(id)
      GOTO 15
 901  CALL GLK_Stop1('+++GLK_BookFun1I: to many bins, id=',id)
      END

      SUBROUTINE GLK_BookFun1S(id,title,nchx,xmin,xmax,func)
*/////////////////////////////////////////////////////////////////////////
*// Fills histogram with function func(x)                               //
*// three point fit used                                                //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      DOUBLE PRECISION  xmin,xmax,func
      EXTERNAL func
      INTEGER  id,nchx
      CHARACTER*80 title
* locals
      DOUBLE PRECISION  yy(m_MaxNb),yy1(0:m_MaxNb)
      LOGICAL GLK_Exist
      DOUBLE PRECISION  xl,xu,x3,x2,dx
      INTEGER           ib  
*--------------------------------------------------------
      CALL GLK_Initialize
      IF( GLK_Exist(id) ) GOTO 900
 15   xl=xmin
      xu=xmax
      CALL GLK_Book1(id,title,nchx,xl,xu)

*...slanted line in plotting
      CALL GLK_idopt(id,'SLAN')
      IF(nchx.gt.200) GOTO 901

      yy1(0) = func(xmin)
      dx=(xmax-xmin)/nchx

      DO ib=1,nchx
         x2= xmin +dx*(ib-0.5d0)
         x3= x2 +dx*0.5d0
         yy(ib)  = func(x2)
         yy1(ib) = func(x3)
*..  simpson
         yy(ib) = ( yy1(ib-1) +4*yy (ib) +yy1(ib))/6d0
      ENDDO

      CALL GLK_Pak(id,yy)
      RETURN
 900  CALL GLK_Retu1('+++GLK_BookFun1S: already exists, id=',id)
      CALL GLK_Delet(id)
      GOTO 15
 901  CALL GLK_Stop1(' +++GLK_BookFun1S: to many bins, id=',id)
      END

*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Setters and Getters                                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////

      SUBROUTINE GLK_Clone1(id1,id2,title2)
*//////////////////////////////////////////////////////////////////////////////
*//   Clone 1-dimensional histo with onl bining and new title                //
*//////////////////////////////////////////////////////////////////////////////
      CHARACTER*80 title1, title2, title3
      INTEGER      i,nb
      DOUBLE PRECISION        xmin,xmax

      CALL GLK_hinbo1(id1,title1,nb,xmin,xmax)
      CALL GLK_Copch(title2,title3)
      CALL GLK_Book1(id2,title3,nb,xmin,xmax)

      END


      SUBROUTINE GLK_Copch(ch1,ch2)
*     *****************************
      IMPLICIT NONE
* copies CHARACTER*80 ch1 into ch2 up to a first $ sign
      CHARACTER*80 ch1,ch2
      LOGICAL met
      INTEGER      i
*----------------------------
      met = .FALSE.
      DO i=1,80
         IF( ch1(i:i) .EQ. '$' .or. met )   THEN
            ch2(i:i)=' '
            met=.TRUE.
         ELSE
            ch2(i:i)=ch1(i:i)
         ENDIF
      ENDDO
      END

      SUBROUTINE GLK_CopyYmax(id1,id2)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id1,id2
      DOUBLE PRECISION   ymax
*
      CALL GLK_GetYmax(id1,ymax)
      CALL GLK_SetYmax(id2,ymax)
      END

      SUBROUTINE GLK_CopyYmin(id1,id2)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id1,id2
      DOUBLE PRECISION   ymin
*
      CALL GLK_GetYmin(id1,ymin)
      CALL GLK_SetYmin(id2,ymin)
      END

      SUBROUTINE GLK_CumHis(IdGen,id1,id2)
*     ************************************
*///////////////////////////////////////////////////////////////////////////
*//   Cumulates histogram content starting from UNDERFLOW                 //
*//   and normalizes to the total x-section in NANOBARNS                  //
*//   IdGen is ID of special histogram written by M.C. generator itself   //
*//   id2. NE. id1 required!!!                                            //
*///////////////////////////////////////////////////////////////////////////
*     ***********************************
      IMPLICIT NONE
      INTEGER  IdGen,id1,id2
*----------------------------------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
*----------------------------------------------------------------------
      CHARACTER*80 TITLE
      DOUBLE PRECISION    X(m_MaxNb),ER(m_MaxNb)
      LOGICAL GLK_EXIST
      DOUBLE PRECISION    swt,sswt,xsec,errel,tmin,tmax
      DOUBLE PRECISION    xscrnb,ERela,WtSup
      INTEGER  i,nbt,nevt
      DOUBLE PRECISION    GLK_hi,GLK_hie
*----------------------------------------------------------------------
      IF (GLK_Exist(id2)) GOTO 900
*
      CALL GLK_MgetNtot(IdGen,nevt)
      CALL GLK_MgetAve( IdGen,xscrnb,ERela,WtSup)
*
      IF(nevt .EQ. 0) GOTO 901
      CALL GLK_hinbo1(id1,title,nbt,tmin,tmax)
      swt  = GLK_hi( id1,0)     ! UNDERFLOW
      sswt = GLK_hie(id1,0)**2  ! UNDERFLOW
      DO i=1,nbt
         swt   = swt + GLK_hi( id1,i)
         sswt  = sswt+ GLK_hie(id1,i)**2
* note NEVT in error calc. is for the entire sample related
* to the crude x-section XCRU including !!! zero weight events !!!!
         xsec  = 0d0
         errel = 0d0
         IF(swt .NE. 0d0 .AND. nevt .NE. 0) THEN
            xsec  = swt*(xscrnb/nevt)
            errel = SQRT(ABS(sswt/swt**2-1d0/FLOAT(nevt)))
         ENDIF
         x(i)  = xsec
         er(i) = xsec*errel
      ENDDO
*! store result in id2
      CALL GLK_Book1(id2,title,nbt,tmin,tmax)
      CALL GLK_Pak(  id2,x)
      CALL GLK_Pake( id2,er)
      CALL GLK_idopt(id2,'ERRO')
      RETURN
 900  WRITE(6,*) '+++++ CUMHIS: ID2 exixsts!!',ID2
      RETURN
 901  WRITE(6,*) '+++++ CUMHIS: EMPTY HISTO ID=',ID1
      END

      SUBROUTINE GLK_Delet(id1)
*     *********************
* Now it should work (stj Nov. 91) but watch out!
* should works for 2-dim histos, please check this!
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id1
*
      LOGICAL GLK_Exist
      INTEGER           id,lact,ist,ist2,nch,iflag2,ityphi,local,k,i,l,next,idec,nchx,nchy
*--------------------------------------------
      ID=ID1
      IF(id .EQ. 0) GOTO 300
      IF( .NOT. GLK_Exist(id)) GOTO 900
      CALL GLK_hadres(id,lact)
      ist  = m_index(lact,2)
      ist2 = ist+7
*----
*[[[      WRITE(6,*) 'GLK_DELET-ing ID= ',ID
      idec    = nint(m_b(ist+2)-9d0-9d12)/10
      IF(idec .NE. id) WRITE(6,*)
     $     '++++GLK_DELET: ALARM! ID,IDEC= ',ID,IDEC
*----
      nch  = m_b(ist2 +1)
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = MOD(iflag2,10)
      IF(ityphi .EQ. 1) THEN
* one-dim.
        nchx  = m_b(ist2 +1)
        nch   = 2*nchx
* lenght of local histo to be removed
        local = nch+m_buf1+1
      ELSEIF(ityphi .EQ. 2) THEN
* two-dim.
        nchx  = m_b(ist2 +1)
        nchy  = m_b(ist2 +5)
        nch   = nchx*nchy
* lenght of local histo to be removed
        local = nch+m_buf2+1
      ELSE
         CALL GLK_Stop1('+++GLK_Delet: wrong type id=',id)
      ENDIF
* starting position of next histo in storage b
      next = ist+1 +local
* move down all histos above this one
      DO 15 k =next,m_length
      m_b(k-local)=m_b(k)
   15 CONTINUE
* define new end of storage
      m_length=m_length-local
* clean free space at the end of storage b
      DO 20 k=m_length+1, m_length+local
   20 m_b(k)=0d0
* shift adresses of all displaced histos
      DO 25 l=lact+1,m_idmax
      IF(m_index(l,1) .NE. 0) m_index(l,2)=m_index(l,2)-local
   25 CONTINUE
* move entries in m_index down by one and remove id=lact entry
      DO 30 l=lact+1,m_idmax
      m_index(l-1,1)=m_index(l,1)
      m_index(l-1,2)=m_index(l,2)
      m_index(l-1,3)=m_index(l,3)
      m_titlc(l-1)=m_titlc(l)
   30 CONTINUE
* last entry should be always empty
      m_index(m_idmax,1)=0
      m_index(m_idmax,2)=0
      m_index(m_idmax,3)=0
      do 50 k=1,80
   50 m_titlc(m_idmax)(k:k)=' '
      RETURN
* -----------------------------------
* Deleting all histos at once!!!
  300 m_length=0
      DO 400 i=1,m_idmax
      DO 340 k=1,3
  340 m_index(i,k)=0
      DO 350 k=1,80
  350 m_titlc(i)(k:k)=' '
 400  CONTINUE
      RETURN
* -----------------------------------
 900  CONTINUE
      CALL GLK_Retu1(' +++GLK_DELET: nonexisting histo id= ',id)
      END

      LOGICAL FUNCTION GLK_Exist(id)
*     ******************************
* this function is true when id  exists !!!!
*     ***************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id,lact
*------------------------------------------------
      CALL GLK_hadres(id,lact)
      GLK_Exist = lact .NE. 0
***   IF(GLK_Exist)      WRITE(6,*) 'GLK_Exist: does   ID,lact=',id,lact
***   IF(.not.GLK_Exist) write(6,*) 'GLK_Exist: doesnt ID,lact=',id,lact
      END

      SUBROUTINE GLK_Fil1(id,xx,wtx)
*     *****************************
* recommended fast filling 1-dim. histogram s.j. 18 nov. 90
* overflow/underflow corrected by Maciek and Zbyszek
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  xx,wtx
* local
      INTEGER           ist,ist2,ist3,iflag2,ityphi,ipose1,iposx1,kposx1,kpose1,kx,nchx,lact
      DOUBLE PRECISION  x1,wt1,xl,factx,xu
*-------------------------------------------------------------------------
      CALL GLK_hadres(id,lact)
* exit for non-existig histo
      IF(lact .EQ. 0)  RETURN
      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
* one-dim. histo only
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1)  CALL GLK_Stop1('+++GLK_Fil1: wrong id=  ',id)
      x1= xx
      wt1= wtx
      m_index(lact,3)=m_index(lact,3)+1
* all entries
      m_b(ist3 +7)  =m_b(ist3 +7)   +1
* for average x
      m_b(ist3 +8)  =m_b(ist3 +8)  +wt1
      m_b(ist3 +9)  =m_b(ist3 +9)  +wt1*x1
* filling coordinates
      nchx  =m_b(ist2 +1)
      xl    =m_b(ist2 +2)
      xu    =m_b(ist2 +3)
      factx =m_b(ist2 +4)
      IF(x1 .LT. xl) THEN
* underflow
         iposx1 = ist3 +1
         ipose1 = ist3 +4
         kposx1 = 0
      ELSEIF(x1 .GT. xu) THEN
* or overflow
         iposx1 = ist3 +3
         ipose1 = ist3 +6
         kposx1 = 0
      ELSE
* or any normal bin
         iposx1 = ist3 +2
         ipose1 = ist3 +5
* or given normal bin
         kx = (x1-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kposx1 = ist +m_buf1+kx
         kpose1 = ist +m_buf1+nchx+kx
      ENDIF
      m_b(iposx1) = m_b(iposx1)  +wt1
      m_b(ipose1) = m_b(ipose1)  +wt1*wt1
      IF( kposx1 .NE. 0) m_b(kposx1) = m_b(kposx1)  +wt1
      IF( kposx1 .NE. 0) m_b(kpose1) = m_b(kpose1)  +wt1*wt1
      END   !GLK_Fil1

      SUBROUTINE GLK_Fil1diff(id,xx,wtx,yy,wty)
*     *****************************************
* Special filling routine to fill the difference f(x)-g(y)
* in the case when f and g are very similar x and y are close for each event.
* In this case coherent filling is done if x and y fall into the same bin.
* Note that bin width starts to be important in this method.
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
*
      INTEGER           id
      DOUBLE PRECISION  xx,wtx,yy,wty
*    
      DOUBLE PRECISION  x1,x2,wt2,wt1,factx,xl,xu
      INTEGER           ist,ist2,ist3,iflag2,ityphi,kx,ke1,ie1,kx1,kx2,ke2,ix2,ie2,nchx,lact,ix1
*-----------------------------------------------------------------
      CALL GLK_hadres(id,lact)
* exit for non-existig histo
      IF(lact .EQ. 0)  RETURN
      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
* one-dim. histo only
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) THEN
        CALL GLK_Stop1('GLK_Fil1diff: 1-dim histos only !!! id=',id)
      ENDIF
      x1= xx
      x2= yy
      wt1= wtx
      wt2= wty
      m_index(lact,3)=m_index(lact,3)+1
* all entries
      m_b(ist3 +7)  =m_b(ist3 +7)   +1
* for average x or y not very well defined yet
      m_b(ist3 +8)  =m_b(ist3 +8)  +wt1*x1 - wt2*x2
      m_b(ist3 +9)  =m_b(ist3 +9)  +wt1*x1*x1 - wt2*x2*x2
* filling coordinates
      nchx  =m_b(ist2 +1)
      xl    =m_b(ist2 +2)
      xu    =m_b(ist2 +3)
      factx =m_b(ist2 +4)
* first variable
      IF(x1 .LT. xl) THEN       ! underflow
         ix1 = ist3 +1
         ie1 = ist3 +4
         kx1 = 0
      ELSEIF(x1 .GT. xu) THEN   ! or overflow
         ix1 = ist3 +3
         ie1 = ist3 +6
         kx1 = 0
      ELSE                      ! normal bin
         ix1 = ist3 +2
         ie1 = ist3 +5
         kx = (x1-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kx1 = ist +m_buf1+kx
         ke1 = ist +m_buf1+nchx+kx
      ENDIF
* second variable
      IF(x2 .LT. xl) THEN       ! underflow
         ix2 = ist3 +1
         ie2 = ist3 +4
         kx2 = 0
      ELSEIF(x2 .GT. xu) THEN   ! or overflow
         ix2 = ist3 +3
         ie2 = ist3 +6
         kx2 = 0
      ELSE                      ! normal bin
         ix2 = ist3 +2
         ie2 = ist3 +5
         kx = (x2-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kx2 = ist +m_buf1+kx
         ke2 = ist +m_buf1+nchx+kx
      ENDIF
* coherent filling
      IF( ix1 .EQ. ix2 ) THEN
         m_b(ix1) = m_b(ix1)  +wt1-wt2
         m_b(ie1) = m_b(ie1)  +(wt1-wt2)**2
      ELSE
         m_b(ix1) = m_b(ix1)  +wt1
         m_b(ie1) = m_b(ie1)  +wt1*wt1
         m_b(ix2) = m_b(ix2)  -wt2
         m_b(ie2) = m_b(ie2)  +wt2*wt2
      ENDIF
      IF( kx1 .EQ. kx2 ) THEN
         IF( kx1 .NE. 0) THEN
            m_b(kx1) = m_b(kx1)  +wt1-wt2
            m_b(ke1) = m_b(ke1)  +(wt1-wt2)**2
         ENDIF
      ELSE
         IF( kx1 .NE. 0) THEN
            m_b(kx1) = m_b(kx1)  +wt1
            m_b(ke1) = m_b(ke1)  +wt1*wt1
         ENDIF
         IF( kx2 .NE. 0) THEN
            m_b(kx2) = m_b(kx2)  -wt2
            m_b(ke2) = m_b(ke2)  +wt2*wt2
         ENDIF
      ENDIF
      END   !GLK_Fil1diff

      SUBROUTINE GLK_Fil2(id,x,y,wtw)
*     ****************************
* this routine not finished, 1-dim only!
*     ***********************************
      IMPLICIT NONE     
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  x,y,wtw
* local
      INTEGER           ist,iflag2,ityphi,ist2,ist3,nchx,nchy,ly,ky,k2,kx,lact,lx,k,l
      DOUBLE PRECISION  xx,yy,wt,factx,xl,yl,facty
*-------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0)  RETURN
      ist  = m_index(lact,2)
* one-dim. histo
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 2) THEN
        CALL GLK_Stop1('GLK_Fil2: 2-dim histos only !!! id=',id)
      ENDIF
*...two-dim. scattergram, no errors!
      ist2 = ist+7
      ist3 = ist+15
      xx= x
      yy= y
      wt= wtw
      m_index(lact,3)=m_index(lact,3)+1
* x-axis
      nchx  =m_b(ist2 +1)
      xl    =m_b(ist2 +2)
      factx =m_b(ist2 +4)
      kx=(xx-xl)*factx+1d0
      lx=2
      IF(kx .LT. 1)     lx=1
      IF(kx .GT. nchx)  lx=3
      l     = ist+34  +lx
      m_b(l)  = m_b(l)    +wt
      k     = ist+m_buf2  +kx
      IF(lx .EQ. 2) m_b(k)  =m_b(k)  +wt
      k2    = ist+m_buf2  +nchx+kx
      IF(lx .EQ. 2) m_b(k2) =m_b(k2) +wt**2
* y-axix
      nchy  =m_b(ist2 +5)
      yl    =m_b(ist2 +6)
      facty =m_b(ist2 +8)
      ky=(yy-yl)*facty+1d0
      ly=2
      IF(ky .LT. 1)    ly=1
      IF(ky .GT. nchy) ly=3
* under/over-flow
      l = ist3  +lx +3*(ly-1)
      m_b(l) =m_b(l)+wt
* regular bin
      k = ist+m_buf2 +kx +nchx*(ky-1)
      IF(lx .EQ. 2.and.ly .EQ. 2) m_b(k)=m_b(k)+wt
      END

      SUBROUTINE GLK_Flush
*     ********************
* FLUSH memory, all histos erased!
*     *************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER i,k
*------------------------------------------------
      CALL GLK_Initialize
      m_length=0
      DO i=1,m_idmax
         DO k=1,3
            m_index(i,k)=0
         ENDDO
         DO k=1,80
            m_titlc(i)(k:k)=' '
         ENDDO
      ENDDO
      DO k=1,m_LenmB
         m_b(k)=0d0
      ENDDO
      END

      DOUBLE PRECISION FUNCTION GLK_Gauss(f,a,b,Eeps)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// This is iterative integration procedure                                  //
*// originates  probably from CERN library                                   //
*// it subdivides inegration range until required precision is reached       //
*// precision is a difference from 8 and 16 point Gauss itegr. result        //
*// Eeps POSITIVE treated as absolute precision                              //
*// Eeps NEGATIVE treated as relative precision                              //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  f,a,b,Eeps
*
      DOUBLE PRECISION  c1,c2,bb,s8,s16,y,aa,const,delta,eps,u
      INTEGER           i
*
      DOUBLE PRECISION  w(12),x(12)
      EXTERNAL f
      DATA const /1.0d-19/
      DATA w
     1/0.10122 85362 90376, 0.22238 10344 53374, 0.31370 66458 77887,
     2 0.36268 37833 78362, 0.02715 24594 11754, 0.06225 35239 38648,
     3 0.09515 85116 82493, 0.12462 89712 55534, 0.14959 59888 16577,
     4 0.16915 65193 95003, 0.18260 34150 44924, 0.18945 06104 55069/
      DATA x
     1/0.96028 98564 97536, 0.79666 64774 13627, 0.52553 24099 16329,
     2 0.18343 46424 95650, 0.98940 09349 91650, 0.94457 50230 73233,
     3 0.86563 12023 87832, 0.75540 44083 55003, 0.61787 62444 02644,
     4 0.45801 67776 57227, 0.28160 35507 79259, 0.09501 25098 37637/
*-----------------------------------------------------------------------------
      eps=abs(Eeps)
      delta=const*abs(a-b)
      GLK_Gauss=0d0
      aa=a
    5 y=b-aa
      IF(abs(y)  .LE.  delta) RETURN
    2 bb=aa+y
      c1=0.5d0*(aa+bb)
      c2=c1-aa
      s8=0d0
      s16=0d0
      DO 1 i=1,4
      u=x(i)*c2
    1 s8=s8+w(i)*(f(c1+u)+f(c1-u))
      DO 3 i=5,12
      u=x(i)*c2
    3 s16=s16+w(i)*(f(c1+u)+f(c1-u))
      s8=s8*c2
      s16=s16*c2
      IF(Eeps .LT. 0d0) THEN
        IF(abs(s16-s8)  .GT.  eps*abs(s16)) GOTO 4
      ELSE
        IF(abs(s16-s8)  .GT.  eps) GOTO 4
      ENDIF
      GLK_Gauss=GLK_Gauss+s16
      aa=bb
      GOTO 5
    4 y=0.5d0*y
      IF(abs(y)  .GT.  delta) GOTO 2
      WRITE(*,7)
      GLK_Gauss=0d0
      RETURN
    7 FORMAT(1x,36hgaus  ... too high accuracy required)
      END

      SUBROUTINE GLK_GetBin(id,ib,Bin)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  getting out bin content                                                 //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER    id,ib
      DOUBLE PRECISION      Bin,GLK_hi

      Bin =  GLK_hi(id,ib)
      END

      SUBROUTINE GLK_GetNb(id,Nb)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER  id,Nb
* local
      CHARACTER*80 title
      INTEGER lact,ist,ist2
*-------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) THEN
         CALL GLK_Stop1('+++STOP in GLK_GetNb: wrong id=',id)
      ENDIF
      ist    = m_index(lact,2)
      ist2   = ist+7
      Nb     = m_b(ist2 +1)
      END

      SUBROUTINE GLK_GetYmax(id,ymax)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymax
      INTEGER lact,ist
*
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist= m_index(lact,2)
      ymax = m_b(ist+6)
      END

      SUBROUTINE GLK_GetYmin(id,ymin)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymin
      INTEGER lact,ist
*
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist= m_index(lact,2)
      ymin = m_b(ist+5)
      END


      SUBROUTINE GLK_GetYminYmax(id,ymin,ymax)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymin,ymax
*
      CALL GLK_GetYmin(id,ymin)
      CALL GLK_GetYmax(id,ymax)
      END

      SUBROUTINE GLK_hadres(id1,jadres)
*     *********************************
*--------------------------------------------------------------------
* Educated guess based on past history is used to find quickly
* location of the histogram in the matrix m_index.
* This is based on observation that subsequent histogram calls
* are linked into loops (so one can predict easily which histo will
* be called next time).
*--------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER       id1,jadres
      INTEGER       ist,i,id
*----------------------------------------------------------------------
      INTEGER iguess,jdlast,idlast
      DATA    iguess,jdlast,idlast /-2141593,-3141593,-3141593/
      SAVE    iguess,jdlast,idlast
*----------------------------------------------------------------------
      id=id1
* --- The case of ID=0 treated separately, it is used to find out
* --- last entry in the m_index (it is marked with zero)
      IF(id .EQ. 0) THEN
         DO i=1,m_idmax
            IF(m_index(i,1) .EQ. 0) GOTO 44
         ENDDO
         CALL GLK_Stop1('+++GLK_hadres: Too short m_index=',m_index)
 44      CONTINUE
         jadres = i
         RETURN
      ENDIF

* --- Omit sophistications if lack of initialization
      IF(jdlast .EQ. -3141593) GOTO 10
      IF(iguess .EQ. -2141593) GOTO 10
      IF(iguess .EQ. 0) GOTO 10
      IF(jdlast .EQ. 0) GOTO 10

* --- Try first previous histo (for repeated calls)
      IF(jdlast .LT. 1 .OR. jdlast .GT. m_idmax) THEN
         WRITE(6,*) '+++++ hadres: jdlast=',jdlast
      ENDIF
      IF(m_index(jdlast,1) .EQ. id) THEN
         jadres = jdlast
*##   WRITE(6,*)
*##   $   'found, guess based on previous call to jadres ',jdlast
         GOTO 20
      ENDIF

* --- Try current guess based on previous call
      IF(iguess .LT. 1 .OR. iguess .GT. m_idmax)  THEN
         WRITE(6,*)'+++++ hadres: iguess=',iguess
      ENDIF
      IF(m_index(iguess,1) .EQ. id) THEN
         jadres = iguess
*##   WRITE(6,*)
*##   $   'found, guess on previous calls recorded in m_b(ist+7)',jdlast
         GOTO 20
      ENDIF

* ================================================
*    Do it HARD WAY, Search all matrix m_index
* ================================================
 10   CONTINUE
*##   WRITE(6,*) 'trying HARD WAY'
      DO i=1,m_idmax
         jadres=i
         IF(m_index(i,1) .EQ. id) GOTO 20
      ENDDO
* -------------------------------------
*     Nothing found: jadres=0
* -------------------------------------
      jadres=0
      RETURN
* =====================================
*     Found: Set new guess for next call
* =====================================
 20   CONTINUE
* --- and store result as a new guess in previous histo
* --- but only if it existed!!!!
      DO i=1,m_idmax
         IF(m_index(i,1) .EQ. 0) GOTO 40
         IF(m_index(i,1) .EQ. idlast) THEN
            ist=m_index(i,2)
            IF(ist .GT. 0 .AND. ist .LT. m_LenmB) m_b(ist +7) = jadres
*##   WRITE(6,*) 'STORED     id=',id
            GOTO 40
         ENDIF
      ENDDO
 40   CONTINUE
*##   WRITE(6,*)  'found, hard way searching all of m_index)', jdlast
      iguess = m_b( m_index(jadres,2) +7)
      jdlast = jadres
      idlast = id
      END

      DOUBLE PRECISION FUNCTION GLK_hi(id,ib)
*     **********************
* getting out bin content
* S.J. 18-Nov. 90
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER  id,ib
* locals
      INTEGER    ist,ist2,ist3,iflag2,ityphi,nch,idmem,lact
      SAVE idmem
      DATA idmem / -1256765/
*------------------------------------------------------
      IF(id .EQ. idmem) goto 100
      idmem=id
* some checks, not repeated if id the same as previously
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) THEN
        CALL GLK_Stop1(' GLK_hi: nonexisting histo id=',id)
      ENDIF
      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
* checking if histo is of proper type
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1 .AND. ityphi.NE.3) THEN
         CALL GLK_Stop1(' GLK_hi: 1-dim histos only !!! id=',id)
      ENDIF
  100 continue
      nch  = nint(m_b(ist2+1))
      IF(ib .EQ. 0) THEN
* underflow
         GLK_hi=   m_b(ist3 +1)
      ELSEIF(ib .GE. 1.and.ib .LE. nch) THEN
* normal bin
         GLK_hi=   m_b(ist +m_buf1+ib)
      ELSEIF(ib .EQ. nch+1) THEN
* overflow
         GLK_hi=   m_b(ist3 +3)
      ELSE
* abnormal exit
         CALL GLK_Stop1(' GLK_hi: wrong binning id=',id)
      ENDIF
      END

      DOUBLE PRECISION FUNCTION  GLK_hie(id,ib)
*     ************************
* getting out error of the bin
* s.j. 18-nov. 90
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
* locals
      INTEGER    ist,ist2,ist3,iflag2,ityphi,nch,lact,ib,id
      SAVE       idmem
      INTEGER    idmem
      DATA idmem / -1256765/
*---------------------------------------------------------
      IF(id .EQ. idmem) goto 100
      idmem=id
* some checks, not repeated if id the same as previously
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) THEN
        CALL GLK_Stop1(' GLK_hie: nonexisting histo id=',id)
      ENDIF
      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
* checking if histo is of proper type
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) THEN
        CALL GLK_Stop1(' GLK_hie: 1-dim histos only !!! id=',id)
      ENDIF
  100 CONTINUE
      nch  = m_b(ist2+1)
      IF(ib .EQ. 0) THEN
* underflow
         GLK_hie=   dsqrt( dabs(m_b(ist3 +4)))
      ELSEIF(ib .GE. 1.and.ib .LE. nch) THEN
*...normal bin, error content
         GLK_hie=   dsqrt( dabs(m_b(ist+m_buf1+nch+ib)) )
      ELSEIF(ib .EQ. nch+1) THEN
* overflow
         GLK_hie=   dsqrt( dabs(m_b(ist3 +6)))
      ELSE
* abnormal exit
         CALL GLK_Stop1('+++GLK_hie: wrong binning id= ',id)
      ENDIF
      END

      SUBROUTINE GLK_hinbo1(id,title,nchx,xl,xu)
*     **************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id,nchx
      DOUBLE PRECISION  xl,xu
      CHARACTER*80 title
      INTEGER           lact,ist,ist2
*----------------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) THEN
         CALL GLK_Stop1('+++STOP in GLK_hinbo1: wrong id=',id)
      ENDIF
      ist=m_index(lact,2)
      ist2   = ist+7
      nchx   = m_b(ist2 +1)
      xl     = m_b(ist2 +2)
      xu     = m_b(ist2 +3)
      title  = m_titlc(lact)
      END


      SUBROUTINE GLK_hinbo2(id,nchx,xl,xu,nchy,yl,yu)
*     *******************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id,nchx,nchy
      DOUBLE PRECISION  xl,xu,yl,yu
      INTEGER           lact,ist,ist2
*--------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) goto 900
      ist  = m_index(lact,2)
      ist2 = ist+7
      nchx = m_b(ist2 +1)
      xl   = m_b(ist2 +2)
      xu   = m_b(ist2 +3)
      nchy = m_b(ist2 +5)
      yl   = m_b(ist2 +6)
      yu   = m_b(ist2 +7)
      RETURN
  900 CALL GLK_Stop1(' +++GLK_hinbo2: nonexisting histo id= ',id)
      END

      SUBROUTINE GLK_hrend(chdum)
*     ***********************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      CHARACTER*(*) chdum
*---------------------------
      CLOSE(m_huni)
      END

      SUBROUTINE GLK_hrfile(nhruni,chd1,chd2)
*     ***************************************
      IMPLICIT NONE
      CHARACTER*(*) chd1,chd2
      INCLUDE 'GLK.h'
      SAVE
      INTEGER nhruni
*-------------------------------------------------
      CALL GLK_Initialize
      m_huni=nhruni
      END


      SUBROUTINE GLK_hrin(idum1,idum2,idum3)
*     **************************************
* New version which has a possibility to
*            MERGE histograms
* If given ID already exists then it is modified by adding 1000000 !!!!
* Mergigng is done simply by appending new histograms at the
* very end of the m_index and bin matrices.
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER        idum1,idum2,idum3
      INTEGER        l,lact,lenold,istn,idn,k,lenind3,nvrs3,nouth
      INTEGER        i,lengt3,lenma3
* Copy of the new m_index from the disk
      INTEGER        lndex(m_idmax,3)
      CHARACTER*80   titld(m_idmax)
      LOGICAL GLK_Exist
*-----------------------------------------------------------
      CALL GLK_Initialize
      nouth=m_huni
* Read basic params
      READ(nouth,'(6i10)')   nvrs3,lenind3,lenma3,lengt3
      IF(m_length+lengt3 .GE. m_LenmB) GOTO 900
* Check version
      IF(m_version .NE. nvrs3) WRITE(m_out,*)
     $ '+++++WARNING (GLK_hrin): histos produced by older version',nvrs3
      IF(m_version .NE. nvrs3) WRITE(6,*)
     $ '+++++WARNING (GLK_hrin): histos produced by older version',nvrs3
      DO i=1,m_idmax
         DO k=1,3
            lndex(i,k)=0
         ENDDO
      ENDDO
* We keep backward compatibility for reading disk files
      IF(nvrs3. LT. 130) lenind3 = m_idmax
* Read new index and title from the disk
      READ(nouth,'(6i10)')  ((lndex(i,k),k=1,3),i=1,lenind3)
      READ(nouth,'(a80)')   (titld(i),          i=1,lenind3)
      lenold=m_length
* Append AT ONCE content of new histos at the end of storage m_b
      m_length=m_length+lengt3
      READ(nouth,'(3d24.16)') (m_b(i),i=lenold+1,m_length)

* Append ONE BY ONE m_index and m_titlc with new histos
      CALL GLK_hadres(0,lact)
      DO l=1,lenind3
         IF(lact .EQ. 0) GOTO 901
         idn= lndex(l,1)
         IF(idn .EQ. 0) GOTO 100
* Identical id's are changed by adding big number = 1000000
 10      CONTINUE
         IF( GLK_Exist(idn) ) THEN
            idn = idn +1000000*(idn/iabs(idn))
            GOTO 10
         ENDIF
         m_index(lact,1)=idn
         m_index(lact,2)=lndex(l,2)+lenold
         m_index(lact,3)=lndex(l,3)
         m_titlc(lact)  =titld(l)
* Still one small correction in the newly appended histo
         istn  = m_index(lact,2)
         m_b(istn +2)  = 9d12 +     idn*10 +9d0
         lact=lact+1
      ENDDO
  100 CONTINUE
      RETURN

 900  CONTINUE
      CALL GLK_Stop1('++++ GLK_hrin: to litle space, m_LenmB= ',m_LenmB)
 901  CONTINUE
      CALL GLK_Stop1('++++ GLK_hrin: to many histos, m_idmax= ',m_idmax)
      END


      SUBROUTINE GLK_hrin2(idum1,idum2,idum3)
*     **********************************
* New version which has a possibility to
*            ADD histograms
* If ID is not existing already then no action is taken
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER         idum1,idum2,idum3
* Copy of the histos from the disk
      DOUBLE PRECISION  bz(m_LenmB)
      INTEGER           indez(m_idmax,3)
      CHARACTER*80      titlz(m_idmax)
      LOGICAL           GLK_Exist
      INTEGER           nouth,ist3,nchx,ist,ist2,ist3z,nchxz,istz
      INTEGER           ist2z,lact,lenmaz,lengtz,nvrsz,lenindz,lz,id,i,k
*-------------------------------------------------------------
      CALL GLK_Initialize
      nouth=m_huni
* Read basic params
      READ(nouth,'(6i10)')   nvrsz,lenindz,lenmaz,lengtz
* Check version
      IF(m_version .NE. nvrsz) WRITE(m_out,*)
     $ '++++WARNING (GLK_hrin2): histos produced by older version',nvrsz
      IF(m_version .NE. nvrsz) WRITE(6,*)
     $ '++++WARNING (GLK_hrin2): histos produced by older version',nvrsz

* We keep backward compatibility for reading disk files
      IF(nvrsz. LT. 130) lenindz = m_idmax
      DO i=1,m_idmax
         DO k=1,3
            indez(i,k)=0
         ENDDO
      ENDDO
* Read new m_index, title and bins from the disk
      READ(nouth,'(6i10)')    ((indez(i,k),k=1,3),i=1,lenindz)
      READ(nouth,'(a80)')     (titlz(i) ,         i=1,lenindz)
      READ(nouth,'(3d24.16)') (bz(i),i=1,lengtz)

* Add new histos from disk to existing ones one by one
      DO lz=1,lenindz
         id= indez(lz,1)
         IF(id .EQ. 0) GOTO 200
         IF( .NOT. GLK_Exist(id)) THEN
            CALL GLK_Retu1('GLK_hrin2: unmached skipped histo ID=', id)
            GOTO 100
         ENDIF
* parameters of existing histo
         CALL GLK_hadres(id,lact)
         ist  = m_index(lact,2)
         ist2 = ist+7
         ist3 = ist+11
         nchx = m_b(ist2 +1)
* parameters of the histo from the disk
         istz   = indez(lz,2)
         ist2z  = istz+7
         ist3z  = istz+11
         nchxz  = bz(ist2z +1)
         IF(nchx .NE. nchxz) THEN
            CALL GLK_Retu1('GLK_hrin2: non-equal bins, skipped ID=', id)
            GOTO 100
         ENDIF
* Add/Merge all additive entries of the two histos
* No of entries in m_index
         m_index(lact,3) = m_index(lact,3)+indez(lact,3)
* Overflows, underflows etc.
         DO i=1,12
            m_b(ist3+i)=m_b(ist3+i) +bz(ist3z+i)
         ENDDO
* Except of this one non-additive entry
         m_b(ist3+13)=max(m_b(ist3+13),m_b(ist3z+13))
* Regular bin content added now!
         DO i= 1, 2*nchx
            m_b(ist+m_buf1+i)=m_b(ist+m_buf1+i) +bz(istz+m_buf1+i)
         ENDDO
 100     CONTINUE
      ENDDO
 200  CONTINUE
      END

      SUBROUTINE GLK_hrout(idum1,idum2,chdum)
*     ***************************************
      IMPLICIT NONE
      CHARACTER*8 chdum
*
      INCLUDE 'GLK.h'
      SAVE
      INTEGER i,k,last,idum1,idum2
*-----------------------------------------------------------------------
      CALL GLK_Initialize
      CALL GLK_hadres(0,last)
      IF(last.EQ.0) GOTO 900
      m_LenInd = last -1 
      WRITE(m_huni,'(6i10)')    m_version, m_LenInd, m_LenmB, m_Length
      WRITE(m_huni,'(6i10)')    ((m_index(i,k),k=1,3),i=1,m_LenInd)
      WRITE(m_huni,'(a80)')     (m_titlc(i),          i=1,m_LenInd)
      WRITE(m_huni,'(3d24.16)') (m_b(i), i=1,m_length)
      RETURN
 900  CONTINUE
      WRITE(m_out,*) '+++ GLK_hrout: no space in index'
      WRITE(    *,*) '+++ GLK_hrout: no space in index'
      END

      SUBROUTINE GLK_idopt(id,ch)
*     ************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER     id
      CHARACTER*4 ch
*
      INTEGER     lact,ist,ioplog,ioperb,iopsla,iopsc1,iopsc2,iflag1
*----------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist=m_index(lact,2)
* decoding flags
      CALL GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      IF(ch .EQ.       'LOGY'  ) THEN
* log scale for print
        ioplog = 2
      ELSEIF(ch .EQ.   'ERRO'  ) THEN
* errors in printing/plotting
       ioperb  = 2
      ELSEIF(ch .EQ.   'SLAN'  ) THEN
* slanted line in plotting
       iopsla  = 2
      ELSEIF(ch .EQ.   'YMIN'  ) THEN
       iopsc1  = 2
      ELSEIF(ch .EQ.   'YMAX'  ) THEN
       iopsc2  = 2
      ENDIF
* encoding back
      iflag1   = ioplog+10*iopsla+100*ioperb+1000*iopsc1+10000*iopsc2
      m_b(ist+3) = 9d12 + iflag1*10 +9d0
      END

*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  YFSini                                //
*//////////////////////////////////////////////////////////////////////////////

*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                       Pseudo-Class  GLK                                  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*
*
*//////////////////////////////////////////////////////////////////////////////
*// =======================================================================  //
*// ==========================  _GLK_  ====================================  //
*// ========== General Library of histogramming/ploting utilities =========  //
*// ========== It is similar but not identical to HBOOK and HPLOT =========  //
*// =======================================================================  //
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      Version:    1.30                                    //
*//              Last correction:    January 1999                            //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*//
*//    ********************************************************************
*//    *  History of the package:                                         *
*//    *  MINI-HBOOK writen by S. Jadach, Rutherford Lab. 1976            *
*//    *  Rewritten December 1989 (S.J.)   and in 1997 (S.J.)             *
*//    ********************************************************************
*//
*//  Installation remarks:
*//  (1) printing backslash character depends on F77 compilator,
*//      user may need to modify definition of BS variable in HPLCAP
*//
*//  Usage of the program:
*//  (1) In many cases names and meanings of programs and their
*//      parameters is the same as in original CERN libraries HBOOK
*//  (2) Unlike to original HBOOK and HPLOT, all floating parameters
*//      of the programs are in DOUBLE PRECISION !
*//  (3) GLK stores histograms in DOUBLE PRECISION  and always with
*//      errors. DOUBLE PRECISION  storage is essential for 10**7 events statistics!
*//  (4) Output from GLK is a picture recorded as regular a LaTeX file
*//      with frame and curves/histograms, it is easy to change fonts
*//      add captions, merge plots, etc. by normal editing. Finally,
*//      picture may be inserted in any place into LaTeX source of the
*//      article.
*//  (5) WARNING: two-dimensional histograms are not active!!!
*//  
*//////////////////////////////////////////////////////////////////////////////
*//     List of procedures,  non-user subprograms in brackets                //
*//////////////////////////////////////////////////////////////////////////////
*    SUBR/FUNC       1 PAR. 2 PAR. 3 PAR. 4 PAR. 5 PAR. 6 PAR.
*  ====================================================================
*     (GLK_Initialize) ----   ----    ----   ----   ----   ----
*      GLK_hi          INT    INT     ----   ----   ----   ----
*      GLK_hie         INT    INT     ----   ----   ----   ----
*      GLK_Fil1        INT    DBL     DBL    ----   ----   ----
*      GLK_Fil2        INT    DBL     DBL    DBL    ----   ----
*      GLK_Book1       INT    CHR*80  INT    DBL    DBL    ----
*     (GLK_OptOut)     INT    INT     INT    INT    INT     INT
* (L.F. GLK_Exist)     INT    -----  ------  ----   ----   ----
*      GLK_Idopt       INT    CHR*4   -----  ----   ----   ----
*      GLK_BookFun1    INT    CHR*80   INT   DBL    DBL  DP-FUNC
*      GLK_Idopt       INT    CHR*4   -----  ----   ----   ----
*      GLK_Book2       INT    CHR*80   INT   DBL    DBL     INT  DBL DBL
*      GLK_PrintAll    ---    ----   ----   ----   ----   ----
*      GLK_SetNout     INT    ----   ----   ----   ----   ----
*      GLK_Print       INT    ----   ----   ----   ----   ----
*      GLK_Operat      INT    CHR*1   INT    INT    DBL    DBL
*      GLK_Hinbo1      INT    CHR*8   INT    DBL    DBL    ----
*      GLK_Unpak       INT    DBL(*) CHR*(*) INT    ---    ----
*      GLK_Pak         INT    DBL(*)  ----   ----   ---    ----
*      GLK_Pake        INT    DBL(*)  ----   ----   ---    ----
*      GLK_Range1      INT    DBL     DBL    ----   ---    ----
*      GLK_Hinbo2      INT    INT     DBL    DBL    INT    DBL   DBL
*      GLK_Ymaxim      INT    DBL     ----   ----   ---    ----
*      GLK_Yminim      INT    DBL     ----   ----   ---    ----
*      GLK_Reset       INT   CHR*(*)  ----   ----   ---    ----
*      GLK_Delet       INT     ----   ----   ----   ----   ----
*     (GLK_Copch)     CHR*80 CHR*80  ----   ----   ----   ----
*     (GLK_hadres)     INT    INT   ----   ----   ----   ----
*      GLK_Hrfile      INT   CHR*(*) CHR*(*) ----   ----   ----
*      GLK_Hrout       INT    INT    CHR*8   ----   ----   ----
*      GLK_Hrin        INT    INT     INT    ----   ----   ----
*      GLK_Hrend     CHR*(*) ----    ----   ----   ----   ----
*  *******************  HPLOT entries ******************
*      GLK_PlInt       INT    ----    ----   ----   ----   ----
*      GLK_PlCap       INT    ----    ----   ----   ----   ----
*      GLK_PlEnd       ----   ----    ----   ----   ----   ----
*      GLK_Plot        INT    CHR*1   CHR*1   INT   ----   ----
*     (GLK_Plfram1)    INT      INT     INT  ----   ----   ----
*     (GLK_SAxisX)     INT      DBL     DBL   INT    DBL   ----
*     (GLK_SAxisY)     INT      DBL     DBL   INT    DBL   ----
*     (GLK_PlHist)     INT      INT     DBL   DBL    INT    INT
*     (GLK_PlHis2)     INT      INT     DBL   DBL    INT    INT
*     (GLK_PlCirc)     INT      INT     INT   DBL    DBL    DBL
*     (GLK_aprof)      DBL      INT     DBL  ----   ----   ----
*      GLK_PlSet       INT      DBL    ----  ----   ----   ----
*      GLK_PlTitle     INT    CHR*80   ----  ----   ----   ----
*  *******************  WMONIT entries ******************
*      GLK_WtMon       INT ???
*  *******************************************************************
*                         END OF TABLE
*  *******************************************************************
*          Map of memory for single histogram
*          ----------------------------------
*  (1-7) Header
*  ist +1   mark      9999999999999
*  ist +2   mark      9d12 + id*10 + 9
*  ist +3   iflag1    9d12 + iflag1*10 +9
*  ist +4   iflag2    9d12 + iflag2*10 +9
*  ist +5   scamin    minimum y-scale
*  ist +6   scamax    maximum y-scale
*  ist +7   jdlast    address of the next histogram
*                     from previous history of calls (see hadres)
*          ----------------------------------
*              Binning size informations
*          ----------------------------------
*  One dimensional histogram            Two dimensional histog.
*  -------------------------            ----------------------
*  (8-11) Binning information           (8-15) Binning information
*  ist2 = ist+7
*  ist2 +1    NCHX                          ist2 +5   NCHY
*  ist2 +2      XL                          ist2 +6     YL
*  ist2 +3      XU                          ist2 +7     YU
*  ist2 +4   FACTX                          ist2 +8  FACTY
*
*          ----------------------------------
*             All kind of sums and  maxwt
*          ----------------------------------
*  One dimensional histogram            Two dimensional histog.
*  -------------------------            ----------------------
*  (12-24) Under/over-flow average x    (16-24)
*  ist3 = ist+11
*  ist3 +1   Underflow                     All nine combinations
*  ist3 +2   Normal                        (U,N,O) x (U,N,O)
*  ist3 +3   Overflow                      sum wt only (no errors)
*  ist3 +4   U  sum w**2
*  ist3 +5   N  sum w**2
*  ist3 +6   O  sum w**2
*  ist3 +7   Sum 1
*  ist3 +8   Sum wt*x
*  ist3 +9   Sum wt*x*x
*  ist3 +10  nevzer    (GLK_WtMon)
*  ist3 +11  nevove    (GLK_WtMon)
*  ist3 +12  nevacc    (GLK_WtMon)
*  ist3 +13  maxwt     (GLK_WtMon)
*          ----------------------------------
*           Content of bins including errors
*          ----------------------------------
*  (25 to 24+2*nchx)                     (25 to 24 +nchx*nchy)
*     sum wt and sum wt**2            sum wt only (no errors)
*  ----------------------------------------------------------------
*//////////////////////////////////////////////////////////////////////////////

      SUBROUTINE GLK_Initialize
*     *************************
* First Initialization called from may routines
*     *************************************
      IMPLICIT NONE
*----------------------------------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
*----------------------------------------------------------------------
* Note that backslash definition is varying from one
* instalation/compiler to another, you have to figure out by yourself
* how to fill backslash code into m_BS
ccc      CHARACTER*1 BBS1
ccc      DATA BBS1 /'\\'/    ! IBM or HP with 'f77 +B '
ccc      CHARACTER*1 BBS2
ccc      DATA BBS2 /1H\ /    ! HP  f77 with standard options
*-----------------------------------------------
      INTEGER init,i,k
      DATA init /0/
*-----------------------------------------------
      IF(init .NE. 0) RETURN
      init=1
* default output unit
      m_out=6
      m_length=0
* color
      m_KeyCol=0
* table range
      m_KeyTbr=0
      DO k=1,3
         m_TabRan(k)=1
      ENDDO
*
      DO k=1,80
         m_Color(k:k)=' '
      ENDDO
      m_Color(1:1)='%'
*
      DO i=1,m_idmax
         DO k=1,3
            m_index(i,k)=0
         ENDDO
         DO k=1,80
            m_titlc(i)(k:k)=' '
         ENDDO
      ENDDO
      DO k=1,m_LenmB
         m_b(k)=0d0
      ENDDO
*----------------------------------------------------------------------
**    m_BS = BBS1      ! IBM or HP with 'f77 +B '
**    m_BS = BBS2      ! HP standard options
      m_BS = '\\'      ! 
*----------------------------------------------------------------------
      END

      INTEGER FUNCTION GLK_jadre2(id)
*------------------------------------------------
* Good old version -- but it is very very slow!!!
* In the case of 100 histograms or more.
*------------------------------------------------
      IMPLICIT NONE 
      INCLUDE 'GLK.h'
      INTEGER           id,i
*---------------------------------------
      GLK_jadre2=0
      DO 1 i=1,m_idmax
      IF(m_index(i,1) .EQ. id) goto 2
    1 CONTINUE
* Nothing found.
      RETURN
* Found: id=0 is also legitimate find!!!
    2 GLK_jadre2=i
      END

      SUBROUTINE GLK_ListPrint(mout)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER i,id
      CHARACTER*80 title
      INTEGER             nb,mout
      DOUBLE PRECISION    xmin,xmax
*----------------------------------
      WRITE(mout,*) 
     $'============================================================================================'
      WRITE(mout,*) 
     $'     ID                 TITLE                                                nb, xmin, xmax'
      DO i=1,m_idmax
         id=m_index(i,1)
         IF(id .NE. 0) THEN
            CALL GLK_hinbo1(id,title,nb,xmin,xmax)
            WRITE(mout,'(i8,a,a,i8,2g14.6)') id, '  ', title, nb,xmin,xmax
         ENDIF
      ENDDO
      END


*///////////////////////////////////////////////////////////////////////
*//                New Weight Motoring ToolBox
*//               (replacement for WTmonit etc.)
*//
*//  The tool to monitor very precisely the average weigh
*//  and other features of the weight distribution.
*//  Note that in principle we are vitaly interested in three parts
*//  of the weight distribution:
*//     Underflow (-infty,0)
*//     Regular   (0, WTmax)
*//     Overflow  (WTmax,+infty)
*//  with special emphasis on events with exactly zero weight WT=0d0.
*//  Nevertheless, we split (0, WTmax) range into several bins
*//  in order to be able to visualise the weight distribution.
*//  (Using stardard tools for histogram)
*//
*//
*///////////////////////////////////////////////////////////////////////
      SUBROUTINE GLK_Mbook(idm,title,nnchx,WTmax)
*     ******************************************
*///////////////////////////////////////////////////////////////////////
*//
*//   Booking one entry. Note it is not an ordinary histogram!!!
*//   It works just like GLK_Book1 except that it
*//   has internaly negative id and x_minimum is always zero.
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER idm
      CHARACTER*80 title
      DOUBLE PRECISION   WTmax
*
      LOGICAL GLK_Exist
      INTEGER j,id,nnchx,nchx,lact,lengt2,ist,ist2,ist3
      INTEGER iopsc1, iopsc2, ioperb, ioplog, iopsla
      INTEGER iflag1, iflag2
      INTEGER ityphi
      DOUBLE PRECISION   xl,xu,ddx
*-------------------------------------------------
      CALL GLK_Initialize
      id = -idm
      IF(GLK_Exist(id)) goto 900
      ist=m_length
      CALL GLK_hadres(0,lact)
* Check if there is a free entry in the m_index
      IF(lact .EQ. 0) CALL GLK_Stop1('GLK_Mbook: no space left,id= ',id)
      m_index(lact,1)=id
      m_index(lact,2)=m_length
      m_index(lact,3)=0
* ---------- limits 
      CALL GLK_Copch(title,m_titlc(lact))
      nchx =nnchx
      IF(nchx .GT. m_MaxNb)
     $     CALL GLK_Stop1(' GLK_Mbook: Too many bins ,id= ',id)
      xl   = 0d0
      xu   = WTmax
* ---------- title and bin content ----------
      lengt2 = m_length +2*nchx +m_buf1+1
      IF(lengt2 .GE. m_LenmB)
     $  CALL GLK_Stop1('GLK_Mbook:too litle storage, m_LenmB= ',m_LenmB)
*
      DO j=m_length+1,lengt2+1
         m_b(j) = 0d0
      ENDDO
      m_length=lengt2
*... default flags
      ioplog   = 1
      iopsla   = 1
      ioperb   = 1
      iopsc1   = 1
      iopsc2   = 1
      iflag1   =
     $ ioplog+10*iopsla+100*ioperb+1000*iopsc1+10000*iopsc2
      ityphi   = 3  !!!! <-- new type of histo !!!!
      iflag2   = ityphi
* examples of decoding flags
*      id       = nint(m_b(ist+2)-9d0-9d12)/10
*      iflag1   = nint(m_b(ist+3)-9d0-9d12)/10
*      ioplog = mod(iflag1,10)
*      iopsla = mod(iflag1,100)/10
*      ioperb = mod(iflag1,1000)/100
*      iopsc1 = mod(iflag1,10000)/1000
*      iopsc2 = mod(iflag1,100000)/10000
*      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
*      ityphi = mod(iflag2,10)
*--------- buffer -----------------
* header
      m_b(ist +1)  = 9999999999999d0
      m_b(ist +2)  = 9d12 +     id*10 +9d0
      m_b(ist +3)  = 9d12 + iflag1*10 +9d0
      m_b(ist +4)  = 9d12 + iflag2*10 +9d0
* dummy vertical scale
      m_b(ist +5)  =  -100d0
      m_b(ist +6)  =   100d0
* pointer used to speed up search of histogram address
      m_b(ist +7)  =   0d0
* information on binning
      ist2         = ist+7
      m_b(ist2 +1) = nchx
      m_b(ist2 +2) = xl
      m_b(ist2 +3) = xu
      ddx = xu-xl
      IF(ddx .EQ. 0d0)
     $     CALL GLK_Stop1(' GLK_Mbook:    xl=xu,              id= ',id)
      m_b(ist2 +4) = float(nchx)/ddx
*
* under/over-flow etc.
      ist3       = ist+11
      DO j=1,13
         m_b(ist3 +j)=0d0
      ENDDO
      RETURN
*----------------
 900  CALL GLK_Retu1(' WARNING GLK_Mbook: already exists id= ', id)
      END


      SUBROUTINE GLK_Mfill(idm,Wtm,rn)
*     ********************************
*///////////////////////////////////////////////////////////////////////
*//
*//    filling of M-subpackage entry
*//    simillar as fil1 for 1-dim histo but the storage for error
*//    is now used to store sum for 'partial averages' <wt-xlowedge>
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER idm
      DOUBLE PRECISION  Wtm,rn
      INCLUDE 'GLK.h'
      SAVE
      INTEGER id
      INTEGER lact, ist, ist2, ist3, iflag2, nchx, ityphi
      INTEGER iposx1,ipose1, kposx1, kpose1, kx
      DOUBLE PRECISION   Wt, deltx, factx, xlowedge
      DOUBLE PRECISION   xu, xl, x1, wtmax
*---------------------------------
      id = -idm
      Wt = Wtm
      CALL GLK_hadres(id,lact)
* exit for non-existig histo
      IF(lact .EQ. 0)  
     $     CALL GLK_Stop1('+++GLK_Mfill: nonexisting id= ',id)

      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
* one-dim. histo only
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 3) CALL GLK_Stop1('+++GLK_Mfill: wrong id=  ',id)
      x1 =  Wt
      m_index(lact,3)=m_index(lact,3)+1
* for standard average of x=Wt and its error
      m_b(ist3 +7)  =m_b(ist3 +7)  +1
      m_b(ist3 +8)  =m_b(ist3 +8)  +x1
      m_b(ist3 +9)  =m_b(ist3 +9)  +x1*x1
* filling coordinates
      nchx  = m_b(ist2 +1)
      xl    = m_b(ist2 +2)      !!<--- It was set to zero in book!!!
      xu    = m_b(ist2 +3)
      WtMax = xu
      factx = m_b(ist2 +4)      ! (fact=nchx/(xu-xl)
      deltx = 1d0/factx
      IF(x1 .LT. xl) THEN
* (U)nderflow
         iposx1 = ist3 +1
         ipose1 = ist3 +4
         m_b(iposx1) = m_b(iposx1)  +1d0
         m_b(ipose1) = m_b(ipose1)  +Wt
      ELSEIF(x1 .GT. xu) THEN
* (O)verflow
         iposx1 = ist3 +3
         ipose1 = ist3 +6
         kposx1 = 0
         m_b(iposx1) = m_b(iposx1)  +1d0
         m_b(ipose1) = m_b(ipose1)  +(Wt- WtMax)
      ELSE
* All of (R)egular range (0,WtMax) in one bin
         iposx1 = ist3 +2
         ipose1 = ist3 +5
         m_b(iposx1) = m_b(iposx1)  +1d0
         m_b(ipose1) = m_b(ipose1)  +Wt
* (R)egular bin, the ACTUAL one
         kx = (x1-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kposx1 = ist +m_buf1+kx
         kpose1 = ist +m_buf1+nchx+kx
         xlowedge = deltx*(kx-1)
         m_b(kposx1) = m_b(kposx1)  +1d0
         m_b(kpose1) = m_b(kpose1)  +(Wt-xlowedge)
      ENDIF
*--------------------------------
* Additional goodies:
* maximum weight -- maximum by absolute value but keeping sign
      m_b(ist3+13) = MAX( DABS(m_b(ist3+13)) ,DABS(wt))
      IF(wt .NE. 0d0) m_b(ist3+13)=m_b(ist3+13) *wt/dabs(wt)
* nevzer,nevove,nevacc
      IF(wt .EQ. 0d0)        m_b(ist3+10) =m_b(ist3+10) +1d0
      IF(wt .GT. wtmax)      m_b(ist3+11) =m_b(ist3+11) +1d0
      IF(rn*wtmax .LE. wt)   m_b(ist3+12) =m_b(ist3+12) +1d0
*---
      END   !GLK_Mfill


      SUBROUTINE GLK_MgetAll(idm,
     $     AveWt,ERela, WtSup, AvUnd, AvOve,
     $     Ntot,Nacc,Nneg,Nove,Nzer)
*     ***************************************************************
*///////////////////////////////////////////////////////////////////////
*//
*//   Get all statistics out
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER idm
      DOUBLE PRECISION   AveWt,ERela, WtSup, AvUnd, AvOve
      INTEGER Ntot,Nacc,Nneg,Nove,Nzer
      INCLUDE 'GLK.h'
      SAVE
      INTEGER id,ist,ist2,ist3,lact
      DOUBLE PRECISION   swt,sswt
*--------------------
      id= -idm
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0)
     $     CALL GLK_Stop1('GLK_MgetAll:lack of initialization, id=',id)
      ist    = m_index(lact,2)
      ist2   = ist+7
      ist3   = ist+11
      Ntot   = nint(m_b(ist3 +7))
      swt    =      m_b(ist3 +8)
      sswt   =      m_b(ist3 +9)
      IF(Ntot.LE.0 .OR. swt.EQ.0d0 )  THEN
         AveWt=0d0
         ERela=0d0
      ELSE
         AveWt=swt/DFLOAT(Ntot)
         ERela=sqrt(abs(sswt/swt**2-1d0/float(Ntot)))
      ENDIF
      WtSup  = m_b(ist3 +13)
      AvUnd  = m_b(ist3 +4)/Ntot
      AvOve  = m_b(ist3 +6)/Ntot
      Nneg = m_b(ist3  +1)    ! NB. it is underflow
      Nzer = m_b(ist3 +10)
      Nove = m_b(ist3 +11)
      Nacc = m_b(ist3 +12)
*-----------------------------
*      WRITE(m_out,1003) idm, AveWt, ERela, WtSup
*      WRITE(m_out,1004) Ntot,Nacc,Nneg,Nove,Nzer
* 1003 FORMAT(
*     $  ' ======================= GLK_Mget =========================='
*     $/,'   id            AveWt          ERela            WtSup'
*     $/,    i5,           e17.7,         f15.9,           e17.7)
* 1004 FORMAT(
*     $  ' -----------------------------------------------------------'
*     $/,'        Ntot        Nacc        Nneg        Nove        Nzer'
*     $/,   5i12)
*------------------------------
      END

      SUBROUTINE GLK_MgetAve(id,AveWt,ERela,WtSup)
*///////////////////////////////////////////////////////////////////////
*//
*//   Get averages only and highest weight
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER idm,id
      DOUBLE PRECISION   AveWt, ERela, WtSup, AvUnd, AvOve
      INTEGER Ntot, Nacc, Nneg, Nove, Nzer
*--------------------
      CALL GLK_MgetAll(id,
     $     AveWt,ERela, WtSup, AvUnd, AvOve,
     $     Ntot,Nacc,Nneg,Nove,Nzer)
      END

      SUBROUTINE GLK_MgetNtot(id,Ntot)
*///////////////////////////////////////////////////////////////////////
*//
*//   Get Ntotal only
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER idm,id
      DOUBLE PRECISION   AveWt, ERela, WtSup, AvUnd, AvOve
      INTEGER Ntot, Nacc, Nneg, Nove, Nzer
*--------------------
      CALL GLK_MgetAll(id,
     $     AveWt,ERela, WtSup, AvUnd, AvOve,
     $     Ntot,Nacc,Nneg,Nove,Nzer)
      END

      SUBROUTINE GLK_Mprint(idm)
*///////////////////////////////////////////////////////////////////////
*//
*//   Printout
*//   Note that bin errors have now changed meaning
*//
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER idm,id
      id= -idm
      CALL GLK_Print(id)
      END

      SUBROUTINE GLK_Operat(ida,chr,idb,idc,coef1,coef2)
*     **********************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           ida,idb,idc
      DOUBLE PRECISION  coef1,coef2
      CHARACTER*80      title
      CHARACTER*1       chr
*
      DOUBLE PRECISION  xl,xu
      INTEGER           ista,ista2,ista3,ncha,iflag2a,ityphia,lactb
      INTEGER           k,j,nchc,istc2,istc3,i1,j2,j3,j1,i2,i3,istc,istb2,istb3,nchb
      INTEGER           lacta,id,istb,nchx,iflag2b,ityphib,lactc
*----------------------------------------------------------
      CALL GLK_hadres(ida,lacta)
      IF(lacta .EQ. 0) RETURN
      ista  = m_index(lacta,2)
      ista2 = ista+7
      ista3 = ista+11
      ncha  = m_b(ista2+1)
* check for type
      iflag2a   = nint(m_b(ista+4)-9d0-9d12)/10
      ityphia   = mod(iflag2a,10)
      IF(ityphia .NE. 1) CALL GLK_Stop1('GLK_Operat: 1-dim histos only, id=',id)
*------------------
      CALL GLK_hadres(idb,lactb)
      IF(lactb .EQ. 0) RETURN
      istb  = m_index(lactb,2)
      istb2 = istb+7
      istb3 = istb+11
      nchb  = m_b(istb2+1)
      IF(nchb .NE. ncha) goto 900
* check for type
      iflag2b   = nint(m_b(istb+4)-9d0-9d12)/10
      ityphib   = mod(iflag2b,10)
      IF(ityphib .NE. 1)  CALL GLK_Stop1('GLK_Operat: 1-dim histos only, id=',id)
*------------------
      CALL GLK_hadres(idc,lactc)
      IF(lactc .EQ. 0) THEN
* ...if nonexistent, histo idc is here defined
        CALL GLK_hinbo1(ida,title,nchx,xl,xu)
        CALL GLK_Book1(idc,title,nchx,xl,xu)
        CALL GLK_hadres(idc,lactc)
        istc  = m_index(lactc,2)
*...option copied from ida
        m_b(istc+ 3)= m_b(ista +3)
      ENDIF
*...one nominal entry recorded
      m_index(lactc,3) = 1
*
      istc  =  m_index(lactc,2)
      istc2 =  istc+7
      istc3 =  istc+11
      nchc  =  m_b(istc2+1)
*
      IF(nchc .NE. ncha) goto 900
      IF(ncha .NE. nchb .OR. nchb .NE. nchc) GOTO 900
      DO k=1,ncha+3
         IF(k .GT. ncha) THEN
*     underflow, overflow
            j=k-ncha
            i1 = ista3 +j
            i2 = istb3 +j
            i3 = istc3 +j
            j1 = ista3 +3+j
            j2 = istb3 +3+j
            j3 = istc3 +3+j
         ELSE
*     normal bins
            i1 = ista +m_buf1 +k
            i2 = istb +m_buf1 +k
            i3 = istc +m_buf1 +k
            j1 = ista +m_buf1 +ncha+k
            j2 = istb +m_buf1 +ncha+k
            j3 = istc +m_buf1 +ncha+k
         ENDIF
         IF    (chr .EQ. '+')   THEN
            m_b(i3) =    coef1*m_b(i1) +    coef2*m_b(i2)
            m_b(j3) = coef1**2*m_b(j1) + coef2**2*m_b(j2)
         ELSEIF(chr .EQ. '-')   THEN
            m_b(i3) = coef1*m_b(i1) - coef2*m_b(i2)
            m_b(j3) = coef1**2*m_b(j1) + coef2**2*m_b(j2)
         ELSEIF(chr .EQ. '*')   THEN
            m_b(j3) = (coef1*coef2)**2
     $           *(m_b(j1)*m_b(i2)**2 + m_b(j2)*m_b(i1)**2)
            m_b(i3) = coef1*m_b(i1) * coef2*m_b(i2)
         ELSEIF(chr .EQ. '/')   THEN
            IF(m_b(i2) .EQ. 0d0) THEN
               m_b(i3) = 0d0
               m_b(j3) = 0d0
            ELSE
***               m_b(j3) = (coef1/coef2)**2/m_b(i2)**4           ! problems with overflow
***     $              *(m_b(j1)*m_b(i2)**2 + m_b(j2)*m_b(i1)**2) ! problems with overflow
               m_b(j3) = (coef1/coef2)**2 *m_b(j1) /m_b(i2)**2
     $                  +(coef1/coef2)**2 *m_b(j2) *(m_b(i1)/m_b(i2)**2)**2
               m_b(i3) = (coef1*m_b(i1) )/( coef2*m_b(i2))
            ENDIF
         ELSE
            GOTO 901
         ENDIF
      ENDDO
      RETURN
 900  WRITE(m_out,*) '+++++ GLK_Operat: non-equal no. bins ',ida,idb,idc
      WRITE(    6,*) '+++++ GLK_Operat: non-equal no. bins ',ida,idb,idc
      STOP
 901  WRITE(m_out,*) '+++++ GLK_Operat: wrong chr=',chr
      WRITE(    6,*) '+++++ GLK_Operat: wrong chr=',chr
      STOP
      END


      SUBROUTINE GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
*     ********************************************************
* decoding option flags
*     **********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER    id,ioplog,iopsla,ioperb,iopsc1,iopsc2
      INTEGER    ist,iflag1,lact
*----------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist=m_index(lact,2)
* decoding flags
      iflag1   = nint(m_b(ist+3)-9d0-9d12)/10
      ioplog = mod(iflag1,10)
      iopsla = mod(iflag1,100)/10
      ioperb = mod(iflag1,1000)/100
      iopsc1 = mod(iflag1,10000)/1000
      iopsc2 = mod(iflag1,100000)/10000
      END

      SUBROUTINE GLK_Pak(id,a)
*     ************************
* Loading in histogram content
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  a(*)
*
      INTEGER           lact,ist,ist2,iflag2,ityphi,nch,local,ib,nchy
*----------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) goto 900
      ist  = m_index(lact,2)
      ist2 = ist+7
* 2-dimens histo alowed
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
         nch   = m_b(ist2 +1)
         local = ist+m_buf1
      ELSEIF(ityphi .EQ. 2) THEN
         nchy  = m_b(ist2+5)
         nch   = nch*nchy
         local = ist+m_buf2
      ELSE
         CALL GLK_Stop1('+++GLK_Pak: wrong histo type, id=',id)
      ENDIF
      DO ib=1,nch
         m_b(local +ib) = a(ib)
      ENDDO
* one nominal entry recorded
      m_index(lact,3)  = 1
      RETURN
  900 CONTINUE
      CALL GLK_Stop1('+++GLK_Pak: nonexisting id=',id)
      END

      SUBROUTINE GLK_Pake(id,a)
*     **********************
* Loading in error content
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  a(*)
*
      INTEGER           lact,ist,ist2,nch,iflag2,ityphi
      INTEGER           nb,ib
*---------------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) goto 901
      ist  = m_index(lact,2)
      ist2 = ist+7
      nch=m_b(ist2+1)
* 2-dimens histo NOT alowed
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) GOTO 900
      DO ib=1,nch
         m_b(ist+m_buf1+nch+ib) = a(ib)**2
      ENDDO
      CALL GLK_idopt( id,'ERRO')
      RETURN
  900 CALL GLK_Stop1('+++GLK_Pake: only for 1-dim hist, id=',id)
      RETURN
  901 CALL GLK_Stop1('+++GLK_Pake: nonexisting id=',id)
      END

      SUBROUTINE GLK_PlCap(LtxUnit)
*     ****************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER   LtxUnit,i,k
*---------
      CALL GLK_Initialize
      m_KeyTit= 0
      DO i=1,m_titlen
         DO k=1,80
            m_titch(i)(k:k)=' '
         ENDDO
      ENDDO
*---------
      m_tline = 1
      m_ltx=IABS(LtxUnit)

      IF( ABS(m_lint) .EQ. 0) THEN
* Normal mode, no colors!!!
         WRITE(m_ltx,'(A,A)') m_BS,'documentclass[12pt]{article}'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{html}'
         WRITE(m_ltx,'(A,A)') m_BS,'textwidth  = 16cm'
         WRITE(m_ltx,'(A,A)') m_BS,'textheight = 18cm'
         WRITE(m_ltx,'(A,A)') m_BS,'begin{document}'
         WRITE(m_ltx,'(A)') '  '
      ELSEIF( ABS(m_lint) .EQ. 1) THEN
* For TeX file is used in \input
         WRITE(m_ltx,'(A)') '  '
      ELSEIF( ABS(m_lint) .EQ. 2) THEN
* For one-page plot being input for postrscript
*!!         WRITE(m_ltx,'(A,A)') m_BS,'documentclass[12pt,html]{article}'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'documentclass[12pt,dvips]{seminar}' !<-for colors!!!
         WRITE(m_ltx,'(A,A)') m_BS,'documentclass[12pt,dvips]{article}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{amsmath}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{amssymb}'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{html}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{epsfig}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{epic}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{eepic}'
         WRITE(m_ltx,'(A,A)') m_BS,'usepackage{color}' !<-for colors!!!
*!!         WRITE(m_ltx,'(A,A)') m_BS,'hoffset    = -1in'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'voffset    = -1in'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'textwidth  = 16cm'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'textheight = 16cm'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'oddsidemargin = 0cm'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'topmargin     = 0cm'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'headheight    = 0cm'
*!!         WRITE(m_ltx,'(A,A)') m_BS,'headsep       = 0cm'
         WRITE(m_ltx,'(A,A)') m_BS,'begin{document}'
         WRITE(m_ltx,'(A,A)') m_BS,'pagestyle{empty}'
         WRITE(m_ltx,'(A)') '  '
      ELSE
         CALL GLK_Stop1('+++STOP in GLK_PlInt, wrong m_lint=',m_lint)
      ENDIF
      END

      SUBROUTINE GLK_PlCapt(lines)
*     ****************************
* This routine defines caption and should be called
* before CALL GLK_Plot2, GLK_PlTable or bpltab2
* The matrix CHARACTER*80 lines containes text of the caption ended
* with the last line '% end-of-caption'
      IMPLICIT NONE
      CHARACTER*80 lines(*)
      INCLUDE 'GLK.h'
      SAVE
      INTEGER i
*----------------------------------
      m_KeyTit=0
      DO i=1,m_titlen
         m_titch(i)=lines(i)
         m_KeyTit= m_KeyTit+1
         IF(lines(i) .EQ. '% end-of-caption' ) GOTO 100
      ENDDO
      CALL GLK_Retu1(' WARNING from GLK_PlCapt: to many lines =',m_titlen)
 100  CONTINUE
      END

      SUBROUTINE GLK_PlCirc(kax,kay,nchx,yl,yu,yy)
*     ****************************************
* plots equidistant points, four-point interpolation,
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           kax,kay,nchx
      DOUBLE PRECISION  yl,yu,yy(*)
*
      INTEGER           IX(m_MaxNb),IY(m_MaxNb)
      DOUBLE PRECISION  ai0,dx,aj0,ds,facy,aj,ai
      INTEGER           ipnt,i,iter,ipoin,irad1,irad2
      DOUBLE PRECISION  GLK_AproF
*---------------------------------------------------

* ...various types of line
* ...distance between points is DS, radius of a point is IRAD
      IRAD2=6
      IRAD1=3
* .............
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $  m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(A)') '% ========== plotting primitives =========='
      IF(m_tline .EQ. 1) THEN
*   small filled circle
       DS = 10
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle*{',IRAD1,'}}}'
      ELSEIF(m_tline .EQ. 2) THEN
*   small open circle
       DS = 10
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle{',IRAD1,'}}}'
      ELSEIF(m_tline .EQ. 3) THEN
*   big filled circle
       DS = 20
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle*{',IRAD2,'}}}'
      ELSEIF(m_tline .EQ. 4) THEN
*   big open circle
       DS = 20
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle{',IRAD2,'}}}'
* Other symbols
      ELSEIF(m_tline .EQ. 5) THEN
       DS = 20
       WRITE(m_ltx,'(10A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'makebox(0,0){$',m_BS,'diamond$}}}'
      ELSE
       DS = 20
       WRITE(m_ltx,'(10A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'makebox(0,0){$',m_BS,'star$}}}'
      ENDIF
      FACY = kay/(YU-YL)
* plot first point
      AI  = 0.
      AJ  = (GLK_AproF( (AI/kax)*NCHX+0.5d0, NCHX, YY) -YL)*FACY
      IPNT =1
      IX(IPNT) = INT(AI)
      IY(IPNT) = INT(AJ)
      DX =  DS
      AI0 = AI
      AJ0 = AJ
* plot next points
      DO 100 IPOIN=2,3000
* iteration to get (approximately) equal distance among ploted points
      DO  50 ITER=1,3
      AI  = AI0+DX
      AJ  = (GLK_AproF( (AI/kax)*NCHX+0.5d0, NCHX, YY) -YL)*FACY
      DX  = DX *DS/SQRT(DX**2 + (AJ-AJ0)**2)
  50  CONTINUE
      IF(INT(AJ) .GE. 0.AND.INT(AJ) .LE. kay.AND.INT(AI) .LE. kax) THEN
         IPNT = IPNT+1
         IX(IPNT) = INT(AI)
         IY(IPNT) = INT(AJ)
      ENDIF
      AI0 = AI
      AJ0 = AJ
      IF(INT(AI) .GT. kax) GOTO 101
 100  CONTINUE
 101  CONTINUE
      WRITE(m_ltx,7000) (m_BS,IX(I),IY(I), I=1,IPNT)
7000  FORMAT(4(A1,2HR{,I4,2H}{,I4,1H}:1X ))
      WRITE(m_ltx,'(2A)') m_BS,'end{picture}} % end of plotting line'
* change line-style
      m_tline= m_tline+1
      IF(m_tline .GT. 2) m_tline=1
      END

      SUBROUTINE GLK_PlEnd
*     ********************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
*---------------------------------------------------
* Note that TeX file is used in \input then you may not want
* to have header and \end{document}
      IF( ABS(m_lint) .NE. 1) THEN
         WRITE(m_ltx,'(2A)') m_BS,'end{document}'
      ENDIF
      CLOSE(m_ltx)
      END

      SUBROUTINE GLK_Plfram1(ID,kax,kay)
*     **********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           ID,kax,kay
      CHARACTER*80 title
      DOUBLE PRECISION   TIPSY(20),TIPSX(20)
      DOUBLE PRECISION   XL,DXL,XU,DXU
      INTEGER            ntipy,ntipx,nchx,icont
      DOUBLE PRECISION   yu,yl
      DATA ICONT/0/
*----------------
      ICONT=ICONT+1
      CALL GLK_HINBO1(ID,TITLE,NCHX,DXL,DXU)
      XL = DXL
      XU = DXU
      CALL GLK_RANGE1(ID,YL,YU)

      IF(ICONT .GT. 1) WRITE(m_ltx,'(2A)') m_BS,'newpage'
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(m_ltx,'(2A)') m_BS,'begin{figure}[!ht]'
      WRITE(m_ltx,'(2A)') m_BS,'centering'
*------------------------------!
* General Caption
*------------------------------!
      WRITE(m_ltx,'(4A)') m_BS,'caption{',m_BS,'small'
      IF(M_KEYTIT.EQ.0) THEN
        WRITE(m_ltx,'(A)')     TITLE
      ELSE
        WRITE(m_ltx,'(A)')     m_titch(1)
      ENDIF
      WRITE(m_ltx,'(A)') '}'
*------------------------------!
* Frames and labels
*------------------------------!
      WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
      WRITE(m_ltx,'(4A)') m_BS,'setlength{',m_BS,'unitlength}{0.1mm}'
      WRITE(m_ltx,'(2A)') m_BS,'begin{picture}(1600,1500)'
      WRITE(m_ltx,'(4A)')
     $     m_BS,'put(0,0){',m_BS,'framebox(1600,1500){ }}'
      WRITE(m_ltx,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $    m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $    m_BS,'put(0,0){',m_BS,'framebox( ',kax,',',kay,'){ }}'
      WRITE(m_ltx,'(A)') '% =========== x and y axis ================'
      CALL GLK_SAxisX(kax,XL,XU,NTIPX,TIPSX)
      CALL GLK_SAxisY(kay,YL,YU,NTIPY,TIPSY)
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE GLK_PlFrame(id,kax,kay,chxfmt,chyfmt)
*     ************************************************
      IMPLICIT NONE
      INTEGER id,kax,kay
      CHARACTER chxfmt*(*),chyfmt*(*)
      INCLUDE 'GLK.h'
      SAVE
*---------------------------------------------------
      CHARACTER*80 title
      DOUBLE PRECISION    dxl,dxu,xl,xu,yl,yu
      INTEGER  icont,i,nchx
      DATA icont/0/
*---------------------------------------------------
      icont=icont+1
      CALL GLK_hinbo1(id,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      CALL GLK_Range1(id,yl,yu)
*
      IF(icont .GT. 1) WRITE(m_ltx,'(2A)') m_BS,'newpage'
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)')
     $'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(m_ltx,'(A)')
     $'%%%%%%%%%%%%%%%%%%%%%%GLK_PlFrame%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      IF(ABS(m_lint) .EQ. 2) THEN
         WRITE(m_ltx,'(2A)') m_BS,'noindent'
      ELSE
         WRITE(m_ltx,'(2A)') m_BS,'begin{figure}[!ht]'
         WRITE(m_ltx,'(2A)') m_BS,'centering'
         WRITE(m_ltx,'(2A)') m_BS,'htmlimage{scale=1.4}'
      ENDIF
*------------------------------!
* General Caption
*------------------------------!
      IF(ABS(m_lint) .NE. 2) THEN
         WRITE(m_ltx,'(6A)')
     $        m_BS,'caption{',m_BS,'footnotesize',m_BS,'sf'
         DO i=1,m_KeyTit
            WRITE(m_ltx,'(A)')     m_titch(i)
         ENDDO
         WRITE(m_ltx,'(A)') '}'
      ENDIF
*------------------------------!
* Frames and labels
*------------------------------!
      WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
      WRITE(m_ltx,'(4A)') m_BS,'setlength{',m_BS,'unitlength}{0.1mm}'
      WRITE(m_ltx,'(2A)') m_BS,'begin{picture}(1600,1500)'
      IF( m_lint .LT. 0) THEN
* Big frame usefull for debuging
         WRITE(m_ltx,'(4A)')
     $        m_BS,'put(0,0){',m_BS,'framebox(1600,1500){ }}'
      ENDIF
      WRITE(m_ltx,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $    m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $    m_BS,'put(0,0){',m_BS,'framebox( ',kax,',',kay,'){ }}'
      WRITE(m_ltx,'(A)') '% =========== x and y axis ================'
      CALL GLK_AxisX(kax,xl,xu,chxfmt)
      CALL GLK_AxisY(kay,yl,yu,chyfmt)
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE GLK_PlHis2(kax,kay,nchx,yl,yu,yy,ker,yer)
*     ************************************************
* marks in the midle of the bin
*     **********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      DOUBLE PRECISION  yl,yu,yy(*),yer(*)
      INTEGER           kax,kay,nchx,ker
*
      INTEGER           iy1,ierr,ie,ix1,irad1,irad2,ib
*---------------------------------------------------

      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $ m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(A)') '% ========== plotting primitives =========='
*...various types of mark
      IRAD1= 6
      IRAD2=10
      IF(m_tline .EQ. 1) THEN
*   small filled circle
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle*{',IRAD1,'}}}'
      ELSEIF(m_tline .EQ. 2) THEN
*   small open circle
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle{',IRAD1,'}}}'
      ELSEIF(m_tline .EQ. 3) THEN
*   big filled circle
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle*{',IRAD2,'}}}'
      ELSEIF(m_tline .EQ. 4) THEN
*   big open circle
       WRITE(m_ltx,'(8A,I3,A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'circle{',IRAD2,'}}}'
* Other symbols
      ELSEIF(m_tline .EQ. 5) THEN
       WRITE(m_ltx,'(10A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'makebox(0,0){$',m_BS,'diamond$}}}'
      ELSE
       WRITE(m_ltx,'(10A)')
     $   m_BS,'newcommand{',m_BS,'R}[2]{',
     $   m_BS,'put(#1,#2){',m_BS,'makebox(0,0){$',m_BS,'star$}}}'
      ENDIF
*   error bars
      WRITE(m_ltx,'(8A)')
     $   m_BS,'newcommand{',m_BS,'E}[3]{',
     $   m_BS,'put(#1,#2){',m_BS,'line(0,1){#3}}}'
      DO 100 IB=1,NCHX
      IX1 = NINT(kax*(IB-0.5000d0)/NCHX)
      IY1 = NINT(kay*(YY(IB)-YL)/(YU-YL))
      IF(IY1 .GE. 0.AND.IY1 .LE. kay) WRITE(m_ltx,7000) m_BS,IX1,IY1
      IF(KER .EQ. 1) THEN
        IERR = NINT(kay*((YY(IB)-YER(IB))-YL)/(YU-YL))
        IE   = NINT(kay*YER(IB)/(YU-YL))
        IF(IY1 .GE. 0.AND.IY1 .LE. kay.and.abs(ierr) .LE. 9999
     $       .and.2*ie .LE. 9999) WRITE(m_ltx,8000) m_BS,IX1,IERR,IE*2
      ENDIF
 100  CONTINUE
7000  FORMAT(4(A1,2HR{,I4,2H}{,I4,1H}:1X ))
8000  FORMAT(4(A1,2HE{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}',
     $    ' % end of plotting histogram'
* change line-style
      m_tline= m_tline+1
      IF(m_tline .GT. 6) m_tline=1
      END

      SUBROUTINE GLK_PlHist(kax,kay,nchx,yl,yu,yy,ker,yer)
*     ************************************************
* plotting contour line for histogram
*     ***********************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           kax,kay,nchx,ker
      DOUBLE PRECISION  yl,yu,yy(*),yer(*)
      CHARACTER*80 FMT1
*
      INTEGER           IX0,ix2,idx,ie,ierr,idy,ib,iy0,iy1,ix1
*---------------------------------------------------
      WRITE(m_ltx,'(4A,I4,A,I4,A)')
     $  m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(A)') '% ========== plotting primitives =========='
*...various types of line
      IF(m_tline .EQ. 1) THEN
         WRITE(m_ltx,'(2A)') m_BS,'thicklines '
      ELSE
         WRITE(m_ltx,'(2A)') m_BS,'thinlines '
      ENDIF
*...short macros for vertical/horizontal straight lines
      WRITE(m_ltx,'(8A)')
     $ m_BS,'newcommand{',m_BS,'x}[3]{',m_BS,'put(#1,#2){',
     $ m_BS,'line(1,0){#3}}}'
      WRITE(m_ltx,'(8A)')
     $ m_BS,'newcommand{',m_BS,'y}[3]{',m_BS,'put(#1,#2){',
     $ m_BS,'line(0,1){#3}}}'
      WRITE(m_ltx,'(8A)')
     $ m_BS,'newcommand{',m_BS,'z}[3]{',m_BS,'put(#1,#2){',
     $ m_BS,'line(0,-1){#3}}}'
*   error bars
      WRITE(m_ltx,'(8A)')
     $   m_BS,'newcommand{',m_BS,'e}[3]{',
     $   m_BS,'put(#1,#2){',m_BS,'line(0,1){#3}}}'
      IX0=0
      IY0=0
      DO 100 IB=1,NCHX
      IX1 = NINT(kax*(IB-0.00001)/NCHX)   !ib=7
      IY1 = NINT(kay*(YY(IB)-YL)/(YU-YL)) !iy1=775,while ix0=168,iy0=770
      IDY = IY1-IY0
      IDX = IX1-IX0
      FMT1 = '(2(2A,I4,A,I4,A,I4,A))'
      IF( IDY .GE. 0) THEN
         IF(IY1 .GE. 0.AND.IY1 .LE. kay)
     $   WRITE(m_ltx,FMT1) m_BS,'y{',IX0,'}{',IY0,'}{',IDY,'}',
     $                     m_BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ELSE
         IF(IY1 .GE. 0.AND.IY1 .LE. kay)
     $   WRITE(m_ltx,FMT1) m_BS,'z{',IX0,'}{',IY0,'}{',-IDY,'}',
     $                     m_BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ENDIF
      IX0=IX1
      IY0=IY1
      IF(KER .EQ. 1) THEN
        IX2  = NINT(kax*(IB-0.5000d0)/NCHX)
        IERR = NINT(kay*((YY(IB)-YER(IB))-YL)/(YU-YL))
        IE = NINT(kay*YER(IB)/(YU-YL))
        IF(IY1 .GE. 0.AND.IY1 .LE. kay.and.abs(ierr) .LE. 9999
     $     .and.2*ie .LE. 9999) WRITE(m_ltx,8000) m_BS,IX2,IERR,IE*2
      ENDIF
 100  CONTINUE
8000  FORMAT(4(A1,2He{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}',
     $       ' % end of plotting histogram'
* change line-style
      m_tline= m_tline+1
      IF(m_tline .GT. 2) m_tline=1
      END
*======================================================================
*                End of histograming procedures
*======================================================================



*======================================================================
*               Ploting procedures using LaTeX
*======================================================================

      SUBROUTINE GLK_PlInitialize(Lint,TeXfile)
*----------------------------------------------------------------------
* Lint =0 
*     Normal mode, full LaTeX header
* Lint =1
*     For TeX file is used in \input, no  LaTeX header
* Lint =2
*     LaTeX header for one-page plot used as input for postscript
*
* Negative Lint only for debug, big frame around plot is added.
*----------------------------------------------------------------------
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER Lint,noufig
      CHARACTER*60  TeXfile
*---------------------------------
* Initialize GLK_Plot
      CALL GLK_PlInt(Lint)             ! Define header style
      noufig=11                        ! 
      OPEN(noufig,file=TeXfile)        ! Open LaTeX file
      CALL GLK_PlCap(noufig)           ! Initialize GLK_Plot
      END

      SUBROUTINE GLK_PlInt(Lint)
*     **************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER Lint
*---------------------------------
      m_lint = Lint
      END

      SUBROUTINE GLK_PlKont(kax,kay,nchx,yl,yu,yy,ker,yer)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//             Plotting contour line for histogram (formely PlHis)                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER kax,kay,nchx,ker
      DOUBLE PRECISION   yl, yu, yy(*),yer(*),z0l
      INCLUDE 'GLK.h'
      SAVE
*---------------------------------------------------
      CHARACTER*80 fmt1
      INTEGER  ix0,iy0,ib,ix1,iy1,ie,ierr,ix2,idy,idx
      DOUBLE PRECISION    yib
*---------------------------------------------------
      WRITE(m_ltx,'(4A,I4,A,I4,A)') m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(A)') '% ========== plotting primitives =========='
* Color string, optionaly
      IF(m_KeyCol .EQ. 1) THEN
         WRITE(m_ltx,'(A)') m_Color
         m_KeyCol = 0
      ENDIF
*...short macros for vertical/horizontal straight lines
      WRITE(m_ltx,'(8A)')
     $     m_BS,'newcommand{',m_BS,'x}[3]{',m_BS,'put(#1,#2){', m_BS,'line(1,0){#3}}}'
      WRITE(m_ltx,'(8A)')
     $     m_BS,'newcommand{',m_BS,'y}[3]{',m_BS,'put(#1,#2){', m_BS,'line(0,1){#3}}}'
      WRITE(m_ltx,'(8A)')
     $     m_BS,'newcommand{',m_BS,'z}[3]{',m_BS,'put(#1,#2){', m_BS,'line(0,-1){#3}}}'
*   error bars
      WRITE(m_ltx,'(8A)')
     $     m_BS,'newcommand{',m_BS,'e}[3]{', m_BS,'put(#1,#2){',m_BS,'line(0,1){#3}}}'
* Starting point for the line
      ix0=0
      iy0=0
* Start at Zero line if possible
      z0l = kay*(-yl)/(yu-yl)
      IF( (z0l .GT. 0d0) .AND. (z0l .LT. FLOAT(kay)) )  iy0=z0l
      DO ib=1,nchx
         yib = yy(ib)
         ix1 = NINT(kax*(ib-0.00001d0)/nchx) ! new x
         iy1 = NINT(kay*(yib-yl)/(yu-yl))    ! new y
         iy1 = MIN(MAX(iy1,-1),kay+1)        ! cosmetics
         idx = ix1-ix0                       ! delta x
         idy = iy1-iy0                       ! delta y
         fmt1 = '(2(2a,i4,a,i4,a,i4,a))'
         IF(iy1 .GE. 0 .AND. iy1 .LE. kay) THEN
            IF( idy .GE. 0) THEN             ! up
               WRITE(m_ltx,fmt1) m_BS,'y{',ix0,'}{',iy0,'}{',idy,'}',
     $                           m_BS,'x{',ix0,'}{',iy1,'}{',idx,'}'
            ELSE                             ! down
               WRITE(m_ltx,fmt1) m_BS,'z{',IX0,'}{',IY0,'}{',-idy,'}',
     $                           m_BS,'x{',IX0,'}{',IY1,'}{',idx,'}'
            ENDIF
         ENDIF
         ix0=ix1
         iy0=iy1
         IF(ker .EQ. 1) THEN
            ix2  = NINT(kax*(ib-0.5000d0)/nchx)
            ierr = NINT(kay*((yy(ib)-yer(ib))-yl)/(yu-yl))  ! bottom of error bar
            ie = NINT(kay*yer(ib)/(yu-yl))                  ! total length of error bar
*        Cosmetics
            IF(ierr .LT. 0) THEN
               ie= ie+ierr
               ierr = 0
            ENDIF
            IF( (ierr+2*ie) .GT. kay) THEN
               ie= IABS(kay-ierr)/2
            ENDIF
            IF( (iy1.GE.0).AND.(iy1.LE. kay).AND.(ABS(1d0*ierr).LE.9999d0).AND.(2d0*ie.LE.9999d0) ) 
     $           WRITE(m_ltx,8000) m_BS,ix2,ierr,2*ie
         ENDIF
      ENDDO
8000  FORMAT(4(A1,2He{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}', ' % end of plotting histogram'
* change line-style
      m_tline= m_tline+1
      IF(m_tline .GT. 2) m_tline=1
      END

      SUBROUTINE GLK_PlLabel(lines)
*     *****************************
* This should be envoked after 'CALL GLK_Plot2'
* to add lines of TeX to a given plot
*     ***********************************
      IMPLICIT NONE
      CHARACTER*80 lines(*)
      INCLUDE 'GLK.h'
      SAVE
      INTEGER i
*----------------------------------
      m_KeyTit=0
      DO i=1,m_titlen
         m_titch(i)=lines(i)
         m_KeyTit= m_KeyTit+1
         IF(lines(i) .EQ. '% end-of-label' ) GOTO 100
      ENDDO
      CALL GLK_Retu1(' WARNING from GLK_PlLabel: to many lines =',m_titlen)
 100  CONTINUE
*------------------------------!
*   erase Ending               !
*------------------------------!
      BACKSPACE(m_ltx)
      BACKSPACE(m_ltx)
*
      DO i=1,m_KeyTit
        WRITE(m_ltx,'(A)')     m_titch(i)
      ENDDO
*------------------------------!
*   restore Ending             !
*------------------------------!
      WRITE(m_ltx,'(2A)') m_BS,'end{picture} % close entire picture '
      IF(ABS(m_lint) .EQ. 2) THEN
         WRITE(m_ltx,'(A)') '%====== end of GLK_PlLabel =========='
      ELSE
         WRITE(m_ltx,'(2A)') m_BS,'end{figure}'
      ENDIF
      END

      SUBROUTINE GLK_PlMark(kax,kay,nchx,yl,yu,yy,ker,yer,chmark,chr,chr2,chr3)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                       marks in the midle of the bin                             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     kax,kay,nchx,ker
      DOUBLE PRECISION       yl,yu, yy(*),yer(*)
      CHARACTER*1 chr
      CHARACTER   chmark*(*),chr2*(*),chr3*(*)
*---------------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
      INTEGER    ib,ix1,iy1,ierr,ie
*---------------------------------------------------
      WRITE(m_ltx,'(4A,I4,A,I4,A)') m_BS,'put(300,250){',m_BS,'begin{picture}( ',kax,',',kay,')'
      WRITE(m_ltx,'(A)') '% ===GLK_PlMark: plotting primitives ======'
* Color string, optionaly
      IF(m_KeyCol .EQ. 1) THEN
         WRITE(m_ltx,'(A)') m_Color
         m_KeyCol = 0
      ENDIF
* Plotting symbol
      WRITE(m_ltx,'(10A)') m_BS,'newcommand{',m_BS,chr2  , '}[2]{', m_BS,'put(#1,#2){',chmark,'}}'
* Error bar symbol
      WRITE(m_ltx,'(10A)')
     $   m_BS,'newcommand{',m_BS,chr3  , '}[3]{', m_BS,'put(#1,#2){',m_BS,'line(0,1){#3}}}'

      DO ib=1,nchx
         IF(chr .EQ. '*') THEN
            ix1 = NINT(kax*(ib-0.5000d0)/nchx) ! Midle of bin
         ELSEIF(chr .EQ. 'R') THEN
            ix1 = NINT(kax*(ib*1d0)/nchx)      ! Right edge of bin
         ELSEIF(chr .EQ. 'L') THEN
            ix1 = NINT(kax*(ib-1d0)/nchx)      ! Left edge of bin
         ELSE
            WRITE(6,*) '+++++ plamark: wrong line type:',chr
            RETURN
         ENDIF
         iy1 = NINT(kay*(yy(ib)-yl)/(yu-yl))
         IF(iy1 .GE. 0 .AND. iy1 .LE. kay)
     $   WRITE(m_ltx,'(A,A,A,I4,A,I4,A)')
     $               m_BS,chr2, '{' ,IX1, '}{' ,IY1, '}'
         IF(ker .EQ. 1) THEN
            ierr = NINT(kay*((yy(ib)-yer(ib))-yl)/(yu-yl)) ! bottom of error bar
            ie   = NINT(kay*yer(ib)/(yu-yl))               ! total length of error bar
*        Cosmetics
            IF(ierr .LT. 0) THEN
               ie= ie+ierr
               ierr = 0
            ENDIF
            IF( (ierr+2*ie) .GT. kay) THEN
               ie= IABS(kay-ierr)/2
            ENDIF
            IF((iy1.GE.0) .AND.(iy1.LE.kay) .AND.(ABS(1d0*ierr).LE.9999d0) .AND.(2d0*ie.LE.9999d0))
     $      WRITE(m_ltx,'(A,A,A,I4,A,I5,A,I4,A)')
     $          m_BS, chr3,  '{'  ,IX1, '}{'  ,ierr, '}{'  ,2*ie,   '}'
         ENDIF
      ENDDO
      WRITE(m_ltx,'(3A)') m_BS,'end{picture}}',
     $    ' % end of plotting histogram'
      END


      SUBROUTINE GLK_Plot(id,ch1,ch2,kdum)
*     ************************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      CHARACTER CH1,CH2,CHR
      CHARACTER*80 TITLE
      INTEGER          id,kdum
      DOUBLE PRECISION YY(m_MaxNb),YER(m_MaxNb)
      LOGICAL GLK_EXIST
      INTEGER          idum,kax,kay,ioplog,iopsla,ioperb,iopsc1,iopsc2
      INTEGER          ker,nchx
      DOUBLE PRECISION XL,XU,DXL,DXU,yl,yu
*--------------------------------------------
      DATA CHR /' '/
* RETURN if histo non-existing
      IF(.NOT.GLK_EXIST(ID)) GOTO 900
* ...unpack histogram
      CALL GLK_UNPAK(ID,YY ,'    ',IDUM)
      CALL GLK_UNPAK(ID,YER,'ERRO',IDUM)
      CALL GLK_HINBO1(ID,TITLE,NCHX,DXL,DXU)
      XL = DXL
      XU = DXU
      CALL GLK_RANGE1(ID,YL,YU)
      kax=1200
      kay=1200
      IF(CH1 .EQ. 'S') THEN
* ...superimpose plot
        BACKSPACE(m_ltx)
        BACKSPACE(m_ltx)
      ELSE
* ...new frame only
        CHR=CH1
        CALL GLK_Plfram1(ID,kax,kay)
      ENDIF
      WRITE(m_ltx,'(A)')     '%========== next plot (line) =========='
      WRITE(m_ltx,'(A,I10)') '%==== HISTOGRAM ID=',ID
      WRITE(m_ltx,'(A,A70 )')'% ',TITLE
*...cont. line for functions
      CALL GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb-1
      IF (iopsla .EQ. 2)  CHR='C'
*...suppress GLK_PLOT assignments
      IF (CH2 .EQ. 'B')   CHR=' '
      IF (CH2 .EQ. '*')   CHR='*'
      IF (CH2 .EQ. 'C')   CHR='C'
*...various types of lines
      IF     (CHR .EQ. ' ') THEN
*...contour line used for histogram
          CALL GLK_PlHist(kax,kay,NCHX,YL,YU,YY,KER,YER)
      ELSE IF(CHR .EQ. '*') THEN
*...marks in the midle of the bin
          CALL GLK_PlHis2(kax,kay,NCHX,YL,YU,YY,KER,YER)
      ELSE IF(CHR .EQ. 'C') THEN
*...slanted (dotted) line in plotting non-MC functions
          CALL GLK_PlCirc(kax,kay,NCHX,YL,YU,YY)
      ENDIF
*------------------------------!
* Ending
*------------------------------!
      WRITE(m_ltx,'(2A)') m_BS,'end{picture} % close entire picture '
      WRITE(m_ltx,'(2A)') m_BS,'end{figure}'

      RETURN
  900 CALL GLK_Retu1('+++GLK_PLOT: Nonexistig histo, skipped, id=' ,ID)
      END


      SUBROUTINE GLK_Plot2(id,ch1,ch2,chmark,chxfmt,chyfmt)
*     *****************************************************
* The new, more user-friendly, version of older GLK_Plot
* INPUT:
*    ID          histogram identifier
*    ch1 = ' '   normal new plot
*        = 'S'   impose new plot on previous one
*    ch2 = ' '   ploting line default, contour
*        = '*'   error bars in midle of the bin
*        = 'R'   error bars at Right edge of the bin
*        = 'L'   error bars at Left  edge of the bin
*        = 'C'   slanted continuous smooth line
*    chmark =    TeX symbol for ploting points
*    chxfmt =    format (string) for labeling x-axis
*    chyfmt =    format (string) for labeling y-axis
* Furthermore:
* Captions are defined by means of
*    CALL GLK_PlCapt(capt) before CALL GLK_Plot2
*    where CHARACTER*80 capt(50) is content of
*    caption, line by line, see also comments in GLK_PlCapt routine.
* Additional text as a TeX source text can be appended by means of
*    CALL GLK_PlLabel(lines) after CALL GLK_Plot2
*    where CHARACTER*80 lines(50) is the TeX add-on.
*    This is to be used to decorate plot with
*    any kind marks, special labels and text on the plot.
*
*     ************************************
      IMPLICIT NONE
      INTEGER id
      CHARACTER ch1,ch2,chmark*(*)
      CHARACTER*8 chxfmt,chyfmt
      INCLUDE 'GLK.h'
      SAVE
      DOUBLE PRECISION  yy(m_MaxNb),yer(m_MaxNb)
      CHARACTER*80 title
*---------------------------------------------------------------------
      LOGICAL GLK_Exist
      INTEGER kax,kay,incr,ker,nchx
      INTEGER iopsla,ioplog,ioperb,iopsc1,iopsc2,idum
      DOUBLE PRECISION   dxl,dxu,xu,xl,yu,yl
      CHARACTER chr
      DATA CHR /' '/
* TeX Names of the error-bar command and of the point-mark command
      CHARACTER*1 chre, chrp1
      PARAMETER ( chre = 'E', chrp1= 'R' )
      CHARACTER*2 chrp
* TeX Name of the point-mark command
      CHARACTER*1 chrx(12)
      DATA  chrx /'a','b','c','d','f','g','h','i','j','k','l','m'/
*---------------------------------------------------------------------
* RETURN if histo non-existing
      IF(.NOT.GLK_Exist(id)) GOTO 900
* ...unpack histogram
      CALL GLK_UnPak(id,yy ,'    ',idum)
      CALL GLK_UnPak(id,yer,'ERRO',idum)
      CALL GLK_hinbo1(id,title,nchx,dxl,dxu)
* Header
      kax=1200
      kay=1200
      IF(CH1 .EQ. 'S') THEN
* Superimpose plot
        incr=incr+1
        BACKSPACE(m_ltx)
        BACKSPACE(m_ltx)
      ELSE
* New frame only
        incr=1
        CHR=CH1
        CALL GLK_PlFrame(id,kax,kay,chxfmt,chyfmt)
* The Y-range from first plot is preserved
        CALL GLK_Range1(id,yl,yu)
      ENDIF
* The X-range as in histo
      xl = dxl
      xu = dxu
*
      chrp= chrp1//chrx(incr)
      WRITE(m_ltx,'(A)')    '%=GLK_Plot2:  next plot (line) =========='
      WRITE(m_ltx,'(A,I10)')'%====HISTOGRAM ID=',ID
      WRITE(m_ltx,'(A,A70 )') '% ',TITLE
      CALL GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb-1
* Default line type
      IF (iopsla .EQ. 2) THEN
         CHR='C'
      ELSE
         CHR=' '
      ENDIF
* User defined line-type
      IF (CH2 .EQ. 'B')   CHR=' '
*...marks in the midle of the bin
      IF (CH2 .EQ. '*')   CHR='*'
*...marks on the right edge of the bin
      IF (CH2 .EQ. 'R')   CHR='R'
*...marks on the left edge of the bin
      IF (CH2 .EQ. 'L')   CHR='L'
      IF (CH2 .EQ. 'C')   CHR='C'
*...various types of lines
      IF     (CHR .EQ. ' ') THEN
*...contour line used for histogram
          CALL GLK_PlKont(kax,kay,nchx,yl,yu,yy,ker,yer)
      ELSE IF(CHR .EQ. '*' .OR. CHR .EQ. 'R'.OR. CHR .EQ. 'L') THEN
*...marks on the right/left/midle of the bin
         CALL GLK_PlMark(kax,kay,nchx,yl,yu,yy,ker,yer,chmark,chr,chrp,chre)
      ELSE IF(CHR .EQ. 'C') THEN
*...slanted (dotted) line in plotting non-MC functions
          CALL GLK_PlCirc(kax,kay,nchx,yl,yu,yy)
      ENDIF
*------------------------------!
*        ENDing                !
*------------------------------!
      WRITE(m_ltx,'(2A)') m_BS,'end{picture} % close entire picture '
      IF(ABS(m_lint) .EQ. 2) THEN
         WRITE(m_ltx,'(A)') '%== GLK_Plot2:  end of plot  =========='
      ELSE
         WRITE(m_ltx,'(2A)') m_BS,'end{figure}'
      ENDIF
      RETURN
  900 CALL GLK_Stop1('+++GLK_Plot2: Nonexistig histo, skipped, id= ',ID)
      END


      SUBROUTINE GLK_PLset(ch,xx)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Old style seter, sets type of the ploting mark                         //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      CHARACTER*4 CH
      DOUBLE PRECISION  xx
      INCLUDE 'GLK.h'
      SAVE
*----------------------------------
      IF(CH .EQ. 'DMOD') THEN
        m_tline = NINT(xx)
      ENDIF
      END


      SUBROUTINE GLK_PlTable(Npl,idl,capt,fmt,nch1,incr,npag)
*     ******************************************************
* Tables in TeX, up to 9 columns
* Npl           = numbers of columns/histograms
* idl(1:Npl)    = list of histo id's
* capt(1:Npl+1) = list of captions above each column
* fmt(1:1)      = format to print x(i) in first columb,
*                 h(i) and error he(i) in further columns
* nch1,incr     = raws are printet in the sequence
*                 (h(i),he(i),i=nch1,nbin,incr), nbin is no. of bins.
* npag          = 0 no page eject, =1 with page eject
*     ******************************************************
      IMPLICIT NONE
*--------------- parameters ------------
      INTEGER        Npl,idl(*),nch1,incr,npag
      CHARACTER*(*)  capt(*)
      CHARACTER*(*)  fmt(3)
*-------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
*---------------------------------------------------
      CHARACTER*16 fmt1,fmt2,fmt3
      LOGICAL GLK_Exist
      INTEGER   i,j,k,n,nchx,nplt,idum,id1,id
      INTEGER   iopsc1,ioperb,iopsla,iopsc2,ioplog
      DOUBLE PRECISION     xl,xu,dxl,dxu,xi
      DOUBLE PRECISION     yyy(m_MaxNb),yer(m_MaxNb),bi(m_MaxNb,9),er(m_MaxNb,9)
      CHARACTER*80 title
      CHARACTER*1 Cn(9)
      DATA Cn /'1','2','3','4','5','6','7','8','9'/
*-----------------------------------------------------------------------------
* Return if histo non-existing or to many columns
      IF(.NOT.GLK_EXIST(ID)) GOTO 900
      IF(Npl .GT. 9 )     GOTO 901
      fmt1 = fmt(1)
      fmt2 = fmt(2)
      fmt3 = fmt(3)
*
* npack histograms
      id1=idl(1)
      CALL GLK_hinbo1( id1,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      DO n=1,Npl
        CALL GLK_UnPak( idl(n),yyy ,'    ',idum)
        CALL GLK_UnPak( idl(n),yer ,'ERRO',idum)
        DO k=1,nchx
           bi(k,n)=yyy(k)
           er(k,n)=yer(k)
        ENDDO
      ENDDO
*------------------------------!
*           Header
*------------------------------!
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)') ' '
      WRITE(m_ltx,'(A)') '% ========================================='
      WRITE(m_ltx,'(A)') '% ============= begin table ==============='
      WRITE(m_ltx,'(2A)') m_BS,'begin{table}[!ht]'
      WRITE(m_ltx,'(2A)') m_BS,'centering'
*------------------------------!
* Central Caption
*------------------------------!
      WRITE(m_ltx,'(4A)') m_BS,'caption{',m_BS,'small'
      DO i=1,m_KeyTit
        WRITE(m_ltx,'(A)')     m_titch(i)
      ENDDO
      WRITE(m_ltx,'(A)') '}'
*------------------------------!
* Tabular header
*------------------------------!
      WRITE(m_ltx,'(20A)') m_BS,'begin{tabular}
     $ {|',  ('|c',j=1,Npl+1),  '||}'
*
      WRITE(m_ltx,'(4A)') m_BS,'hline',m_BS,'hline'
*------------------------------!
* Captions in columns
*------------------------------!
      WRITE(m_ltx,'(2A)') capt(1),('&',capt(j+1),j=1,Npl)
*
      WRITE(m_ltx,'(2A)') m_BS,m_BS
      WRITE(m_ltx,'(2A)') m_BS,'hline'
*----------------------------------------!
* Table content
* Note that by default RIGHT EDGE of bin is printed, as necessary for
* cumulative distributions, this can be changed with SLAN option
*----------------------------------------!
      CALL GLK_OptOut(idl(1),ioplog,iopsla,ioperb,iopsc1,iopsc2)
      DO k=nch1,nchx,incr
        xi= dxl + (dxu-dxl)*k/(1d0*nchx)
        IF(iopsla.eq.2) xi= dxl + (dxu-dxl)*(k-0.5d0)/(1d0*nchx)
        IF(ioperb.eq.2) THEN
        WRITE(m_ltx,'(A,'//fmt1//','//Cn(Npl)//'(A,'//fmt2//',A,A,'//fmt3//'),  A)')
     $               '$', xi, ('$ & $', bi(k,j), m_BS, 'pm', er(k,j), j=1,Npl), '$'
        WRITE(m_ltx,'(2A)') m_BS,m_BS
        ELSE
        WRITE(m_ltx,'(A,'//fmt1//','//Cn(Npl)//'(A,'//fmt2//'),  A)')
     $               '$', xi, ('$ & $', bi(k,j), j=1,Npl), '$'
        WRITE(m_ltx,'(2A)') m_BS,m_BS
        ENDIF
      ENDDO
*------------------------------!
* Ending
*------------------------------!
      WRITE(m_ltx,'(4A)') m_BS,'hline',m_BS,'hline'
      WRITE(m_ltx,'(2A)') m_BS,'end{tabular}'
      WRITE(m_ltx,'(2A)') m_BS,'end{table}'
      WRITE(m_ltx,'(A)') '% ============= end   table ==============='
      WRITE(m_ltx,'(A)') '% ========================================='
      IF(npag .NE. 0) WRITE(m_ltx,'(2A)') m_BS,'newpage'

      RETURN
 900  CALL GLK_Retu1('++++ GLK_PlTable: Nonexistig histo id=',ID)
      RETURN
 901  CALL GLK_Retu1('++++ GLK_PlTable: To many columns Nplt=',Nplt)
      END

      SUBROUTINE GLK_PlTable2(Npl,idl,ccapt,mcapt,fmt,chr1,chr2,chr3)
*     ***************************************************************
* Tables in TeX, up to 9 columns
* Npl           = numbers of columns/histograms
* idl(1:Npl)    = list of histo id's
* ccapt(1:Npl+1)= list of column-captions above each column
* mcapt         = multicolumn header, none if mcapt=' ',
* fmt(1:1)      = format to print x(i) in first columb,
*                 h(i) and error he(i) in further columns
* chr1          = ' ' normal default, ='S' the Same table continued
* chr2          = ' ' midle of the bin for x(i) in the first column
*               = 'R' right edge,     ='L' left edge of the bin
* chr3          = ' ' no page eject,  ='E' with page eject at the end.
* Furthermore:
* Captions are defined by means of
*    CALL GLK_PlCapt(capt) before CALL GLK_PlTable2
*    where CHARACTER*80 capt(50) is content of
*    caption, line by line, see also comments in GLK_PlCapt routine.
*
*     ******************************************************
      IMPLICIT NONE
*-------------- parameters--------------
      INTEGER       Npl,idl(*)
      CHARACTER*(*) ccapt(*)
      CHARACTER*(*) fmt(3)
      CHARACTER*1   chr1,chr2,chr3
      CHARACTER*(*) mcapt
*----------------------------------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
*----------------------------------------------------------------------
      CHARACTER*16 fmt1,fmt2,fmt3
      LOGICAL GLK_Exist
      INTEGER   iopsc1,ioperb,iopsla,iopsc2,ioplog
      INTEGER   i,j,k,n,idum,id1,id,nchx,Nplt
      DOUBLE PRECISION     xl,xu,xi,dxu,dxl
      DOUBLE PRECISION     yyy(m_MaxNb),yer(m_MaxNb),bi(m_MaxNb,9),er(m_MaxNb,9)
      CHARACTER*80 title
      CHARACTER*1 Cn(9)
      INTEGER   k1,k2,k3
      DATA Cn /'1','2','3','4','5','6','7','8','9'/
*----------------------------------------------------------------------
* RETURN if histo non-existing or to many columns
      IF(.NOT.GLK_EXIST(ID)) GOTO 900
      IF(Npl .GT. 9 )     GOTO 901
      fmt1 = fmt(1)
      fmt2 = fmt(2)
      fmt3 = fmt(3)
*
* unpack histograms
      id1 = idl(1)
      CALL GLK_hinbo1( id1,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      DO n=1,Npl
         CALL GLK_UnPak( idl(n),yyy ,'    ',idum)
         CALL GLK_UnPak( idl(n),yer ,'ERRO',idum)
         DO k=1,nchx
            bi(k,n)=yyy(k)
            er(k,n)=yer(k)
         ENDDO
      ENDDO

      IF(chr1 .EQ. ' ' ) THEN
*------------------------------!
*           Header
*------------------------------!
         WRITE(m_ltx,'(A)') ' '
         WRITE(m_ltx,'(A)') ' '
         WRITE(m_ltx,'(A)') '% ========================================'
         WRITE(m_ltx,'(A)') '% ============ begin table ==============='
*
         IF(ABS(m_lint) .EQ. 2 ) THEN
            WRITE(m_ltx,'(2A)') m_BS,'noindent'
         ELSE
            WRITE(m_ltx,'(2A)') m_BS,'begin{table}[!ht]'
            WRITE(m_ltx,'(2A)') m_BS,'centering'
         ENDIF
*------------------------------!
* Central Caption
*------------------------------!
         IF(ABS(m_lint) .NE. 2 ) THEN
            WRITE(m_ltx,'(6A)')
     $           m_BS,'caption{',m_BS,'footnotesize',m_BS,'sf'
            DO i=1,m_KeyTit
               WRITE(m_ltx,'(A)')     m_titch(i)
            ENDDO
            WRITE(m_ltx,'(A)') '}'
         ENDIF
*------------------------------!
* Tabular header
*------------------------------!
         WRITE(m_ltx,'(20A)') m_BS,'begin{tabular}
     $        {|',  ('|c',j=1,Npl+1),  '||}'
         WRITE(m_ltx,'(4A)') m_BS,'hline',m_BS,'hline'
*------------------------------!
* Captions in columns
*------------------------------!
         WRITE(m_ltx,'(2A)') ccapt(1),('&',ccapt(j+1),j=1,Npl)
*------------------------------!
* Append previous table
*------------------------------!
      ELSEIF(chr1 .EQ. 'S' ) THEN
         DO i=1,7
            BACKSPACE(m_ltx)
         ENDDO
      ELSE
         WRITE(*,*) ' ++++ GLK_PlTable2: WRONG chr1 ' ,chr1
      ENDIF

      WRITE(m_ltx,'(2A)') m_BS,m_BS
      WRITE(m_ltx,'(2A)') m_BS,'hline'

*------------------------------!
* Optional multicolumn caption
*------------------------------!
      IF(mcapt .NE. ' ') THEN
         WRITE(m_ltx,'(3A,I2,A)') '& ',m_BS,'multicolumn{',Npl,'}{c||}{'
         WRITE(m_ltx,'(3A)') '     ',mcapt, ' }'
         WRITE(m_ltx,'(2A)') m_BS,m_BS
         WRITE(m_ltx,'(2A)') m_BS,'hline'
      ENDIF

*----------------------------------------!
* Table content
* Note that by default RIGHT EDGE of bin is printed, as necessary for
* cumulative distributions, this can be changed with SLAN option
*----------------------------------------!
      CALL GLK_OptOut(idl(1),ioplog,iopsla,ioperb,iopsc1,iopsc2)
*
* table printout can be controlled by  GLK_SetTabRan(i1,i2,i3)
      k1=1
      k2=nchx
      k3=1
      IF( m_KeyTbr .EQ. 1 ) THEN
         k1 = MAX(k1,m_TabRan(1))
         k2 = MIN(k2,m_TabRan(2))
         k3 = MAX(k3,m_TabRan(3))
         m_KeyTbr = 0
      ENDIF
*
      DO k=k1,k2,k3
         IF(chr2 .EQ. 'R') THEN
* right
            xi= dxl + (dxu-dxl)*k/(1d0*nchx)
         ELSEIF(chr2 .EQ. 'L') THEN
* left
            xi= dxl + (dxu-dxl)*(k-1d0)/(1d0*nchx)
         ELSE
* midle
            xi= dxl + (dxu-dxl)*(k-0.5d0)/(1d0*nchx)
         ENDIF
         IF(ioperb.eq.2) THEN
          WRITE(m_ltx,'(A,'//fmt1//','//Cn(Npl)//'(A,'//fmt2//',A,A,'//fmt3//'),  A)')
     $                '$', xi, ('$ & $', bi(k,j), m_BS, 'pm', er(k,j), j=1,Npl), '$'
          WRITE(m_ltx,'(2A)') m_BS,m_BS
         ELSE
          WRITE(m_ltx,'(A,'//fmt1//','//Cn(Npl)//'(A,'//fmt2//'),  A)')
     $                '$', xi, ('$ & $', bi(k,j), j=1,Npl), '$'
          WRITE(m_ltx,'(2A)') m_BS,m_BS
         ENDIF
      ENDDO
*------------------------------!
* Ending
*------------------------------!
      WRITE(m_ltx,'(4A)') m_BS,'hline',m_BS,'hline'
      WRITE(m_ltx,'(2A)') m_BS,'end{tabular}'
      IF(ABS(m_lint) .EQ. 2 ) THEN
         WRITE(m_ltx,'(A)') '% ========================================'
      ELSE
         WRITE(m_ltx,'(2A)') m_BS,'end{table}'
      ENDIF
      WRITE(m_ltx,'(A)') '% ============= end   table =============='
      WRITE(m_ltx,'(A)') '% ========================================'
      IF(chr3 .EQ. 'E') THEN
         WRITE(m_ltx,'(2A)') m_BS,'newpage'
      ELSE
         WRITE(m_ltx,'(A)') '% ========================================'
      ENDIF
      RETURN
 900  CALL GLK_Retu1(' ++++ GLK_PlTable2: Nonexistig histo,id= ',ID)
      RETURN
 901  CALL GLK_Retu1(' ++++ GLK_PlTable2: To many columns Nplt= ',Nplt)
      END

      SUBROUTINE GLK_PlTitle(title)
*     *****************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      CHARACTER*80 title
*----------------------------------------
      m_KeyTit=1
      CALL GLK_Copch(title,m_titch(1))
      END



      SUBROUTINE GLK_Print(id)
*     ***********************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER  id
*
      DOUBLE PRECISION xl,bind,xlow,z,er,avex,dx,fact,ovef,undf,bmax,bmin,deltb
      DOUBLE PRECISION sum,sumw,sumx
      INTEGER          ist,ist2,ist3,idec,k2,k1,kros,j,ind,i,n,i1,ky,nchy,kx,nent,iflag2,lmx
      INTEGER          ioplog,iopsla,ioperb,iopsc1,iopsc2,lact,ker,ityphi,kzer,k,ibn,nchx,istr
      LOGICAL llg
      CHARACTER*1 line(0:105),lchr(22),lb,lx,li,l0
      SAVE lb,lx,li,l0,lchr
      DATA lb,lx,li,l0 /' ','X','I','0'/
      DATA lchr/' ','1','2','3','4','5','6','7','8','9',
     $      'A','B','C','D','E','F','G','H','I','J','K','*'/
*---------------------------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) goto 900
      ist  = m_index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
      idec    = nint(m_b(ist+2)-9d0-9d12)/10
      IF(idec .NE. id) WRITE(6,*) '++++GLK_PRINT: PANIC! ID,IDEC= ',ID,IDEC
      CALL GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker    =  ioperb-1
      lmx = 67
      IF(ker .EQ. 1) lmx=54
      nent=m_index(lact,3)
      IF(nent  .EQ.  0)                          GOTO 901
      WRITE(m_out,1000) id,m_titlc(lact)
 1000 FORMAT('1',/,1X,I9,10X,A)
*
* one-dim. histo
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 2) GOTO 200
      IF( (ityphi.NE.1) .AND. (ityphi.NE.3) )
     $   CALL GLK_Stop1(' GLK_PRINT: wrong histo type, id=',id)

      nchx =   m_b(ist2 +1)
      xl   =   m_b(ist2 +2)
      dx   =  (  m_b(ist2 +3)-m_b(ist2 +2)  )/float(nchx)
* fixing vertical scale
      istr=ist+m_buf1+1
      bmin = m_b(istr)
      bmax = m_b(istr)+1d-5*abs(m_b(istr))  ! problems for single bin case
      DO  ibn=istr,istr+nchx-1
         bmax = max(bmax,m_b(ibn))
         bmin = min(bmin,m_b(ibn))
      ENDDO
      IF(bmin  .EQ.  bmax)                       GOTO 903
      IF(iopsc1 .EQ. 2) bmin=m_b(ist +5)
      IF(iopsc2 .EQ. 2) bmax=m_b(ist +6)
*
      llg=ioplog .EQ. 2
      IF(llg.and.bmin .LE. 0d0) bmin=bmax/10000.d0
*
      deltb = bmax-bmin
      IF(deltb  .EQ.  0d0)                       GOTO 902
      fact  = (lmx-1)/deltb
      kzer  = -bmin*fact+1.00001d0
      IF(llg) fact=(lmx-1)/(log(bmax)-log(bmin))
      IF(llg) kzer=-log(bmin)*fact+1.00001d0
*
      undf = m_b(ist3 +1)
      ovef = m_b(ist3 +3)
      avex = 0d0
      sumw  = m_b(ist3 +8)
      sumx  = m_b(ist3 +9)
      IF(sumw .NE. 0d0) avex = sumx/sumw
      WRITE(m_out,'(4a15      )')  'nent',' sum','bmin','bmax'
      WRITE(m_out,'(i15,3e15.5)')   nent,   sum,  bmin,  bmax
      WRITE(m_out,'(4a15  )')      'undf','ovef','sumw','avex'
      WRITE(m_out,'(4e15.5)')       undf,  ovef,  sumw,  avex
*
      IF(llg) write(m_out,1105)
 1105 format(35x,17hlogarithmic scale)
*
      kzer=max0(kzer,0)
      kzer=min0(kzer,lmx)
      xlow=xl
      do 100 k=1,nchx
* first fill with blanks
      do  45 j=1,105
   45 line(j)  =lb
* THEN fill upper and lower boundry
      line(1)  =li
      line(lmx)=li
      ind=istr+k-1
      bind=m_b(ind)
      bind= max(bind,bmin)
      bind= min(bind,bmax)
      kros=(bind-bmin)*fact+1.0001d0
      IF(llg) kros=log(bind/bmin)*fact+1.0001d0
      k2=max0(kros,kzer)
      k2=min0(lmx,max0(1,k2))
      k1=min0(kros,kzer)
      k1=min0(lmx,max0(1,k1))
      do 50 j=k1,k2
   50 line(j)=lx
      line(kzer)=l0
      z=m_b(ind)
      IF(ker .NE. 1) THEN
        WRITE(m_out,'(a, f7.4,  a, d14.6,  132a1)')
     $             ' ', xlow,' ',     z,' ',(line(i),i=1,lmx)
      ELSE
        er=dsqrt(dabs(m_b(ind+nchx)))
        WRITE(m_out,'(a,f7.4,  a,d14.6,  a,d14.6, 132a1 )')
     $             ' ',xlow,' ',    z,' ',   er,' ',(line(i),i=1,lmx)
      ENDIF
      xlow=xlow+dx
  100 continue
      RETURN
*//////////////////////////////////////////////////////////////////////
*// two dimensional requires complete restoration and tests          //
*//////////////////////////////////////////////////////////////////////
  200 continue
      nchx=m_b(ist+1)
      nchy=m_b(ist+5)
      WRITE(m_out,2000) (lx,i=1,nchy)
 2000 format(1h ,10x,2hxx,100a1)
      do 300 kx=1,nchx
      do 250 ky=1,nchy
      k=ist +m_buf2 +kx+nchx*(ky-1)
      N=m_b(K)+1.99999D0
      n=max0(n,1)
      n=min0(n,22)
      IF(DABS(m_b(k)) .LT. 1D-20) n=1
      line(ky)=lchr(n)
  250 continue
      line(nchy+1)=lx
      i1=nchy+1
      WRITE(m_out,2100) (line(i),i=1,i1)
 2100 format(1h ,10x,1hx,100a1)
  300 continue
      WRITE(m_out,2000) (lx,i=1,nchy)
      RETURN
 900  CALL GLK_Retu1('GLK_PRINT: nonexisting histo',id)
      RETURN
 901  CALL GLK_Retu1('   GLK_PRINT: nent.eq.0',ID)
      RETURN
 902  CALL GLK_Retu1('   GLK_PRINT: wrong plotting limits, id=',id)
      RETURN
 903  CALL GLK_Retu1('   GLK_PRINT: bmin.eq.bmax, id=',id)
      END

      SUBROUTINE GLK_PrintAll
*     ***********************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER i,id

      DO i=1,m_idmax
         id=m_index(i,1)
         IF(id .GT. 0) CALL GLK_Print(id)
      ENDDO
      END


      SUBROUTINE GLK_Range1(id,ylr,yur)
*     *****************************
* provides y-scale for 1-dim plots
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  ylr,yur
*
      INTEGER           lact,ist,ist2,nch,ib,ioplog,iopsla,ioperb,iopsc1,iopsc2
      DOUBLE PRECISION  yl,yu
*-------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist  = m_index(lact,2)
      ist2 = ist+7
      nch  = m_b(ist2 +1)
      yl   = m_b(ist+m_buf1+1)
      yu   = m_b(ist+m_buf1+1)
      DO ib=1,nch
         yl = min(yl,m_b(ist+m_buf1+ib))
         yu = max(yu,m_b(ist+m_buf1+ib))
      ENDDO
* For default range some safety range is added
      yu = yu + 0.05*ABS(yu-yl)
***   yl = yl - 0.05*ABS(yu-yl) ! to be decided later on

* If range was pre-defined then yl,yu are overwritten
      CALL GLK_OptOut(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      IF(iopsc1 .EQ. 2) yl= m_b( ist +5)
      IF(iopsc2 .EQ. 2) yu= m_b( ist +6)
      ylr = yl
      yur = yu
      END


*--------------------------------------------------------------
* ----------- storing histograms in the disk file -------------
*--------------------------------------------------------------

      SUBROUTINE GLK_ReadFile(Dname)
*     ******************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER ninph
      CHARACTER*60 Dname
*-------------------------------------------------
      CALL GLK_Initialize
* Read histograms
      WRITE(    *,*) 'GLK_ReadFile: Reading histos from ', Dname
      WRITE(m_out,*) 'GLK_ReadFile: Reading histos from ', Dname
      ninph = 21
      OPEN(ninph,file=Dname)           ! Open dump-file
      CALL GLK_hrfile(ninph,' ',' ')   ! Define dump-file unit in GKL
      CALL GLK_hrin(0,0,0)             ! Read histos from dump-file
      CALL GLK_hrend(' ')              ! Close dump-file
      END




      SUBROUTINE GLK_RenHst(chak,IdGen,id1,id2)
*     *****************************************
*///////////////////////////////////////////////////////////////////////////
*//   IdGen is ID of special histogram written by M.C. generator itself   //
*//   This routine RE-NORMALIZES to  NANOBARNS or to UNITY                //
*//   CHAK = 'NB  '    normal case [nb]                                   //
*//   CHAK = 'NB10'    log10 x-scale assumed [nb]                         //
*//   CHAK = 'UNIT'    normalization to unity                             //
*//   id2 .NE. id1 required !!!                                           //
*///////////////////////////////////////////////////////////////////////////
*     ***********************************
      IMPLICIT NONE
      CHARACTER*4 CHAK
      INTEGER     IdGen,id1,id2
*----------------------------------------------------------------------
      INCLUDE 'GLK.h'
      SAVE
      CHARACTER*80 TITLE
      DOUBLE PRECISION        xscrnb,ERela,WtSup,tmin,tmax
      DOUBLE PRECISION        swt,fln10,fact
      INTEGER      i,nbt,nevt
      DOUBLE PRECISION    GLK_hi,GLK_hie
*----------------------------------------------------------------------
      IF( id2 .eq. id1) GOTO 900

      CALL GLK_MgetNtot(IdGen,nevt)
      CALL GLK_MgetAve( IdGen,xscrnb,ERela,WtSup)
*
      CALL GLK_hinbo1(id1,title,nbt,tmin,tmax)
      IF(     chak .EQ. 'NB  ') THEN
         fact = nbt*xscrnb/(nevt*(tmax-tmin))
         CALL GLK_Operat(id1,'+',id1,id2, fact, 0d0)
      ELSEIF( chak .EQ. 'NB10') THEN
         fln10 = log(10.)
         fact = nbt*xscrnb/(nevt*(tmax-tmin)*fln10)
         CALL GLK_Operat(id1,'+',id1,id2, fact, 0d0)
      ELSEIF( chak .EQ. 'UNIT') THEN
         swt  = GLK_hi(id1,0)
         DO i=1,nbt+1
            swt   = swt + GLK_hi(id1,i)
         ENDDO
         fact = nbt/((tmax-tmin))/swt
         CALL GLK_Operat(id1,'+',id1,id2, fact, 0d0)
      ELSEIF( chak .EQ. 'UN10') THEN
         swt  = GLK_hi(id1,0)
         DO i=1,nbt+1
            swt   = swt + GLK_hi(id1,i)
         ENDDO
         fact = nbt/((tmax-tmin)*log(10.))/swt
         CALL GLK_Operat(id1,'+',id1,id2, fact, 0d0)
      ELSEIF( chak .EQ. '    ') THEN
         CALL GLK_Operat(id1,'+',id1,id2, 1d0, 0d0)
      ELSE
         WRITE(6,*) '+++++ RENHST: wrong chak=',chak
      ENDIF
*
      RETURN
 900  WRITE(6,*) '+++++ RENHST: ID1=ID2=',ID1
      END

      SUBROUTINE GLK_Reset(id,chd1)
*     **************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER       id
      CHARACTER*(*) chd1
      INTEGER  lact,ist,ist2,iflag2,ityphi,ist3,nchx,nch,local,nchy,j
*-------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .LE. 0) RETURN
      ist  =m_index(lact,2)
      ist2 = ist+7
*
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
* one-dim.
        ist3  = ist+11
        nchx  = m_b(ist2 +1)
        nch   = 2*nchx
        local = ist + m_buf1
      ELSEIF(ityphi .EQ. 2) THEN
* two-dim.
        ist3  = ist+15
        nchx  = m_b(ist2 +1)
        nchy  = m_b(ist2 +5)
        nch   = nchx*nchy
        local = ist +m_buf2
      ELSE
         CALL GLK_Stop1('+++GLK_Reset: wrong type  id=',id)
      ENDIF
* reset miscaelaneous entries and bins
      DO j=ist3+1,local +nch
         m_b(j)    = 0d0
      ENDDO
* and no. of entries in m_index
      m_index(lact,3) = 0
      END

      SUBROUTINE GLK_Retu1(mesage,id)
*     *******************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER id
      CHARACTER*(*) mesage
*-----------------------------
      WRITE(m_out,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(m_out,'(a,a,i10,a)')
     $                          '++ ', mesage, id, ' ++'
      WRITE(m_out,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a,a,i10,a)')
     $                          '++ ', mesage, id, ' ++'
      WRITE(6   ,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      END

      SUBROUTINE GLK_SAxisX(kay,YL,YU,NLT,TIPSY)
*     ***************************************
* plotting x-axis with long and short tips
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           kay,NLT
      DOUBLE PRECISION  YL,YU,TIPSY(20)
*
      INTEGER           LY,JY,n,nts,k,lex
      DOUBLE PRECISION  DY,pds,scmx,p0s,ddys,yy0l,ddyl,pdl,p0l,yy0s
*---------------------------------------------------
      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.4999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)             DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)             DDYL = 10d0**LY*2.0d0
      WRITE(m_ltx,'(A)') '% .......GLK_SAxisX........ '
      WRITE(m_ltx,'(A,I4)') '%  JY= ',JY
*-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.5d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.4999999d0)*DDYS
      P0L = kay*(YY0L-YL)/(YU-YL)
      PDL = kay*DDYL/(YU-YL)
      P0S = kay*(YY0S-YL)/(YU-YL)
      PDS = kay*DDYS/(YU-YL)
      NLT = INT(ABS(YU-YY0L)/DDYL+0.0000001d0)+1
      NTS = INT(ABS(YU-YY0S)/DDYS+0.0000001d0)+1
      DO 41 N=1,NLT
      TIPSY(N) =YY0L+ DDYL*(N-1)
  41  CONTINUE
      WRITE(m_ltx,1000)
     $ m_BS,'multiput('  ,P0L,  ',0)('  ,PDL,  ',0){'  ,NLT,  '}{',
     $ m_BS,'line(0,1){25}}',
     $ m_BS,'multiput('  ,P0S,  ',0)('  ,PDS,  ',0){'  ,NTS,  '}{',
     $ m_BS,'line(0,1){10}}'
      WRITE(m_ltx,1001)
     $ m_BS,'multiput('  ,P0L,  ','  ,kay,  ')('  ,PDL,  ',0){'  ,NLT,
     $ '}{'  ,m_BS,  'line(0,-1){25}}',
     $ m_BS,'multiput('  ,P0S,  ','  ,kay,  ')('  ,PDS,  ',0){'  ,NTS,
     $ '}{'  ,m_BS,  'line(0,-1){10}}'
 1000 FORMAT(2A,F8.2,A,F8.2,A,I4,3A)
 1001 FORMAT(2A,F8.2,A,I4,A,F8.2,A,I4,3A)
* ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001)
      DO 45 N=1,NLT
      K = NINT(kay*(TIPSY(N)-YL)/(YU-YL))
      IF(LEX .LT. 2.AND.LEX .GT. -1) THEN
* ...without exponent
      WRITE(m_ltx,'(2A,I4,5A,F8.3,A)')
     $ m_BS,'put(',K,',-25){',m_BS,'makebox(0,0)[t]{',m_BS,'large $ ',
     $ TIPSY(N), ' $}}'
      ELSE
* ...with exponent
      WRITE(m_ltx,'(2A,I4,5A,F8.3,2A,I4,A)')
     $ m_BS,'put(' ,K, ',-25){',m_BS,'makebox(0,0)[t]{',m_BS,'large $ ',
     $ TIPSY(N)/(10d0**LEX),m_BS,'cdot 10^{',LEX,'} $}}'
      ENDIF
  45  CONTINUE
      END

      SUBROUTINE GLK_SAxisY(kay,yl,yu,nlt,tipsy)
*     ******************************************
* plotting y-axis with long and short tips
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER          kay,nlt
      DOUBLE PRECISION yl,yu,tipsy(20)
*
      DOUBLE PRECISION dy,ddyl,z0l,scmx,yy0s,ddys,yy0l,p0l,pds,p0s,pdl
      INTEGER          ly,jy,n,nts,k,lex
*---------------------------------------------------
      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.49999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)             DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)             DDYL = 10d0**LY*2.0d0
      WRITE(m_ltx,'(A)') '% .......GLK_SAxisY........ '
      WRITE(m_ltx,'(A,I4)') '%  JY= ',JY
*-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.4999999d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.5d0)*DDYS
      P0L = kay*(YY0L-YL)/(YU-YL)
      PDL = kay*DDYL/(YU-YL)
      P0S = kay*(YY0S-YL)/(YU-YL)
      PDS = kay*DDYS/(YU-YL)
      NLT= INT(ABS(YU-YY0L)/DDYL+0.0000001d0) +1
      NTS= INT(ABS(YU-YY0S)/DDYS+0.0000001d0) +1
      DO 41 N=1,NLT
      TIPSY(N) =YY0L+ DDYL*(N-1)
  41  CONTINUE
* plotting tics on vertical axis
      WRITE(m_ltx,1000)
     $ m_BS,'multiput(0,'  ,P0L,  ')(0,'  ,PDL  ,'){'  ,NLT,  '}{',
     $ m_BS,'line(1,0){25}}',
     $ m_BS,'multiput(0,'  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,  '}{',
     $ m_BS,'line(1,0){10}}'
      WRITE(m_ltx,1001)
     $ m_BS,'multiput('  ,kay,  ','  ,P0L,  ')(0,'  ,PDL,  '){'  ,NLT,
     $ '}{',m_BS,'line(-1,0){25}}',
     $ m_BS,'multiput('  ,kay,  ','  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,
     $ '}{',m_BS,'line(-1,0){10}}'
 1000 FORMAT(2A,F8.2,A,F8.2,A,I4,3A)
 1001 FORMAT(2A,I4,A,F8.2,A,F8.2,A,I4,3A)
* ...Zero line if necessary
      Z0L = kay*(-YL)/(YU-YL)
      IF(Z0L .GT. 0D0.AND.Z0L .LT. FLOAT(kay))
     $      WRITE(m_ltx,'(2A,F8.2,3A,I4,A)')
     $       m_BS,'put(0,'  ,Z0L,  '){',m_BS,'line(1,0){'  ,kay,  '}}'
* ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001d0)
      DO 45 N=1,NLT
      K = NINT(kay*(TIPSY(N)-YL)/(YU-YL))
      IF(LEX .LT. 2.AND.LEX .GT. -1) THEN
* ...without exponent
      WRITE(m_ltx,'(2A,I4,5A,F8.3,A)')
     $  m_BS,'put(-25,'  ,K,  '){',m_BS,'makebox(0,0)[r]{',
     $  m_BS,'large $ '  ,TIPSY(N),  ' $}}'
      ELSE
* ...with exponent
      WRITE(m_ltx,'(2A,I4,5A,F8.3,2A,I4,A)')
     $ m_BS,'put(-25,'  ,K,  '){',m_BS,'makebox(0,0)[r]{',
     $ m_BS,'large $ '
     $ ,TIPSY(N)/(10d0**LEX),  m_BS,'cdot 10^{'  ,LEX,  '} $}}'
      ENDIF
  45  CONTINUE
      END

      SUBROUTINE GLK_SetColor(Color)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Sets output unit number                                                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      CHARACTER*(*) Color
*
      CALL GLK_Copch(Color,m_Color)
*
      m_KeyCol = 1              !flag set up
      END

      SUBROUTINE GLK_SetNout(ilun)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Sets output unit number                                                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER ilun

      CALL GLK_Initialize
      m_out=ilun
      END

      SUBROUTINE GLK_SetTabRan(i1,i2,i3)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Sets table range for taple printout in GKL_PlTable2                    //
*//   i1,i2,i3 are lower limit, upper limit and increment                    //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER i1,i2,i3
*
      m_KeyTbr = 1              !flag set up
      m_TabRan(1) = i1
      m_TabRan(2) = i2
      m_TabRan(3) = i3
      END

      SUBROUTINE GLK_SetYmax(id,ymax)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymax
      INTEGER lact,ist
*
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist= m_index(lact,2)
      m_b(ist+6) = ymax
      CALL GLK_idopt(id,'YMAX')
      END

      SUBROUTINE GLK_SetYmin(id,ymin)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymin
      INTEGER lact,ist
*
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) RETURN
      ist= m_index(lact,2)
      m_b(ist+5) = ymin
      CALL GLK_idopt(id,'YMIN')
      END

      SUBROUTINE GLK_SetYminYmax(id,ymin,ymax)
*//////////////////////////////////////////////////////////////////////////////
*//   Sets vertical scale                                                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER id
      DOUBLE PRECISION   ymin,ymax
*
      CALL GLK_SetYmin(id,ymin)
      CALL GLK_SetYmax(id,ymax)
      END

      SUBROUTINE GLK_Stop1(mesage,id)
*     *******************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(m_out,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(m_out,'(a,a,i10,a)')
     $                          '++ ', mesage, id, ' ++'
      WRITE(m_out,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a,a,i10,a)')
     $                          '++ ', mesage, id, ' ++'
      WRITE(6   ,'(a)')
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END

      SUBROUTINE GLK_UnPak(id,a,chd1,idum)
*     *********************************
* getting out histogram content (and error)
* chd1= 'ERRO' is nonstandard option (unpack errors)
*     ***********************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id,idum
      DOUBLE PRECISION  a(*)
      CHARACTER*(*) chd1
*
      INTEGER            lact,ist,ist2,iflag2,ityphi,local,nch,nchy,ib
*------------------------------------------------------------------------
      CALL GLK_hadres(id,lact)
      IF(lact .EQ. 0) goto 900
      ist   = m_index(lact,2)
      ist2  = ist+7
      iflag2   = nint(m_b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
         nch   = m_b(ist2 +1)
         local = ist +m_buf1
      ELSEIF(ityphi .EQ. 2) THEN
         nchy  = m_b(ist2+5)
         nch   = nch*nchy
         local = ist+ m_buf2
      ELSE
         CALL GLK_Stop1('+++GLK_UnPak: check type of histo id=',id)
      ENDIF
      do 10 ib=1,nch
      IF(chd1 .NE. 'ERRO') THEN
* normal bin
        a(ib) = m_b(local+ib)
      ELSE
* error content
        IF(ityphi .EQ. 2) goto 901
        a(ib) = dsqrt( dabs(m_b(local+nch+ib) ))
      ENDIF
   10 continue
      RETURN
 900  CALL GLK_Retu1('+++GLK_UnPak: nonexisting id=',id)
      RETURN
 901  CALL GLK_Retu1('+++GLK_UnPak: no errors, two-dim, id=',id)
      END

      SUBROUTINE GLK_WriteFile(Dname)
*     ******************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      SAVE
      INTEGER nouth
      CHARACTER*60 Dname
*-------------------------------------------------
      CALL GLK_Initialize
* Write all histograms into disk file
      WRITE(    *,*) 'GLK_WriteFile: Writing histos into ', Dname
      WRITE(m_out,*) 'GLK_WriteFile: Writing histos into ', Dname
      nouth=22
      OPEN(nouth,file=Dname)           ! Open dump-file
      CALL GLK_hrfile(nouth,' ',' ')   ! Define dump-file in GLK
      CALL GLK_hrout(0,0,' ')          ! Dump all histos on disk
      CALL GLK_hrend(' ')              ! Close dump-file
      END


      SUBROUTINE GLK_WtMon(mode,id,par1,par2,par3)
*     ********************************************
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!!!  It is now replaces by GKL_M package, see below  !!!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Utility program for monitoring M.C. rejection weights.
* ---------------------------------------------------------
* It is backward compatible with WMONIT except:
*  (1) for id=-1 one  should call as follows:
*      GLK_WtMon(-1,id,0d0,1d0,1d0) or skip initialisation completely!
*  (2) maximum absolute weight is looked for,
*  (3) GLK_Print(-id) prints weight distribution, net profit!
*  (4) no restriction id<100 any more!
* ---------------------------------------------------------
* wt is weight, wtmax is maximum weight and rn is random number.
* IF(mode .EQ. -1) then
*          initalization if entry id,
*        - wtmax is maximum weight used for couting overweighted
*          other arguments are ignored
* ELSEIF(mode .EQ. 0) then
*          summing up weights etc. for a given event for entry id
*        - wt is current weight.
*        - wtmax is maximum weight used for couting overweighted
*          events with wt>wtmax.
*        - rn is random number used in rejection, it is used to
*          count no. of accepted (rn < wt/wtmax) and rejected
*          (wt > wt/wtmax) events,
*          if ro rejection then put rn=0d0.
* ELSEIF(mode .EQ. 1) THEN
*          in this mode wmonit repports on accumulated statistics
*        - averwt= average weight wt counting all event
*        - errela= relative error of averwt
*        - nevtot= total number of accounted events
*        - nevacc= no. of accepted events (rn < wt/wtmax)
*        - nevneg= no. of events with negative weight (wt < 0)
*        - nevzer= no. of events with zero weight (wt = 0d0)
*        - nevove= no. of overweghted events (wt > wtmax)
*          and if you do not want to use cmonit then the value
*          the value of averwt is assigned to wt,
*          the value of errela is assigned to wtmax and
*          the value of wtmax  is assigned to rn in this mode.
* ELSEIF(mode .EQ. 2) THEN
*          all information defined for entry id defined above
*          for mode=2 is just printed of unit nout
* ENDIF
* note that output repport (mode=1,2) is done dynamically just for a
* given entry id only and it may be repeated many times for one id and
* for various id's as well.
*     ************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           mode,id
      DOUBLE PRECISION  par1,par2,par3
* locals
      INTEGER           idg,nevneg,nevzer,nevtot,nevove,nevacc,nbin,lact,ist3,ntot,ist,ist2
      DOUBLE PRECISION  xl,xu,errela,sswt,averwt,wwmax,swt,wt,wtmax,rn
*---------------------------------------------------------------------------
      idg = -id
      IF(id .LE. 0) THEN
           CALL GLK_Stop1(' =====> GLK_WtMon: wrong id= ',id)
      ENDIF
      IF(mode .EQ. -1) THEN
*     *******************
           nbin = nint(dabs(par3))
           IF(nbin .GT. 100) nbin =100
           IF(nbin .EQ. 0)   nbin =1
           xl   =  par1
           xu   =  par2
           IF(xu .LE. xl) THEN
             xl = 0d0
             xu = 1d0
           ENDIF
           CALL GLK_hadres(idg,lact)
           IF(lact .EQ. 0) THEN
              CALL GLK_Book1(idg,' GLK_WtMon $',nbin,xl,xu)
           ELSE
              WRITE(m_out,*) ' WARNING GLK_WtMon: exists, id= ',id
              WRITE(    6,*) ' WARNING GLK_WtMon: exists, id= ',id
           ENDIF
      ELSEIF(mode .EQ. 0) THEN
*     **********************
         CALL GLK_hadres(idg,lact)
           IF(lact .EQ. 0) THEN
              WRITE(m_out,*) ' *****> GLK_WtMon: uninitialized, id= ',id
              WRITE(    6,*) ' *****> GLK_WtMon: uninitialized, id= ',id
              CALL GLK_Book1(idg,' GLK_WtMon $',1,0d0,1d0)
              CALL GLK_hadres(idg,lact)
           ENDIF
           wt   =par1
           wtmax=par2
           rn   =par3
*     standard entries
           CALL GLK_Fil1(idg,wt,1d0)  !!!! <-- principal filling!!!!
*     additional goodies
           ist  = m_index(lact,2)
           ist2 = ist+7
           ist3 = ist+11
*    maximum weight -- maximum by absolute value but keeping sign
           m_b(ist3+13)    = max( dabs(m_b(ist3+13)) ,dabs(wt))
           IF(wt .NE. 0d0) m_b(ist3+13)=m_b(ist3+13) *wt/dabs(wt)
*    nevzer,nevove,nevacc
           IF(wt .EQ. 0d0)        m_b(ist3+10) =m_b(ist3+10) +1d0
           IF(wt .GT. wtmax)      m_b(ist3+11) =m_b(ist3+11) +1d0
           IF(rn*wtmax .LE. wt)   m_b(ist3+12) =m_b(ist3+12) +1d0
      ELSEIF(mode .GE. 1 .OR. mode .LE. 10) THEN
*     *************************************
         CALL GLK_hadres(idg,lact)
           IF(lact .EQ. 0) THEN
              CALL GLK_Stop1(' lack of initialization, id=',id)
           ENDIF
           ist    = m_index(lact,2)
           ist2   = ist+7
           ist3   = ist+11
           ntot   = nint(m_b(ist3 +7))
           swt    =      m_b(ist3 +8)
           sswt   =      m_b(ist3 +9)
           IF(ntot.LE.0 .OR. swt.EQ.0d0 )  THEN
              averwt=0d0
              errela=0d0
           ELSE
              averwt=swt/float(ntot)
              errela=sqrt(abs(sswt/swt**2-1d0/float(ntot)))
           ENDIF
           nevneg = m_b(ist3  +1) !!! it us underflow, xlow=0 assumed!!!
           nevzer = m_b(ist3 +10)
           nevove = m_b(ist3 +11)
           nevacc = m_b(ist3 +12)
           wwmax  = m_b(ist3 +13)
           nevtot = ntot
* Output through parameters
           par1   = averwt
           par2   = errela
           par3   = nevtot
           IF(mode .EQ. 2) THEN
              par1   = nevacc
              par2   = nevneg
              par3   = nevove
           ELSEIF(mode .EQ. 3) THEN
              par1   = nevneg
              par2   = wwmax
           ENDIF
*  no printout for mode <10
*  ************************
           IF(mode .LE. 9) RETURN
           WRITE(m_out,1003) id, averwt, errela, wwmax
           WRITE(m_out,1004) nevtot,nevacc,nevneg,nevove,nevzer
           IF(mode .LE. 10) RETURN
           CALL GLK_Print(idg)
      ELSE
*     ****
           CALL GLK_Stop1('+++GLK_WtMon: wrong mode=',mode)
      ENDIF
*     *****
 1003 FORMAT(
     $  ' ======================= GLK_WtMon ========================='
     $/,'   id           averwt         errela            wwmax'
     $/,    i5,           e17.7,         f15.9,           e17.7)
 1004 FORMAT(
     $  ' -----------------------------------------------------------'
     $/,'      nevtot      nevacc      nevneg      nevove      nevzer'
     $/,   5i12)
      END


      SUBROUTINE GLK_Ymaxim(id,wmax)
*     **************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  wmax
      INTEGER           lact,ist,jd,k
*-------------------------------------------------------
      IF(id .NE. 0) THEN
         CALL GLK_hadres(id,lact)
         IF(lact .EQ. 0) RETURN
         ist= m_index(lact,2)
         m_b(ist+6) =wmax
         CALL GLK_idopt(id,'YMAX')
      ELSE
         DO k=1,m_idmax
            IF(m_index(k,1) .EQ. 0) GOTO 20
            ist=m_index(k,2)
            jd =m_index(k,1)
            m_b(ist+6) =wmax
            CALL GLK_idopt(jd,'YMAX')
         ENDDO
 20      CONTINUE
      ENDIF
      END

      SUBROUTINE GLK_Ymimax(id,wmin,wmax)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER id
      DOUBLE PRECISION  wmin,wmax

      CALL GLK_Yminim(id,wmin)
      CALL GLK_Ymaxim(id,wmax)
      END

      SUBROUTINE GLK_Yminim(id,wmin)
*     ******************************
      IMPLICIT NONE
      INCLUDE 'GLK.h'
      INTEGER           id
      DOUBLE PRECISION  wmin
      INTEGER           lact,ist,k,jd
*---------------------------------------------
      IF(id .NE. 0) THEN
         CALL GLK_hadres(id,lact)
         IF(lact .EQ. 0) RETURN
         ist =m_index(lact,2)
         m_b(ist+5) =wmin
         CALL GLK_idopt(id,'YMIN')
      ELSE
         DO k=1,m_idmax
            IF(m_index(k,1) .EQ. 0) GOTO 20
            ist=m_index(k,2)
            jd =m_index(k,1)
            m_b(ist+5) =wmin
            CALL GLK_idopt(jd,'YMIN')
         ENDDO
 20      CONTINUE
      ENDIF
      END


      SUBROUTINE GPS_Amp1Print(nout,word,Amp1Phot)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Print 1-photon 32 spin amplitudes in a readible format on unit nout           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      DOUBLE COMPLEX    Amp1Phot(2,2,2,2,2)
      CHARACTER*8  word
      INTEGER      j1,j2,j3,j4,k
      DOUBLE PRECISION        Sum
*
      WRITE(nout,'(a)') ' '
      WRITE(nout,'(4a)') '++++++++++++++++++++++++++++++++++',
     $                    ' 1-phot amplits: ',word,
     $                  ' ++++++++++++++++++++++++++++++++++'
      DO j1=1,2
         DO j2=1,2
            WRITE(*,'(a,4(a,4i2,a))')  '     ',
     $           (('{', 3-2*j1, 3-2*j2, 3-2*j3 , 3-2*j4 ,'}  ', j3=1,2),j4=1,2)
         ENDDO
      ENDDO
      DO k=1,2
         DO j1=1,2
            DO j2=1,2
****               WRITE(nout,'(4(a,2f14.8,a))') 
               WRITE(nout,'(4(a,2g14.6,a))') 
     $              (('[',Amp1Phot(j1,j2,j3,j4,k),'] ', j3=1,2),j4=1,2)
            ENDDO
         ENDDO
      ENDDO
      Sum=0d0
      DO k=1,2
         DO j1=1,2
            DO j2=1,2
               DO j3=1,2
                  DO j4=1,2
                     Sum=Sum+ CDABS(Amp1Phot(j1,j2,j3,j4,k))**2
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
***      WRITE(nout,'(a,f20.12)') '++++++++++ Sum= ',Sum
      WRITE(nout,'(a,g20.12)') '++++++++++ Sum= ',Sum
      END


      DOUBLE COMPLEX  FUNCTION GPS_bfacb(sigma,phot,pferm,mass)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   diagonal element of U-matrix for massive fermion = denominator in s-factor    //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   sigma  = photon polarization (+1,-1)                                          //
*//   phot   = photon 4-momentum                                                    //
*//   pferm  = fermion 4-momentum                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER     sigma
      DOUBLE PRECISION       phot(4), pferm(4), mass
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
*---------------------------
      CALL GPS_Initialize
      GPS_bfacb = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1(-sigma,phot,m_b)
     $        *(     GPS_iProd1( -sigma,m_b,pferm) *GPS_iProd1( sigma, pferm, phot)
     $          +mass**2 *GPS_XiProd(   m_b,pferm) *GPS_XiProd(        phot, pferm) )
      END

      DOUBLE COMPLEX  FUNCTION GPS_bfact(sigma,phot,pferm)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//     diagonal element of U-matrix for massive fermion = denominator in s-factor  //
*//     sigma  = photon polarization (+1,-1)                                        //
*//     phot   = photon 4-momentum                                                  //
*//     pferm  = fermion 4-momentum                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     sigma
      DOUBLE PRECISION       phot(4), pferm(4)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
*---------------------------
      CALL GPS_Initialize
      GPS_bfact =  DSQRT(2d0)*GPS_iProd1(sigma,phot,pferm)*GPS_XiProd(pferm,phot)
      END


      SUBROUTINE GPS_Born(KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,AmpBorn)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Used in construction of the hard Non-IR parts: in GPS_HiniPlus, GPS_HfinPlus  //
*//   It is esentialy a simplified clone of GPS_BornPlus                            //
*//                                                                                 //
*//   CAREFUL!!! p_i are sometimes be substituted for photons!!!                    //
*//                                                                                 //
*//   Mass of the final fermion kept exactly.                                       //
*//                                                                                 //
*//   Input:                                                                        //
*//   KFi, Kff = beam and final fermion flavour codes (to define charges)           //
*//   PX       = s-chanel momentum for gamma and Z propagators (not for spinors)    //
*//   pi,mi    are for spinors, not for gamma and Z propagators                     //
*//   p1,m1    =fermion momentum and mass (beam)                                    //
*//   p2,m2    =fermion momentum and mass (beam)                                    //
*//   p3,m3    =fermion momentum and mass final state                               //
*//   p4,m4    =fermion momentum and mass final state                               //
*//                                                                                 //
*//   Output:                                                                       //
*//   AmpBorn   = spin amplitudes                                                   //
*//                                                                                 //
*//   Notes:                                                                        //
*//   Electron mass neglected in spinors, this is why we may use Chisholm!          //
*//   Final fermion mass kept exactly.                                              //
*//   Gamma and Z in s-chanel.                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4)
      DOUBLE PRECISION      m1,m2,m3,m4
      DOUBLE COMPLEX  AmpBorn(2,2,2,2)
*
      DOUBLE PRECISION      T3e,Qe
      DOUBLE PRECISION      T3f,Qf
      DOUBLE COMPLEX  Ve,Vf,Ae,Af,VVcor,GamVPi,ZetVPi
      INTEGER  NCf,NCe
      DOUBLE PRECISION    svarX
*-----------------------------------------------------------------------------
      INTEGER    i,j,k,l
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  PropGam,PropZet
      DOUBLE COMPLEX  s31,s24,s14,s32
      DOUBLE COMPLEX  FFacTT(2),      FFacUU(2)
      DOUBLE COMPLEX  SpinoTT(2,2,2,2),SpinoUU(2,2,2,2)
      DOUBLE COMPLEX  TT,UU
      DOUBLE COMPLEX  GPS_iProd1
      DOUBLE COMPLEX  GPS_iProd2
      DOUBLE PRECISION      dummy
*-----------------------------------------------------------------------------
      CALL GPS_Initialize
*=============================================================
* Get charges, izospin, color
      CALL BornV_GetParticle(KFi, dummy, Qe,T3e,NCe)
      CALL BornV_GetParticle(KFf, dummy, Qf,T3f,NCf)
*=============================================================
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  Hel1 = 3-2*j1
                  Hel2 = 3-2*j2
                  Hel3 = 3-2*j3
                  Hel4 = 3-2*j4
                  TT  = DCMPLX(0d0,0d0)
                  UU  = DCMPLX(0d0,0d0)
                  IF( Hel2 .EQ. -Hel1) THEN   !!! <--helicity conservation imposed
                     s31 = GPS_iProd2(  Hel3, p3, m3,   Hel1, p1, m1) ! t
                     s24 = GPS_iProd2(  Hel2, p2, m2,   Hel4, p4, m4) ! t1
                     s32 = GPS_iProd2(  Hel3, p3, m3,   Hel2, p2,-m2) ! u1
                     s14 = GPS_iProd2(  Hel1, p1,-m1,   Hel4, p4, m4) ! u
                     TT  = s31*s24
                     UU  = s14*s32
                  ENDIF
                  SpinoTT(j1,j2,j3,j4) =  TT
                  SpinoUU(j1,j2,j3,j4) =  UU
               ENDDO
            ENDDO
         ENDDO
      ENDDO
*////////////////////////////////////////////////////////////////////////////////////////////
*//                        ElectroWeak Corrections                                         //
*//   CosThetD = 0d0 is not mistake, we neglect miniscule second order effects only        //
*////////////////////////////////////////////////////////////////////////////////////////////
      svarX=PX(4)**2-PX(3)**2-PX(2)**2-PX(1)**2
      IF(svarX .LE. (ABS(m3)+ABS(m4))**2 ) RETURN
      CALL GPS_EWFFact(KFi,KFf,SvarX,0d0 ,Ve,Vf,Ae,Af,VVcor,GamVPi,ZetVPi)
* Propagators, with s-dependent width
      PropGam =    DCMPLX(  1d0/svarX,  0d0)
      PropZet =    1d0/DCMPLX(svarX-m_MZ**2, m_GammZ*svarX/m_MZ)
* Possibility to switch off Z or gamma, etc.
      IF(m_KeyZet .LE. 0) PropZet =  DCMPLX(0d0)
      IF(m_KeyZet .EQ. 9) PropGam =  DCMPLX(0d0)
      IF(m_KeyZet .EQ.-1) PropZet =  1d0/DCMPLX(SvarX-m_MZ**2, m_GammZ*m_MZ)
* Exponentiate Resonance BigLogs according to Greco et al.
      IF(  m_KeyINT .EQ. 2 .AND. m_KeyISR .NE. 0 .AND.  m_KeyFSR .NE. 0  ) THEN
         PropZet = PropZet * EXP(m_IntReson)
      ENDIF
*////////////////////////////////////////////////////////////////////////////////////////////
*//     Primitives formfactor-type for construction of spin amplitudes                     //
*//     (Ve -Hel1*Ae)*(Vf +Hel1*Af) is expanded because of double-vector f-factor          //
*////////////////////////////////////////////////////////////////////////////////////////////
      DO j1 = 1,2
         Hel1 = 3-2*j1
         FFacTT(j1) = PropGam*GamVPi *Qe*Qf 
     $               +PropZet*ZetVPi *(Ve*Vf*VVCor -Hel1*Ae*Vf +Hel1*Ve*Af -Ae*Af)
         FFacUU(j1) = PropGam*GamVPi *Qe*Qf 
     $               +PropZet*ZetVPi *(Ve*Vf*VVCor -Hel1*Ae*Vf -Hel1*Ve*Af +Ae*Af)
      ENDDO
*////////////////////////////////////////////////////////////////////////////////////////////
*//                     Total result = Spinors*Formfactor                                  //
*////////////////////////////////////////////////////////////////////////////////////////////
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  AmpBorn(j1,j2,j3,j4) =  SpinoTT(j1,j2,j3,j4)* FFacTT(j1)
     $                                   +SpinoUU(j1,j2,j3,j4)* FFacUU(j1)
               ENDDO                  
            ENDDO
         ENDDO
      ENDDO
      END                       !!!GPS_Born!!!

      SUBROUTINE GPS_BornCopy(AmpBorn,AmpBorn2)
*//////////////////////////////////////////////////////////////////////////////////
*//   Copy AmpBorn into AmpBorn2                                                 //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      DOUBLE COMPLEX  AmpBorn(2,2,2,2),AmpBorn2(2,2,2,2)
      INTEGER    j1,j2,j3,j4
*
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  AmpBorn2(j1,j2,j3,j4) = AmpBorn(j1,j2,j3,j4)
               ENDDO                  
            ENDDO
         ENDDO
      ENDDO
      END                       !!!GPS_BornCopy!!!



      SUBROUTINE GPS_BornPlus(Mode,KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,Cfac,Xborn,Xboxy)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Two-stroke version of GPS_Born, optimized for summation over partitions       //
*//   Virtual corrections (boxes vertices) to ms-one are also here!!!               //
*//   Warning! Input masses are TRUE (not signed as in GPS_Born)                    //
*//                                                                                 //
*//   Born spin amplitudes calculated with spinor methods.                          //
*//   Mass of the final fermion kept exactly.                                       //
*//                                                                                 //
*//   Input:                                                                        //
*//   KFi, Kff = beam and final fermion flavour codes (to define charges)           //
*//   PX       = s-chanel momentum for gamma and Z propagators (not for spinors)    //
*//   pi,mi    are for spinors, not for gamma and Z propagators                     //
*//   p1,m1    =fermion momentum and mass (beam)                                    //
*//   p2,m2    =fermion momentum and mass (beam)                                    //
*//   p3,m3    =fermion momentum and mass final state                               //
*//   p4,m4    =fermion momentum and mass final state                               //
*//                                                                                 //
*//   Output:                                                                       //
*//   Born     = spin summed squared amplitudes                                     //
*//                                                                                 //
*//   Common working space:                                                         //
*//   m_AmpBorn   is working space, used by HfinMinus                               //
*//   m_AmpExpo*  is working space, used by HiniPlus, HfinPlus, HfinMinus           //
*//                                                                                 //
*//   Notes:                                                                        //
*//   Electron mass neglected in spinors, this is why we may use Chisholm!          //
*//   Final fermion mass kept exactly.                                              //
*//   Gamma and Z in s-chanel.                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      SAVE                      !!! <-- necessary !!!
*
      INTEGER    Mode,KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4)
      DOUBLE PRECISION      m1,m2,m3,m4,Xborn,Xboxy
*
      DOUBLE PRECISION      MasPhot
      DOUBLE PRECISION      BornSum,BoxySum
      DOUBLE PRECISION      SvarP, SvarQ, SvarX, Svar, s,t,u
      DOUBLE PRECISION      Fleps
*-----------------------------------------------------------------------------
      INTEGER    i,j,k,l
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  Cfac,AmpBorn,AmpBoxy
      DOUBLE COMPLEX  PropGam,PropZet
      DOUBLE COMPLEX  s31,s24,s14,s32
      DOUBLE COMPLEX  FFacTT(2),      FFacUU(2)
      DOUBLE COMPLEX  FFacTG(2),FFacTZ(2),      FFacUG(2),FFacUZ(2)
      DOUBLE COMPLEX  SpinoTT(2,2,2,2), SpinoUU(2,2,2,2)
      DOUBLE COMPLEX  BoxGG(2,2,2,2),   BoxGZ(2,2,2,2)
      DOUBLE COMPLEX  BVR_CBoxGG, BVR_CBoxGZ, BVR_IntIR, BVR_IntReson
      DOUBLE COMPLEX  Coef, IntIR
      DOUBLE COMPLEX  TT,UU
      DOUBLE COMPLEX  GPS_iProd1
      DOUBLE COMPLEX  GPS_iProd2
*-----------------------------------------------------------------------------
* Electroweak
      INTEGER      NCf,NCe
      DOUBLE PRECISION        T3e,Qe
      DOUBLE PRECISION        T3f,Qf
      DOUBLE COMPLEX    Ve,Ae,Vf,Af, VVCor, GamVPi, ZetVPi
      DOUBLE PRECISION        Svar9,CosThetD
*-----------------------------------------------------------------------------
      DOUBLE PRECISION        PP(4),QQ(4),dummy
c[[[[[[[[[[!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c      INTEGER    icont
c      DATA       icont /0/
c]]]]]]]]]]!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*-----------------------------------------------------------------------------
      Fleps =  1d-100
* Pure spinor part, does not depend on PX, Mode introduced to save CPU time
      IF(Mode .EQ. 0) THEN
         DO k=1,4
            PP(k) = p1(k)+p2(k)
            QQ(k) = p3(k)+p4(k)
         ENDDO
         SvarP  = PP(4)**2 - PP(3)**2 - PP(2)**2 - PP(1)**2
         SvarQ  = QQ(4)**2 - QQ(3)**2 - QQ(2)**2 - QQ(1)**2
*=============================================================
* Get charges, izospin, color
         CALL BornV_GetParticle(KFi, dummy, Qe,T3e,NCe)
         CALL BornV_GetParticle(KFf, dummy, Qf,T3f,NCf)
         CALL KK2f_GetMasPhot(MasPhot)
*=============================================================
* Loop below correcponds to
****> CALL GPS_Born(KFi,KFf,PX, p1,Mbeam, p2,-Mbeam,  p3,Massf, p4,-Massf,m_AmpBorn) !!!!<****
         DO j1 = 1,2
            DO j2 = 1,2
               DO j3 = 1,2
                  DO j4 = 1,2
                     Hel1 = 3-2*j1
                     Hel2 = 3-2*j2
                     Hel3 = 3-2*j3
                     Hel4 = 3-2*j4
                     TT  = DCMPLX(0d0,0d0)
                     UU  = DCMPLX(0d0,0d0)
                     IF( Hel2 .EQ. -Hel1) THEN !!! <--helicity conservation imposed
                        s31 = GPS_iProd2(  Hel3, p3, m3,      Hel1, p1, Fleps) ! t
                        s24 = GPS_iProd2(  Hel2, p2,-Fleps,   Hel4, p4,-m4)    ! t1
                        s32 = GPS_iProd2(  Hel3, p3, m3,      Hel2, p2, Fleps) ! u1
                        s14 = GPS_iProd2(  Hel1, p1,-Fleps,   Hel4, p4,-m4)    ! u
                        TT  = s31*s24
                        UU  = s32*s14
                     ENDIF
                     SpinoTT(j1,j2,j3,j4) =  TT
                     SpinoUU(j1,j2,j3,j4) =  UU
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDIF                     !!! Mode.EQ.1
*////////////////////////////////////////////////////////////////////////////////////////////
*//                          Partition (PX) dependent part                                 //
*////////////////////////////////////////////////////////////////////////////////////////////
* Boxes: 
* IR-subtracted, helicity conservation imposed (small mass approx.)
      SvarX = PX(4)**2-PX(3)**2-PX(2)**2-PX(1)**2
      IF(SvarX .LE. (ABS(m3)+ABS(m4))**2 ) RETURN
      CALL KinLib_ThetaD(PX,p1,p2,p3,p4,Svar9,CosThetD)
      s =  SvarX
      t = -s*(1d0-CosThetD)/2d0
      u = -s*(1d0+CosThetD)/2d0
      Coef  = DCMPLX(m_Alfpi*Qe*Qf)
      IF(  m_KeyINT .NE. 0 .AND. m_KeyISR .NE. 0 .AND.  m_KeyFSR .NE. 0  ) THEN
* Virtual 2*(B(t)-B(u)) Intereference IR part to be subtracted from boxes
         IntIR      = Coef*BVR_IntIR(MasPhot,s,t,u)                 !!<- asymetric in (t,u)
         m_IntReson = Coef*BVR_IntReson(MasPhot,m_MZ,m_GammZ,s,t,u) !!<- asymetric in (t,u)
         m_BoxGGtu  = Coef*( BVR_CBoxGG(MasPhot,             s,t,u)) -IntIR
         m_BoxGZtu  = Coef*( BVR_CBoxGZ(MasPhot,m_MZ,m_GammZ,s,t,u)) -IntIR
         m_BoxGGut  = Coef*(-BVR_CBoxGG(MasPhot,             s,u,t)) -IntIR
         m_BoxGZut  = Coef*(-BVR_CBoxGZ(MasPhot,m_MZ,m_GammZ,s,u,t)) -IntIR
* Exponentiate Resonance BigLogs according to Greco et al.
         IF( m_KeyInt .EQ. 2) THEN
            m_BoxGZtu = m_BoxGZtu -m_IntReson
            m_BoxGZut = m_BoxGZut -m_IntReson
         ENDIF
      ELSE
         m_IntReson = DCMPLX(0d0,0d0)
         m_BoxGGtu  = DCMPLX(0d0,0d0)
         m_BoxGGut  = DCMPLX(0d0,0d0)
         m_BoxGZtu  = DCMPLX(0d0,0d0)
         m_BoxGZut  = DCMPLX(0d0,0d0)
      ENDIF
c[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
c[[[[  switching off boxes by hand
c      m_BoxGZtu = DCMPLX(0d0,0d0)
c      m_BoxGZut = DCMPLX(0d0,0d0)
c      m_BoxGGtu = DCMPLX(0d0,0d0)
c      m_BoxGGut = DCMPLX(0d0,0d0)
c]]]]
c]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  Hel1 = 3-2*j1
                  Hel2 = 3-2*j2
                  Hel3 = 3-2*j3
                  Hel4 = 3-2*j4
                  BoxGG(j1,j2,j3,j4) =DCMPLX(0d0,0d0)
                  BoxGZ(j1,j2,j3,j4) =DCMPLX(0d0,0d0)
                  IF((Hel2 .EQ. -Hel1) .AND. (Hel4 .EQ. -Hel3)) THEN !!<--helicity conserv.
                     IF( Hel1*Hel3 .EQ. 1) THEN
                        BoxGG(j1,j2,j3,j4) = m_BoxGGtu
                        BoxGZ(j1,j2,j3,j4) = m_BoxGZtu
                     ELSE
                        BoxGG(j1,j2,j3,j4) = m_BoxGGut
                        BoxGZ(j1,j2,j3,j4) = m_BoxGZut
                     ENDIF
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
      ENDDO
c[[[[[[[[[[[[[!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c      icont=icont+1
c      IF(icont.LE.10) THEN
c         write(m_out,*) ' //////////////////////GPS///////////////////////////////////////'
cc         write(*,'(a,5g22.14)') 'CosThetD= ',CosThetD
cc         write(*,'(a,5g22.14)') 'Sw2= ',m_Sw2
c      ENDIF
c]]]]]]]]]]]]]!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* Propagators, with s-dependent width
      PropGam =    DCMPLX(  1d0/SvarX,  0d0)
      PropZet =    1d0/DCMPLX(SvarX-m_MZ**2, m_GammZ*SvarX/m_MZ)
* Possibility to switch off Z or gamma, etc.
      IF(m_KeyZet .LE. 0) PropZet =  DCMPLX(0d0)
      IF(m_KeyZet .EQ. 9) PropGam =  DCMPLX(0d0)
      IF(m_KeyZet .EQ.-1) PropZet =  1d0/DCMPLX(SvarX-m_MZ**2, m_GammZ*m_MZ)
* Exponentiate Resonance BigLogs according to Greco et al.
      IF(  m_KeyINT .EQ. 2 .AND. m_KeyISR .NE. 0 .AND.  m_KeyFSR .NE. 0  ) THEN
         PropZet = PropZet * EXP(m_IntReson)
      ENDIF
*////////////////////////////////////////////////////////////////////////////////////////////
*//                        ElectroWeak Corrections                                         //    
*////////////////////////////////////////////////////////////////////////////////////////////
      CALL GPS_EWFFact(KFi,KFf,SvarX,CosThetD,Ve,Vf,Ae,Af,VVcor,GamVPi,ZetVPi)
*////////////////////////////////////////////////////////////////////////////////////////////
*//     Primitives formfactor-type for construction of spin amplitudes                     //
*//     For boxes we need separately photon and Z parts                                    //
*//     (Ve -Hel1*Ae)*(Vf +Hel1*Af) is expanded because of double-vector f-factor          //
*////////////////////////////////////////////////////////////////////////////////////////////
      DO j1 = 1,2
         Hel1 = 3-2*j1
         FFacTG(j1) = PropGam*GamVPi *Qe*Qf
         FFacTZ(j1) = PropZet*ZetVPi *(Ve*Vf*VVCor -Hel1*Ae*Vf +Hel1*Ve*Af -Ae*Af)
         FFacUG(j1) = PropGam*GamVPi *Qe*Qf
         FFacUZ(j1) = PropZet*ZetVPi *(Ve*Vf*VVCor -Hel1*Ae*Vf -Hel1*Ve*Af +Ae*Af)
         FFacTT(j1) = FFacTG(j1)+FFacTZ(j1)
         FFacUU(j1) = FFacUG(j1)+FFacUZ(j1)
c[[[[[[[[[[[[[!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c         IF(icont.LE.10) THEN
c            write(m_out,'(a,i5,5g22.14)') 'j1,FFacUU,TT= ',j1,FFacUU(j1),FFacTT(j1)
c         ENDIF
c]]]]]]]]]]]]]!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*//       QED vertex  FFactor F1 minus B-vrtual (IR removed), exact mass terms    //
*///////////////////////////////////////////////////////////////////////////////////
      m_F1ini1 = DCMPLX(0d0)
      m_F1fin1 = DCMPLX(0d0)
      m_F1ini2 = DCMPLX(0d0)
      m_F1fin2 = DCMPLX(0d0)
      IF( m_KeyISR .NE. 0) THEN
         CALL  BVR_MakeF1ini(SvarP,m1,m2,m_Alfpi,Qe,m_F1ini1,m_F1ini2)
      ENDIF
      IF( m_KeyFSR .NE. 0) THEN
         CALL  BVR_MakeF1fin(SvarQ,m3,m4,m_Alfpi,Qf,m_F1fin1,m_F1fin2)
      ENDIF
c[[[[[[[
c      IF( DABS(SvarQ/SvarP-1d0) .LT. 1d-10 ) THEN
c      write(*,*) ' GPS:ABS(SvarQ/SvarP-1)', DABS(SvarQ/SvarP-1d0)
c      write(*,*) ' GPS: alf1 ',CDABS(1+ m_F1ini1)**2*CDABS(1+ m_F1fin1)**2
c      write(*,*) ' GPS: alf2 ',CDABS(1+ m_F1ini2)**2*CDABS(1+ m_F1fin2)**2
ccc      write(*,*) ' GPS: STOP'
ccc      STOP
c      ENDIF
c]]]]]]]

*///////////////////////////////////////////////////////////////////////////////////
*//                      Total result = Spinors*Formfactor                        //
*///////////////////////////////////////////////////////////////////////////////////
      BornSum = 0d0
      BoxySum  = 0d0
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
* Born,  Zero order
                  AmpBorn = SpinoTT(j1,j2,j3,j4)* FFacTT(j1)
     $                     +SpinoUU(j1,j2,j3,j4)* FFacUU(j1)
* Boxes, First order
                  AmpBoxy = SpinoTT(j1,j2,j3,j4)* FFacTG(j1) *BoxGG(j1,j2,j3,j4)
     $                     +SpinoTT(j1,j2,j3,j4)* FFacTZ(j1) *BoxGZ(j1,j2,j3,j4)
     $                     +SpinoUU(j1,j2,j3,j4)* FFacUG(j1) *BoxGG(j1,j2,j3,j4)
     $                     +SpinoUU(j1,j2,j3,j4)* FFacUZ(j1) *BoxGZ(j1,j2,j3,j4)
* Store results
                  m_AmpBorn( j1,j2,j3,j4) = AmpBorn
                  m_AmpBoxy( j1,j2,j3,j4) = AmpBoxy*Cfac
                  m_AmpExpo0(j1,j2,j3,j4) = m_AmpExpo0(j1,j2,j3,j4) 
     $                 +Cfac*AmpBorn                               !!! pure Born
                  m_AmpExpo1(j1,j2,j3,j4) = m_AmpExpo1(j1,j2,j3,j4) 
     $                 +Cfac*AmpBorn*(1 +m_F1ini1)*(1 +m_F1fin1 )  !!! Born, O(alf1) FFactors
     $                 +Cfac*AmpBoxy                               !!! O(alf1) boxes
*///////// new !!!!!!!! in construction !!!!!!! ////////////////////
                  m_AmpExpo2(j1,j2,j3,j4) = m_AmpExpo2(j1,j2,j3,j4) 
     $                 +Cfac*AmpBorn*(1 +m_F1ini2)*(1 +m_F1fin2 )  !!! Born, O(alf2) FFactors
     $                 +Cfac*AmpBoxy                               !!! O(alf1) boxes
*/////////////////////////////
                  BornSum = BornSum +Cfac*AmpBorn*DCONJG(Cfac*AmpBorn)
                  BoxySum = BoxySum +2*DREAL(Cfac*AmpBoxy*DCONJG(Cfac*AmpBorn))
               ENDDO                  
            ENDDO
         ENDDO
      ENDDO
      Xborn = BornSum
      Xboxy = BoxySum
* debug variables for tests
      m_debg( 1) = BornSum
      m_debg( 2) = BoxySum
      END                       !!!GPS_BornPlus!!!

      SUBROUTINE GPS_BornPrint(nout,Mode)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Printout of Born spin amplitudes ina a nice format                      //
*//   Mode=0    prints AmpBorn, principal Born spin amplitudes                //
*//   Mode=1,2  for test printouts (to be kicked out!!!!!)                    //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER nout,Mode
*
      INTEGER j1,j2,j3,j4
*----------------------------------------
      WRITE(nout,*) ' '
      WRITE(nout,'(5a)') '++++++++++++++++++++++++++++++++++++',
     $                        ' Born spin amplitudes ',
     $                   '++++++++++++++++++++++++++++++++++++'
      DO j1=1,2
         DO j2=1,2
            WRITE(nout,'(a,4(a,4i2,a))')  '     ',
     $           (('{', 3-2*j1, 3-2*j2, 3-2*j3 , 3-2*j4 ,'}  ', j3=1,2),j4=1,2)
         ENDDO
      ENDDO
      DO j1=1,2
         DO j2=1,2
            IF(Mode .EQ. 0) THEN
               WRITE(nout,'(4(a,2f10.6,a))') 
     $              (('[',m_AmpBorn(j1,j2,j3,j4),'] ', j3=1,2),j4=1,2)
            ELSEIF(Mode .EQ. 1) THEN
               WRITE(nout,'(4(a,2f10.6,a))') 
     $              (('[',m_AmpBorn1(j1,j2,j3,j4),'] ', j3=1,2),j4=1,2)
            ELSEIF(Mode .EQ. 2) THEN
               WRITE(nout,'(4(a,2f10.6,a))') 
     $              (('[',m_AmpBorn2(j1,j2,j3,j4),'] ', j3=1,2),j4=1,2)
            ENDIF
         ENDDO
      ENDDO
      WRITE(nout,'(120i1)') (mode, j1=1,91)
      END


      SUBROUTINE GPS_BornSimple(KFi,KFf,svar,costhe,Born)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Simple Born similar as in BornV                                         //
*//   Limitation: final mass terms exact for photon exchange!                 //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER  KFi,KFf
      DOUBLE PRECISION    svar,costhe
      DOUBLE PRECISION    Born
*
      DOUBLE PRECISION    ss,T3e,Qe,deno,Ve,Ae
      DOUBLE PRECISION    ye,yf,xf,rechi,xe,amx2
      DOUBLE PRECISION    thresh,ff0,ff1,chi2
      DOUBLE PRECISION    t3f,af,vf,sum,qf
      DOUBLE PRECISION    Massf,Mbeam
      DOUBLE PRECISION    BWD
      INTEGER  NCf,NCe
      DOUBLE PRECISION    BetaFin
*-----------------------------------------------------------------
      CALL GPS_Initialize
      CALL BornV_GetParticle(KFi, Mbeam, Qe,T3e,NCe)
      CALL BornV_GetParticle(KFf, Massf,Qf,T3f,NCf)

      IF(abs(costhe) .GT. 1d0) WRITE(*,*) ' BornV: costhe=',costhe

      ss = svar
      amx2=4d0*Massf**2/svar
* Z and gamma couplings to beams (electrons)
      deno  = 4d0*sqrt(m_Sw2*(1d0-m_Sw2))
      Ve    = (2*T3e -4*Qe*m_Sw2)/deno
      Ae    =  2*T3e             /deno
      Vf    = (2*T3f -4*Qf*m_Sw2)/deno
      Af    =  2*T3f             /deno

      IF(m_KeyZet .LE. 0) THEN
         Ve=0d0
         Ae=0d0
      ENDIF
      IF(m_KeyZet .EQ. 9) THEN
         Qe=0d0
         Qf=0d0
      ENDIF
      BWD = (ss-m_MZ**2)**2 + (m_GammZ*ss/m_MZ)**2
      IF(m_KeyZet .EQ.-1) BWD = (ss-m_MZ**2)**2 + (m_GammZ*m_MZ)**2
      chi2 = ss**2        /BWD
      rechi=(ss-m_MZ**2)*ss /BWD
      xe= Ve**2 +Ae**2
      xf= Vf**2 +Af**2
      ye= 2*Ve*Ae
      yf= 2*Vf*Af
      ff0= qe**2*qf**2 +2*rechi*qe*qf*Ve*Vf +chi2*xe*xf
      ff1=             +2*rechi*qe*qf*Ae*Af +chi2*ye*yf
      Born    = (1d0+ costhe**2 +amx2*(1d0-costhe**2))*ff0 +2d0*costhe*ff1
*     Colour factor
      Born = NCf*Born

      thresh = BetaFin
      IF(    svar .LE.  4d0*Massf**2) THEN
         thresh=0d0
      ELSE
         BetaFin = SQRT(1d0 -4d0*Massf**2/svar)
         thresh  = BetaFin
      ENDIF
c[[[
c      thresh=1d0
c]]]
      Born= Born*thresh
      END                       !!!! GPS_BornSimple

      SUBROUTINE GPS_BornSumSq(AmpBorn,Sum)
*//////////////////////////////////////////////////////////////////////////////////
*//   Sum up Born amplitudes squared                                             //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      DOUBLE COMPLEX  AmpBorn(2,2,2,2)
      DOUBLE PRECISION      Sum
*
      INTEGER    j1,j2,j3,j4
*----------------------------------
      Sum = 0d0
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  Sum = Sum +AmpBorn(j1,j2,j3,j4)*DCONJG(AmpBorn(j1,j2,j3,j4))
               ENDDO                  
            ENDDO
         ENDDO
      ENDDO
      END                       !!!GPS_BornSumSq!!!


      SUBROUTINE GPS_BornZero(AmpBorn)
*//////////////////////////////////////////////////////////////////////////////////
*//   Set AmpBorn to zero                                                        //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      DOUBLE COMPLEX  AmpBorn(2,2,2,2)
      INTEGER    j1,j2,j3,j4
*
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  AmpBorn(j1,j2,j3,j4) = DCMPLX(0d0,0d0)
               ENDDO                  
            ENDDO
         ENDDO
      ENDDO
      END                       !!!GPS_BornZero!!!

      SUBROUTINE GPS_BPrint(nout,word,AmpBorn)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Printout of Born 16 spin amplitudes in  a nice format                   //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER      nout
      CHARACTER*8  word
      DOUBLE COMPLEX    AmpBorn(2,2,2,2)
      DOUBLE PRECISION        Sum
*
      INTEGER     j1,j2,j3,j4
*----------------------------------------
      WRITE(nout,'(a)') ' '
      WRITE(nout,'(4a)') '+++++++++++++++++++++++++++++++++++++++++++++',
     $                             ' Born amplits: ', word,
     $                  ' +++++++++++++++++++++++++++++++++++++++++++++'
***      DO j1=1,2
***         DO j2=1,2
***            WRITE(*,'(a,4(a,4i2,a))')  '     ',
***     $           (('{', 3-2*j1, 3-2*j2, 3-2*j3 , 3-2*j4 ,'}  ', j3=1,2),j4=1,2)
***         ENDDO
***      ENDDO
      DO j1=1,2
         DO j2=1,2
*@@@@       WRITE(nout,'(4(a,2f10.6,a))') 
            WRITE(nout,'(4(a,2g14.6,a))') 
     $           (('[',AmpBorn(j1,j2,j3,j4),'] ', j3=1,2),j4=1,2)
         ENDDO
      ENDDO
      Sum=0d0
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Sum=Sum+CDABS(AmpBorn(j1,j2,j3,j4))**2
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      WRITE(nout,'(a,g20.12)') '++++++++++ Sum= ',Sum
      END


      SUBROUTINE GPS_EWFFact(KFi,KFf,Svar,CosThetD,Ve,Vf,Ae,Af,VVcor,GamVPi,ZetVPi)
*////////////////////////////////////////////////////////////////////////////////////////////
*//                        ElectroWeak Corrections                                         //    
*//  They are in Vector Couplings (multiplied by correcting f-factors)                     //
*//  Because of cost(theta) depenedence of WW boxes we need to define CosThetD variable    //
*////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
* Input
      INTEGER    KFi,KFf
      DOUBLE PRECISION      Svar,CosThetD
* Output
      DOUBLE COMPLEX    Ve,Vf,Ae,Af,VVcor,GamVPi,ZetVPi
* Local
      INTEGER      NCf,NCe
      DOUBLE PRECISION        T3e,Qe
      DOUBLE PRECISION        T3f,Qf
      DOUBLE COMPLEX    GSW(100)
      DOUBLE COMPLEX    RhoEW, VPgamma, CorEle, CorFin, CorEleFin, VVCef 
      DOUBLE PRECISION        Deno,  dummy
*===============================================================================
* Get charges, izospin, color
      CALL BornV_GetParticle(KFi, dummy, Qe,T3e,NCe)
      CALL BornV_GetParticle(KFf, dummy, Qf,T3f,NCf)
*
******IF( m_KeyElw .EQ. 0 .OR.  CosThetD .EQ. 0d0 ) THEN   !!! TEST TEST TEST
      IF( m_KeyElw .EQ. 0 ) THEN
* Vacuum polarization factors
         GamVPi = DCMPLX(1d0)
         ZetVPi = DCMPLX(1d0)
         VVCor  = DCMPLX(1d0)
* Couplings costants
         Deno   = DSQRT(16d0*m_Sw2*(1d0-m_Sw2))
         Ve     = (2*T3e -4*Qe*m_Sw2)/Deno
         Vf     = (2*T3f -4*Qf*m_Sw2)/Deno
         Ae     =  2*T3e             /Deno
         Af     =  2*T3f             /Deno
c[[[[[[[!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
c         Ve     = 2*T3e             /Deno
c         Vf     = 2*T3e             /Deno
c         Ae     =  0d0
c         Af     =  0d0
c]]]]]]]!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ELSE
* Get EW form-factors
         CALL BornV_InterpoGSW(KFf,Svar,CosThetD)
         CALL BornV_GetGSW(GSW)
         RhoEW     = GSW(1)
         VPgamma   = GSW(6)
         CorEle    = GSW(2)
         CorFin    = GSW(3)
         CorEleFin = GSW(4)
* Vacuum polarization factors
         GamVPi = 1d0   /(2d0-VPgamma)
         ZetVPi = m_Gmu *m_MZ**2 *m_AlfInv /(DSQRT(2.d0)*8.d0*m_pi)
     $            *(m_Sw2*(1d0-m_Sw2)) *16d0
     $            *RhoEW
* Coupling costants times EW form-factors
         Deno   = DSQRT(16d0*m_Sw2*(1d0-m_Sw2))
         Ve     = (2*T3e -4*Qe*m_Sw2*CorEle)/Deno
         Vf     = (2*T3f -4*Qf*m_Sw2*CorFin)/Deno
         Ae     =  2*T3e             /Deno
         Af     =  2*T3f             /Deno
* Angle dependent double-vector extra-correction
         VVCef  = ( (2*T3e)      *(2*T3f) 
     $             -(4*Qe*m_Sw2) *(2*T3f)      *CorEle 
     $             -(4*Qf*m_Sw2) *(2*T3e)      *CorFin
     $             +(4*Qe*m_Sw2) *(4*Qf*m_Sw2) *CorEleFin )/Deno**2
         VVCor  = VVCef/(Ve*Vf)
* CosThetD = 1d0 is special
         IF( CosThetD .EQ. 0d0) VVCor  = DCMPLX(1d0)
      ENDIF
      END

      SUBROUTINE GPS_GetDebg(j,y)
*////////////////////////////////////////////////////////////////////////////////
*//                                                                            //
*////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      DOUBLE PRECISION  y
      INTEGER j
*---------------------------------------------------------------
      y = m_Debg(j)
      END   ! GPS_GetDebg

      SUBROUTINE GPS_GetHvectors(HvecFer1,HvecFer2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   !!!!!!!!!!!!!!!!! TEMPORARY, no getters for these variables !!!!!!!!!!!!!!!!! //
*//   Geting final fermion POLARIMETER vectors                                      //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER k
      DOUBLE PRECISION  HvecFer1(4),HvecFer2(4)
*
      DO k=1,4
         HvecFer1( k) = m_HvecFer1(k)
         HvecFer2( k) = m_HvecFer2(k)
      ENDDO
      END

      SUBROUTINE GPS_GetKeyArb(KeyArb)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  KeyArb is for switching on/off the use of m_b,   KeyArb=0 means b=Xi           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER KeyArb
      KeyArb = m_KeyArb
      END


      SUBROUTINE GPS_GetPolBeams(PolBeam1,PolBeam2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   !!!!!!!!!!!!!!!!! TEMPORARY, no getters for these variables !!!!!!!!!!!!!!!!! //
*//   Geting beam POLARIZATION vectors                                              //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER k
      DOUBLE PRECISION  PolBeam1(4),PolBeam2(4)
*
      DO k=1,4
         PolBeam1( k) = m_PolBeam1(k)
         PolBeam2( k) = m_PolBeam2(k)
      ENDDO
      END

      SUBROUTINE GPS_GetRmat(Rmat)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Export m_Rmat to outside world                                                //
*//   Note that Rmat is REAL while m_Rmat is still COMPLEX                          //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      DOUBLE PRECISION      sum,sum1,Rmat(0:3,0:3)
      INTEGER    i,j
*-----------------------------------
* Save old result
      DO i=0,3
         DO j=0,3
            Rmat(i,j)=m_Rmat(i,j)
         ENDDO
      ENDDO
      END

      SUBROUTINE GPS_GetWtSet(WtBest,WtSet)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Export list of weights                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    WtBest,WtSet(*)
      INCLUDE 'GPS.h'
*
      INTEGER  j
*--------------------------------------------------------------
      WtBest = m_WtBest
* collection of all weights
      DO j=1,m_lenwt
         WtSet(j)= m_WtSet(j)
      ENDDO
      END                       !!!GPS_GetWtSet!!!
            
*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//           Setters and Getters of CLASS  GPS                                     //
*//           Setters and Getters of CLASS  GPS                                     //
*//           Setters and Getters of CLASS  GPS                                     //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE GPS_GetXi(xi,eta)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   xi is basic lightlike vector in LAB frame entering definition of all spinors  //
*//   called k0 in Kleiss Stirling papers                                           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      DOUBLE PRECISION  xi(4),eta(4)
      INTEGER k
*--------------
      DO k=1,4
         xi(k)  =  m_Xi(k)
         eta(k) =  m_Eta(k)
      ENDDO
      END


      SUBROUTINE GPS_GPS(xi,eta,Rot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*// Defines basis vectors e1,e2,e2 from xi and eta                            //
*// Columns in Rot are e1,e2,e2                                               //
*// Called in GPS_TralorPrepare                                               //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      DOUBLE PRECISION   xi(4),eta(4)
      DOUBLE PRECISION   Rot(4,4)
      DOUBLE PRECISION   e1(4),e2(4),e3(4),a
      INTEGER k
*---------------------------------------
* GPS rule 1: z-axis antiparalel to xi
      a = SQRT(xi(1)**2 +xi(2)**2 +xi(3)**2 )
      e3(1) = -xi(1)/a
      e3(2) = -xi(2)/a
      e3(3) = -xi(3)/a
      e3(4) = 0d0
* GPS rule 2: x-axis in plane (+eta, -xi),
* that is y-axis perpendicular to (eta,xi), i.e. e2 = eta X xi
      e2(1) =  eta(2)*xi(3) -eta(3)*xi(2)
      e2(2) = -eta(1)*xi(3) +eta(3)*xi(1)
      e2(3) =  eta(1)*xi(2) -eta(2)*xi(1)
      a = SQRT(e2(1)**2 +e2(2)**2 +e2(3)**2 )
      e2(1) = e2(1)/a
      e2(2) = e2(2)/a
      e2(3) = e2(3)/a
      e2(4) = 0d0
      e1(1) = e2(2)*e3(3) -e2(3)*e3(2)
      e1(2) =-e2(1)*e3(3) +e2(3)*e3(1)
      e1(3) = e2(1)*e3(2) -e2(2)*e3(1)
      e1(4) = 0d0
* Define additional rotation matrix from GPS (e1,e2,e3) frame 
* to actual fermion rest frame defined with matrix Lorenz 
      CALL KinLib_RotColumn(e1,e2,e3,Rot)
      END






      SUBROUTINE GPS_HffPlus(CNorm,KFi,KFf,PX,pA,mA,pB,mB,pC,mC,pD,mD,Hel1,ph1,Hel2,ph2,mph,AmpWork) !
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Genuine IR-finite non 1-photon amplitudes for FSR-FSR are added to AmpWork    //
*//   Photon helicity imported from the calling program.                            //
*//                                                                                 //
*//   For Y_IR=1 IR-finite 1-photon contributions are calculated here as well.      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                                    FSR                                            //
*      //                                                                                   //
*      //                            1                  2                                   //
*      //                            |                  |                                   //
*      //             c              |                  |          d                        //
*      //    u  ------<------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO----<----- v                 //
*      //                                     |                                             //
*      //                                     |X                                            //
*      //                                     |                                             //
*      //                                                                                   //
*      ///////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER            KFi,KFf
      DOUBLE PRECISION   PX(4),pA(4),pB(4),pC(4),pD(4),ph1(4),ph2(4),ph(4)
      DOUBLE PRECISION   mA,mB,mC,mD,mph
      DOUBLE COMPLEX     CNorm,sProd
      INTEGER            Hel1, Hel2
      DOUBLE COMPLEX     BornAB1D(2,2,2,2), BornAB2D(2,2,2,2), BornABCD(2,2,2,2)
      DOUBLE COMPLEX     BornABC1(2,2,2,2), BornABC2(2,2,2,2)
      DOUBLE COMPLEX     BornAB12(2,2,2,2), BornAB21(2,2,2,2)
      DOUBLE COMPLEX     AmpWork(2,2,2,2)
      DOUBLE COMPLEX     Uc11(2,2),   V11d(2,2),   U122(2,2),  V221(2,2)
      DOUBLE COMPLEX     Uc22(2,2),   V22d(2,2),   U211(2,2),  V112(2,2)
      DOUBLE COMPLEX     U21c(2,2),   Vd12(2,2),   Uc12(2,2),  V21d(2,2)
      DOUBLE COMPLEX     U12c(2,2),   Vd21(2,2),   Uc21(2,2),  V12d(2,2)
      DOUBLE COMPLEX     U121(2,2),   V121(2,2),   U212(2,2),  V212(2,2)
      DOUBLE COMPLEX     Su1,Su2,Su3
      INTEGER            j,j1,j2,j3,j4,k,Sig,l
      DOUBLE PRECISION   Fprop1, Fprop2
      DOUBLE PRECISION   prC1, prD1, prC2, prD2, prC12, prD12
      DOUBLE PRECISION   BornV_GetCharge, ChaIni,ChaFin
      DOUBLE COMPLEX     GPS_Sof1,GPS_Sof1b
      DOUBLE COMPLEX     sC(2,2),sD(2,2)
      DOUBLE COMPLEX     gF
      INTEGER            Y_IR, N_IR
      DOUBLE PRECISION   PP12(4),PP1(4),PP2(4),QQ(4),SvarQ,SvarX12,SvarX1,SvarX2
*------------------------------------------------------------------------------------------
      Y_IR=1                  ! YES, IR included
      Y_IR=0                  ! No,  IR not included
      N_IR=1-Y_IR
*--------------------
      ChaFin =  BornV_GetCharge( KFf)
      gF = DCMPLX(ChaFin *m_e_QED)
      IF( m_KeyArb  .EQ.  0 ) THEN
         sC(1,1)  =  gF *GPS_Sof1( 1,ph1,pC)
         sC(2,1)  =  gF *GPS_Sof1( 1,ph2,pC)
         sD(1,1)  = -gF *GPS_Sof1( 1,ph1,pD)
         sD(2,1)  = -gF *GPS_Sof1( 1,ph2,pD)
      ELSE
         sC(1,1)  =  gF *GPS_Sof1b( 1,ph1,pC,mC)
         sC(2,1)  =  gF *GPS_Sof1b( 1,ph2,pC,mC)
         sD(1,1)  = -gF *GPS_Sof1b( 1,ph1,pD,mD)
         sD(2,1)  = -gF *GPS_Sof1b( 1,ph2,pD,mD)
      ENDIF
      sC(1,2) = -DCONJG(sC(1,1))
      sC(2,2) = -DCONJG(sC(2,1))
      sD(1,2) = -DCONJG(sD(1,1))
      sD(2,2) = -DCONJG(sD(2,1))
* Calculate Born spin amplitudes, also with substitutions
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  pC,   mC,   pD,   -mD, BornABCD) ! Standard
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  ph1, mph,   pD,   -mD, BornAB1D) ! C->1
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  pC,   mC,   ph1, -mph, BornABC1) ! D->1
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  ph2, mph,   pD,   -mD, BornAB2D) ! C->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  pC,   mC,   ph2, -mph, BornABC2) ! D->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  ph1, mph,   ph2, -mph, BornAB12) ! C->1,D->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,  pB,-mB,  ph2, mph,   ph1, -mph, BornAB21) ! C->2,D->1
      DO k=1,4
         PP12(k) = pC(k)+pD(k)+ph1(k)+ph2(k)
         PP1 (k) = pC(k)+pD(k)+ph1(k)
         PP2 (k) = pC(k)+pD(k)+ph2(k)
         QQ(k)   = pC(k)+pD(k)
      ENDDO
      svarX12 = PP12(4)**2 -PP12(3)**2 -PP12(2)**2 -PP12(1)**2
      svarX1  =  PP1(4)**2  -PP1(3)**2  -PP1(2)**2  -PP1(1)**2
      svarX2  =  PP2(4)**2  -PP2(3)**2  -PP2(2)**2  -PP2(1)**2
      svarQ   =   QQ(4)**2   -QQ(3)**2   -QQ(2)**2   -QQ(1)**2
* Fermion propagarotors 1
      prC1=  1d0/(pC(4)*ph1(4)-pC(3)*ph1(3)-pC(2)*ph1(2)-pC(1)*ph1(1))/2d0
      prD1= -1d0/(pD(4)*ph1(4)-pD(3)*ph1(3)-pD(2)*ph1(2)-pD(1)*ph1(1))/2d0
* Fermion propagarotors 2
      prC2=  1d0/(pC(4)*ph2(4)-pC(3)*ph2(3)-pC(2)*ph2(2)-pC(1)*ph2(1))/2d0
      prD2= -1d0/(pD(4)*ph2(4)-pD(3)*ph2(3)-pD(2)*ph2(2)-pD(1)*ph2(1))/2d0
* Double propagators
      prC12= 1d0/( pC(4)*ph1(4)- pC(3)*ph1(3)- pC(2)*ph1(2)- pC(1)*ph1(1)
     $           + pC(4)*ph2(4)- pC(3)*ph2(3)- pC(2)*ph2(2)- pC(1)*ph2(1)
     $           +ph1(4)*ph2(4)-ph1(3)*ph2(3)-ph1(2)*ph2(2)-ph1(1)*ph2(1))/2d0
      prD12=-1d0/( pD(4)*ph1(4)- pD(3)*ph1(3)- pD(2)*ph1(2)- pD(1)*ph1(1)
     $            +pD(4)*ph2(4)- pD(3)*ph2(3)- pD(2)*ph2(2)- pD(1)*ph2(1)
     $           +ph1(4)*ph2(4)-ph1(3)*ph2(3)-ph1(2)*ph2(2)-ph1(1)*ph2(1))/2d0
      Fprop1= (1d0/prC1+1d0/prC2)*prC12 -1d0
      Fprop2= (1d0/prD1+1d0/prD2)*prD12 -1d0
      Sig = 3-2*Hel1
      IF( m_KeyArb  .EQ.  0 ) THEN
* end of line
         CALL GPS_MatrV( gF, ph1,Sig,  ph1,mph, pD,mD,     V11d) ! <1|{1}|D>
         CALL GPS_MatrU( gF, ph1,Sig,  pC,mC,   ph1,mph,   Uc11) ! <C|[1]|1>
* false second
         CALL GPS_MatrV( gF, ph1,Sig,  ph2,mph, pD,mD,     V21d) ! <2|{1}|D>
         CALL GPS_MatrU( gF, ph1,Sig,  pC,mC,   ph2,mph,   Uc12) ! <C|[1]|2>
* reverse order
         CALL GPS_MatrV( gF, ph1,Sig,  pD,mD,   ph2,mph,   Vd12) ! <D|{1}|2>
         CALL GPS_MatrU( gF, ph1,Sig,  ph2,mph, pC,mC,     U21c) ! <2|[1]|C>
* xk-xk term case, ph2 first
         CALL GPS_MatrV( gF, ph1,Sig,  ph1,mph, ph2,mph,   V112) ! <1|{1}|2>
         CALL GPS_MatrU( gF, ph1,Sig,  ph2,mph, ph1,mph,   U211) ! <2|[1]|1>
* xk-xk term case ph2 first
         CALL GPS_MatrV( gF, ph1,Sig,  ph2,mph, ph2,mph,   V212) ! <2|{1}|2>
         CALL GPS_MatrU( gF, ph1,Sig,  ph2,mph, ph2,mph,   U212) ! <2|[1]|2>
      ELSE
         CALL GPS_MatrVb(gF, ph1,Sig,  ph1,mph, pD,mD,     V11d)
         CALL GPS_MatrUb(gF, ph1,Sig,  pC,mC,   ph1,mph,   Uc11)
* falSe second
         CALL GPS_MatrVb(gF, ph1,Sig,  ph2,mph, pD,mD,     V21d)
         CALL GPS_MatrUb(gF, ph1,Sig,  pC,mC,   ph2,mph,   Uc12)
* reverse order
         CALL GPS_MatrVb(gF, ph1,Sig,  pD,mD,   ph2,mph,   Vd12)
         CALL GPS_MatrUb(gF, ph1,Sig,  ph2,mph, pC,mC,     U21c)
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrVb(gF, ph1,Sig,  ph1,mph, ph2,mph,   V112)
         CALL GPS_MatrUb(gF, ph1,Sig,  ph2,mph, ph1,mph,   U211)
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrVb(gF, ph1,Sig,  ph2,mph, ph2,mph,   V212)
         CALL GPS_MatrUb(gF, ph1,Sig,  ph2,mph, ph2,mph,   U212)
      ENDIF
      Sig = 3-2*Hel2
      IF( m_KeyArb  .EQ.  0 ) THEN
         CALL GPS_MatrV( gF, ph2,Sig,  ph2,mph,  pD,mD,    V22d) ! <2|{2}|D>
         CALL GPS_MatrU( gF, ph2,Sig,  pC,mC,   ph2,mph,   Uc22) ! <C|[2]|2>
* falSe second
         CALL GPS_MatrV( gF, ph2,Sig,  ph1,mph,  pD,mD,    V12d) ! <1|{2}|D>
         CALL GPS_MatrU( gF, ph2,Sig,  pC,mC,   ph1,mph,   Uc21) ! <C|[2]|1>
* reverse order
         CALL GPS_MatrV( gF, ph2,Sig,  pD,mD,   ph1,mph,   Vd21) ! <D|{2}|1>
         CALL GPS_MatrU( gF, ph2,Sig,  ph1,mph, pC,mC,     U12c) ! <1|[2]|C>
* xk-xk term, ph1 first
         CALL GPS_MatrV( gF, ph2,Sig,  ph2,mph, ph1,mph,   V221) ! <2|{2}|1>
         CALL GPS_MatrU( gF, ph2,Sig,  ph1,mph, ph2,mph,   U122) ! <1|[2]|2>
* xk-xk term, ph1 first 
         CALL GPS_MatrV( gF, ph2,Sig,  ph1,mph, ph1,mph,   V121) ! <1|{2}|1>
         CALL GPS_MatrU( gF, ph2,Sig,  ph1,mph, ph1,mph,   U121) ! <1|[2]|1>
      ELSE
         CALL GPS_MatrVb(gF, ph2,Sig,  ph2,mph,  pD,mD,    V22d)
         CALL GPS_MatrUb(gF, ph2,Sig,  pC,mC,   ph2,mph,   Uc22)
* falSe second
         CALL GPS_MatrVb(gF, ph2,Sig,  ph1,mph,  pD,mD,    V12d)
         CALL GPS_MatrUb(gF, ph2,Sig,  pC,mC,   ph1,mph,   Uc21)
* reverse order
         CALL GPS_MatrVb(gF, ph2,Sig,  pD,mD,   ph1,mph,   Vd21)
         CALL GPS_MatrUb(gF, ph2,Sig,  ph1,mph, pC,mC,     U12c)
* for the case when there was ph1 first xk-xk term
         CALL GPS_MatrVb(gF, ph2,Sig,  ph2,mph, ph1,mph,   V221)
         CALL GPS_MatrUb(gF, ph2,Sig,  ph1,mph, ph2,mph,   U122)
* for the case when there was ph1 first xk-xk term
         CALL GPS_MatrVb(gF, ph2,Sig,  ph1,mph, ph1,mph,   V121)
         CALL GPS_MatrUb(gF, ph2,Sig,  ph1,mph, ph1,mph,   U121)
      ENDIF
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Su1 = DCMPLX(0d0,0d0)
                  DO j=1,2
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     1|            2|                                              //
*      //               c      |    c+m+1    |    c+m+1+2          -d                       //
*      //       u  -----<------S-----<-------U------<-------O-------<------ v               //
*      //                                                   |X                              //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +(sC(1,Hel1)*(prC12-prC2*N_IR))*Uc22(j3,j)*BornAB2D(j1,j2,j,j4) !<c|(1)c[2]2|X|d>
                     Su1=Su1  +sC(1,Hel1)* prC12            *Uc21(j3,j)*BornAB1D(j1,j2,j,j4) !<c|(1)c[2]1|X|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     2|            1|                                              //
*      //               c      |    c+m+2    |    c+m+1+2          -d                       //
*      //       u  -----<------S-----<-------U------<-------O-------<------ v               //
*      //                                                   |X                              //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1+(sC(2,Hel2)*(prC12-prC1*N_IR))*Uc11(j3,j)*BornAB1D(j1,j2,j,j4) !<c|(2)c[1]1|X|d>
                     Su1=Su1 +sC(2,Hel2)* prC12            *Uc12(j3,j)*BornAB2D(j1,j2,j,j4) !<c|(2)c[1]2|X|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                                    |1             |2                              //
*      //               c          -d+m-1-2  |   -d+m-2     |       -d                      //
*      //       u  -----<------O-----<-------V-----<--------S--------<----- v               //
*      //                     X|                                                            //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +BornABC1(j1,j2,j3,j)*V11d(j,j4)*( sD(2,Hel2)*(prD12-prD1*N_IR))!<c|X|1{1}d(2)|d>
                     Su1=Su1 +BornABC2(j1,j2,j3,j)*V21d(j,j4)*  sD(2,Hel2)* prD12            !<c|X|2{1}d(2)|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                                    |2             |1                              //
*      //               c          -d+m-1-2  |   -d+m-1     |       -d                      //
*      //       u  -----<------O-----<-------V-----<--------S--------<----- v               //
*      //                     X|                                                            //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +BornABC2(j1,j2,j3,j)*V22d(j,j4)*( sD(1,Hel1)*(prD12-prD2*N_IR))!<c|X|2{2}d(1)|d>
                     Su1=Su1 +BornABC1(j1,j2,j3,j)*V12d(j,j4)  *sD(1,Hel1)* prD12            !<c|X|1{2}d(1)|d>
                  ENDDO
                  Su3 = DCMPLX(0d0,0d0)
                  DO j=1,2
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     2|                            |1                              //
*      //               c      |    c+m+1         c+m+1     |      -d                       //
*      //       u  -----<------U-----<-------O------<-------S-------<------ v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su3=Su3 +Uc22(j3,j)*prC2  *BornAB2D(j1,j2,j,j4) *sD(1,Hel1) *Y_IR !<c|[2]c|X|1(1)|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     1|                            |2                              //
*      //               c      |    c+m+1         c+m+2     |      -d                       //
*      //       u  -----<------U-----<-------O------<-------S-------<------ v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su3=Su3 +Uc11(j3,j)*prC1 *BornAB1D(j1,j2,j,j4)  *sD(2,Hel2) *Y_IR !<c|[1]c|X|2(2)|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     2|                            |1                              //
*      //               c      |    c+m+2         c+m+1     |      -d                       //
*      //       u  -----<------S-----<-------O------<-------U-------<------ v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su3=Su3 +sC(2,Hel2) *BornABC1(j1,j2,j3,j) *prD1 *V11d(j,j4) *Y_IR !<c|(2)c|X|1{1}|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     1|                            |2                              //
*      //               c      |    c+m+1         c+m+2     |      -d                       //
*      //       u  -----<------S-----<-------O------<-------U-------<------ v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                     Su3=Su3 +sC(1,Hel1) *BornABC2(j1,j2,j3,j) *prD2 *V22d(j,j4) *Y_IR !<c|(1)c|X|2{2}|d>
                  ENDDO
                  Su2 = DCMPLX(0d0,0d0)
                  DO j=1,2
                     DO l=1,2
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                      |2                           |1                              //
*      //               c      |    c+m+2        -d+m-1     |       -d                      //
*      //       u  -----<------U-----<-------O-----<--------V--------<----- v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Uc22( j3,l)*prC2 *BornAB21(j1,j2,l,j ) *V11d( j,j4)*prD1 !<c|[2]2|X|1{1}|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                      |1                           |2                              //
*      //               c      |    c+m+1        -d+m-2     |       -d                      //
*      //       u  -----<------U-----<-------O-----<--------V--------<----- v               //
*      //                                    |X                                             //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Uc11( j3,l)*prC1 *BornAB12(j1,j2,l,j ) *V22d( j,j4)*prD2 !<c|[1]1|X|2{2}|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     1|            2|                                              //
*      //               c      |    c+m+1    |    c+m+1+2          -d                       //
*      //       u  -----<------U-----<-------O------<-------V-------<------ v               //
*      //                                                  X|                               //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Uc11( j3,l)*prC1  *U122(l,j)*prC12  *BornAB2D(j1,j2,j ,j4) ! <c|[1]1[2]2|X|d>
                        Su2=Su2 +Uc11( j3,l)*prC1  *U121(l,j)*prC12  *BornAB1D(j1,j2,j ,j4) ! <c|[1]1[2]1|X|d>
                        Su2=Su2 +Uc11( j3,l)*prC1  *U12c(l,j)*prC12  *BornABCD(j1,j2,j ,j4) ! <c|[1]1[2]c|X|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                     2|            1|                                              //
*      //               c      |    c+m+2    |    c+m+1+2          -d                       //
*      //       u  -----<------U-----<-------U------<-------O-------<------ v               //
*      //                                                  X|                               //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Uc22( j3,l)*prC2  *U211(l,j)*prC12  *BornAB1D(j1,j2,j ,j4) ! <c|[2]2[1]1|X|d>
                        Su2=Su2 +Uc22( j3,l)*prC2  *U212(l,j)*prC12  *BornAB2D(j1,j2,j ,j4) ! <c|[2]2[1]2|X|d>
                        Su2=Su2 +Uc22( j3,l)*prC2  *U21c(l,j)*prC12  *BornABCD(j1,j2,j ,j4) ! <c|[2]2[1]c|X|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                                    |2             |1                              //
*      //               c          -d+m-1-2  |   -d+m-1     |       -d                      //
*      //       u  -----<------O-----<-------V-----<--------V--------<----- v               //
*      //                      |X                                                           //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +BornABC2(j1,j2,j3,j ) *V221(j,l )*prD12 *V11d( l,j4)*prD1  ! <c|X|2{2}1{1}|d>
                        Su2=Su2 +BornABC1(j1,j2,j3,j ) *V121(j,l )*prD12 *V11d( l,j4)*prD1  ! <c|X|1{2}1{1}|d>
                        Su2=Su2 +BornABCD(j1,j2,j3,j ) *Vd21(j,l )*prD12 *V11d( l,j4)*prD1  ! <c|X|d{2}1{1}|d>
*      ///////////////////////////////////////////////////////////////////////////////////////
*      //                                    |1             |2                              //
*      //               c          -d+m-1-2  |   -d+m-2     |       -d                      //
*      //       u  -----<------O-----<-------V-----<--------V--------<----- v               //
*      //                      |X                                                           //
*      ///////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +BornABC1(j1,j2,j3,j ) *V112(j,l )*prD12 *V22d( l,j4)*prD2  ! <c|X|1{1}2{2}|d>
                        Su2=Su2 +BornABC2(j1,j2,j3,j ) *V212(j,l )*prD12 *V22d( l,j4)*prD2  ! <c|X|2{1}2{2}|d>
                        Su2=Su2 +BornABCD(j1,j2,j3,j ) *Vd12(j,l )*prD12 *V22d( l,j4)*prD2  ! <c|X|d{1}2{2}|d>
                     ENDDO
                  ENDDO
                  sProd = (sC(1,Hel1)+sD(1,Hel1)) *( sC(2,Hel2)+sD(2,Hel2)) !
                  AmpWork(j1,j2,j3,j4) = AmpWork(j1,j2,j3,j4)
     $                 +CNorm*( Su1 +Su2 +Su3)
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*( sC(1,Hel1)*sC(2,Hel2)*Fprop1   !
     $                                               +sD(1,Hel1)*sD(2,Hel2)*Fprop2 ) !
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*sProd *(1d0 -svarX12/svarQ)  *N_IR !
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*sProd *( svarX1/svarQ -1d0)  *N_IR !
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*sProd *( svarX2/svarQ -1d0)  *N_IR !
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*sProd                        *Y_IR !
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       ! GPS_HffPlus


      SUBROUTINE GPS_Hfin(KFi,KFf,PP, p1,m1,p2,m2,p3,m3,p4,m4,ph,mph, AmHarFsr)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   IR-finite part od 1-photon amplitudes for FSR                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PP(4),p1(4),p2(4),p3(4),p4(4),ph(4)
      DOUBLE PRECISION      m1,m2,m3,m4,mph
*
      DOUBLE COMPLEX  AmHarFsr(2,2,2,2,2)
      DOUBLE COMPLEX  AmpBornU(2,2,2,2)
      DOUBLE COMPLEX  AmpBornV(2,2,2,2)
      DOUBLE COMPLEX  Csum1,Csum2,U(2,2),V(2,2)
      INTEGER    j,j1,j2,j3,j4,k,Sig
      DOUBLE PRECISION      pr1,pr2,Fleps
*----------------------------------------
      Fleps =  1d-100
* FSR non-infrared two parts: (1) p1 -> photon, contracted with U-matrix
*                             (2) p2 -> photon, contracted with V-matrix
      CALL GPS_Born(KFi,KFf,PP, p1,Fleps, p2,-Fleps, ph,mph, p4,-m4,   AmpBornU)
      CALL GPS_Born(KFi,KFf,PP, p1,Fleps, p2,-Fleps, p3,m3,  ph,-mph,  AmpBornV)
***   CALL GPS_BPrint(6,'Bo(12k4)',AmpBornU)
***   CALL GPS_BPrint(6,'Bo(123k)',AmpBornV)
* Fermion propagarotors
      pr1 = 1d0/(p3(4)*ph(4)-p3(3)*ph(3)-p3(2)*ph(2)-p3(1)*ph(1))/2d0
      pr2 =-1d0/(p4(4)*ph(4)-p4(3)*ph(3)-p4(2)*ph(2)-p4(1)*ph(1))/2d0
      DO k=1,2
         Sig = 3-2*k
         IF( m_KeyArb .EQ. 0 ) THEN
            CALL GPS_MakeU(ph,Sig,    p3,m3,  ph,mph,   U)
            CALL GPS_MakeV(ph,Sig,    ph,mph, p4,m4,    V)
         ELSE
            CALL GPS_MakeUb(ph,Sig,   p3,m3,  ph,mph,   U)
            CALL GPS_MakeVb(ph,Sig,   ph,mph, p4,m4,    V)
         ENDIF
***      WRITE(*,*) ' ///// sig = ', sig
***      CALL GPS_UPrint(6,' U(k,p3)    ',U)
***      CALL GPS_UPrint(6,' V(p4,k)    ',V)
         DO j1=1,2
            DO j2=1,2
               DO j3=1,2
                  DO j4=1,2
                     Csum1=DCMPLX(0d0,0d0)
                     Csum2=DCMPLX(0d0,0d0)
                     DO j=1,2
                        Csum1=Csum1 +U(j3,j)*pr1* AmpBornU(j1,j2, j,j4)
                        Csum2=Csum2 +V(j,j4)*pr2* AmpBornV(j1,j2,j3, j)
                     ENDDO
                     AmHarFsr(j1,j2,j3,j4,k) =  Csum1+Csum2
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       !!! GPS_Hfin


      SUBROUTINE GPS_HfinPlus(KFi,KFf,PX, p1,m1,p2,m2,p3,m3,p4,m4,ph,mph,Hel,Sactu,sProd,CKine)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   IR-finite part od 1-photon amplitudes for FSR  (equiv. to GPS_HfinPlus)       //
*//   Photon helicity is give by the calling program                                //
*//                                                                                 //
*//   Missing contribution in FSR non-IR part due to  svarX/svarQ                   //
*//   Contribution -svarX/svarQ from HERE cancels exactly with svarX/svarQ in beta0 //
*//                                                                                 //
*//   m_AmpExpo*  is working space                                                  //
*//   m_AmpBorn   is hidden INPUT                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4),ph(4)
      DOUBLE PRECISION      m1,m2,m3,m4,mph
*
      DOUBLE COMPLEX        Sactu,sProd,CKine
      INTEGER               Hel
      DOUBLE COMPLEX        AmpBornU(2,2,2,2)
      DOUBLE COMPLEX        AmpBornV(2,2,2,2)
      DOUBLE COMPLEX        Csum1,Csum2,U(2,2),V(2,2)
      INTEGER               j,j1,j2,j3,j4,k,Sig
      DOUBLE PRECISION      pr1,pr2,Fleps
      DOUBLE PRECISION      BornV_GetCharge,Qf
      DOUBLE COMPLEX        Vir1,Vir2
      DOUBLE COMPLEX        AmpExpo1,AmpExpo2,AmpBorn
*----------------------------------------
      Fleps =  1d-100
      Qf =  BornV_GetCharge( KFf)
* Virtual corrections
      CALL  BVR_MakeVfin(m_Alfpi,Qf,p3,m3,p4,m4,ph, Vir1,Vir2)
***      WRITE(*,*) 'ph/ene,Vir1,Vir2 =',ph(4)/p1(4),Vir1,Vir2
* FSR non-infrared two parts: (1) p1 -> photon, contracted with U-matrix
*                             (2) p2 -> photon, contracted with V-matrix
****> CALL GPS_Born(KFi,KFf,PX, p1,Mbeam, p2,-Mbeam,  p3,Massf, p4,-Massf,m_AmpBorn) !!!!<****
      CALL GPS_Born(KFi,KFf,PX, p1,Fleps, p2,-Fleps,  ph,mph,   p4,-m4,   AmpBornU)
      CALL GPS_Born(KFi,KFf,PX, p1,Fleps, p2,-Fleps,  p3,m3,    ph,-mph,  AmpBornV)
* Fermion propagarotors
      pr1 = 1d0/(p3(4)*ph(4)-p3(3)*ph(3)-p3(2)*ph(2)-p3(1)*ph(1))/2d0
      pr2 =-1d0/(p4(4)*ph(4)-p4(3)*ph(3)-p4(2)*ph(2)-p4(1)*ph(1))/2d0
      Sig = 3-2*Hel
      IF( m_KeyArb .EQ. 0 ) THEN
         CALL GPS_MakeU(ph,Sig,    p3,m3,  ph,mph,   U)
         CALL GPS_MakeV(ph,Sig,    ph,mph, p4,m4,    V)
      ELSE
         CALL GPS_MakeUb(ph,Sig,   p3,m3,  ph,mph,   U)
         CALL GPS_MakeVb(ph,Sig,   ph,mph, p4,m4,    V)
      ENDIF
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Csum1=DCMPLX(0d0,0d0)
                  Csum2=DCMPLX(0d0,0d0)
                  DO j=1,2
                     Csum1=Csum1 +DCMPLX(Qf *m_e_QED) *U(j3,j)*pr1* AmpBornU(j1,j2, j,j4)
                     Csum2=Csum2 +DCMPLX(Qf *m_e_QED) *V(j,j4)*pr2* AmpBornV(j1,j2,j3, j)
                  ENDDO
                  AmpBorn  = m_AmpBorn(j1,j2,j3,j4)
*///// first order
                  AmpExpo1 =  
     $                 +sProd/Sactu*(Csum1+Csum2)             !! non-IR sigle bremss. part
     $                 -sProd*CKine*AmpBorn +sProd*AmpBorn    !! compensate for (svarX1/svarQ)
*///// second order
** (1+Vir1)*AmpBorn is already included in AmpExpo2 so we drop it to avoid double counting
** the remaining Vir2*AmpBorn is IR-finite because Vir2->0 in the IR limit
                  AmpExpo2 =  
     $                 +sProd/Sactu*(Csum1+Csum2)*(1+Vir1+Vir2)*(1+m_F1ini1) ! non-IR sigle bremss. part
     $                 +sProd*(-CKine*AmpBorn+AmpBorn)*(1+Vir1)*(1+m_F1ini1) ! compensate for (svarX1/svarQ)
     $                 +sProd*AmpBorn*Vir2                                   ! add virtual_non_IR*Born
*///////////////////////
                  m_AmpExpo1(j1,j2,j3,j4) =m_AmpExpo1(j1,j2,j3,j4) +AmpExpo1
                  m_AmpExpo2(j1,j2,j3,j4) =m_AmpExpo2(j1,j2,j3,j4) +AmpExpo2
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       !!! GPS_HfinPlus !!!

      SUBROUTINE GPS_HifPlus(CNorm,KFi,KFf,PX,pA,mA,pB,mB,pC,mC,pD,mD,Hel1,ph1,Hel2,ph2,mph,AmpWork) !
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Genuine IR-finite non 1-photon amplitudes for ISR-FSR are added to AmpWork    //
*//   1-st photon in Initial  state,  symmetrisation 1<-->2 is required!            //
*//                                                                                 //
*//   For Y_IR=1 IR-finite 1-photon contributions are calculated here as well       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                              1                2                                 //
*//                              |                |                                 //
*//                              |                |                                 //
*//               c              |    OOOOOOOOOOOOOOOOOO          d                 //
*//     u  -------<------------- | ---OOOOOOOOOOOOOOOOOO----------<----- v          //
*//                              |         |                                        //
*//                              |         |X                                       //
*//                              |         |                                        //
*//      _       -b          OOOOOOOOOOOOOOOOOOOOO                a                 //
*//      v  ------<----------OOOOOOOOOOOOOOOOOOOOO----------------<----- u          //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER           KFi,KFf
      DOUBLE PRECISION  PX(4),pA(4),pB(4),pC(4),pD(4),ph1(4),ph2(4),ph(4)
      DOUBLE PRECISION  mA,mB,mC,mD,mph
      DOUBLE COMPLEX    CNorm
      INTEGER           Hel1,Hel2
      DOUBLE COMPLEX    Born1BCD(2,2,2,2),BornAB2D(2,2,2,2),BornABCD(2,2,2,2)
      DOUBLE COMPLEX    BornA1CD(2,2,2,2),BornABC2(2,2,2,2)
      DOUBLE COMPLEX    Born1B2D(2,2,2,2),Born1BC2(2,2,2,2)
      DOUBLE COMPLEX    BornA12D(2,2,2,2),BornA1C2(2,2,2,2)
      DOUBLE COMPLEX    AmpWork(2,2,2,2)
      DOUBLE COMPLEX    U11a(2,2),Vb11(2,2),Uc22(2,2),V22d(2,2)
      DOUBLE COMPLEX    Su1,Su2
      DOUBLE COMPLEX    GPS_soft,GPS_softb
      DOUBLE COMPLEX    Sini(2),Sfin(2)
      INTEGER           j,j1,j2,j3,j4,k,Sig,l
      DOUBLE PRECISION  prA1,prB1,prC2,prD2
      DOUBLE PRECISION  BornV_GetCharge,ChaIni,ChaFin
      DOUBLE COMPLEX    gI,gF,sProd
      INTEGER           Y_IR,N_IR
      DOUBLE PRECISION  PP2(4),QQ(4),SvarQ,SvarX2
*----------------------------------------
      Y_IR=1                  ! YES, IR included
      Y_IR=0                  ! No,  IR not included
      N_IR=1-Y_IR
*--------------------
      ChaIni =  BornV_GetCharge( KFi)
      ChaFin =  BornV_GetCharge( KFf)
      gI = DCMPLX(ChaIni *m_e_QED)
      gF = DCMPLX(ChaFin *m_e_QED)
      IF( m_KeyArb  .EQ.  0 ) THEN
         Sini(1)  =  gI *GPS_soft(  1,ph1,pA,pB)
         Sfin(1)  = -gF *GPS_soft(  1,ph2,pC,pD)
      ELSE
         Sini(1)  =  gI *GPS_softb( 1,ph1,pA,mA,pB,mB)
         Sfin(1)  = -gF *GPS_softb( 1,ph2,pC,mC,pD,mD)
      ENDIF
      Sini(2) = -DCONJG(Sini(1))
      Sfin(2) = -DCONJG(Sfin(1))
* Calculate Born spin amplitudes
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    pB,-mB,    pC,MC,    pD,-md,   BornABCD) ! standard
      CALL GPS_Born(KFi,KFf,PX, ph1,mph,  pB,-mB,    pC,mC,    pD,-mD,   Born1BCD) ! A->1
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    ph1,-mph,  pC,mC,    pD,-mD,   BornA1CD) ! B->1
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    pB,-mB,    ph2,mph,  pD,-mD,   BornAB2D) ! C->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    pB,-mB,    pC,mC,    ph2,-mph, BornABC2) ! D->2
      CALL GPS_Born(KFi,KFf,PX, ph1,mph,  pB,-mB,    ph2,mph,  pD,-mD,   Born1B2D) ! A->1,C->2
      CALL GPS_Born(KFi,KFf,PX, ph1,mph,  pB,-mB,    pC,mC,    ph2,-mph, Born1BC2) ! A->1,D->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    ph1,-mph,  ph2,mph,  pD,-mD,   BornA12D) ! B->1,C->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    ph1,-mph,  pC,mC,    ph2,-mph, BornA1C2) ! B->1,D->2
      DO k=1,4
         PP2 (k) = pC(k)+pD(k)+ph2(k)
         QQ(k)   = pC(k)+pD(k)
      ENDDO
      svarX2  =  PP2(4)**2  -PP2(3)**2  -PP2(2)**2  -PP2(1)**2
      svarQ   =   QQ(4)**2   -QQ(3)**2   -QQ(2)**2   -QQ(1)**2
* Fermion propagarotors ini
      prA1=  1d0/(pA(4)*ph1(4)-pA(3)*ph1(3)-pA(2)*ph1(2)-pA(1)*ph1(1))/2d0
      prB1= -1d0/(pB(4)*ph1(4)-pB(3)*ph1(3)-pB(2)*ph1(2)-pB(1)*ph1(1))/2d0
* Fermion propagarotors fin
      prC2=  1d0/(pC(4)*ph2(4)-pC(3)*ph2(3)-pC(2)*ph2(2)-pC(1)*ph2(1))/2d0
      prD2= -1d0/(pD(4)*ph2(4)-pD(3)*ph2(3)-pD(2)*ph2(2)-pD(1)*ph2(1))/2d0
      Sig = 3-2*Hel1
      IF( m_KeyArb  .EQ.  0 ) THEN
         CALL GPS_MatrU( gI, ph1,Sig,  ph1,mph,  pA,mA,    U11a) ! <1|[1]|a>
         CALL GPS_MatrV( gI, ph1,Sig,  pB,mB,   ph1,mph,   Vb11) ! <b|{1}|1>
      ELSE
         CALL GPS_MatrUb(gI, ph1,Sig,  ph1,mph,  pA,mA,    U11a)
         CALL GPS_MatrVb(gI, ph1,Sig,  pB,mB,   ph1,mph,   Vb11)
      ENDIF
      Sig = 3-2*Hel2
      IF( m_KeyArb  .EQ.  0 ) THEN
         CALL GPS_MatrU( gF, ph2,Sig,  pC,mC,   ph2,mph,   Uc22) ! <c|[2]|2>
         CALL GPS_MatrV( gF, ph2,Sig,  ph2,mph,  pD,mD,    V22d) ! <2|{2}|d>
      ELSE
         CALL GPS_MatrUb(gF, ph2,Sig,  pC,mC,   ph2,mph,   Uc22) ! 
         CALL GPS_MatrVb(gF, ph2,Sig, ph2,mph,  pD,mD,     V22d) ! 
      ENDIF
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Su1= DCMPLX(0d0,0d0)
                  DO j=1,2
*      /////////////////////////////////////////////////////////////////////////////////////
*      //               c                |2                             d                 //
*      //      u  ------<-------SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS-----<----- v          //
*      //                                        |                                        //
*      //                                        |X             |1                        //
*      //      _       -b                        |     a+m-1    |       a                 //
*      //      v  ------<------------------------O--------------O-------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +Born1BCD( j,j2,j3,j4) *U11a(j,j1)*prA1 *Sfin(Hel2)*Y_IR !<b|X|1[1]|a><c|(+2)|X|(+2)|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //               c                |2                            -d                 //
*      //      u  ------<-------SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS-----<----- v          //
*      //                                        |                                        //
*      //                          |1            |X                                       //
*      //      _       -b          |   -b+m+1    |                      a                 //
*      //      v  ------<----------O-------------O----------------------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +Vb11(j2,j)*prB1 *BornA1CD(j1,j,j3,j4) *Sfin(Hel2)*Y_IR !<b|[1]1|X|a><c|(+2)|X|(+2)|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                         |2                                                      //
*      //               c         |   c+m+2                            -d                 //
*      //      u  ------<---------O--------------O----------------------<----- v          //
*      //                                        |X                                       //
*      //      _       -b                        |       |1             a                 //
*      //      v  ------<------SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS-----<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +Uc22(j3,j)*prC2 *BornAB2D(j1,j2,j,j4) *Sini(Hel1)*Y_IR !<b|(+1)|X|(+1)|a><c|[2]2|X|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                                                       |2                        //
*      //               c                            -d+m+2     |      -d                 //
*      //      u  ------<------------------------O----------------------<----- v          //
*      //                                        |X                                       //
*      //      _       -b                        |       |1             a                 //
*      //      v  ------<------SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS-----<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +BornABC2(j1,j2,j3,j) *V22d(j,j4)*prD2  *Sini(Hel1)*Y_IR !<b|(+1)|X|(+1)|a><c|X|2[2]d>
                  ENDDO
                  Su2= DCMPLX(0d0,0d0)
                  DO j=1,2
                     DO l=1,2
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                         |2                                                      //
*      //               c         |   c+m+2                             d                 //
*      //      u  ------<---------O--------------O----------------------<----- v          //
*      //                                        |                                        //
*      //                                        |X             |1                        //
*      //      _       -b                        |     a+m-1    |       a                 //
*      //      v  ------<------------------------O--------------O-------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Uc22(j3,l )*prC2 *Born1B2D(j,j2,l,j4) *U11a(j,j1)*prA1 !<b|X|1[1]|a><c|[2]2|X|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                                                       |2                        //
*      //               c                             -d+m-2    |       d                 //
*      //      u  ------<------------------------O--------------O-------<----- v          //
*      //                                        |                                        //
*      //                                        |X             |1                        //
*      //      _       -b                        |     a+m-1    |       a                 //
*      //      v  ------<------------------------O--------------O-------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Born1BC2(j,j2,j3,l) *U11a(j,j1)*prA1  *V22d(l,j4)*prD2 !<b|X|1[1]|a><c|X|2{2}|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                       |2                                                        //
*      //               c       |    c+m+2                              d                 //
*      //      u  ------<-------O----------------O----------------------<----- v          //
*      //                                        |                                        //
*      //                       |1               |X                                       //
*      //      _       -b       |   -b+m+1       |                      a                 //
*      //      v  ------<-------O----------------O----------------------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Vb11(j2,j)*prB1  *Uc22(j3,l )*prC2 *BornA12D(j1,j,l,j4)!<b|{1}1|X|a><c|[2]2|X|d>
*      /////////////////////////////////////////////////////////////////////////////////////
*      //                                                       |2                        //
*      //               c                             -d+m-2    |       d                 //
*      //      u  ------<------------------------O--------------O-------<----- v          //
*      //                                        |                                        //
*      //                       |1               |X                                       //
*      //      _       -b       |   -b+m+1       |                      a                 //
*      //      v  ------<-------O----------------O----------------------<----- u          //
*      /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Vb11(j2,j)*prB1  *BornA1C2(j1,j,j3,l) *V22d(l,j4)*prD2 !<b|{1}1|X|a><c|X|2[2]|d>
                     ENDDO
                  ENDDO
                  sProd = Sini(Hel1)* Sfin(Hel2)
                  AmpWork(j1,j2,j3,j4) =AmpWork(j1,j2,j3,j4) 
     $                 +CNorm*( Su1+Su2 )
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*sProd                      *Y_IR !
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       ! GPS_HifPlus



      SUBROUTINE GPS_HiiPlus(CNorm,KFi,KFf,PX,pA,mA,pB,mB,pC,mC,pD,mD,Hel1,ph1,Hel2,ph2,mph,AmpWork) !
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Genuine IR-finite non 1-photon amplitudes for ISR-ISR are added to AmpWork    //
*//   That is for dip-switch Y_IR=0.                                                //
*//   For Y_IR=1 IR-finite 1-photon contributions are calculated here as well       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*//                                        |                                        //
*//                              1         |          2                             //
*//                              |         |X         |                             //
*//      _       -b              |         |          |          a                  //
*//      v  ------<------OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO----<----- u           //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER           KFi,KFf
      DOUBLE PRECISION  PX(4),pA(4),pB(4),pC(4),pD(4),ph1(4),ph2(4),ph(4)
      DOUBLE PRECISION  mA,mB,mC,mD,mph
      DOUBLE COMPLEX    CNorm
      INTEGER           Hel1, Hel2
      DOUBLE COMPLEX    Born1BCD(2,2,2,2), Born2BCD(2,2,2,2), BornABCD(2,2,2,2)
      DOUBLE COMPLEX    BornA1CD(2,2,2,2), BornA2CD(2,2,2,2)
      DOUBLE COMPLEX    Born12CD(2,2,2,2), Born21CD(2,2,2,2)
      DOUBLE COMPLEX    AmpWork(2,2,2,2)
      DOUBLE COMPLEX    U11a(2,2),Vb11(2,2),U221(2,2),V122(2,2)
      DOUBLE COMPLEX    U22a(2,2),Vb22(2,2),U112(2,2),V211(2,2)
      DOUBLE COMPLEX    Ua12(2,2),V21b(2,2),U21a(2,2),Vb12(2,2)
      DOUBLE COMPLEX    Ua21(2,2),V12b(2,2),U12a(2,2),Vb21(2,2)
      DOUBLE COMPLEX    U121(2,2),V121(2,2),U212(2,2),V212(2,2)
      DOUBLE COMPLEX    Su1,Su2,sProd
      INTEGER           j,j1,j2,j3,j4,k,Sig,l
      DOUBLE PRECISION  prA1,prB1,prA2,prB2,prA12,prB12
      DOUBLE PRECISION  BornV_GetCharge,ChaIni
      DOUBLE PRECISION  Fprop1,Fprop2
      DOUBLE COMPLEX    gI
      DOUBLE COMPLEX    GPS_Sof1,GPS_Sof1b
      DOUBLE COMPLEX    sA(2,2),sB(2,2)
      INTEGER           Y_IR,N_IR
*------------------------------------------------------------------------------------------
      Y_IR=1                  ! YES, IR included
      Y_IR=0                  ! No,  IR not included
      N_IR=1-Y_IR
*--------------------
      ChaIni =  BornV_GetCharge( KFi)
      gI = DCMPLX(ChaIni*m_e_QED)
      IF( m_KeyArb  .EQ.  0 ) THEN
         sA(1,1)  = -gI*GPS_Sof1( 1,ph1,pA)
         sA(2,1)  = -gI*GPS_Sof1( 1,ph2,pA)
         sB(1,1)  =  gI*GPS_Sof1( 1,ph1,pB)
         sB(2,1)  =  gI*GPS_Sof1( 1,ph2,pB)
      ELSE
         sA(1,1)  = -gI*GPS_Sof1b( 1,ph1,pA,mA)
         sA(2,1)  = -gI*GPS_Sof1b( 1,ph2,pA,mA)
         sB(1,1)  =  gI*GPS_Sof1b( 1,ph1,pB,mB)
         sB(2,1)  =  gI*GPS_Sof1b( 1,ph2,pB,mB)
      ENDIF
      sA(1,2) = -DCONJG(sA(1,1))
      sA(2,2) = -DCONJG(sA(2,1))
      sB(1,2) = -DCONJG(sB(1,1))
      sB(2,2) = -DCONJG(sB(2,1))
* Calculate Born spin amplitudes
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    pB,-mB,      pC,MC,   pD,-mD,   BornABCD) ! Standard
      CALL GPS_Born(KFi,KFf,PX, ph1,mph,  pB,-mB,      pC,mC,   pD,-mD,   Born1BCD) ! A->1
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    ph1,-mph,    pC,mC,   pD,-mD,   BornA1CD) ! B->1
      CALL GPS_Born(KFi,KFf,PX, ph2,mph,  pB,-mB,      pC,mC,   pD,-mD,   Born2BCD) ! A->2
      CALL GPS_Born(KFi,KFf,PX, pA,mA,    ph2,-mph,    pC,mC,   pD,-mD,   BornA2CD) ! B->2
      CALL GPS_Born(KFi,KFf,PX, ph1,mph,  ph2,-mph,    pC,mC,   pD,-mD,   Born12CD) ! A->1,B->2
      CALL GPS_Born(KFi,KFf,PX, ph2,mph,  ph1,-mph,    pC,mC,   pD,-mD,   Born21CD) ! A->2,B->1
* Fermion propagarotors ini1
      prA1= 1d0/(pA(4)*ph1(4)-pA(3)*ph1(3)-pA(2)*ph1(2)-pA(1)*ph1(1))/2d0
      prB1=-1d0/(pB(4)*ph1(4)-pB(3)*ph1(3)-pB(2)*ph1(2)-pB(1)*ph1(1))/2d0
* Fermion propagarotors ini2
      prA2= 1d0/(pA(4)*ph2(4)-pA(3)*ph2(3)-pA(2)*ph2(2)-pA(1)*ph2(1))/2d0
      prB2=-1d0/(pB(4)*ph2(4)-pB(3)*ph2(3)-pB(2)*ph2(2)-pB(1)*ph2(1))/2d0
* DOUBLE propagators
      prA12= 1d0/( pA(4)*ph1(4)- pA(3)*ph1(3)- pA(2)*ph1(2)- pA(1)*ph1(1)
     $           + pA(4)*ph2(4)- pA(3)*ph2(3)- pA(2)*ph2(2)- pA(1)*ph2(1)
     $           -ph1(4)*ph2(4)+ph1(3)*ph2(3)+ph1(2)*ph2(2)+ph1(1)*ph2(1)
     $           )/2d0
      prB12=-1d0/( pB(4)*ph1(4)- pB(3)*ph1(3)- pB(2)*ph1(2)- pB(1)*ph1(1)
     $            +pB(4)*ph2(4)- pB(3)*ph2(3)- pB(2)*ph2(2)- pB(1)*ph2(1)
     $           -ph1(4)*ph2(4)+ph1(3)*ph2(3)+ph1(2)*ph2(2)+ph1(1)*ph2(1)
     $           )/2d0
      Fprop1=(1d0/prA1+1d0/prA2)*prA12-1d0
      Fprop2=(1d0/prB1+1d0/prB2)*prB12-1d0
      Sig = 3-2*Hel1
      IF( m_KeyArb  .EQ.  0 ) THEN
         CALL GPS_MatrU( gI, ph1,Sig,  ph1,mph, pA,mA,     U11a) ! <1|[1]|a>
         CALL GPS_MatrV( gI, ph1,Sig,  pB,mB,   ph1,mph,   Vb11) ! <b|{1}|1>
* falSe second
         CALL GPS_MatrU( gI, ph1,Sig,  ph2,mph, pA,mA,     U21a) ! <2|[1]|a>
         CALL GPS_MatrV( gI, ph1,Sig,  pB,mB,   ph2,mph,   Vb12) ! <b|{1}|2>
* reverse order
         CALL GPS_MatrU( gI, ph1,Sig,  pA,mA,   ph2,mph,   Ua12) ! <a|[1]|2>
         CALL GPS_MatrV( gI, ph1,Sig,  ph2,mph, pB,mB,     V21b) ! <2|{1}|b>
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrU( gI, ph1,Sig,  ph1,mph, ph2,mph,   U112) ! <1|[1]|2>
         CALL GPS_MatrV( gI, ph1,Sig,  ph2,mph, ph1,mph,   V211) ! <2|{1}|1>
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrU( gI, ph1,Sig,  ph2,mph, ph2,mph,   U212) ! <2|[1]|2>
         CALL GPS_MatrV( gI, ph1,Sig,  ph2,mph, ph2,mph,   V212) ! <2|{1}|2>
      ELSE
         CALL GPS_MatrUb(gI, ph1,Sig,  ph1,mph, pA,mA,     U11a)
         CALL GPS_MatrVb(gI, ph1,Sig,  pB,mB,   ph1,mph,   Vb11)
* falSe second
         CALL GPS_MatrUb(gI, ph1,Sig,  ph2,mph, pA,mA,     U21a)
         CALL GPS_MatrVb(gI, ph1,Sig,  pB,mB,   ph2,mph,   Vb12)
* reverse order
         CALL GPS_MatrUb(gI, ph1,Sig,  pA,mA,   ph2,mph,   Ua12)
         CALL GPS_MatrVb(gI, ph1,Sig,  ph2,mph, pB,mB,     V21b)
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrUb(gI, ph1,Sig,  ph1,mph, ph2,mph,   U112)
         CALL GPS_MatrVb(gI, ph1,Sig,  ph2,mph, ph1,mph,   V211)
* for the case when there was ph2 first xk-xk term
         CALL GPS_MatrUb(gI, ph1,Sig,  ph2,mph, ph2,mph,   U212)
         CALL GPS_MatrVb(gI, ph1,Sig,  ph2,mph, ph2,mph,   V212)
      ENDIF
      Sig = 3-2*Hel2
      IF( m_KeyArb  .EQ.  0 ) THEN
         CALL GPS_MatrU( gI, ph2,Sig,  ph2,mph,  pA,mA,    U22a) ! <2|[2]|a>
         CALL GPS_MatrV( gI, ph2,Sig,  pB,mB,   ph2,mph,   Vb22) ! <b|{2}|2>
* falSe second
         CALL GPS_MatrU( gI, ph2,Sig,  ph1,mph,  pA,mA,    U12a) ! <1|[2]|a>
         CALL GPS_MatrV( gI, ph2,Sig,  pB,mB,   ph1,mph,   Vb21) ! <b|{2}|1>
* reverse order
         CALL GPS_MatrU( gI, ph2,Sig,  pA,mA,   ph1,mph,   Ua21) ! <a|[2]|1>
         CALL GPS_MatrV( gI, ph2,Sig,  ph1,mph, pB,mB,     V12b) ! <1|{2}|b>
* for the case when there was ph1 first xk-xk term
         CALL GPS_MatrU( gI, ph2,Sig,  ph2,mph, ph1,mph,   U221) ! <2|[2]|1>
         CALL GPS_MatrV( gI, ph2,Sig,  ph1,mph, ph2,mph,   V122) ! <1|{2}|2>
c for the case when there was ph1 first xk-xk term
         CALL GPS_MatrU( gI, ph2,Sig,  ph1,mph, ph1,mph,   U121) ! <1|[2]|1>
         CALL GPS_MatrV( gI, ph2,Sig,  ph1,mph, ph1,mph,   V121) ! <1|{2}|1>
      ELSE
         CALL GPS_MatrUb(gI, ph2,Sig,  ph2,mph,  pA,mA,    U22a)
         CALL GPS_MatrVb(gI, ph2,Sig,  pB,mB,   ph2,mph,   Vb22)
c falSe second
         CALL GPS_MatrUb(gI, ph2,Sig,  ph1,mph,  pA,mA,    U12a)
         CALL GPS_MatrVb(gI, ph2,Sig,  pB,mB,   ph1,mph,   Vb21)
c reverse order
         CALL GPS_MatrUb(gI, ph2,Sig,  pA,mA,   ph1,mph,   Ua21)
         CALL GPS_MatrVb(gI, ph2,Sig,  ph1,mph, pB,mB,     V12b)
c for the case when there was ph1 first xk-xk term
         CALL GPS_MatrUb(gI, ph2,Sig,  ph2,mph, ph1,mph,   U221)
         CALL GPS_MatrVb(gI, ph2,Sig,  ph1,mph, ph2,mph,   V122)
c for the case when there was ph1 first xk-xk term
         CALL GPS_MatrUb(gI, ph2,Sig,  ph1,mph, ph1,mph,   U121)
         CALL GPS_MatrVb(gI, ph2,Sig,  ph1,mph, ph1,mph,   V121)
      ENDIF
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Su1 = DCMPLX(0d0,0d0)
                  DO j=1,2
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    |                  1               2                         //
*        //                    |X                 |               |                         //
*        //      _       -b    |      b+m-1-2     |      a+m-2    |      a                  //
*        //      v  ------<----O--------<---------U--------<------S------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1+Born1BCD(j,j2,j3,j4) *U11a(j,j1)*(prA12-prA1*N_IR)*sA(2,Hel2) !<b|X|1[1]a(2)|a>
                     Su1=Su1+Born2BCD(j,j2,j3,j4) *U21a(j,j1)*   prA12         *sA(2,Hel2) !<b|X|2[1]a(2)|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    |                  2               1                         //
*        //                    |X                 |               |                         //
*        //      _       -b    |      b+m-1-2     |      a+m-1    |      a                  //
*        //      v  ------<----O--------<---------U-------<-------S------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1+Born2BCD(j,j2,j3,j4) *U22a(j,j1)*(prA12-prA2*N_IR)*sA(1,Hel1) !<b|X|2[2]a(1)|a>
                     Su1=Su1+Born1BCD(j,j2,j3,j4) *U12a(j,j1)* prA12           *sA(1,Hel1) !<b|X|1[2]a(1)|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    2                  1               |                         //
*        //                    |                  |               |X                        //
*        //      _       -b    |     -b+m+2       |    -b+m+1+2   |      a                  //
*        //      v  ------<----S--------<---------V--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1+( sB(2,Hel2)*(-prB1*N_IR+prB12))*Vb11(j2,j)*BornA1CD(j1,j,j3,j4)!<b|(2)b[1]1|X|a>
                     Su1=Su1+( sB(2,Hel2))           *prB12  *Vb12(j2,j)*BornA2CD(j1,j,j3,j4)!<b|(2)b[1]2|X|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    1                  2               |                         //
*        //                    |                  |               |X                        //
*        //      _       -b    |     -b+m+1       |    -b+m+1+2   |      a                  //
*        //      v  ------<----S--------<---------V--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +(sB(1,Hel1)*(-prB2*N_IR+prB12))*Vb22(j2,j)*BornA2CD(j1,j,j3,j4)!<b|(1)b[2]2|X|a>
                     Su1=Su1 +(sB(1,Hel1))           *prB12  *Vb21(j2,j)*BornA1CD(j1,j,j3,j4)!<b|(1)b[2]1|X|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    2                  |               1                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+2       |     a+m-1     |      a                  //
*        //      v  ------<----S--------<---------O--------<------U------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +sB(2,Hel2)    *Born1BCD(j,j2,j3,j4) *prA1*U11a(j,j1) *Y_IR !<b|(2)2|X|1[1]|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    1                  |               2                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+1       |     a+m-2     |      a                  //
*        //      v  ------<----S--------<---------O--------<------U------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +sB(1,Hel1)    *Born2BCD(j,j2,j3,j4) *prA2*U22a(j,j1) *Y_IR !<b|(1)1|X|2[2]|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    1                  |               2                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+1       |     a+m-2     |      a                  //
*        //      v  ------<----V--------<---------O--------<------S------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +Vb11(j2,j)*prB1 *BornA1CD(j1,j,j3,j4) *sA(2,Hel2)    *Y_IR !<b|[1]1|X|a[2]|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    2                  |               1                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+2       |     a+m-1     |      a                  //
*        //      v  ------<----V--------<---------O--------<------S------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                     Su1=Su1 +Vb22(j2,j)*prB2 *BornA2CD(j1,j,j3,j4) *sA(1,Hel1)    *Y_IR !<b|[2]2|X|a(1)|a>
                  ENDDO
                  Su2 = DCMPLX(0d0,0d0)
                  DO j=1,2
                     DO l=1,2
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    2                  |               1                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+2       |     a+m-1     |      a                  //
*        //      v  ------<----*--------<---------O--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2  +Vb22(j2,l)*prB2  *Born12CD(j,l,j3,j4 )  *U11a(j,j1)*prA1 ! <b|[2]2|X|1[1]|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    1                  |               2                         //
*        //                    |                  |X              |                         //
*        //      _       -b    |     -b+m+1       |     a+m-2     |      a                  //
*        //      v  ------<----*--------<---------O--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2  +Vb11(j2,l)*prB1  *Born21CD(j,l,j3,j4 )  *U22a(j,j1)*prA2 ! <b|[1]1|X|2[2]|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    |                  2               1                         //
*        //                    |X                 |               |                         //
*        //      _       -b    |      b+m-1-2     |      a+m-1    |      a                  //
*        //      v  ------<----O--------<---------O--------<------*------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Born1BCD(j,j2,j3,j4) *U121(j,l)*prA12 *U11a(l,j1)*prA1  ! <b|X|1[2]1(1)|a>
                        Su2=Su2 +Born2BCD(j,j2,j3,j4) *U221(j,l)*prA12 *U11a(l,j1)*prA1  ! <b|X|2[2]1(1)|a>
                        Su2=Su2 -BornABCD(j,j2,j3,j4) *Ua21(j,l)*prA12 *U11a(l,j1)*prA1  ! <b|X|a[2]1(1)|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    |                  1               2                         //
*        //                    |X                 |               |                         //
*        //      _       -b    |      b+m-1-2     |      a+m-2    |      a                  //
*        //      v  ------<----O--------<---------O--------<------*------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Born2BCD(j,j2,j3,j4) *U212(j,l)*prA12  *U22a(l,j1)*prA2 ! <b|X|2[1]2(2)|a>
                        Su2=Su2 +Born1BCD(j,j2,j3,j4) *U112(j,l)*prA12  *U22a(l,j1)*prA2 ! <b|X|1[1]2(2)|a>
                        Su2=Su2 -BornABCD(j,j2,j3,j4) *Ua12(j,l)*prA12  *U22a(l,j1)*prA2 ! <b|X|a[1]2(2)|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    1                  2               |                         //
*        //                    |                  |               |X                        //
*        //      _       -b    |     -b+m+1       |    -b+m+1+2   |      a                  //
*        //      v  ------<----*--------<---------O--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Vb11(j2,l)*prB1 *V121(l,j)*prB12 *BornA1CD(j1,j,j3,j4) ! <b|(1)1[2]1|X|a>
                        Su2=Su2 +Vb11(j2,l)*prB1 *V122(l,j)*prB12 *BornA2CD(j1,j,j3,j4) ! <b|(1)1[2]2|X|a>
                        Su2=Su2 -Vb11(j2,l)*prB1 *V12b(l,j)*prB12 *BornABCD(j1,j,j3,j4) ! <b|(1)1[2]b|X|a>
*        /////////////////////////////////////////////////////////////////////////////////////
*        //                    2                  1               |                         //
*        //                    |                  |               |X                        //
*        //      _       -b    |     -b+m+2       |    -b+m+1+2   |      a                  //
*        //      v  ------<----*--------<---------O--------<------O------<----- u           //
*        /////////////////////////////////////////////////////////////////////////////////////
                        Su2=Su2 +Vb22(j2,l)*prB2 *V212(l,j)*prB12  *BornA2CD(j1,j,j3,j4) ! <b|(2)2[1]2|X|a>
                        Su2=Su2 +Vb22(j2,l)*prB2 *V211(l,j)*prB12  *BornA1CD(j1,j,j3,j4) ! <b|(2)2[1]1|X|a>
                        Su2=Su2 -Vb22(j2,l)*prB2 *V21b(l,j)*prB12  *BornABCD(j1,j,j3,j4) ! <b|(2)2[2]b|X|a>
                     ENDDO
                  ENDDO
                  sProd = ( sA(1,Hel1)+sB(1,Hel1))*( sA(2,Hel2)+sB(2,Hel2))
                  AmpWork(j1,j2,j3,j4) =AmpWork(j1,j2,j3,j4)
     $                 +CNorm*( Su1+Su2 )
     $                 +CNorm*BornABCD(j1,j2,j3,j4)*( sA(1,Hel1)*sA(2,Hel2)*Fprop1  !
     $                                               +sB(1,Hel1)*sB(2,Hel2)*Fprop2) !
     $                 +CNorm*BornABCD(j1,j2,j3,j4)* sProd                   *Y_IR  !
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       ! GPS_HiiPlus    


      SUBROUTINE GPS_Hini(KFi,KFf,PX, p1,m1,p2,m2,p3,m3,p4,m4,ph,mph, AmHarIsr)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   IR-finite part od 1-photon amplitudes for ISR                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4),ph(4)
      DOUBLE PRECISION      m1,m2,m3,m4,mph

      DOUBLE COMPLEX  AmHarIsr(2,2,2,2,2)
      DOUBLE COMPLEX  AmpBornU(2,2,2,2)
      DOUBLE COMPLEX  AmpBornV(2,2,2,2)
      DOUBLE COMPLEX  Csum1,Csum2,U(2,2),V(2,2)
      INTEGER    j,j1,j2,j3,j4,k,Sig
      DOUBLE PRECISION      pr1,pr2,Fleps
*----------------------------------------
      Fleps =  1d-100
* ISR non-infrared two parts: (1) p1 -> photon, contracted with U-matrix
*                             (2) p2 -> photon, contracted with V-matrix
      CALL GPS_Born(KFi,KFf,PX, ph,mph,    p2,-Fleps,  p3,m3, p4,-m4, AmpBornU)
      CALL GPS_Born(KFi,KFf,PX, p1,Fleps,  ph,-mph,    p3,m3, p4,-m4, AmpBornV)
***   CALL GPS_BPrint(6,'Bo(k234)',AmpBornU)
***   CALL GPS_BPrint(6,'Bo(1k34)',AmpBornV)
* Fermion propagarotors
      pr1 = 1d0/(p1(4)*ph(4)-p1(3)*ph(3)-p1(2)*ph(2)-p1(1)*ph(1))/2d0
      pr2 =-1d0/(p2(4)*ph(4)-p2(3)*ph(3)-p2(2)*ph(2)-p2(1)*ph(1))/2d0
      DO k=1,2
         Sig = 3-2*k
         IF( m_KeyArb .EQ. 0 ) THEN
            CALL GPS_MakeU(ph,Sig,  ph,mph,  p1,m1,    U)
            CALL GPS_MakeV(ph,Sig,  p2,m2,   ph,mph,   V)
         ELSE
            CALL GPS_MakeUb(ph,Sig, ph,mph,  p1,m1,    U)
            CALL GPS_MakeVb(ph,Sig, p2,m2,   ph,mph,   V)
         ENDIF
***      WRITE(*,*) ' ///// sig = ', sig
***      CALL GPS_UPrint(6,' U(k,p1)    ',U)
***      CALL GPS_UPrint(6,' V(p2,k)    ',V)
         DO j1=1,2
            DO j2=1,2
               DO j3=1,2
                  DO j4=1,2
                     Csum1=DCMPLX(0d0,0d0)
                     Csum2=DCMPLX(0d0,0d0)
                     DO j=1,2
                        Csum1=Csum1 +U(j,j1)*pr1 *AmpBornU( j,j2,j3,j4)
                        Csum2=Csum2 +V(j2,j)*pr2 *AmpBornV(j1, j,j3,j4)
                     ENDDO
                     AmHarIsr(j1,j2,j3,j4,k) =  Csum1+Csum2
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       !!! GPS_Hini

      SUBROUTINE GPS_HiniPlus(KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,ph,mph,Hel,Sactu,sProd)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   IR-finite part od 1-photon amplitudes for ISR  (equiv. to GPS_Hini)           //
*//   Photon helicity imported from the calling program                             //
*//                                                                                 //
*//   m_AmpExpo*  is working space                                                  //
*//   m_AmpBorn   is hidden INPUT                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4),ph(4)
      DOUBLE PRECISION      m1,m2,m3,m4,mph
      DOUBLE COMPLEX        Sactu,sProd
      INTEGER               Hel
      DOUBLE COMPLEX        AmpBornU(2,2,2,2)
      DOUBLE COMPLEX        AmpBornV(2,2,2,2)
      DOUBLE COMPLEX        Csum1,Csum2,U(2,2),V(2,2)
      DOUBLE COMPLEX        AmpExpo1,AmpExpo2,AmpBorn
      INTEGER               j,j1,j2,j3,j4,k,Sig
      DOUBLE PRECISION      pr1,pr2,Fleps
      DOUBLE PRECISION      BornV_GetCharge,Qe
      DOUBLE COMPLEX        Vir1,Vir2
*----------------------------------------
      Fleps =  1d-100
      Qe =  BornV_GetCharge( KFi)

* Virtual corrections
      CALL  BVR_MakeVini(m_Alfpi,Qe,p1,m1,p2,m2,ph, Vir1,Vir2)
***   WRITE(*,*) 'ph/ene,Vir1,Vir2  =',ph(4)/p1(4),Vir1,Vir2

* ISR non-infrared two parts: (1) p1 -> photon, contracted with U-matrix
*                             (2) p2 -> photon, contracted with V-matrix
* Calculate Born spin amplitudes
****> CALL GPS_Born(KFi,KFf,PX, p1,Mbeam,  p2,-Mbeam,  p3,Massf,p4,-Massf,m_AmpBorn) !!!!<****
      CALL GPS_Born(KFi,KFf,PX, ph,mph,    p2,-Fleps,  p3,m3,   p4,-m4,   AmpBornU)
      CALL GPS_Born(KFi,KFf,PX, p1,Fleps,  ph,-mph,    p3,m3,   p4,-m4,   AmpBornV)
* Fermion propagarotors
      pr1 = 1d0/(p1(4)*ph(4)-p1(3)*ph(3)-p1(2)*ph(2)-p1(1)*ph(1))/2d0
      pr2 =-1d0/(p2(4)*ph(4)-p2(3)*ph(3)-p2(2)*ph(2)-p2(1)*ph(1))/2d0
      Sig = 3-2*Hel
      IF( m_KeyArb .EQ. 0 ) THEN
         CALL GPS_MakeU(ph,Sig,  ph,mph,  p1,m1,    U)
         CALL GPS_MakeV(ph,Sig,  p2,m2,   ph,mph,   V)
      ELSE
         CALL GPS_MakeUb(ph,Sig, ph,mph,  p1,m1,    U)
         CALL GPS_MakeVb(ph,Sig, p2,m2,   ph,mph,   V)
      ENDIF
      DO j1=1,2
         DO j2=1,2
            DO j3=1,2
               DO j4=1,2
                  Csum1=DCMPLX(0d0,0d0)
                  Csum2=DCMPLX(0d0,0d0)
                  DO j=1,2
                     Csum1=Csum1 +DCMPLX(Qe *m_e_QED) *U(j,j1)*pr1 *AmpBornU( j,j2,j3,j4)
                     Csum2=Csum2 +DCMPLX(Qe *m_e_QED) *V(j2,j)*pr2 *AmpBornV(j1, j,j3,j4)
                  ENDDO
                  AmpBorn  =  m_AmpBorn(j1,j2,j3,j4)
                  AmpExpo1 =  sProd/Sactu*(Csum1+Csum2)
**/////////////// under construction
** (1+Vir1)*AmpBorn is already included in AmpExpo0 so we drop it to avoid double counting
** Note that remaining Vir2*AmpBorn is IR-finite because Vir2->0 in the IR limit
                  AmpExpo2 =  
     $                 sProd/Sactu*(Csum1+Csum2) *(1+Vir1+Vir2)*(1+m_F1fin1) ! non-IR sigle bremss. part
     $                       +sProd*AmpBorn*Vir2                             ! add virtual_non_IR*Born
**//////////////////////
                  m_AmpExpo1(j1,j2,j3,j4) =m_AmpExpo1(j1,j2,j3,j4) +AmpExpo1
                  m_AmpExpo2(j1,j2,j3,j4) =m_AmpExpo2(j1,j2,j3,j4) +AmpExpo2
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      END                       !!! GPS_HiniPlus


*/////////////////////////////////////////////////////////////////////////////////////////////
*//                   End of class BVR                                                      //
*/////////////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//                         Pseudo-CLASS  GPS                                       //
*//                                                                                 //
*//       Purpose:  Calculation of spin amplitudes using spinor methods             //
*//                                                                                 //
*//   This is still an experimental stage, a lot of code is still for testing       //
*//   purpose, some of code will go away to other parts of the program.             //
*//                                                                                 //
*//    WARNIG:  !!!!!!!!!!!!!!!!!!!!!!![[[[[[[[]]]]]]]!!!!!!!!!!!!!!!               //
*//    Function BVR_SBvirt modified temporarily to avoid problem with pi**2/beta    //
*//    Not important for anything in practice                                       //
*//    WARNIG:  !!!!!!!!!!!!!!!!!!!!!!![[[[[[[[]]]]]]]!!!!!!!!!!!!!!!               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE GPS_Initialize
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Class initialization                                                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      INCLUDE 'BXformat.h'
      INCLUDE 'GPS.h'
      INTEGER j1,j2,k,KeyPia
      INTEGER init
      DOUBLE PRECISION    alfa

      SAVE    init
      DATA init/0/
*------------------------------------
      IF(init .EQ. 1) RETURN
      init = 1
*------------------------------------
      m_out    = 6
*
*/////////////////////////////////////////////////////////////////////////////////////
*//                        Import from   BornV                                      //
*/////////////////////////////////////////////////////////////////////////////////////
* EW parameters
      CALL BornV_GetSwsq(  m_Sw2 )
      CALL BornV_GetGmu(   m_Gmu)
      CALL BornV_GetMZ(    m_MZ)
      CALL BornV_GetGammZ( m_GammZ)
      CALL BornV_GetAlfInv(m_AlfInv)
      alfa   = 1d0/m_AlfInv
      m_e_QED  = DSQRT( 4d0*m_pi*alfa)
      m_Alfpi  = alfa/m_pi
      CALL BornV_GetKeyElw(m_KeyElw)
      CALL BornV_GetKeyZet(m_KeyZet)
*
      CALL KK2f_GetKeyISR(m_KeyISR)
      CALL KK2f_GetKeyFSR(m_KeyFSR)
      CALL KK2f_GetKeyINT(m_KeyINT)
      CALL KK2f_GetKeyGPS(m_KeyGPS)
      CALL KK2f_GetVcut(  m_Vcut)
*
*/////////////////////////////////////////////////////////////////////////////////////
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  GPS   Initializator                '
      WRITE(m_out,bxl1f) m_MZ    ,   'Z mass     [GeV]   ','MZ    ','a1'
      WRITE(m_out,bxl1f) m_GammZ,    'Z width    [GeV]   ','GammZ ','a2'
      WRITE(m_out,bxl1f) m_Sw2,      'sin(theta_w)**2    ','Sw2   ','a3'
      WRITE(m_out,bxl1f) m_AlfInv,   '1/alfa_QED  at  Q=0','AlfInv','a4'
      WRITE(m_out,bxtxt) 'Test switches:                         '
      WRITE(m_out,bxl1i) m_KeyZet,   'Z on/off   switch  ','KeyZet','a5'
      WRITE(m_out,bxl1i) m_KeyElw,   'Electroweak lib.   ','KeyElw','a6'
      WRITE(m_out,bxl1i) m_KeyGPS,   'CEEX level         ','KeyGPS','a7'
      WRITE(m_out,bxl1i) m_KeyISR,   'ISR emission       ','KeyISR','a8'
      WRITE(m_out,bxl1i) m_KeyFSR,   'FSR emission       ','KeyFSR','a9'
      WRITE(m_out,bxl1i) m_KeyINT,   'ISR*FSR interferenc','KeyINT','a10'
      WRITE(m_out,bxclo)
*/////////////////////////////////////////////////////////////////////////////////////
* Key for switching on/off the use of m_b, can be reset with GPS_SetKeyArb
      m_KeyArb = 0 ! default zero value, m_b=Xi is assumed
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '     Initialization of GPS class      '
      WRITE(m_out,bxclo)
********************************
*     Define Pauli matrices
      DO k = 0,3
         DO j1 = 1,2
            DO j2 = 1,2
               m_Pauli( k,j1,j2) = DCMPLX(0d0,0d0)
            ENDDO
         ENDDO
      ENDDO
* Sigma0
      m_Pauli( 0,1,1) = DCMPLX( 1d0, 0d0)
      m_Pauli( 0,2,2) = DCMPLX( 1d0, 0d0)
* SigmaX
      m_Pauli( 1,1,2) = DCMPLX( 1d0, 0d0)
      m_Pauli( 1,2,1) = DCMPLX( 1d0, 0d0)
* SigmaY
      m_Pauli( 2,1,2) = DCMPLX( 0d0,-1d0)
      m_Pauli( 2,2,1) = DCMPLX( 0d0, 1d0)
* SigmaZ
      m_Pauli( 3,1,1) = DCMPLX( 1d0, 0d0)
      m_Pauli( 3,2,2) = DCMPLX(-1d0, 0d0)
*
* The other notation for 4-vector index
      DO k = 1,3
         DO j1 = 1,2
            DO j2 = 1,2
               m_Pauli4( k,j1,j2) = m_Pauli( k,j1,j2)
            ENDDO
         ENDDO
      ENDDO
      DO j1 = 1,2
         DO j2 = 1,2
            m_Pauli4( 4,j1,j2) = m_Pauli( 0,j1,j2)
         ENDDO
      ENDDO
********************************
*     Define GPS vectors in CMS
*     Note that they define uniquely the inner products
*     and spin quantization axises in fermion rest frame
      DO k = 1,4
         m_Xi(k)  = 0d0
         m_Eta(k) = 0d0
      ENDDO
      m_Xi( 4)  =  1d0
      m_Xi( 1)  =  1d0
      m_Eta(2)  =  1d0
* axial vectors (arbitrary lightlike ) for photon polarization
      m_b1( 1)   =  0.8723d0
      m_b1( 2)   = -0.7683d0
      m_b1( 3)   =  0.3348d0
      m_b1( 4)   =  DSQRT(m_b1( 1)**2 + m_b1( 2)**2 +m_b1( 3)**2)
* another random setting
      m_b2( 1)   = -0.78833d0
      m_b2( 2)   =  0.34788d0
      m_b2( 3)   = -0.33282d0
      m_b2( 4)   =  DSQRT(m_b2( 1)**2 + m_b2( 2)**2 +m_b2( 3)**2)
* this setting is very close to b=Xi, for special tests
      m_b3( 1)   =  1d0
      m_b3( 2)   =  1d-7
      m_b3( 3)   =  0d0
      m_b3( 4)   =  DSQRT(m_b3( 1)**2 + m_b3( 2)**2 +m_b3( 3)**2)
*
* default setting to m_b1, can be changed with CALL GPS_Setb2,3
      DO k=1,4
         m_b( k) = m_b1( k)
      ENDDO
*
      CALL KarFin_GetKeyPia(KeyPia)
      IF( (m_KeyFSR .EQ. 1) .AND.  (KeyPia .EQ. 0) ) THEN
         WRITE(*,*) ' +++++ STOP in GPS: you cannot have KeyPia=0 for GPS and FSR '
         STOP
      ENDIF
*
      END                       !!!end of GPS_Initialize!!!

      DOUBLE COMPLEX  FUNCTION GPS_iProd1(L,p,q)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// This is basic inner s-product of spinors s_{L}(p,q)=ubar_{L}(p)*u_{-L}(q)       //
*// We exploit identity s_{-}(p,q) = -[s_{+}(p,q)]^*                                //
*// Four-vectors p,q are in principle massless, however, massive p,q                //
*// are also meaningfull. Implicit projection on xi is then assumed.                //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER     L
      DOUBLE PRECISION       p(4), q(4)
      DOUBLE COMPLEX   Prod

      IF(     L .EQ.  1 ) THEN
         Prod=
     $        -DSQRT( (p(4)-p(1)) / (q(4)-q(1)) ) *DCMPLX(q(2),q(3))
     $        +DSQRT( (q(4)-q(1)) / (p(4)-p(1)) ) *DCMPLX(p(2),p(3))
      ELSEIF( L .EQ. -1 ) THEN
         Prod=
     $        -DSQRT( (q(4)-q(1)) / (p(4)-p(1)) ) *DCMPLX(p(2),p(3))
     $        +DSQRT( (p(4)-p(1)) / (q(4)-q(1)) ) *DCMPLX(q(2),q(3))
         Prod= DCONJG(Prod)
      ELSE
         WRITE(*,*) '##### GPS_iProd1: Wrong L= ', L
      ENDIF
      GPS_iProd1 =  Prod
      END       

      DOUBLE COMPLEX  FUNCTION GPS_iProd2(Lamp,p,mp,Lamq,q,mq)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// General spinor product s_{l1,l2}(p,q) for massive spinors u and/or v            //
*// mp and mq are masses of p and q. Negative mass means antiparticle!              //
*//                                                                                 //
*// NOTES:                                                                          //
*// Antiparticle, v-spinor, is recognized according to sign of mass.                //
*// Spin sign is flipped for v-spinor.                                              //
*// This requires attention for zero-mass because zero mass particle is recognized  //
*// as u-spinor (no flip of spin).                                                  //
*// The way out is to give to antiparticle very small mass like -1e-150.            //
*//                                                                                 //
*// Note also that mp=0 or mq=0 for massive p, q, mean that p, q                    //
*// are projected on xi.                                                            //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     Lamp,Lamq
      DOUBLE PRECISION       p(4),q(4),mp,mq
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE COMPLEX   Prod
      INTEGER     Lp,Lq

      Lp = Lamp
      Lq = Lamq
* Helicity for v-spinor is fliped
      IF( mp .LT. 0d0) Lp = -Lp
      IF( mq .LT. 0d0) Lq = -Lq
* Helicity conservation and non-conservation separately
      IF(     Lp .EQ. -Lq ) THEN
         Prod = GPS_iProd1(Lp,p,q)
      ELSEIF( Lp .EQ.  Lq ) THEN
         Prod = DCMPLX( mp*GPS_XiProd(q,p) +mq*GPS_XiProd(p,q), 0d0)
      ELSE
         WRITE(*,*) '##### GPS_iProd2: Wrong Lp,Lq= ', Lp,Lq
      ENDIF
      GPS_iProd2 = Prod
      END       


      SUBROUTINE GPS_Make
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Spin amplitudes O(alf1) and O(alf0) for exponentiation.                       //
*//   Helicities of emitted photons are choosen randomly!!!                         //
*//                                                                                 //
*//   INPUT: is transfered from  BornV and KK2f using Getters                       //
*//                                                                                 //
*//   OUTPUT:                                                                       //
*//   m_AmpExpo0 =  O(alf0) spin amplitudes                                         //
*//   m_AmpExpo1 =  O(alf1) spin amplitudes                                         //
*//   m_AmpExpo2 =  O(alf2) spin amplitudes                                         //
*//   Wt0     =  O(alf0) exponentiation weight                                      //
*//   Wt1     =  O(alf1) exponentiation weight                                      //
*//                                                                                 //
*//   COMMON working space:                                                         //
*//   m_AmpExpo*  is working space, used by HiniPlus, HfinPlus, HfinMinus           //
*//   m_AmpBorn   is working space, used by HfinMinus                               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER               KFi,KFf,Nphot
      DOUBLE PRECISION      p1(4),p2(4),p3(4),p4(4),Phot(m_phmax,4)
*
      DOUBLE PRECISION      ph(4),ph1(4),ph2(4),PX(4),PP(4),QQ(4)
      INTEGER               i,j,k,l,n,j1,j2,last,loop,loop2,Hel,Hel1,Hel2
      DOUBLE PRECISION      ChaIni,ChaFin
      DOUBLE PRECISION      svar,svarX,svarX1,svarQ,Ene,betaf
      DOUBLE COMPLEX        GPS_soft,GPS_softb
      DOUBLE COMPLEX        Sini(2,m_phmax),Sfin(2,m_phmax)
      DOUBLE COMPLEX        CKine,sProd,Sactu,Sactu1,Sactu2,Cfact0,Cfact2
      DOUBLE PRECISION      Fleps,Massf,Mbeam,m1,m2,m3,m4,mph
      DOUBLE PRECISION      XborSum,XboxSum,CrudSum,Exp0Sum,Exp1Sum
      DOUBLE PRECISION      Xborn,Xboxy
      DOUBLE PRECISION      DistCru,BornCru,fLLux
      DOUBLE PRECISION      CrudNorm, ExpoNorm
      DOUBLE PRECISION      RhoCru3
      DOUBLE PRECISION      alfQED,alfpini,alfpfin, alfpmix, Emin, MasPhot
      DOUBLE PRECISION      BVR_SForFac,BVR_TForFac
      DOUBLE PRECISION      Yisr,Yfsr,Yint
      DOUBLE PRECISION      YFSkonIni, YFSkonFin, YFS_IRini, YFS_IRfin, YFS_isr, YFS_fsr
      DOUBLE PRECISION      BornV_GetMass, BornV_GetCharge, BornV_Simple,BornV_Differential
      DOUBLE PRECISION      Wt0,Wt1
      DOUBLE PRECISION      dummy
      DOUBLE PRECISION      QCDcor
      INTEGER               BornV_GetColor, NCf
      INTEGER               iSaveCPU
*-----------------------------------------------
      INTEGER   Icont
      SAVE      Icont
      DATA      Icont /0/
*-----------------------------------------------
      CALL GPS_Initialize
*
      CALL KK2f_GetKFini(   KFi)     ! Normaly for beam KFi=11 is electron
      CALL KarLud_GetKFfin( KFf)     ! Actual KFcode of the final fermion
      Mbeam  =  BornV_GetMass(   KFi)
      Massf  =  BornV_GetMass(   KFf)
      ChaIni =  BornV_GetCharge( KFi)
      ChaFin =  BornV_GetCharge( KFf)
      NCf    =  BornV_GetColor(  KFf)
      CALL BornV_GetQCDcor(QCDcor)

      Fleps =  1d-100
      m1  = Mbeam
      m2  = Mbeam
      m3  = Massf
      m4  = Massf
      mph = Fleps
      CALL KK2f_GetBeams(    p1,p2)
      CALL KK2f_GetFermions( p3,p4)
      CALL KK2f_GetPhotAll(Nphot,Phot) ! ordered in energy
      CALL KK2f_GetEmin( Emin)
      CALL KK2f_GetMasPhot(MasPhot)
*-------------------------------------------------------------
      DO k=1,4
         PP(k) = p1(k)+p2(k)
         QQ(k) = p3(k)+p4(k)
      ENDDO
      svar  = PP(4)**2 - PP(3)**2 - PP(2)**2 - PP(1)**2
      svarQ = QQ(4)**2 - QQ(3)**2 - QQ(2)**2 - QQ(1)**2
      Ene   = SQRT(svar)/2d0
*-------------------------------------------------------------
* Overall normalization factors
      CrudNorm  =  1d0
      ExpoNorm  =  2d0/(4d0*m_pi)*NCf*(1d0 +QCDcor)  ! it is still quasi-empirical...
*////////////////////////////////////////////////////////////////////////////////////
*//                         YFS  FormFactors                                       //
*//  Note that FSR formfactor below cannot be used for KeyPia=0, Emin is in CMS!!! //
*////////////////////////////////////////////////////////////////////////////////////
      alfQED   = m_e_QED**2/(4d0*m_pi)
      alfpini  = m_Alfpi*ChaIni**2
      alfpfin  = m_Alfpi*ChaFin**2
      alfpmix  = m_Alfpi*ChaFin*ChaIni
      IF( m_KeyISR .NE. 0) THEN
         CALL  BornV_GetYFS_IR( YFS_IRini )
         CALL  BornV_GetYFSkon( YFSkonIni )
****>>   YFS_isr =  YFS_IRini*YFSkonIni
         YFS_isr =  YFS_IRini       !!!<<**  YFSkon not in WtCrud (historical reasons)
         CrudNorm  = CrudNorm *YFS_isr
         Yisr= BVR_SForFac( alfpini, p1,Mbeam, p2,Mbeam, Emin, MasPhot)
         ExpoNorm  = ExpoNorm *Yisr
      ENDIF
      IF( m_KeyFSR .NE. 0) THEN
         CALL KarFin_GetYFS_IR( YFS_IRfin )
         CALL KarFin_GetYFSkon( YFSkonFin )
****>>   YFS_fsr =  YFS_IRfin*YFSkonFin
         YFS_fsr =  YFS_IRfin       !!!<<** YFSkon not in WtCrud (historical reasons)
         CrudNorm  = CrudNorm *YFS_fsr
         Yfsr= BVR_SForFac( alfpfin, p3,Massf, p4,Massf, Emin, MasPhot)
         ExpoNorm  = ExpoNorm *Yfsr
      ENDIF
* Remember Yint depends on Emin and provides angular asymmetry (MasPhot is dummy)
      IF(  m_KeyINT .NE. 0 .AND. m_KeyISR .NE. 0 .AND.  m_KeyFSR .NE. 0  ) THEN
         Yint= BVR_TForFac( alfpmix, p1,Mbeam, p3,Massf, Emin, MasPhot)
     $        *BVR_TForFac( alfpmix, p2,Mbeam, p4,Massf, Emin, MasPhot)
     $        *BVR_TForFac(-alfpmix, p1,Mbeam, p4,Massf, Emin, MasPhot)
     $        *BVR_TForFac(-alfpmix, p2,Mbeam, p3,Massf, Emin, MasPhot)
         ExpoNorm  = ExpoNorm *Yint
      ENDIF
*//////////////////////////////////////////////////////////////////
*//                       S-factors                              //
*//////////////////////////////////////////////////////////////////
* List of soft-factors, note that we calculate them for helicity=+1
* The other one helicity=-1 is just minus complex conjugate!
* Sig = 3-2*Hel, Hel=1,2 --> Sig=1,-1
      DO j=1,nphot
         CrudNorm = CrudNorm *1d0/(2d0*m_pi)**3    !!<-- photon phase-space factor
         ExpoNorm = ExpoNorm *1d0/(2d0*m_pi)**3    !!<-- photon phase-space factor
         DO k=1,4
            ph(k) = Phot(j,k)
         ENDDO
         IF( m_KeyArb .EQ. 0 ) THEN
            Sini(1,j)  =  DCMPLX(ChaIni*m_e_QED) *GPS_soft(  1,ph,p1,p2)
            Sfin(1,j)  = -DCMPLX(ChaFin*m_e_QED) *GPS_soft(  1,ph,p3,p4)
         ELSE
            Sini(1,j)  =  DCMPLX(ChaIni*m_e_QED) *GPS_softb( 1,ph,p1,m1,p2,m2)
            Sfin(1,j)  = -DCMPLX(ChaFin*m_e_QED) *GPS_softb( 1,ph,p3,m3,p4,m4)
         ENDIF
         Sini(2,j) = -DCONJG(Sini(1,j))
         Sfin(2,j) = -DCONJG(Sfin(1,j))
      ENDDO
*//////////////////////////////////////////////////////////////////
*//             Define (randomly) photon helicities              //
*//////////////////////////////////////////////////////////////////
* Photon gelicities are now generated in the main module KK2f and imported here
* This is better in case of multiple calls of GPS for the single event
      CALL KK2f_GetPhel(m_Phel)
***   CALL GPS_PhelRandom(nphot)
***   WRITE(*,'(a,20i2)') 'Phel=   ',(m_Phel(j),j=1,nphot)
      CALL GPS_BornZero(m_AmpExpo0)
      CALL GPS_BornZero(m_AmpExpo1)
      CALL GPS_BornZero(m_AmpExpo2)
      CrudSum = 0d0
      XborSum = 0d0
      XboxSum = 0d0
      iSaveCPU = 0
*//////////////////////////////////////////////////////////////////////
*//  *************************************************************   //
*//              LOOP OVER PARTITIONS STARTS HERE                    //
*//  Initialize loop over partitions, m_isr(j)=1,0 denotes isr,fsr   //
*//  *************************************************************   //
*//////////////////////////////////////////////////////////////////////
      CALL GPS_PartitionStart(nphot,last)
      DO loop=1,10000000
*        Calculate reduced 4-momentum to be used in gamma/Z propagator
         DO k=1,4
            PX(k) = p1(k)+p2(k)
         ENDDO
*   /////////////////////////////////////////////////////////
*   //         ===============================             //
*   //         Soft-part, soft-factors, m-zero             //
*   //         ===============================             //
*   /////////////////////////////////////////////////////////
         sProd=DCMPLX(1d0,0d0)
         DO j=1,nphot
            Hel  = m_Phel(j)+1
            Sactu  = m_isr(j)*Sini(Hel,j) + (1-m_isr(j))*Sfin(Hel,j)
            sProd  = sProd*Sactu
            DO k=1,4
               PX(k) = PX(k) -m_isr(j)*Phot(j,k)
            ENDDO
         ENDDO
         svarX = PX(4)**2 - PX(3)**2 - PX(2)**2 - PX(1)**2
         Cfact0 = sProd  *(svarX/svarQ)
         CALL GPS_BornPlus(iSaveCPU,KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4, Cfact0,Xborn,Xboxy)
*        ==================================================================================
*****    IF(nphot.EQ.0) CALL GPS_BPrint(6,' AmpBoxy ',m_AmpBoxy)
*****    IF(nphot.EQ.0) WRITE(*,'(a,5g20.10)') '#######>>> Boxy/Born = ',Xborn
*****    CALL GPS_BPrint(6,' AmpExp0',m_AmpExpo0)
*****    CALL GPS_BPrint(6,' AmpBoxy',m_AmpBoxy)
*****    WRITE(*,'(a,5g20.10)') '#######>>> Boxy/Born = ',Xborn
*  //////////////////////////////////////////////////////////////////////////////////////
*  //    Crude distribution as in low level Monte Carlo, see also KK2f_DsigOverDtau    //
*  //    We DO NOT use BornCru memorized in KK2f in order to be able to recalculate    //
*  //    Weights with another input parameters like MZ etc.                            //
*  //    This trick is susspended, have to think if it could be restored?              //
*  //////////////////////////////////////////////////////////////////////////////////////
*****    BornCru = 4d0/3d0*BornV_Simple( KFi,KFf,svarX, 0d0  )
         BornCru = 4d0/3d0*BornV_Differential(0,KFf,svarX,0d0,0d0,0d0,0d0,0d0)
         BornCru = BornCru *(svar/svarX)                                  !!<-- Born(svar)*svar
         fLLux   = svarX/svarQ                                            !!<-- extra LL factor
         betaf = DSQRT( 1d0 - 4*Massf**2/svarQ )                          !!<-- 2-body phase spase
         DistCru = BornCru/(4d0*m_pi) *fLLux *2d0/betaf *CDABS(sProd)**2  !!<-- CRUDE
         CrudSum =       CrudSum  + DistCru
         XborSum =       XborSum  + XBorn
         XboxSum =       XboxSum  + XBoxy
***      WRITE(*,'(a,5g20.10)') ' vv, Xborn/DistCru ', 1-svarX/svar, Xborn/DistCru
*   /////////////////////////////////////////////////////////////////
*   //         1-photon IR-finite contribution     ms-one           //
*   /////////////////////////////////////////////////////////////////
         iSaveCPU = 1
         IF(nphot .EQ. 0) GOTO 300
*        =========================
         DO j1=1,nphot
            DO k=1,4
               ph1(k) = Phot(j1,k)
            ENDDO
            IF( ph1(4)/Ene .GT. m_Vcut(1) ) THEN ! accept 1 hard only
               Hel1  = m_Phel(j1)+1
               Sactu1  = m_isr(j1)*Sini(Hel1,j1) + (1-m_isr(j1))*Sfin(Hel1,j1)
               SvarX1  = (QQ(4)+ph1(4))**2-(QQ(3)+ph1(3))**2-(QQ(2)+ph1(2))**2-(QQ(1)+ph1(1))**2 !
               CKine   = (svarX1/svarQ)
               IF( m_isr(j1) .EQ. 1) THEN
                  CALL GPS_HiniPlus(KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,ph1,mph,Hel1,Sactu1,sProd) !
               ELSE
                  CALL GPS_HfinPlus(KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,ph1,mph,Hel1,Sactu1,sProd,CKine) !
               ENDIF
            ENDIF
         ENDDO
*   /////////////////////////////////////////////////////////////////
*   //         2-photon IR-finite contribution   ms-two            //
*   /////////////////////////////////////////////////////////////////
*   O(alf2) correction to 2 photons in ISR or FSR, 
*   implicit Bose Einstein symmetrization inside HiiPlus, HffPlus
         DO j1=1,nphot
            DO j2=j1+1,nphot
               DO k=1,4
                  ph1(k) = Phot(j1,k)
                  ph2(k) = Phot(j2,k)
               ENDDO
               IF( (ph1(4)/Ene .GT. m_Vcut(2)) .AND. (ph2(4)/Ene .GT. m_Vcut(2)) ) THEN ! accept 2 hard only
                  Hel1  = m_Phel(j1)+1
                  Hel2  = m_Phel(j2)+1
                  Sactu2  = ( m_isr(j1)*Sini(Hel1,j1) + (1-m_isr(j1))*Sfin(Hel1,j1) ) !
     $                     *( m_isr(j2)*Sini(Hel2,j2) + (1-m_isr(j2))*Sfin(Hel2,j2) ) !
                  Cfact2 = sProd/Sactu2
                  IF(     (m_isr(j1) .EQ. 1) .AND. (m_isr(j2) .EQ. 1) ) THEN ! ini-ini
                     CALL GPS_HiiPlus(Cfact2,KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,Hel1,ph1,Hel2,ph2,mph,m_AmpExpo2) !
                  ELSEIF( (m_isr(j1) .EQ. 0) .AND. (m_isr(j2) .EQ. 0) ) THEN ! fin-fin
                     CALL GPS_HffPlus(Cfact2,KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,Hel1,ph1,Hel2,ph2,mph,m_AmpExpo2) !
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
*   O(alf2) correction to 1 photon ISR and 1 photon FSR, explicit Bose-Einstein symmetrisation
         DO j1=1,nphot
            DO j2=1,nphot
               IF( j1 .NE. j2) THEN
                  DO k=1,4
                     ph1(k) = Phot(j1,k)
                     ph2(k) = Phot(j2,k)
                  ENDDO
                  IF( (ph1(4)/Ene .GT. m_Vcut(2)) .AND. (ph2(4)/Ene .GT. m_Vcut(2)) ) THEN ! accept 2 hard only
                     Hel1  = m_Phel(j1)+1
                     Hel2  = m_Phel(j2)+1
                     Sactu2  = ( m_isr(j1)*Sini(Hel1,j1) + (1-m_isr(j1))*Sfin(Hel1,j1) ) !
     $                        *( m_isr(j2)*Sini(Hel2,j2) + (1-m_isr(j2))*Sfin(Hel2,j2) ) !
                     Cfact2 = sProd/Sactu2
                     IF(     (m_isr(j1) .EQ. 1) .AND. (m_isr(j2) .EQ. 0) ) THEN ! ini-fin
                        CALL GPS_HifPlus(Cfact2,KFi,KFf,PX,p1,m1,p2,m2,p3,m3,p4,m4,Hel1,ph1,Hel2,ph2,mph,m_AmpExpo2) !
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
*-------------------
*****    WRITE(*,'(f20.10,a,20i2)') sqrt(svarX),' >>> m_isr(j)= ',(m_isr(j),j=1,nphot)
*/////////////////////////////////////////////////////////
*//   Update m_isr, check if it is the last partition   //
*/////////////////////////////////////////////////////////
         IF(last .EQ. 1) GOTO 300
         CALL GPS_PartitionPlus(nphot,last)
         IF(last .EQ. 2) GOTO 300
      ENDDO
      write(*,*) '########### INCORRECT EXIT from loop over partitions'
      STOP
 300  CONTINUE
*//////////////////////////////////////////////////////////////////////
*//  *************************************************************   //
*//              LOOP OVER PARTITIONS ENDS HERE                      //
*//  *************************************************************   //
*//////////////////////////////////////////////////////////////////////

      m_RhoCrud = CrudSum *CrudNorm   !<-- Crude (unpolarized for the time being)
      CALL GPS_MakeRho(ExpoNorm)      !<-- Defines m_RhoExp0, m_RhoExp1, m_RhoExp2

*/////////////////////////////////////////////////////////////////////////////////
*//                     Assigning weight list                                   //
*/////////////////////////////////////////////////////////////////////////////////
      IF( m_KeyINT .EQ. 0 ) THEN
         m_WtSet( 51) =   m_RhoExp0 /m_RhoCrud    !!! Interference OFF
         m_WtSet( 52) =   m_RhoExp1 /m_RhoCrud
         m_WtSet( 53) =   m_RhoExp2 /m_RhoCrud
         m_WtBest     =   m_WtSet( 53)
      ELSE
         m_WtSet( 1)  =   m_RhoExp0 /m_RhoCrud    !!! Interference ON
         m_WtSet( 2)  =   m_RhoExp1 /m_RhoCrud
         m_WtSet( 3)  =   m_RhoExp2 /m_RhoCrud
         m_WtBest     =   m_WtSet( 3)
      ENDIF
*/////////////////////////////////////////////////////////////////////////////////
*//                     X-Checks   Printouts                                    //
*/////////////////////////////////////////////////////////////////////////////////
* debug variables for tests
      m_debg( 3) = XBorSum
      m_debg( 4) = XBoxSum
*
      IF(Icont .GE. 100 )  RETURN
***      WRITE(*,'(3a)') '**************************************************'
***     $                            ,' !!!GPS_Make!!! ',
***     $                '**************************************************'
***      WRITE( *,'(a,i10,6g20.12)') 'GPS_Make::  nphot, vq, wt0,wt1,wt2',
***     $     nphot, 1-svarQ/svar, m_WtSet( 1),m_WtSet( 2),m_WtSet( 3)
***      CALL GPS_BPrint(6,'m_AmpEx0',m_AmpExpo0)
***      CALL GPS_BPrint(6,'m_AmpEx1',m_AmpExpo1)
***      CALL GPS_BPrint(6,'m_AmpEx2',m_AmpExpo2)
***   IF(Wt1 .LT. 10d0 )  RETURN
***   IF( (1-svarQ/svar) .LT. 0.1d0 ) RETURN
***   IF( nphot.NE.0 ) RETURN
***   Wt0 = Exp0Sum/XborSum/2**nphot
***   Wt1 = Exp1Sum/XborSum/2**nphot
***   CALL KK2f_Print1(6)
* X-check with DsigOverDtau makes sense ONLY for KeyINT=0
***   CALL  KK2f_DsigOverDtau(6,RhoCru3)
***   WRITE(*,'(a,5g20.12)') '***  nphot, vq, wt0,wt1', nphot, 1-svarQ/svar,wt0,wt1
***   WRITE(*,'(a,5g20.12)') '*** CDABS(sProd)**2 = ', CDABS(sProd)**2 *CrudNorm
***   WRITE(*,'(a,5g20.12)') '*** m_RhoCrud/RhoCru3 = ', m_RhoCrud/RhoCru3, m_RhoCrud

      Icont = Icont +1
      END                       !!!end of GPS_Make!!!


      SUBROUTINE GPS_MakeBorn(KFi,KFf,PX,p1,p2,p3,p4,Born)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Define spin amplitudes and calculate Born x-section.                          //
*//   Resulting spin amplitudes stored in m_AmpBorn                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER    KFi,KFf
      DOUBLE PRECISION      PX(4),p1(4),p2(4),p3(4),p4(4),Born
*
      INTEGER    k,j1,j2,j3,j4
      DOUBLE PRECISION      Massf,Mbeam,Sum,Fleps
      DOUBLE PRECISION      svarX,svarQ,BetaFin
      INTEGER    NCf,BornV_GetColor
      DOUBLE PRECISION      BornV_GetMass
      DOUBLE PRECISION      PQ(4)
*----------------------------------
      CALL GPS_Initialize
      Mbeam  =  BornV_GetMass(KFi)
      Massf =  BornV_GetMass(KFf)
      Fleps = 1d-100
      Mbeam  = Fleps             ! electron mass almost zero
      DO k=1,4
         PQ(k)=p3(k)+p4(k)
      ENDDO
      svarX=PX(4)**2-PX(3)**2-PX(2)**2-PX(1)**2
      svarQ=PQ(4)**2-PQ(3)**2-PQ(2)**2-PQ(1)**2
      IF(svarX .LE. 4*Massf**2) GOTO 900

* Calculate Born spin amplitudes
      CALL GPS_Born(KFi,KFf,PX,p1,Mbeam,p2,-Mbeam,p3,Massf,p4,-Massf,m_AmpBorn)
* Calculate total x-section
      CALL GPS_BornSumSq(m_AmpBorn,Sum)
* Phase Space factor, Lorenz Beta due to final state 2-body phase space
      BetaFin = SQRT(1d0 -4d0*Massf**2/svarQ)
      Born = Sum*BetaFin
* Color factor
      NCf = BornV_GetColor(KFf)
      Born = NCf*Born
      RETURN
 900  Born = 0d0
      END


      SUBROUTINE GPS_MakeBorn1(KFi,KFf,p1,p2,p3,p4,Born)
*///////////////////////////////////////////////////////////////////////////////
*//  !!!!!  TEST !!!!!   !!!!!  TEST !!!!! !!!!!  TEST !!!!! !!!!!  TEST !!!  //
*//                                                                           //
*//  Born  spin amplitudes, spinor method, massles, based on Chisholm         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER KFi,KFf
      DOUBLE PRECISION   p1(4),p2(4),p3(4),p4(4)
      DOUBLE PRECISION   Born
*
      DOUBLE PRECISION    T3e,Qe,Ve,Ae
      DOUBLE PRECISION    T3f,Qf,Af,Vf
      INTEGER  NCf,NCe
      DOUBLE PRECISION    BetaFin, svar
*-----------------------------------------------------------------------------
      DOUBLE COMPLEX  PropGam,PropZet
      DOUBLE COMPLEX  AmpGam(2,2,2,2),AmpZet(2,2,2,2)
      INTEGER    i,j,k,l
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  s31,s24,s14,s32
      DOUBLE PRECISION      CupGam,CupZet
      DOUBLE COMPLEX  HeliFactor
      DOUBLE COMPLEX  GPS_iProd1
      DOUBLE COMPLEX  GPS_iProd2
      DOUBLE PRECISION      Massf,Mbeam
      DOUBLE PRECISION      Sum
*-----------------------------------------------------------------------------
      CALL GPS_Initialize
      CALL BornV_GetParticle(KFf, Massf,Qf,T3f,NCf)
      CALL BornV_GetParticle(KFi, Mbeam, Qe,T3e,NCe)
      svar= (p1(4)+p2(4))**2 -(p1(3)+p2(3))**2 -(p1(2)+p2(2))**2 -(p1(1)+p2(1))**2
      IF(svar .LE. 4*Massf**2) GOTO 900
* Couplings
      Ve    = (2*T3e -4*Qe*m_Sw2)/DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Ae    =  2*T3e             /DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Vf    = (2*T3f -4*Qf*m_Sw2)/DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Af    =  2*T3f             /DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      IF(m_KeyZet .LE. 0) THEN
         Ve=0d0
         Ae=0d0
      ENDIF
      IF(m_KeyZet .EQ. 9) THEN
         Qe=0d0
         Qf=0d0
      ENDIF
*=============================================================
* Propagators
      PropGam =    DCMPLX(  1d0/svar,  0d0)
      PropZet =    1d0/DCMPLX(svar-m_MZ**2, m_GammZ*svar/m_MZ)
      IF(m_KeyZet .EQ.-1) PropZet =  1d0/DCMPLX(Svar-m_MZ**2, m_GammZ*m_MZ)
*=============================================================
* Clean
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  AmpGam( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
                  AmpZet( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
                  m_AmpBorn1( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
               ENDDO
            ENDDO
         ENDDO
      ENDDO
* Spinor, massles, based on Chisholm
      DO j1 = 1,2
         DO j3 = 1,2
            Hel1 = 3-2*j1
            Hel3 = 3-2*j3
            Hel2 = -Hel1        ! helicity conservation initial state
            Hel4 = -Hel3        ! helicity conservation initial state
            j2  = (3-Hel2)/2
            j4  = (3-Hel4)/2
            CupGam = Qe*Qf
            IF( Hel1 .EQ. -Hel3 ) THEN
               s31 = GPS_iProd1( -Hel1,p3,p1)
               s24 = GPS_iProd1(  Hel1,p2,p4)
               HeliFactor = s31*s24
               CupZet = (Ve +Hel2*Ae)*(Vf +Hel1*Af)
            ELSE
               s14 = GPS_iProd1( -Hel1,p1,p4)
               s32 = GPS_iProd1(  Hel1,p3,p2)
               HeliFactor = s14*s32
               CupZet = (Ve +Hel2*Ae)*(Vf +Hel2*Af)
            ENDIF
            AmpGam( j1,j2,j3,j4) = HeliFactor*PropGam*CupGam
            AmpZet( j1,j2,j3,j4) = HeliFactor*PropZet*CupZet
            m_AmpBorn1(j1,j2,j3,j4) = AmpGam(j1,j2,j3,j4)+AmpZet(j1,j2,j3,j4)
         ENDDO
      ENDDO
* Spin sumation/averaging
      CALL GPS_BornSumSq(m_AmpBorn1,Sum)
* Lorenz Beta due to final state 2-body phase space
      BetaFin = SQRT(1d0 -4d0*Massf**2/svar)
      Born = Sum*BetaFin
      Born = NCf*Born           ! Color factor
      RETURN
 900  Born = 0d0
      END                       !!!!!!  GPS_MakeBorn1


      SUBROUTINE GPS_MakeBorn2(KFi,KFf,p1,p2,p3,p4,Born)
*//////////////////////////////////////////////////////////////////////////////////
*//  !!!!!  TEST !!!!!   !!!!!  TEST !!!!! !!!!!  TEST !!!!! !!!!!  TEST !!!     //
*//                                                                              //
*//   Clasical, massive/massles, in terms of cos(theta), similar to KORALB       //
*//   We use here KORALB spin amplitudes for pure s-chanel photons               //
*//   Note that for KORALB x-axis is perpendicular to reaction plane             //
*//   while in JacobWick y-axis is perpendicular to reaction plane.              //
*//   We expect in Rmat, for pure s-chanel photon exchange,                      //
*//   strictly zero correlations between in-plane  and                           //
*//   perpendicular-to-plane components, see APP B15 (1984) p. 1154, eq. (2.6)   //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER KFi,KFf
      DOUBLE PRECISION   p1(4),p2(4),p3(4),p4(4)
      DOUBLE PRECISION   Born
*
      DOUBLE PRECISION    T3e,Qe,Ve,Ae
      DOUBLE PRECISION    T3f,Qf,Af,Vf
      INTEGER  NCf,NCe
      DOUBLE PRECISION    BetaFin
      DOUBLE PRECISION    svar,CosTheta
*-----------------------------------------------------------------------------
      DOUBLE COMPLEX  PropGam,PropZet
      DOUBLE COMPLEX  AmpGam(2,2,2,2),AmpZet(2,2,2,2)
      INTEGER    i,j,k,l
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  s31,s24,s14,s32
      DOUBLE PRECISION      CupGam,CupZet,CupZet1,CupZet2
      DOUBLE COMPLEX  HeliFactor
      DOUBLE COMPLEX  GPS_iProd1
      DOUBLE COMPLEX  GPS_iProd2
      DOUBLE PRECISION      Massf,Mbeam,Mfin,SinTheta
      DOUBLE PRECISION      Sum,Fleps
*-----------------------------------------------------------------------------
      CALL GPS_Initialize
      CALL BornV_GetParticle(KFf, Massf,Qf,T3f,NCf)
      CALL BornV_GetParticle(KFi, Mbeam, Qe,T3e,NCe)
      svar= (p1(4)+p2(4))**2 -(p1(3)+p2(3))**2 -(p1(2)+p2(2))**2 -(p1(1)+p2(1))**2
      Mfin = Massf*2d0/sqrt(svar)
      IF(svar .LE. 4*Massf**2) GOTO 900
      CosTheta= (p1(3)*p3(3)+p1(2)*p3(2)+p1(1)*p3(1))
     $     /SQRT(p1(3)*p1(3)+p1(2)*p1(2)+p1(1)*p1(1))
     $     /SQRT(p3(3)*p3(3)+p3(2)*p3(2)+p3(1)*p3(1))
      IF(abs(CosTheta) .GT. 1d0) WRITE(*,*) ' BornV: CosTheta=',CosTheta
      SinTheta = SQRT(1d0-CosTheta**2)
      WRITE(*,*) ' GPS_MakeBorn2: svar,CosTheta=',svar,CosTheta
* Couplings
      Ve    = (2*T3e -4*Qe*m_Sw2)/DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Ae    =  2*T3e             /DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Vf    = (2*T3f -4*Qf*m_Sw2)/DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      Af    =  2*T3f             /DSQRT(m_Sw2*(1d0-m_Sw2))/4d0
      IF(m_KeyZet .LE. 0) THEN
         Ve=0d0
         Ae=0d0
      ENDIF
      IF(m_KeyZet .EQ. 9) THEN
         Qe=0d0
         Qf=0d0
      ENDIF
*=============================================================
* Propagators
      PropGam =    DCMPLX(  1d0/svar,  0d0)
      PropZet =    1d0/DCMPLX(svar-m_MZ**2, m_GammZ*svar/m_MZ)
      IF(m_KeyZet .EQ.-1) PropZet =  1d0/DCMPLX(Svar-m_MZ**2, m_GammZ*m_MZ)
*=============================================================
* Clean
      DO j1 = 1,2
         DO j2 = 1,2
            DO j3 = 1,2
               DO j4 = 1,2
                  AmpGam( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
                  AmpZet( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
                  m_AmpBorn2( j1,j2,j3,j4) = DCMPLX(0d0,0d0)
               ENDDO
            ENDDO
         ENDDO
      ENDDO
* Clasical, massles
      DO j1 = 1,2
         DO j3 = 1,2
            DO j4 = 1,2
               Hel1 = 3-2*j1
               Hel3 = 3-2*j3
               Hel4 = 3-2*j4
               Hel2 = -Hel1     ! helicity conservation
               j2  = (3-Hel2)/2
***[[ With finite Massf this part is valid strictly if you switch off Z exchange
               IF(Hel3 .EQ. -Hel4) THEN
                  HeliFactor = -DCMPLX( 0d0, Hel1*Hel3 -CosTheta )
               ELSE         
                  HeliFactor = -DCMPLX(Mfin*SinTheta, 0d0)
***  Activate line below if you want to get rid of mass effects completely!!!
***               HeliFactor = -DCMPLX(0d0, 0d0)
               ENDIF
***]]
               CupGam = Qe*Qf
               CupZet = (Ve +Hel2*Ae)*(Vf +Hel3*Af)
               AmpGam( j1,j2,j3,j4) = HeliFactor*PropGam*CupGam
               AmpZet( j1,j2,j3,j4) = HeliFactor*PropZet*CupZet
               m_AmpBorn2(j1,j2,j3,j4) =
     $              (AmpGam(j1,j2,j3,j4)+AmpZet(j1,j2,j3,j4))*svar/2
            ENDDO
         ENDDO
      ENDDO
* Spin sumation/averaging
      CALL GPS_BornSumSq(m_AmpBorn2,Sum)
      Born = Sum
* Lorenz Beta due to final state 2-body phase space
      BetaFin = SQRT(1d0 -4d0*Massf**2/svar)
      Born = Born*BetaFin
      Born = NCf*Born           ! Color factor
      RETURN
 900  Born = 0d0
      END      !GPS_MakeBorn2

      SUBROUTINE GPS_MakeRho(ExpoNorm)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Calculate differential distributions (normalized to LIPS) from spin ampl.  //
*//                UNPOLARIZED final fermions                                    //
*//                                                                              //
*//   To be done:                                                                //
*//   One needs to put wigner rotation for initial polarizations somewhere       //
*//   either in setter called in KK2f, or in flight, for every event             //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
* params
      DOUBLE PRECISION      ExpoNorm
* locals
      INTEGER               j1,j2,j3,j4,i1,i2,i3,i4
      DOUBLE PRECISION      Sum0, Sum1, Sum2
      DOUBLE PRECISION      polar1,  polar2
      DOUBLE COMPLEX        Tensor0, Tensor1, Tensor2, SDMprod
*----------------------------------
* Normalized factor to LIPS for CEEX amplitudes is memorized for further use
      m_ExpoNorm = ExpoNorm
*
      polar1 = SQRT(ABS(m_PolBeam1(3)**2 +m_PolBeam1(2)**2 +m_PolBeam1(1)**2))
      polar2 = SQRT(ABS(m_PolBeam2(3)**2 +m_PolBeam2(2)**2 +m_PolBeam2(1)**2))
      Sum0 = 0d0
      Sum1 = 0d0
      Sum2 = 0d0
      IF( (polar1+polar2) .LT. 1d-6) THEN
*        The case with UNPOLARIZED beams and UNPOLARIZED final fermions
         DO j1 = 1,2
            DO j2 = 1,2
               DO j3 = 1,2
                  DO j4 = 1,2
                     Sum0 = Sum0 +m_AmpExpo0(j1,j2,j3,j4)*DCONJG(m_AmpExpo0(j1,j2,j3,j4))
                     Sum1 = Sum1 +m_AmpExpo1(j1,j2,j3,j4)*DCONJG(m_AmpExpo1(j1,j2,j3,j4))
                     Sum2 = Sum2 +m_AmpExpo2(j1,j2,j3,j4)*DCONJG(m_AmpExpo2(j1,j2,j3,j4))
                  ENDDO                  
               ENDDO
            ENDDO
         ENDDO
      ELSE
*        The case with POLARIZED beams and UNPOLARIZED final fermions
         DO j1=1,2
         DO i1=1,2
            DO j2=1,2
            DO i2=1,2
               DO j3=1,2
                  DO j4=1,2
                     SDMprod = m_SDMat1(i1,j1)*m_SDMat2(i2,j2)
                     Tensor0 = m_AmpExpo0(i1,i2,j3,j4)*DCONJG(m_AmpExpo0(j1,j2,j3,j4))
                     Tensor1 = m_AmpExpo1(i1,i2,j3,j4)*DCONJG(m_AmpExpo1(j1,j2,j3,j4))
                     Tensor2 = m_AmpExpo2(i1,i2,j3,j4)*DCONJG(m_AmpExpo2(j1,j2,j3,j4))
                     Sum0 = Sum0 + Tensor0 *SDMprod
                     Sum1 = Sum1 + Tensor1 *SDMprod
                     Sum2 = Sum2 + Tensor2 *SDMprod
                  ENDDO
               ENDDO
            ENDDO
            ENDDO
         ENDDO
         ENDDO
      ENDIF
      m_RhoExp0 = Sum0 *ExpoNorm
      m_RhoExp1 = Sum1 *ExpoNorm
      m_RhoExp2 = Sum2 *ExpoNorm
      END                       !!!GPS_MakeRho!!!

      SUBROUTINE GPS_MakeRho2(wt0,wt1,wt2)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Used in Taupair_ImprintSpin                                                //
*//                                                                              //
*//   Calculate differential distributions (normalized to LIPS) from spin ampl.  //
*//                  POLARIZED final fermions                                    //
*//                                                                              //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
* params
      DOUBLE PRECISION   wt0,wt1,wt2
* locals
      INTEGER      j1,j2,j3,j4,i1,i2,i3,i4
      DOUBLE PRECISION        Sum0, Sum1, Sum2
      DOUBLE PRECISION        polar1,  polar2
      DOUBLE COMPLEX          Tensor0, Tensor1, Tensor2, SDMprod
      DOUBLE PRECISION        Rho0, Rho1, Rho2
*----------------------------------
      polar1 = SQRT(ABS(m_PolBeam1(3)**2 +m_PolBeam1(2)**2 +m_PolBeam1(1)**2))
      polar2 = SQRT(ABS(m_PolBeam2(3)**2 +m_PolBeam2(2)**2 +m_PolBeam2(1)**2))
      Sum0 = 0d0
      Sum1 = 0d0
      Sum2 = 0d0
      IF( (polar1+polar2) .LT. 1d-6) THEN
*        The case with UNPOLARIZED beams and POLARIZED final fermions
         DO j1 = 1,2
            DO j2 = 1,2
               DO j3 = 1,2
               DO i3 = 1,2
                     DO j4 = 1,2
                     DO i4 = 1,2
                        SDMprod = m_SDMat3(j3,i3)*m_SDMat4(j4,i4)
                        Tensor0 = m_AmpExpo0(j1,j2,i3,i4)*DCONJG(m_AmpExpo0(j1,j2,j3,j4))
                        Tensor1 = m_AmpExpo1(j1,j2,i3,i4)*DCONJG(m_AmpExpo1(j1,j2,j3,j4))
                        Tensor2 = m_AmpExpo2(j1,j2,i3,i4)*DCONJG(m_AmpExpo2(j1,j2,j3,j4))
                        Sum0 = Sum0 + Tensor0 *SDMprod
                        Sum1 = Sum1 + Tensor1 *SDMprod
                        Sum2 = Sum2 + Tensor2 *SDMprod
                     ENDDO                  
                     ENDDO
               ENDDO
               ENDDO
            ENDDO
         ENDDO
      ELSE
*        The case with POLARIZED beams and POLARIZED final fermions
         DO j1=1,2
         DO i1=1,2
            DO j2=1,2
            DO i2=1,2
               DO j3=1,2
               DO i3=1,2
                  DO j4=1,2
                  DO i4=1,2
                     SDMprod = m_SDMat1(i1,j1)*m_SDMat2(i2,j2)
     $                        *m_SDMat3(j3,i3)*m_SDMat4(j4,i4)
                     Tensor0 = m_AmpExpo0(i1,i2,i3,i4)*DCONJG(m_AmpExpo0(j1,j2,j3,j4))
                     Tensor1 = m_AmpExpo1(i1,i2,i3,i4)*DCONJG(m_AmpExpo1(j1,j2,j3,j4))
                     Tensor2 = m_AmpExpo2(i1,i2,i3,i4)*DCONJG(m_AmpExpo2(j1,j2,j3,j4))
                     Sum0 = Sum0 + Tensor0 *SDMprod
                     Sum1 = Sum1 + Tensor1 *SDMprod
                     Sum2 = Sum2 + Tensor2 *SDMprod
                  ENDDO
                  ENDDO
               ENDDO
               ENDDO
            ENDDO
            ENDDO
         ENDDO
         ENDDO
      ENDIF
* distributions with polarized final fermions
      Rho0 = Sum0 *m_ExpoNorm
      Rho1 = Sum1 *m_ExpoNorm
      Rho2 = Sum2 *m_ExpoNorm
* Spin weight for  polarized final fermions
      wt0 = Rho0/m_RhoExp0
      wt1 = Rho1/m_RhoExp1
      wt2 = Rho2/m_RhoExp2
      END                       !!!GPS_MakeRho2!!!



      SUBROUTINE GPS_MakeU(ph,sigma,p1,m1,p2,m2,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix U, (epsilon-slash sandwiched between ubar-u spinors)        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   U(2,2)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE PRECISION       Sqr2
*-----------
      Sqr2 = DSQRT(2d0)
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         U(1,1) =  Sqr2*( GPS_XiProd(p2,ph) *GPS_iProd1(1,ph,p1))           ! (++)
         U(2,2) =  Sqr2*( GPS_XiProd(p1,ph) *GPS_iProd1(1,ph,p2))           ! (--)
         U(1,2) =  0d0                                                      ! (+-)
         U(2,1) =  Sqr2*( -m1*GPS_XiProd(p2,p1) +m2*GPS_XiProd(p1,p2))      ! (-+)
      ELSEIF(sigma. EQ. -1 ) THEN
         U(1,1) =  Sqr2*( GPS_XiProd(p1,ph) *GPS_iProd1(-1,ph,p2))          ! (++)
         U(2,2) =  Sqr2*( GPS_XiProd(p2,ph) *GPS_iProd1(-1,ph,p1))          ! (--)
         U(2,1) =  0d0                                                      ! (-+)
         U(1,2) =  Sqr2*( -m1*GPS_XiProd(p2,p1) +m2*GPS_XiProd(p1,p2))      ! (+-)
      ELSE
         Write(*,*) '++++++++ GPS_MakeU: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MakeU


      SUBROUTINE GPS_MakeUb(ph,sigma,p1,m1,p2,m2,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix U, (epsilon-slash sandwiched between ubar-u spinors)        //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//   m_b     = auxiliary lightlike vector IS IMPLICIT INPUT                        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   U(2,2)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE COMPLEX   Cnor
*-----------
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1(-1,ph,m_b)
         U(1,1) = Cnor*(     GPS_iProd1(  1,p1, ph)*GPS_iProd1(-1,m_b,p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         U(2,2) = Cnor*(     GPS_iProd1( -1,p1,m_b)*GPS_iProd1( 1,ph, p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         U(1,2) = Cnor*(    +m1*GPS_XiProd( m_b,p1)*GPS_iProd1( 1,ph, p2)    !(+-)
     $                      +m2*GPS_XiProd( m_b,p2)*GPS_iProd1( 1,p1, ph) )
         U(2,1) = Cnor*(    +m1*GPS_XiProd(  ph,p1)*GPS_iProd1(-1,m_b,p2)    !(-+)
     $                      +m2*GPS_XiProd(  ph,p2)*GPS_iProd1(-1,p1,m_b) )
      ELSEIF(sigma. EQ. -1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1( 1,ph,m_b)
         U(1,1) = Cnor*(     GPS_iProd1(  1,p1,m_b)*GPS_iProd1(-1,ph, p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         U(2,2) = Cnor*(     GPS_iProd1( -1,p1, ph)*GPS_iProd1( 1,m_b,p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         U(2,1) = Cnor*(    +m1*GPS_XiProd( m_b,p1)*GPS_iProd1(-1,ph, p2)    !(-+)
     $                      +m2*GPS_XiProd( m_b,p2)*GPS_iProd1(-1,p1, ph) )
         U(1,2) = Cnor*(    +m1*GPS_XiProd(  ph,p1)*GPS_iProd1( 1,m_b,p2)    !(+-)
     $                      +m2*GPS_XiProd(  ph,p2)*GPS_iProd1( 1,p1,m_b) )
      ELSE
         Write(*,*) '++++++++ GPS_MakeUb: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MakeUb



      SUBROUTINE GPS_MakeUE(ph,sigma,p1,m1,p2,m2,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Alternative construction of U using MultiE, essentialy for tests.             //
*//   Note that one cannot input Xi into MultiE                                     //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'GPS.h'
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   U(2,2)
      DOUBLE COMPLEX   A1(2,2),A2(2,2)
      DOUBLE PRECISION       eps
      INTEGER     i,j,k
      DOUBLE COMPLEX   Csum,Norm
      DOUBLE COMPLEX   GPS_iProd1
*-----------
      CALL GPS_Initialize
      eps = 1d-100
      CALL GPS_MultiE(      1,  p1, m1,  p1, m1,   sigma, m_b,eps,  ph,eps,   A1)
      CALL GPS_MultiE(  sigma,  ph,eps, m_b,eps,       1,  p2, m2,  p2, m2,   A2)
      Norm = DSQRT(2d0) /GPS_iProd1(-sigma,ph,m_b)
      CALL  GPS_times(Norm,A1,A2,U)
      END                       !!!!  GPS_MakeUE

      SUBROUTINE GPS_MakeV(ph,sigma,p1,m1,p2,m2,V)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix V, (epsilon-slash sandwiched between v vbar spinors)        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   V(2,2)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE PRECISION       Sqr2
*-----------
      Sqr2 = DSQRT(2d0)
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         V(2,2) =  Sqr2*( GPS_XiProd(p2,ph) *GPS_iProd1(1,ph,p1))            !(--)
         V(1,1) =  Sqr2*( GPS_XiProd(p1,ph) *GPS_iProd1(1,ph,p2))            !(++)
         V(2,1) =  0d0                                                       !(-+)
         V(1,2) =  Sqr2*( m1*GPS_XiProd(p2,p1) -m2*GPS_XiProd(p1,p2))        !(+-)
      ELSEIF(sigma. EQ. -1 ) THEN
         V(2,2) =  Sqr2*( GPS_XiProd(p1,ph) *GPS_iProd1(-1,ph,p2))           !(--)
         V(1,1) =  Sqr2*( GPS_XiProd(p2,ph) *GPS_iProd1(-1,ph,p1))           !(++)
         V(1,2) =  0d0                                                       !(+-)
         V(2,1) =  Sqr2*( m1*GPS_XiProd(p2,p1) -m2*GPS_XiProd(p1,p2))        !(-+)
      ELSE
         Write(*,*) '++++++++ GPS_MakeV: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MakeV

      SUBROUTINE GPS_MakeVb(ph,sigma,p1,m1,p2,m2,V)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix V, (epsilon-slash sandwiched between vbar-v spinors)        //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//   m_b     = auxiliary lightlike vector IS IMPLICIT INPUT                        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   V(2,2)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE COMPLEX   Cnor
*-----------
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1(-1,ph,m_b)
         V(2,2) = Cnor*(     GPS_iProd1(  1,p1, ph)*GPS_iProd1(-1,m_b,p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         V(1,1) = Cnor*(     GPS_iProd1( -1,p1,m_b)*GPS_iProd1( 1,ph, p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         V(2,1) = Cnor*(    -m1*GPS_XiProd( m_b,p1)*GPS_iProd1( 1,ph, p2)    !(-+)
     $                      -m2*GPS_XiProd( m_b,p2)*GPS_iProd1( 1,p1, ph) )
         V(1,2) = Cnor*(    -m1*GPS_XiProd(  ph,p1)*GPS_iProd1(-1,m_b,p2)    !(+-)
     $                      -m2*GPS_XiProd(  ph,p2)*GPS_iProd1(-1,p1,m_b) )
      ELSEIF(sigma. EQ. -1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1( 1,ph,m_b)
         V(2,2) = Cnor*(     GPS_iProd1(  1,p1,m_b)*GPS_iProd1(-1,ph, p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         V(1,1) = Cnor*(     GPS_iProd1( -1,p1, ph)*GPS_iProd1( 1,m_b,p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         V(1,2) = Cnor*(    -m1*GPS_XiProd( m_b,p1)*GPS_iProd1(-1,ph, p2)    !(+-)
     $                      -m2*GPS_XiProd( m_b,p2)*GPS_iProd1(-1,p1, ph) )
         V(2,1) = Cnor*(    -m1*GPS_XiProd(  ph,p1)*GPS_iProd1( 1,m_b,p2)    !(-+)
     $                      -m2*GPS_XiProd(  ph,p2)*GPS_iProd1( 1,p1,m_b) )
      ELSE
         Write(*,*) '++++++++ GPS_MakeVb: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MakeVb

      SUBROUTINE GPS_MakeVE(ph,sigma,p1,m1,p2,m2,V)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Alternative construction of V using MultiE, essentialy for tests.             //
*//   Note that one cannot input Xi into MultiE                                     //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'GPS.h'
      INTEGER     sigma,l1,l2
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   V(2,2)
      DOUBLE COMPLEX   A1(2,2),A2(2,2)
      DOUBLE PRECISION       eps
      INTEGER     i,j,k
      DOUBLE COMPLEX   Csum,Norm
      DOUBLE COMPLEX   GPS_iProd1
*-----------
      CALL GPS_Initialize
      eps = 1d-100
      CALL GPS_MultiE(      1,  p1,-m1,  p1,-m1,   sigma, m_b,eps,  ph,eps,   A1)
      CALL GPS_MultiE(  sigma,  ph,eps, m_b,eps,       1,  p2,-m2,  p2,-m2,   A2)
      Norm = DSQRT(2d0) /GPS_iProd1(-sigma,ph,m_b)
      CALL  GPS_times(Norm,A1,A2,V)
      END                       !!!!  GPS_MakeVE




      SUBROUTINE GPS_MatrU(Cfact,ph,sigma,p1,m1,p2,m2,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix U, (epsilon-slash sandwiched between ubar-u spinors)        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER           sigma,l1,l2
      DOUBLE PRECISION  ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX    Cfact,U(2,2)
      DOUBLE COMPLEX    GPS_iProd1
      DOUBLE PRECISION  GPS_XiProd
      DOUBLE COMPLEX    Norm
*-----------
      Norm = DSQRT(2d0)*Cfact
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         U(1,1) =  Norm*( GPS_XiProd(p2,ph) *GPS_iProd1(1,ph,p1))           ! (++)
         U(2,2) =  Norm*( GPS_XiProd(p1,ph) *GPS_iProd1(1,ph,p2))           ! (--)
         U(1,2) =  0d0                                                      ! (+-)
         U(2,1) =  Norm*( -m1*GPS_XiProd(p2,p1) +m2*GPS_XiProd(p1,p2))      ! (-+)
      ELSEIF(sigma. EQ. -1 ) THEN
         U(1,1) =  Norm*( GPS_XiProd(p1,ph) *GPS_iProd1(-1,ph,p2))          ! (++)
         U(2,2) =  Norm*( GPS_XiProd(p2,ph) *GPS_iProd1(-1,ph,p1))          ! (--)
         U(2,1) =  0d0                                                      ! (-+)
         U(1,2) =  Norm*( -m1*GPS_XiProd(p2,p1) +m2*GPS_XiProd(p1,p2))      ! (+-)
      ELSE
         Write(*,*) '++++++++ GPS_MatrU: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MatrU


      SUBROUTINE GPS_MatrUb(Cfact,ph,sigma,p1,m1,p2,m2,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix U, (epsilon-slash sandwiched between ubar-u spinors)        //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//   m_b     = auxiliary lightlike vector IS IMPLICIT INPUT                        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER           sigma,l1,l2
      DOUBLE PRECISION  ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX    Cfact,U(2,2)
      DOUBLE COMPLEX    GPS_iProd1
      DOUBLE PRECISION  GPS_XiProd
      DOUBLE COMPLEX    Cnor
*-----------
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1(-1,ph,m_b)*Cfact
         U(1,1) = Cnor*(     GPS_iProd1(  1,p1, ph)*GPS_iProd1(-1,m_b,p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         U(2,2) = Cnor*(     GPS_iProd1( -1,p1,m_b)*GPS_iProd1( 1,ph, p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         U(1,2) = Cnor*(    +m1*GPS_XiProd( m_b,p1)*GPS_iProd1( 1,ph, p2)    !(+-)
     $                      +m2*GPS_XiProd( m_b,p2)*GPS_iProd1( 1,p1, ph) )
         U(2,1) = Cnor*(    +m1*GPS_XiProd(  ph,p1)*GPS_iProd1(-1,m_b,p2)    !(-+)
     $                      +m2*GPS_XiProd(  ph,p2)*GPS_iProd1(-1,p1,m_b) )
      ELSEIF(sigma. EQ. -1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1( 1,ph,m_b)*Cfact
         U(1,1) = Cnor*(     GPS_iProd1(  1,p1,m_b)*GPS_iProd1(-1,ph, p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         U(2,2) = Cnor*(     GPS_iProd1( -1,p1, ph)*GPS_iProd1( 1,m_b,p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         U(2,1) = Cnor*(    +m1*GPS_XiProd( m_b,p1)*GPS_iProd1(-1,ph, p2)    !(-+)
     $                      +m2*GPS_XiProd( m_b,p2)*GPS_iProd1(-1,p1, ph) )
         U(1,2) = Cnor*(    +m1*GPS_XiProd(  ph,p1)*GPS_iProd1( 1,m_b,p2)    !(+-)
     $                      +m2*GPS_XiProd(  ph,p2)*GPS_iProd1( 1,p1,m_b) )
      ELSE
         Write(*,*) '++++++++ GPS_MatrUb: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MatrUb

      SUBROUTINE GPS_MatrV(Cfact,ph,sigma,p1,m1,p2,m2,V)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix V, (epsilon-slash sandwiched between v vbar spinors)        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER           sigma,l1,l2
      DOUBLE PRECISION  ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX    Cfact,V(2,2)
      DOUBLE COMPLEX    GPS_iProd1
      DOUBLE PRECISION  GPS_XiProd
      DOUBLE COMPLEX    Norm
*-----------
      Norm = DSQRT(2d0)*Cfact
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         V(2,2) =  Norm*( GPS_XiProd(p2,ph) *GPS_iProd1(1,ph,p1))            !(--)
         V(1,1) =  Norm*( GPS_XiProd(p1,ph) *GPS_iProd1(1,ph,p2))            !(++)
         V(2,1) =  0d0                                                       !(-+)
         V(1,2) =  Norm*( m1*GPS_XiProd(p2,p1) -m2*GPS_XiProd(p1,p2))        !(+-)
      ELSEIF(sigma. EQ. -1 ) THEN
         V(2,2) =  Norm*( GPS_XiProd(p1,ph) *GPS_iProd1(-1,ph,p2))           !(--)
         V(1,1) =  Norm*( GPS_XiProd(p2,ph) *GPS_iProd1(-1,ph,p1))           !(++)
         V(1,2) =  0d0                                                       !(+-)
         V(2,1) =  Norm*( m1*GPS_XiProd(p2,p1) -m2*GPS_XiProd(p1,p2))        !(-+)
      ELSE
         Write(*,*) '++++++++ GPS_MatrV: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MatrV

      SUBROUTINE GPS_MatrVb(Cfact,ph,sigma,p1,m1,p2,m2,V)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Transition matrix V, (epsilon-slash sandwiched between vbar-v spinors)        //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   ph      = photon  4-momentum                                                  //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//   m_b     = auxiliary lightlike vector IS IMPLICIT INPUT                        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER           sigma,l1,l2
      DOUBLE PRECISION  ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX    Cfact,V(2,2)
      DOUBLE COMPLEX    GPS_iProd1
      DOUBLE PRECISION  GPS_XiProd
      DOUBLE COMPLEX    Cnor
*-----------
      CALL GPS_Initialize
      IF(     sigma. EQ. 1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1(-1,ph,m_b)*Cfact
         V(2,2) = Cnor*(     GPS_iProd1(  1,p1, ph)*GPS_iProd1(-1,m_b,p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         V(1,1) = Cnor*(     GPS_iProd1( -1,p1,m_b)*GPS_iProd1( 1,ph, p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         V(2,1) = Cnor*(    -m1*GPS_XiProd( m_b,p1)*GPS_iProd1( 1,ph, p2)    !(-+)
     $                      -m2*GPS_XiProd( m_b,p2)*GPS_iProd1( 1,p1, ph) )
         V(1,2) = Cnor*(    -m1*GPS_XiProd(  ph,p1)*GPS_iProd1(-1,m_b,p2)    !(+-)
     $                      -m2*GPS_XiProd(  ph,p2)*GPS_iProd1(-1,p1,m_b) )
      ELSEIF(sigma. EQ. -1 ) THEN
         Cnor   = DCMPLX(DSQRT(2d0),0d0)/GPS_iProd1( 1,ph,m_b)*Cfact
         V(2,2) = Cnor*(     GPS_iProd1(  1,p1,m_b)*GPS_iProd1(-1,ph, p2)    !(--)
     $                +m1*m2*GPS_XiProd(    m_b,p2)*GPS_XiProd(   ph, p1) )
         V(1,1) = Cnor*(     GPS_iProd1( -1,p1, ph)*GPS_iProd1( 1,m_b,p2)    !(++)
     $                +m1*m2*GPS_XiProd(    m_b,p1)*GPS_XiProd(   ph, p2) )
         V(1,2) = Cnor*(    -m1*GPS_XiProd( m_b,p1)*GPS_iProd1(-1,ph, p2)    !(+-)
     $                      -m2*GPS_XiProd( m_b,p2)*GPS_iProd1(-1,p1, ph) )
         V(2,1) = Cnor*(    -m1*GPS_XiProd(  ph,p1)*GPS_iProd1( 1,m_b,p2)    !(-+)
     $                      -m2*GPS_XiProd(  ph,p2)*GPS_iProd1( 1,p1,m_b) )
      ELSE
         Write(*,*) '++++++++ GPS_MatrVb: WRONG sigma= ',sigma
      ENDIF
      END                       !!!! GPS_MatrVb

      SUBROUTINE GPS_MultiE(rho, a,ma,b,mb, mu,c,mc,d,md, Matrix)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Clever routine Multi introduced by Elzbieta Richter-Was.                      //
*//   Simplified version.                                                           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     rho,mu
      DOUBLE PRECISION       a(4),ma, b(4),mb, c(4),mc, d(4),md
      DOUBLE COMPLEX   Matrix(2,2)
      DOUBLE COMPLEX   GPS_iProd2
*------------------------------
      Matrix(1,1) = GPS_iProd2(  rho,a,ma,   mu,c,mc)
      Matrix(1,2) = GPS_iProd2(  rho,a,ma,  -mu,d,md)
      Matrix(2,1) = GPS_iProd2( -rho,b,mb,   mu,c,mc)
      Matrix(2,2) = GPS_iProd2( -rho,b,mb,  -mu,d,md)
*------------------------------
      END                       !!!! GPS_MultiE

      SUBROUTINE GPS_PartitionPlus(nphot,last)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   update m_isr, check if it is last partition                             //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER   nphot,last
      INTEGER   i
*
      IF(nphot .EQ. 1) last=1   !!! Exit next time
      m_isr(1)=m_isr(1)+1
      DO i=1,nphot
         IF( m_isr(i).EQ. 2 ) THEN
            m_isr(i)=0
            m_isr(i+1)=m_isr(i+1)+1
            IF( m_isr(nphot) .EQ. 2 ) last=2 !!! Immediate exit
         ENDIF
      ENDDO
      END

      SUBROUTINE GPS_PartitionStart(nphot,last)
*///////////////////////////////////////////////////////////////////////////////
*//   Initialize first partition                                              //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER   nphot,last
      INTEGER   i
*----------
      IF(     (m_KeyISR. EQ. 1) .AND. (m_KeyFSR. EQ. 1) ) THEN
         IF(      m_KeyINT .NE. 0) THEN
*     Normal case, ISR+FSR
            DO i = 1,nphot
               m_isr(i) = 0     ! Start with all FSR
            ENDDO
            last=0              ! Run through all partitions
         ELSE
*     INTerference OFF, Copy partition from crude MC
            CALL KK2f_GetIsr(m_isr)
            last=1              ! Exit next time
         ENDIF
      ELSEIF( (m_KeyISR. EQ. 1) .AND. (m_KeyFSR. EQ. 0) ) THEN
*     Special test, ISR ONLY
         DO i = 1,nphot
            m_isr(i) = 1        ! Start with all ISR
         ENDDO
         last=1                 ! Exit next time
      ELSEIF( (m_KeyISR. EQ. 0) .AND. (m_KeyFSR. EQ. 1) ) THEN
*     Special test, FSR ONLY
         DO i = 1,nphot
            m_isr(i) = 0        ! Start with all FSR
         ENDDO
         last=1                 ! Exit next time
      ELSE
         WRITE(*,*) '#### GPS_PartitionStart: Wrong KeyISR,KeyFSR = ',m_KeyISR,m_KeyFSR
         STOP
      ENDIF
      END

      SUBROUTINE GPS_PhelPlus(nphot,last)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//    Not Used                                                               //
*//   update m_Phel, check if it is last combination                          //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER   nphot,last
      INTEGER   i
*
      IF(nphot .EQ. 1) last=1
      m_Phel(1)=m_Phel(1)+1       !!!
      DO i=1,nphot
         IF( m_Phel(i).EQ. 2 ) THEN
            m_Phel(i)=0          !!!
            m_Phel(i+1)=m_Phel(i+1)+1 !!!
            IF( m_Phel(nphot) .EQ. 2 ) last=2
         ENDIF
      ENDDO
      END

      SUBROUTINE GPS_PhelRandom(nphot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//    Not Used                                                               //
*//   Generate photon helicities randomly                                     //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER   nphot
      INTEGER   i
      REAL                 rvec(m_phmax)
* 
      CALL PseuMar_MakeVec(rvec,nphot)
      DO i=1,nphot
         IF( rvec(i) .GT. 0.5d0 ) THEN
            m_Phel(i)=0
         ELSE
            m_Phel(i)=1
         ENDIF
      ENDDO
      END



      SUBROUTINE GPS_PhelStart(nphot,last)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//    Not Used                                                               //
*//    Initialize first photon helicity combination                           //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER   nphot,last
      INTEGER   i
*----------  Initialize first partition -----------------
      last=0
      DO i = 1,nphot
         m_Phel(i) = 0
      ENDDO
      END


      SUBROUTINE GPS_RmatMake
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//   Translates Born spin amplitudes into double spin density matrix               //
*//                m_AmpBorn  -----> R_{ab}                                         //
*//                                                                                 //
*//   Notes:                                                                        //
*//   Polarizations for beams not included but it will be strightforward...         //
*//   m_Rmat( k, l) is realy REAL, we keep it complex to be able to xcheck it.      //
*//   One should remember to use DREAL( m_Rmat( k, l) ) in the calculations!        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    k,l
      INTEGER    i1,i2,i3,i4
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  Sum,cx

      CALL GPS_Initialize
*
* No polarization yet for initial state spins
* Loop over 4*4*2**6=16*64=1024 indices!
* The formula is eq. (2.14) in Acta. Phys. Pol. B16 (1985) 1007.
      DO k = 0,3
         DO l = 0,3
            Sum = DCMPLX(0d0,0d0)
            DO i1 = 1,2
               DO i2 = 1,2
                  DO i3 = 1,2
                     DO i4 = 1,2
                        DO j3 = 1,2
                           DO j4 = 1,2
                              Sum= Sum+
     $                                      m_AmpBorn( i1,i2, i3,i4)
     $                             *DCONJG( m_AmpBorn( i1,i2, j3,j4) )
     $                             *m_Pauli( k,j3,i3)
     $                             *m_Pauli( l,j4,i4)
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
            m_Rmat( k, l) = Sum
         ENDDO
      ENDDO
      cx = m_Rmat( 0, 0)
      DO k = 0,3
         DO l = 0,3
            m_Rmat( k, l) = m_Rmat( k, l)/cx
         ENDDO
      ENDDO
      END                       !Rmat


      SUBROUTINE GPS_RmatMake2
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    !!!!!!!!!!!!!!!!!!!!!!! TEST TEST !!!!!!!!!!!!!!!!!!!!!!!                    //
*//                                                                                 //
*//             m_AmpBorn2 instead of m_AmpBorn                                     //
*//                m_AmpBorn  -----> R_{ab}                                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      INTEGER    k,l
      INTEGER    i1,i2,i3,i4
      INTEGER    j1,j2,j3,j4
      INTEGER    Hel1,Hel2,Hel3,Hel4
      DOUBLE COMPLEX  Sum,cx

      CALL GPS_Initialize
*
* No polarization yet for initial state spins
* Loop over 4*4*2**6=16*64=1024 indices!
* The formula is eq. (2.14) in Acta. Phys. Pol. B16 (1985) 1007.
      DO k = 0,3
         DO l = 0,3
            Sum = DCMPLX(0d0,0d0)
            DO i1 = 1,2
               DO i2 = 1,2
                  DO i3 = 1,2
                     DO i4 = 1,2
                        DO j3 = 1,2
                           DO j4 = 1,2
                              Sum= Sum+
     $                                      m_AmpBorn2( i1,i2, i3,i4)
     $                             *DCONJG( m_AmpBorn2( i1,i2, j3,j4) )
     $                             *m_Pauli( k,j3,i3)
     $                             *m_Pauli( l,j4,i4)
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
            m_Rmat( k, l) = Sum
         ENDDO
      ENDDO
      cx = m_Rmat( 0, 0)
      DO k = 0,3
         DO l = 0,3
            m_Rmat( k, l) = m_Rmat( k, l)/cx
         ENDDO
      ENDDO
      END                       !Rmat


      SUBROUTINE GPS_RmatMult(Rot1,Rot2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Multiplies tensor m_Rmat (spin correlations joint density matrix)             //
*//   with two rotatios Rot1 and Rot2.                                              //
*//   Transposed Rot1 and Rot2 are realy employed.                                  //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      DOUBLE PRECISION      Rot1(4,4),Rot2(4,4)
      INTEGER    i,j,k,l
      DOUBLE PRECISION      sum,sum1,Rmat(0:3,0:3)
*-----------------------------------
* Save old result
      DO i=0,3
         DO j=0,3
            Rmat(i,j)=m_Rmat(i,j)
         ENDDO
      ENDDO
* Transform first index in tensor Rmat
      DO i=1,3                  !active
         DO j=0,3               !passive
            sum  = 0d0
            DO k=1,3
               sum  = sum + Rmat(k,j) *Rot1(i,k)
            ENDDO
            m_Rmat(i,j) = sum
         ENDDO
      ENDDO
* Save partial result
      DO i=0,3
         DO j=0,3
            Rmat(i,j)=m_Rmat(i,j)
         ENDDO
      ENDDO
* Transform second index in Rmat
      DO i=0,3                  !passive
         DO j=1,3               !active
            sum  = 0d0
            DO k=1,3
               sum  = sum + Rmat(i,k) *Rot2(j,k)
            ENDDO
            m_Rmat(i,j) = sum
         ENDDO
      ENDDO
      END

      SUBROUTINE GPS_RmatPrint(nout,word)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Born similar as in BornV, mass terms exact for photon exchange!         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER      nout
      CHARACTER*8  word
*
      INTEGER    k,l
*----------------
      WRITE(nout,'(a)') ' '
      WRITE(nout,'(4a)') '#####################################',
     $                    ' R-matrix ', word,
     $                   ' #####################################'
      DO k=0,3
         WRITE(nout,'(4(a,2f10.6,a))')  ('[',m_Rmat(k,l),'] ', l=0,3)
      ENDDO
*----------------
      END

      SUBROUTINE GPS_Setb1
*/////////////////////////////////////////////////////////////////////////////////////
*//   b1-->b                                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER k
      DO k=1,4
         m_b( k) = m_b1( k)
      ENDDO
      END

      SUBROUTINE GPS_Setb2
*/////////////////////////////////////////////////////////////////////////////////////
*//   b2-->b                                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER k
      DO k=1,4
         m_b( k) = m_b2( k)
      ENDDO
      END

      SUBROUTINE GPS_Setb3
*/////////////////////////////////////////////////////////////////////////////////////
*//   b3-->b                                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER k
      DO k=1,4
         m_b( k) = m_b3( k)
      ENDDO
      END


      SUBROUTINE GPS_SetDebg(j,y)
*////////////////////////////////////////////////////////////////////////////////
*//                                                                            //
*////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
*
      DOUBLE PRECISION  y
      INTEGER j
*---------------------------------------------------------------
      IF(j.LT.0 .OR. j.GT.200) THEN
         WRITE(*,*) ' STOP in GPS_SetDebg: j= ',j
         STOP
      ENDIF
      m_Debg(j) =y
      END   ! GPS_SetDebg

      SUBROUTINE GPS_SetHvectors(HvecFer1,HvecFer2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Seting final fermion POLARIMETER vectors                                      //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER i,j,k
      DOUBLE PRECISION  HvecFer1(4),HvecFer2(4)
*-------------------------------------------------------------------------------------
      DO k=1,4
         m_HvecFer1( k) = HvecFer1(k)
         m_HvecFer2( k) = HvecFer2(k)
      ENDDO
* Define immediately polarimeter density matriced
      DO i=1,2
         DO j=1,2
            m_SDMat3(i,j)=0D0
            m_SDMat4(i,j)=0D0
            DO k=1,4
               m_SDMat3(i,j)=m_SDMat3(i,j)+m_Pauli4( k,i,j) *HvecFer1(k)
               m_SDMat4(i,j)=m_SDMat4(i,j)+m_Pauli4( k,i,j) *HvecFer2(k)
            ENDDO
         ENDDO
      ENDDO
      END

      SUBROUTINE GPS_SetKeyArb(KeyArb)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  KeyArb is for switching on/off the use of m_b,   KeyArb=0 means b=Xi           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER KeyArb
      m_KeyArb = KeyArb
      END

      SUBROUTINE GPS_SetKeyINT(KeyINT)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Set INTerference ISR*FSR switch                                               //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER KeyINT
*
      m_KeyINT = KeyINT
      END


      SUBROUTINE GPS_SetPolBeams(PolBeam1,PolBeam2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Seting beam POLARIZATION vectors                                              //
*//   Dont forget Wigner rotation to GPS frame!!!!                                  //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER i,j,k
      DOUBLE PRECISION  PolBeam1(4),PolBeam2(4)
*------------------------------------------------------------------------------------
      DO k=1,4
         m_PolBeam1( k) = PolBeam1(k)
         m_PolBeam2( k) = PolBeam2(k)
      ENDDO
* Define spin density matriced
      DO i=1,2
         DO j=1,2
            m_SDMat1(i,j)=0D0
            m_SDMat2(i,j)=0D0
            DO k=1,4
               m_SDMat1(i,j)=m_SDMat1(i,j)+m_Pauli4( k,i,j) *PolBeam1(k)
               m_SDMat2(i,j)=m_SDMat2(i,j)+m_Pauli4( k,i,j) *PolBeam2(k)
            ENDDO
         ENDDO
      ENDDO
      END



      DOUBLE COMPLEX FUNCTION GPS_Sof1(sigma,ph,pf)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Single soft photon contribution to Soft factor at amplitude level             //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   ph      = photon  4-momentum                                                  //
*//   pf      = fermion 4-momenta                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER              sigma
      DOUBLE PRECISION     ph(4),pf(4)
      DOUBLE COMPLEX       GPS_iProd1
      DOUBLE PRECISION     GPS_XiProd
*
      GPS_Sof1 =  
     $     DSQRT(2d0)*GPS_iProd1(sigma,ph,pf)*GPS_XiProd(pf,ph)
     $     /(2d0*(pf(4)*ph(4)-pf(3)*ph(3)-pf(2)*ph(2)-pf(1)*ph(1))) !
      END

      DOUBLE COMPLEX FUNCTION GPS_Sof1b(sigma,ph,pf,mf)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Single soft photon contribution to Soft factor at amplitude level             //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   ph      = photon  4-momentum                                                  //
*//   pf      = fermion 4-momentum                                                  //
*//   mf      = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER           sigma
      DOUBLE PRECISION  ph(4),pf(4),mf
      DOUBLE COMPLEX    GPS_bfacb
*
      GPS_Sof1b =
     $     GPS_bfacb(sigma,ph,pf,mf)
     $     /(2*( pf(4)*ph(4)-pf(3)*ph(3)-pf(2)*ph(2)-pf(1)*ph(1) ))
      END


      DOUBLE COMPLEX  FUNCTION GPS_soft(sigma,ph,p1,p2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   2-fermion Soft factor at amplitude level                                      //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   ph      = photon  4-momentum                                                  //
*//   p1,p2   = fermion 4-momenta                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     sigma
      DOUBLE PRECISION       ph(4),p1(4),p2(4)
      DOUBLE COMPLEX   GPS_iProd1
      DOUBLE PRECISION       GPS_XiProd
      DOUBLE COMPLEX   Soft,bf1,bf2
      DOUBLE PRECISION       pk1,pk2
      DOUBLE PRECISION       Sqr2
*------
      Sqr2 = DSQRT(2d0)
      CALL GPS_Initialize
      pk1 = p1(4)*ph(4)-p1(3)*ph(3)-p1(2)*ph(2)-p1(1)*ph(1)
      pk2 = p2(4)*ph(4)-p2(3)*ph(3)-p2(2)*ph(2)-p2(1)*ph(1)
      bf1 =  Sqr2*GPS_iProd1(sigma,ph,p1)*GPS_XiProd(p1,ph) !!! =GPS_bfact(sigma,ph,p1)
      bf2 =  Sqr2*GPS_iProd1(sigma,ph,p2)*GPS_XiProd(p2,ph) !!! =GPS_bfact(sigma,ph,p2)
      Soft = -bf1/(2*pk1) +bf2/(2*pk2)
      GPS_soft = Soft
      END


      DOUBLE COMPLEX  FUNCTION GPS_softb(sigma,ph,p1,m1,p2,m2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Soft factor at amplitude level                                                //
*//   dependend of vector auxial-gauge vector b=beta=m_b !!!                        //
*//   sigma   = photon polarization (+1,-1)                                         //
*//   ph      = photon  4-momentum                                                  //
*//   p1,p2   = fermion 4-momenta                                                   //
*//   m1,m2   = fermion masses                                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER     sigma
      DOUBLE PRECISION       ph(4),p1(4),m1,p2(4),m2
      DOUBLE COMPLEX   GPS_bfacb
      DOUBLE COMPLEX   bf1,bf2
      DOUBLE PRECISION       pk1,pk2
*------
      CALL GPS_Initialize
      pk1 = p1(4)*ph(4)-p1(3)*ph(3)-p1(2)*ph(2)-p1(1)*ph(1)
      pk2 = p2(4)*ph(4)-p2(3)*ph(3)-p2(2)*ph(2)-p2(1)*ph(1)
      bf1 = GPS_bfacb(sigma,ph,p1,m1)
      bf2 = GPS_bfacb(sigma,ph,p2,m2)
      GPS_softb = -bf1/(2*pk1) +bf2/(2*pk2)
      END

      SUBROUTINE GPS_times(C,A1,A2,Result)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Matrix multiplication, Warning: Result cannot be the same as A1 or A2 !!!!    //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      DOUBLE COMPLEX   C,A1(2,2),A2(2,2),Result(2,2)
      INTEGER     i,j,k
      DOUBLE COMPLEX   Csum
*-----------
      DO i=1,2
         DO j=1,2
            Csum= DCMPLX(0d0,0d0)
            DO k=1,2
               Csum= Csum +A1(i,k)*A2(k,j)
            ENDDO
            Result(i,j)=Csum*C
         ENDDO
      ENDDO
      END                       !!!!  GPS_times

      SUBROUTINE GPS_TraJacobWick(Mode,QQ,pp,rr)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Tralor-type transformation for Jacob Wick quantization axies.           //
*//   Not optimized, mainly for tests.                                        //
*//                                                                           //
*//   Mode =-1 from ferm_rest to LAB  (normal mode for KORALB Tralor)         //
*//   Mode =+1 from LAB to ferm_rest                                          //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER Mode
      DOUBLE PRECISION   QQ(4)             ! Fermion 4-momentum in LAB
      DOUBLE PRECISION   pp(4)             ! input momentum
      DOUBLE PRECISION   rr(4)             ! transformed momentum
      DOUBLE PRECISION   MQ,pQ, exe, Theta, Phi
      DOUBLE PRECISION   Lor(4,4),Bos3(4,4),Rot2(4,4),Rot3(4,4)
      INTEGER i,j
      DOUBLE PRECISION   KinLib_AngPhi
*--------------------------------
      pQ = DSQRT(QQ(1)**2 +QQ(2)**2 +QQ(3)**2)
      MQ = QQ(4)**2-pQ**2
      IF(MQ .LE. 0d0 ) GOTO 901
      MQ  = DSQRT(MQ)
      exe   = (QQ(4)+pQ)/MQ     ! exe=exp(hiper_velocity), exe>1 for q(3)>0
* Completely standard Theta, Phi
      Theta = KinLib_AngPhi(QQ(3),DSQRT(QQ(1)**2+QQ(2)**2) ) ! range (0,pi)
      Phi   = KinLib_AngPhi(QQ(1),QQ(2))                     ! range (0,2pi)
      IF(Mode .EQ. 1) THEN
         exe   = 1d0/exe
         Theta = -Theta
         Phi   = -Phi
      ENDIF
* Define matrices for elementary boosts/rotations
      CALL KinLib_DefBoost(3,     exe,Bos3) ! Calculate Boost3 matrix
      CALL KinLib_DefRotor(3,1, Theta,Rot2) ! Rotation x-z plane, around y axis
      CALL KinLib_DefRotor(1,2,   Phi,Rot3) ! Rotation x-y plane, around z axis
* Define the Entire transformation matrix (slow but secure)
      IF(Mode .EQ. -1) THEN
*     Mode =-1 from ferm_rest to LAB  (normal mode in KORALB Tralor)
         CALL KinLib_LorCopy(Bos3,     Lor) ! Lor=Bos3(exe)
         CALL KinLib_LorMult(Rot2,Lor, Lor) ! Lor=Rot2(Theta)*Bos3(exe)
         CALL KinLib_LorMult(Rot3,Lor, Lor) ! Lor=Rot3(Phi)*Rot2(Theta)*Bos3(exe)
      ELSEIF( Mode .EQ. 1) THEN
*     Mode =+1 from LAB to ferm_rest
         CALL KinLib_LorCopy(Rot3,     Lor) ! Lor=Rot3(-Phi)
         CALL KinLib_LorMult(Rot2,Lor, Lor) ! Lor=Rot2(-Theta)*Rot3(-Phi)
         CALL KinLib_LorMult(Bos3,Lor, Lor) ! Lor=Bos3(1/exe)*Rot2(-Theta)*Rot3(-Phi)
      ELSE
         GOTO 902
      ENDIF
* Transform vector
      CALL KinLib_VecTrasform(Lor,pp,rr)
      RETURN
 901  WRITE(*,*) '++++++++GPS_TraJacobWick: WRONG QQ, not timelike'
      STOP
 902  WRITE(*,*) '++++++++GPS_TraJacobWick: WRONG Mode= ', Mode
      STOP
      END


      SUBROUTINE GPS_TralorDoIt(id,pp,q)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Transform pp from rest frame of fermion id to LAB, q is result          //
*//   It uses Lorenz transfromation prepared and memorized in                 //
*//   the subprogram GPS_TralorPrepare, which has to be called first!         //
*//   This organization saves time in the case of multiple calls for many     //
*//   decay products.                                                         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER id                ! Ident of fermion, id=1,2 for 2 fermions
      DOUBLE PRECISION   pp(4),q(4)        ! fermion moms to be transformed TO LAB
      INTEGER k,l
      DOUBLE PRECISION   p(4),sum
*-----------------
      DO k=1,4
         p(k)=pp(k)
      ENDDO
* Transform vector p, i.e. multiply by matrix Loren1 or Loren2
      IF( id .EQ. 1) THEN
         DO k=1,4
            sum = 0d0
            DO l=1,4
               sum=sum+ m_Loren1(k,l)*p(l)
            ENDDO
            q(k) = sum
         ENDDO
      ELSEIF( id .EQ. 2) THEN
         DO k=1,4
            sum = 0d0
            DO l=1,4
               sum=sum+ m_Loren2(k,l)*p(l)
            ENDDO
            q(k) = sum
         ENDDO
      ELSE
         GOTO 900
      ENDIF
*-----------
      RETURN
 900  WRITE(*,*) '++++++++ WRONG id in GPS_TralorDoIt =',id
      STOP
      END


      SUBROUTINE GPS_TralorPrepare(QQ,id)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Prepares transformation for Tralor, according to GPS rules              //
*//   The resulting Lorenz transformation matrix is stored for multiple use!  //
*//   This organization saves time in the case of multiple calls for many     //
*//   decay products.                                                         //
*//   Ident id=1,2 for two fermions only, later on may be extended.           //
*//   Note that Tralor is a good candidate for separate class!                //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER id                ! Ident of fermion, id=1,2 for 2 fermions
      DOUBLE PRECISION   QQ(4)             ! Fermion 4-momentum in LAB
      DOUBLE PRECISION   Lorenz(4,4),Lorinv(4,4)
      DOUBLE PRECISION   Rot(4,4),   Rotinv(4,4)
      DOUBLE PRECISION   EQ,MQ,sum,a,b
      DOUBLE PRECISION   xi(4),eta(4)
      INTEGER k,l
*--------------------------------------------------
* Construct Lorenz transformation from/to QQ rest frame (Jackson style)
      CALL KinLib_DefBostQQ(-1,QQ,Lorenz) ! from ferm. rest frame to LAB
      CALL KinLib_DefBostQQ( 1,QQ,Lorinv) ! from LAB to ferm. rest frame

* Additional 3-rotation according to GPS rules
      CALL KinLib_VecTrasform(Lorinv, m_Xi,  xi)
      CALL KinLib_VecTrasform(Lorinv, m_Eta, eta)
      CALL GPS_GPS(xi,eta,Rot)
* Inverse matrix is just transpose of Rot
      CALL KinLib_LorCopy(Rot,Rotinv)
      CALL KinLib_RotTranspose(Rotinv)
* Consctruct total GPS transformation
      CALL KinLib_LorMult(Lorenz,      Rot,  Lorenz) ! towards LAB
      CALL KinLib_LorMult(Rotinv,   Lorinv,  Lorinv)
* Memorize transformation matrices for further use
      IF( id .EQ. 1) THEN
         CALL KinLib_LorCopy(Lorenz,m_Loren1) ! towards LAB
         CALL KinLib_LorCopy(Lorinv,m_Lorin1)
      ELSEIF(id .EQ. 2) THEN
         CALL KinLib_LorCopy(Lorenz,m_Loren2) ! towards LAB
         CALL KinLib_LorCopy(Lorinv,m_Lorin2)
      ELSE
         GOTO 900
      ENDIF
      RETURN
 901  WRITE(*,*) '++++++++ GPS_TralorMake: WRONG QQ, not timelike'
      STOP
 900  WRITE(*,*) '++++++++ GPS_TralorMake: WRONG id=',id
      STOP
      END

      SUBROUTINE GPS_TralorUnDo(id,pp,q)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//               Inverse of GPS_TralorDoIt                                   //
*//                                                                           //
*//   Transform pp from LAB to rest frame of fermion, q is result             //
*//   It uses Lorenz transfromation prepared and memorized in                 //
*//   the subprogram GPS_TralorPrepare, which has to be called first!         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER id                ! Ident of fermion, id=1,2 for 2 fermions
      DOUBLE PRECISION   pp(4),q(4)        ! fermion moms to be transformed TO LAB
      INTEGER k,l
      DOUBLE PRECISION   p(4),sum
*-----------------
      DO k=1,4
         p(k)=pp(k)
      ENDDO
* Transform vector p, i.e. multiply by matrix Loren1 or Loren2
      IF( id .EQ. 1) THEN
         DO k=1,4
            sum = 0d0
            DO l=1,4
               sum=sum+ m_Lorin1(k,l)*p(l)
            ENDDO
            q(k) = sum
         ENDDO
      ELSEIF( id .EQ. 2) THEN
         DO k=1,4
            sum = 0d0
            DO l=1,4
               sum=sum+ m_Lorin2(k,l)*p(l)
            ENDDO
            q(k) = sum
         ENDDO
      ELSE
         GOTO 900
      ENDIF
*-----------
      RETURN
 900  WRITE(*,*) '++++++++ WRONG id in GPS_TralorUnDo =',id
      STOP
      END

      SUBROUTINE GPS_UPrint(nout,word,U)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Print U-matrix in a nice form                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      DOUBLE COMPLEX  U(2,2)
      INTEGER k,l
      CHARACTER*8  word
*
      WRITE(nout,'(a)') '  '
      WRITE(nout,'(4a)') '////////////////////////////////////////',
     $                             ' T-matrix: ',word,
     $                  ' ////////////////////////////////////////'
      DO k=1,2
         WRITE(nout,'(2(a,2f20.12,a))')  ('[',U(k,l),' ]     ', l=1,2)
      ENDDO
      END

      DOUBLE PRECISION  FUNCTION GPS_XiProd(p,q)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   auxiliary function called in GPS_iProd2                                       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  p(4),q(4)

      GPS_XiProd = DSQRT( (p(4)-p(1)) / (q(4)-q(1)) )
      END


      SUBROUTINE GPS_ZeroWtSet
*/////////////////////////////////////////////////////////////////////////////////////
*//   Zeroing weght list                                                            //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'GPS.h'
      INTEGER  j
*
      DO j=1,m_lenwt
         m_WtSet(j)=0d0
      ENDDO
      END   ! GPS_ZeroWtSet

      SUBROUTINE HepEvt_Fil1(n,ist,id,jmo1,jmo2,jda1,jda2,p4,pinv,phflag)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// This subroutine fills one entry into the hepevt common                   //
*// and updates the information for affected mother entries                  //
*// WRITTEN by Martin W. Gruenewald (91/01/28)                               //
*// Re-Edited by S. Jadach, 6 july 97                                        //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
* input
      INTEGER           n,ist,id,jmo1,jmo2,jda1,jda2
      DOUBLE PRECISION  p4(4),pinv
      LOGICAL           phflag
* locals
      INTEGER           ip,i,ihep
      SAVE
* ----------------------------------------------------------------------
*
* check address mode
      IF (n .EQ. 0) THEN
* append mode
        ihep=nhep+1
      ELSE IF (n .GT. 0) THEN
* absolute position
        ihep=n
      ELSE
* relative position
        ihep=nhep+n
      END IF
*
* check on ihep
      IF ((ihep .LE. 0) .OR. (ihep .GT. nmxhep)) RETURN
*
* add entry
      nhep=ihep
      isthep(ihep)   =ist
      idhep(ihep)    =id
      jmohep(1,ihep) =jmo1
      IF(jmo1 .LT. 0)  jmohep(1,ihep)=jmohep(1,ihep)+ihep
      jmohep(2,ihep) =jmo2
      IF(jmo2 .LT. 0)  jmohep(2,ihep)=jmohep(2,ihep)+ihep
      jdahep(1,ihep) =jda1
      jdahep(2,ihep) =jda2
*
      DO i=1,4
         phep(i,ihep)=p4(i)
* KORAL-B and KORAL-Z do not provide vertex and/or lifetime informations
         vhep(i,ihep)=0d0
      END DO
      phep(5,ihep)=pinv
* flag for photos...
      qedrad(ihep)=phflag
* update process:
      DO ip=jmohep(1,ihep),jmohep(2,ihep)
         IF(ip .GT. 0)THEN
* IF there is a daughter at ihep, mother entry at ip has decayed
            IF(isthep(ip) .EQ. 1)isthep(ip)=2
* and daughter pointers of mother entry must be updated
            IF(jdahep(1,ip) .EQ. 0)THEN
               jdahep(1,ip)=ihep
               jdahep(2,ip)=ihep
            ELSE
               jdahep(2,ip)=max(ihep,jdahep(2,ip))
            END IF
         END IF
      END DO
*
      END
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                      End of CLASS  GPS                                          //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Pseudo-CLASS  HepEvt                                 //
*//                                                                          //
*//  Purpose:  keep and serve event in HEPEVT format                         //
*//                                                                          //
*//  Output of KK2f is encoded in double precission /d_hepevt/               //
*//  which is double precision version of /hepevt/                           //
*//  It was necessary to rename /hepevt/                                     //
*//  because older Jetset uses single precision version of /hepevt/          //
*//                                                                          //
*//  We introduce luhepc->luhepcd which is                                   //
*//  Double Precision version of luhepc. It translates                       //
*//  from /hepevtd/ to (from) Jetset-common-blocks                           //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      SUBROUTINE HepEvt_Fill
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Filling HEP COMMON block using HepEvt_Fil1 routine                              //
*//                                                                                  //
*//  INPUT:                                                                          //
*//     KFfin          final particle code       (KarLud)                            //
*//     pf1,pf2        beam (electron) momenta   (KarLud)                            //
*//     nphox          photon multiplicity       (KarLud)                            //
*//     xphot          photon momenta            (KarLud)                            //
*//     qf1,qf2        final momenta             (Karfin)                            //
*//     nphoy          photon multiplicity       (KarFin)                            //
*//     yphot          photon momenta            (KarFin)                            //
*//                                                                                  //
*//  I present version we add beamstrahlung photons to the record                    //
*//  along with the ISR photons. It can be missleading!                              //
*//  May be they should be rather listed                                             //
*//  as the initial state particles, together with beams?                            //
*//  This has to be disscussed with the users.                                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  pf1(4),pf2(4),qf1(4),qf2(4),xphot(100,4),yphot(100,4)
      DOUBLE PRECISION  aph(5), bph(5)
      DOUBLE PRECISION  amel,amfin,BornV_GetMass
      INTEGER           KFfin,ip,kstat,j,i,nphoy,nphox,kfbeam,n_ISR
      COMMON /NUMBERISR/n_ISR
*------------------------------------------------------------------------------
* Actual KFcode of final fermion
      CALL KarLud_GetKFfin(KFfin)
* Beams and ISR photons
      CALL KarLud_GetPhotons(nphox,xphot)
      CALL KarLud_GetBeams(pf1,pf2)
* Final fermions and FSR photons
      CALL KarFin_GetPhotons(nphoy,yphot)
      CALL KarFin_GetFermions(qf1,qf2)
*
      KFbeam = 11    ! KF=11 denotes electron
      amel   =BornV_GetMass(KFbeam)
* Beams
      CALL HepEvt_Fil1(1,3, 11, 0,0,0,0, pf1,amel,.FALSE.)
      CALL HepEvt_Fil1(2,3,-11, 0,0,0,0, pf2,amel,.FALSE.)

* Radiative photons (5 ... 4+nphot) (pdg-code for gamma is 22)  ! ISR
      ip=0
      IF(nphox .NE. 0) THEN
         DO i=1,nphox
            DO j=1,4
               aph(j)=xphot(i,j)
            END DO
            ip=ip+1
            CALL HepEvt_Fil1(2+ip,1,22, 1,2,0,0, aph,0d0,.FALSE.)
         END DO
      END IF
* add beamstrahlung photons to the record along with ISR photons, can be missleading!!
      CALL KarLud_GetBeasts( aph, bph)
      IF( aph(4).NE.0d0) THEN
         ip=ip+1
         CALL HepEvt_Fil1(2+ip,1,22, 1,2,0,0, aph,0d0,.FALSE.)
      ENDIF
      IF( bph(4).NE.0d0) THEN
         ip=ip+1
         CALL HepEvt_Fil1(2+ip,1,22, 1,2,0,0, bph,0d0,.FALSE.)
      ENDIF

      n_ISR = ip

* Final state fermions
      IF( KFfin .EQ. 0 ) RETURN
      amfin  =BornV_GetMass(KFfin)
      KStat = 1
      CALL HepEvt_Fil1(3+n_ISR,KStat, KFfin, 1,2,0,0, qf1,amfin,.FALSE.)
      CALL HepEvt_Fil1(4+n_ISR,KStat,-KFfin, 1,2,0,0, qf2,amfin,.FALSE.)

      ip = 0
* Radiative photons (5 ... 4+nphot) (pdg-code for gamma is 22)  ! FSR
      IF(nphoy .NE. 0) THEN
         DO i=1,nphoy
            DO j=1,4
               aph(j)=yphot(i,j)
            END DO
            ip=ip+1
            CALL HepEvt_Fil1(4+ip+n_ISR,1,22,1,2,0,0, aph,0d0,.FALSE.)
         END DO
      END IF
*
* Finaly fill also LUND common block
      CALL HepEvt_LuHepc(2)
      END
      SUBROUTINE HepEvt_GetBeams(pf1,pf2)
*//////////////////////////////////////////////////////////////////////////////
*// Purpose:  Get Beam momenta out of /hepevt/                               //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  pf1(4),pf2(4)
      INTEGER k
* ----------------------------------------------------------------------
      DO k=1,4
         pf1(k) =phep(k,1)
         pf2(k) =phep(k,2)
      ENDDO
      END 
      SUBROUTINE HepEvt_GetFfins(pf1,pf2)
*//////////////////////////////////////////////////////////////////////////////
*// Purpose:  Get final fermion momenta out of /hepevt/                      //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  pf1(4),pf2(4)
      INTEGER k,n_isr
      COMMON /NUMBERISR/n_ISR
* ----------------------------------------------------------------------
      DO k=1,4
         pf1(k) =phep(k,3+n_isr)
         pf2(k) =phep(k,4+n_isr)
      ENDDO
      END 
      SUBROUTINE HepEvt_GetKFfin(KFfin)
*//////////////////////////////////////////////////////////////////////////////
*// Purpose:  Get KFcode of final fermion out of /hepevt/                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      INTEGER KFfin,n_isr
      COMMON /NUMBERISR/n_ISR
* ----------------------------------------------------------------------
      KFfin = idhep(3+n_isr)
      END ! GetKFfin

      SUBROUTINE HepEvt_GetNPhot(nphot)
*//////////////////////////////////////////////////////////////////////////////
*// Purpose:  Get number of bremsstrahlung photons  out of /hepevt/          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      INTEGER nphot,kf,j,ih
*
      nphot=0
      DO j=1,100
         ih = 4+j
         kf = idhep(ih)
* STOP if /hepevt/ ended or non-photon found
         IF(ih .GT. nhep) GOTO 110
         IF(kf .NE. 22)   GOTO 110
* Bremsstrahlung photons have by convention 1-st parent being 1-st beam (ISR)
* at ih=1 or first final fermion at ih=3 (FSR)
         IF(jmohep(1,ih).EQ.1 .OR. jmohep(1,ih).EQ.3) nphot=nphot+1
      ENDDO
      RETURN
 110  CONTINUE
      END
      SUBROUTINE HepEvt_GetParticle(Id,Istart,Iadress,pf1)
*//////////////////////////////////////////////////////////////////////////////
*// Purpose:  Get Id-partcle momenta out of /hepevt/                         //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  pf1(4)
      INTEGER k,l,Id,Istart,Iadress
* ----------------------------------------------------------------------
      Iadress=-1
      DO l=Istart,nhep
        IF(Idhep(l).eq.Id) then
          Iadress=l
          DO k=1,4
             pf1(k) =phep(k,l)
          ENDDO
          RETURN
        ENDIF
      ENDDO
      END 
      SUBROUTINE HepEvt_GetPhotAll(nphot,phot)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Purpose:  Get ALL photons out of /hepevt/                                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  phot(100,4)
      INTEGER nphot,j,k,ih,kf
* ----------------------------------------------------------------------
      nphot=0
      DO j=1,100
         ih = 4+j
         kf = idhep(ih)
* STOP if /hepevt/ ended or non-photon found
         IF(ih .GT. nhep) GOTO 110
         IF(kf .NE. 22)   GOTO 110
* Bremsstrahlung photons have by convention 1-st parent being 1-st beam (ISR)
* at ih=1 or first final fermion at ih=3 (FSR)
         IF(jmohep(1,ih).EQ.1 .OR. jmohep(1,ih).EQ.3) THEN
            nphot=nphot+1
            DO  k=1,4
               phot(nphot,k) =phep(k,ih)
            ENDDO
         ENDIF
      ENDDO
      GOTO 900
 110  CONTINUE
      RETURN
 900  WRITE(*,*) '++++ HepEvt_GetPhotAll: To many photons!!!'
      END 
      SUBROUTINE HepEvt_GetPhotBst(nphot,phot)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Purpose:  Get Beamstrahlung photons out of /hepevt/                      //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  phot(100,4)
      INTEGER nphot,j,k,ih,kf,n_ISR
      COMMON /NUMBERISR/n_ISR
* ----------------------------------------------------------------------
      nphot=0
      DO j=1,n_ISR
         ih = 2+j               !photons start always at position ih=3
         kf = idhep(ih)
* STOP if /hepevt/ ended or non-photon found
         IF(ih .GT. nhep) GOTO 110
         IF(kf .NE. 22)   GOTO 110
* Beamsstrahlung photons have pT exactly zero
         IF( (phep(1,ih)**2 +phep(2,ih)) .EQ. 0d0) THEN
            nphot=nphot+1
            DO  k=1,4
               phot(nphot,k) =phep(k,ih)
            ENDDO
         ENDIF
      ENDDO
      GOTO 900
 110  CONTINUE
      RETURN
 900  WRITE(*,*) '++++ HepEvt_GetPhotBst: To many photons!!!'
      END 
      SUBROUTINE HepEvt_GetPhotFin(nphot,phot)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Purpose:  Get FSR photons out of /hepevt/                                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  phot(100,4)
      INTEGER nphot,j,k,ih,kf,n_ISR
      COMMON /NUMBERISR/n_ISR
* ----------------------------------------------------------------------
      nphot=0
      DO j=1,100
         ih = 4+j+n_ISR     !photons FSR start always at position ih=5+n_ISR
         kf = idhep(ih)
* STOP if /hepevt/ ended or non-photon found
         IF(ih .GT. nhep) GOTO 110
         IF(kf .NE. 22)   GOTO 110
* FSR photons have 1-st parent being beam
         IF(jmohep(1,ih) .EQ. 1) THEN
            nphot=nphot+1
            DO  k=1,4
               phot(nphot,k) =phep(k,ih)
            ENDDO
         ENDIF
      ENDDO
      GOTO 900
 110  CONTINUE
      RETURN
 900  WRITE(*,*) '++++ HepEvt_GetPhotFin: To many photons!!!'
      END 
      SUBROUTINE HepEvt_GetPhotIni(nphot,phot)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Purpose:  Get ISR photons out of /hepevt/                                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
      DOUBLE PRECISION  phot(100,4)
      INTEGER nphot,j,k,ih,kf,n_ISR
      COMMON /NUMBERISR/n_ISR
* ----------------------------------------------------------------------
      nphot=0
      DO j=1,n_ISR
         ih = 2+j               !photons ISR start always at position ih=3
         kf = idhep(ih)
* STOP if /hepevt/ ended or non-photon found
         IF(ih .GT. nhep) GOTO 900
         IF(kf .NE. 22)   GOTO 110
* ISR photons have by convention 1-st parent being 1-st beam
         IF(jmohep(1,ih) .EQ. 1) THEN
            nphot=nphot+1
            DO  k=1,4
               phot(nphot,k) =phep(k,ih)
            ENDDO
         ENDIF
 110  CONTINUE
      ENDDO
      RETURN
 900  WRITE(*,*) '++++ HepEvt_GetPhotIni: To many photons!!!'
      END 
      SUBROUTINE HepEvt_Hadronize(HadMin)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//          Aranging jets and hadronization                                 //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'HepEvt.h'
*
      INTEGER  ijoin(2)
      DOUBLE PRECISION    HadMin
      DOUBLE PRECISION    sqrs1
      INTEGER  ih1,ih2,n_ISR
      COMMON /NUMBERISR/n_ISR
      Real*4   am,amarset
      external amarset
* ----------------------------------------------------------------------
C     switch to 2nd ranmar sequence
          am = amarset(1)           ! b.bloch jan 2000
* Quarks only, KeyHad=1 required
      ih1=3+n_ISR  ! fermion is here
      ih2=4+n_ISR  ! antifermion is here
      IF ( ABS(idhep(ih1)) .LT. 10 ) THEN
** Explicit string arangement:
         ijoin(1) = ih1
         ijoin(2) = ih2
** q-qbar effective mass

         sqrs1=(phep(4,ih1)+phep(4,ih2))**2
     $        -(phep(3,ih1)+phep(3,ih2))**2
     $        -(phep(2,ih1)+phep(2,ih2))**2
     $        -(phep(1,ih1)+phep(1,ih2))**2
         sqrs1=sqrt(abs(sqrs1))

* Showering < HadMas cut-off value (this also deals with WT=0 events)
* see also bornv
         IF( sqrs1 .GT. HadMin**2) THEN
            CALL pyjoin(2,ijoin)
            CALL pyshow(ih1,ih2,sqrs1)
            CALL pyexec
         ENDIF
      ENDIF
      END
      SUBROUTINE HepEvt_LuHepc(MCONV)
 
C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      IMPLICIT INTEGER(I-N)
      INTEGER PYK,PYCHGE,PYCOMP
C...Commonblocks.
      COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /PYJETS/,/PYDAT1/,/PYDAT2/
C...HEPEVT commonblock.
      PARAMETER (NMXHEP=2000)
      COMMON/D_HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      DOUBLE PRECISION PHEP,VHEP
      SAVE /D_HEPEVT/


C...Conversion from PYTHIA to standard, the easy part.
      IF(MCONV.EQ.1) THEN
        NEVHEP=0
        IF(N.GT.NMXHEP) CALL PYERRM(8,
     &  '(PYHEPC:) no more space in /HEPEVT/')
        NHEP=MIN(N,NMXHEP)
        DO 140 I=1,NHEP
          ISTHEP(I)=0
          IF(K(I,1).GE.1.AND.K(I,1).LE.10) ISTHEP(I)=1
          IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=2
          IF(K(I,1).GE.21.AND.K(I,1).LE.30) ISTHEP(I)=3
          IF(K(I,1).GE.31.AND.K(I,1).LE.100) ISTHEP(I)=K(I,1)
          IDHEP(I)=K(I,2)
          JMOHEP(1,I)=K(I,3)
          JMOHEP(2,I)=0
          IF(K(I,1).NE.3.AND.K(I,1).NE.13.AND.K(I,1).NE.14) THEN
            JDAHEP(1,I)=K(I,4)
            JDAHEP(2,I)=K(I,5)
          ELSE
            JDAHEP(1,I)=0
            JDAHEP(2,I)=0
          ENDIF
          DO 100 J=1,5
            PHEP(J,I)=P(I,J)
  100     CONTINUE
          DO 110 J=1,4
            VHEP(J,I)=V(I,J)
  110     CONTINUE
 
C...Check if new event (from pileup).
          IF(I.EQ.1) THEN
            INEW=1
          ELSE
            IF(K(I,1).EQ.21.AND.K(I-1,1).NE.21) INEW=I
          ENDIF
 
C...Fill in missing mother information.
          IF(I.GE.INEW+2.AND.K(I,1).EQ.21.AND.K(I,3).EQ.0) THEN
            IMO1=I-2
            IF(I.GE.INEW+3.AND.K(I-1,1).EQ.21.AND.K(I-1,3).EQ.0)
     &      IMO1=IMO1-1
            JMOHEP(1,I)=IMO1
            JMOHEP(2,I)=IMO1+1
          ELSEIF(K(I,2).GE.91.AND.K(I,2).LE.93) THEN
            I1=K(I,3)-1
  120       I1=I1+1
            IF(I1.GE.I) CALL PYERRM(8,
     &      '(PYHEPC:) translation of inconsistent event history')
            IF(I1.LT.I.AND.K(I1,1).NE.1.AND.K(I1,1).NE.11) GOTO 120
            KC=PYCOMP(K(I1,2))
            IF(I1.LT.I.AND.KC.EQ.0) GOTO 120
            IF(I1.LT.I.AND.KCHG(KC,2).EQ.0) GOTO 120
            JMOHEP(2,I)=I1
          ELSEIF(K(I,2).EQ.94) THEN
            NJET=2
            IF(NHEP.GE.I+3.AND.K(I+3,3).LE.I) NJET=3
            IF(NHEP.GE.I+4.AND.K(I+4,3).LE.I) NJET=4
            JMOHEP(2,I)=MOD(K(I+NJET,4)/MSTU(5),MSTU(5))
            IF(JMOHEP(2,I).EQ.JMOHEP(1,I)) JMOHEP(2,I)=
     &      MOD(K(I+1,4)/MSTU(5),MSTU(5))
          ENDIF
 
C...Fill in missing daughter information.
          IF(K(I,2).EQ.94.AND.MSTU(16).NE.2) THEN
            DO 130 I1=JDAHEP(1,I),JDAHEP(2,I)
              I2=MOD(K(I1,4)/MSTU(5),MSTU(5))
              JDAHEP(1,I2)=I
  130       CONTINUE
          ENDIF
          IF(K(I,2).GE.91.AND.K(I,2).LE.94) GOTO 140
          I1=JMOHEP(1,I)
          IF(I1.LE.0.OR.I1.GT.NHEP) GOTO 140
          IF(K(I1,1).NE.13.AND.K(I1,1).NE.14) GOTO 140
          IF(JDAHEP(1,I1).EQ.0) THEN
            JDAHEP(1,I1)=I
          ELSE
            JDAHEP(2,I1)=I
          ENDIF
  140   CONTINUE
        DO 150 I=1,NHEP
          IF(K(I,1).NE.13.AND.K(I,1).NE.14) GOTO 150
          IF(JDAHEP(2,I).EQ.0) JDAHEP(2,I)=JDAHEP(1,I)
  150   CONTINUE
 
C...Conversion from standard to PYTHIA, the easy part.
      ELSE
        IF(NHEP.GT.MSTU(4)) CALL PYERRM(8,
     &  '(PYHEPC:) no more space in /PYJETS/')
        N=MIN(NHEP,MSTU(4))
        NKQ=0
        KQSUM=0
        DO 180 I=1,N
          K(I,1)=0
          IF(ISTHEP(I).EQ.1) K(I,1)=1
          IF(ISTHEP(I).EQ.2) K(I,1)=11
          IF(ISTHEP(I).EQ.3) K(I,1)=21
          K(I,2)=IDHEP(I)
          K(I,3)=JMOHEP(1,I)
          K(I,4)=JDAHEP(1,I)
          K(I,5)=JDAHEP(2,I)
          DO 160 J=1,5
            P(I,J)=PHEP(J,I)
  160     CONTINUE
          DO 170 J=1,4
            V(I,J)=VHEP(J,I)
  170     CONTINUE
          V(I,5)=0D0
          IF(ISTHEP(I).EQ.2.AND.PHEP(4,I).GT.PHEP(5,I)) THEN
            I1=JDAHEP(1,I)
            IF(I1.GT.0.AND.I1.LE.NHEP) V(I,5)=(VHEP(4,I1)-VHEP(4,I))*
     &      PHEP(5,I)/PHEP(4,I)
          ENDIF
 
C...Fill in missing information on colour connection in jet systems.
          IF(ISTHEP(I).EQ.1) THEN
            KC=PYCOMP(K(I,2))
            KQ=0
            IF(KC.NE.0) KQ=KCHG(KC,2)*ISIGN(1,K(I,2))
            IF(KQ.NE.0) NKQ=NKQ+1
            IF(KQ.NE.2) KQSUM=KQSUM+KQ
            IF(KQ.NE.0.AND.KQSUM.NE.0) THEN
              K(I,1)=2
            ELSEIF(KQ.EQ.2.AND.I.LT.N) THEN
              IF(K(I+1,2).EQ.21) K(I,1)=2
            ENDIF
          ENDIF
  180   CONTINUE
        IF(NKQ.EQ.1.OR.KQSUM.NE.0) CALL PYERRM(8,
     &  '(PYHEPC:) input parton configuration not colour singlet')
      ENDIF

      END
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  !!!!!!! WARNING!!!!!   This source may be overwriting !!!!              //
*//                                                                          //
*//  Due to short common block names it  owerwrites variables in other parts        //
*//  of the code.                                                            //
*//                                                                          //
*//  One should add suffix c_Taul_ to names of all commons as soon as possible!!!!  //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Standard Tauola interface/initialization routines of functionality exactly    //
*//   as in Tauola CPC  but input is partially from xpar(*) matrix           //
*// ITAUXPAR is for indirect adressing                                       //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      SUBROUTINE INIETC(ITAUXPAR,xpar)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      INCLUDE 'BXformat.h'
      REAL*8 xpar(*)
      INTEGER   INUT,IOUT
      COMMON /INOUT/  
     $     INUT,         ! Input  unit  number (not used)
     $     IOUT          ! Ounput unit  number
      COMMON / IDFC  / IDFF
      COMMON / TAURAD / XK0DEC,ITDKRC
      DOUBLE PRECISION            XK0DEC
      COMMON / JAKI   /  JAK1,JAK2,JAKP,JAKM,KTOM
* Note: I dont see KeyA1=2,3 realy implemented in the code SJ. ??????
      INTEGER  KeyA1
      COMMON /TESTA1/
     $     KeyA1           ! Special switch for tests of dGamma/dQ**2 in a1 decay
* KeyA1=1 constant width of a1 and rho
* KeyA1=2 free choice of rho propagator (defined in function FPIK)
*         and free choice of a1 mass and width. function g(Q**2)
*         (see formula 3.48 in Comp. Phys. Comm. 64 (1991) 275)
*         hard coded both in Monte Carlo and in testing distribution.
* KeyA1=3 function g(Q**2) hardcoded in the Monte Carlo
*         (it is timy to calculate!), but appropriately adjusted in testing distribution.
      SAVE
       idff    = xpar(ITAUXPAR+3)        ! Lund identifier for first tau (15 for  tau-)
C XK0 for tau decays.
       xk0dec  = xpar(ITAUXPAR+5)        ! IR-cut for QED rad. in leptonic decays
C radiative correction switch in tau --> e (mu) decays !
       itdkRC  = xpar(ITAUXPAR+4)        ! QED rad. in leptonic decays
C switches of tau+ tau- decay modes !!
       Jak1            = xpar(ITAUXPAR+1)   ! Decay Mask for first tau
       Jak2            = xpar(ITAUXPAR+2)   ! Decay Mask for second tau
C output file number for TAUOLA
       IOUT    = xpar(4)
C  KeyA1 is used for formfactors actually not in use
      KeyA1   = xpar(ITAUXPAR+6)        ! Type of a1 current

        WRITE(iout,bxope)
        WRITE(iout,bxtxt) ' Parameters passed from KK  to Tauola:   '
        WRITE(iout,bxl1i) Jak1,      'dec. type 1-st tau  ','Jak1  ','t01'
        WRITE(iout,bxl1i) Jak2,      'dec. type 2-nd tau  ','Jak2  ','t02'
        WRITE(iout,bxl1i) KeyA1,     'current type a1 dec.','KeyA1 ','t03'
        WRITE(iout,bxl1i) idff,      'PDG id 1-st tau     ','idff  ','t04'
        WRITE(iout,bxl1i) itdkRC,    'R.c. switch lept dec','itdkRC','t05'
        WRITE(iout,bxl1g) xk0dec,    'IR-cut for lept r.c.','xk0dec','t06'
        WRITE(iout,bxclo)

      end
      SUBROUTINE INIMAS(ITAUXPAR,xpar)
* ----------------------------------------------------------------------
*     INITIALISATION OF MASSES
*
*     called by : KORALZ
* ----------------------------------------------------------------------
      INCLUDE 'BXformat.h'
      INTEGER   INUT,IOUT
      COMMON /INOUT/  
     $     INUT,         ! Input  unit  number (not used)
     $     IOUT          ! Ounput unit  number
      REAL*8 xpar(*)
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      CHARACTER*80 bxINIT
      PARAMETER (
     $  bxINIT ='(1x,1h*,g17.8,            16x, a31,a4,a4, 1x,1h*)'
     $ )
*
* IN-COMING / OUT-GOING  FERMION MASSES
      AMTAU  = xpar(656)
      AMNUTA = 0.010
      AMEL   = xpar(616)
      AMNUE  = 0.0
      AMMU   = xpar(636)
      AMNUMU = 0.0
*
* MASSES USED IN TAU DECAYS
      AMPIZ  = 0.134964
      AMPI   = 0.139568
      AMRO   = 0.773
      GAMRO  = 0.145
*C    GAMRO  = 0.666
      AMA1   = 1.251
      GAMA1  = 0.599
      AMK    = 0.493667
      AMKZ   = 0.49772
      AMKST  = 0.8921
      GAMKST = 0.0513
      WRITE(iout,bxope)
      WRITE(iout,bxtxt) ' TAUOLA Initialization SUBROUTINE INIMAS:    '
      WRITE(iout,bxtxt) ' Adopted to read from KK                     '
      WRITE(iout,bxINIT) amtau, 'AMTAU tau-mass             ','****','***'
      WRITE(iout,bxINIT) amel , 'AMEL  electron-mass        ','****','***'
      WRITE(iout,bxINIT) ammu , 'AMMU  muon-mass            ','****','***'
      WRITE(iout,bxclo)

      END


      SUBROUTINE INIPHY(XK00)
* ----------------------------------------------------------------------
*     INITIALISATION OF PARAMETERS
*     USED IN QED and/or GSW ROUTINES
* ----------------------------------------------------------------------
      COMMON / QEDPRM /ALFINV,ALFPI,XK0
      REAL*8           ALFINV,ALFPI,XK0
      REAL*8 PI8,XK00
*
      PI8    = 4.D0*DATAN(1.D0)
      ALFINV = 137.03604D0
      ALFPI  = 1D0/(ALFINV*PI8)
      XK0=XK00
      END


      SUBROUTINE INITDK(ITAUXPAR,xpar)
* ----------------------------------------------------------------------
*     INITIALISATION OF TAU DECAY PARAMETERS  and routines
*
*     called by : KORALZ
* ----------------------------------------------------------------------
      INCLUDE 'BXformat.h'
      INTEGER   INUT,IOUT
      COMMON /INOUT/  
     $     INUT,         ! Input  unit  number (not used)
     $     IOUT          ! Ounput unit  number
      REAL*8 xpar(*)
      COMMON / DECPAR / GFERMI,GV,GA,CCABIB,SCABIB,GAMEL
      REAL*4            GFERMI,GV,GA,CCABIB,SCABIB,GAMEL
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      COMMON / TAUBRA / GAMPRT(30),JLIST(30),NCHAN
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      PARAMETER (NMODE=15,NM1=0,NM2=1,NM3=8,NM4=2,NM5=1,NM6=3)
      COMMON / DECOMP /IDFFIN(9,NMODE),MULPIK(NMODE)
     &                ,NAMES
      CHARACTER NAMES(NMODE)*31
      CHARACTER OLDNAMES(7)*31
      CHARACTER*80 bxINIT
      PARAMETER (
     $  bxINIT ='(1x,1h*,g17.8,            16x, a31,a4,a4, 1x,1h*)'
     $ )
      REAL*4 PI
*
* LIST OF BRANCHING RATIOS
*AM normalised to e nu nutau channel
*AM                  enu   munu   pinu  rhonu   A1nu   Knu    K*nu   pi'
*AM   DATA JLIST  /    1,     2,     3,     4,     5,     6,     7,
*AM   DATA GAMPRT /1.000,0.9730,0.6054,1.2432,0.8432,0.0432,O.O811,0.616
*AM
*AM  multipion decays
*
*    conventions of particles names
*                 K-,P-,K+,  K0,P-,KB,  K-,P0,K0
*                  3, 1,-3  , 4, 1,-4  , 3, 2, 4  ,
*                 P0,P0,K-,  K-,P-,P+,  P-,KB,P0
*                  2, 2, 3  , 3, 1,-1  , 1,-4, 2  ,
*                 ET,P-,P0   P-,P0,GM
*                  9, 1, 2  , 1, 2, 8
*
      DIMENSION NOPIK(6,NMODE),NPIK(NMODE)
*AM   outgoing multiplicity and flavors of multi-pion /multi-K modes    
      DATA   NPIK  /                4,                    4,  
     1                              5,                    5,
     2                              6,                    6,
     3                              3,                    3,            
     4                              3,                    3,            
     5                              3,                    3,            
     6                              3,                    3,  
     7                              2                         /         
      DATA  NOPIK / -1,-1, 1, 2, 0, 0,     2, 2, 2,-1, 0, 0,  
     1              -1,-1, 1, 2, 2, 0,    -1,-1,-1, 1, 1, 0,  
     2              -1,-1,-1, 1, 1, 2,    -1,-1, 1, 2, 2, 2, 
     3              -3,-1, 3, 0, 0, 0,    -4,-1, 4, 0, 0, 0,  
     4              -3, 2,-4, 0, 0, 0,     2, 2,-3, 0, 0, 0,  
     5              -3,-1, 1, 0, 0, 0,    -1, 4, 2, 0, 0, 0,  
     6               9,-1, 2, 0, 0, 0,    -1, 2, 8, 0, 0, 0,
     7              -3, 4, 0, 0, 0, 0                         /
* LIST OF BRANCHING RATIOS
      NCHAN = NMODE + 7
      DO 1 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = 1.0000
        IF(I.EQ. 2) GAMPRT(I) = 1.0000
        IF(I.EQ. 3) GAMPRT(I) = 1.0000
        IF(I.EQ. 4) GAMPRT(I) = 1.0000
        IF(I.EQ. 5) GAMPRT(I) = 1.0000
        IF(I.EQ. 6) GAMPRT(I) = 1.0000
        IF(I.EQ. 7) GAMPRT(I) = 1.0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
        IF(I.EQ.20) GAMPRT(I) = 1.0000
        IF(I.EQ.21) GAMPRT(I) = 1.0000
        IF(I.EQ.22) GAMPRT(I) = 1.0000
        IF(I.EQ. 1) OLDNAMES(I)='  TAU-  -->   E-               '
        IF(I.EQ. 2) OLDNAMES(I)='  TAU-  -->  MU-               '
        IF(I.EQ. 3) OLDNAMES(I)='  TAU-  -->  PI-               '
        IF(I.EQ. 4) OLDNAMES(I)='  TAU-  -->  PI-, PI0          '
        IF(I.EQ. 5) OLDNAMES(I)='  TAU-  -->  A1- (two subch)   '
        IF(I.EQ. 6) OLDNAMES(I)='  TAU-  -->   K-               '
        IF(I.EQ. 7) OLDNAMES(I)='  TAU-  -->  K*- (two subch)   '
        IF(I.EQ. 8) NAMES(I-7)='  TAU-  --> 2PI-,  PI0,  PI+   '
        IF(I.EQ. 9) NAMES(I-7)='  TAU-  --> 3PI0,        PI-   '
        IF(I.EQ.10) NAMES(I-7)='  TAU-  --> 2PI-,  PI+, 2PI0   '
        IF(I.EQ.11) NAMES(I-7)='  TAU-  --> 3PI-, 2PI+,        '
        IF(I.EQ.12) NAMES(I-7)='  TAU-  --> 3PI-, 2PI+,  PI0   '
        IF(I.EQ.13) NAMES(I-7)='  TAU-  --> 2PI-,  PI+, 3PI0   '
        IF(I.EQ.14) NAMES(I-7)='  TAU-  -->  K-, PI-,  K+      '
        IF(I.EQ.15) NAMES(I-7)='  TAU-  -->  K0, PI-, K0B      '
        IF(I.EQ.16) NAMES(I-7)='  TAU-  -->  K-,  K0, PI0      '
        IF(I.EQ.17) NAMES(I-7)='  TAU-  --> PI0, PI0,  K-      '
        IF(I.EQ.18) NAMES(I-7)='  TAU-  -->  K-, PI-, PI+      '
        IF(I.EQ.19) NAMES(I-7)='  TAU-  --> PI-, K0B, PI0      '
        IF(I.EQ.20) NAMES(I-7)='  TAU-  --> ETA, PI-, PI0      '
        IF(I.EQ.21) NAMES(I-7)='  TAU-  --> PI-, PI0, GAM      '
        IF(I.EQ.22) NAMES(I-7)='  TAU-  -->  K-,  K0           '
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   1  CONTINUE
      DO I=1,NMODE
        MULPIK(I)=NPIK(I)
        DO J=1,MULPIK(I)
         IDFFIN(J,I)=NOPIK(J,I)
        ENDDO
      ENDDO
*
*
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
*

C      GFERMI = 1.16637E-5
C      CCABIB = 0.975
C      GV     = 1.0
C      GA     =-1.0
      GFERMI = xpar(32)
      CCABIB = XPAR(ITAUXPAR+7)
      GV     = XPAR(ITAUXPAR+8)
      GA     = XPAR(ITAUXPAR+9)

      BRA1   = XPAR(ITAUXPAR+10)
      BRKS   = XPAR(ITAUXPAR+11)
      BRK0   = XPAR(ITAUXPAR+12)
      BRK0B  = XPAR(ITAUXPAR+13)
      DO K=1,NCHAN
       GAMPRT(K)=XPAR(ITAUXPAR+100+K)
      ENDDO
* ZW 13.04.89 HERE WAS AN ERROR
      SCABIB = SQRT(1.-CCABIB**2)
      PI =4.*ATAN(1.)
      GAMEL  = GFERMI**2*AMTAU**5/(192*PI**3)
*
*      CALL DEXAY(-1)
*
* PRINTOUTS FOR KK version

      SUM=0
      DO K=1,NCHAN
       SUM=SUM+GAMPRT(K)
      ENDDO

      
      WRITE(iout,bxope)
      WRITE(iout,bxtxt) ' TAUOLA Initialization SUBROUTINE INITDK:    '
      WRITE(iout,bxtxt) ' Adopted to read from KK                     '
      WRITE(iout,bxtxt) '                      '
      WRITE(iout,bxtxt) ' Choice Probability      --     Decay Channel'
      DO K=1,7      
      WRITE(iout,bxINIT) GAMPRT(K)/SUM,    OLDNAMES(K),'****','***'
      ENDDO
      DO K=8,7+NMODE      
      WRITE(iout,bxINIT) GAMPRT(K)/SUM,     NAMES(K-7),'****','***'
      ENDDO
      WRITE(iout,bxtxt) ' In addition:'
      WRITE(iout,bxINIT) GV,    'Vector W-tau-nu coupl.     ','****','***'
      WRITE(iout,bxINIT) GA,    'Axial  W-tau-nu coupl.     ','****','***'
      WRITE(iout,bxINIT) GFERMI,'Fermi Coupling             ','****','***'
      WRITE(iout,bxINIT) CCABIB,'cabibo angle               ','****','***'
      WRITE(iout,bxINIT) BRA1,  'a1 br ratio (massless)     ','****','***'
      WRITE(iout,bxINIT) BRKS,  'K* br ratio (massless)     ','****','***'
      WRITE(iout,bxclo)
            
      RETURN
      END



*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*////////////////////////////////////////////////////////////////////////////////////
*//                                                                                //
*//            Customization by S. Jadach, April 1999                              //
*//                                                                                //
*//     Prefix IRC_ added to all subrogram names                                   //
*//     Name /circom/ replaced with /c_IRC/                                        //
*//                                                                                //
*//                                                                                //
*//                                                                                //
*////////////////////////////////////////////////////////////////////////////////////

c circe.f -- canonical beam spectra for linear collider physics
c   Copyright (C) 1996,1997 by Thorsten.Ohl@Physik.TH-Darmstadt.de
c
c   Circe is free software; you can redistribute it and/or modify it
c   under the terms of the GNU General Public License as published by
c   the Free Software Foundation; either version 2, or (at your option)
c   any later version.
c
c   Circe is distributed in the hope that it will be useful, but
c   WITHOUT ANY WARRANTY; without even the implied warranty of
c   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c   GNU General Public License for more details.
c
c   You should have received a copy of the GNU General Public License
c   along with this program; if not, write to the Free Software
c   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

      DOUBLE PRECISION FUNCTION IRC_circe (x1, x2, p1, p2)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      INTEGER p1, p2
      DOUBLE PRECISION IRC_circee, IRC_circeg, IRC_circgg
      INTEGER electr, positr, photon
      PARAMETER (electr =  11)
      PARAMETER (positr = -11)
      PARAMETER (photon =  22)
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IRC_circe = -1.0
      IF (ABS(p1)  .EQ.  electr) THEN
         IF (ABS(p2)  .EQ.  electr) THEN
            IRC_circe = IRC_circee (x1, x2)
         ELSEIF (p2  .EQ.  photon) THEN
            IRC_circe = IRC_circeg (x1, x2)
         ENDIF
      ELSEIF (p1  .EQ.  photon) THEN
         IF (ABS(p2)  .EQ.  electr) THEN
            IRC_circe = IRC_circeg (x2, x1)
         ELSEIF (p2  .EQ.  photon) THEN
            IRC_circe = IRC_circgg (x1, x2)
         ENDIF
      ENDIF
      END
      DOUBLE PRECISION FUNCTION IRC_circee (x1, x2)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION d1, d2
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IRC_circee = -1.0
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      IF (x1  .EQ.  1d0) THEN
         d1 = a1(0)
      ELSEIF (x1  .LT.  1d0  .AND.  x1  .GT.  0d0) THEN
         d1 = a1(1) * x1**a1(2) * (1d0 - x1)**a1(3)
      ELSEIF (x1  .EQ.  -1d0) THEN
         d1 = 1d0 - a1(0)
      ELSE
         d1 = 0d0
      ENDIF
      IF (x2  .EQ.  1d0) THEN
         d2 = a1(0)
      ELSEIF (x2  .LT.  1d0  .AND.  x2  .GT.  0d0) THEN
         d2 = a1(1) * x2**a1(2) * (1d0 - x2)**a1(3)
      ELSEIF (x2  .EQ.  -1d0) THEN
         d2 = 1d0 - a1(0)
      ELSE
         d2 = 0d0
      ENDIF
      IRC_circee = d1 * d2
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END
      DOUBLE PRECISION FUNCTION IRC_circeg (x1, x2)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION d1, d2
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IRC_circeg = -1.0
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      IF (x1  .EQ.  1d0) THEN
         d1 = a1(0)
      ELSEIF (x1  .LT.  1d0  .AND.  x1  .GT.  0d0) THEN
         d1 = a1(1) * x1**a1(2) * (1d0 - x1)**a1(3)
      ELSEIF (x1  .EQ.  -1d0) THEN
         d1 = 1d0 - a1(0)
      ELSE
         d1 = 0d0
      ENDIF
      IF (x2  .LT.  1d0  .AND.  x2  .GT.  0d0) THEN
         d2 = a1(4) * x2**a1(5) * (1d0 - x2)**a1(6)
      ELSEIF (x2  .EQ.  -1d0) THEN
         d2 = a1(7)
      ELSE
         d2 = 0d0
      ENDIF
      IRC_circeg = d1 * d2
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END
      SUBROUTINE IRC_circel (l)
      IMPLICIT NONE
      DOUBLE PRECISION l
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      l = lumi
      END
      SUBROUTINE IRC_circem (errlvl, errmsg)
      IMPLICIT NONE
      CHARACTER*(*) errlvl, errmsg
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      INTEGER errcnt
      SAVE errcnt
      DATA errcnt /0/
      IF (errlvl  .EQ.  'message') THEN
         print *, 'circe:message: ', errmsg
      ELSEIF (errlvl  .EQ.  'warning') THEN
         IF (errcnt  .LT.  100) THEN
            errcnt = errcnt + 1
            print *, 'circe:warning: ', errmsg
         ELSEIF (errcnt  .EQ.  100) THEN
            errcnt = errcnt + 1
            print *, 'circe:message: more than 100 messages' 
            print *, 'circe:message: turning warnings off' 
         ENDIF
      ELSEIF (errlvl  .EQ.  'error') THEN
         IF (errcnt  .LT.  200) THEN
            errcnt = errcnt + 1
            print *, 'circe:error:   ', errmsg
         ELSEIF (errcnt  .EQ.  200) THEN
            errcnt = errcnt + 1
            print *, 'circe:message: more than 200 messages' 
            print *, 'circe:message: turning error messages off' 
         ENDIF
      ELSEIF (errlvl  .EQ.  'panic') THEN
         IF (errcnt  .LT.  300) THEN
            errcnt = errcnt + 1
            print *, 'circe:panic:   ', errmsg
         ELSEIF (errcnt  .EQ.  300) THEN
            errcnt = errcnt + 1
            print *, 'circe:message: more than 300 messages' 
            print *, 'circe:message: turning panic messages off' 
         ENDIF
      ELSE
         print *, 'circe:panic:    invalid error code ', errlvl
      ENDIF
      END
      SUBROUTINE IRC_circes (xx1m, xx2m, xroots, xacc, xver, xrev, xchat)
      IMPLICIT NONE
      DOUBLE PRECISION xx1m, xx2m, xroots
      INTEGER xacc, xver, xrev, xchat
      INTEGER sband, tesla, xband
      PARAMETER (sband  =  1, tesla  =  2, xband  =  3)
      INTEGER sbndee, teslee, xbndee
      PARAMETER (sbndee =  4, teslee =  5, xbndee =  6)
      INTEGER nacc
      PARAMETER (nacc = 6)
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      CHARACTER*60 msgbuf
      CHARACTER*6 accnam(nacc)
      INTEGER zver
      SAVE zver
      INTEGER ver34
      INTEGER gev350, gev500, gev800, tev1, tev16
      PARAMETER (gev350 = 1, gev500 = 2, gev800 = 3,
     $           tev1 =   4, tev16  = 5)
      INTEGER a1negy, a1nrev
      PARAMETER (a1negy = 5, a1nrev = 5)
      INTEGER i
      REAL xa1lum(a1negy,nacc,0:a1nrev)
      REAL xa1(0:7,a1negy,nacc,0:a1nrev)
      INTEGER a3negy, a3nrev
      PARAMETER (a3negy = 5, a3nrev = 5)
      REAL xa3lum(a3negy,nacc,0:a3nrev)
      REAL xa3(0:7,a3negy,nacc,0:a3nrev)
      INTEGER a5negy, a5nrev
      PARAMETER (a5negy = 5, a5nrev = 1)
      REAL xa5lum(a5negy,nacc,0:a5nrev)
      REAL xa5(0:7,a5negy,nacc,0:a5nrev)
      DATA accnam(sband)  /'sband'/
      DATA accnam(tesla)  /'tesla'/
      DATA accnam(xband)  /'xband'/
      DATA accnam(sbndee) /'sbndee'/
      DATA accnam(teslee) /'teslee'/
      DATA accnam(xbndee) /'xbndee'/
      DATA zver / -1 /
      DATA xa1lum(gev500,sband,1) /  5.212299e+01 /
      DATA (xa1(i,gev500,sband,1),i=0,7) /
     $    .39192e+00,   .66026e+00,   .11828e+02,  -.62543e+00, 
     $    .52292e+00,  -.69245e+00,   .14983e+02,   .65421e+00 /
      DATA xa1lum(gev500,tesla,1) /  6.066178e+01 /
      DATA (xa1(i,gev500,tesla,1),i=0,7) /
     $    .30196e+00,   .12249e+01,   .21423e+02,  -.57848e+00, 
     $    .68766e+00,  -.69788e+00,   .23121e+02,   .78399e+00 /
      DATA xa1lum(gev500,xband,1) /  5.884699e+01 /
      DATA (xa1(i,gev500,xband,1),i=0,7) /
     $    .48594e+00,   .52435e+00,   .83585e+01,  -.61347e+00, 
     $    .30703e+00,  -.68804e+00,   .84109e+01,   .44312e+00 /
      DATA xa1lum(tev1,sband,1)   /  1.534650e+02 /
      DATA (xa1(i,tev1,sband,1),i=0,7) /
     $    .24399e+00,   .87464e+00,   .66751e+01,  -.56808e+00, 
     $    .59295e+00,  -.68921e+00,   .94232e+01,   .83351e+00 /
      DATA xa1lum(tev1,tesla,1)   /  1.253381e+03 /
      DATA (xa1(i,tev1,tesla,1),i=0,7) /
     $    .39843e+00,   .70097e+00,   .11602e+02,  -.61061e+00, 
     $    .40737e+00,  -.69319e+00,   .14800e+02,   .51382e+00 /
      DATA xa1lum(tev1,xband,1)   /  1.901783e+02 /
      DATA (xa1(i,tev1,xband,1),i=0,7) /
     $    .32211e+00,   .61798e+00,   .28298e+01,  -.54644e+00, 
     $    .45674e+00,  -.67301e+00,   .41703e+01,   .74536e+00 /
      DATA (xa1lum(gev350,i,1),i=1,nacc) / nacc*-1d0 /
      DATA (xa1lum(gev800,i,1),i=1,nacc) / nacc*-1d0 /
      DATA (xa1lum(gev500,i,1),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev1,i,1),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev16,i,1),i=1,nacc) / 6*-1d0 /
      DATA xa1lum(gev500,sband,2) /   .31057e+02 /
      DATA (xa1(i,gev500,sband,2),i=0,7) /
     $    .38504e+00,   .79723e+00,   .14191e+02,  -.60456e+00, 
     $    .53411e+00,  -.68873e+00,   .15105e+02,   .65151e+00 /
      DATA xa1lum(tev1,sband,2) /   .24297e+03 /
      DATA (xa1(i,tev1,sband,2),i=0,7) /
     $    .24374e+00,   .89466e+00,   .70242e+01,  -.56754e+00, 
     $    .60910e+00,  -.68682e+00,   .96083e+01,   .83985e+00 /
      DATA xa1lum(gev350,tesla,2) /   .73369e+02 /
      DATA (xa1(i,gev350,tesla,2),i=0,7) /
     $    .36083e+00,   .12819e+01,   .37880e+02,  -.59492e+00, 
     $    .69109e+00,  -.69379e+00,   .40061e+02,   .65036e+00 /
      DATA xa1lum(gev500,tesla,2) /   .10493e+03 /
      DATA (xa1(i,gev500,tesla,2),i=0,7) /
     $    .29569e+00,   .11854e+01,   .21282e+02,  -.58553e+00, 
     $    .71341e+00,  -.69279e+00,   .24061e+02,   .77709e+00 /
      DATA xa1lum(gev800,tesla,2) /   .28010e+03 /
      DATA (xa1(i,gev800,tesla,2),i=0,7) /
     $    .22745e+00,   .11265e+01,   .10483e+02,  -.55711e+00, 
     $    .69579e+00,  -.69068e+00,   .13093e+02,   .89605e+00 /
      DATA xa1lum(tev1,tesla,2) /   .10992e+03 /
      DATA (xa1(i,tev1,tesla,2),i=0,7) /
     $    .40969e+00,   .66105e+00,   .11972e+02,  -.62041e+00, 
     $    .40463e+00,  -.69354e+00,   .14669e+02,   .51281e+00 /
      DATA xa1lum(gev500,xband,2) /   .35689e+02 /
      DATA (xa1(i,gev500,xband,2),i=0,7) /
     $    .48960e+00,   .46815e+00,   .75249e+01,  -.62769e+00, 
     $    .30341e+00,  -.68754e+00,   .85545e+01,   .43453e+00 /
      DATA xa1lum(tev1,xband,2) /   .11724e+03 /
      DATA (xa1(i,tev1,xband,2),i=0,7) /
     $    .31939e+00,   .62415e+00,   .30763e+01,  -.55314e+00, 
     $    .45634e+00,  -.67089e+00,   .41529e+01,   .73807e+00 /
      DATA xa1lum(gev350,sband,2) / -1d0 /
      DATA xa1lum(gev350,xband,2) / -1d0 /
      DATA xa1lum(gev800,sband,2) / -1d0 /
      DATA xa1lum(gev800,xband,2) / -1d0 /
      DATA (xa1lum(gev350,i,2),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev500,i,2),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev800,i,2),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev1,i,2),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev16,i,2),i=1,nacc) / 6*-1d0 /
      DATA xa1lum(gev500,sband, 3) /   .31469e+02 /
      DATA (xa1(i,gev500,sband, 3),i=0,7) /
     $    .38299e+00,   .72035e+00,   .12618e+02,  -.61611e+00, 
     $    .51971e+00,  -.68960e+00,   .15066e+02,   .63784e+00 /
      DATA xa1lum(tev1,  sband, 3) /   .24566e+03 /
      DATA (xa1(i,tev1,  sband, 3),i=0,7) /
     $    .24013e+00,   .95763e+00,   .69085e+01,  -.55151e+00, 
     $    .59497e+00,  -.68622e+00,   .94494e+01,   .82158e+00 /
      DATA xa1lum(gev350,tesla, 3) /   .74700e+02 /
      DATA (xa1(i,gev350,tesla, 3),i=0,7) /
     $    .34689e+00,   .12484e+01,   .33720e+02,  -.59523e+00, 
     $    .66266e+00,  -.69524e+00,   .38488e+02,   .63775e+00 /
      DATA xa1lum(gev500,tesla, 3) /   .10608e+03 /
      DATA (xa1(i,gev500,tesla, 3),i=0,7) /
     $    .28282e+00,   .11700e+01,   .19258e+02,  -.58390e+00, 
     $    .68777e+00,  -.69402e+00,   .23638e+02,   .75929e+00 /
      DATA xa1lum(gev800,tesla, 3) /   .28911e+03 /
      DATA (xa1(i,gev800,tesla, 3),i=0,7) /
     $    .21018e+00,   .12039e+01,   .96763e+01,  -.54024e+00, 
     $    .67220e+00,  -.69083e+00,   .12733e+02,   .87355e+00 /
      DATA xa1lum(tev1,  tesla, 3) /   .10936e+03 /
      DATA (xa1(i,tev1,  tesla, 3),i=0,7) /
     $    .41040e+00,   .68099e+00,   .11610e+02,  -.61237e+00, 
     $    .40155e+00,  -.69073e+00,   .14698e+02,   .49989e+00 /
      DATA xa1lum(gev500,xband, 3) /   .36145e+02 /
      DATA (xa1(i,gev500,xband, 3),i=0,7) /
     $    .51285e+00,   .45812e+00,   .75135e+01,  -.62247e+00, 
     $    .30444e+00,  -.68530e+00,   .85519e+01,   .43062e+00 /
      DATA xa1lum(tev1,  xband, 3) /   .11799e+03 /
      DATA (xa1(i,tev1,  xband, 3),i=0,7) /
     $    .31241e+00,   .61241e+00,   .29938e+01,  -.55848e+00, 
     $    .44801e+00,  -.67116e+00,   .41119e+01,   .72753e+00 /
      DATA xa1lum(gev350,sband,3) / -1d0 /
      DATA xa1lum(gev350,xband,3) / -1d0 /
      DATA xa1lum(gev800,sband,3) / -1d0 /
      DATA xa1lum(gev800,xband,3) / -1d0 /
      DATA (xa1lum(gev350,i,3),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev500,i,3),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev800,i,3),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev1,i,3),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev16,i,3),i=1,nacc) / 6*-1d0 /
      DATA xa1lum(gev500,sband, 4) /   .31528e+02 /
      DATA (xa1(i,gev500,sband, 4),i=0,7) /
     $    .38169e+00,   .73949e+00,   .12543e+02,  -.61112e+00, 
     $    .51256e+00,  -.69009e+00,   .14892e+02,   .63314e+00 /
      DATA xa1lum(tev1,  sband, 4) /   .24613e+03 /
      DATA (xa1(i,tev1,  sband, 4),i=0,7) /
     $    .24256e+00,   .94117e+00,   .66775e+01,  -.55160e+00, 
     $    .57484e+00,  -.68891e+00,   .92271e+01,   .81162e+00 /
      DATA xa1lum(gev350,tesla, 4) /   .74549e+02 /
      DATA (xa1(i,gev350,tesla, 4),i=0,7) /
     $    .34120e+00,   .12230e+01,   .32932e+02,  -.59850e+00, 
     $    .65947e+00,  -.69574e+00,   .38116e+02,   .63879e+00 /
      DATA xa1lum(gev500,tesla, 4) /   .10668e+03 /
      DATA (xa1(i,gev500,tesla, 4),i=0,7) /
     $    .28082e+00,   .11074e+01,   .18399e+02,  -.59118e+00, 
     $    .68880e+00,  -.69375e+00,   .23463e+02,   .76073e+00 /
      DATA xa1lum(gev800,tesla, 4) /   .29006e+03 /
      DATA (xa1(i,gev800,tesla, 4),i=0,7) /
     $    .21272e+00,   .11443e+01,   .92564e+01,  -.54657e+00, 
     $    .66799e+00,  -.69137e+00,   .12498e+02,   .87571e+00 /
      DATA xa1lum(tev1,  tesla, 4) /   .11009e+03 /
      DATA (xa1(i,tev1,  tesla, 4),i=0,7) /
     $    .41058e+00,   .64745e+00,   .11271e+02,  -.61996e+00, 
     $    .39801e+00,  -.69150e+00,   .14560e+02,   .49924e+00 /
      DATA xa1lum(gev500,xband, 4) /   .36179e+02 /
      DATA (xa1(i,gev500,xband, 4),i=0,7) /
     $    .51155e+00,   .43313e+00,   .70446e+01,  -.63003e+00, 
     $    .29449e+00,  -.68747e+00,   .83489e+01,   .42458e+00 /
      DATA xa1lum(tev1,  xband, 4) /   .11748e+03 /
      DATA (xa1(i,tev1,  xband, 4),i=0,7) /
     $    .32917e+00,   .54322e+00,   .28493e+01,  -.57959e+00, 
     $    .39266e+00,  -.68217e+00,   .38475e+01,   .68478e+00 /
      DATA xa1lum(gev350,sband,4) / -1d0 /
      DATA xa1lum(gev350,xband,4) / -1d0 /
      DATA xa1lum(gev800,sband,4) / -1d0 /
      DATA xa1lum(gev800,xband,4) / -1d0 /
      DATA (xa1lum(gev350,i,4),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev500,i,4),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(gev800,i,4),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev1,i,4),i=sbndee,nacc) / 3*-1d0 /
      DATA (xa1lum(tev16,i,4),i=1,nacc) / 6*-1d0 /
      DATA xa1lum(gev350,sband, 5) /  0.21897e+02 /
      DATA (xa1(i,gev350,sband, 5),i=0,7) /
     $   0.57183e+00,  0.53877e+00,  0.19422e+02, -0.63064e+00, 
     $   0.49112e+00, -0.69109e+00,  0.24331e+02,  0.52718e+00 /
      DATA xa1lum(gev500,sband, 5) /  0.31383e+02 /
      DATA (xa1(i,gev500,sband, 5),i=0,7) /
     $   0.51882e+00,  0.49915e+00,  0.11153e+02, -0.63017e+00, 
     $   0.50217e+00, -0.69113e+00,  0.14935e+02,  0.62373e+00 /
      DATA xa1lum(gev800,sband, 5) /  0.95091e+02 /
      DATA (xa1(i,gev800,sband, 5),i=0,7) /
     $   0.47137e+00,  0.46150e+00,  0.56562e+01, -0.61758e+00, 
     $   0.46863e+00, -0.68897e+00,  0.85876e+01,  0.67577e+00 /
      DATA xa1lum(tev1,sband, 5) /  0.11900e+03 /
      DATA (xa1(i,tev1,sband, 5),i=0,7) /
     $   0.43956e+00,  0.45471e+00,  0.42170e+01, -0.61180e+00, 
     $   0.48711e+00, -0.68696e+00,  0.67145e+01,  0.74551e+00 /
      DATA xa1lum(tev16,sband, 5) /  0.11900e+03 /
      DATA (xa1(i,tev16,sband, 5),i=0,7) /
     $   0.43956e+00,  0.45471e+00,  0.42170e+01, -0.61180e+00, 
     $   0.48711e+00, -0.68696e+00,  0.67145e+01,  0.74551e+00 /
      DATA xa1lum(gev350,tesla, 5) /  0.97452e+02 /
      DATA (xa1(i,gev350,tesla, 5),i=0,7) /
     $   0.39071e+00,  0.84996e+00,  0.17614e+02, -0.60609e+00, 
     $   0.73920e+00, -0.69490e+00,  0.28940e+02,  0.77286e+00 /
      DATA xa1lum(gev500,tesla, 5) /  0.10625e+03 /
      DATA (xa1(i,gev500,tesla, 5),i=0,7) /
     $   0.42770e+00,  0.71457e+00,  0.15284e+02, -0.61664e+00, 
     $   0.68166e+00, -0.69208e+00,  0.24165e+02,  0.73806e+00 /
      DATA xa1lum(gev800,tesla, 5) /  0.17086e+03 /
      DATA (xa1(i,gev800,tesla, 5),i=0,7) /
     $   0.36025e+00,  0.69118e+00,  0.76221e+01, -0.59440e+00, 
     $   0.71269e+00, -0.69077e+00,  0.13117e+02,  0.91780e+00 /
      DATA xa1lum(tev1,tesla, 5) /  0.21433e+03 /
      DATA (xa1(i,tev1,tesla, 5),i=0,7) /
     $   0.33145e+00,  0.67075e+00,  0.55438e+01, -0.58468e+00, 
     $   0.72503e+00, -0.69084e+00,  0.99992e+01,  0.10112e+01 /
      DATA xa1lum(tev16,tesla, 5) /  0.34086e+03 /
      DATA (xa1(i,tev16,tesla, 5),i=0,7) /
     $   0.49058e+00,  0.42609e+00,  0.50550e+01, -0.61867e+00, 
     $   0.39225e+00, -0.68916e+00,  0.75514e+01,  0.58754e+00 /
      DATA xa1lum(gev350,xband, 5) /  0.31901e+02 /
      DATA (xa1(i,gev350,xband, 5),i=0,7) /
     $   0.65349e+00,  0.31752e+00,  0.94342e+01, -0.64291e+00, 
     $   0.30364e+00, -0.68989e+00,  0.11446e+02,  0.40486e+00 /
      DATA xa1lum(gev500,xband, 5) /  0.36386e+02 /
      DATA (xa1(i,gev500,xband, 5),i=0,7) /
     $   0.65132e+00,  0.28728e+00,  0.69853e+01, -0.64440e+00, 
     $   0.28736e+00, -0.68758e+00,  0.83227e+01,  0.41492e+00 /
      DATA xa1lum(gev800,xband, 5) /  0.10854e+03 /
      DATA (xa1(i,gev800,xband, 5),i=0,7) /
     $   0.49478e+00,  0.36221e+00,  0.30116e+01, -0.61548e+00, 
     $   0.39890e+00, -0.68418e+00,  0.45183e+01,  0.67243e+00 /
      DATA xa1lum(tev1,xband, 5) /  0.11899e+03 /
      DATA (xa1(i,tev1,xband, 5),i=0,7) /
     $   0.49992e+00,  0.34299e+00,  0.26184e+01, -0.61584e+00, 
     $   0.38450e+00, -0.68342e+00,  0.38589e+01,  0.67408e+00 /
      DATA xa1lum(tev16,xband, 5) /  0.13675e+03 /
      DATA (xa1(i,tev16,xband, 5),i=0,7) /
     $   0.50580e+00,  0.30760e+00,  0.18339e+01, -0.61421e+00, 
     $   0.35233e+00, -0.68315e+00,  0.26708e+01,  0.67918e+00 /
      DATA xa1lum(gev500,sbndee, 0) /   .92914e+01 /
      DATA (xa1(i,gev500,sbndee, 0),i=0,7) /
     $    .34866e+00,   .78710e+00,   .10304e+02,  -.59464e+00, 
     $    .40234e+00,  -.69741e+00,   .20645e+02,   .47274e+00 /
      DATA xa1lum(tev1,  sbndee, 0) /   .45586e+02 /
      DATA (xa1(i,tev1,  sbndee, 0),i=0,7) /
     $    .21084e+00,   .99168e+00,   .54407e+01,  -.52851e+00, 
     $    .47493e+00,  -.69595e+00,   .12480e+02,   .64027e+00 /
      DATA xa1lum(gev350,teslee, 0) /   .15175e+02 /
      DATA (xa1(i,gev350,teslee, 0),i=0,7) /
     $    .33093e+00,   .11137e+01,   .25275e+02,  -.59942e+00, 
     $    .49623e+00,  -.70403e+00,   .60188e+02,   .44637e+00 /
      DATA xa1lum(gev500,teslee, 0) /   .21622e+02 /
      DATA (xa1(i,gev500,teslee, 0),i=0,7) /
     $    .27175e+00,   .10697e+01,   .14858e+02,  -.58418e+00, 
     $    .50824e+00,  -.70387e+00,   .36129e+02,   .53002e+00 /
      DATA xa1lum(gev800,teslee, 0) /   .43979e+02 /
      DATA (xa1(i,gev800,teslee, 0),i=0,7) /
     $    .22994e+00,   .10129e+01,   .81905e+01,  -.55751e+00, 
     $    .46551e+00,  -.70461e+00,   .19394e+02,   .58387e+00 /
      DATA xa1lum(tev1,  teslee, 0) /   .25465e+02 /
      DATA (xa1(i,tev1,  teslee, 0),i=0,7) /
     $    .37294e+00,   .67522e+00,   .87504e+01,  -.60576e+00, 
     $    .35095e+00,  -.69821e+00,   .18526e+02,   .42784e+00 /
      DATA xa1lum(gev500,xbndee, 0) /   .13970e+02 /
      DATA (xa1(i,gev500,xbndee, 0),i=0,7) /
     $    .47296e+00,   .46800e+00,   .58897e+01,  -.61689e+00, 
     $    .27181e+00,  -.68923e+00,   .10087e+02,   .37462e+00 /
      DATA xa1lum(tev1,  xbndee, 0) /   .41056e+02 /
      DATA (xa1(i,tev1,  xbndee, 0),i=0,7) /
     $    .27965e+00,   .74816e+00,   .27415e+01,  -.50491e+00, 
     $    .38320e+00,  -.67945e+00,   .47506e+01,   .62218e+00 /
      DATA xa1lum(gev350,sbndee,0) / -1d0 /
      DATA xa1lum(gev350,xbndee,0) / -1d0 /
      DATA xa1lum(gev800,sbndee,0) / -1d0 /
      DATA xa1lum(gev800,xbndee,0) / -1d0 /
      DATA xa1lum(gev500,sband, 0) /   .31528e+02 /
      DATA (xa1(i,gev500,sband, 0),i=0,7) /
     $    .38169e+00,   .73949e+00,   .12543e+02,  -.61112e+00, 
     $    .51256e+00,  -.69009e+00,   .14892e+02,   .63314e+00 /
      DATA xa1lum(tev1,  sband, 0) /   .24613e+03 /
      DATA (xa1(i,tev1,  sband, 0),i=0,7) /
     $    .24256e+00,   .94117e+00,   .66775e+01,  -.55160e+00, 
     $    .57484e+00,  -.68891e+00,   .92271e+01,   .81162e+00 /
      DATA xa1lum(gev350,tesla, 0) /   .74549e+02 /
      DATA (xa1(i,gev350,tesla, 0),i=0,7) /
     $    .34120e+00,   .12230e+01,   .32932e+02,  -.59850e+00, 
     $    .65947e+00,  -.69574e+00,   .38116e+02,   .63879e+00 /
      DATA xa1lum(gev500,tesla, 0) /   .10668e+03 /
      DATA (xa1(i,gev500,tesla, 0),i=0,7) /
     $    .28082e+00,   .11074e+01,   .18399e+02,  -.59118e+00, 
     $    .68880e+00,  -.69375e+00,   .23463e+02,   .76073e+00 /
      DATA xa1lum(gev800,tesla, 0) /   .29006e+03 /
      DATA (xa1(i,gev800,tesla, 0),i=0,7) /
     $    .21272e+00,   .11443e+01,   .92564e+01,  -.54657e+00, 
     $    .66799e+00,  -.69137e+00,   .12498e+02,   .87571e+00 /
      DATA xa1lum(tev1,  tesla, 0) /   .11009e+03 /
      DATA (xa1(i,tev1,  tesla, 0),i=0,7) /
     $    .41058e+00,   .64745e+00,   .11271e+02,  -.61996e+00, 
     $    .39801e+00,  -.69150e+00,   .14560e+02,   .49924e+00 /
      DATA xa1lum(gev500,xband, 0) /   .36179e+02 /
      DATA (xa1(i,gev500,xband, 0),i=0,7) /
     $    .51155e+00,   .43313e+00,   .70446e+01,  -.63003e+00, 
     $    .29449e+00,  -.68747e+00,   .83489e+01,   .42458e+00 /
      DATA xa1lum(tev1,  xband, 0) /   .11748e+03 /
      DATA (xa1(i,tev1,  xband, 0),i=0,7) /
     $    .32917e+00,   .54322e+00,   .28493e+01,  -.57959e+00, 
     $    .39266e+00,  -.68217e+00,   .38475e+01,   .68478e+00 /
      DATA xa1lum(gev350,sband,0) / -1d0 /
      DATA xa1lum(gev350,xband,0) / -1d0 /
      DATA xa1lum(gev800,sband,0) / -1d0 /
      DATA xa1lum(gev800,xband,0) / -1d0 /
      DATA xa3lum(gev800,tesla, 3) /   .17196e+03 /
      DATA (xa3(i,gev800,tesla, 3),i=0,7) /
     $    .21633e+00,   .11333e+01,   .95928e+01,  -.55095e+00, 
     $    .73044e+00,  -.69101e+00,   .12868e+02,   .94737e+00 /
      DATA xa3lum(gev800,tesla, 4) /   .16408e+03 /
      DATA (xa3(i,gev800,tesla, 4),i=0,7) /
     $    .41828e+00,   .72418e+00,   .14137e+02,  -.61189e+00, 
     $    .36697e+00,  -.69205e+00,   .17713e+02,   .43583e+00 /
      DATA xa3lum(gev350,tesla, 5) /  0.66447e+02 /
      DATA (xa3(i,gev350,tesla, 5),i=0,7) /
     $   0.69418e+00,  0.50553e+00,  0.48430e+02, -0.63911e+00, 
     $   0.34074e+00, -0.69533e+00,  0.55502e+02,  0.29397e+00 /
      DATA xa3lum(gev500,tesla, 5) /  0.95241e+02 /
      DATA (xa3(i,gev500,tesla, 5),i=0,7) /
     $   0.64882e+00,  0.45462e+00,  0.27103e+02, -0.64535e+00, 
     $   0.35101e+00, -0.69467e+00,  0.33658e+02,  0.35024e+00 /
      DATA xa3lum(gev800,tesla, 5) /  0.16974e+03 /
      DATA (xa3(i,gev800,tesla, 5),i=0,7) /
     $   0.58706e+00,  0.43771e+00,  0.13422e+02, -0.63804e+00, 
     $   0.35541e+00, -0.69467e+00,  0.17528e+02,  0.43051e+00 /
      DATA xa3lum(tev1,tesla, 5) /  0.21222e+03 /
      DATA (xa3(i,tev1,tesla, 5),i=0,7) /
     $   0.55525e+00,  0.42577e+00,  0.96341e+01, -0.63587e+00, 
     $   0.36448e+00, -0.69365e+00,  0.13161e+02,  0.47715e+00 /
      DATA xa3lum(tev16,tesla, 5) /  0.34086e+03 /
      DATA (xa3(i,tev16,tesla, 5),i=0,7) /
     $   0.49058e+00,  0.42609e+00,  0.50550e+01, -0.61867e+00, 
     $   0.39225e+00, -0.68916e+00,  0.75514e+01,  0.58754e+00 /
      DATA xa3lum(gev350,tesla, 0) /  0.66447e+02 /
      DATA (xa3(i,gev350,tesla, 0),i=0,7) /
     $   0.69418e+00,  0.50553e+00,  0.48430e+02, -0.63911e+00, 
     $   0.34074e+00, -0.69533e+00,  0.55502e+02,  0.29397e+00 /
      DATA xa3lum(gev500,tesla, 0) /  0.95241e+02 /
      DATA (xa3(i,gev500,tesla, 0),i=0,7) /
     $   0.64882e+00,  0.45462e+00,  0.27103e+02, -0.64535e+00, 
     $   0.35101e+00, -0.69467e+00,  0.33658e+02,  0.35024e+00 /
      DATA xa3lum(gev800,tesla, 0) /  0.16974e+03 /
      DATA (xa3(i,gev800,tesla, 0),i=0,7) /
     $   0.58706e+00,  0.43771e+00,  0.13422e+02, -0.63804e+00, 
     $   0.35541e+00, -0.69467e+00,  0.17528e+02,  0.43051e+00 /
      DATA xa3lum(tev1,tesla, 0) /  0.21222e+03 /
      DATA (xa3(i,tev1,tesla, 0),i=0,7) /
     $   0.55525e+00,  0.42577e+00,  0.96341e+01, -0.63587e+00, 
     $   0.36448e+00, -0.69365e+00,  0.13161e+02,  0.47715e+00 /
      DATA xa3lum(tev16,tesla, 0) /  0.34086e+03 /
      DATA (xa3(i,tev16,tesla, 0),i=0,7) /
     $   0.49058e+00,  0.42609e+00,  0.50550e+01, -0.61867e+00, 
     $   0.39225e+00, -0.68916e+00,  0.75514e+01,  0.58754e+00 /
      DATA xa5lum(gev350,tesla, 1) /  -1.0 /
      DATA xa5lum(gev500,tesla, 1) /  0.33980e+03 /
      DATA (xa5(i,gev500,tesla, 1),i=0,7) /
     $   0.49808e+00,  0.54613e+00,  0.12287e+02, -0.62756e+00, 
     $   0.42817e+00, -0.69120e+00,  0.17067e+02,  0.51143e+00 /
      DATA xa5lum(gev800,tesla, 1) /  0.35936e+03 /
      DATA (xa5(i,gev800,tesla, 1),i=0,7) /
     $   0.58751e+00,  0.43128e+00,  0.13324e+02, -0.64006e+00, 
     $   0.30682e+00, -0.69235e+00,  0.16815e+02,  0.37078e+00 /
      DATA xa5lum(tev1,  tesla, 1) /  -1.0 /
      DATA xa5lum(tev16, tesla, 1) /  -1.0 /
      DATA xa5lum(gev350,tesla, 0) /  -1.0 /
      DATA xa5lum(gev500,tesla, 0) /  0.33980e+03 /
      DATA (xa5(i,gev500,tesla, 0),i=0,7) /
     $   0.49808e+00,  0.54613e+00,  0.12287e+02, -0.62756e+00, 
     $   0.42817e+00, -0.69120e+00,  0.17067e+02,  0.51143e+00 /
      DATA xa5lum(gev800,tesla, 0) /  0.35936e+03 /
      DATA (xa5(i,gev800,tesla, 0),i=0,7) /
     $   0.58751e+00,  0.43128e+00,  0.13324e+02, -0.64006e+00, 
     $   0.30682e+00, -0.69235e+00,  0.16815e+02,  0.37078e+00 /
      DATA xa5lum(tev1,  tesla, 0) /  -1.0 /
      DATA xa5lum(tev16, tesla, 0) /  -1.0 /

      IF (magic  .NE.  1904 06 16) THEN
         magic = 1904 06 16
      x1m = 0d0
      x2m = 0d0
      roots = 500d0
      acc = tesla
      ver = 0
      rev = 0
      chat = 1
      IF (xchat  .NE.  0) THEN
         CALL IRC_circem ('message', 'starting up ...')
         CALL IRC_circem ('message',
     $        '$id: circe.nw,v 1.28 1998/05/05 10:37:32 ohl exp $')
      ENDIF
      ENDIF
      IF ((xchat  .GE.  0)  .AND.  (xchat  .NE.  chat)) THEN
         chat = xchat
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1000) 'chat', chat
 1000       FORMAT ('updating `', a, ''' to ', i2)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1100) 'chat', chat
 1100       FORMAT ('keeping `', a, ''' at ', i2)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((xx1m  .GE.  0d0)  .AND.  (xx1m  .NE.  x1m)) THEN
         x1m = xx1m
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1001) 'x1min', x1m
 1001       FORMAT ('updating `', a, ''' to ', e12.4)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1101) 'x1min', x1m
 1101       FORMAT ('keeping `', a, ''' at ', e12.4)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((xx2m  .GE.  0d0)  .AND.  (xx2m  .NE.  x2m)) THEN
         x2m = xx2m
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1001) 'x2min', x2m
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1101) 'x2min', x2m
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((xroots  .GE.  0d0)  .AND. (xroots  .NE.  roots)) THEN
         roots = xroots
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1002) 'roots', roots
 1002       FORMAT ('updating `', a, ''' to ', f6.1)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1102) 'roots', roots
 1102       FORMAT ('keeping `', a, ''' at ', f6.1)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((xacc  .GE.  0)  .AND. (xacc  .NE.  acc)) THEN
         IF ((xacc  .GE.  1)  .AND.  (xacc  .LE.  nacc)) THEN
            acc = xacc
            IF (chat  .GE.  1) THEN
               WRITE (msgbuf, 1003) 'acc', accnam(acc)
 1003          FORMAT ('updating `', a, ''' to ', a)
               CALL IRC_circem ('message', msgbuf)
            ENDIF
         ELSE
            WRITE (msgbuf, 1203) xacc
 1203       FORMAT ('invalid `acc'': ', i8)
            CALL IRC_circem ('error', msgbuf)
            WRITE (msgbuf, 1103) 'acc', accnam(acc)
 1103       FORMAT ('keeping `', a, ''' at ', a)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1003) 'acc', accnam(acc)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((acc  .EQ.  sbndee)  .OR.  (acc  .EQ.  teslee)
     $     .OR.  (acc  .EQ.  xbndee)) THEN
      CALL IRC_circem ('warning', '***********************************')
      CALL IRC_circem ('warning', '* the accelerator PARAMETERs have *')
      CALL IRC_circem ('warning', '* not been ENDorsed for use in    *')
      CALL IRC_circem ('warning', '* an e-e- collider yet!!!         *')
      CALL IRC_circem ('warning', '***********************************')
      ENDIF
      IF ((xver  .GE.  0)  .AND.  (xver  .NE.  zver)) THEN
         ver = xver
         zver = xver
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1000) 'ver', ver
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1100) 'ver', ver
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      IF ((xrev  .GE.  0)  .AND. (xrev  .NE.  rev)) THEN
         rev = xrev
         IF (chat  .GE.  1) THEN
            WRITE (msgbuf, 1004) 'rev', rev
 1004       FORMAT ('updating `', a, ''' to ', i8)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ELSE
         IF (chat  .GE.  2) THEN
            WRITE (msgbuf, 1104) 'rev', rev
 1104       FORMAT ('keeping `', a, ''' at ', i8)
            CALL IRC_circem ('message', msgbuf)
         ENDIF
      ENDIF
      ver34 = 0
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      IF (rev  .EQ.  0) THEN
         r = 0
      CALL IRC_circem ('warning', '*************************************')
      CALL IRC_circem ('warning', '* this release is not official yet, *')
      CALL IRC_circem ('warning', '* DO not use it in publications!    *')
      CALL IRC_circem ('warning', '*************************************')
      ELSEIF (rev  .GE.  1997 04 17) THEN
         r = 5
      ELSEIF (rev  .GE.  1996 09 02) THEN
         r = 4
      ELSEIF (rev  .GE.  1996 07 29) THEN
         r = 3
      ELSEIF (rev  .GE.  1996 07 11) THEN
         r = 2
      ELSEIF (rev  .GE.  1996 04 01) THEN
         r = 1
      ELSEIF (rev  .LT.  1996 04 01) THEN
         CALL IRC_circem ('error',
     $        'no revision of version 1 before 96/04/01 available')
         CALL IRC_circem ('message', 'falling back to default')
         r = 1
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2000) rev, r
 2000    FORMAT ('mapping date ', i8, ' to revision index ', i2)
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      IF (roots  .EQ.  350d0) THEN
         e = gev350
      ELSEIF ((roots  .GE.  340d0)  .AND.  (roots  .LE.  370d0)) THEN
         WRITE (msgbuf, 2001) roots, 350d0
         CALL IRC_circem ('message', msgbuf)
         e = gev350
      ELSEIF (roots  .EQ.  500d0) THEN
         e = gev500
      ELSEIF ((roots  .GE.  480d0)  .AND.  (roots  .LE.  520d0)) THEN
         WRITE (msgbuf, 2001) roots, 500d0
         CALL IRC_circem ('message', msgbuf)
         e = gev500
      ELSEIF (roots  .EQ.  800d0) THEN
         e = gev800
      ELSEIF ((roots  .GE.  750d0)  .AND.  (roots  .LE.  850d0)) THEN
         WRITE (msgbuf, 2001) roots, 800d0
         CALL IRC_circem ('message', msgbuf)
         e = gev800
      ELSEIF (roots  .EQ.  1000d0) THEN
         e = tev1
      ELSEIF ((roots  .GE.  900d0)  .AND.  (roots  .LE.  1100d0)) THEN
         WRITE (msgbuf, 2001) roots, 1000d0
         CALL IRC_circem ('message', msgbuf)
         e = tev1
      ELSEIF (roots  .EQ.  1600d0) THEN
         e = tev16
      ELSEIF ((roots  .GE.  1500d0)  .AND.  (roots  .LE.  1700d0)) THEN
         WRITE (msgbuf, 2001) roots, 1600d0
         CALL IRC_circem ('message', msgbuf)
         e = tev16
      ELSE
         CALL IRC_circem ('error',
     $        'only roots = 350, 500, 800, 1000 and 1600gev available')
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (xa1lum(e,acc,r)  .LT.  0d0) THEN
         WRITE (msgbuf, 2002) roots, accnam(acc), r
         CALL IRC_circem ('error', msgbuf)
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2003) roots, e
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      lumi = xa1lum (e,acc,r)
      DO 10 i = 0, 7
         a1(i) = xa1(i,e,acc,r)
 10   CONTINUE
      ELSEIF ((ver  .EQ.  3)  .OR.  (ver  .EQ.  4)) THEN
         ver34 = ver
         ver = 1
      IF (rev  .EQ.  0) THEN
         r = 0
      CALL IRC_circem ('warning', '*************************************')
      CALL IRC_circem ('warning', '* this release is not official yet, *')
      CALL IRC_circem ('warning', '* DO not use it in publications!    *')
      CALL IRC_circem ('warning', '*************************************')
      ELSEIF (rev  .GE.  1997 04 17) THEN
         r = 5
         IF (ver34  .EQ.  3) THEN
            CALL IRC_circem ('warning', 'version 3 retired after 97/04/17')
            CALL IRC_circem ('message', 'falling back to version 4')
         ENDIF
      ELSEIF (rev  .GE.  1996 10 22) THEN
         r = ver34
         IF ((roots  .NE.  800d0)  .OR.  (acc  .NE.  tesla)) THEN
            CALL IRC_circem ('error', 'versions 3 and 4 before 97/04/17')
            CALL IRC_circem ('error', 'apply to tesla at 800 gev only')
            CALL IRC_circem ('message', 'falling back to tesla at 800gev')
            acc = tesla
            e = gev800
         ENDIF
      ELSEIF (rev  .LT.  1996 10 22) THEN
         CALL IRC_circem ('error',
     $     'no revision of versions 3 and 4 available before 96/10/22')
         CALL IRC_circem ('message', 'falling back to default')
         r = 5
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2000) rev, r
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      IF (roots  .EQ.  350d0) THEN
         e = gev350
      ELSEIF ((roots  .GE.  340d0)  .AND.  (roots  .LE.  370d0)) THEN
         WRITE (msgbuf, 2001) roots, 350d0
         CALL IRC_circem ('message', msgbuf)
         e = gev350
      ELSEIF (roots  .EQ.  500d0) THEN
         e = gev500
      ELSEIF ((roots  .GE.  480d0)  .AND.  (roots  .LE.  520d0)) THEN
         WRITE (msgbuf, 2001) roots, 500d0
         CALL IRC_circem ('message', msgbuf)
         e = gev500
      ELSEIF (roots  .EQ.  800d0) THEN
         e = gev800
      ELSEIF ((roots  .GE.  750d0)  .AND.  (roots  .LE.  850d0)) THEN
         WRITE (msgbuf, 2001) roots, 800d0
         CALL IRC_circem ('message', msgbuf)
         e = gev800
      ELSEIF (roots  .EQ.  1000d0) THEN
         e = tev1
      ELSEIF ((roots  .GE.  900d0)  .AND.  (roots  .LE.  1100d0)) THEN
         WRITE (msgbuf, 2001) roots, 1000d0
         CALL IRC_circem ('message', msgbuf)
         e = tev1
      ELSEIF (roots  .EQ.  1600d0) THEN
         e = tev16
      ELSEIF ((roots  .GE.  1500d0)  .AND.  (roots  .LE.  1700d0)) THEN
         WRITE (msgbuf, 2001) roots, 1600d0
         CALL IRC_circem ('message', msgbuf)
         e = tev16
      ELSE
         CALL IRC_circem ('error',
     $        'only roots = 350, 500, 800, 1000 and 1600gev available')
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (xa3lum(e,acc,r)  .LT.  0d0) THEN
         WRITE (msgbuf, 2002) roots, accnam(acc), r
         CALL IRC_circem ('error', msgbuf)
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2003) roots, e
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      lumi = xa3lum (e,acc,r)
      DO 20 i = 0, 7
         a1(i) = xa3(i,e,acc,r)
 20   CONTINUE
      ELSEIF (ver  .EQ.  5) THEN
         ver = 1
      IF (rev  .EQ.  0) THEN
         r = 0
      CALL IRC_circem ('warning', '*************************************')
      CALL IRC_circem ('warning', '* this release is not official yet, *')
      CALL IRC_circem ('warning', '* DO not use it in publications!    *')
      CALL IRC_circem ('warning', '*************************************')
      ELSEIF (rev  .GE.  1998 05 05) THEN
         r = 1
      ELSEIF (rev  .LT.  1998 05 05) THEN
         CALL IRC_circem ('error',
     $     'no revision of version 5 available before 98/05/05')
         CALL IRC_circem ('message', 'falling back to default')
         r = 1
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2000) rev, r
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      IF (acc  .NE.  tesla) THEN
         CALL IRC_circem ('error', 'versions 5 applies to tesla only')
         acc = tesla
      END IF
      IF (roots  .EQ.  350d0) THEN
         e = gev350
      ELSEIF ((roots  .GE.  340d0)  .AND.  (roots  .LE.  370d0)) THEN
         WRITE (msgbuf, 2001) roots, 350d0
         CALL IRC_circem ('message', msgbuf)
         e = gev350
      ELSEIF (roots  .EQ.  500d0) THEN
         e = gev500
      ELSEIF ((roots  .GE.  480d0)  .AND.  (roots  .LE.  520d0)) THEN
         WRITE (msgbuf, 2001) roots, 500d0
         CALL IRC_circem ('message', msgbuf)
         e = gev500
      ELSEIF (roots  .EQ.  800d0) THEN
         e = gev800
      ELSEIF ((roots  .GE.  750d0)  .AND.  (roots  .LE.  850d0)) THEN
         WRITE (msgbuf, 2001) roots, 800d0
         CALL IRC_circem ('message', msgbuf)
         e = gev800
      ELSEIF (roots  .EQ.  1000d0) THEN
         e = tev1
      ELSEIF ((roots  .GE.  900d0)  .AND.  (roots  .LE.  1100d0)) THEN
         WRITE (msgbuf, 2001) roots, 1000d0
         CALL IRC_circem ('message', msgbuf)
         e = tev1
      ELSEIF (roots  .EQ.  1600d0) THEN
         e = tev16
      ELSEIF ((roots  .GE.  1500d0)  .AND.  (roots  .LE.  1700d0)) THEN
         WRITE (msgbuf, 2001) roots, 1600d0
         CALL IRC_circem ('message', msgbuf)
         e = tev16
      ELSE
         CALL IRC_circem ('error',
     $        'only roots = 350, 500, 800, 1000 and 1600gev available')
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (xa5lum(e,acc,r)  .LT.  0d0) THEN
         WRITE (msgbuf, 2002) roots, accnam(acc), r
         CALL IRC_circem ('error', msgbuf)
         CALL IRC_circem ('message', 'falling back to 500gev')
         e = gev500
      ENDIF
      IF (chat  .GE.  2) THEN
         WRITE (msgbuf, 2003) roots, e
         CALL IRC_circem ('message', msgbuf)
      ENDIF
      lumi = xa5lum (e,acc,r)
      DO 30 i = 0, 7
         a1(i) = xa5(i,e,acc,r)
 30   CONTINUE
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
 2001 FORMAT ('treating energy ', f6.1, 'gev as ',  f6.1, 'gev')
 2002 FORMAT ('energy ', f6.1, ' not available for ', a6,
     $        ' in revison ', i2)
 2003 FORMAT ('mapping energy ', f6.1, ' to energy index ', i2)
      END
      DOUBLE PRECISION FUNCTION IRC_circgg (x1, x2)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION d1, d2
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IRC_circgg = -1.0
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      IF (x1  .LT.  1d0  .AND.  x1  .GT.  0d0) THEN
         d1 = a1(4) * x1**a1(5) * (1d0 - x1)**a1(6)
      ELSEIF (x1  .EQ.  -1d0) THEN
         d1 = a1(7)
      ELSE
         d1 = 0d0
      ENDIF
      IF (x2  .LT.  1d0  .AND.  x2  .GT.  0d0) THEN
         d2 = a1(4) * x2**a1(5) * (1d0 - x2)**a1(6)
      ELSEIF (x2  .EQ.  -1d0) THEN
         d2 = a1(7)
      ELSE
         d2 = 0d0
      ENDIF
      IRC_circgg = d1 * d2
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END


      SUBROUTINE IRC_GetParamee (Paramee)
*////////////////////////////////////////////////////////////////////////////////////
*//                                                                                //
*//   This is clone of circee  by S.J.                                             //
*//   Instead of function it provides 3 constants to build the function            //
*//                                                                                //
*////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION Paramee(0:3)
*
      DOUBLE PRECISION x1, x2
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION d1, d2
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
*(((((((((((((
******   d2 = a1(1) * x2**a1(2) * (1d0 - x2)**a1(3)
         Paramee(0) = a1(0)     ! Normalization of delta part
         Paramee(1) = a1(1)     ! Normalization of beta part
         Paramee(2) = a1(2)     ! Power at x=0, big one
         Paramee(3) = a1(3)     ! Power at x=1, small one
*))))))))))))))
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END
      SUBROUTINE IRC_girce (x1, x2, p1, p2, rng)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      INTEGER p1, p2
      EXTERNAL rng
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION u, w, IRC_circgg
      INTEGER electr, positr, photon
      PARAMETER (electr =  11)
      PARAMETER (positr = -11)
      PARAMETER (photon =  22)
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
 99   CONTINUE
      w = 1d0 / (1d0 + IRC_circgg (-1d0, -1d0))
      CALL rng (u)
      IF (u*u  .LE.  w) THEN
         p1 = positr
      ELSE
         p1 = photon
      ENDIF
      CALL rng (u)
      IF (u*u  .LE.  w) THEN
         p2 = electr
      ELSE
         p2 = photon
      ENDIF
      IF (ABS(p1)  .EQ.  electr) THEN
         IF (ABS(p2)  .EQ.  electr) THEN
            CALL IRC_gircee (x1, x2, rng)
         ELSEIF (p2  .EQ.  photon) THEN
            CALL IRC_girceg (x1, x2, rng)
         ENDIF
      ELSEIF (p1  .EQ.  photon) THEN
         IF (ABS(p2)  .EQ.  electr) THEN
            CALL IRC_girceg (x2, x1, rng)
         ELSEIF (p2  .EQ.  photon) THEN
            CALL IRC_gircgg (x1, x2, rng)
         ENDIF
      ENDIF
      IF ((x1  .LT.  x1m)  .OR.  (x2  .LT.  x2m)) GOTO 99
      END
      DOUBLE PRECISION FUNCTION IRC_girceb (xmin, xmax, a, b, rng)
      IMPLICIT NONE
      DOUBLE PRECISION xmin, xmax, a, b
      EXTERNAL rng
      DOUBLE PRECISION t, p, u, umin, umax, x, w
      IF ((a  .GT.  1d0)  .OR.  (b  .LT.  1d0)) THEN
         IRC_girceb = -1d0
         CALL IRC_circem ('error', 'beta-distribution expects a<=1<=b')
         RETURN
      ENDIF
      t = (1d0 - a) / (b + 1d0 - a)
      p = b*t / (b*t + a * (1d0 - t)**b)
      IF (xmin  .LE.  0d0) THEN
         umin = 0d0
      ELSEIF (xmin  .LT.  t) THEN
         umin = p * (xmin/t)**a
      ELSEIF (xmin  .EQ.  t) THEN
         umin = p
      ELSEIF (xmin  .LT.  1d0) THEN
         umin = 1d0 - (1d0 - p) * ((1d0 - xmin)/(1d0 - t))**b
      ELSE
         umin = 1d0
      ENDIF
      IF (xmax  .GE.  1d0) THEN
         umax = 1d0
      ELSEIF (xmax  .GT.  t) THEN
         umax = 1d0 - (1d0 - p) * ((1d0 - xmax)/(1d0 - t))**b
      ELSEIF (xmax  .EQ.  t) THEN
         umax = p
      ELSEIF (xmax  .GT.  0d0) THEN
         umax = p * (xmax/t)**a
      ELSE
         umax = 0d0
      ENDIF
      IF (umax  .LT.  umin) THEN
         IRC_girceb = -1d0
         RETURN
      ENDIF
 10   CONTINUE
      CALL rng (u)
      u = umin + (umax - umin) * u
      IF (u  .LE.  p) THEN
         x = t * (u/p)**(1d0/a)
         w = (1d0 - x)**(b-1d0)
      ELSE
         x = 1d0 - (1d0 - t) * ((1d0 - u)/(1d0 - p))**(1d0/b)
         w = (x/t)**(a-1d0)
      ENDIF
         CALL rng (u)
      IF (w  .LE.  u) GOTO 10
      IRC_girceb = x
      END
      SUBROUTINE IRC_gircee (x1, x2, rng)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      EXTERNAL rng
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION u, IRC_girceb
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      CALL rng (u)
      IF (u  .LE.  a1(0)) THEN
         x1 = 1d0
      ELSE
         x1 = 1d0 - IRC_girceb (0d0, 1d0-x1m, a1(3)+1d0, a1(2)+1d0, rng)
      ENDIF
      CALL rng (u)
      IF (u  .LE.  a1(0)) THEN
         x2 = 1d0
      ELSE
         x2 = 1d0 - IRC_girceb (0d0, 1d0-x2m, a1(3)+1d0, a1(2)+1d0, rng)
      ENDIF
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END
      SUBROUTINE IRC_girceg (x1, x2, rng)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      EXTERNAL rng
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION u, IRC_girceb
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      CALL rng (u)
      IF (u  .LE.  a1(0)) THEN
         x1 = 1d0
      ELSE
         x1 = 1d0 - IRC_girceb (0d0, 1d0-x1m, a1(3)+1d0, a1(2)+1d0, rng)
      ENDIF
      x2 = IRC_girceb (x2m, 1d0, a1(5)+1d0, a1(6)+1d0, rng)
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END
      SUBROUTINE IRC_gircgg (x1, x2, rng)
      IMPLICIT NONE
      DOUBLE PRECISION x1, x2
      EXTERNAL rng
      INTEGER magic0
      PARAMETER (magic0 = 1904 06 16)
      DOUBLE PRECISION x1m, x2m, roots
      COMMON /c_IRC/ x1m, x2m, roots
      DOUBLE PRECISION lumi
      COMMON /c_IRC/ lumi
      DOUBLE PRECISION a1(0:7)
      COMMON /c_IRC/ a1
      INTEGER acc, ver, rev, chat
      COMMON /c_IRC/ acc, ver, rev, chat
      INTEGER magic
      COMMON /c_IRC/ magic
      INTEGER e, r
      COMMON /c_IRC/ e, r
      SAVE /c_IRC/
      DOUBLE PRECISION IRC_girceb
      IF (magic  .NE.  magic0) THEN
         CALL IRC_circes (-1d0, -1d0, -1d0, -1, -1, -1, -1)
      ENDIF
      IF ((ver  .EQ.  1)  .OR.  (ver  .EQ.  0)) THEN
      x1 = IRC_girceb (x1m, 1d0, a1(5)+1d0, a1(6)+1d0, rng)
      x2 = IRC_girceb (x2m, 1d0, a1(5)+1d0, a1(6)+1d0, rng)
      ELSEIF (ver  .EQ.  2) THEN
      CALL IRC_circem ('panic', '*********************************')
      CALL IRC_circem ('panic', '* version 2 has been retired,   *')
      CALL IRC_circem ('panic', '* please use version 1 instead! *')
      CALL IRC_circem ('panic', '*********************************')
      RETURN
      ELSEIF (ver  .GT.  5) THEN
         CALL IRC_circem ('panic', 'versions >5 not available yet')
         RETURN
      ELSE
         CALL IRC_circem ('panic', 'version must be positive')
         RETURN
      ENDIF
      END

      SUBROUTINE KarFin_AngBre(am2,del1,del2,costhg,sinthg,dist0,dist1)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//   This routine generates photon angular distribution                                    //
*//   in the rest frame of the fermion pair.                                                //
*//   The distribution is the S-factor without mass term,                                   //
*//   i.e. without terms 2p_1p_2/(kp_1)(kp_2)                                               //
*//   Fermion mass is treated exactly!                                                      //
*//   INPUT:                                                                                //
*//       am2 = 4*massf**2/s where massf is fermion mass                                    //
*//       and s is effective mass squared of the parent fermion-pair.                       //
*//   OUTPUT:                                                                               //
*//       del1= 1-beta*cos(theta)                                                           //
*//       del2= 1+beta*cos(theta)                                                           //
*//       costhg, sinthg, cos and sin of the photon                                         //
*//       angle with respect to fermions direction                                          //
*//       dist0 = distribution generated, without m**2/(kp)**2 terms                        //
*//       dist1 = distribution with m**2/(kp)**2 terms                                      //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT  NONE
      DOUBLE PRECISION am2,del1,del2,costhg,sinthg,dist0,dist1
* Locals
      DOUBLE PRECISION  a,eps,beta
      REAL              rn(10)
*---------------------------------------------------------------------------------------------
      CALL PseuMar_MakeVec(rn,2)
      beta =SQRT(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=SQRT(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

      SUBROUTINE KarFin_BostEul(mode,qqk,PX,pvec,qvec)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Three transformations:                                                                  //
*// (1) Boost from final fermions rest frame to ferms+phots rest frame (Z frame).           //
*// (2) Euler rotation erasing memory of fermion directions.                                //
*// (3) Boost to laboratory system.                                                         //
*// Note that this transformation generates 'flat 2-body Born' in PX frame.                 //
*// This is very easy to implement.                                                         //
*// Of course, more sophisticated angular distribution can be implemented.                  //
*// In such a case BostEul will be replaced with some other transformation.                 //
*// Photon removal procedure with Piatek will work for arbitrary transformation.            //
*//                                                                                         //
*// Note that the procedure is encapsulated functionaly by generating Euler                 //
*// angles localy, during first call for mode=-1.                                           //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER mode
      DOUBLE PRECISION  pvec(4),qvec(4),qqk(4),PX(4)
      DOUBLE PRECISION  pi
      PARAMETER(pi=3.1415926535897932d0)
      REAL               rvec(10)
      DOUBLE PRECISION   the,phi,cth
*
      IF(mode .EQ. -1) THEN
* Angles for Euler rotation
         CALL PseuMar_MakeVec(rvec,2)
         cth= 1.d0 -2.d0*rvec(1)
         the= acos(cth)
         phi= 2.d0*pi*rvec(2)
      ENDIF
* And the transformations
      CALL KinLib_BostQ(  1,qqk,pvec,qvec) ! Boost along qqk
      CALL KinLib_Rotor(2,3,the,qvec,qvec) ! Rotation y-z
      CALL KinLib_Rotor(1,2,phi,qvec,qvec) ! Rotation x-y
      CALL KinLib_BostQ( -1,PX,qvec,qvec)  ! Boost to CMS
      END


      SUBROUTINE KarFin_Finalize(mode)
*     ********************************
      IMPLICIT NONE
*
      INCLUDE 'BXformat.h'
      INCLUDE 'KarFin.h'
*-----------------------------------------------------------------------------
      INTEGER mode
      DOUBLE PRECISION   avmlt,ermlt,upmlt
      DOUBLE PRECISION    WTsup, AvUnd, AvOve, ROverf, AveWt, ERela
      INTEGER  Nevtot,Nevacc,Nevneg,Nevove,Nevzer
*
      DOUBLE PRECISION   awt69,dwt69
      DOUBLE PRECISION   evove,evneg,evacc,evzer,evtot,dumm2
*----------
      DOUBLE PRECISION   awt61,dwt61
      DOUBLE PRECISION   awt62,dwt62
      DOUBLE PRECISION   awt63,dwt63
      DOUBLE PRECISION   awt65,dwt65
      DOUBLE PRECISION   awt66,dwt66
      INTEGER ntot66,nzer66
*
      INTEGER Ntot, Nacc, Nneg, Nove, Nzer
*---------------------------------------------------------------------------
*
      IF(m_KeyFSR .EQ. 0) RETURN
* no printout for mode=1
      IF(mode .EQ. 1) RETURN
* no printout if there was no generation
      IF(m_Nevgen .EQ. 0) RETURN
*============================================================================
      CALL  GLK_Mprint(m_idyfs+64)
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'KarFin Finalize    START'
      WRITE(m_out,bxl1i) m_NevGen,   ' generated events  ','nevgen','a2'

      CALL  GLK_MgetAve(m_idyfs+61,awt61,dwt61,WtSup)
      CALL  GLK_MgetAve(m_idyfs+62,awt62,dwt62,WtSup)
      CALL  GLK_MgetAve(m_idyfs+63,awt63,dwt63,WtSup)

      WRITE(m_out,bxl2f) awt61,dwt61,' kinematics, smin  ','wt1   ','a5'
      WRITE(m_out,bxl2f) awt62,dwt62,' jacobian          ','wt2   ','a6'
      WRITE(m_out,bxl2f) awt63,dwt63,' photon ang. dist. ','wt3   ','a7'
*
* Details on MASS WEIGHT REARRANGENMENT, and PHOTON REMOVAL
*
      CALL  GLK_MgetAve(m_idyfs+64,avmlt,ermlt,upmlt)
      CALL  GLK_MgetAve(m_idyfs+65,awt65,dwt65,WtSup)

      CALL GLK_MgetAll(m_idyfs+66,
     $     awt66,dwt66, WtSup, AvUnd, AvOve,
     $     ntot66,Nacc,Nneg,Nove,nzer66)
*
      WRITE(m_out,bxtxt) '    ON MASS WEIGHTS     '
      WRITE(m_out,bxl2f) awt66,dwt66,'removal wgt wtrem  ','     ',' b1'
      WRITE(m_out,bxl1i) ntot66,     'no. of raw events  ','     ',' b2'
      WRITE(m_out,bxl1i) nzer66,     'wt6=0      events  ','     ',' b3'
      WRITE(m_out,bxl2f) awt65,dwt65,'control wgt wctrl  ','     ',' b4'
      WRITE(m_out,bxl1i) m_MarTot,   'marked photons     ','MarTot','a5'
      WRITE(m_out,bxl1g) m_emin,     'emin               ','     ',' b6'
      WRITE(m_out,bxl1g) m_delta,    'delta              ','     ',' b7'
      WRITE(m_out,bxl1f) avmlt,      'raw ph. multipl.   ','     ',' b8'
      WRITE(m_out,bxl1f) upmlt,      'Highest phot. mult.','     ',' b9'
      WRITE(m_out,bxtxt) 'YFSfin Finalize    END  '
      WRITE(m_out,bxclo)
* test histograms
*[[      CALL GLK_Print(m_idyfs+20)
*[[      CALL gopera(m_idyfs+31,'/',m_idyfs+32,m_idyfs+33,1d0,1d0)
*[[      CALL GLK_Print(m_idyfs+33)
*=========================================================================
*-----------------------------------------------------------------------
*.........................output window a...............................
      CALL GLK_MgetAve(m_idyfs+60, avmlt, ermlt, upmlt)
      CALL GLK_MgetAve(m_idyfs+69,awt69,dwt69,WtSup)


* general information on weights
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '    KarFin Finalize     '
      WRITE(m_out,bxl1i) m_NevGen,   ' generated events  ','nevgen','a2'
      WRITE(m_out,bxl2f) awt69,dwt69,' general weight    ','wt    ','a1'
      WRITE(m_out,bxl1f) avmlt,      ' aver. ph. multi.  ','avmlt ','a3'
      WRITE(m_out,bxclo)
      END                       !!!KarFin_Finalize!!!

      SUBROUTINE KarFin_GetFermions(qf1,qf2)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      DOUBLE PRECISION   qf1(4),qf2(4)
      INTEGER k
*---------------
      DO k=1,4
         qf1(k) = m_q1(k)
         qf2(k) = m_q2(k)
      ENDDO
      END


      SUBROUTINE KarFin_GetIsFSR(IsFSR)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER IsFSR
      IsFSR= m_IsFSR
      END

      SUBROUTINE KarFin_GetKeyPia(KeyPia)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER KeyPia
      KeyPia= m_KeyPia
      END

      SUBROUTINE KarFin_GetNphot(nphot)     
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get photon multiplicity                                                 //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER nphot
*
      nphot = m_nphot
      END

      SUBROUTINE KarFin_GetPhoton1(iphot,phot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   get i-th photon momentum                                                //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER iphot
      DOUBLE PRECISION   phot(4)
      INTEGER k
*
      DO k=1,4
         phot(k) = m_phot(iphot,k)
      ENDDO
      END

      SUBROUTINE KarFin_GetPhotons(nphot,sphot)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      INTEGER nphot
      DOUBLE PRECISION   sphot(m_npmx,4)
      INTEGER j,k
*-------------
      nphot = m_nphot
      DO j=1,m_nphot
         DO k=1,4
            sphot(j,k) = m_phot(j,k)
         ENDDO
      ENDDO
      END


      SUBROUTINE KarFin_GetSudakov(nphot,yfin,zfin)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      INTEGER nphot
      DOUBLE PRECISION   yfin(*),zfin(*)
      INTEGER i
*-------------
      nphot = m_nphot
      DO i=1,m_nphot
         yfin(i) = m_yfin(i)
         zfin(i) = m_zfin(i)
      ENDDO
      END

      SUBROUTINE KarFin_GetSudakov1(iphot,y,z)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get sudakovs of i-th photon                                             //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER iphot
      DOUBLE PRECISION   y,z
*
      y = m_yfin(iphot)
      z = m_zfin(iphot)
      END

      SUBROUTINE KarFin_GetSvarQ(SvarQ)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      DOUBLE PRECISION   SvarQ
*---------------
      SvarQ = ( m_q1(4)+m_q2(4) )**2 -( m_q1(3)+m_q2(3) )**2 
     $       -( m_q1(2)+m_q2(2) )**2 -( m_q1(1)+m_q2(1) )**2
      END

      SUBROUTINE KarFin_GetYFS_IR(YFS_IR)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Get finite part of YFS form-factor                                     //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      DOUBLE PRECISION    YFS_IR
*------------------
      YFS_IR = m_YFS_IR
      END

      SUBROUTINE KarFin_GetYFSkon(YFSkon)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Get finite part of YFS form-factor                                     //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      DOUBLE PRECISION    YFSkon
*------------------
      YFSkon = m_YFSkon
      END

*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                     Pseudo-CLASS  KarFin                                        //
*//                                                                                 //
*//   Purpose:                                                                      //
*//   Top level  Monte-Carlo event generator for FSR radiadion.                     //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE KarFin_Initialize(xpar_input)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Initialization of input and internal variables                               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION   xpar_input(*)
      DOUBLE PRECISION   vvmin,cmsene,delfac
*
      m_Nevgen = 0
      m_MarTot = 0
      m_out    = xpar_input(4)
      m_idyfs  = xpar_input(8)
      m_nmax   = xpar_input(19)/2
      
      m_KeyFSR = xpar_input(21)
      m_KeyPia = xpar_input(22)
      m_MltFSR = xpar_input(24)
      m_KeyQSR = xpar_input(29)
      m_alfinv = xpar_input(30)

      m_IsFSR  = m_KeyFSR ! initial value only

      vvmin     = xpar_input(16)
      cmsene    = xpar_input( 1)
      m_emin    = cmsene/2d0*vvmin
      m_MasPhot =1d-60 ! dummy photon mass
     
      delfac   = xpar_input(18)
      m_delta  = vvmin*delfac

      CALL KK2f_GetXenph(m_Xenph)

      m_WtMass = 1d0

      CALL GLK_Mbook(m_idyfs+60,'KarLud: phot. mult. raw $', 1, 1d0*m_nmax)
      CALL GLK_Mbook(m_idyfs+69,'KarLud: totat weight    $', 1, 2d0)

      IF(m_KeyFSR .EQ. 0) RETURN

      CALL GLK_Mbook(m_idyfs+64,'YFSfin: photon raw multiplicity$', 10, 0.2d0*m_nmax)
      CALL GLK_Mbook(m_idyfs+61,'YFSfin: wt1, kinematics $', 1, 2d0)
      CALL GLK_Mbook(m_idyfs+62,'YFSfin: wt2, jacobian   $', 1, 2d0)
      CALL GLK_Mbook(m_idyfs+63,'YFSfin: wt3, mass       $', 1, 2d0)
      CALL GLK_Mbook(m_idyfs+65,'YFSfin: piatek, wtctrl  $', 1, 2d0)
      CALL GLK_Mbook(m_idyfs+66,'YFSfin: piatek, wtrem   $', 1, 2d0)

      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'KarFin Initialize  START'
      WRITE(m_out,bxl1i) m_KeyFSR,  'FSR radiation on/off','KeyFSR','a1'
      WRITE(m_out,bxl1i) m_KeyQSR,  'radiation from quark','KeyQSR','a2'
      WRITE(m_out,bxl1i) m_KeyPia,  'removal    switch   ','KeyPia','a3'
      WRITE(m_out,bxl1g) delfac,    'infrared cut FACTOR ','delfac','a4'
      WRITE(m_out,bxl1g) m_delta,   'infrared cut itself ','delta ','a5'
      WRITE(m_out,bxl1g) m_emin ,   'EminCMS for removal ','[GeV] ','a6'
      WRITE(m_out,bxl1i) m_nmax,    'Max. photon mult.   ','nmax  ','a7'
      WRITE(m_out,bxtxt) 'KarFin Initialize  END  '
      WRITE(m_out,bxclo)

      END                       !!!KarFin_Initialize!!!


      SUBROUTINE KarFin_Kinf1(PX,q1,q2,q1c,q2c,nphot,phot,phsu)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Transforms final fermions and photons from QMS through Z-frame to CMS.                  //
*// Random Euler rotation is applied in the intermediate PX frame (Z frame)                 //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      DOUBLE PRECISION   PX(4),phot(100,4),phsu(4),q1(4),q2(4),q1c(4),q2c(4)
      DOUBLE PRECISION   ph(4),qqk(4)
      INTEGER i,k,nphot

* Calculate total final state four-momentum ferms+phots
      DO k=1,4
         qqk(k)=q1(k)+q2(k)+phsu(k)
      ENDDO
* Transform fermions
      CALL KarFin_BostEul(-1,qqk,PX,q1,q1) ! <-- Initialize Euler angles!!!
      CALL KarFin_BostEul( 0,qqk,PX,q2,q2)
      CALL KarFin_BostEul( 0,qqk,PX,q1c,q1c)
      CALL KarFin_BostEul( 0,qqk,PX,q2c,q2c)
      CALL KarFin_BostEul( 0,qqk,PX,phsu,phsu)
* Transform photons
      DO i=1,nphot
         DO k=1,4
            ph(k)=phot(i,k)
         ENDDO
         CALL KarFin_BostEul( 0,qqk,PX,ph,ph)
         DO k=1,4
            phot(i,k)= ph(k)
         ENDDO
      ENDDO
      END


      SUBROUTINE KarFin_Make(PX,amfi1,amfi2,CharSq,wt)
*/////////////////////////////////////////////////////////////////////////////
* INPUT:
*     amfi1,2 = final masses, may change event per event (resonances)
*     CharSq  = charge squared
*     PX     = 4-momentum of the entire FSR system (fermions+photons)
*     KFfin     = final state fermion KF code
* OUTPUT:
*     qf1,2   = final state charged particle momenta
*     nphot   = FSR photon multiplicity
*     phot    = list of FSR photons
*     phsu    = total FSR photon 4-momentum
*     wt      = Crude mc weight
*/////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION   CharSq,amfi1,amfi2
      DOUBLE PRECISION   PX(4)
      DOUBLE PRECISION   wt,WtFin,wtt
      INTEGER KFfin
      INTEGER k,j
*----------------------------------------------------------------------------
*
* Initialize momenta to zero
      DO k=1,4
         m_q1(k)   =0d0
         m_q2(k)   =0d0
         m_phsu(k) =0d0
      ENDDO
      m_nphot=0
      DO j=1,m_npmx
         DO k=1,4
            m_phot(j,k) =0d0
         ENDDO
      ENDDO
*
*     Generate photons and fermions in the rest frame of ferms Q=qf1+qf2
*     and transform to LAB system, 
*     PX=qf1+qf2+phsu is total momentum of the entire FSR system,
*     as seen from the LAB system.
*
      m_IsFSR = m_KeyFSR
      CALL KarLud_GetKFfin(KFfin)
* check for quarks KeyQSR flag
      IF( ABS(KFfin) .LT. 10) m_IsFSR = m_IsFSR*m_KeyQSR
*-----------------------------------------------------------------------
      IF(m_IsFSR .EQ. 1) THEN
         m_NevGen = m_NevGen+1  ! Only bremsstrahlung counts!!!
         CALL KarFin_YFSfin( PX,  amfi1, amfi2,  CharSq,  WtFin)
      ELSE
*-----------------------------------------------------------------------
*     No final state bremss, fermion momenta defined in Z frame
         CALL KinLib_phspc2( PX,amfi1,amfi2,m_q1,m_q2,wtt)
         WtFin = 1d0
         m_nphot  = 0
      ENDIF
*-----------------------------------------------------------------------
*     main weight
      wt=WtFin

      CALL GLK_Mfill(m_idyfs+69, wt,  1d0)
      CALL GLK_Mfill(m_idyfs+60, 1d0*m_nphot,  1d0)
* =============================================
      END                       !!!KarFin_Make!!!


      SUBROUTINE KarFin_Piatek( Mas1,Mas2,CharSq,WtMlist, Wt3)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// Written CERN, piatek, 22 sept. 1989  (S.J.)                                             //
*// This routine calculates YFS form-factor and optionaly                                   //
*// removes some of soft photons (below Emin in CMS), calculating compensating weight.      //
*// Note the action of this routine is not Loretnz invariant !!!!                           //
*// Input:                                                                                  //
*//     KeyPia   = 0, NO removal of photons below Emin                                      //
*//              = 1, with removal of photons below Emin                                    //
*//     Mas1,2  = fermion masses                                                           //
*//     delta    = infrared cut-off in generation (dimensionless)                           //
*//     CharSq   = FSR charge squared                                                       //
*//     alfinv   = 1/alpha_QED                                                              //
*//     qf1,2    = fermion momenta                                                          //
*//     qf1c,2c  = ghost fermion momenta in crude S-factor                                  //
*//     phsu     = sum of photon momenta                                                    //
*//     phot     = list of photon momenta                                                   //
*//     WtMlist  = list of mass-weights for all photons                                     //
*// OUTPUT:                                                                                 //
*//     WtRem    = mass-weight of removed photons, for tests                                //
*//              = 1,  for KeyPia=0                                                         //
*//     WtMas    = mass-weight for all photons, see comments below,                         //
*//                the MOST IMPORTANT OUTPUT of Piatek !!!                                  //
*//     WtCtrl    = control-weight for remowed photons, for tests                           //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*// REMARK on r1, r2:                                                                       //
*// They are ghost-fermion momenta in the definition of the crude                           //
*// distribution, i.e. truncated S-factor is r1*r2/(k*r1)/(k*r2)                            //
*// as generated in the crude MC.                                                           //
*// In QMS frame 4-momenta r1, r2 have the same energy                                      //
*// and directions as q1, q2                                                                //
*// but different masses Mas1c, Mas2c and therefore longer 3-momenta.                       //
*// They are usefull because we may use the same analytical                                 //
*// expression for the exact Breal and  for 'crude Breal'                                   //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      DOUBLE PRECISION    Mas1,Mas2,CharSq,WtMlist(100),Wt3
*
      DOUBLE PRECISION  pi
      PARAMETER(pi=3.1415926535897932d0)
      INTEGER  i,j,k,nph
      DOUBLE PRECISION    QQ(4),PX(4)
      DOUBLE PRECISION    amc2,Mass,Delta1,Epsi1,wtm1,wtm2
      DOUBLE PRECISION    svarX,svarQ,QQk,q1q2,betc
      DOUBLE PRECISION    DelB,DelB2,DelB2u,DelVol,DelYFS
      DOUBLE PRECISION    BVR_A
      DOUBLE PRECISION    Eq1,Eq2,EminQ,EQQ,r1r2,Mas1c,Mas2c
      DOUBLE PRECISION    BtiXcru,BtiQcru,BtiQexa,BtiXexa
      DOUBLE PRECISION    BVR_Btildc,BVR_Btilda
      DOUBLE PRECISION    WtRem,WtCtrl
      DOUBLE PRECISION    VoluMC, YFS_IR, YFSkon
      DOUBLE PRECISION    alfpi,alfch,alfCR
*-----------------------------
      INTEGER  iCont
      DATA     iCont /0/
*-----------------------------
      WtCtrl =1d0
      WtRem  =1d0
      alfpi = 1d0/pi/m_AlfInv
      alfch = alfpi*CharSq
      alfCR = alfch* m_Xenph
      Mass = MIN(Mas1,Mas2)
      DO k=1,4
         PX(k) = m_q1(k)+m_q2(k) +m_phsu(k)
         QQ(k) = m_q1(k)+m_q2(k)
      ENDDO
      svarX = PX(4)**2-PX(3)**2 -PX(2)**2 -PX(1)**2
      svarQ = QQ(4)**2-QQ(3)**2 -QQ(2)**2 -QQ(1)**2
      EQQ   = 0.5d0*SQRT(svarQ)
      q1q2  =  m_q1(4)*m_q2(4) -m_q1(3)*m_q2(3) -m_q1(2)*m_q2(2) -m_q1(1)*m_q2(1)
      r1r2  =  m_r1(4)*m_r2(4) -m_r1(3)*m_r2(3) -m_r1(2)*m_r2(2) -m_r1(1)*m_r2(1)
      QQk   =  QQ(4)*m_phsu(4) -QQ(3)*m_phsu(3) -QQ(2)*m_phsu(2) -QQ(1)*m_phsu(1)
      Eq1   = (svarQ +Mas1**2 -Mas2**2)/(2*SQRT(svarQ))
      Eq2   = (svarQ -Mas1**2 +Mas2**2)/(2*SQRT(svarQ))
* Delta1 and Epsi1 are cutoffs located in YFS formfactor
* Note that xfact=(1+2*QQk/svarQ) is EXACTLY the same as in KarFin_YFSfin
* Delta1 = 2*Emin/sqrt(s'), where Emin is in QMS
      Delta1 = m_Delta*(1+ 2*QQk/svarQ)
      Epsi1  = DSQRT(m_Emin**2/m_q1(4)/m_q2(4))
      EminQ  = EQQ*Delta1
* The total phase space integral for crude x-section and YFS formfactor cut-off dependend part
* Note that delta is a lower limit on y-z-variables in crude generation
      amc2  =  4d0*Mass**2/svarX
      betc  =  DSQRT(1d0-amc2)
*     ===========================================================================================
      VoluMC =  2d0*alfCR *(1d0+betc**2)/(2d0*betc)* DLOG((1d0+betc)**2/amc2) *DLOG(1/m_Delta)
      YFS_IR = -2d0*alfch *(     q1q2 *BVR_A( q1q2, Mas1,Mas2) -1d0  )        *DLOG(1/Delta1)
* YFSkon is delegated/exported to QED3 (unused here).
      YFSkon =  1/4d0 *2*alfch*(DLOG(svarQ/Mass**2)-1) + alfch*( -.5d0  +pi**2/3d0) ! Mass<<sqrt(s)
*     ===========================================================================================
* Corrections necessary for photon remooval scenario (now default!)
      Mas1c  = Mass*SQRT(svarQ/svarX)
      Mas2c  = Mass*SQRT(svarQ/svarX)
      BtiXcru= BVR_Btildc(alfCR, r1r2, m_r1(4),m_r2(4), Mas1c,Mas2c, m_Emin, m_MasPhot) !crude
      BtiQcru= BVR_Btildc(alfCR, r1r2, EQQ,    EQQ,     Mas1c,Mas2c, EminQ,  m_MasPhot) !crude
      BtiXexa= BVR_Btilda(alfch, q1q2, m_q1(4),m_q2(4), Mas1, Mas2,  m_Emin, m_MasPhot) !exact
      BtiQexa= BVR_Btilda(alfch, q1q2, Eq1,    Eq2,     Mas1 ,Mas2,  EminQ,  m_MasPhot) !exact
      DelVol = BtiXcru -BtiQcru   ! positive
      DelYFS = BtiXexa -BtiQexa   ! positive
      DelB2  = -DelVol+DelYFS
*------ oldies ------
* Total QMS-CMS, result should be negative ( delta<<epsilon )
      DelB  =   VoluMC +YFS_IR
* Ultrarelativistic (small mass) old version is the following:
      DelB2u = -2*alfch*(DLOG(svarX/svarQ)+1) *dlog(Epsi1/Delta1)
* The average mass-weight for removed photon = exp(DelB2)
* It can be calculated analyticaly as a  ratio of YFS formfactors
* On the other hand, it is checked by MC, see control weight WtCtrl.
*********************************************************************************************
*      IF(iCont.LE.10 ) THEN
*         IF((1-svarQ/svarX) .GT. 0.1d0) THEN
*            iCont = iCont+1
*((( Approximate version of DelB2 without contr. with A4 terms for tests (surpisingly good!!!)
*      DelB2w = -2*alfch*(  (1d0+betc**2)/(2d0*betc)* DLOG((1d0+betc)**2/amc2) 
*     $                    -( q1q2*BVR_A(q1q2,Mas1,Mas2) -1d0 )
*     $                  ) *DLOG(Epsi1/Delta1)
*         WRITE(*,'(a,5f20.10)') 'piatek: ',1-svarQ/svarX,DelB2,DelB2u/DelB2,DelB2w/DelB2
*)))
*            VoluMC2 = 
*     $            BVR_Btildc(alfch, r1r2, EQQ,EQQ,  Mas1c,Mas2c, EQQ,          m_MasPhot)
*     $           -BVR_Btildc(alfch, r1r2, EQQ,EQQ,  Mas1c,Mas2c, EQQ*m_Delta,  m_MasPhot)
*            WRITE(*,'(a,5f20.10)') '###Piatek: ',1-svarQ/svarX, VoluMC2,VoluMC,VoluMC2/VoluMC
*         ENDIF
*      ENDIF
*********************************************************************************************
*--------------------------
      wtm1=1d0
      wtm2=1d0
* mass weight below and above Emin calculated separately
      DO i=1,m_nphot
         IF(m_phot(i,4) .LT. m_Emin) THEN
            wtm1=wtm1*WtMlist(i) /m_Xenph
            IF(wtm1 .LE. 1d-90) wtm1=0d0
         ELSE
            wtm2=wtm2*WtMlist(i) /m_Xenph
            IF(wtm2 .LE. 1d-90) wtm2=0d0
         ENDIF
      ENDDO
*------------------------------------------------------------------------------
* Control weight - its average should be =1 within statist. error!
      WtCtrl =wtm1*exp(-DelB2)
      IF(m_KeyPia .EQ. 0) THEN
         IF( ABS(DelB) .GT. 100d0 ) WRITE(*,*) '#### KarFin_Piatek: DelB= ',DelB
         WtRem    = 1d0
         m_WtMass = wtm1*wtm2      !!! <--removal OFF
         m_VoluMC = EXP( VoluMC)
         m_YFS_IR = EXP( YFS_IR)
         m_YFSkon = EXP( YFSkon)   !!! <--finite part of YFS formfactor
*        =====================================
      ELSE
* Optional removal of photons below Emin from the record
* in such a case WtMas includes exp(belb2)= <wt3> for removed ph.
         nph=m_nphot
         DO j=m_nphot,1,-1
            IF(m_phot(j,4) .LT. m_Emin) THEN
               DO i=j+1,nph
                  DO k=1,4
                     m_phot(i-1,k)=m_phot(i,k)
                  ENDDO
               ENDDO
               nph=nph-1
            ENDIF
         ENDDO
* Correction of Alex Read, probably obsolete because KarFin_Merge is also corrected
         DO j=nph+1,m_nphot
            DO k=1,4
               m_phot(j,k) = 0.d0
            ENDDO
         ENDDO
         m_nphot=nph
* Important to remember: EXP(YFS_IR +YFSkon)         = full YFS formfactor in QMS
*                        EXP(YFS_IR +YFSkon +DelYFS) = full YFS formfactor in CMS
         WtRem    = wtm1
         m_WtMass = wtm2           !!! <--removal ON
         m_VoluMC = EXP(VoluMC -DelVol)
         m_YFS_IR = EXP(YFS_IR +DelYFS)
* YFSkon is delegated/exported to QED3 (unused here).
         m_YFSkon = EXP(YFSkon)    !!! <--finite part of YFS formfactor in QMS frame!!!
*        ===============================================
      ENDIF
*     **********************************
      Wt3 = m_WtMass *m_VoluMC *m_YFS_IR
*     **********************************
* Monitoring
      CALL GLK_Mfill(m_idyfs+65,       WtCtrl ,1d0)
      CALL GLK_Mfill(m_idyfs+66,       WtRem  ,1d0)
*
      END                       !!! KarFin_Piatek !!!



      SUBROUTINE KarFin_PoissGen(average,nmax,mult,rr)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//  Last corr. nov. 91                                                                     //
*//   This generates photon multipl. nphot according to poisson distr.                      //
*//   Input:  average = average multiplicity                                                //
*//           nmax  = maximum multiplicity                                                  //
*//   Output: mult = generated multiplicity                                                 //
*//           rr(1:100) list of ordered uniform random numbers,                             //
*//           a byproduct result, to be eventually used for some further                    //
*//           purpose (i.e.  generation of photon energies).                                //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE   PRECISION average,  rr(*)
      INTEGER  nmax,mult
* locals
      REAL                 rvec(10)
      DOUBLE   PRECISION   sum,y
      INTEGER              nn,it,nfail
      DATA nfail/0/
*---------------------------------------------------------------------------------------------
      IF( average.LE.0 ) GOTO 900
 50   nn=0
      sum=0d0
      DO it=1,nmax
         CALL PseuMar_MakeVec(rvec,1)
         y= log(rvec(1))
         sum=sum+y
         nn=nn+1
         rr(nn)=sum/(-average)
         IF(sum .LT. -average) GOTO 130
      ENDDO
      nfail=nfail+1
      IF(nfail .GT. 10) GOTO 900
      GOTO 50
 130  mult=nn-1
      RETURN
 900  CONTINUE
      WRITE(*,*) ' STOP in KarFin_PoissGen: nmax,average= ',nmax,average
      STOP
      END

      SUBROUTINE KarFin_Print(iev,ie1,ie2)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// Prints out four momenta of FINAL state                                   //
*// and the serial number of event iev on unit m_out                         //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      INTEGER  iev,ie1,ie2
      DOUBLE PRECISION    sphum(4)
      CHARACTER*8 txt
      DOUBLE PRECISION    sum(4),ams,amph,amf1,amf2
      INTEGER  i,k
*--------------------------------------------------------
      IF( (iev .GE. ie1) .AND. (iev .LE. ie2) ) THEN
         txt = '  KarFin '
         WRITE(m_out,*) 
     $        '=========== ',txt,' ======================>',iev
         amf1 = m_q1(4)**2-m_q1(3)**2-m_q1(2)**2-m_q1(1)**2
         amf1 = sqrt(abs(amf1))
         amf2 = m_q2(4)**2-m_q2(3)**2-m_q2(2)**2-m_q2(1)**2
         amf2 = sqrt(abs(amf2))
         WRITE(m_out,3100) 'qf1',(  m_q1(  k),k=1,4),amf1
         WRITE(m_out,3100) 'qf2',(  m_q2(  k),k=1,4),amf2
         DO i=1,m_nphot
            amph = m_phot(i,4)**2-m_phot(i,3)**2 -m_phot(i,2)**2-m_phot(i,1)**2
            amph = sqrt(abs(amph))
            WRITE(m_out,3100) 'pho',(m_phot(i,k),k=1,4),amph
         ENDDO
         DO k=1,4
            sum(k)=m_q1(k)+m_q2(k)
         ENDDO
         DO i=1,m_nphot
            DO k=1,4
               sum(k)=sum(k)+m_phot(i,k)
            ENDDO
         ENDDO
         ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
         ams = sqrt(abs(ams))
         WRITE(m_out,3100) 'sum',(  sum(  k),k=1,4),ams
      ENDIF
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE KarFin_WtMass(WtMass)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      DOUBLE PRECISION   WtMass
*
      WtMass = m_WtMass
      END


      SUBROUTINE KarFin_YFSfin( PX,Mas1,Mas2,CharSq,WtFin)
*/////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                         //
*//  Simulates final state bremsstrahlung out of pair of charged patricles.                 //
*//  (algorithm of 11-th March 1989, by S. Jadach)                                          //
*//  INPUT  :                                                                               //
*//      MltFSR  = normaly set to zero, otherwise enforces photon                           //
*//                multiplicity to be exactly equal MltFSR (special tests)                  //
*//      KeyPia  = photon removal switch                                                    //
*//      PX     = 4-momentum of FSR system as seen from LAB system                          //
*//      Mas1,2 = masses of the final charged pair                                          //
*//      delta   = lower energy bound (dimensionless)                                       //
*//      emin    = lower energy bound (GeV) in LAB system                                   //
*//      CharSq  = final state charge squared                                               //
*//      alfinv  = 1/alpha_QED                                                              //
*//  OUTPUT :                                                                               //
*//      qf1,2    = final fermion four momentum (GeV)                                       //
*//      nphot   = photon multiplicity                                                      //
*//      phot    = photon four momenta (GeV) in cms                                         //
*//      phsu    = sum of photon momenta                                                    //
*//      ygr,zet = Sudakov variables                                                        //
*//      WtFin   = MC weight at this stage                                                  //
*//      martot  = control variable, no of marked photons                                   //
*//  OTHER:                                                                                 //
*//      Mark    = marks on photons CLOSE to lower energy bound                             //
*//      qf1c,2c = ficticious final fermion four momenta for crude S-factor                 //
*//      wt1    = the weight - phase space limits for very hard phot.                       //
*//      wt2    = the weight - translation jacobian.                                        //
*//      wt3    = the weight - single final mass-weight                                     //
*//      wtm    = the list/matrix of mass-weights.                                          //
*//                                                                                         //
*/////////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
*
      DOUBLE PRECISION  pi
      PARAMETER(pi=3.1415926535897932d0)
*
      DOUBLE PRECISION   PX(4)

      DOUBLE PRECISION   WtMlist(100)
      DOUBLE PRECISION   rr(100),xk(100),cgx(100),sgx(100)
      DOUBLE PRECISION   dis0(100)
      REAL               rvec(100)
      INTEGER Mark(100)
*
      INTEGER i,j,k
      DOUBLE PRECISION  phi,cg,sg,eta1,eta2,uu,ul,del1,del2
      DOUBLE PRECISION  yy,xmk2,ener,smini
      DOUBLE PRECISION  wt1,wt2,wt3,WtFin
      DOUBLE PRECISION  betc,etc1,etc2,amd1
      DOUBLE PRECISION  average,Mas1,Mas2,svar,amfin,sprim,qmsene,amcru
      DOUBLE PRECISION  alf1,dis1,amc2,CharSq,xsum
      DOUBLE PRECISION  dl1,dl2,betn,xfact,gamf2,dist1,amd2
*-----------------------------------------------------------------------
      m_NevGen = m_NevGen + 1
*
      alf1 = 1d0/pi/m_alfinv
      wt1   =1d0
      wt2   =1d0
      wt3   =1d0
*-----------------------------------------------------------------------
      svar = PX(4)**2-PX(3)**2-PX(2)**2-PX(1)**2
      amfin = MIN(Mas1,Mas2)
      amc2  = 4.d0*amfin**2/svar  ! overvalued svar for crude
      betc  = sqrt(1d0-amc2)      ! overvalued svar for crude
      DO i=1,100
         rr(i)=0.d0
         Mark(i)=0
      ENDDO
      DO k=1,4
         m_phsu(k)=0.d0
      ENDDO
      DO i=1,100
         m_yfin(i)=0
         m_zfin(i)=0
         DO k=1,4
            m_phot(i,k)=0.d0
         ENDDO
      ENDDO
*-----------------------------------------------------------------------
*  generate photon multiplicity, average = average multiplicity (crude)
*-----------------------------------------------------------------------
      gamf2 = CharSq*alf1 *(1+betc**2)/betc *dlog((1d0+betc)**2/amc2)
      average = gamf2*dlog(1/m_delta)
      average = average *m_Xenph
    5 CONTINUE
      CALL KarFin_PoissGen(average,m_nmax,m_nphot,rr)
** This is for tests of program at fixed multiplicity (advanc. users)
      IF((m_MltFSR .NE. 0) .AND. (m_nphot .NE. m_MltFSR)) GOTO 5
**
      IF(m_nphot .EQ. 0) THEN
         sprim=svar
      ELSE
*-----------------------------------------------------------------------
*     begin with photon energy
         xsum=0.d0
         DO  i=1,m_nphot
            xk(i)=m_delta**rr(i)
            IF(xk(i) .LT. sqrt(10.d0)*m_delta) Mark(i)=1
            xsum=xsum+xk(i)
         ENDDO
         IF(xsum .GE. 1.d0) GOTO 900
         xfact=1d0/(1.d0-xsum)
         DO i=1,m_nphot
            xk(i)=xk(i)*xfact
         ENDDO
         CALL PseuMar_MakeVec(rvec,m_nphot)
         DO i=1,m_nphot
*-----------------------------------------------------------------------
*     simplified photon angular distribution,
*     s'->s and m**2/(kp)**2 dropped
*     cg=cos(theta) and sg=sin(theta) memorized to avoid rounding err.
            CALL KarFin_AngBre(amc2,dl1,dl2,cg,sg,dis0(i),dis1)
*-----------------------------------------------------------------------
*     define photon momenta (in units of sqrt(s')/2 )
            phi=2.d0*pi*rvec(i)
            m_phot(i,1)=xk(i)*sg*cos(phi)
            m_phot(i,2)=xk(i)*sg*sin(phi)
            m_phot(i,3)=xk(i)*cg
            m_phot(i,4)=xk(i)
            DO k=1,4
               m_phsu(k)=m_phsu(k)+m_phot(i,k)
            ENDDO
            cgx(i)=cg
            sgx(i)=sg
         ENDDO
*-----------------------------------------------------------------------
*     determine rescaling factor and s', wt2 is dilatation jacobian
         xmk2 = m_phsu(4)**2-m_phsu(3)**2-m_phsu(2)**2-m_phsu(1)**2
         yy   = 1.d0/(1.d0 +m_phsu(4) +xmk2/4.d0 )
         wt2  = yy*(1.d0+m_phsu(4))
         sprim= svar*yy
*-----------------------------------------------------------------------
*     reject events with too hard photons
         smini= (Mas1+Mas2)**2
         IF(sprim .LT. smini) GOTO 900
*-----------------------------------------------------------------------
*     Recsale properly all photon momenta
*-----------------------------------------------------------------------
         ener = sqrt(sprim)/2.d0
         DO  k=1,4
            m_phsu(k)= m_phsu(k)*ener
            DO  i=1,m_nphot
               m_phot(i,k)=m_phot(i,k)*ener
            ENDDO
         ENDDO
      ENDIF ! m_nphot
*-----------------------------------------------------------------------
*     final fermion momenta
*-----------------------------------------------------------------------
      amcru  = amfin*SQRT(sprim/svar)
      qmsene = SQRT(sprim)
      ener   = qmsene/2d0
      CALL KinLib_givpair(qmsene,Mas1,Mas2,m_q1, m_q2 ,betn,eta1,eta2)! real
      CALL KinLib_givpair(qmsene,amcru,amcru,m_r1,m_r2,betc,etc1,etc2)! ghost
*-----------------------------------------------------------------------
*     Mass weight for theta distribution
*-----------------------------------------------------------------------
*     Mass weight compensates for s'->s and droping terms -m**2/(k.q)**2
*     Care is taken of machine rounding errors.
*     del1 and del2 RECALCULATED out of angles sgx(i),cgx(i)
*     with TRUE sprim, using EXACT formulas
      amd1 = (Mas1/ener)**2
      amd2 = (Mas2/ener)**2
      DO i=1,m_nphot
         IF( cgx(i) .GT. 0.d0 ) THEN
            del1 = amd1/(eta1+betn) +betn*sgx(i)**2/(1+cgx(i))
            del2 = eta2 +betn*cgx(i)
         ELSE
            del1 = eta1 -betn*cgx(i)
            del2 = amd2/(eta2+betn) +betn*sgx(i)**2/(1-cgx(i))
         ENDIF
         dist1=1d0/(del1*del2) 
     $        *(1d0 -(amd1+amd2)/4d0
     $                   -amd2/4d0*del1/del2 -amd1/4d0*del2/del1)
         WtMlist(i)= dist1/dis0(i)
         IF(WtMlist(i) .LT.  1.d-90) WtMlist(i)= 0.d0
***********
** dist1x below is exactly the same as dist1 but for small masses is 
** prone to severe rounding errors (in contrast to dist1 used above)
*         IF((1-sprim/svar) .gt. 0.01d0) THEN
*            qf1qf2= m_q1(4)*m_q2(4) -m_q1(3)*m_q2(3) -m_q1(2)*m_q2(2) -m_q1(1)*m_q2(1)
*            qf1k = m_q1(4)*m_phot(i,4)-m_q1(3)*m_phot(i,3) -m_q1(2)*m_phot(i,2)-m_q1(1)*m_phot(i,1)
*            qf2k = m_q2(4)*m_phot(i,4)-m_q2(3)*m_phot(i,3) -m_q2(2)*m_phot(i,2)-m_q2(1)*m_phot(i,1)
*            dist1x = 2*qf1qf2/qf1k/qf2k -Mas1**2/qf1k**2 -Mas2**2/qf2k**2
*            dist1x = dist1x/4d0*m_phot(i,4)**2
*            WRITE(*,'(a,5f20.10)') '===>: ',dist1x/dist1
*         ENDIF
***********
*     finaly define Sudakov variables
         m_yfin(i)=del1*xk(i)/2d0
         m_zfin(i)=del2*xk(i)/2d0
      ENDDO
*-----------------------------------------------------------------------
* Transform from rest frame of Q=qf1+qf2 down to CMS=Lab,
* through inetrmediate rest frame of PX=qf1+qf2+phsu.
*-----------------------------------------------------------------------
      CALL KarFin_Kinf1(PX,m_q1,m_q2,m_r1,m_r2,m_nphot,m_phot,m_phsu)
*-----------------------------------------------------------------------
* Calculate YFS formfactor (cut-off dependent part) and mass weights
* Optionally removing photons below emin from the list
      CALL KarFin_Piatek( Mas1,Mas2,CharSq,WtMlist, wt3)
*-----------------------------------------------------------------------
* Monitoring weights and other control variables,
* Non-essential for the MC generation itself.
      CALL GLK_Mfill(m_idyfs+64, 1d0*m_nphot  ,1d0)
*[[[      uu = 1d0-sprim/svar
*[[[      CALL GLK_Fil1(m_idyfs+31, uu  ,wctrl)
*[[[      CALL GLK_Fil1(m_idyfs+32, uu  ,  1d0)
* marked photons
      IF(m_nphot .GE. 1) THEN
         DO i=1,m_nphot
*[[[            ul= log10(m_phot(i,4)/m_emin)
*[[[            IF(Mark(i) .EQ. 1)   CALL GLK_Fil1(m_idyfs+20,   ul,1.d0)
            IF(Mark(i) .EQ. 1)   m_MarTot=m_MarTot+1
         ENDDO
      ENDIF
*-----------------------------------------------------------------------
* Final Monitoring weights
 1000 CONTINUE
      WtFin = wt1*wt2*wt3
      CALL GLK_Mfill(m_idyfs+61,     wt1  ,1d0)
      CALL GLK_Mfill(m_idyfs+62,     wt2  ,1d0)
      CALL GLK_Mfill(m_idyfs+63,     wt3  ,1d0)
*-----------------------------------------------------------------------
      RETURN
*-----------------------------------------------------------------------
* Event outside phase space (too hard photon)
 900  CONTINUE
      wt1   = 0.d0
      wt2   = 1.d0
      wt3   = 1.d0
      m_nphot = 0
      GOTO 1000   !!!! a litle bit clumsy jump
*
      END                       !!!KarFin_YFSfin!!!


      SUBROUTINE KarFin_ZBoostAll(exe)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   performs z-boost on all momenta of the event                            //
*//   this z-boost corresponds to beamstrahlung or beamspread                 //
*//   and is done at the very end of generation, after m.el. calculation      //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarFin.h'
      DOUBLE PRECISION  exe
      INTEGER           j,k
      DOUBLE PRECISION  ph(4)
*
      IF( exe.EQ. 1d0) RETURN
      CALL KinLib_Boost(3,exe,m_q1,m_q1)
      CALL KinLib_Boost(3,exe,m_q2,m_q2)
      CALL KinLib_Boost(3,exe,m_phsu,m_phsu)
      DO j=1,m_nphot
         DO k=1,4
            ph(k) = m_phot(j,k)
         ENDDO
         CALL KinLib_Boost(3,exe,ph,ph)
         DO k=1,4
            m_phot(j,k) = ph(k)
         ENDDO
      ENDDO
      END

      SUBROUTINE KarLud_AngBre(am2,del1,del2,costhg,sinthg,dist0,dist1)
*//////////////////////////////////////////////////////////////////////////////
*// This routine generates photon angular distribution                       //
*// in the rest frame of the fermion pair.                                   //
*// The distribution is the S-factor without mass term,                      //
*// i.e. without terms 2p_1p_2/(kp_1)(kp_2)                                  //
*// Fermion mass is treated exactly!                                         //
*// INPUT:                                                                   //
*//     am2 = 4*massf**2/s where massf is fermion mass                       //
*//     and s is effective mass squared of the parent fermion-pair.          //
*// OUTPUT:                                                                  //
*//     del1= 1-beta*cos(theta)                                              //
*//     del2= 1+beta*cos(theta)                                              //
*//     costhg, sinthg, cos and sin of the photon                            //
*//     angle with respect to fermions direction                             //
*//     dist0 = distribution generated, without m**2/(kp)**2 terms           //
*//     dist1 = distribution with m**2/(kp)**2 terms                         //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  am2,del1,del2,costhg,sinthg,dist0,dist1
* locals
      DOUBLE PRECISION  a,eps,beta
      REAL              rn(10)
*------------------------------------------------------------------------------
      CALL PseuMar_MakeVec(rn,2)
      beta =sqrt(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=sqrt(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

      SUBROUTINE KarLud_Finalize(mode, XKarlud, KError)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Calculates crude xsection  XKarlud  and prints out final statistics     //
*//                                                                           //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'KarLud.h'
      INTEGER  mode
      DOUBLE PRECISION    XKarlud,  KError
      DOUBLE PRECISION    ISRcru,  ISRerr, ISRbest
      DOUBLE PRECISION    averwt,  evtot,  evacc,  evneg, evove
      DOUBLE PRECISION    wt_ISR,  erkrl,  ErRela
      DOUBLE PRECISION    ddr,     ddv,    erkr,   xskr
      DOUBLE PRECISION    WTsup, AvUnd, AvOve, ROverf
      INTEGER  Nevtot,Nevacc,Nevneg,Nevove,Nevzer
*///////////////////////////////////////////////////////////////////////////////
*//   Normal case, ISR is ON                                                  //
*///////////////////////////////////////////////////////////////////////////////
      IF(m_KeyISR .EQ. 1) THEN
* Important part for NORMALIZATION in KK2f
         IF(     m_KeyFix .EQ. 0 ) THEN
            CALL Vesk1_Finalize(ISRbest,ErRela,ISRcru)
            ISRerr   = ISRbest*ErRela
            XKarlud  = ISRcru                      ! true crude
            KError   = 0d0
         ELSEIF( m_KeyFix .EQ. 1 ) THEN
            CALL VegasA_GetIntCrude(ISRcru)
            CALL VegasA_Finalize(ISRbest,ErRela)
            ISRerr   = ISRbest*ErRela
            XKarlud  = ISRcru                      ! true crude
            KError   = 0d0
         ELSEIF( m_KeyFix .EQ. 2 ) THEN
            CALL BStra_GetXCrude(ISRcru)
            CALL BStra_Finalize(ISRbest,ErRela)
            ISRerr   = ISRbest*ErRela
            XKarlud  = ISRbest                     ! crude from internal loop
            KError   = ISRerr                      ! and its error
         ELSEIF( m_KeyFix .EQ. -1 ) THEN
            ISRcru   = m_XCrude
            ISRbest  = m_XCrude
            ISRerr   = 0d0
            XKarlud  = ISRcru                     ! artificial crude
            KError   = 0d0
         ELSE
            WRITE(*,*) ' ++++ KarLud_Finalize: wrong KeyFix=',m_KeyFix
            STOP
         ENDIF
*---------------------------------------------------------------
* The rest is miscelaneous information
* no printout for mode = 1
         IF(mode .EQ. 2) THEN
            WRITE(m_out,bxope)
            WRITE(m_out,bxtxt) '     KarLud  final  report     '
            WRITE(m_out,bxl1i) m_NevGen,         'total no of events','nevtot ','=='
            WRITE(m_out,bxl1f) ISRcru,           'ISRcru  [R]       ','ISRcru ','=='
            WRITE(m_out,bxl2f) ISRbest,ISRerr,   'ISRbest [R],ISRerr','ISRbest','=='
            WRITE(m_out,bxl1g) XKarlud,          'XKarlud [R]       ','XKarlud','=='
            WRITE(m_out,bxl1g) KError,           'KError  [R]       ','KError ','=='
            WRITE(m_out,bxclo)
*     Principal weight
            CALL GLK_MgetAll(m_idyfs+59, wt_ISR,erkrl, WtSup, AvUnd, AvOve,
     $                                Nevtot,Nevacc,Nevneg,Nevove,Nevzer)
            WRITE(m_out,bxope)
            WRITE(m_out,bxtxt) '  Report on wt_ISR of KarLud   '
            WRITE(m_out,bxl1i) nevtot,          'total no of events ','nevtot ','=='
            WRITE(m_out,bxl1i) nevneg,          'wt<0        events ','nevneg ','=='
            WRITE(m_out,bxl2f) wt_ISR,erkrl,    '<wt>               ','wt_ISR ','=='
            xskr   = XKarlud*wt_ISR
            erkr   = xskr*erkrl
            WRITE(m_out,bxl2f) xskr,erkr,       'sigma of KarLud [R]','xskarl ','=='
            WRITE(m_out,bxclo)
*     Vesko weight (miscelaneous)
            IF(     m_KeyFix .EQ. 0 ) THEN
               CALL GLK_MgetAve(m_idyfs+58,AverWt,ErRela,WtSup)
               WRITE(m_out,bxope)
               WRITE(m_out,bxl2f) averwt,errela,    'Average WT of Vesk1','AVesk1','=='
               WRITE(m_out,bxl2f) m_xcgaus,m_ErGaus,'xs_est gauss    [R]','xcgaus','=='
               ddv    = ISRbest/m_xcgaus-1d0
               ddr    = ErRela + 1d-6
               WRITE(m_out,bxl2f) ddv,ddr,          'xcve/xcgs-1        ','      ','=='
               WRITE(m_out,bxclo)
               CALL  GLK_Mprint(m_idyfs+58)
            ENDIF
         ENDIF
*///////////////////////////////////////////////////////////////////////////////
*//   Normal case, ISR is OFF, Born only                                      //
*///////////////////////////////////////////////////////////////////////////////
      ELSEIF( (m_KeyISR .EQ. 0) .OR. (m_KeyISR .EQ. 2) ) THEN
         XKarlud    = m_XCrude
         KError     = 0d0   
         IF(mode .EQ. 2) THEN
            WRITE(m_out,bxope)
            WRITE(m_out,bxl1i) m_NevGen,   'total no of events','nevtot ','a0'
            WRITE(m_out,bxl1f) XKarlud,    'xs_crude  Born     ','xborn ','  '
            WRITE(m_out,bxclo)
         ENDIF
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',m_KeyISR
         STOP
      ENDIF
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '     KarLud_Finalize END  <<<     '
      WRITE(m_out,bxclo)
      END  ! KarLud_Finalize

      SUBROUTINE KarLud_GetBeams(p1,p2)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   In the case of beamstrahlung these are beams AFTER beamstrahlung        //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION   p1(4),p2(4)
      INTEGER k
*
      DO k=1,4
         p1(k) = m_p1(k)
         p2(k) = m_p2(k)
      ENDDO
      END

      SUBROUTINE KarLud_GetBeasts(p1,p2)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   In the case of beamstrahlung these are photons of the  beamstrahlung    //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION   p1(*),p2(*)
      INTEGER k
*-----------------------------------------
      DO k=1,4
         p1(k) = 0d0
         p2(k) = 0d0
      ENDDO
      p1(4) =  0.5d0*m_CMSene*m_x1
      p1(3) =  p1(4)
      p2(4) =  0.5d0*m_CMSene*m_x2
      p2(3) = -p2(4)
      END

      SUBROUTINE KarLud_GetExe(Exe)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION  Exe
*
      Exe = m_Exe
      END

      SUBROUTINE KarLud_GetKFfin(KFfin)     
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get photon multiplicity                                                 //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER KFfin
*
      KFfin = m_KFfin
      END

      SUBROUTINE KarLud_GetNphot(nphot)     
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get photon multiplicity                                                 //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER nphot
*
      nphot = m_nphot
      END

      SUBROUTINE KarLud_GetPhoton1(iphot,phot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   get i-th photon momentum                                                //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER iphot
      DOUBLE PRECISION   phot(4)
      INTEGER k
*
      DO k=1,4
         phot(k) = m_sphot(iphot,k)
      ENDDO
      END


      SUBROUTINE KarLud_GetPhotons(nphot,sphot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get all photons                                                         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER nphot
      DOUBLE PRECISION   sphot(m_npmx,4)
      INTEGER j,k
*
      nphot = m_nphot
      DO j=1,m_nphot
         DO k=1,4
            sphot(j,k) = m_sphot(j,k)
         ENDDO
      ENDDO
      END

      SUBROUTINE KarLud_GetPX(PX)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION   PX(4)
      INTEGER k
*
      DO k=1,4
         PX(k) = m_PX(k)
      ENDDO
      END

      SUBROUTINE KarLud_GetSudakov(nphot,yini,zini)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get all Sudakovs                                                        //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER nphot
      DOUBLE PRECISION   yini(*),zini(*)
      INTEGER i
*
      nphot = m_nphot
      DO i=1,m_nphot
         yini(i) = m_yini(i)
         zini(i) = m_zini(i)
      ENDDO
      END


      SUBROUTINE KarLud_GetSudakov1(iphot,y,z)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Get sudakovs of i-th photon                                             //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER iphot
      DOUBLE PRECISION   y,z
*
      y = m_yini(iphot)
      z = m_zini(iphot)
      END

      SUBROUTINE KarLud_Getvvmax(vvmax)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION  vvmax
*
      vvmax = m_vvmax
      END

      SUBROUTINE KarLud_GetVVxx(vv,x1,x2)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION  vv,x1,x2
*
      vv = m_vv
      x1 = m_x1
      x2 = m_x2
      END


      SUBROUTINE KarLud_GetXXXene(XXXene)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION  XXXene
*
      XXXene = m_XXXene
      END


*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  KarFin                                //
*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Pseudo-CLASS  KarLud                                 //
*//                                                                          //
*//   Purpose:                                                               //
*//   Top level  Monte-Carlo event generator for ISR radiadion.              //
*//   Administrates directly generation of v=1-s'/s                          //
*//   and optionaly of beamstrahlung variables x1 and x2.                    //
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////


      SUBROUTINE KarLud_Initialize(xpar_input,XCrude)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION   xpar_input(*)
      DOUBLE PRECISION   XCrude, prec, Mathlib_Gauss
      INTEGER            ke, KFbeam, n, KeyGrid
      DOUBLE PRECISION   a,b,result,error
      DOUBLE PRECISION   BornV_Crude
      DOUBLE PRECISION   xborn,xdel
      DOUBLE PRECISION   IRCroots
      INTEGER            IRCacc,   IRCver,   IRCdate,   IRCxchat
      DOUBLE PRECISION   BornV_RhoVesko1
      EXTERNAL           BornV_RhoVesko1
* debug
      DOUBLE PRECISION   dbg_xsec,dbg_err,dbg_AveWt,dbg_RatWt,dbg_XCrude
*--------------------------------------------------------------------------------
      m_nevgen =  0
      m_nmax   =  xpar_input(19)/2
      m_idyfs  =  xpar_input(8)
*
      m_CMSene = xpar_input( 1)  ! initial value, to be preserved
      m_XXXene = m_CMSene        ! initial value, to be variable
      m_DelEne = xpar_input( 2)
      m_exe    = 1d0             ! no z-boost for default exe=1 
      m_out    = xpar_input( 4)
      m_vvmin  = xpar_input(16)
      m_vvmax  = xpar_input(17)
      m_KeyZet = xpar_input(501)
      m_KeyISR = xpar_input(20)
      m_MltISR = xpar_input(23)
      m_KeyFix = xpar_input(25)
      m_KeyWtm = xpar_input(26)
      m_alfinv = xpar_input(30)

      CALL KK2f_GetXenph(m_Xenph)

      m_WtMass = 1d0
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'KarLud_Initialize START'
      WRITE(m_out,bxl1f) m_CMSene,   'CMS energy average','CMSene','=='
      WRITE(m_out,bxl1f) m_DelEne,   'Beam energy spread','DelEne','=='
      WRITE(m_out,bxl1i) m_KeyISR,   'ISR on/off switch ','KeyISR','=='
      WRITE(m_out,bxl1i) m_KeyFix,   'Type of ISR       ','KeyFix','=='
      WRITE(m_out,bxl1i) m_KeyZet,   'Elect_weak switch ','KeyZet','=='
      WRITE(m_out,bxl1i) m_MltISR,   'Fixed nphot mult. ','MltISR','=='
      WRITE(m_out,bxl1i) m_nmax,     'Max. photon mult. ','nmax  ','=='
      WRITE(m_out,bxclo)
*//////////////////////////////////////////////////////////////////////////////////////
*//     Check on validity of input                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IF(m_DelEne.GT.2d0) THEN
         WRITE(m_out,*) ' ### STOP in KarLud_Initialize: DelEne too big ', m_DelEne
         STOP
      ENDIF
      IF( (m_DelEne.NE.0d0) .AND. (m_KeyFix.EQ.2) ) THEN
         WRITE(m_out,*) ' ### STOP in KarLud_Initialize:'
         WRITE(m_out,*) ' Beamsstrahlung and Beam energy spread together not safe, not tested'
         STOP
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
      KFbeam = 11           ! KF=11 is electron
      ke = 500+10*KFbeam
      m_amel   = xpar_input(ke+6)
*
      IF(m_KeyISR .EQ. 2) THEN
*        YFSini2 is only for very special tests, no harm if deleted
         CALL YFSini2_Initialize(m_amel, m_alfinv, m_vvmin, m_nmax, m_out, m_KeyWtm, m_MltISR)
      ENDIF
*
      xborn  = BornV_Crude(0d0)

      IF(m_KeyISR .EQ. 1) THEN
         IF(m_KeyFix .EQ. 0) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   This is normal ISR with help of Vesko1 routine, initialization                 //
*//////////////////////////////////////////////////////////////////////////////////////

            CALL Vesk1_Initialize(BornV_RhoVesko1,m_XCrude)

            XCrude    = m_XCrude
         ELSEIF(m_KeyFix .EQ. 1) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   This is normal ISR with help of Vegas routine, initialization                  //
*//////////////////////////////////////////////////////////////////////////////////////
            CALL VegasA_Initialize                  ! basic initialization
            CALL VegasA_SetnDim(     1)             ! redefine nDim
*****       CALL VegasA_SetPriLev(  -1)             ! printout level
            CALL VegasA_SetnCall( 100000)           ! maximum number of function calls
            CALL VegasA_SetIterMax(  5)             ! maximum iterations
            CALL VegasA_SetAccur(   0d0)            ! requested accuracy
            CALL VegasA_Make(BornV_RhoVesko1)       ! make grid and calculate integral
*****       CALL VegasA_GetIntegral(m_XCrude,error) ! get best integral value
            CALL VegasA_PreGenerate                 ! prepeare generation
            CALL VegasA_GetIntCrude(m_XCrude)       ! get crude normalization for MC
            XCrude    = m_XCrude
         ELSEIF(m_KeyFix .EQ. 2) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   Initialization of Circe package of Thorsten Ohl                                //
*//   and of the beamstrahlung module Bstra                                          //
*//////////////////////////////////////////////////////////////////////////////////////
            IRCroots = xpar_input(71)
            IRCacc   = xpar_input(72)
            IRCver   = xpar_input(73)
            IRCdate  = xpar_input(74)
            IRCxchat = xpar_input(75)
            CALL IRC_circes(0d0, 0d0, IRCroots, IRCacc, IRCver, IRCdate, IRCxchat)
            KeyGrid  = xpar_input(76)
            CALL BStra_Initialize(KeyGrid,m_XCrude)         ! beamstrahlung initialization
         ELSEIF(m_KeyFix .EQ. -1) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//  The case of ISR swithed off, Born process                                       //
*//////////////////////////////////////////////////////////////////////////////////////
            m_XCrude = BornV_RhoVesko1(2d0)
            XCrude   = m_XCrude
            m_xcgaus = m_XCrude
            WRITE(m_out,bxl1f) m_XCrude,'xs_crude  BornV_Rho','xcvesk','  '
         ELSE
            WRITE(m_out,*) ' +++++ STOP in KarLud_Initialize, KeyFix = ', m_KeyFix
            STOP
         ENDIF
*     Miscelaneous x-check on x-section from vesko1
         IF(m_KeyFix .GE. 0 ) THEN

            a = 0d0
            b = 1d0
            prec = 1d-5
            m_xcgaus = Mathlib_Gauss(BornV_RhoVesko1,a,b, prec)
***         CALL Mathlib_GausJad(BornV_RhoVesko1,a,b, -prec, m_xcgaus) ! rather slow
            m_ErGaus   = m_xcgaus*prec
            xdel = m_XCrude/m_xcgaus-1
            WRITE(m_out,bxl1f) m_XCrude,'xs_crude  vesko    ','xcvesk','  '
            WRITE(m_out,bxl1f) m_xcgaus,'xs_crude  gauss    ','xcgaus','  '
            WRITE(m_out,bxl1f) xdel  ,  'xcvesk/xcgaus-1    ','      ','  '
         ENDIF
      ELSEIF( (m_KeyISR .EQ. 0) .OR. (m_KeyISR .EQ. 2) ) THEN
         XCrude    = xborn
         m_XCrude  = xborn
         WRITE(m_out,bxl1f) m_XCrude,'xs_crude  Born     ','xborn ','  '
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',m_KeyISR
         STOP
      ENDIF
*
      CALL GLK_Mbook(m_idyfs+58,'KarLud, wtvesk  $', 100, 1.20d0)
      CALL GLK_Mbook(m_idyfs+59,'KarLud, wt_ISR  $', 1, 2.d0)
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'KarLud_Initialize END '
      WRITE(m_out,bxclo)
      END                       ! KarLud_Initialize

      SUBROUTINE KarLud_Make(PX,wt_ISR)
*/////////////////////////////////////////////////////////////////////////////////
*//                                                                             //
*// OUTPUT:                                                                     //
*//     PX       4-momentum left after photon emission (PX=q1+q2)               //
*//     m_p1,2   beams 4-momenta                                                //
*//     m_q1,2   final state 4-momenta                                          //
*//     m_nphot   photon multiplicity                                           //
*//     m_sphot   photon 4-momenta                                              //
*//     m_sphum   sum of photon 4-momenta                                       //
*//     m_yini,zini Sudakov variables from low level MC generator               //
*//                                                                             //
*/////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION    PX(4)
*---------------------
      DOUBLE PRECISION    BornV_GetMass
      DOUBLE PRECISION    BornV_RhoVesko1
      EXTERNAL            BornV_RhoVesko1
      DOUBLE PRECISION    et1,et2
      DOUBLE PRECISION    amfi1,amfi2, x,y, bt1, dummy
      DOUBLE PRECISION    wtt, wt_ISR
      DOUBLE PRECISION    ph(4)
      DOUBLE PRECISION    EBeam1,EBeam2
      INTEGER             k,j 
*
      m_NevGen =  m_NevGen+1
      m_exe    = 1d0
      m_XXXene = m_CMSene
      IF(m_KeyISR .EQ. 1) THEN
*///////////////////////////////////////////////////////////////////////////////////
*//    Machine Gaussian Beam Spread  << 1GeV                                      //
*// Weight from Vesko/Vegas has Z peak at wrong v, at rescaled prosition          //
*// However, rho of Bornv is called once again by Vesko/Vegas for modified XXXene //
*// and Z position will be at the correct position in vv.                         //
*// The weight in model is not modifying Z position any more, see KK2f.           //
*///////////////////////////////////////////////////////////////////////////////////
      CALL KarLud_SmearBeams
      CALL BornV_SetCMSene(m_XXXene)
*-------------------------------------------------------------
*     Generate vv = 1-s'/s
         IF(    m_KeyFix .EQ. 0) THEN
            CALL Vesk1_Make( BornV_RhoVesko1, x,y, m_WtBasic)
         ELSEIF(m_KeyFix .EQ. 1) THEN
            CALL VegasA_Generate(BornV_RhoVesko1)
            CALL VegasA_GetMCwt( m_WtBasic)
         ELSEIF(m_KeyFix .EQ. 2) THEN
            CALL BStra_Make(m_vv, m_x1, m_x2, m_WtBasic)
*           Redefine CMS energy and boost
            m_XXXene = m_XXXene*SQRT((1d0-m_x1)*(1d0-m_x2))
            m_exe    = m_exe   *SQRT((1d0-m_x1)/(1d0-m_x2))
         ELSEIF(m_KeyFix .EQ.-1) THEN
            m_WtBasic=1d0
            dummy = BornV_RhoVesko1(2d0)
         ELSE          
            WRITE(*,*) ' ++++ KarLud: wrong KeyFix=',m_KeyFix
            STOP
         ENDIF
         CALL BornV_GetVV(m_vv)
*        Low-level multiphoton generator
         CALL KarLud_YFSini(m_XXXene, m_vv, PX, m_WtIni)
         wt_ISR = m_WtBasic*m_WtIni
*-------------------------------------------------------------
      ELSEIF(m_KeyISR .EQ. 2) THEN
*     This is for special tests with flat x-section
         CALL YFSini2_Make(m_XXXene, m_vv, m_p1,m_p2,
     $        m_nphot,m_sphot,m_sphum,m_yini,m_zini,PX,m_WtIni)
         wt_ISR = m_WtIni
*-------------------------------------------------------------
      ELSEIF(m_KeyISR .EQ. 0) THEN
         CALL KinLib_givpair(m_XXXene,m_amel,m_amel,m_p1,m_p2,bt1,et1,et2)
         DO k=1,4
            PX(k) = m_p1(k)+m_p2(k)
         ENDDO
         m_nphot   = 0
         wt_ISR  = 1d0
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',m_KeyISR
         STOP
      ENDIF
*-------------------------------------------------------------
* Generate flavour KF and set exclusive mode
* Note that GenKF uses table of xsections m_Xborn defined in 
* the Vesk1_Make( BornV_RhoVesko1,...) or predefined during Initialization
      IF(wt_ISR .NE. 0d0)  THEN
         CALL MBrA_GenKF(m_KFfin,m_Wt_KF)
         wt_ISR = wt_ISR *m_Wt_KF
      ENDIF
      CALL KK2f_SetOneY(255,m_Wt_KF) ! Pure debug
*-------------------------------------------------------------
      IF(wt_ISR .EQ. 0d0 ) THEN
*     Set momenta to zero for WT=0 events
         DO k=1,4
            m_q1(k) =0d0
            m_q2(k) =0d0
            m_sphum(k)=0d0
         ENDDO
         m_nphot=0
         DO j=1,m_npmx
            DO k=1,4
               m_sphot(j,k)=0d0
            ENDDO
         ENDDO
         m_KFfin = 0
      ELSE
*     Define final fermion momenta (NOT used in case of FSR)
*     PX is the four-momentum of final state fermion pair in CMS
         amfi1  =BornV_GetMass(m_KFfin)
         amfi2  =BornV_GetMass(m_KFfin)
         CALL KinLib_phspc2( PX,amfi1,amfi2,m_q1,m_q2,wtt)
      ENDIF
*-------------------------------------------------------------
*     Final weight administration
      CALL GLK_Mfill(m_idyfs+58, m_WtBasic,  1d0)
      CALL GLK_Mfill(m_idyfs+59, wt_ISR, 1d0)
* store PX for further use through getter
      DO k=1,4
         m_PX(k) = PX(k)
      ENDDO
*-------------------------------------------------------------
      CALL KK2f_SetOneY(203,Wt_ISR)    ! Pure temporary debug
      CALL KK2f_SetOneY(250,m_WtBasic) ! Pure temporary debug
      CALL KK2f_SetOneY(251,m_WtIni)   ! Pure temporary debug
      END

      SUBROUTINE KarLud_PoissGen(average,nmax,mult,rr)
*//////////////////////////////////////////////////////////////////////////////
*// Last corr. nov. 91                                                       //
*// This generates photon multipl. nphot according to poisson distr.         //
*// Input:  average = average multiplicity                                   //
*//         nmax  = maximum multiplicity                                     //
*// Output: mult = generated multiplicity                                    //
*//         rr(1:100) list of ordered uniform random numbers,                //
*//         a byproduct result, to be eventually used for some further       //
*//         purpose (i.e.  generation of photon energies).                   //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER           nmax,mult
      DOUBLE PRECISION  rr(*),average
* locals
      DOUBLE PRECISION  sum,y
      INTEGER           it,nfail,nn
      REAL              rvec(10)
      DATA nfail/0/
*------------------------------------------------------------------------------
 50   nn=0
      sum=0d0
      DO it=1,nmax
         CALL PseuMar_MakeVec(rvec,1)
         y= log(rvec(1))
         sum=sum+y
         nn=nn+1
         rr(nn)=sum/(-average)
         IF(sum .LT. -average) GOTO 130
      ENDDO
      nfail=nfail+1
      IF(nfail .GT. 100) GOTO 900
      GOTO 50
 130  mult=nn-1
      RETURN
 900  WRITE(*,*) ' poissg: to small nmax ',nmax
      STOP
      END


      SUBROUTINE KarLud_Print(iev,ie1,ie2)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//  Prints out four momenta of INITIAL state                                 //
*//  and the serial number of event iev on unit m_out                         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER  iev,ie1,ie2
      CHARACTER*8 txt
      DOUBLE PRECISION    sum(4),ams,amph,amf1,amf2
      INTEGER  i,k
*--------------------------------------------------------
      IF( (iev .GE. ie1) .AND. (iev .LE. ie2) ) THEN
         txt = '  KarLud '
         WRITE(m_out,*) 
     $        '=========== ',txt,' ======================>',iev
         amf1 = m_p1(4)**2-m_p1(3)**2-m_p1(2)**2-m_p1(1)**2
         amf1 = sqrt(abs(amf1))
         amf2 = m_p2(4)**2-m_p2(3)**2-m_p2(2)**2-m_p2(1)**2
         amf2 = sqrt(abs(amf2))
         WRITE(m_out,3100) 'p1',(  m_p1(  k),k=1,4),amf1
         WRITE(m_out,3100) 'p2',(  m_p2(  k),k=1,4),amf2
         DO i=1,m_nphot
            amph = m_sphot(i,4)**2-m_sphot(i,3)**2
     $            -m_sphot(i,2)**2-m_sphot(i,1)**2
            amph = sqrt(abs(amph))
            WRITE(m_out,3100) 'pho',(m_sphot(i,k),k=1,4),amph
         ENDDO
         DO k=1,4
            sum(k)=m_p1(k)+m_p2(k)
         ENDDO
         DO i=1,m_nphot
            DO k=1,4
               sum(k)=sum(k)-m_sphot(i,k)
            ENDDO
         ENDDO
         ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
         ams = sqrt(abs(ams))
         WRITE(m_out,3100) 'sum',(  sum(  k),k=1,4),ams
      ENDIF
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE KarLud_Print1(nout)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//  Prints out four momenta of INITIAL state                                 //
*//  and the serial number of event iev on unit m_out                         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      INTEGER  nout
      CHARACTER*8 txt
      DOUBLE PRECISION    sum(4),ams,amph,amf1,amf2
      INTEGER  i,k
*--------------------------------------------------------
      txt = '  KarLud '
      WRITE(nout,*) '=========== ',txt,' ======================',m_NevGen
      amf1 = m_p1(4)**2-m_p1(3)**2-m_p1(2)**2-m_p1(1)**2
      amf1 = sqrt(abs(amf1))
      amf2 = m_p2(4)**2-m_p2(3)**2-m_p2(2)**2-m_p2(1)**2
      amf2 = sqrt(abs(amf2))
      WRITE(nout,3100) 'p1',(  m_p1(  k),k=1,4),amf1
      WRITE(nout,3100) 'p2',(  m_p2(  k),k=1,4),amf2
      DO i=1,m_nphot
         amph = m_sphot(i,4)**2-m_sphot(i,3)**2
     $        -m_sphot(i,2)**2-m_sphot(i,1)**2
         amph = sqrt(abs(amph))
         WRITE(nout,3100) 'pho',(m_sphot(i,k),k=1,4),amph
      ENDDO
      DO k=1,4
         sum(k)=m_p1(k)+m_p2(k)
      ENDDO
      DO i=1,m_nphot
         DO k=1,4
            sum(k)=sum(k)-m_sphot(i,k)
         ENDDO
      ENDDO
      ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
      ams = sqrt(abs(ams))
      WRITE(nout,3100) 'sum',(  sum(  k),k=1,4),ams
 3100 FORMAT(1x,a3,1x,5f20.14)
      END


      SUBROUTINE KarLud_SmearBeams
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Beam spread is implemented here                                              //
*//    This is correct only for very small spread < 2GeV                            //
*//    Should not be used together with beamstrahlung, lack of tests.               //
*//                                                                                 //
*//    Distribution is Gauss(X)=N*EXP( (X-CMSene/2)**2/(2*DelEne**2) )              //
*//    that is DelEne is proper dispersion in  Ebeam (not in CMSene).               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION   pi
      PARAMETER(         pi=3.1415926535897932d0)
      DOUBLE PRECISION   EBeam1,EBeam2
      DOUBLE PRECISION   R
      REAL               rvec(10)
*------------------------------------------------------------------------------------
      IF( m_DelEne.EQ.0d0 ) RETURN
      CALL PseuMar_MakeVec(rvec,2)
      R  = m_DelEne*SQRT(-2d0*LOG(rvec(1)))
      EBeam1 = m_CMSene/2 + R*cos(2*pi*rvec(2))
      EBeam2 = m_CMSene/2 + R*sin(2*pi*rvec(2))
      EBeam1 = MAX(EBeam1,0d0)
      EBeam2 = MAX(EBeam2,0d0)
* Redefine CMS energy after smearing of the beam energies!
      m_XXXene = 2*SQRT(EBeam1*EBeam2)
      m_exe    = m_exe*SQRT(EBeam1/EBeam2)
      END                       ! KarLud_SmearBeams

      SUBROUTINE KarLud_WtMass(WtMass)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION   WtMass
*
      WtMass = m_WtMass
      END


      SUBROUTINE KarLud_YFSini(XXXene,vv, PX,WtIni)
*////////////////////////////////////////////////////////////////////////////////////
*//                                                                                //
*//  ======================================================================        //
*//  ======================= Y F S G E N ==================================        //
*//  ======================================================================        //
*//  The algorithm in this subprogram was described in:                            //
*//  ``Yennie-Frautschi-Suura soft photons in Monte Carlo event generators''       //
*//             Unpublished report by S. Jadach,                                   //
*//          MPI-Munchen, MPI-PAE/PTh 6/87, Jan. 1987.                             //
*//                                                                                //
*//  Later on used in YFS1,YFS2,YFS3, YFSWW, KORALZ, KORALW Monte Carlo programs   //
*//                                                                                //
*//  Purpose:  ISR photon emission, photon multiplicity and momenta                //
*//                                                                                //
*////////////////////////////////////////////////////////////////////////////////////
*//   INPUT:    XXXene,vv                                                          //
*//   OUTPUT:   PX,WtIni                                                           //
*//                                                                                //
*//   XXXene  = total cms energy                                                   //
*//   amel    = beam mass                                                          //
*//   MltISR  = flag normaly set to zero, for SPECIAL tests enforces               //
*//             photon multiplicity to be exactly equal MltISR                     //
*//   vv      = v=1-s'/s variable                                                  //
*//   vmin    = minimum v variable (infrared cutoff)                               //
*//   nmax    = maximum photon multiplicity                                        //
*//   alfinv  = 1/apha_QED                                                         //
*//   p1,2    = initial fermion momenta (along z-axix)                             //
*//   nphot   = photon multiplicity                                                //
*//   sphot   = photon four-momenta                                                //
*//   sphum   = total photon four-momentum                                         //
*//   ygr,zet = Sudakov variables                                                  //
*//   PX      = 4-mmentum left after photon emission                               //
*//   WtIni   = total weight from this sub-generator                               //
*////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
*
      DOUBLE PRECISION  pi
      PARAMETER( pi=3.1415926535897932d0)
*
      DOUBLE PRECISION    XXXene,vv
*
      DOUBLE PRECISION    xphot(100,4)    ! photon momenta before rescaling
      DOUBLE PRECISION    PX(4),xph(100),rr(100)
      DOUBLE PRECISION    pp(4),pk(4)
*
      INTEGER  i,j,k
      DOUBLE PRECISION    phi,cg,sg,xk
      DOUBLE PRECISION    dist0,dist1
      DOUBLE PRECISION    beta,eta1,eta2
      DOUBLE PRECISION    Ene,ppdpp,ppdpk,pkdpk,DilFac,DilFac0,AA
      DOUBLE PRECISION    del1,del2,am2
      DOUBLE PRECISION    DilJac0,DilJac,AvMult,WtIni
      DOUBLE PRECISION    WtDil0,WtCut0
      REAL                rvec(10)
*---------------------------------------
      Ene  = XXXene/2d0
* Define 4-momenta of the initial charged particles (emitters)
      CALL KinLib_givpair(XXXene,m_amel,m_amel,m_p1,m_p2,beta,eta1,eta2)
      DO i=1,m_nmax
         xph(i)=0d0
         m_yini(i)=0d0
         m_zini(i)=0d0
         DO j=1,4
            xphot(i,j)=0d0
            m_sphot(i,j)=0d0
         ENDDO
      ENDDO
      IF(vv .LE. m_vvmin) THEN
*///////////////////////////////////////////////////
*//    no photon above detectability threshold    //
*///////////////////////////////////////////////////
         m_WtMass  = 1d0
         m_WtDil  = 1d0
         m_WtCut  = 1d0
         WtDil0 = 1d0          !test
         WtCut0 = 1d0          !test
         m_nphot=0
      ELSE
*/////////////////////////////////////////////////////////
*// one or more photons, generate photon multiplicity   //
*// nphot = poisson(AvMult) + 1                         //
*/////////////////////////////////////////////////////////
         CALL BornV_GetAvMult(AvMult)
 100     CONTINUE
         CALL KarLud_PoissGen(AvMult,m_nmax,m_nphot,rr)
         m_nphot = m_nphot+1
* For special tests of program at fixed multiplicity (for advc. users)
         IF((m_MltISR .NE. 0) .AND. (m_nphot .NE. m_MltISR)) GOTO 100
         IF(m_nphot .EQ. 1) THEN
            xph(1)=vv
         ELSE
            xph(1)=vv
            DO i=2,m_nphot
               xph(i)=vv*(m_vvmin/vv)**rr(i-1)
            ENDDO
         ENDIF ! nphot
         m_WtMass=1d0
         DO i=1,m_nphot
            xk=xph(i)
            am2  = (m_amel/Ene)**2
            CALL KarLud_AngBre(am2,del1,del2,cg,sg,dist0,dist1)
            dist0 = dist0 *m_Xenph
            m_WtMass    =m_WtMass *(dist1/dist0)
            CALL PseuMar_MakeVec(rvec,1)
            phi=2d0*pi*rvec(1)
            xphot(i,1)=xk*sg*cos(phi)
            xphot(i,2)=xk*sg*sin(phi)
            xphot(i,3)=xk*cg
            xphot(i,4)=xk
            m_yini(i)    =xk*del1/2d0
            m_zini(i)    =xk*del2/2d0
         ENDDO
*///////////////////////////////////////////////////////////////////////////
*// Here we determine dilatation factor for rescaling 4-momenta           //
*// of all photons such that total 4-momentum is conserved (for fixed v)  //
*///////////////////////////////////////////////////////////////////////////
         IF(m_nphot .EQ. 1) THEN
            DilFac0 = 1d0
            DilFac  = 1d0
            DilJac  = 1d0
         ELSE
            DO k=1,4
               pk(k)=0d0
               pp(k)=0d0
            ENDDO
            pp(4)=2d0           ! total energy in units of ene
            DO i=1,m_nphot
               DO k=1,4
                  pk(k)=pk(k)+xphot(i,k)
               ENDDO
            ENDDO
            ppdpp = pp(4)**2-pp(3)**2-pp(2)**2-pp(1)**2
            pkdpk = pk(4)**2-pk(3)**2-pk(2)**2-pk(1)**2
            ppdpk = pp(4)*pk(4)-pp(3)*pk(3)-pp(2)*pk(2)-pp(1)*pk(1)
            AA    = ppdpp*pkdpk/(ppdpk)**2
*     Dilatation factor
            DilFac0 = 2d0*ppdpk/ppdpp/vv
            DilFac  = DilFac0*.5d0*(1d0+sqrt(1d0-vv*AA))
*     and the corresponding jacobian factor
            DilJac  = (1d0+1d0/sqrt(1d0-vv*AA))/2d0
         ENDIF
         DilJac0 = (1d0+1d0/sqrt(1d0-vv))/2d0  !!! as in crude v-dist. in BornV_RhoVesko1
         m_WtDil  = DilJac/DilJac0
         m_WtCut  = 1d0
         WtDil0   = 1d0 /DilJac0   ! test
         WtCut0   = 1d0            ! test
*     scale down photon energies and momenta
         DO i=1,m_nphot
            m_yini(i) =m_yini(i)/DilFac
            m_zini(i) =m_zini(i)/DilFac
            DO k=1,4
               m_sphot(i,k)=xphot(i,k)/DilFac
            ENDDO
         ENDDO
*     Check on lower energy cut-off
         IF(m_sphot(m_nphot,4) .LT. m_vvmin)      m_WtCut = 0d0
         IF(xphot(m_nphot,4)/DilFac0 .LT. m_vvmin ) WtCut0 =0d0 !!! test
      ENDIF ! vv
*     Photon momenta rescaled into GEV units
      DO j=1,4
         m_sphum(j)=0d0
      ENDDO
      DO  i=1,m_nphot
         DO  j=1,4
            m_sphot(i,j) = m_sphot(i,j)*Ene
            m_sphum(j)   = m_sphum(j) +m_sphot(i,j)
         ENDDO
      ENDDO
* 4-momentum left after photon emission
      DO k=1,4
         PX(k)= -m_sphum(k)
      ENDDO
      PX(4)=PX(4)+XXXene
* Total ISR weight
      IF(m_KeyWtm .EQ. 1) m_WtMass=1d0
*
      WtIni = m_WtMass *m_WtDil *m_WtCut
*     ==============================
*((((((((((((((((((((((((((((
* Testing/debug part, some variables exported up to KK2f class
* NO HARM IF OMITTED !!!!
      CALL KK2f_SetOneY(252,m_WtMass)
      CALL KK2f_SetOneY(253,m_WtDil)
      CALL KK2f_SetOneY(254,m_WtCut)
* Auxiliary weights for tests of crude v-distr.
      CALL KK2f_SetOneY(263,WtDil0)
      CALL KK2f_SetOneY(264,WtCut0)
*))))))))))))))))))))))))))))
*----------------------------
      END


      SUBROUTINE KarLud_ZBoostAll(exe)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   performs z-boost on all momenta of the event                            //
*//   this z-boost corresponds to beamstrahlung or beamspread                 //
*//   and is done at the very end of generation, after m.el. calculation      //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KarLud.h'
      DOUBLE PRECISION  exe
      INTEGER           j,k
      DOUBLE PRECISION  ph(4)
*
      IF( exe.EQ. 1d0) RETURN
      CALL KinLib_Boost(3,exe,m_p1,m_p1)
      CALL KinLib_Boost(3,exe,m_p2,m_p2)
      CALL KinLib_Boost(3,exe,m_q1,m_q1)
      CALL KinLib_Boost(3,exe,m_q2,m_q2)
      CALL KinLib_Boost(3,exe,m_sphum,m_sphum)
      CALL KinLib_Boost(3,exe,m_PX,m_PX)
      DO j=1,m_nphot
         DO k=1,4
            ph(k) = m_sphot(j,k)
         ENDDO
         CALL KinLib_Boost(3,exe,ph,ph)
         DO k=1,4
            m_sphot(j,k) = ph(k)
         ENDDO
      ENDDO
      END


      DOUBLE PRECISION  FUNCTION KinLib_AngPhi(x,y)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//     calculates angle in (0,2*pi) range out of (x,y) vector                   //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  x,y
      DOUBLE PRECISION  pi
      PARAMETER( pi =3.1415926535897932d0)
      DOUBLE PRECISION  the

      IF(ABS(y) .LT. ABS(x)) THEN
        the = ATAN(abs(y/x))
        IF(x .LE. 0d0) the=pi-the
      ELSE
        the = ACOS(x/sqrt(x**2+y**2))
      ENDIF
      IF(y .LT. 0d0) the = 2d0*pi-the
      KinLib_AngPhi = the
      END

      SUBROUTINE KinLib_Boost(k,exe,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*// boost along k-th axis, exe=exp(eta), eta= hiperbolic velocity.               //
*// unboosted components are copied                                              //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER  k
      DOUBLE PRECISION    exe
      DOUBLE PRECISION    pvec(4),qvec(4)
      DOUBLE PRECISION    rpl,rmi,qpl,qmi
      INTEGER  i
*
      IF(exe .LT. 0d0 ) THEN
         WRITE(*,*) '+++++++ KinLib_Boost: Wrong exe= ',exe
         STOP
      ENDIF
      DO i=1,4
         qvec(i)=pvec(i)
      ENDDO
      rpl=pvec(4)+pvec(k)
      rmi=pvec(4)-pvec(k)
      qpl=rpl*exe
      qmi=rmi/exe
      qvec(k)=(qpl-qmi)/2
      qvec(4)=(qpl+qmi)/2
      END

      SUBROUTINE KinLib_BostQ(Mode,QQ,pp,r)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*// Boost along arbitrary axis (as implemented by Ronald Kleiss).                //
*// The method is described in textbook of Jackson on electrodynamics.           //
*// p boosted into r  from actual frame to rest frame of Q                       //
*// forth (Mode = 1) or back (Mode = -1).                                        //
*// Q must be a timelike, p may be arbitrary.                                    //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER   Mode
      DOUBLE PRECISION     QQ(*),pp(*),r(*)
      DOUBLE PRECISION     Q(4),p(4),fac,amq
      INTEGER   k
*
      DO k=1,4
         p(k)=pp(k)
         Q(k)=QQ(k)
      ENDDO
      amQ =dsqrt(Q(4)**2-Q(1)**2-Q(2)**2-Q(3)**2)
      IF    (Mode .EQ. -1) THEN
         r(4) = (p(1)*Q(1)+p(2)*Q(2)+p(3)*Q(3)+p(4)*Q(4))/amQ
         fac  = (r(4)+p(4))/(Q(4)+amQ)
      ELSEIF(Mode .EQ.  1) THEN
         r(4) =(-p(1)*Q(1)-p(2)*Q(2)-p(3)*Q(3)+p(4)*Q(4))/amQ
         fac  =-(r(4)+p(4))/(Q(4)+amQ)
      ELSE
         WRITE(*,*) ' ++++++++ Wrong Mode in KinLib_BostQ ', Mode
         STOP
      ENDIF
      r(1)=p(1)+fac*Q(1)
      r(2)=p(2)+fac*Q(2)
      r(3)=p(3)+fac*Q(3)
      END


      SUBROUTINE KinLib_BostQQ(Mode,QQ,pp,r)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*// Boost along arbitrary axis (as implemented by S.J.).                         //
*// The method is described in textbook of Jackson on electrodynamics.           //
*// p boosted into r  from actual frame to rest frame of Q                       //
*// forth (Mode = 1) or back (Mode = -1).                                        //
*// Q must be a timelike, p may be arbitrary.                                    //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      INTEGER  Mode
      DOUBLE PRECISION    QQ(*),pp(*),r(*)
      DOUBLE PRECISION    Lor(4,4),p(4)
      DOUBLE PRECISION    EQ,MQ,sum
      INTEGER  i,j,k,l
*---------------------------
      IF( IABS(MODE) .NE. 1 ) GOTO 900
      EQ = QQ(4)
      IF(EQ .LE. 0d0 ) GOTO 901
      MQ = QQ(4)**2-QQ(1)**2-QQ(2)**2-QQ(3)**2
      IF(MQ .LE. 0d0 ) GOTO 901
      MQ = DSQRT(MQ)
      DO i=1,4
         p(i)=pp(i)
      ENDDO
* Construct Lorenz transformation matrix
      DO k=1,3
         DO l=1,3
            Lor(k,l) = QQ(k)*QQ(l)/MQ/(MQ+EQ)
         ENDDO
      ENDDO
      DO k=1,3
         Lor(4,k) = -Mode*QQ(k)/MQ
         Lor(k,4) = -Mode*QQ(k)/MQ
         Lor(k,k) =  Lor(k,k) +1d0
      ENDDO
      Lor(4,4) = EQ/MQ

* Transform vector p, i.e. multiply by matrix Lor
      DO k=1,4
         sum = 0d0
         DO l=1,4
            sum=sum+ Lor(k,l)*p(l)
         ENDDO
         r(k) = sum
      ENDDO
*
      RETURN
 901  WRITE(*,*) '++++++++ KinLib_BostQQ: WRONG QQ, not timelike'
      STOP
 900  WRITE(*,*) '++++++++ KinLib_BostQQ: WRONG Mode = ',Mode
      STOP
      END

      SUBROUTINE KinLib_DefBoost(kaxis,exe,Lor)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Defines boost matrix the same as in  KinLib_Boost                          //
*//   boost along k-th axis, exe=exp(eta), eta= hiperbolic velocity.             //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER kaxis
      DOUBLE PRECISION   exe,Lor(4,4)
      INTEGER i,j,k
      DOUBLE PRECISION   ch,sh
*
      IF(exe .LT. 0d0 ) THEN
         WRITE(*,*) '+++++++ KinLib_DefBoost: Wrong exe= ',exe
         STOP
      ENDIF
      DO i=1,4
         DO j=1,4
            Lor(i,j) = 0d0
         ENDDO
         Lor(i,i) = 1d0
      ENDDO
      ch = (exe +1d0/exe)/2d0
      sh = (exe -1d0/exe)/2d0
      k=kaxis
      Lor(4,4) = ch
      Lor(k,k) = ch
      Lor(4,k) = sh
      Lor(k,4) = sh
      END

      SUBROUTINE KinLib_DefBostQQ(Mode,QQ,Lor)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   defines Lorenz transformation Lor, the same as in BostQQ                   //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      INTEGER  Mode
      DOUBLE PRECISION    QQ(4),Lor(4,4)
      INTEGER  k,l
      DOUBLE PRECISION    EQ,MQ
*---------------------------
      IF( IABS(MODE) .NE. 1 ) GOTO 900
      EQ = QQ(4)
      IF(EQ .LE. 0d0 ) GOTO 901
      MQ = QQ(4)**2-QQ(1)**2-QQ(2)**2-QQ(3)**2
      IF(MQ .LE. 0d0 ) GOTO 901
      MQ = DSQRT(MQ)
* Construct Lorenz transformation matrix
      DO k=1,3
         DO l=1,3
            Lor(k,l) = QQ(k)*QQ(l)/MQ/(MQ+EQ)
         ENDDO
      ENDDO
      DO k=1,3
         Lor(4,k) = -Mode*QQ(k)/MQ
         Lor(k,4) = -Mode*QQ(k)/MQ
         Lor(k,k) =  Lor(k,k) +1d0
      ENDDO
      Lor(4,4) = EQ/MQ
      RETURN
 900  WRITE(*,*) '++++++++ WRONG Mode in KinLib_BostQQ =',Mode
      STOP
 901  WRITE(*,*) '++++++++ WRONG QQ, not timelike'
      STOP
      END

      SUBROUTINE KinLib_DefPair(cmsene,am1,am2,p1,p2)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//  For CMS energy = cmsene it defines two 'decay' momenta p1,p2                //
*//  in their rest frame, along z-axix                                           //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  cmsene,am1,am2,beta,eta1,eta2
      DOUBLE PRECISION  p1(*),p2(*)
      DOUBLE PRECISION  ener,svar
*
      ener  =  cmsene/2d0
      svar  =  cmsene**2
      beta  =  sqrt((svar-(am1-am2)**2)
     $             *(svar-(am1+am2)**2))/svar
      eta1=    (svar+am1**2-am2**2)/svar
      eta2  =  (svar-am1**2+am2**2)/svar

      p1(1)  =  0d0
      p1(2)  =  0d0
      p1(3)  =  ener*beta
      p1(4)  =  ener*eta1

      p2(1)  =  0d0
      p2(2)  =  0d0
      p2(3)  = -ener*beta
      p2(4)  =  ener*eta2
      END

      SUBROUTINE KinLib_DefRotor(k1,k2,phi,Lor)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Defines rotation matrix the same as in  KinLib_Rotor                       //
*//   (k1,k2)= (1,2), x-y plane, around z axis                                   //
*//   (k1,k2)= (2,3), y-z plane, around x axis                                   //
*//   (k1,k2)= (3,1), x-z plane, around y axis                                   //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER k1,k2
      DOUBLE PRECISION  phi,Lor(4,4)
      INTEGER i,j,k
*
      DO i=1,4
         DO j=1,4
            Lor(i,j) = 0d0
         ENDDO
         Lor(i,i) = 1d0
      ENDDO
      Lor(k1,k1) =  cos(phi)
      Lor(k2,k2) =  cos(phi)
      Lor(k1,k2) = -sin(phi)
      Lor(k2,k1) =  sin(phi)  
      END

      SUBROUTINE KinLib_givpair(cmsene,am1,am2,p1,p2,beta,eta1,eta2)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//  For CMS energy = cmsene it defines two 'decay' momenta p1,p2                //
*//  in their rest frame, along z-axix                                           //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  cmsene,am1,am2,beta,eta1,eta2
      DOUBLE PRECISION  p1(*),p2(*)
      DOUBLE PRECISION  ener,svar
*
      ener  =  cmsene/2d0
      svar  =  cmsene**2
      beta  =  sqrt((svar-(am1-am2)**2)
     $             *(svar-(am1+am2)**2))/svar
      eta1=    (svar+am1**2-am2**2)/svar
      eta2  =  (svar-am1**2+am2**2)/svar

      p1(1)  =  0d0
      p1(2)  =  0d0
      p1(3)  =  ener*beta
      p1(4)  =  ener*eta1

      p2(1)  =  0d0
      p2(2)  =  0d0
      p2(3)  = -ener*beta
      p2(4)  =  ener*eta2
      END

      SUBROUTINE KinLib_LorCopy(Lor1,Lor2)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Copy Lor1 --> Lor2                                                         //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  Lor1(4,4),Lor2(4,4)
      INTEGER  k,l
*-------
      DO k=1,4
         DO l=1,4
c[[[            Lor2(k,l) = Lor1(k,l)
            Lor2(k,l) = Lor1(k,l)
         ENDDO
      ENDDO
      END


      SUBROUTINE KinLib_LorMult(Lor1,Lor2,Lor3)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Multiply matrices Lor3=Lor1*Lor2 for Lorenz transformations                //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    Lor1(4,4),Lor2(4,4),Lor3(4,4)
      DOUBLE PRECISION    Lor(4,4)
      INTEGER  i,j,k,l
      DOUBLE PRECISION    sum
*-------
      DO i=1,4
         DO j=1,4
            sum=0d0
            DO k=1,4
               sum=sum+Lor1(i,k)*Lor2(k,j)
            ENDDO
            Lor(i,j)=sum
         ENDDO
      ENDDO
      DO i=1,4
         DO j=1,4
            Lor3(i,j) = Lor(i,j)
         ENDDO
      ENDDO
      END

      SUBROUTINE KinLib_LorPrint(nunit,word,Lor)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Print transformation matrix Lor                                            //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER      nunit
      CHARACTER*8  word
      DOUBLE PRECISION  Lor(4,4)
      INTEGER k,j

      WRITE(nunit,'(4a)') '::::::::::::::::::::::::::::',
     $                    ' Lorenz Transformation ',word,
     $                    ' :::::::::::::::::::::::::::'
      DO k=1,4
         WRITE(nunit,'(6f20.14)') (Lor(k,j), j=1,4)
      ENDDO
      END

      SUBROUTINE KinLib_phspc2(qq,am1,am2,q1,q2,wt)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*// Generates q1, q2 with masses am1,am2, such that qq = q1+q2                   //
*// In the qq rest frame spherical density is flat                               //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  qq(*),q1(*),q2(*),am1,am2,wt
      DOUBLE PRECISION  pi
      PARAMETER( pi = 3.1415926535897932d0)
      DOUBLE PRECISION  cmsene,cth,phi,beta,eta1,eta2,the
      REAL              rvec(10)

      cmsene= sqrt(qq(4)**2-qq(3)**2-qq(2)**2-qq(1)**2)
      CALL PseuMar_MakeVec(rvec,2)
      cth= 1.d0 -2.d0*rvec(1)
      the= acos(cth)
      phi= 2.d0*pi*rvec(2)
      CALL KinLib_givpair(cmsene,am1,am2,q1,q2,beta,eta1,eta2)
      CALL KinLib_RotEul(the,phi,q1,q1)
      CALL KinLib_BostQ(  -1,qq,q1,q1)
      CALL KinLib_RotEul(the,phi,q2,q2)
      CALL KinLib_BostQ(  -1,qq,q2,q2)
      wt = beta/2d0
      END

      SUBROUTINE KinLib_RotColumn(e1,e2,e3,Rot)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Column-wise construction of rotation using 3 versors                       //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  Rot(4,4)
      DOUBLE PRECISION  e1(4),e2(4),e3(4)
      INTEGER  k,l
*-------
      Rot(4,4) = 1d0
      DO k=1,3
         Rot(k,4) =0d0
         Rot(4,k) =0d0
      ENDDO
      Rot(1,1) = e1(1)
      Rot(2,1) = e1(2)
      Rot(3,1) = e1(3)
      Rot(1,2) = e2(1)
      Rot(2,2) = e2(2)
      Rot(3,2) = e2(3)
      Rot(1,3) = e3(1)
      Rot(2,3) = e3(2)
      Rot(3,3) = e3(3)
      END

      SUBROUTINE KinLib_RotEul(the,phi,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//      Theta-phi rotation, it turns vector r along z-axis into r(theta,phi)    //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  the,phi,pvec(4),qvec(4)

      CALL KinLib_Rotor(3,1,the,pvec,qvec) ! y-rotation
      CALL KinLib_Rotor(1,2,phi,qvec,qvec) ! z-rotation
      END

      SUBROUTINE KinLib_RotEuler(alfa,beta,gamma,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//      Full Euler rotation R_3(alpha)*R_2(beta)*R_3(gamma)                     //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  pvec(4),qvec(4),alfa,beta,gamma
*
      CALL KinLib_Rotor(1,2, alfa,  pvec,qvec) ! z-rotation
      CALL KinLib_Rotor(3,1, beta,  qvec,qvec) ! y-rotation
      CALL KinLib_Rotor(1,2, gamma, qvec,qvec) ! z-rotation
      END

      SUBROUTINE KinLib_RotEulerInv(alfa,beta,gamma,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//      Inverse of KinLib_RotEuler                                              //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  pvec(4),qvec(4),alfa,beta,gamma
*
      CALL KinLib_Rotor(1,2, -gamma, pvec,qvec) ! z-rotation
      CALL KinLib_Rotor(3,1, -beta,  qvec,qvec) ! y-rotation
      CALL KinLib_Rotor(1,2, -alfa,  qvec,qvec) ! z-rotation
      END

      SUBROUTINE KinLib_RotEulInv(the,phi,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//      Inverse of KinLib_RotEul                                                //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  the,phi,pvec(4),qvec(4)

      CALL KinLib_Rotor(1,2,-phi,pvec,qvec) ! z-rotation
      CALL KinLib_Rotor(3,1,-the,qvec,qvec) ! y-rotation
      END

      SUBROUTINE KinLib_Rotor(k1,k2,ph1,pvec,qvec)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//  This is for rotation in any of the three planes                             //
*//  Rotation of (k1,k2) components, with copying of other                       //
*//   (k1,k2)= (1,2), x-y plane, around z axis                                   //
*//   (k1,k2)= (2,3), y-z plane, around x axis                                   //
*//   (k1,k2)= (3,1), x-z plane, around y axis                                   //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER k1,k2
      DOUBLE PRECISION   ph1,pvec(4),qvec(4)
      INTEGER k
      DOUBLE PRECISION   cs,sn,rvec1,rvec2,phi

      phi=ph1
      cs=cos(phi)
      sn=sin(phi)
      DO k=1,4
         qvec(k)=pvec(k)
      ENDDO
      rvec1  = pvec(k1)
      rvec2  = pvec(k2)
      qvec(k1)= cs*rvec1-sn*rvec2
      qvec(k2)= sn*rvec1+cs*rvec2
      END


      SUBROUTINE KinLib_RotTranspose(Lor)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Transpose spacelike part of matrix Lor                                     //
*//   Used for getting inverse of the rotation matrix                            //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  Lor(4,4),x
      INTEGER  k,l
*-------
      DO k=1,2
         DO l=k+1,3
            x= Lor(k,l)
            Lor(k,l) = Lor(l,k)
            Lor(l,k) = x
         ENDDO
      ENDDO
      END

      SUBROUTINE KinLib_SvarThet(p1,p2,q1,q2,Svar,CosTheta)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Provides Svar and  ONE cos(theta) among p1,p2 and q1,q2                       //
*//   Energy conservation required!!                                                //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION     p1(4),p2(4),q1(4),q2(4)
      DOUBLE PRECISION     Svar,CosTheta
*
      IF( ABS((p1(4)+p2(4)) - (q1(4)+q2(4))) .GT. 1d-50 ) THEN
         WRITE(*,*) '++++++++++ KinLib_ThetSvar: not conserved energy!!!!'
         STOP
      ENDIF
*
      Svar = (p1(4)+p2(4))**2-(p1(3)+p2(3))**2-(p1(2)+p2(2))**2-(p1(1)+p2(1))**2
      CosTheta=      (p1(3)*q1(3)+p1(2)*q1(2)+p1(1)*q1(1))
     $          /SQRT(p1(3)*p1(3)+p1(2)*p1(2)+p1(1)*p1(1))
     $          /SQRT(q1(3)*q1(3)+q1(2)*q1(2)+q1(1)*q1(1))
      END


*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//                       End of CLASS  KarLud                                //
*///////////////////////////////////////////////////////////////////////////////


*///////////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                           //
*//                                       KinLib                                                              //
*//                                                                                                           //
*//                   Library of kinematics operations on Lorentz vectors and matrices                        //
*//                                                                                                           //
*//  This class is just collection of tools for Lorentz vectors and transformation                            //
*//  Probably in future will be incorporated in the corresponding classes                                     //
*//                                                                                                           //
*// KinLib_ThetaD(PX,p1,p2,q1,q2,Svar,CosTheta)  : Provides Svar and single cos(theta) among p1,p2 and q1,q2  //
*// KinLib_SvarThet(p1,p2,q1,q2,Svar,CosTheta)   : The same as ThetaD but Energy conservation required        //
*// KinLib_ThetaR(Qtot,pp1,pp2,qq1,qq2,cth11,cth12,cth21,cth22) : cos(theta) of four scattering angles        //
*// KinLib_phspc2(qq,am1,am2,q1,q2,wt)                     : Generates q1, q2 with masses am1,am2             //
*// KinLib_givpair(cmsene,am1,am2,p1,p2,beta,eta1,eta2)    : Constructs  p1,p2 along z-axis                   //
*// KinLib_DefPair(cmsene,am1,am2,p1,p2)                   : Constructs  p1,p2 along z-axis                   //
*// KinLib_RotEul(the,phi,pvec,qvec)                  : Theta-phi rotation  y-rot(the) z-rot(phi)             //
*// KinLib_RotEulInv(the,phi,pvec,qvec)               : Inverse of KinLib_RotEul                              //
*// KinLib_RotEuler(alfa,beta,gamma,pvec,qvec)        : Full Euler rotation R_3(alpha)*R_2(beta)*R_3(gamma)   //
*// KinLib_RotEulerInv(alfa,beta,gamma,pvec,qvec)     : Inverse of KinLib_RotEuler                            //
*// KinLib_BostQ(Mode,QQ,pp,r)                        : Boost to rest frame of arbitrary timelike QQ          //
*// KinLib_BostQQ(Mode,QQ,pp,r)                       : Boost to rest frame of arbitrary timelike QQ          //
*// KinLib_DefBostQQ(Mode,QQ,Lor)                     : defines Lorenz transformation Lor of BostQQ           //
*// KinLib_Rotor(k1,k2,ph1,pvec,qvec)                 : Rotation in any of the three planes k1,k2             //
*// KinLib_DefRotor(k1,k2,phi,Lor)                    : Defines rotation matrix of  KinLib_Rotor              //
*// KinLib_Boost(k,exe,pvec,qvec)           : Boost along k-th axis, exe=exp(eta), eta= hiperbolic velocity   //
*// KinLib_DefBoost(kaxis,exe,Lor)          : Defines boost matrix the same as in  KinLib_Boost               //
*// KinLib_RotTranspose(Lor)                          : Transpose spacelike part of matrix Lor                //
*// KinLib_LorCopy(Lor1,Lor2)                         : Copy Lor1 --> Lor2                                    //
*// KinLib_RotColumn(e1,e2,e3,Rot)          : Column-wise construction of rotation using 3 versors            //
*// KinLib_LorMult(Lor1,Lor2,Lor3)          : Multiply matrices Lor3=Lor1*Lor2 for Lorenz transformations     //
*// KinLib_VecTrasform(Lor,p,q)             : Multiply vector and matrix, q=Lor*p (Lorentz transform)         //
*// FUNCTION KinLib_AngPhi(x,y)             : calculates angle in (0,2*pi) range out of (x,y) vector          //
*// KinLib_VecPrint(nunit,word,pp)          : prints single momentum 'pp' on unit 'nunit' with comment 'word' //
*// KinLib_LorPrint(nunit,word,Lor)         : Print transformation matrix Lor                                 //
*//                                                                                                           //
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE KinLib_ThetaD(PX,p1,p2,q1,q2,Svar,CosTheta)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Provides Svar and  ONE cos(theta) among p1,p2 and q1,q2                       //
*//   Energy conservation NOT required!!                                            //
*//   The angle is beteween 3-vectors (p1-p2) and (q1-q2) in PX rest frame.         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION     PX(4),p1(4),p2(4),q1(4),q2(4)
      DOUBLE PRECISION     Svar,CosTheta
      DOUBLE PRECISION     pd(4),qd(4),a,b
      INTEGER   k
*
      DO k=1,4
         pd(k) = p1(k)-p2(k)
         qd(k) = q1(k)-q2(k)
      ENDDO
      Svar = PX(4)**2-PX(3)**2-PX(2)**2-PX(1)**2
      IF( Svar .LE. 0d0 ) THEN
         WRITE(*,*) '++++++++++ KinLib_ThetaDr: PX not timelike'
         STOP
      ENDIF
      a = PX(4)*pd(4) -PX(3)*pd(3) -PX(2)*pd(2) -PX(1)*pd(1)
      b = PX(4)*qd(4) -PX(3)*qd(3) -PX(2)*qd(2) -PX(1)*qd(1)
      DO k=1,4
         pd(k) = pd(k) - a*PX(k)/Svar
         qd(k) = qd(k) - b*PX(k)/Svar
      ENDDO
      a = pd(4)**2-pd(3)**2-pd(2)**2-pd(1)**2
      b = qd(4)**2-qd(3)**2-qd(2)**2-qd(1)**2
      IF( a*b .LE. 0d0 ) THEN
         WRITE(*,*) '++++++++++ KinLib_ThetaDr: a,b=',a,b
         STOP
      ENDIF
      CosTheta = -(qd(4)*pd(4) -qd(3)*pd(3) -qd(2)*pd(2) -qd(1)*pd(1))/DSQRT(ABS(a*b))
*
      IF( ABS(CosTheta) .GT. 1d0 ) THEN
         WRITE(*,*) '++++++++++ KinLib_ThetaDr: CosTheta= ',CosTheta
      ENDIF
*
      END

      SUBROUTINE KinLib_ThetaR(Qtot,pp1,pp2,qq1,qq2,cth11,cth12,cth21,cth22)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Provides cos(theta) for four scattering angles among p1,p2 and q1,q2          //
*//   Angles are calculated in the rest frame of Qtot                               //
*//   Called in programs calculating Born(p1,p2,q1,q2) distribution.                //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  cth11,cth12,cth21,cth22
      DOUBLE PRECISION  Qtot(*),pp1(*),pp2(*),qq1(*),qq2(*)
      DOUBLE PRECISION  p1(4),p2(4),q1(4),q2(4)
      DOUBLE PRECISION  q1d,q2d,p1d,p2d
*
* Boost to Z/gamma frame
      CALL KinLib_BostQ(1,Qtot,pp1,p1)
      CALL KinLib_BostQ(1,Qtot,pp2,p2)
      CALL KinLib_BostQ(1,Qtot,qq1,q1)
      CALL KinLib_BostQ(1,Qtot,qq2,q2)
* Calculate all four possible angles
      q1d=        sqrt(q1(1)**2 +q1(2)**2 +q1(3)**2)
      q2d=        sqrt(q2(1)**2 +q2(2)**2 +q2(3)**2)
      p1d=        sqrt(p1(1)**2 +p1(2)**2 +p1(3)**2)
      p2d=        sqrt(p2(1)**2 +p2(2)**2 +p2(3)**2)
      cth11 = (p1(1)*q1(1) +p1(2)*q1(2) +p1(3)*q1(3))/p1d/q1d
      cth12 =-(p1(1)*q2(1) +p1(2)*q2(2) +p1(3)*q2(3))/p1d/q2d
      cth21 =-(p2(1)*q1(1) +p2(2)*q1(2) +p2(3)*q1(3))/p2d/q1d
      cth22 = (p2(1)*q2(1) +p2(2)*q2(2) +p2(3)*q2(3))/p2d/q2d
c[[[
c      cth11 = (q1(1)*p1(1) +q1(2)*p1(2) +q1(3)*p1(3))/q1d/p1d
c      cth12 =-(q1(1)*p2(1) +q1(2)*p2(2) +q1(3)*p2(3))/q1d/p2d
c      cth21 =-(q2(1)*p1(1) +q2(2)*p1(2) +q2(3)*p1(3))/q2d/p1d
c      cth22 = (q2(1)*p2(1) +q2(2)*p2(2) +q2(3)*p2(3))/q2d/p2d
c]]]
      END

      SUBROUTINE KinLib_VecPrint(nunit,word,pp)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   prints single momentum 'pp' on unit 'nunit' with comment 'word'         //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER      nunit
      CHARACTER*8  word
      DOUBLE PRECISION        pp(4),ams
      INTEGER      i
*----
      ams = pp(4)**2 -pp(3)**2 -pp(2)**2 -pp(1)**2
      IF(ams .GT. 0.0) ams = SQRT(ams)
      WRITE(nunit,'(a8,5(1x,f20.13))') word,(pp(i),i=1,4),ams
      END


      SUBROUTINE KinLib_VecTrasform(Lor,p,q)
*//////////////////////////////////////////////////////////////////////////////////
*//                                                                              //
*//   Multiply vector and matrix, q=Lor*p                                        //
*//                                                                              //
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION    Lor(4,4),p(4),q(4)
      INTEGER  k,l
      DOUBLE PRECISION    pp(4),sum
*-------
      DO k=1,4
         pp(k)=p(k)
      ENDDO
      DO k=1,4
         sum=0d0
         DO l=1,4
            sum=sum+Lor(k,l)*pp(l)
         ENDDO
         q(k)=sum
      ENDDO
      END



      SUBROUTINE  KK2f_DsigOverDtau(mout,Rho)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   !!! This routine is only for documentation and testing purposes !!!           //
*//                                                                                 //
*//   The distribution DsigOverDtau corresponding to WtCrud                         //
*//   Normalized with respect to dTau = Lorenz invariant phase space                //
*//                                                                                 //
*//   Photons attributed to ISR or FSR as in MC and interference ISR/FSR absent.    //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION      Rho
      INTEGER    mout
*
      DOUBLE PRECISION     pi
      PARAMETER (pi =3.1415926535897932d0)
      INTEGER    i,j,k
      DOUBLE PRECISION      PP(4),PX(4),PQ(4),Pho(4)
      DOUBLE PRECISION      SfacIniProd, SfacIni
      DOUBLE PRECISION      SfacFinProd, SfacFin
      DOUBLE PRECISION      kp1, kp2, kq1, kq2
      DOUBLE PRECISION      alfQED, Jcur(4)
      DOUBLE PRECISION      svar, svarX, svarQ, Massf, Mas1, Mas2, Mbeam
      DOUBLE PRECISION      ChaIni, ChaFin, xBorn, betaf, fLLux
      DOUBLE PRECISION      vv, vx,vq
      INTEGER    KFfin
      DOUBLE PRECISION      BornV_GetMass, BornV_GetCharge, BornV_Simple
      DOUBLE PRECISION      YFSkonIni, YFS_IRini, YFSkonFin, YFS_IRfin, YFS_isr, YFS_fsr, Yisr, Yfsr
      DOUBLE PRECISION      BVR_SForFac
      DOUBLE PRECISION      alfpi, alfpini, alfpfin, e_QED
      DOUBLE PRECISION      SfaSpi
      DOUBLE COMPLEX  GPS_soft
      INTEGER    nout
*-----------------------------------------------
      INTEGER   Icont
      SAVE      Icont
      DATA      Icont /0/
*-----------------------------------------------
      IF(Icont .GE. 500 )  RETURN
      nout = mout
      alfQED  = 1d0/m_alfinv
      e_QED  = DSQRT( 4d0*pi*alfQED)
* Actual KFcode of final fermion
      CALL MBrA_GetKF(KFfin)
      Massf  = BornV_GetMass(KFfin)
      Mas1  = Massf
      Mas2  = Massf
      Mbeam = BornV_GetMass(m_KFini)
* Final/initial state charges, (-1 for electron)
      ChaFin = BornV_GetCharge(KFfin)
      ChaIni = BornV_GetCharge(m_KFini)
      alfpi   = alfQED/pi
      alfpini  = alfpi*ChaIni**2
      alfpfin  = alfpi*ChaFin**2
* Product of ISR factors
      DO k=1,4
         PP(k) = m_p1(k) +m_p2(k)
         PX(k) = m_p1(k) +m_p2(k)
         PQ(k) = m_q1(k) +m_q2(k)
      ENDDO
      svar  = PP(4)*PP(4) -PP(3)*PP(3) -PP(2)*PP(2) -PP(1)*PP(1)
      IF( svar .LE. (2*Massf)**2 ) GOTO 900
*   //////////////////////////////////////////
*   //            S-factors                 //
*   //////////////////////////////////////////
      SfacIniProd = 1d0
      DO i=1,m_nphot
         IF( m_isr(i) .EQ. 1 ) THEN   ! select ISR
            DO k=1,4
               Pho(k) = m_sphot(i,k)
               PX(k)  = PX(k) -Pho(k)
            ENDDO
            kp1 = m_p1(4)*Pho(4)-m_p1(3)*Pho(3)-m_p1(2)*Pho(2)-m_p1(1)*Pho(1)
            kp2 = m_p2(4)*Pho(4)-m_p2(3)*Pho(3)-m_p2(2)*Pho(2)-m_p2(1)*Pho(1)
            DO k=1,4
               Jcur(k)  = m_p1(k)/kp1 -m_p2(k)/kp2
            ENDDO
            SfacIni = -(ChaIni**2 *alfQED/(4*pi**2))*(Jcur(4)**2 -Jcur(3)**2-Jcur(2)**2-Jcur(1)**2)
            SfacIniProd = SfacIniProd *SfacIni
*///////////////////////////
***            SfaSpi = 1/2d0 *1d0/(2d0*pi)**3  *CDABS( e_QED *GPS_soft(1,Pho,m_p1,m_p2) )**2
***            SfaSpi = 2d0*SfaSpi       !! factor 2 for two +- photon helicities
***            WRITE(*,'(a,6e20.14)') '/// SfacIni,SfaSpi = ', SfacIni,SfaSpi/SfacIni
*///////////////////////////
         ENDIF
      ENDDO
* Product of FSR factors
      SfacFinProd = 1d0
      DO i=1,m_nphot
         IF( m_isr(i) .EQ. 0 ) THEN   ! select FSR
            DO k=1,4
               Pho(k) = m_sphot(i,k)
            ENDDO
            kq1 = m_q1(4)*Pho(4)-m_q1(3)*Pho(3)-m_q1(2)*Pho(2)-m_q1(1)*Pho(1)
            kq2 = m_q2(4)*Pho(4)-m_q2(3)*Pho(3)-m_q2(2)*Pho(2)-m_q2(1)*Pho(1)
            DO k=1,4
               Jcur(k)  = m_q1(k)/kq1 -m_q2(k)/kq2
            ENDDO
            SfacFin = -(ChaFin**2 *alfQED/(4*pi**2))*(Jcur(4)**2 -Jcur(3)**2-Jcur(2)**2-Jcur(1)**2)
            SfacFinProd = SfacFinProd *SfacFin
*///////////////////////////
***         SfaSpi =1/2d0 *1d0/(2d0*pi)**3 *(ChaFin*e_QED *CDABS(GPS_soft(1,Pho,m_q1,m_q2)))**2
***         SfaSpi = 2d0*SfaSpi        !! factor 2 for two +- photon helicities ?
***         WRITE(*,'(a,6e20.14)') '/// SfacFin,SfaSpi = ', SfacFin, SfaSpi/SfacFin
*///////////////////////////
         ENDIF
      ENDDO
      svarX = PX(4)*PX(4) -PX(3)*PX(3) -PX(2)*PX(2) -PX(1)*PX(1)
      svarQ = PQ(4)*PQ(4) -PQ(3)*PQ(3) -PQ(2)*PQ(2) -PQ(1)*PQ(1)
      CALL BornV_GetVV(vv)
      vx    = 1d0 -svarX/svar
      vq    = 1d0 -svarQ/svar
      IF( svarQ .LE. (2*Massf)**2 ) GOTO 900
*   //////////////////////////////////////////
*   //              Born                    //
*   //////////////////////////////////////////
      xBorn = BornV_Simple( m_KFini,KFfin,svarX, 0d0  ) *(svar/svarX) !!<- Born(svarX)*svar
      xBorn = xBorn/(4*pi)
*   //////////////////////////////////////////
*   //              FormFactors             //
*   //////////////////////////////////////////
* Finaly formfactors, provided common IR sphere in CMS
* Equivalent alternatives:  Yisr==YFS_isr  and  Yfsr==YFS_fsr
* YFSkon imported from BornV and KarFin(piatek), unused there, not included in WtCrude!
* YFS_IR is included in WtCrude (Karfin) and normalization (Karlud, BornV).
      CALL  BornV_GetYFS_IR( YFS_IRini )
      CALL  BornV_GetYFSkon( YFSkonIni )
      YFS_isr =  YFS_IRini*YFSkonIni
      CALL KarFin_GetYFS_IR( YFS_IRfin )
      CALL KarFin_GetYFSkon( YFSkonFin )
      YFS_fsr =  YFS_IRfin*YFSkonFin
      Yisr= BVR_SForFac(alfpini, m_p1,Mbeam, m_p2,Mbeam, m_Emin, m_MasPhot)
      Yfsr= BVR_SForFac(alfpfin, m_q1,Mas1,  m_q2,Mas2,  m_Emin, m_MasPhot)
*   //////////////////////////////////////////
*   //              Other                   //
*   //////////////////////////////////////////
      betaf = DSQRT( 1d0 - 4*Massf**2/svarQ )
      fLLux = (svarX/svarQ)
*   //////////////////////////////////////////
*   //              Total                   //
*   //////////////////////////////////////////
      Rho = SfacIniProd            !! product of ISR formfactors
     $     *SfacFinProd            !! product of FSR formfactors
     $     *xBorn                  !! Born x-section dependend on vv
     $     *2d0/betaf              !! 2-body phase space factor (inverse of it)
     $     *fLLux                  !! LL 'flux-factor'
     $     *Yisr                   !! YFS full formfactor, ISR part
     $     *Yfsr                   !! YFS full formfactor, FSR part
*/////////////////////////////////////////////////////////////////////////////////
*//                            X-Checks                                         //
*/////////////////////////////////////////////////////////////////////////////////
**      IF(vq  .LE. 0.3d0)  RETURN
**      IF(vq  .GE. 0.9d0)  RETURN
      WRITE(nout,'(a,5g20.12)') '////////////// KK2f_DsigOverDtau ///////////////'
      WRITE(nout,'(a,5g20.12)') '/// SfacIniProd*SfacFinProd  = ', SfacIniProd*SfacFinProd
      WRITE(nout,'(a,5g20.12)') '///   vx,vq = ',vx,vq, vv/vx, betaf
      WRITE(nout,'(a,5g20.12)') '///   Yisr  = ',Yisr,YFS_isr,Yisr/YFS_isr
      WRITE(nout,'(a,5g20.12)') '///   Yfsr  = ',Yfsr,YFS_fsr,Yfsr/YFS_fsr
      WRITE(nout,'(a,5g20.12)') '///   Rho   = ',Rho
      WRITE(nout,'(a,5g20.12)') '//////////////////////////////////////////////////'
*/////////////////////////////////////////////////////////////////////////////////
      Icont =Icont +1
      RETURN
 900  CONTINUE
      Rho = 0d0
      END                       !!! KK2f_DsigOverDtau !!!

      SUBROUTINE KK2f_Finalize
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Final bookkeping and printouts                                                //
*//   Normalization available through getter KK2f_GetXsecMC(xSecPb, xErrPb)         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'KK2f.h'
*
      INTEGER     LevelPrint
      DOUBLE PRECISION       errela,averwt
      DOUBLE PRECISION       BornV_Integrated
      DOUBLE PRECISION       BornV_Sig0nb
      DOUBLE PRECISION       xkarl,error,erkarl,erabs
      DOUBLE PRECISION       xsmc,erel
      DOUBLE PRECISION       sig0pb,xBorPb
      DOUBLE PRECISION       avmlt,ermlt,upmlt
      DOUBLE PRECISION       WTsup, AvUnd, AvOve
      DOUBLE PRECISION       ROverf, RUnder
*-------------------------------------------------------------------
      LevelPrint=2
      sig0pb =  BornV_Sig0nb(m_CMSene)*1000

* Born xsec, just for orientation whwre we are...
      xBorPb =  BornV_Integrated(0,m_CMSene**2) * sig0pb

* Crude from karLud + printout
      CALL KarLud_Finalize(LevelPrint,xkarl,error)
      erkarl = 0d0

* Printout from Karfin
      CALL KarFin_Finalize(LevelPrint)

* Average of the main weight
      CALL GLK_MgetAve(m_idbra, AverWt, ErRela, WtSup)

* main X-section = crude * <WtMain>
      xsmc   =  xkarl*averwt
      erel   =  SQRT(erkarl**2+errela**2)
      erabs  =  xsmc*erel
*============================================================
* The final cross section exported to user
* through getter KK2f_GetXsecMC(xSecPb, xErrPb)
      m_xSecPb =  xsmc*sig0pb     ! MC xsection in picobarns
      m_xErrPb =  m_xSecPb*erel     ! Its error   in picobarns
*============================================================

* no printout for LevelPrint =1
      IF(LevelPrint .LE. 1) RETURN
*
* print photon multiplicity distribution
      CALL  GLK_Mprint(m_Idyfs+40)
*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '  KK2f_Finalize  printouts '
      WRITE(m_out,bxl1f) m_cmsene,   'cms energy total   ','cmsene','a0'
      WRITE(m_out,bxl1i) m_nevgen,   'total no of events ','nevgen','a1'
      WRITE(m_out,bxtxt) '** principal info on x-section **'
      WRITE(m_out,bxl2f) xsmc,erabs, 'xs_tot MC R-units  ','xsmc  ','a1'
      WRITE(m_out,bxl1f) m_xSecPb,   'xs_tot    picob.   ','xSecPb','a3'
      WRITE(m_out,bxl1f) m_xErrPb,   'error     picob.   ','xErrPb','a4'
      WRITE(m_out,bxl1f) erel,       'relative error     ','erel  ','a5'
      WRITE(m_out,bxl1f) WTsup ,    'WTsup, largest WT  ','WTsup ','a10'
      WRITE(m_out,bxtxt) '** some auxiliary info **'
      WRITE(m_out,bxl1f) xBorPb,     'xs_born   picobarns','xborn','a11'
      CALL GLK_MgetAve(m_Idyfs+40, avmlt, ermlt, upmlt)
      WRITE(m_out,bxl1f) avmlt,      'Raw phot. multipl. ','     ','==='
      WRITE(m_out,bxl1f) upmlt,      'Highest phot. mult.','     ','==='
      WRITE(m_out,bxtxt) '  End of KK2f  Finalize  '
      WRITE(m_out,bxclo)

* Print more on the main weight
      CALL MBrA_Print0
* Print even more on the weight in each branch!
      CALL MBrA_Print1
*--------------------------------------------------------------------------------
      CALL TauPair_Finalize
      END

      SUBROUTINE KK2f_GetBeams(p1,p2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Four-momenta of beams                                                         //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION   p1(4),p2(4)
      INTEGER k
*
      DO k=1,4
         p1(k) = m_p1(k)
         p2(k) = m_p2(k)
      ENDDO
      END


      SUBROUTINE KK2f_GetBornCru(BornCru)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Memorizing m_BornCru makes sense because we  may freely manipulate in QED3      //
*// with input parameters like MZ, couplings etc. (recalculate weights for event)   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION  BornCru
*------------------
      BornCru = m_BornCru
      END

      SUBROUTINE KK2f_GetCMSene(CMSene)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Photon minimum energy in LAB system                                           //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   CMSene
*
      CMSene = m_CMSene
      END

      SUBROUTINE KK2f_GetDate(Date)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Get VERSION date of the program                                             //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      CHARACTER*14   Date
*
      Date = m_Date
      END

      SUBROUTINE KK2f_GetEmin(Emin)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Photon minimum energy in LAB system                                           //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   Emin
*
      Emin = m_Emin
      END

      SUBROUTINE KK2f_GetFermions(q1,q2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   final state fermion four-momenta                                              //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION   q1(4),q2(4)
      INTEGER k
*
      DO k=1,4
         q1(k) = m_q1(k)
         q2(k) = m_q2(k)
      ENDDO
      END

      SUBROUTINE KK2f_GetIdyfs(Idyfs)
*/////////////////////////////////////////////////////////////////////////////////////
*//   pointer for histograms                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER Idyfs
*
      Idyfs = m_Idyfs
      END

      SUBROUTINE KK2f_GetIsBeamPolarized(IsBeamPolarized)
*/////////////////////////////////////////////////////////////////////////////////////
*//   ISR/FSR markers of all photons                                                //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER  IsBeamPolarized
*--------
      IsBeamPolarized = m_IsBeamPolarized
      END                       !!! KK2f_GetIsBeamPolarized !!!

      SUBROUTINE KK2f_GetIsr(isr)
*/////////////////////////////////////////////////////////////////////////////////////
*//   ISR/FSR markers of all photons                                                //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER  isr(*),j
*--------
      DO j=1,m_nphot
         isr(j) = m_isr(j)
      ENDDO
      END                       !!! KK2f_GetIsr !!!

      SUBROUTINE KK2f_GetKeyFSR(KeyFSR)
*/////////////////////////////////////////////////////////////////////////////////////
*//   FSR switch                                                                    //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER KeyFSR
*
      KeyFSR = m_KeyFSR
      END

      SUBROUTINE KK2f_GetKeyGPS(KeyGPS)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Get CEEX level switch                                                         //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER KeyGPS
*
      KeyGPS = m_KeyGPS
      END

      SUBROUTINE KK2f_GetKeyINT(KeyINT)
*/////////////////////////////////////////////////////////////////////////////////////
*//   ISR*FSR interference switch                                                   //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER KeyINT
*
      KeyINT = m_KeyINT
      END

      SUBROUTINE KK2f_GetKeyISR(KeyISR)
*/////////////////////////////////////////////////////////////////////////////////////
*//   ISR switch                                                                    //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER KeyISR
*
      KeyISR = m_KeyISR
      END

      SUBROUTINE KK2f_GetKFini(KFini)
*/////////////////////////////////////////////////////////////////////////////////////
*//   KF of beams                                                                   //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER KFini
*
      KFini = m_KFini
      END

      SUBROUTINE KK2f_GetMasPhot(MasPhot)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Photon mass for virtual corrections                                           //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   MasPhot
*
      MasPhot = m_MasPhot
      END

      SUBROUTINE KK2f_GetNphot(Nphot)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Get total photon multiplicity                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      INTEGER  Nphot
*------------------
      Nphot = m_nphot
      END                       !!! KK2f_GetNphot !!!


      SUBROUTINE KK2f_GetOneY(j,y)
*/////////////////////////////////////////////////////////////////////////////////////
*//   obsolete                                                                      //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION  y
      INTEGER j
*---------------------------------------------------------------
      y = m_ypar(j)
      END   ! KK2f_GetOneY

      SUBROUTINE KK2f_GetPhel(Phel)
*/////////////////////////////////////////////////////////////////////////////////////
*//   ISR/FSR markers of all photons                                                //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER  Phel(*),j
*--------
      DO j=1,m_nphot
         Phel(j) = m_Phel(j)
      ENDDO
      END                       !!! KK2f_GetPhel !!!

      SUBROUTINE KK2f_GetPhotAll(NphAll,PhoAll)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Get all photons, note that they are ordered in energy                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      INTEGER  NphAll
      DOUBLE PRECISION    PhoAll(m_phmax,4) ! Now we have m_phmax=100
      INTEGER  j,k
*------------------
      NphAll = m_nphot
      DO j=1,m_nphot
         DO k=1,4
            PhoAll(j,k) = m_sphot(j,k)
         ENDDO
      ENDDO
      END                       !!! KK2f_GetPhotAll !!!


      SUBROUTINE KK2f_GetPhoton1(iphot,phot)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   get i-th photon momentum                                                //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      SAVE
      INTEGER iphot
      DOUBLE PRECISION   phot(4)
      INTEGER k
*
      DO k=1,4
         phot(k) = m_sphot(iphot,k)
      ENDDO
      END

      SUBROUTINE KK2f_GetPolBeam1(PolBeam1)
*/////////////////////////////////////////////////////////////////////////////////////
*//   FIRST beam spin polarization                                                  //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   PolBeam1(4)
      INTEGER j
*
      DO j=1,4
         PolBeam1(j) = m_PolBeam1(j)
      ENDDO
      END

      SUBROUTINE KK2f_GetPolBeam2(PolBeam2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   SECOND beam spin polarization                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   PolBeam2(4)
      INTEGER j
*
      DO j=1,4
         PolBeam2(j) = m_PolBeam2(j)
      ENDDO
      END

      SUBROUTINE KK2f_GetVcut(Vcut)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Technical cuts for consecutive beta's                                         //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION   Vcut(3)
      INTEGER k
*
      DO k=1,3
         Vcut(k) = m_Vcut(k)
      ENDDO
      END

      SUBROUTINE KK2f_GetVersion(Version)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Get VERSION number of the program                                             //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   Version
*
      Version = m_Version
      END


      SUBROUTINE KK2f_GetWt(WtMain,WtCrud)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Main weights                                                                  //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION    WtMain,WtCrud
*--------------------------------------------------------------
      WtMain = m_WtMain  ! the best total weight
      WtCrud = m_WtCrud  ! Crude weight (helps to avoid bad events)
*
      END ! KK2f_GetWt


      SUBROUTINE KK2f_GetWtAll(WtMain,WtCrud,WtSet)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Weights ALL                                                                   //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      INTEGER  j
      DOUBLE PRECISION    WtMain,WtCrud,WtSet(*)
      DOUBLE PRECISION    WtBest
*--------------------------------------------------------------
      WtMain = m_WtMain  ! the best total weight
      WtCrud = m_WtCrud  ! Crude weight (helps to avoid bad events)
      DO j=1,m_lenwt
         WtSet(j) = m_WtSet(j)
      ENDDO
      END ! KK2f_GetWtAll

      SUBROUTINE KK2f_GetXenph(Xenph)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Enhancement factor in crude photon multiplicity                               //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   Xenph
*
      Xenph = m_Xenph
      END

      SUBROUTINE KK2f_GetXsecMC(xSecPb, xErrPb)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Photon minimum energy in LAB system                                           //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION   xSecPb, xErrPb
*
      xSecPb = m_xSecPb
      xErrPb = m_xErrPb
      END



      SUBROUTINE KK2f_Initialize(xpar)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Initialize class KK2f_                                                        //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INCLUDE 'BXformat.h'
      DOUBLE PRECISION    xpar(*)
      INTEGER             IsGenerated, KF,j,kxp
      INTEGER             Nbranch, KFferm
      DOUBLE PRECISION    BornV_Integrated, BornV_Sig0nb
      DOUBLE PRECISION    BornV_GetMass, BornV_GetAuxPar
      DOUBLE PRECISION    WtMax,  amferm, xcru, vmaxGPS
      DOUBLE PRECISION    WMlist(200), Xborn(200)  ! 200 should be class parameter!!!
      INTEGER             NBbranch,   KFlist(200), Nbin
      DOUBLE PRECISION    vvmin, pol1, pol2, PolBeam1(4), PolBeam2(4)
*--------------------------------------------------------------------------
*     Initialization of the internal histogramming package
      CALL GLK_Initialize

      DO j=1,m_jlim
         m_xpar(j)=xpar(j)
      ENDDO
*
      m_out = m_xpar(4)
*
      WRITE(m_out,'(10x,a)')
     $' ',
     $'  *************************************************************',
     $'  *  ****   ****    ****  ****      *******      ***********  *',
     $'  *  ****   ****    ****  ****    ***********    ***********  *',
     $'  *  ****   ****    ****  ****    ****   ****    ****         *',
     $'  *  **********     *********     ****   ****    *********    *',
     $'  *  *******        ******            *****      *********    *',
     $'  *  **********     ********        *****        ****         *',
     $'  *  ****  *****    ****  ****    **********     ****         *',
     $'  *  ****   *****   ****   ****   **********     ****         *',
     $'  *************************************************************',
     $' '
*
      m_CMSene = m_xpar( 1)
      m_DelEne = m_xpar( 2)
      m_WTmax  = m_xpar( 9)
      m_KeyWgt = m_xpar(10)
      m_npmax  = m_xpar(19)
      m_Idyfs  = m_xpar(8)
      m_KeyISR = m_xpar(20)
      m_KeyFSR = m_xpar(21)
      m_KeyINT = m_xpar(27)
      m_KeyGPS = m_xpar(28)
      m_alfinv = m_xpar(30)
      m_vcut(1)= m_xpar(41)
      m_vcut(2)= m_xpar(42)
      m_vcut(3)= m_xpar(43)
      m_KeyHad = m_xpar(50)
      m_HadMin = m_xpar(51)
      m_KFini  = m_xpar(400)
      m_MasPhot= m_xpar(510)
      vvmin =xpar(16)
      m_Emin   = m_CMSene/2d0 * vvmin
      m_Xenph  = m_xpar(40)
      IF(m_KeyINT .EQ. 0)  m_Xenph  = 1D0
*
      DO j=1,3
         m_PolBeam1(j)=m_xpar(60+j)
         m_PolBeam2(j)=m_xpar(63+j)
      ENDDO
      m_PolBeam1(4)=1d0
      m_PolBeam2(4)=1d0

*
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) '        KK Monte Carlo         '
      WRITE(m_out,bxl1v) 'Version ',      m_version,     m_date
      WRITE(m_out,bxl1f) m_CMSene,   'CMS energy average ','CMSene','a1'
      WRITE(m_out,bxl1f) m_DelEne,   'Beam energy spread ','DelEne','a2'
      WRITE(m_out,bxl1i) m_npmax,    'Max. photon mult.  ','npmax ','a3'
      WRITE(m_out,bxl1i) m_KeyISR,   'ISR switch         ','KeyISR','a4'
      WRITE(m_out,bxl1i) m_KeyFSR,   'FSR switch         ','KeyFSR','a5'
      WRITE(m_out,bxl1i) m_KeyINT,   'ISR/FSR interferenc','KeyINT','a6'
      WRITE(m_out,bxl1i) m_KeyGPS,   'New exponentiation ','KeyGPS','a7'
      WRITE(m_out,bxl1i) m_KeyHad,   'Hadroniz.  switch  ','KeyHad','a7'
      WRITE(m_out,bxl1f) m_HadMin,   'Hadroniz. min. mass','HadMin','a9'
      WRITE(m_out,bxl1f) m_WTmax,    'Maximum weight     ','WTmax ','a10'
      WRITE(m_out,bxl1i) m_npmax,    'Max. photon mult.  ','npmax ','a11'
      WRITE(m_out,bxl1i) m_KFini,    'Beam ident         ','KFini ','a12'
      WRITE(m_out,bxl1f) m_Emin,     'Manimum phot. ener.','Ene   ','a13'
      WRITE(m_out,bxl1g) m_MasPhot,  'Phot.mass, IR regul','MasPho','a14'
      WRITE(m_out,bxl1g) m_Xenph  ,  'Phot. mult. enhanc.','Xenph ','a15'
      WRITE(m_out,bxl1g) m_Vcut(1),  'Vcut1              ','Vcut1 ','a16'
      WRITE(m_out,bxl1g) m_Vcut(2),  'Vcut2              ','Vcut2 ','a16'
      WRITE(m_out,bxl1g) m_Vcut(3),  'Vcut3              ','Vcut2 ','a16'
      WRITE(m_out,bxl1f) m_PolBeam1(1), 'PolBeam1(1)     ','Pol1x ','a17'
      WRITE(m_out,bxl1f) m_PolBeam1(2), 'PolBeam1(2)     ','Pol1y ','a18'
      WRITE(m_out,bxl1f) m_PolBeam1(3), 'PolBeam1(3)     ','Pol1z ','a19'
      WRITE(m_out,bxl1f) m_PolBeam2(1), 'PolBeam2(1)     ','Pol2x ','a20'
      WRITE(m_out,bxl1f) m_PolBeam2(2), 'PolBeam2(2)     ','Pol2y ','a21'
      WRITE(m_out,bxl1f) m_PolBeam2(3), 'PolBeam2(3)     ','Pol2z ','a22'
      WRITE(m_out,bxclo)

* Check on polarization vectors
      pol1 = SQRT( m_PolBeam1(1)**2+m_PolBeam1(2)**2+m_PolBeam1(3)**2 )
      pol2 = SQRT( m_PolBeam2(1)**2+m_PolBeam2(2)**2+m_PolBeam2(3)**2 )
      IF(       pol1 .GT. 1d0 .OR. pol2 .GT. 1d0 ) THEN
         WRITE(m_out,'(a)') ' ##### STOP in KK2f_Initialize: WRONG SPIN VECTORS '
         WRITE(    *,'(a)') ' ##### STOP in KK2f_Initialize: WRONG SPIN VECTORS '
         STOP
      ENDIF
* Note that getter KK2f_GetIsBeamPolarized exists!
      m_IsBeamPolarized = 1
      IF( (pol1+pol2) .LT. 1d-6 ) m_IsBeamPolarized = 0

      IF(m_KeyWgt.EQ.1 .AND. m_KeyHad.EQ.1 ) THEN
         WRITE(m_out,*) '+++WARNING: for WT=0 events NO hadronization!'
         WRITE(    *,*) '+++WARNING: for WT=0 events NO hadronization!'
      ENDIF
*
*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
* Identificator for this generator
      m_idgen = 6
* Important 'signature histo' which remembers crude total x-section
      CALL GLK_Mbook(m_idgen   ,'KK2f signature  $', 1,m_WTmax)
* Tests
      CALL GLK_Mbook(m_Idyfs+40, 'KK2f: Photon raw multiplicity $',10, 0.1d0*m_xpar(19))
*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
* Basic initialization of brancher, branches are defined in BornV_Initialize
      m_IdBra = m_Idyfs+100
      CALL MBrA_Initialize(m_out,m_IdBra,50,m_WTmax, 'MBrA: KK2f main weight$')
*     Add branch for each final fermion
      DO j=1,20
         IsGenerated = m_xpar(400+j)

         IF( IsGenerated .NE. 0) THEN
            kxp = 500+10*j
            KF    = m_xpar(kxp+1)
            WtMax = m_xpar(kxp+7)
            IF(m_KeyISR .EQ. 0) WtMax = 1d0
            Nbin = 5
            CALL MBrA_AddBranch(KF,Nbin,WTmax,'MBrA: next branch$')

         ENDIF
      ENDDO
*----------------------------------------------------------------------
      CALL  BornV_Initialize( m_xpar)
      CALL KarLud_Initialize(m_xpar,xcru)
      CALL KarFin_Initialize(m_xpar)
      CALL   QED3_Initialize(m_xpar)
      IF(m_KeyGPS .NE. 0 ) THEN
         CALL GPS_Initialize
         CALL GPS_Setb2
         IF( m_IsBeamPolarized .EQ. 1) THEN
            CALL KK2f_WignerIni(m_KFini,m_CMSene,m_PolBeam1,m_PolBeam2, PolBeam1,PolBeam2) 
            WRITE(m_out,bxope)
            WRITE(m_out,bxtxt) 'KK2f: Beam polarizations Wigner rotated '
            WRITE(m_out,bxl1f) PolBeam1(1), 'PolBeam1(1)     ','Pol1x ','=='
            WRITE(m_out,bxl1f) PolBeam1(2), 'PolBeam1(2)     ','Pol1y ','=='
            WRITE(m_out,bxl1f) PolBeam1(3), 'PolBeam1(3)     ','Pol1z ','=='
            WRITE(m_out,bxl1f) PolBeam2(1), 'PolBeam2(1)     ','Pol2x ','=='
            WRITE(m_out,bxl1f) PolBeam2(2), 'PolBeam2(2)     ','Pol2y ','=='
            WRITE(m_out,bxl1f) PolBeam2(3), 'PolBeam2(3)     ','Pol2z ','=='
            WRITE(m_out,bxclo)
         ENDIF
         CALL GPS_SetPolBeams(PolBeam1,PolBeam2)
      ENDIF
*----------------------------------------------------------------------
      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'KK2f: Initialization '
* Crude normalization in nanobarns
      m_Xcrunb = xcru * BornV_Sig0nb(m_CMSene)
      WRITE(m_out,bxl1g) m_Xcrunb,   'x-crude [nb]       ','Xcrunb','**'
* Note that m_Xborn initialized here is used for KF generation for KeyISR=0
*
* List of properties of generated channels, calculate Xborn list
      CALL MBrA_GetKFlist(Nbranch,KFList)
      CALL MBrA_GetWMList(Nbranch,WMList)
      WRITE(m_out,bxtxt) 'List of final fermions:                '
      DO j=1,Nbranch
         KF = KFList(j)
         Xborn(j)= BornV_Integrated(KF,m_CMSene**2)    !<-- Initialization for tests only
         amferm  = BornV_GetMass(KF)
         vmaxGPS = BornV_GetAuxPar(KF)
         WRITE(m_out,bxl1i) KF       ,'KF of final fermion','KFfin ','**'
         WRITE(m_out,bxl1g) amferm   ,'mass of final ferm.','amferm','**'
         WRITE(m_out,bxl1g) Xborn(j) ,'Xborn [R]          ','Xborn ','**'
         WRITE(m_out,bxl1g) WMlist(j),'WtMax sampling par.','WtMax ','**'
         WRITE(m_out,bxl1g) vmaxGPS  ,'vmax for CEEX      ','vmaxGPS','**'
      ENDDO
      WRITE(m_out,bxclo)

* set generation parameters
* This initialization is used in KeyISR=0 case !!!
      CALL MBrA_SetXSList(Xborn)
*----------------------------------------------------------------------
      CALL TauPair_Initialize(m_xpar)
*----------------------------------------------------------------------
      m_nevgen=0
***** CALL GLK_ListPrint(6)     ! debug
      END                       !!! KK2f_Initialize !!!


      SUBROUTINE KK2f_Make
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//   Make one event ISR + FSR                                                      //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INCLUDE 'BXformat.h'
*
      DOUBLE PRECISION  xxf(4)
      REAL              rvec(10)
      INTEGER     i,j,k
      INTEGER     LevPri,Ie1Pri,Ie2Pri
      INTEGER     KFfin
      INTEGER     TauIsInitialized
      DOUBLE PRECISION       wt_fsr,wt_isr,WtScaled
      DOUBLE PRECISION       CMSE, vv, svar1, vmaxGPS
      DOUBLE PRECISION       charg2,amfi1,amfi2
      DOUBLE PRECISION       BornV_GetMass,BornV_GetCharge,BornV_GetAuxPar
      DOUBLE PRECISION       BornV_Differential
      DOUBLE PRECISION       WtSetNew(200), WtBest, WtBest1, WtBest2
      DOUBLE PRECISION       rn
      DOUBLE PRECISION       SvarQ, vvQ, Exe
*-----------------------------------------------------------
      m_nevgen   = m_nevgen +1
      m_ypar( 9) = m_nevgen
  100 CONTINUE
      m_WtCrud  = 1d0
      LevPri =m_xpar( 5)  !PrintOut Level 0,1,2,3
      Ie1Pri =m_xpar( 6)  !PrintOut Start point
      Ie2Pri =m_xpar( 7)  !PrintOut End   point
* WtSet reseting to zero
      DO j=1,m_lenwt
         m_WtSet(j) =0d0
      ENDDO
* =============================================
*                   ISR
* =============================================
* define p1,2, xxf, xf1,2 and photons
* note that xf1,xf2 are not used anymore
* Different Final state masses supported (for W pair production)
      CALL KarLud_Make(xxf,wt_ISR)
      m_WtCrud  = m_WtCrud*wt_ISR

* Actual KFcode of final fermion
      CALL MBrA_GetKF(KFfin)
      m_ypar(400) = KFfin  ! temporary debug

*   Control printout
      IF(LevPri .GE. 2) CALL KarLud_Print(m_nevgen,Ie1Pri,Ie2Pri)
* =============================================
*                   FSR
* =============================================
* Generate FSR photons and final fermion momenta.
* xxf defines frame (Z-frame) of final fermions + FSR photons.
* (Fermion momenta from KarLud_Make are not used, even for pure ISR)
      IF(m_WtCrud .NE. 0d0) THEN
         charg2 =BornV_GetCharge(KFfin)**2
         amfi1  =BornV_GetMass(KFfin)
         amfi2  =BornV_GetMass(KFfin)
         CALL KarFin_Make(xxf,amfi1,amfi2,charg2,wt_FSR)
         m_WtCrud  = m_WtCrud*wt_FSR
      ENDIF
*   Control printout
      IF(LevPri .GE. 2) CALL KarFin_Print(m_nevgen,Ie1Pri,Ie2Pri)
* ==============================================================================
* Merging photons in CMS frame. The common list from merging
* is used in GPS package. It is not used in QED3. Merge is BEFORE ZBoostAll.
* ==============================================================================
      IF(m_WtCrud .NE. 0d0)  CALL KK2f_Merge
      IF(m_WtCrud .NE. 0d0)  CALL KK2f_MakePhelRand         !<-- Generate photon helicities
* Control printout ISR+FSR
      IF(LevPri .GE. 1) CALL KK2f_Print(Ie1Pri,Ie2Pri)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// All four-momenta are constructed and recorded at this point.                    //
*//                                                                                 //
*// The generated distribution with the weight WtCrud represents the differential   //
*// distribution equal to phase space times all ISR S-factor times FSR S-factors    //
*// times 'Born(s*(1-v),cosheta)'                                                   //
*//                                                                                 //
*// The 'Born' angular distribution in xxf frame (in terms of Euler angles) is in   //
*// present version exactly flat (generated in KarFin).                             //
*// The distribution m_BornCru represents the above  'Born(s*(1-v),cosheta)'.       //
*// It is remodeled later on during calculation of the QED mat. elem. in QED3.      //
*//                                                                                 //
*// Memorizing m_BornCru makes sense because we  may freely manipulate in QED3      //
*// with input parameters like MZ, couplings etc. (recalculate weights for event)   //
*// This trick is not working for GPS where  BornCru is calculated internaly        //
*//                                                                                 //
*// The weight from QED3/GPS is not modifying Z position any more, see also KarLud  //
*/////////////////////////////////////////////////////////////////////////////////////
* =============================================================
*                    Model weight
* =============================================================
      m_WtMain  =m_WtCrud
      IF(m_WtCrud .NE. 0d0) THEN
         CALL BornV_GetVV(vv)
         CALL KarLud_GetXXXene(CMSE)            !<-- It is this realy OK, see above
         svar1     = CMSE**2*(1d0-vv)
         m_BornCru = 4d0/3d0*BornV_Differential(0,KFfin,svar1,0d0,0d0,0d0,0d0,0d0)
         CALL QED3_Make                         !<-- EEX
* WtSet from QED3 is filled in the range (1:200)
         CALL QED3_GetWtSet(WtBest,m_WtSet)     !<-- WtBest initialized
* New CEEX matrix element is now default for leptons and optional for quarks.
* Its use is controled by auxiliary parameter vmaxGPS (temporary solutions)
* CEEX is calculated twice, with ISR*FSR interference OFF and ON
         CALL  KarFin_GetSvarQ(SvarQ)
         vvQ = 1-SvarQ/CMSE**2
         vmaxGPS = BornV_GetAuxPar(KFfin)
         IF( m_KeyGPS.NE.0 .AND. vvQ.LT.vmaxGPS ) THEN
            CALL GPS_ZeroWtSet                 !<-- zeroing GPS weights
            CALL GPS_SetKeyINT( 0)             !<-- ISR*FSR interfer. OFF
            CALL GPS_Make                      !<-- CEEX    interfer. OFF
            IF( m_KeyINT .NE. 0 ) THEN
               CALL GPS_SetKeyINT( m_KeyINT)   !<-- ISR*FSR interfer. ON
               CALL GPS_Make                   !<-- CEEX    interfer. ON
            ENDIF
            CALL GPS_GetWtSet(WtBest,WtSetNew) !<-- WtBest redefined !!!
* m_WtSet appended with WtSetNew
            DO j=1,200
               m_WtSet(j+200) = WtSetNew(j)
            ENDDO
         ENDIF
         m_WtMain  = m_WtMain*WtBest
      ENDIF
*   Control printout
      IF(LevPri .GE. 2) THEN
         CALL  QED3_wtPrint(' KK2f ',m_out,m_nevgen,Ie1Pri,Ie2Pri,wt_ISR,wt_FSR,WtBest,m_WtSet)
      ENDIF
*///////////////////////////////////////////////////////////////
*//                                                           //
*//     Optional rejection according to principal weight      //
*//                                                           //
*///////////////////////////////////////////////////////////////
      IF(m_KeyWgt .EQ. 0) THEN              !!! CONSTANT-WEIGHT events
         CALL PseuMar_MakeVec(rvec,1)
         rn = rvec(1)
         CALL GLK_Mfill(m_idgen, m_Xcrunb*m_WTmax, rn)
         CALL MBrA_Fill(m_WtMain   ,rn)
         WtScaled = m_WtMain/m_WTmax
         IF( WtScaled .GT. 1d0) THEN
            m_WtMain = WtScaled
         ELSE
            m_WtMain = 1.d0
         ENDIF
         m_WtCrud=1d0
         IF(rn .GT. WtScaled) GOTO 100
      ELSE                                  !!! VARIABLE-WEIGHT events
         CALL GLK_Mfill(m_idgen   , m_Xcrunb, 0d0)
         CALL MBrA_Fill(m_WtMain,  0d0)
      ENDIF
* =============================================================
* =============================================================
* Some test
      CALL GLK_Mfill(m_Idyfs+40, 1d0*m_nphot,   rn)
* =============================================================
* collection of the weights for the advanced user
      IF(m_KeyWgt .EQ. 0) THEN
* wt_ISR,2  weights are reset to one
         wt_ISR=1d0
         wt_FSR=1d0
** WtSet reseting to zero, not realy necessary!!!
**         DO j=1,m_lenwt
**            m_WtSet(j) =0d0
**         ENDDO
      ENDIF
      m_ypar(1)=m_WtMain        ! Main Total Weight  ! debug
      m_ypar(2)=m_WtCrud        ! Total Crude weight ! debug
      m_ypar(3)=wt_ISR          ! reintroduction     ! debug
      m_ypar(4)=wt_FSR          !                      debug
*/////////////////////////////////////////////////////////////////////////////////////
*//         Fill standard HEP and/or LUND common blocks and HADRONIZE               //
*/////////////////////////////////////////////////////////////////////////////////////
      CALL KarLud_GetExe(Exe)
      CALL KK2f_ZBoostAll(  exe)
      CALL KarLud_ZBoostAll(exe)
      CALL KarFin_ZBoostAll(exe)
*
C      print *,'before hadronization in kk2fmake'
      CALL HepEvt_Fill
      IF( m_WtMain .NE. 0d0 .AND. m_KeyHad .EQ. 1 ) CALL HepEvt_Hadronize(m_HadMin)
C      print *,'end of hadronization in kk2fmake'
* =================================================================
* Tau decays using tauola, all spin effects implemented!
      IF(m_WtCrud .NE. 0d0) THEN
         IF( ABS(KFfin) .EQ. 15) THEN
            CALL TauPair_GetIsInitialized(TauIsInitialized)
            IF( TauIsInitialized .NE. 0) THEN
               IF(m_KeyGPS .EQ. 0 ) THEN
                  WRITE(m_out,*) ' #### STOP in KK2f_Make: for tau decays GPS not activated !!!'
                  WRITE(    *,*) ' #### STOP in KK2f_Make: for tau decays GPS not activated !!!'
                  STOP
               ENDIF
               CALL TauPair_Make1        ! tau decay generation
               CALL TauPair_ImprintSpin  ! introduction of spin effects by rejection
               CALL TauPair_Make2        ! the remaining book-keeping and Photos
            ENDIF
         ENDIF
      ENDIF
C      print *,'end of kk2f make'
      END                       !!! end of KK2f_Make !!!


      SUBROUTINE KK2f_MakePhelRand
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Generate photon helicities randomly                                     //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER   i
      REAL                 rvec(m_phmax)
*
      IF(m_nphot .LE. 0) RETURN
      CALL PseuMar_MakeVec(rvec,m_nphot)
      DO i=1,m_nphot
         IF( rvec(i) .GT. 0.5d0 ) THEN
            m_Phel(i)=0
         ELSE
            m_Phel(i)=1
         ENDIF
      ENDDO
      END

      SUBROUTINE  KK2f_Merge
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Merging ISR and FSR photon momenta.                                            //
*//  Photons are ordered according to energy (in CMS)                               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      INTEGER nphox,nphoy
      DOUBLE PRECISION   xphot(m_phmax,4),yphot(m_phmax,4),enex,eney
      INTEGER i,k,i1,i2
*-----------------------------------------------------------------------
      CALL KarLud_GetBeams(    m_p1, m_p2)
      CALL KarFin_GetFermions( m_q1, m_q2)
*
      CALL KarLud_GetPhotons(nphox,xphot)
      CALL KarFin_GetPhotons(nphoy,yphot)
*
      m_nphot  = nphox +nphoy
      i1=1
      i2=1
      DO i=1,m_nphot
         enex = 0d0
         eney = 0d0
* saveguard against Alex Read and Tiziano Camporesi effect (bug in old BHLUMI)
         IF(i1 .LE. nphox) enex = xphot(i1,4)
         IF(i2 .LE. nphoy) eney = yphot(i2,4)
         IF(enex .GT. eney) THEN
            DO k=1,4
               m_sphot( i,k) = xphot(i1,k)
            ENDDO
            m_isr(i) = 1        ! ISR origin
            i1=i1+1    
         ELSE
            DO k=1,4
               m_sphot( i,k) = yphot(i2,k) ! FSR
            ENDDO
            m_isr(i) = 0        ! FSR origin
            i2=i2+1    
         ENDIF
      ENDDO
      END


      SUBROUTINE  KK2f_Print(ie1,ie2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Prints out four momenta of Beams and Final state particles,                    //
*//  and the serial number of event m_nevgen on unit m_out                          //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION   p1(4),p2(4),q1(4),q2(4),sphum(4)
      CHARACTER*8 txt
      DOUBLE PRECISION    sum(4),amf1,amf2,ams,amph
      INTEGER  i,k,KFfin,ie1,ie2
*-----------------------------------------------------------------
* Actual KFcode of final fermion
      CALL MBrA_GetKF(KFfin)
* Fermion momenta
      CALL KarLud_GetBeams(p1,p2)
      CALL KarFin_GetFermions(q1,q2)
*
      txt = ' KK2f '
      IF( (m_nevgen .GE. ie1) .AND. (m_nevgen .LE. ie2) ) THEN
         CALL  KK2f_Print1(m_out)
      ENDIF
      END


      SUBROUTINE  KK2f_Print1(nout)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Prints out four momenta of Beams and Final state particles,                    //
*//  and the serial number of event m_nevgen on unit nout                           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      INTEGER     nout
      CHARACTER*8 txt
      DOUBLE PRECISION    sum(4),amf1,amf2,ams,amph
      INTEGER  i,k,KFfin
*-----------------------------------------------------------------
* Actual KFcode of final fermion
      CALL MBrA_GetKF(KFfin)
*
      txt = ' KK2f '
      WRITE(nout,*) '================== ',txt,' ======================>',m_nevgen
*     
      amf1 = m_p1(4)**2-m_p1(3)**2-m_p1(2)**2-m_p1(1)**2
      amf1 = sqrt(abs(amf1))
      amf2 = m_p2(4)**2-m_p2(3)**2-m_p2(2)**2-m_p2(1)**2
      amf2 = sqrt(abs(amf2))
      WRITE(nout,3100) 'm_p1',(  m_p1(  k),k=1,4),amf1
      WRITE(nout,3100) 'm_p2',(  m_p2(  k),k=1,4),amf2
*     
      amf1 = m_q1(4)**2-m_q1(3)**2-m_q1(2)**2-m_q1(1)**2
      amf1 = sqrt(abs(amf1))
      amf2 = m_q2(4)**2-m_q2(3)**2-m_q2(2)**2-m_q2(1)**2
      amf2 = sqrt(abs(amf2))
      WRITE(nout,3100) 'm_q1',(  m_q1(  k),k=1,4),amf1,KFfin
      WRITE(nout,3100) 'm_q2',(  m_q2(  k),k=1,4),amf2,KFfin
*     
      DO i=1,m_nphot
         amph = m_sphot(i,4)**2-m_sphot(i,3)**2 -m_sphot(i,2)**2-m_sphot(i,1)**2
         amph = sqrt(abs(amph))
         WRITE(nout,3100) 'pho',(m_sphot(i,k),k=1,4),amph
      ENDDO
      DO k=1,4
         sum(k)=m_q1(k)+m_q2(k)
      ENDDO
      DO i=1,m_nphot
         DO k=1,4
            sum(k)=sum(k)+m_sphot(i,k)
         ENDDO
      ENDDO
      ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
      ams = sqrt(abs(ams))
      WRITE(nout,3100) 'sum',(  sum(  k),k=1,4),ams
 3100 FORMAT(1x,a3,1x,5f20.14,i5)
      END
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//  =======================================================================        //
*//  =======================================================================        //
*//  =====================FERMION PAIR PRODUCTION===========================        //
*//  ===========QED INITIAL AND FINAL STATE EXPONENTIATION==================        //
*//  =======================================================================        //
*//  ==This program is the descendant of the YFS3 and KORALZ Monte Carlos===        //
*//  ===================YFS1 September 1987 ================================        //
*//  ===================YFS2 September 1988 ================================        //
*//  ===================YFS3 February  1993 ================================        //
*//  =================YFS3ff September 1997 ================================        //
*//  ===================KK2f June      1998 ================================        //
*//  ===================KK  4.00  Nov. 1998 ================================        //
*//  ===================KK  4.01  Feb. 1999 ================================        //
*//  ===================KK  4.02  Apr. 1999 ================================        //
*//  ===================KK  4.11  Sep. 1999 ================================        //
*//  =======================================================================        //
*//                                                                                 //
*//  AUTHORS:                                                                       //
*//                        S. Jadach                                                //
*//     Address: Institute of Nuclear Physics, Cracow, Poland                       //
*//                       B.F.L. Ward                                               //
*//     Address: University of Tennessee,  Knoxville, Tennessee                     //
*//                         Z. Was                                                  //
*//     Address: Institute of Nuclear Physics, Cracow, Poland                       //
*//                                                                                 //
*//            (C) 1998 by S. Jadach, BFL Ward, Z. Was                              //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////


*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//                       Pseudo-CLASS  KK2f                                        //
*//                                                                                 //
*//     Purpose:   KK2f generator, top level class                                  //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*

      SUBROUTINE KK2f_ReaDataX(DiskFile,iReset,imax,xpar)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   DiskFile  = input file to read                                                //
*//   imax   = maximum index in xpar                                                //
*//   iReset = 1, resets xpar to 0d0                                                //
*//   iTalk=1,     prints echo into standard input                                  //
*//                                                                                 //
*//   Single data card is:    (a1,i4,d15.0,a60)                                     //
*//   First data card: BeginX                                                       //
*//   Last  data card: EndX                                                         //
*//   First character * defines comment card!                                       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      CHARACTER*(*)     DiskFile
      DOUBLE PRECISION  xpar(*)
      CHARACTER*6       beg6
      CHARACTER*4       end4
      CHARACTER*1       mark1
      CHARACTER*60      comm60
      CHARACTER*80      comm80
      INTEGER           imax,iReset,iTalk
      INTEGER           ninp,i,line,index
      DOUBLE PRECISION  value
*////////////////////////////////////////
*//  Clear xpar and read default Umask //
*////////////////////////////////////////
      iTalk = 1
      IF(iReset .EQ. 1 ) THEN
         iTalk = 0
         DO i=1,imax
            xpar(i)=0d0
         ENDDO
      ENDIF
      ninp = 13
      OPEN(ninp,file=DiskFile)
      IF(iTalk .EQ. 1) THEN
         WRITE(  *,*) '****************************'
         WRITE(  *,*) '*    KK2f_ReaDataX Starts  *'
         WRITE(  *,*) '****************************'
      ENDIF
* Search for 'BeginX'
      DO line =1,100000
         READ(ninp,'(a6,a)') beg6,comm60
         IF(beg6 .EQ. 'BeginX') THEN
            IF(iTalk .EQ. 1)   WRITE( *,'(a6,a)') beg6,comm60
            GOTO 200
         ENDIF
      ENDDO
 200  CONTINUE
* Read data, 'EndX' terminates data, '*' marks comment
      DO line =1,100000
         READ(ninp,'(a)') mark1
         IF(mark1 .EQ. ' ') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a1,i4,d15.0,a60)') mark1,index,value,comm60
            IF(iTalk .EQ. 1) 
     $           WRITE( *,'(a1,i4,g15.6,a60)') mark1,index,value,comm60
            IF( (index .LE. 0) .OR. (index .GE. imax)) GOTO 990
            xpar(index) = value
         ELSEIF(mark1 .EQ. 'E') THEN
            BACKSPACE(ninp)
            READ(  ninp,'(a4,a)') end4,comm60
            IF(iTalk .EQ. 1)   WRITE( *,'(a4,a)') end4,comm60
            IF(end4 .EQ. 'EndX') GOTO 300
            GOTO 991
         ELSEIF(mark1 .EQ. '*') THEN
            BACKSPACE(ninp)
            READ(  ninp,'(a)') comm80
            IF(iTalk .EQ. 1)    WRITE( *,'(a)') comm80
         ENDIF
      ENDDO
 300  CONTINUE
      IF(iTalk .EQ. 1)  THEN
         WRITE(  *,*) '**************************'
         WRITE(  *,*) '*   KK2f_ReaDataX Ends   *'
         WRITE(  *,*) '**************************'
      ENDIF
      CLOSE(ninp)
      RETURN
*-----------
 990  WRITE(    *,*) '+++ KK2f_ReaDataX: wrong index= ',index
      STOP
      RETURN
 991  WRITE(    *,*) '+++ KK2f_ReaDataX: wrong end of data '
      STOP
      END


      SUBROUTINE KK2f_SetOneY(j,y)
*/////////////////////////////////////////////////////////////////////////////////////
*//   obsolete                                                                      //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
*
      DOUBLE PRECISION  y
      INTEGER j
*---------------------------------------------------------------
      m_ypar(j) =y
      END   ! KK2f_GetOneY


      SUBROUTINE KK2f_WignerIni(KFbeam,CMSene,PolBeam1,PolBeam2, Polar1,Polar2) 
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Purpose: Wigner rotation for spin polarizations vectors of beams.             //
*//                                                                                 //
*//   For the moment we assume that beam polarization vectors are defined           //
*//   in beam particle rest frames which are reached from CSM by simple             //
*//   z-boost without any rotation. Note that first beam is paralel to z-axis.      //
*//                                                                                 //
*//   Notes:                                                                        //
*//   - Initialization of class BornV and GPS required                              //
*//   - Externals from GPS and Kinlib classes                                       //
*//   - In order to facilitate external tests, KK2f.h is not included (temporarily) //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
*-------------------------------------------------------------------------------------
      INTEGER   KFbeam
      DOUBLE PRECISION     CMSene
      DOUBLE PRECISION     BornV_GetMass, Mbeam
      DOUBLE PRECISION     p1(4),p2(4)
      DOUBLE PRECISION     PolBeam1(4), PolBeam2(4), Polar1(4),Polar2(4)
      INTEGER   i,j,k
      DOUBLE PRECISION     pi,thet,phi,exe
*-------------------------------------------------------------------------------------
      WRITE(*,*) '=====================: KK2f_WignerIni: ============================'

      Mbeam   = BornV_GetMass(KFbeam)
      WRITE(*,*) 'Mbeam= ',Mbeam,CMSene

      CALL KinLib_DefPair(CMSene,Mbeam,Mbeam,p1,p2)

* Initialize GPS tralor
      CALL GPS_TralorPrepare(p1,1)
      CALL GPS_TralorPrepare(p2,2)

      WRITE(*,*) 'KK2f_WignerIni:================beam rest frame====================='
      CALL KinLib_VecPrint(6 ,'PolBeam1',PolBeam1)
      CALL KinLib_VecPrint(6 ,'PolBeam2',PolBeam2)

*/////////////////////////////////////////////////////////////////////////////////////
*//   These two transformations from beam particle frames to CMS define where       //
*//   'machine spin polarization vectors' are primarily defined.                    //
*//   In the present version the transformations are simple boosts along z-axis.    //
*//   To be changed apprioprietly, if we adopt another convention!!!!               //
*/////////////////////////////////////////////////////////////////////////////////////
      exe   = (p1(4)+p1(3))/Mbeam
      CALL KinLib_Boost(3,     exe,PolBeam1,PolBeam1) ! beam1_rest --> CMS
      CALL KinLib_Boost(3, 1d0/exe,PolBeam2,PolBeam2) ! beam2_rest --> CMS
*/////////////////////////////////////////////////////////////////////////////////////

      WRITE(*,*) 'KK2f_WignerIni:=================CMS================================='
      CALL KinLib_VecPrint(6 ,'PolBeam1',PolBeam1)
      CALL KinLib_VecPrint(6 ,'PolBeam2',PolBeam2)

*/////////////////////////////////////////////////////////////////////////////////////
*//   These transformations assures that for calculations with KS spinors we use    //
*//   beam spin polarization vectors in the proper GPS frames of the beam particles //
*/////////////////////////////////////////////////////////////////////////////////////
      CALL GPS_TralorUnDo(   1,PolBeam1,Polar1)     ! CMS --> beam1_rest GPS
      CALL GPS_TralorUnDo(   2,PolBeam2,Polar2)     ! CMS --> beam2_rest GPS

      WRITE(*,*) 'KK2f_WignerIni:=================GPS================================='
      CALL KinLib_VecPrint(6 ,'Polar1  ',Polar1)
      CALL KinLib_VecPrint(6 ,'Polar2  ',Polar2)

      Polar1(4)=1d0             ! in order to get rid of rounding errors
      Polar2(4)=1d0             ! in order to get rid of rounding errors
      END

      SUBROUTINE KK2f_ZBoostAll(exe)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   performs z-boost on all momenta of the event                            //
*//   this z-boost corresponds to beamstrahlung or beamspread                 //
*//   and is done at the very end of generation, after m.el. calculation      //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'KK2f.h'
      DOUBLE PRECISION  exe
      INTEGER           j,k
      DOUBLE PRECISION  ph(4)
*
      IF( exe.EQ. 1d0) RETURN
      CALL KinLib_Boost(3,exe,m_p1,m_p1)
      CALL KinLib_Boost(3,exe,m_p2,m_p2)
      CALL KinLib_Boost(3,exe,m_q1,m_q1)
      CALL KinLib_Boost(3,exe,m_q2,m_q2)
      DO j=1,m_nphot
         DO k=1,4
            ph(k) = m_sphot(j,k)
         ENDDO
         CALL KinLib_Boost(3,exe,ph,ph)
         DO k=1,4
            m_sphot(j,k) = ph(k)
         ENDDO
      ENDDO
      END
      FUNCTION LUNPIK(ID,ISGN)
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      REAL*4  XIO(1)
      IDENT=ID*ISGN
      IF      (IDENT.EQ. 1) THEN
        IPKDEF=-211
      ELSEIF  (IDENT.EQ.-1) THEN
        IPKDEF= 211
      ELSEIF  (IDENT.EQ. 2) THEN
        IPKDEF=111
      ELSEIF  (IDENT.EQ.-2) THEN
        IPKDEF=111
      ELSEIF  (IDENT.EQ. 3) THEN
        IPKDEF=-321
      ELSEIF  (IDENT.EQ.-3) THEN
        IPKDEF= 321
      ELSEIF  (IDENT.EQ. 4) THEN
*
* K0 --> K0_LONG (IS 130) / K0_SHORT (IS 310) = 1/1
        CALL RANMAR(XIO,1)
        IF (XIO(1).GT.BRK0) THEN
          IPKDEF= 130
        ELSE
          IPKDEF= 310
        ENDIF
      ELSEIF  (IDENT.EQ.-4) THEN
*
* K0B--> K0_LONG (IS 130) / K0_SHORT (IS 310) = 1/1
        CALL RANMAR(XIO,1)
        IF (XIO(1).GT.BRK0B) THEN
          IPKDEF= 130
        ELSE
          IPKDEF= 310
        ENDIF
      ELSEIF  (IDENT.EQ. 8) THEN
        IPKDEF= 22
      ELSEIF  (IDENT.EQ.-8) THEN
        IPKDEF= 22
      ELSEIF  (IDENT.EQ. 9) THEN
        IPKDEF= 221
      ELSEIF  (IDENT.EQ.-9) THEN
        IPKDEF= 221
      ELSE
        PRINT *, 'STOP IN IPKDEF, WRONG IDENT=',IDENT
        STOP
      ENDIF
      LUNPIK=IPKDEF
      END


      DOUBLE PRECISION FUNCTION Mathlib_dilogy(x)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// dilogarithm FUNCTION: dilog(x)=int( -ln(1-z)/z ) , 0 < z < x .           //
*// this is the cernlib version.                                             //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION x
* locals
      DOUBLE PRECISION a,b,s,t,y,z
*------------------------------------------------------------------------------
      z=-1.644934066848226d0
      IF(x  .LT. -1.d0) go to 1
      IF(x  .LE.  0.5d0) go to 2
      IF(x  .EQ.  1.d0) go to 3
      IF(x  .LE.  2.d0) go to 4
      z=3.289868133696453d0
    1 t=1.d0/x
      s=-0.5d0
      z=z-0.5d0*dlog(dabs(x))**2
      go to 5
    2 t=x
      s=0.5d0
      z=0.d0
      go to 5
    3 Mathlib_Dilogy=1.644934066848226d0
      RETURN
    4 t=1.d0-x
      s=-0.5d0
      z=1.644934066848226d0-dlog(x)*dlog(dabs(t))
    5 y=2.666666666666667d0*t+0.666666666666667d0
      b=      0.000000000000001d0
      a=y*b  +0.000000000000004d0
      b=y*a-b+0.000000000000011d0
      a=y*b-a+0.000000000000037d0
      b=y*a-b+0.000000000000121d0
      a=y*b-a+0.000000000000398d0
      b=y*a-b+0.000000000001312d0
      a=y*b-a+0.000000000004342d0
      b=y*a-b+0.000000000014437d0
      a=y*b-a+0.000000000048274d0
      b=y*a-b+0.000000000162421d0
      a=y*b-a+0.000000000550291d0
      b=y*a-b+0.000000001879117d0
      a=y*b-a+0.000000006474338d0
      b=y*a-b+0.000000022536705d0
      a=y*b-a+0.000000079387055d0
      b=y*a-b+0.000000283575385d0
      a=y*b-a+0.000001029904264d0
      b=y*a-b+0.000003816329463d0
      a=y*b-a+0.000014496300557d0
      b=y*a-b+0.000056817822718d0
      a=y*b-a+0.000232002196094d0
      b=y*a-b+0.001001627496164d0
      a=y*b-a+0.004686361959447d0
      b=y*a-b+0.024879322924228d0
      a=y*b-a+0.166073032927855d0
      a=y*a-b+1.935064300869969d0
      Mathlib_Dilogy = s*t*(a-b)+z
      END


      DOUBLE PRECISION FUNCTION Mathlib_dpgamm(z)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//            Double precision gamma function                               //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION z,z1,x,x1,x2,d1,d2,s1,s2,s3,pi,c(20),const
      SAVE c,pi,const
      DATA c( 1) / 8.3333333333333333333333333332d-02/
      DATA c( 2) /-2.7777777777777777777777777777d-03/
      DATA c( 3) / 7.9365079365079365079365079364d-04/
      DATA c( 4) /-5.9523809523809523809523809523d-04/
      DATA c( 5) / 8.4175084175084175084175084175d-04/
      DATA c( 6) /-1.9175269175269175269175269175d-03/
      DATA c( 7) / 6.4102564102564102564102564102d-03/
      DATA c( 8) /-2.9550653594771241830065359477d-02/
      DATA c( 9) / 1.7964437236883057316493849001d-01/
      DATA c(10) /-1.3924322169059011164274322169d+00/
      DATA c(11) / 1.3402864044168391994478951001d+01/
      DATA c(12) /-1.5684828462600201730636513245d+02/
      DATA c(13) / 2.1931033333333333333333333333d+03/
      DATA c(14) /-3.6108771253724989357173265219d+04/
      DATA c(15) / 6.9147226885131306710839525077d+05/
      DATA c(16) /-1.5238221539407416192283364959d+07/
      DATA c(17) / 3.8290075139141414141414141414d+08/
      DATA c(18) /-1.0882266035784391089015149165d+10/
      DATA c(19) / 3.4732028376500225225225225224d+11/
      DATA c(20) /-1.2369602142269274454251710349d+13/
      DATA pi    / 3.1415926535897932384626433832d+00/
      DATA const / 9.1893853320467274178032973641d-01/
      IF(z .GT. 5.75d 1)                                     GOTO  6666
      nn = z
      IF (z  -  dble(float(nn)))                 3,1,3
    1 IF (z     .LE.     0.d 0)                    GOTO 6667
      Mathlib_dpgamm = 1.d 0
      IF (z     .LE.     2.d 0)                    RETURN
      z1 = z
    2 z1 = z1  -  1.d 0
      Mathlib_dpgamm = Mathlib_dpgamm * z1
      IF (z1  -  2.d 0)                          61,61,2
    3 IF (dabs(z)     .LT.     1.d-29)             GOTO 60
      IF (z     .LT.     0.d 0)                    GOTO 4
      x  = z
      kk = 1
      GOTO 10
    4 x  = 1.d 0  -  z
      kk = 2
   10 x1 = x
      IF (x     .GT.     19.d 0)                   GOTO 13
      d1 = x
   11 x1 = x1  +  1.d 0
      IF (x1     .GE.     19.d 0)                  GOTO 12
      d1 = d1 * x1
      GOTO 11
   12 s3 = -dlog(d1)
      GOTO 14
   13 s3 = 0.d 0
   14 d1 = x1 * x1
      s1 = (x1  -  5.d-1) * dlog(x1)  -  x1  +  const
      DO 20                  k=1,20
      s2 = s1  +  c(k)/x1
      IF (dabs(s2  -  s1)     .LT.     1.d-28)     GOTO 21
      x1 = x1 * d1
   20 s1 = s2
   21 s3 = s3  +  s2
      GOTO (50,22),    kk
   22 d2 = dabs(z  -  nn)
      d1 = d2 * pi
      IF (d1     .LT.     1.d-15)                  GOTO 31
   30 x2 =  dlog(pi/dsin(d1))  -  s3
      GOTO 40
   31 x2 = -dlog(d2)
   40 mm = dabs(z)
      IF(x2       .GT.       1.74d2)                  GOTO 6666
      Mathlib_dpgamm = dexp(x2)
      IF (mm    .ne.    (mm/2) * 2)              RETURN
      Mathlib_dpgamm = -Mathlib_dpgamm
      RETURN
   50 IF(s3       .GT.       1.74d2)                  GOTO 6666
      Mathlib_dpgamm = dexp(s3)
      RETURN
 6666 print *, 2000
      RETURN
 6667 print *, 2001
      RETURN
   60 Mathlib_dpgamm = 0.d 0
      IF(dabs(z)    .LT.    1.d-77)   RETURN
      Mathlib_dpgamm = 1.d 0/z
   61 RETURN
 2000 FORMAT (/////, 2x, 32hdpgamm ..... argument too large., /////)
 2001 FORMAT (/////, 2x, 32hdpgamm ..... argument is a pole., /////)
      END

      SUBROUTINE Mathlib_Gaus16(fun,aa,bb,result)
*//////////////////////////////////////////////////////////////////////////////
*//   12-point Gauss                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  fun,aa,bb,result
      EXTERNAL fun
      DOUBLE PRECISION  a,b,sum16,xmidle,range,xplus,xminu
      INTEGER           k,i
      DOUBLE PRECISION  wg(8),xx(8)
      DATA wg              /0.027152459411754d0, 0.062253523938648d0,
     $ 0.095158511682493d0, 0.124628971255534d0, 0.149595988816577d0,
     $ 0.169156519395003d0, 0.182603415044924d0, 0.189450610455069d0/
      DATA xx              /0.989400934991650d0, 0.944575023073233d0,
     $ 0.865631202387832d0, 0.755404408355003d0, 0.617876244402644d0,
     $ 0.458016777657227d0, 0.281603550779259d0, 0.095012509837637d0/
*-------------------------------------------------------------------------------
      a  = aa
      b  = bb
      xmidle= 0.5d0*(a+b)
      range = 0.5d0*(b-a)
      sum16 =0d0
      DO i=1,8
         xplus= xmidle+range*xx(i)
         xminu= xmidle-range*xx(i)
         sum16 =sum16  +(fun(xplus)+fun(xminu))*wg(i)/2d0
      ENDDO
      result = sum16*(b-a)
      END



      SUBROUTINE Mathlib_Gaus8(fun,aa,bb,result)
*//////////////////////////////////////////////////////////////////////////////
*//   8-point Gauss                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  fun,aa,bb,result
      EXTERNAL fun
      DOUBLE PRECISION  a,b,sum8,xmidle,range,xplus,xminu
      INTEGER           k,i
      DOUBLE PRECISION  wg(4),xx(4)
      DATA wg /0.101228536290376d0, 0.222381034453374d0, 0.313706645877887d0, 0.362683783378362d0/
      DATA xx /0.960289856497536d0, 0.796666477413627d0, 0.525532409916329d0, 0.183434642495650d0/
*-------------------------------------------------------------------------------
      a  = aa
      b  = bb
      xmidle= 0.5d0*(a+b)
      range = 0.5d0*(b-a)
      sum8 =0d0
      DO i=1,4
         xplus= xmidle+range*xx(i)
         xminu= xmidle-range*xx(i)
         sum8 =sum8  +(fun(xplus)+fun(xminu))*wg(i)/2d0
      ENDDO
      result = sum8*(b-a)
      END


*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  GLK                                   //
*//////////////////////////////////////////////////////////////////////////////

 
*//////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                              //
*//                                                                                              //
*//                     Pseudo-CLASS  Mathlib                                                    //
*//                                                                                              //
*//      Purpose:  library of math utilies                                                       //
*//                                                                                              //
*//      SUBROUTINE Mathlib_GausJad(fun,aa,bb,eeps,result)     : Gauss integration               //
*//      DOUBLE PRECISION FUNCTION Mathlib_Gauss(f,a,b,eeps)   : Gauss integration               //
*//      DOUBLE PRECISION FUNCTION Mathlib_dilogy(x)           : Dilog function Li_2             //
*//      DOUBLE PRECISION FUNCTION Mathlib_dpgamm(z)           : Euler Gamma function            //
*//                                                                                              //
*//////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE Mathlib_GausJad(fun,aa,bb,eeps,result)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  Gauss-type integration by S. Jadach, Oct. 1990, June 1997               //
*//  this is non-adaptive (!!!!) unoptimized (!!!) integration subprogram.   //
*//                                                                          //
*//  Eeps>0 treated as ABSOLUTE requested error                              //
*//  Eeps<0 treated as RELATIVE requested error                              //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      DOUBLE PRECISION  fun,aa,bb,eeps,result
      EXTERNAL fun
*
      DOUBLE PRECISION  a,b,xplus,sum16,range,sum8,erabs,erela,fminu,xminu
      DOUBLE PRECISION  fplus,xmidle,calk8,eps,x1,x2,delta,calk16
      INTEGER           iter,ndivi,itermx,k,i
      DOUBLE PRECISION  wg(12),xx(12)
      DATA wg
     $/0.101228536290376d0, 0.222381034453374d0, 0.313706645877887d0,
     $ 0.362683783378362d0, 0.027152459411754d0, 0.062253523938648d0,
     $ 0.095158511682493d0, 0.124628971255534d0, 0.149595988816577d0,
     $ 0.169156519395003d0, 0.182603415044924d0, 0.189450610455069d0/
      DATA xx
     $/0.960289856497536d0, 0.796666477413627d0, 0.525532409916329d0,
     $ 0.183434642495650d0, 0.989400934991650d0, 0.944575023073233d0,
     $ 0.865631202387832d0, 0.755404408355003d0, 0.617876244402644d0,
     $ 0.458016777657227d0, 0.281603550779259d0, 0.095012509837637d0/
      DATA itermx / 15/
*-------------------------------------------------------------------------------
      a  = aa
      b  = bb
      eps= ABS(eeps)
      ndivi=1
*** iteration over subdivisions terminated by precision requirement
      DO iter=1,itermx
         calk8  =0d0
         calk16 =0d0
***   sum over delta subintegrals
         DO k = 1,ndivi
            delta = (b-a)/ndivi
            x1    =  a + (k-1)*delta
            x2    =  x1+ delta
            xmidle= 0.5d0*(x2+x1)
            range = 0.5d0*(x2-x1)
            sum8 =0d0
            sum16=0d0
***   8- and 12-point   gauss integration over single delta subinterval
            DO i=1,12
               xplus= xmidle+range*xx(i)
               xminu= xmidle-range*xx(i)
               fplus=fun(xplus)
               fminu=fun(xminu)
               IF(i .LE. 4) THEN
                  sum8 =sum8  +(fplus+fminu)*wg(i)/2d0
               ELSE
                  sum16=sum16 +(fplus+fminu)*wg(i)/2d0
               ENDIF
            ENDDO
            calk8 = calk8 + sum8 *(x2-x1)
            calk16= calk16+ sum16*(x2-x1)
         ENDDO
         erabs = ABS(calk16-calk8)
         erela = 0d0
         IF(calk16 .NE. 0d0) erela= erabs/ABS(calk16)
***   WRITE(*,*) 'gausjad: calk8,calk16=',iter,calk8,calk16,erela
***   precision check to terminate integration
         IF(eeps .GT. 0d0) THEN
            IF(erabs .LT.  eps) GOTO 800
         ELSE
            IF(erela .LT.  eps) GOTO 800
         ENDIF
         ndivi=ndivi*2
      ENDDO
      WRITE(*,*) '++++ Mathlib_GausJad: required precision to high!'
      WRITE(*,*) '++++ Mathlib_GausJad: eeps,erela,erabs=',eeps,erela,erabs
  800 CONTINUE
      result = calk16
      END


      DOUBLE PRECISION FUNCTION Mathlib_Gauss(f,a,b,eeps)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// this is iterative integration procedure                                  //
*// originates  probably from cern library                                   //
*// it subdivides inegration range until required PRECISION is reached       //
*// PRECISION is a difference from 8 and 16 point gauss itegr. result        //
*// eeps positive treated as absolute PRECISION                              //
*// eeps negative treated as relative PRECISION                              //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  f,a,b,eeps
*
      DOUBLE PRECISION  c1,c2,bb,s8,s16,y,aa,const,delta,eps,u
      INTEGER           i
*
      DOUBLE PRECISION  w(12),x(12)
      EXTERNAL f
      DATA const /1.0d-19/
      DATA w
     1/0.10122 85362 90376, 0.22238 10344 53374, 0.31370 66458 77887,
     2 0.36268 37833 78362, 0.02715 24594 11754, 0.06225 35239 38648,
     3 0.09515 85116 82493, 0.12462 89712 55534, 0.14959 59888 16577,
     4 0.16915 65193 95003, 0.18260 34150 44924, 0.18945 06104 55069/
      DATA x
     1/0.96028 98564 97536, 0.79666 64774 13627, 0.52553 24099 16329,
     2 0.18343 46424 95650, 0.98940 09349 91650, 0.94457 50230 73233,
     3 0.86563 12023 87832, 0.75540 44083 55003, 0.61787 62444 02644,
     4 0.45801 67776 57227, 0.28160 35507 79259, 0.09501 25098 37637/
*-----------------------------------------------------------------------------
      eps=abs(eeps)
      delta=const*abs(a-b)
      Mathlib_Gauss=0d0
      aa=a
    5 y=b-aa
      IF(abs(y)  .LE.  delta) RETURN
    2 bb=aa+y
      c1=0.5d0*(aa+bb)
      c2=c1-aa
      s8=0d0
      s16=0d0
      DO 1 i=1,4
      u=x(i)*c2
    1 s8=s8+w(i)*(f(c1+u)+f(c1-u))
      DO 3 i=5,12
      u=x(i)*c2
    3 s16=s16+w(i)*(f(c1+u)+f(c1-u))
      s8=s8*c2
      s16=s16*c2
      IF(eeps .LT. 0d0) THEN
        IF(abs(s16-s8)  .GT.  eps*abs(s16)) GOTO 4
      ELSE
        IF(abs(s16-s8)  .GT.  eps) GOTO 4
      ENDIF
      Mathlib_Gauss=Mathlib_Gauss+s16
      aa=bb
      GOTO 5
    4 y=0.5d0*y
      IF(abs(y)  .GT.  delta) GOTO 2
      WRITE(*,7)
      Mathlib_Gauss=0d0
      RETURN
    7 FORMAT(1x,36hgaus  ... too high accuracy required)
      END

      SUBROUTINE MBrA_AddBranch(KF,Nbin,WTmax,Title)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Register one branch in the system                                      //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER KF,Nbin
      CHARACTER*(*) Title
      DOUBLE PRECISION  WTmax
      INCLUDE 'MBrA.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      DO i=1,m_Ntot
         IF(KF .EQ. m_KFlist(i)) CALL MBrA_Stoper(
     $        'MBrA_AddBranch: KF code already defined KF=',KF)
      ENDDO
*
      m_Ntot=m_Ntot+1

      IF(m_Ntot .GT. m_MaxBra) CALL MBrA_Stoper(
     $     'MBrA_AddBranch: Too many branches, MaxBra= ',m_MaxBra)
*-----------------------------------------------------------------------
      m_KFlist(m_Ntot)=KF
      m_WMList( m_Ntot)=WTmax
      CALL GLK_Mbook(m_idMBR+m_Ntot,Title, Nbin, 1d0)
      END                       ! MBrA_AddBranch

      SUBROUTINE MBrA_Fill(Wt,Rn)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  Wt,Rn
      INCLUDE 'MBrA.h'
      SAVE
*-----------------------------------------------------------------------
      CALL GLK_Mfill(m_idMBR, Wt, Rn)
      CALL GLK_Mfill(m_idMBR +m_IDlast, Wt,   Rn)
      END


      SUBROUTINE MBrA_GenKF(KF,Wt_KF)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Generate KF (and branch ID)                                             //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrA.h'
      SAVE
      INTEGER  KF,ID
      DOUBLE PRECISION    Wt_KF
      DOUBLE PRECISION    cumuKF(m_MaxBra)
      DOUBLE PRECISION    sum,rnumb
      REAL                rvec(10)
      INTEGER  i
*-----------------------------------------------------------------------
      Wt_KF = 1d0
      CALL PseuMar_MakeVec(rvec,1)
      rnumb = rvec(1)
*
      sum=0d0
      DO i=1,m_Ntot
         sum = sum +m_XsList(i)*m_WMList(i)
         cumuKF(i)= sum
      ENDDO
*
      IF(sum .EQ. 0d0 ) GOTO 900
      DO i=1,m_Ntot
         cumuKF(i)=cumuKF(i)/sum
      ENDDO
*
      DO i=1,m_Ntot
         IF(rnumb .LE. cumuKF(i)) THEN
            KF = m_KFList(i)
            ID = i
            GOTO 500
         ENDIF
      ENDDO
      CALL MBrA_Stoper('MBrA_GenKF: unable to define KF !!! ',-1)
*-----------------------------------------------------------------------
 500  CONTINUE
      Wt_KF = 1d0/m_WMList(ID)  ! compensating weight
      m_KFlast = KF             ! memorize generated KFcode
      m_IDlast = ID             ! memorize generated ID
      RETURN
*
 900  CONTINUE
      WRITE(*,*) '+++ MBrA_GenKF: STOP, sum=0'
      STOP
      END ! MBrA_GenKF

      SUBROUTINE MBrA_GetKF(KF)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER ID,KF
      INCLUDE 'MBrA.h'
      SAVE
*-----------------------------------------------------------------------
      KF = m_KFlast
      END

      SUBROUTINE MBrA_GetKFlist(Ntot,KFlist)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER Ntot, KFlist(*)
      INCLUDE 'MBrA.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      Ntot = m_Ntot
      DO i=1,m_Ntot
         KFlist(i) = m_KFlist(i)
      ENDDO
      END

      SUBROUTINE MBrA_GetWMList(Ntot,WMList)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER Ntot
      DOUBLE PRECISION   WMList(*)
      INCLUDE 'MBrA.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      Ntot = m_Ntot
      DO i=1,m_Ntot
         WMList(i) = m_WMList(i)
      ENDDO
      END

      SUBROUTINE MBrA_GetXCrude(XCrude)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   get total crude integral, for normalization purpose                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrA.h'
      DOUBLE PRECISION   XCrude
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      XCrude=0d0
      DO i=1,m_Ntot
         XCrude= XCrude + m_Xslist(i)*m_WMlist(i)
      ENDDO
      END

*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                Pseudo-CLASS  MBrA (Multi-Brancher)                       //
*//                                                                          //
*//   Purpose: Manage general multi-branched Monte Carlo algorithm           //
*//                                                                          //
*//   MBrA is capable to:                                                    //
*//    -register arbitrary number of branches                                //
*//    -keep track of elaborate MC statistics for each branch                //
*//    -generate randomly branch index                                       //
*//    -prowide useful averages and counts at the end of the run             //
*//    -print out statistics at the ned of the run                           //
*//   It is using tools from GLK library for weight monitoring               //
*//                                                                          //
*//  Xslist(i) = list of crude xsections without WTmax used in GenKF,        //
*//  Probablitity of branch(i) = XsList(i)*WTmax(i)*Normalization            //
*//                                                                          //
*//  Entries:                                                                //
*//      Global initialization:                                              //
*//  MBrA_Initialize(Nout, m_idMBrA, Nbin, WTmax, Title)                     //
*//  MBrA_AddBranch(KF,Nbin,WTmax,Title)    add branch i with name KF        //
*//      Event generation:                                                   //
*//  MBrA_SetXSList(XsList)                 set list of Xs Crude, see above  //
*//  MBrA_GenKF(KF,Wt_KF)                   generate KF                      //
*//  MBrA_GetKF(KF)                         get generated KF                 //
*//  MBrA_Fill(Wt,Rn)                       fill statistics                  //
*//      Global finalization:                                                //
*//  MBrA_MgetAve(AverWt, ErRela, WtSup)    get average total weight         //
*//  MBrA_Print0                            small final printout             //
*//  MBrA_Print1                            detailed final printout          //
*//      Tools:                                                              //
*//  MBrA_GetWMList(Ntot,WMList)            get list of WMlist(i)=WTmax(i)   //
*//  MBrA_GetKFlist(Ntot,KFlist)            get list of KF names             //
*//  MBrA_Stoper(mesage,id)                 miscelaneous                     //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*
      SUBROUTINE MBrA_Initialize(Nout,idMBR,Nbin,WTmax,Title)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Basic initialization:                                                  //
*//   Nout  = output unit number                                             //
*//   idMBR = pointer for histograming                                       //
*//   Nbin  = number of bins for main weight                                 //
*//   WTmax = maximum weight for main weight                                 //
*//   Title = title of the branch system/main weight                         //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER idMBR,Nout,Nbin
      CHARACTER*(*) Title
      DOUBLE PRECISION  WTmax
      INCLUDE 'MBrA.h'
      SAVE
      INTEGER i
*---------------------------------
      m_out   = Nout
      m_idMBR = idMBR
      m_Ntot  = 0
      DO i=1,m_MaxBra
         m_KFlist(i) =0
         m_XSlist(i) =0d0
         m_WMList(i) =0d0
      ENDDO
      CALL GLK_Mbook(m_idMBR,Title, Nbin, WTmax)
      END

      SUBROUTINE MBrA_MgetAve(AverWt, ErRela, WtSup)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      INCLUDE 'MBrA.h'
      DOUBLE PRECISION          AverWt, ErRela, WtSup
      CALL GLK_MgetAve(m_idMBR, AverWt, ErRela, WtSup)
      END

      SUBROUTINE MBrA_Print0
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'MBrA.h'
      SAVE
      DOUBLE PRECISION    AveWt, ERela, WTsup, AvUnd, AvOve
      INTEGER  Ntot,Nacc,Nneg,Nove,Nzer
      DOUBLE PRECISION    ROverf, RUnder
      INTEGER  i
*-----------------------------------------------------------------------
      CALL GLK_Mprint( m_idMBR)
      CALL GLK_MgetAll(m_idMBR,
     $     AveWt, ERela, WtSup, AvUnd, AvOve,
     $     Ntot, Nacc, Nneg, Nove, Nzer)
      
      ROverf = AvOve/AveWt
      RUnder = AvUnd/AveWt

      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) ' MBrA: report on the main Weight '
      WRITE(m_out,bxl1i) Ntot,      'no of raw events   ','Ntot  ',' b1'
      WRITE(m_out,bxl1i) Nacc,      'accepted    events ','Nacc  ',' b2'
      WRITE(m_out,bxl1i) Nneg,      'wt<0        events ','Nneg  ',' b3'
      WRITE(m_out,bxl1i) Nove,      'wt>WTmax    events ','Nove  ',' b4'
      WRITE(m_out,bxl1f) WTsup ,    'WTsup, largest WT  ','WTsup ',' b5'
      WRITE(m_out,bxl1f) AvOve ,    '<Wt-WtMax>  Overfl.','AvOve ',' b6'
      WRITE(m_out,bxl1f) AvUnd ,    '<Wt> for Wt<0      ','AvUnd ',' b7'
      WRITE(m_out,bxl1f) ROverf,    'AvOve/<Wt>,WT>WtMax','ROverf',' b8'
      WRITE(m_out,bxl1f) RUnder,    'AvUnd/<Wt>,Wt<0    ','RUnder',' b9'
      WRITE(m_out,bxclo)
      END

      SUBROUTINE MBrA_Print1
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'MBrA.h'
      SAVE
      DOUBLE PRECISION  AveWt, ERela, WTsup, AvUnd, AvOve
      INTEGER  Ntot,Nacc,Nneg,Nove,Nzer
      INTEGER  i, KF
      DOUBLE PRECISION  Overf, Under
*-----------------------------------------------------------------------
      
***      DO i=1,m_Ntot
***         CALL GLK_Mprint( m_idMBR+i)
***      ENDDO

      WRITE(m_out,'(a)') ' '
      WRITE(m_out,'(2a)') '=============',
     $ '========================================================================================'
      WRITE(m_out,'(a)') '            MBrA:    Detailed statistics for all branches    '
      WRITE(m_out,'(2a)') '=============',
     $ '========================================================================================'

      WRITE(m_out,'(a4, 2a10,a10,2a10,2a11,3a7)') 
     $     'KF',
     $     'AveWt', 'ERela', 'WtSup', 'Wt<0', 'Wt>Wmax',
     $     'Ntot', 'Nacc', 'Nneg', 'Nove', 'Nzer'
*--------- chanel by chanel
      DO i= 1,m_Ntot
         KF=m_KFList(i)
         CALL GLK_MgetAll(m_idMBR+i,
     $        AveWt, ERela, WtSup, AvUnd, AvOve,
     $        Ntot, Nacc, Nneg, Nove, Nzer)
         Under = AvUnd/AveWt
         Overf = AvOve/AveWt
         WRITE(m_out,'(I4,2f10.6,g10.4,2f10.6,2i11,3i7)')
     $        KF,
     $        AveWt, ERela, WtSup, Under, Overf,
     $        Ntot, Nacc, Nneg, Nove, Nzer
      ENDDO
*-------- all chanels
      CALL GLK_MgetAll(m_idMBR,
     $     AveWt, ERela, WtSup, AvUnd, AvOve,
     $     Ntot, Nacc, Nneg, Nove, Nzer)
      Under = AvUnd/AveWt
      Overf = AvOve/AveWt
      WRITE(m_out,'(a4,2f10.6,g10.4,2f10.6,2i11,3i7)')
     $     'All:',
     $     AveWt, ERela, WtSup, Under, Overf,
     $     Ntot, Nacc, Nneg, Nove, Nzer

      WRITE(m_out,'(2a)')  '=============',
     $ '========================================================================================'

      END

      SUBROUTINE MBrA_SetXSList(XsList)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrA.h'
      DOUBLE PRECISION   XsList(*)
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      DO i=1,m_Ntot
         m_Xslist(i) = XsList(i)
      ENDDO
      END



      SUBROUTINE MBrA_Stoper(mesage,id)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrA.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(m_out,'(a)')'++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(m_out,'(a,a,i10,a)') '+++ ',   mesage, id,    ' +++'
      WRITE(m_out,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6    ,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6    ,'(a,a,i10,a)') '+++ ',   mesage, id,    ' +++'
      WRITE(6    ,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END

      SUBROUTINE MBrB_AddBranch(KF,Nbin,WTmax,Title)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Register one branch in the system                                      //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER KF,Nbin
      CHARACTER*(*) Title
      DOUBLE PRECISION  WTmax
      INCLUDE 'MBrB.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      DO i=1,m_Ntot
         IF(KF .EQ. m_KFlist(i)) CALL MBrB_Stoper('MBrB_AddBranch: KF code already defined KF=',KF)
      ENDDO
*
      m_Ntot=m_Ntot+1
      IF(m_Ntot .GT. m_MaxBra) CALL MBrB_Stoper(
     $     'MBrB_AddBranch: Too many branches, MaxBra= ',m_MaxBra)
*-----------------------------------------------------------------------
      m_KFlist(m_Ntot)=KF
      m_WMList( m_Ntot)=WTmax
      CALL GLK_Mbook(m_idMBR+m_Ntot,Title, Nbin, 50d0)
      END                       ! MBrB_AddBranch

      SUBROUTINE MBrB_Fill(Wt,Rn)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  Wt,Rn
      INCLUDE 'MBrB.h'
      SAVE
*-----------------------------------------------------------------------
      CALL GLK_Mfill(m_idMBR, Wt, Rn)
      CALL GLK_Mfill(m_idMBR +m_IDlast, Wt,   Rn)
      END


      SUBROUTINE MBrB_GenKF(KF,Wt_KF)
*///////////////////////////////////////////////////////////////////////////////
*//                                                                           //
*//   Generate KF (and branch ID)                                             //
*//                                                                           //
*///////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrB.h'
      SAVE
      INTEGER  KF,ID
      DOUBLE PRECISION    Wt_KF
      DOUBLE PRECISION    cumuKF(m_MaxBra)
      DOUBLE PRECISION    sum,rnumb
      REAL                rvec(10)
      INTEGER  i
*-----------------------------------------------------------------------
      Wt_KF = 1d0
      CALL PseuMar_MakeVec(rvec,1)
      rnumb = rvec(1)
*
      sum=0d0
      DO i=1,m_Ntot
         sum = sum +m_XsList(i)*m_WMList(i)
         cumuKF(i)= sum
      ENDDO
*
      IF(sum .EQ. 0d0 ) GOTO 900
      DO i=1,m_Ntot
         cumuKF(i)=cumuKF(i)/sum
      ENDDO
*
      DO i=1,m_Ntot
         IF(rnumb .LE. cumuKF(i)) THEN
            KF = m_KFList(i)
            ID = i
            GOTO 500
         ENDIF
      ENDDO
      CALL MBrB_Stoper('MBrA_GenKF: unable to define KF !!! ',-1)
*-----------------------------------------------------------------------
 500  CONTINUE
      Wt_KF = 1d0/m_WMList(ID)  ! compensating weight
      m_KFlast = KF             ! memorize generated KFcode
      m_IDlast = ID             ! memorize generated ID
      RETURN
*
 900  CONTINUE
      WRITE(*,*) '+++ MBrB_GenKF: STOP, sum=0'
      STOP
      END ! MBrB_GenKF

      SUBROUTINE MBrB_GetKF(KF)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER ID,KF
      INCLUDE 'MBrB.h'
      SAVE
*-----------------------------------------------------------------------
      KF = m_KFlast
      END

      SUBROUTINE MBrB_GetKFlist(Ntot,KFlist)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER Ntot, KFlist(*)
      INCLUDE 'MBrB.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      Ntot = m_Ntot
      DO i=1,m_Ntot
         KFlist(i) = m_KFlist(i)
      ENDDO
      END

      SUBROUTINE MBrB_GetWMList(Ntot,WMList)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER Ntot
      DOUBLE PRECISION   WMList(*)
      INCLUDE 'MBrB.h'
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      Ntot = m_Ntot
      DO i=1,m_Ntot
         WMList(i) = m_WMList(i)
      ENDDO
      END

      SUBROUTINE MBrB_GetXCrude(XCrude)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   get total crude integral, for normalization purpose                    //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrB.h'
      DOUBLE PRECISION   XCrude
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      XCrude=0d0
      DO i=1,m_Ntot
         XCrude= XCrude + m_Xslist(i)*m_WMlist(i)
      ENDDO
      END

*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  MBrA                                  //
*//////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                Pseudo-CLASS  MBrB (Multi-Brancher)                       //
*//                                                                          //
*//   Purpose: Manage general multi-branched Monte Carlo algorithm           //
*//                                                                          //
*//   MBrB is capable to:                                                    //
*//    -register arbitrary number of branches                                //
*//    -keep track of elaborate MC statistics for each branch                //
*//    -generate randomly branch index                                       //
*//    -prowide useful averages and counts at the end of the run             //
*//    -print out statistics at the ned of the run                           //
*//   It is using tools from GLK library for weight monitoring               //
*//                                                                          //
*//  Xslist(i) = list of crude xsections without WTmax used in GenKF,        //
*//  Probablitity of branch(i) = XsList(i)*WTmax(i)*Normalization            //
*//                                                                          //
*//  Entries:                                                                //
*//      Global initialization:                                              //
*//  MBrB_Initialize(Nout, m_idMBrA, Nbin, WTmax, Title)                     //
*//  MBrB_AddBranch(KF,Nbin,WTmax,Title)    add branch i with name KF        //
*//      Event generation:                                                   //
*//  MBrB_SetXSList(XsList)                 set list of Xs Crude, see above  //
*//  MBrB_GenKF(KF,Wt_KF)                   generate KF                      //
*//  MBrB_GetKF(KF)                         get generated KF                 //
*//  MBrB_Fill(Wt,Rn)                       fill statistics                  //
*//      Global finalization:                                                //
*//  MBrB_MgetAve(AverWt, ErRela, WtSup)    get average total weight         //
*//  MBrB_Print0                            small final printout             //
*//  MBrB_Print1                            detailed final printout          //
*//      Tools:                                                              //
*//  MBrB_GetWMList(Ntot,WMList)            get list of WMlist(i)=WTmax(i)   //
*//  MBrB_GetKFlist(Ntot,KFlist)            get list of KF names             //
*//  MBrB_Stoper(mesage,id)                 miscelaneous                     //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*
      SUBROUTINE MBrB_Initialize(Nout,idMBR,Nbin,WTmax,Title)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Basic initialization:                                                  //
*//   Nout  = output unit number                                             //
*//   idMBR = pointer for histograming                                       //
*//   Nbin  = number of bins for main weight                                 //
*//   WTmax = maximum weight for main weight                                 //
*//   Title = title of the branch system/main weight                         //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER idMBR,Nout,Nbin
      CHARACTER*(*) Title
      DOUBLE PRECISION  WTmax
      INCLUDE 'MBrB.h'
      SAVE
      INTEGER i
*---------------------------------
      m_out   = Nout
      m_idMBR = idMBR
      m_Ntot  = 0
      DO i=1,m_MaxBra
         m_KFlist(i) =0
         m_XSlist(i) =0d0
         m_WMList(i) =0d0
      ENDDO
      CALL GLK_Mbook(m_idMBR,Title, Nbin, WTmax)
      END

      SUBROUTINE MBrB_MgetAve(AverWt, ErRela, WtSup)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      INCLUDE 'MBrB.h'
      DOUBLE PRECISION          AverWt, ErRela, WtSup
      CALL GLK_MgetAve(m_idMBR, AverWt, ErRela, WtSup)
      END

      SUBROUTINE MBrB_Print0
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'MBrB.h'
      SAVE
      DOUBLE PRECISION    AveWt, ERela, WTsup, AvUnd, AvOve
      INTEGER  Ntot,Nacc,Nneg,Nove,Nzer
      DOUBLE PRECISION    ROverf, RUnder
      INTEGER  i
*-----------------------------------------------------------------------
      CALL GLK_Mprint( m_idMBR)
      CALL GLK_MgetAll(m_idMBR,
     $     AveWt, ERela, WtSup, AvUnd, AvOve,
     $     Ntot, Nacc, Nneg, Nove, Nzer)
      
      ROverf = AvOve/AveWt
      RUnder = AvUnd/AveWt

      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) ' MBrB: report on the main Weight '
      WRITE(m_out,bxl1i) Ntot,      'no of raw events   ','Ntot  ',' b1'
      WRITE(m_out,bxl1i) Nacc,      'accepted    events ','Nacc  ',' b2'
      WRITE(m_out,bxl1i) Nneg,      'wt<0        events ','Nneg  ',' b3'
      WRITE(m_out,bxl1i) Nove,      'wt>WTmax    events ','Nove  ',' b4'
      WRITE(m_out,bxl1f) WTsup ,    'WTsup, largest WT  ','WTsup ',' b5'
      WRITE(m_out,bxl1f) AvOve ,    '<Wt-WtMax>  Overfl.','AvOve ',' b6'
      WRITE(m_out,bxl1f) AvUnd ,    '<Wt> for Wt<0      ','AvUnd ',' b7'
      WRITE(m_out,bxl1f) ROverf,    'AvOve/<Wt>,WT>WtMax','ROverf',' b8'
      WRITE(m_out,bxl1f) RUnder,    'AvUnd/<Wt>,Wt<0    ','RUnder',' b9'
      WRITE(m_out,bxclo)
      END

      SUBROUTINE MBrB_Print1
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'BXformat.h'
      INCLUDE 'MBrB.h'
      SAVE
      DOUBLE PRECISION  AveWt, ERela, WTsup, AvUnd, AvOve
      INTEGER  Ntot,Nacc,Nneg,Nove,Nzer
      INTEGER  i, KF
      DOUBLE PRECISION  Overf, Under
*-----------------------------------------------------------------------
      
***      DO i=1,m_Ntot
***         CALL GLK_Mprint( m_idMBR+i)
***      ENDDO

      WRITE(m_out,'(a)') ' '
      WRITE(m_out,'(2a)') '=============',
     $ '========================================================================================'
      WRITE(m_out,'(a)') '            MBrB:    Detailed statistics for all branches    '
      WRITE(m_out,'(2a)') '=============',
     $ '========================================================================================'

      WRITE(m_out,'(a4, 2a10,a10,2a10,2a11,3a7)') 
     $     'KF',
     $     'AveWt', 'ERela', 'WtSup', 'Wt<0', 'Wt>Wmax',
     $     'Ntot', 'Nacc', 'Nneg', 'Nove', 'Nzer'
*--------- chanel by chanel
      DO i= 1,m_Ntot
         KF=m_KFList(i)
         CALL GLK_MgetAll(m_idMBR+i,
     $        AveWt, ERela, WtSup, AvUnd, AvOve,
     $        Ntot, Nacc, Nneg, Nove, Nzer)
         Under = AvUnd/AveWt
         Overf = AvOve/AveWt
         WRITE(m_out,'(I4,2f10.6,g10.4,2f10.6,2i11,3i7)')
     $        KF,
     $        AveWt, ERela, WtSup, Under, Overf,
     $        Ntot, Nacc, Nneg, Nove, Nzer
      ENDDO
*-------- all chanels
      CALL GLK_MgetAll(m_idMBR,
     $     AveWt, ERela, WtSup, AvUnd, AvOve,
     $     Ntot, Nacc, Nneg, Nove, Nzer)
      Under = AvUnd/AveWt
      Overf = AvOve/AveWt
      WRITE(m_out,'(a4,2f10.6,g10.4,2f10.6,2i11,3i7)')
     $     'All:',
     $     AveWt, ERela, WtSup, Under, Overf,
     $     Ntot, Nacc, Nneg, Nove, Nzer

      WRITE(m_out,'(2a)')  '=============',
     $ '========================================================================================'

      DO i= 1,m_Ntot
***      CALL GLK_Print(   -(m_idMBR+i))
         CALL MBrB_WtLimit(-(m_idMBR+i))
      ENDDO

      END

      SUBROUTINE MBrB_SetXSList(XsList)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrB.h'
      DOUBLE PRECISION   XsList(*)
      SAVE
      INTEGER i
*-----------------------------------------------------------------------
      DO i=1,m_Ntot
         m_Xslist(i) = XsList(i)
      ENDDO
      END

      SUBROUTINE MBrB_Stoper(mesage,id)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrB.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(m_out,'(a)')'++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(m_out,'(a,a,i10,a)') '+++ ',   mesage, id,    ' +++'
      WRITE(m_out,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6    ,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6    ,'(a,a,i10,a)') '+++ ',   mesage, id,    ' +++'
      WRITE(6    ,'(a)') '+++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END

      SUBROUTINE MBrB_WtLimit(id)
*//////////////////////////////////////////////////////////////////////////////////
*// calculates wtmax for which overflow integral is below epsilon
*// the precision of the result is limited by beam size and statistics
*//////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MBrB.h'
      CHARACTER*80 title
      INTEGER           id,nchx
      DOUBLE PRECISION  xl,xu, Bin
      DOUBLE PRECISION  GLK_hi,sum,sumWt,WtLimit,tail,eps,AveWt,Wt
      INTEGER           ib,ibX
*     ------------------------------------------
      CALL GLK_hinbo1(id,title,nchx,xl,xu)
      eps=1d-4
      sum   = 0d0
      sumWt = 0d0
      DO ib=1,nchx
         Bin = GLK_hi(id,ib)
         Wt = xl+(ib-0.5d0)*(xu-xl)/nchx
         sum   = sum   +Bin
         sumWt = sumWt +Bin*Wt
      ENDDO
      AveWt = sumWt/sum

      DO ibX=nchx,1,-1
         WtLimit =xl+(ibX-0.5d0)*(xu-xl)/nchx
         tail=0d0
         DO ib=ibX,nchx
            Bin = GLK_hi(id,ib)
            Wt = xl+(ib-0.5d0)*(xu-xl)/nchx
            tail=tail+Bin*(Wt-WtLimit) ! deficit of xsection because Wt->WtLimit
         ENDDO
         IF(tail/sum .GT. eps) GOTO 100
      ENDDO
 100  CONTINUE
      WRITE(m_out,*) '-------------------------------------------------------------------------------'
      WRITE(m_out,*) '-->FindWtLimit: content, <Wt>,  WtLimit= ',sum,AveWt,WtLimit
      WRITE(m_out,*) '-->FindWtLimit: EFFICIENCY <Wt>/WtLimit= ',AveWt/WtLimit
      WRITE(    6,*) '-------------------------------------------------------------------------------'
      WRITE(    6,*) '-->FindWtLimit: content, <Wt>,  WtLimit= ',sum,AveWt,WtLimit
      WRITE(    6,*) '-->FindWtLimit: EFFICIENCY <Wt>/WtLimit= ',AveWt/WtLimit
      END                       !!!WtLimit
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                           //
*//                          End of CLASS  KinLib                                                             //
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////
*//                                                                         //
*// Actual version rewritten by S. Jadach, Nov 1997.                        //
*//                                                                         //
*// Universal random number generator proposed by MARSAGLIA and ZAMAN       //
*// in report FSU-SCRI-87-50                                                //
*//        modified by F. James, 1988 and 1989, to generate a vector        //
*//        of pseudorandom numbers rvec of length lenv, and to put in       //
*//        the COMMON block everything needed to specify currrent state,    //
*//        and to add input and output entry points rmarin, rmarut.         //
*// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++   //
*// ++  CALLing sequences for ranmar:                                  ++   //
*// ++      CALL ranmar (rvec, len)   returns a vector rvec of len     ++   //
*// ++                   32-bit random floating point numbers between  ++   //
*// ++                   zero and one.                                 ++   //
*// ++      CALL rmarin(i1,n1,n2)   initializes the generator from one ++   //
*// ++                  32-bit integer i1, and number counts n1,n2     ++   //
*// ++                  (for initializing, set n1=n2=0, but to restart ++   //
*// ++                    a previously generated sequence, use values  ++   //
*// ++                    output by rmarut)                            ++   //
*// ++      CALL rmarut(i1,n1,n2)   outputs the value of the original  ++   //
*// ++                  seed and the two number counts, to be used     ++   //
*// ++                  for restarting by initializing to i1 and       ++   //
*// ++                  skipping n2*100000000+n1 numbers.              ++   //
*// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++   //
*//                                                                         //
*//         Initializing routine for ranmar, may be called before           //
*//         generating pseudorandom numbers with ranmar. the input          //
*//         values should be in the ranges:  0<=ijklin<=900 000 000         //
*//                                          0<=ntotin<=999 999 999         //
*//                                          0<=ntot2n<<999 999 999!        //
*// to get the standard values in MARSAGLIA's paper, ijklin=54217137        //
*//                                            ntotin,ntot2n=0              //
*//                                                                         //
*/////////////////////////////////////////////////////////////////////////////
      SUBROUTINE PseuMar_Initialize(ijkl,ntot,ntot2)
C ----------------------------------------------------
C   this is the interface to RANMAR .... a la ALEPH
C ----------------------------------------------------
      CALL RMARIN(IJKL,NTOT,NTOT2)
      RETURN
      END
      SUBROUTINE PseuMar_MakeVec(rvec,lenv)
C ----------------------------------------------------
C   this is the interface to RANMAR .... a la ALEPH
C ----------------------------------------------------
      REAL              rvec(*)
      INTEGER lenv
      CALL RANMAR(RVEC,LENV)
      RETURN
      END
      SUBROUTINE PseuMar_Out(ijkl, ntot, ntot2)
C ----------------------------------------------------
C   this is the interface to RANMAR .... a la ALEPH
C ----------------------------------------------------
      INTEGER ijkl, ntot, ntot2
*
      CALL RMARUT(ijkl,ntot,ntot2)
      RETURN
      END
      SUBROUTINE OPseuMar_Initialize(ijkl_new, ntot_new,ntot2_new)
*/////////////////////////////////////////////////////////////////////////////
*//                                                                         //
*/////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'PseuMar.h'
      INTEGER ijkl_new, ntot_new, ntot2_new
*
      REAL    t,uni,s
      INTEGER m,i24,jj,idum,loop2,now
      INTEGER i,j,ij,k,l,ii,kl

      m_iwarm = 9000009   ! special mark on initialization

      m_ijkl = ijkl_new
      m_ntot = max(ntot_new,0)
      m_ntot2= max(ntot2_new,0)
      
      ij = m_ijkl/30082
      kl = m_ijkl - 30082*ij
      i = MOD(ij/177, 177) + 2
      j = MOD(ij, 177)     + 2
      k = MOD(kl/169, 178) + 1
      l = MOD(kl, 169)
      WRITE(6,'(a,5i10)')
     $     'ranmar initialized: ij,kl,ijkl,ntot,ntot2=',
     $     ij,kl,m_ijkl,m_ntot,m_ntot2
      DO ii= 1, 97
         s = 0.
         t = .5
         DO jj= 1, 24
            m = MOD(MOD(i*j,179)*k, 179)
            i = j
            j = k
            k = m
            l = MOD(53*l+1, 169)
            IF (MOD(l*m,64)  .GE.  32)  s = s+t
            t = 0.5*t
         ENDDO
         m_U(ii) = s
      ENDDO
      m_twom24 = 1.0
      DO i24= 1, 24
         m_twom24 = 0.5*m_twom24
      ENDDO
      m_C  =   362436.*m_twom24
      m_CD =  7654321.*m_twom24
      m_CM = 16777213.*m_twom24
      m_i97 = 97
      m_j97 = 33
*       complete initialization by skipping
*            (ntot2*modcns + ntot) random numbers
      DO loop2= 1, m_ntot2+1
         now = modcns
         IF (loop2  .EQ.  m_ntot2+1)  now=m_ntot
         IF (now  .GT.  0)  THEN
            WRITE(6,'(a,i15)') ' rmarin skipping over ',now
            DO idum = 1, m_ntot
               uni = m_U(m_i97)-m_U(m_j97)
               IF (uni  .LT.  0.)  uni=uni+1.
               m_U(m_i97) = uni
               m_i97 = m_i97-1
               IF (m_i97  .EQ.  0)  m_i97=97
               m_j97 = m_j97-1
               IF (m_j97  .EQ.  0)  m_j97=97
               m_C = m_C - m_CD
               IF (m_C  .LT.  0.)   m_C=m_C+m_CM
            ENDDO
         ENDIF
      ENDDO
      END


      SUBROUTINE OPseuMar_MakeVec(rvec,lenv)
*/////////////////////////////////////////////////////////////////////////////
*//                                                                         //
*/////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'PseuMar.h'
*
      REAL              rvec(*)
      INTEGER lenv
      INTEGER ijkl_new, ntot_new,ntot2_new
      REAL              zuni,uni
      INTEGER ivec
*-------------------------------------------------------------------------
      IF (m_iwarm  .NE.  9000009)  THEN
* Default initialization. User has called ranmar without rmarin.
         ijkl_new  = 54217137
         ntot_new  = 0
         ntot2_new = 0
         CALL PseuMar_Initialize(ijkl_new, ntot_new,ntot2_new)
      ENDIF

* Normal entry to generate lenv random numbers
      DO ivec= 1, lenv
         uni = m_U(m_i97)-m_U(m_j97)
         IF (uni  .LT.  0.)  uni=uni+1.
         m_U(m_i97) = uni
         m_i97 = m_i97-1
         IF (m_i97  .EQ.  0)  m_i97=97
         m_j97 = m_j97-1
         IF (m_j97  .EQ.  0)  m_j97=97
         m_C = m_C - m_CD
         IF (m_C  .LT.  0.)   m_C=m_C+m_CM
         uni = uni-m_C
         IF (uni  .LT.  0.) uni=uni+1.
         rvec(ivec) = uni
* Replace exact zeros by uniform distr. *2**-24
         IF (uni  .EQ.  0.)  THEN
            zuni = m_twom24*m_U(2)
*     an exact zero here is very unlikely, but let's be safe.
            IF (zuni  .EQ.  0.) zuni= m_twom24*m_twom24
            rvec(ivec) = zuni
         ENDIF
      ENDDO
      m_ntot  = m_ntot + lenv
      IF (m_ntot  .GE.  modcns)  THEN
         m_ntot2  =  m_ntot2 + 1
         m_ntot   =  m_ntot - modcns
      ENDIF
      END


      SUBROUTINE OPseuMar_Out(ijkl_out, ntot_out, ntot2_out)
*/////////////////////////////////////////////////////////////////////////////
*//                                                                         //
*/////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'PseuMar.h'
      INTEGER ijkl_out, ntot_out, ntot2_out
*
      ijkl_out  = m_ijkl
      ntot_out  = m_ntot
      ntot2_out = m_ntot2
      END


      SUBROUTINE QED3_bvirt0(alfinv,charg2,svar,am,dels1,dels2,dels3)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// ISR/FSR virtual corrections to beta0                                            //
*// beta0 is equal born*(1+dels1+dels2+dels3)                                       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION alfinv,charg2,svar,am,dels1,dels2,dels3
* locals
      DOUBLE PRECISION pi,zet2,zet3
      PARAMETER(pi=3.1415926535897932d0)
      PARAMETER(zet2= pi**2/6d0)
      PARAMETER(zet3= 1.2020569031595942854d0)
      DOUBLE PRECISION gami,bilg,alfpi,Mlog
*-------------------------------------------------------------------------------------
      DOUBLE COMPLEX     F1_1, F1_2, cL
*-------------------------------------------------------------------------------------
      alfpi =  1d0/alfinv/pi
      bilg  =  DLOG(svar/am**2)
      Mlog  =  DLOG(svar/am**2) -1d0
      gami  =  2*charg2*alfpi*(bilg-1)
      dels1 =  gami/2d0
**    dels2 =  1/2d0 *(gami/2d0)**2
* ISR with subleading terms from Berends, Burgers, Van Neerveen
* (the effect of including NLL is negligible, below 1d-4)
      dels2 =  
     $      charg2**2*alfpi**2  *0.5d0*bilg**2                 ! LL
**     $     +charg2**2*alfpi**2*(
**     $       -(13d0/16d0 +1.5d0*zet2 -3d0*zet3)*bilg           ! NLL
**     $       -16d0/5d0*zet2*zet2 +51d0/8d0*zet2 +13d0/4d0      ! NNLL
**     $       -4.5d0*zet3 -6d0*zet2*log(2d0)                    ! NNLL
**     $      )
      dels3 = 1/6d0 *(gami/2d0)**3
***/////////////////////////////////////////////////////////////////////////
*** The assignements below will get together O(alf1)CEEX and O(alf1)EEX
*** but it will spoil O(alf2)EEX because dels1 is also input for beta1
*      cL    = DCMPLX( DLOG(Svar/Am**2)-1d0, -1d0 )
*      F1_1  = Alfpi*charg2   *0.5d0*cL
*      dels1 = CDABS(1+ F1_1)**2 -1d0
*      F1_2 = F1_1
*     $     +(Alfpi*charg2)**2 *(
*     $              +cL**2/8d0 
*     $              +cL*( 3d0/32 -3d0/4*zet2 +3d0/2*zet3 ) 
*     $     )
*      dels2 = CDABS(1+ F1_2)**2 -(1d0+dels1)
***/////////////////////////////////////////////////////////////////////////
      END                       !!!QED3_bvirt0!!!


      SUBROUTINE QED3_Dfsr1(gamf,y,z,j1,g1,g2,gg1,gg2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Ingredients for O(alf2)NLL FSR matrix element.                                  //
*// INPUT:                                                                          //
*//     y,z Sudakov variables                                                       //
*//     j1 pointer of input-photons                                                 //
*// OUTPUT:                                                                         //
*//     g's are set here                                                            //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER           j1
      DOUBLE PRECISION  gamf,g1,g2,gg1,gg2
      DOUBLE PRECISION  y(*),z(*)
* locals
      DOUBLE PRECISION  zz,dels1,a1,b1
*-------------------------------------------------------------------------------------
* normal definition as in O(alf1) single-photon case
      a1 = y(j1)/( 1d0 +y(j1) +z(j1) )
      b1 = z(j1)/( 1d0 +y(j1) +z(j1) )
      zz = (1d0-a1)*(1d0-b1)
      IF(zz  .LE. 0d0) WRITE(*,*) '!!!! zz=',zz
      dels1 =  gamf/2d0 +gamf/4d0*dlog(zz)
* Exact O(alf1) matrix element for the hardest photon jhard
      g2 = ((1-a1)**2            ) /2d0              ! corrected
      g1 = (            (1-b1)**2) /2d0              ! corrected
      gg2= ((1-a1)**2            ) /2d0 *(1+dels1)   ! corrected
      gg1= (            (1-b1)**2) /2d0 *(1+dels1)   ! corrected
      END                       !!!QED3_Dfsr1!!!

      SUBROUTINE QED3_Dfsr2(y,z,jhard,j1,j2,g1,g2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Ingredients for O(alf2)NLL FSR matrix element.                                  //
*// INPUT:                                                                          //
*//     y,z Sudakov variables                                                       //
*//     jhard pointer of hardes photon                                              //
*//     j1,j2 pointers of two input-photons                                         //
*// OUTPUT:                                                                         //
*//     g1,g2 are updated (have to be initialized in calling program)               //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER           jhard,j1,j2
      DOUBLE PRECISION  g1,g2
      DOUBLE PRECISION  y(*),z(*)
* locals
      DOUBLE PRECISION  b2,a2,p1,p2,b1,a1,zp2,yp2
*-------------------------------------------------------------------------------------
* normal definition as in O(alf1) single-photon case
      a1 = y(j1)/( 1d0 +y(j1) +z(j1) )
      b1 = z(j1)/( 1d0 +y(j1) +z(j1) )
* take into account primary photon emission
      yp2 = y(j2)/( 1d0 +y(j1) )
      zp2 = z(j2)/( 1d0 +z(j1) )
* as in O(alf1) single-photon case
      a2 = yp2/(1d0 + yp2 +zp2)
      b2 = zp2/(1d0 + yp2 +zp2)

* Exact O(alf1) matrix element for the hardest photon jhard
      IF(jhard .EQ. j1) THEN
         p2= ((1-a1)**2            ) *( (1-a2)**2 + (1-b2)**2 )/4d0 ! corrected
         p1= (            (1-b1)**2) *( (1-a2)**2 + (1-b2)**2 )/4d0 ! corrected
      ELSE
         p2= ((1-a1)**2 +(1-b1)**2 ) *( (1-a2)**2             )/4d0 ! corrected
         p1= ((1-a1)**2 +(1-b1)**2 ) *(             (1-b2)**2 )/4d0 ! corrected
      ENDIF
      g1=g1 +p1
      g2=g2 +p2
      END

      SUBROUTINE QED3_Disr1(gami,y,z,j1,g1,g2,gg1,gg2,ggg1,ggg2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Ingredients for O(alf3)NLL ISR matrix element.                                  //
*// INPUT:                                                                          //
*//     alfinv=  QED coupling                                                       //
*//     charg2=  charge squared                                                     //
*//     y,z=     Sudakov variables                                                  //
*//     j1=      pointers to input-photon                                           //
*// OUTPUT:                                                                         //
*//     g's are set here: g=treelevel, gg=oneloop, ggg=twoloop                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  gami,g1,g2,gg1,gg2,ggg1,ggg2
      INTEGER           j1
      DOUBLE PRECISION  y(*),z(*)
* locals
      DOUBLE PRECISION  dels1,dels2,zz,a1,b1
*-------------------------------------------------------------------------------------
      a1 = y(j1)
      b1 = z(j1)
      zz = (1d0-a1)*(1d0-b1)
      IF(zz  .le.0d0) WRITE(*,*) '!!!! zz=',zz
      dels1 =  gami/2d0 -gami/4d0*dlog(zz)
      dels2 =  gami**2/8d0
     $        -gami**2/8d0  *dlog(zz)
     $        +gami**2/24d0 *dlog(zz)**2
* Exact O(alf1) matrix element for the hardest photon jhard
      g1   = ((1-a1)**2            )/2d0
      g2   = (            (1-b1)**2)/2d0
      gg1  = ((1-a1)**2            )/2d0 *(1+dels1)
      gg2  = (            (1-b1)**2)/2d0 *(1+dels1)
      ggg1 = ((1-a1)**2            )/2d0 *(1+dels1+dels2)
      ggg2 = (            (1-b1)**2)/2d0 *(1+dels1+dels2)
      END

      SUBROUTINE QED3_Disr2(gami,y,z,jhard,j1,j2,g1,g2,gg1,gg2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Ingredients for O(alf2)NLL ISR matrix element.                                  //
*// INPUT:                                                                          //
*//     gami  = 2*alfa/pi*(BigLog-1)                                                //
*//     y,z   = Sudakov variables                                                   //
*//     jhard = pointer of hardes photon                                            //
*//     j1,j2 = pointers of two input-photons                                       //
*// OUTPUT:                                                                         //
*//     g's, gg's are updated (have to be initialized in calling program)           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  y(*),z(*)
      DOUBLE PRECISION  gami,g1,g2,gg1,gg2
      INTEGER           jhard,j1,j2
* locals
      DOUBLE PRECISION  a1,z1,p2,delvir1,z1z2,a2,b1,p1,b2
*-------------------------------------------------------------------------------------
      a1 = y(j1)
      b1 = z(j1)
      a2 = y(j2)/(1d0-y(j1))
      b2 = z(j2)/(1d0-z(j1))
* Exact O(alf1) matrix element for the hardest photon jhard
      IF(jhard .EQ. j1) THEN
         p1= ((1-a1)**2            ) *( (1-a2)**2 + (1-b2)**2 )/4d0
         p2= (            (1-b1)**2) *( (1-a2)**2 + (1-b2)**2 )/4d0
      ELSE
         p1= ((1-a1)**2 +(1-b1)**2 ) *( (1-a2)**2             )/4d0
         p2= ((1-a1)**2 +(1-b1)**2 ) *(             (1-b2)**2 )/4d0
      ENDIF
      g1 = g1 +p1
      g2 = g2 +p2
      z1 =  (1-y(j1))*(1-z(j1))
      z1z2= (1-y(j1)-y(j2))*(1-z(j1)-z(j2))
* soft limit to QED3_Disr1 OK, for 2 trees we get 3 terms gami/6d0*dlog(zz)
      delvir1 = gami/2d0 -gami/6d0*dlog(z1) -gami/6d0*dlog(z1z2)
      gg1=gg1 +p1*(1+delvir1)
      gg2=gg2 +p2*(1+delvir1)

      IF(z1  .le.0d0) WRITE(*,*) '!!!! z1=',z1
      IF(z1z2.le.0d0) WRITE(*,*) '!!!! z1z2=',z1z2
      END


      SUBROUTINE QED3_Disr3(y,z,jhard,j1,j2,j3,g1,g2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Ingredients for O(alf3)LL ISR matrix element.                                   //
*// INPUT:                                                                          //
*//     y,z Sudakov variables                                                       //
*//     jhard pointer of hardes photon                                              //
*//     j1,j2,j3 pointers of 3 input-photons                                        //
*// OUTPUT:                                                                         //
*//     g1,g2 are updated (have to be initialized in calling program)               //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  y(*),z(*)
      DOUBLE PRECISION  g1,g2
      INTEGER           jhard,j1,j2,j3
* locals
      DOUBLE PRECISION  chi1,chi2,b3,a3,p2,p1,b1,a1,b2,a2,a,b
* inline functions
      chi1(a  )=  0.5d0*    (1d0-a)**2
      chi2(a,b)=  0.5d0*   ((1d0-a)**2+(1d0-b)**2)
*-------------------------------------------------------------------------------------
      a1 = y(j1)
      b1 = z(j1)
      a2 = y(j2)/(1d0-y(j1))
      b2 = z(j2)/(1d0-z(j1))
      a3 = y(j3)/(1d0-y(j2)-y(j1))
      b3 = z(j3)/(1d0-z(j2)-z(j1))
* Exact O(alf1) matrix element for the hardest photon jhard
      IF(jhard .EQ. j1) THEN
         p1= chi1(a1) *chi2(a2,b2) *chi2(a3,b3)
         p2= chi1(b1) *chi2(a2,b2) *chi2(a3,b3)
      ELSEIF(jhard .EQ. j2) THEN
         p1= chi2(a1,b1) *chi1(a2) *chi2(a3,b3)
         p2= chi2(a1,b1) *chi1(b2) *chi2(a3,b3)
      ELSE
         p1= chi2(a1,b1) *chi2(a2,b2) *chi1(a3)
         p2= chi2(a1,b1) *chi2(a2,b2) *chi1(b3)
      ENDIF
      g1=g1 +p1
      g2=g2 +p2
      END                       !!!QED3_Disr3!!!

      SUBROUTINE QED3_GetDig1(dig1)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Provides O(alf1) ISR matrix element for tests                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'QED3.h'
      DOUBLE PRECISION   dig1
*---------------------------------------------------------------
      dig1= m_dig1
      END                       !!!QED3_GetDig1!!!

      SUBROUTINE QED3_GetWtSet(WtBest,WtSet)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Export list of weights                                                        //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'QED3.h'
      DOUBLE PRECISION    WtBest,WtSet(*)
* locals
      INTEGER  j
*--------------------------------------------------------------
      WtBest = m_WtBest
* collection of all weights
      DO j=1,m_lenwt
         WtSet(j)= m_WtSet(j)
      ENDDO
      END                       !!!QED3_GetWtSet!!!

*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                     Pseudo-CLASS  QED3                                          //
*//                                                                                 //
*//   Calculation of QED matrix element with Yennie-Frautschi-Suura exponentiation  //
*//   for s-chanel exchange-exchange fermion-anfifermion production processe.       //
*//   Order alpha^1 is complete, beyond O(alf^1) leading-log is mainly exploited.   //
*//                                                                                 //
*//   e+ e- ---> f + fbar + n gamma                                                 //
*//                                                                                 //
*//   The following contributions are included:                                     //
*//                                                                                 //
*//   ISR:  O(L^0*alf^0)                                                            //
*//         O(L^1*alf^1)  O(L^0*alf^1)                                              //
*//         O(L^2*alf^2)                                                            //
*//         O(L^3*alf^3)                                                            //
*//   FSR:  O(L^0*alf^0)                                                            //
*//         O(L^1*alf^1)  O(L^0*alf^1)                                              //
*//         O(L^2*alf^2)                                                            //
*//                                                                                 //
*//   Neglected:                                                                    //
*//      ISR*FSR interferences, spin polarization                                   //
*//      t-chanel exchanges                                                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE QED3_Initialize(xpar)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Initialization directly from basic input                                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION  xpar(*)
*
      INCLUDE 'QED3.h'
*
      m_IdeWgt = xpar(11)
      m_alfinv = xpar(30)
      m_KeyISR = xpar(20)
      m_vvmin  = xpar(16)
      END

      SUBROUTINE QED3_Make
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   main routine for calculation of long list of the weights                      //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      SAVE
      INCLUDE 'QED3.h'
*
      DOUBLE PRECISION   xx(4)
      DOUBLE PRECISION   pf1(4),pf2(4)
      DOUBLE PRECISION   qf1(4),qf2(4)
      INTEGER nphox,nphoy
      DOUBLE PRECISION   xphot(100,4),yphot(100,4)
      DOUBLE PRECISION   yini(100),zini(100),yfin(100),zfin(100)
* Elements of beta calculation, Auxiliary/temporary
      DOUBLE PRECISION   beta20,beta21,beta30
      DOUBLE PRECISION   betx12,bety12
      DOUBLE PRECISION   beti12,beti21
      DOUBLE PRECISION   betf01
* Contributions from individual photons
      DOUBLE PRECISION  
     $  betx10(npmx),              ! ISR beta1 tree     times (1+delf1), factorization!
     $  betx11(npmx),              ! ISR beta1 one-loop times (1+delf1), factorization!
     $  bety10(npmx),              ! FSR beta1 tree     times (1+deli1), factorization!
     $  bety11(npmx),              ! FSR beta1 one-loop times (1+deli1), factorization!
     $  betxx20(npmx,npmx),        ! beta2 ISR*ISR tree 
     $  betxy20(npmx,npmx),        ! beta2 ISR*FSR tree 
     $  betyy20(npmx,npmx),        ! beta2 FSR*FSR tree 
     $  beti10(npmx),              ! beta1 tree   ISR only
     $  beti11(npmx),              ! beta1 1-loop ISR only
     $  beti20(npmx,npmx),         ! beta2 tree   ISR only
     $  betf10(npmx),              ! beta1 tree   FSR only, for beta2, beta3
     $  betf11(npmx)               ! beta1 1-loop FSR only, for beta2, beta3
***********************************************************************
      DOUBLE PRECISION   qq(4),pp(4)
      DOUBLE PRECISION   ggf1,ggf2,gggi1,gggi2,gi1,gi2,ggi1,ggi2,gf1,gf2
      DOUBLE PRECISION   cth21,cth12,cth22,cth11
      DOUBLE PRECISION   DisCru
      DOUBLE PRECISION   dist20,disi11,dist10,dist11,dist12,dist30
      DOUBLE PRECISION   andi11,andi21,andi12,andi22,andis,dist21
      DOUBLE PRECISION   hfac1,hfac2,hfac,hfac3,sfacj
      DOUBLE PRECISION   zz,yy,y3,z3,z1,y1,z2,y2,uu,vv,z,y
      DOUBLE PRECISION   ForFin,ForIni,fYFS,fYFSu
      DOUBLE PRECISION   Bor1
c{{{{
      DOUBLE PRECISION   ph(4),kq1,kq2,p1p2,q1q2,tt,tt1,uu1,borc,dig1,sofc
c}}}}

      DOUBLE PRECISION   gami,gamf,delp,delq,deli3,deli2,delf2,delf1,deli1,delf3
      DOUBLE PRECISION   svar,svar1,svar2
      DOUBLE PRECISION   amel,amfin,charge,charg2

      DOUBLE PRECISION   BornV_GetMass,BornV_GetCharge,BornV_Differential

      INTEGER i,j,k,jph,ntree
      INTEGER jph1,jph2,jph3
*
      INTEGER IsFSR,KFbeam,KFfin
*
      INTEGER icont             !debug
      SAVE    icont
      DOUBLE PRECISION   wtm2,wtm0,wtm1
***********************************************************************
**                     Inline functions                              **
***********************************************************************
* Multiplicative mass-correction to truncated S-factor 
      DOUBLE PRECISION   wm0,wm1,wmd,wm7,a,b,del
      wm0(del,a,b)= 1d0 -2d0*del -del*(a/b+b/a)
*
*     O(alf1) amplitude, bremsstrahlung factor, del->0 limit
      wm1(del,a,b)=
     $  1d0 - del*(a/b+b/a)*(1d0-a)*(1d0-b)*2d0/((1d0-a)**2+(1d0-b)**2)
*
* wmd as in BHLUMI, (what about exact mass terms???)
      wmd(del,a,b) =
     $  1d0 + del*(a/b+b/a)*(a**2+b**2)/((1-a)**2+(1-b)**2)
*
* Factorized wm1, as in BHLUMI, to improve numerical stability.
*     Identity wm1=wm7=wm0*wmd, is true up to delta**4 terms
      wm7(del,a,b) = (1d0 +2d0*del -del*(a/b+b/a))
     $ *(1d0 + del*(a**2+b**2)*(a**2+b**2)/((1-a)**2+(1-b)**2)/(a*b))
*
**                 End of inline functions                           **
***********************************************************************
      DATA icont /0/
*     =================================================================
      icont=icont+1
      m_WtBest=1d0

      DO i=1,m_lenwt
         m_WtSet(i)=0d0
      ENDDO
*
      KFbeam = 11                      ! KF=11 is electron
      amel   = BornV_GetMass(KFbeam)
* Actual KFcode of final fermion
      CALL KarLud_GetKFfin(KFfin)
      amfin  = BornV_GetMass(KFfin)
* Final state charge, -1 for electron
      charge = BornV_GetCharge(KFfin)
      charg2 = charge**2

* Check dynamicaly on FSR (quarks!!!)
      CALL KarFin_GetIsFSR(IsFSR)

* ISR
      CALL KarLud_GetSudakov(nphox,yini,zini)
      CALL KarLud_GetPhotons(nphox,xphot)
      CALL KarLud_GetBeams(pf1,pf2)
* FSR
      CALL KarFin_GetSudakov(nphoy,yfin,zfin)
      CALL KarFin_GetPhotons(nphoy,yphot)
      CALL KarFin_GetFermions(qf1,qf2)

* Define 4-mometa for initial/final states and Z
      DO k=1,4
         pp(k)= pf1(k)+ pf2(k)
         qq(k)= qf1(k)+ qf2(k)
         xx(k)= qq(k)
      ENDDO
      DO j=1,nphoy
         DO k=1,4
            xx(k) = xx(k)+yphot(j,k)
         ENDDO
      ENDDO

      svar  = pp(4)**2-pp(3)**2-pp(2)**2-pp(1)**2
      svar1 = xx(4)**2-xx(3)**2-xx(2)**2-xx(1)**2
      svar2 = qq(4)**2-qq(3)**2-qq(2)**2-qq(1)**2
      vv = 1d0 -svar1/svar
      uu = 1d0 -svar2/svar1
      gami =         2d0/m_alfinv/pi*(dlog(svar/amel**2)  -1d0)
      gamf = charg2* 2d0/m_alfinv/pi*(dlog(svar2/amfin**2)-1d0)

* Crude Born distribution
      CALL KK2f_GetBornCru(DisCru)
*
      delp=  amel**2/svar
      delq= amfin**2/svar2
*
      CALL KinLib_ThetaR(xx,pf1,pf2,qf1,qf2,cth11,cth12,cth21,cth22)
      andi11= BornV_Differential(1,KFfin,svar1,cth11,0d0,0d0,0d0,0d0)
      andi12= BornV_Differential(1,KFfin,svar1,cth12,0d0,0d0,0d0,0d0)
      andi21= BornV_Differential(1,KFfin,svar1,cth21,0d0,0d0,0d0,0d0)
      andi22= BornV_Differential(1,KFfin,svar1,cth22,0d0,0d0,0d0,0d0)
*-----------------------------------------------------------
*                beta0 
*-----------------------------------------------------------
* Beta0 components
      CALL QED3_bvirt0(m_alfinv,   1d0,svar , amel,deli1,deli2,deli3)
      CALL QED3_bvirt0(m_alfinv,charg2,svar2,amfin,delf1,delf2,delf3)
*
      IF(m_KeyISR .EQ. 0)  deli1   = 0d0
      IF(m_KeyISR .EQ. 0)  deli2   = 0d0
      IF(IsFSR    .EQ. 0)  delf1   = 0d0
      IF(IsFSR    .EQ. 0)  delf2   = 0d0

* Beta0, initial+final, factorized form
      andis = (andi11 +andi12 +andi21 +andi22)/4
      m_Beta03 = andis*(1d0+deli1+deli2+deli3)*(1d0+delf1+delf2) !O(alf3)
      m_Beta02 = andis*(1d0+deli1+deli2)      *(1d0+delf1+delf2) !O(alf2)
      m_Beta01 = andis*(1d0+deli1)            *(1d0+delf1)       !O(alf1)
      m_Beta00 = andis                                           !O(alf0)
* Initial only
      m_beti03 = andis*(1d0+deli1+deli2+deli3)
      m_beti02 = andis*(1d0+deli1+deli2)
      m_beti01 = andis*(1d0+deli1)
      m_beti00 = andis
* Auxiliary
      betf01 = andis*(1d0+delf1)

c[[[[[[[
c      IF( nphox+nphoy .EQ.0) THEN
c      write(*,*) '||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||'
c      write(*,*) ' QED3: nphox+nphoy =',nphox+nphoy
c      write(*,*) ' QED3: m_Beta01,m_Beta02 = ',m_Beta01,m_Beta02
c      write(*,*) ' QED3: (1d0+deli1)*(1d0+delf1)= ',(1d0+deli1)*(1d0+delf1)
c      write(*,*) ' QED3: (1d0+deli1+deli2)*(1d0+delf1+delf2)= ',(1d0+deli1+deli2)*(1d0+delf1+delf2)
c      ENDIF
c]]]]]]]

*-----------------------------------------------------------
*                beta1 initial
*-----------------------------------------------------------
      m_xBet10 = 0d0
      m_xBet11 = 0d0
      m_xBet12 = 0d0
      m_sbti10 = 0d0
      m_sbti11 = 0d0
      m_sbti12 = 0d0
      IF(m_KeyISR .NE. 0  .AND.  vv .GT. m_vlim1) THEN
         DO jph=1,nphox
            y = yini(jph)
            z = zini(jph)
            sfacj  =  2d0/(y*z) *wm0(delp,y,z)
            m_xSfac(jph) = sfacj
            hfac = wmd(delp,y,z) *sfacj
            gf1 = 0.5d0
            gf2 = 0.5d0
            CALL QED3_Disr1(gami,yini,zini,jph, gi1,gi2,ggi1,ggi2,gggi1,gggi2)
*---- O(alf1) ----,  tree_level --------
*     The unconventional (1+delf1) in betx10 helps ISR*FSR factorization
*     in the O(alf2) semi-analytical x-check
            dist10= (  gi1*gf1*andi11   +gi1*gf2*andi12
     $                +gi2*gf1*andi21   +gi2*gf2*andi22)*hfac
            betx10(jph)=(dist10 -m_Beta00*sfacj )*(1+delf1)
            m_xBet10 = m_xBet10 +betx10(jph) /sfacj
*---- O(alf2) ----,  one_loop_level --------
            dist11= ( ggi1*gf1*andi11  +ggi1*gf2*andi12
     $               +ggi2*gf1*andi21  +ggi2*gf2*andi22)*hfac
            betx11(jph)= dist11*(1+delf1)       -m_Beta01*sfacj
            m_xBet11 = m_xBet11 +betx11(jph) /sfacj
*---- O(alf3) ----,  two_loop_level -------- !!!NEW!!!
            dist12= (gggi1*gf1*andi11 +gggi1*gf2*andi12
     $              +gggi2*gf1*andi21 +gggi2*gf2*andi22)*hfac
            betx12     = dist12*(1+delf1+delf2) -m_Beta02*sfacj
            m_xBet12 = m_xBet12 +betx12      /sfacj
***** pure ISR
            beti10(jph) =  dist10 -m_beti00*sfacj   !O(alf1)
            m_sbti10 = m_sbti10 +beti10(jph) /sfacj
            beti11(jph) =  dist11 -m_beti01*sfacj   !O(alf2)
            m_sbti11 = m_sbti11 +beti11(jph) /sfacj
            beti12      =  dist12 -m_beti02*sfacj   !O(alf3) !!!NEW
            m_sbti12 = m_sbti12 +beti12      /sfacj
         ENDDO
      ELSE
         DO jph=1,nphox
            m_xSfac(jph)  = -1d0
            betx10(jph) =  0d0
            betx11(jph) =  0d0
            beti10(jph) =  0d0
            beti11(jph) =  0d0
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta1 final
*-----------------------------------------------------------
      m_yBet10=0d0
      m_yBet11=0d0
      m_yBet12=0d0
      IF(IsFSR .NE. 0  .AND.  uu .GT. m_vlim1) THEN
         DO jph=1,nphoy
            yy = yfin(jph)
            zz = zfin(jph)
            y  = yy/(1 +yy+zz)
            z  = zz/(1 +yy+zz)
            sfacj  =  2d0/(yy*zz)*wm0(delq,yy,zz)
            m_ySfac(jph) = sfacj
            hfac = wmd(delq,y,z) *sfacj
            gi1 = 0.5d0
            gi2 = 0.5d0
            CALL QED3_Dfsr1(gamf,yfin,zfin,jph, gf1,gf2,ggf1,ggf2)
*---- O(alf1) ---,  tree level
*     unconventional (1+deli1) in bety10 helps ISR*FSR factorization 
*     in the O(alf2) semi-analytical x-check
            dist10= (gi1*gf1*andi11   + gi1*gf2*andi12
     $              +gi2*gf1*andi21   + gi2*gf2*andi22)*hfac
            bety10(jph) = (dist10 -m_Beta00*sfacj  )*(1d0+deli1) !!!
            m_yBet10 = m_yBet10 +bety10(jph) /sfacj
*---- O(alf2) ---, one loop level
            dist11= (gi1*ggf1*andi11 + gi1*ggf2*andi12
     $              +gi2*ggf1*andi21 + gi2*ggf2*andi22)*hfac
            bety11(jph) =  dist11*(1+deli1) -m_Beta01*sfacj
            m_yBet11 = m_yBet11 +bety11(jph) /sfacj
*---- O(alf3) ---, two loop level for ISR !!!NEW
*     Additional O(alf2) ISR virtual correction deli2 only
            bety12 = (1+deli1+deli2)*(dist11 -m_Beta00*(1+delf1)*sfacj)
            m_yBet12 = m_yBet12 +bety12 /sfacj
*****  pure FSR *****, for construction of beta2, beta3
            betf10(jph) =  dist10 -m_Beta00*sfacj
            betf11(jph) =  disi11 -betf01*sfacj
         ENDDO
      ELSE
        DO jph=1,nphoy
           m_ySfac(jph)  = -1d0
           bety10(jph) =  0d0
           bety11(jph) =  0d0
        ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta2 initial-initial
*-----------------------------------------------------------
      m_xxBet20=0d0
      m_xxBet21=0d0
      m_sbti20=0d0
      m_sbti21=0d0
      IF(m_KeyISR .NE. 0  .AND.  vv .GT. m_vlim2) THEN
         DO jph2=2,nphox
            DO jph1=1,jph2-1
               hfac1  =  m_xSfac(jph1)*wmd(delp,yini(jph1),zini(jph1))
               hfac2  =  m_xSfac(jph2)*wmd(delp,yini(jph2),zini(jph2))
*     Summation over two LL fragmentation trees for 2 ISR ohotons,
*     photon jph1 is always harder because of low level M.C. generation
               ntree = 2  ! for 2 ISR fragmentation trees
               gi1  = 0d0
               gi2  = 0d0
               ggi1 = 0d0
               ggi2 = 0d0
               CALL QED3_Disr2(gami,yini,zini,jph1, jph1,jph2,
     $                                  gi1,gi2,ggi1,ggi2) ! 1-st tree
               CALL QED3_Disr2(gami,yini,zini,jph1, jph2,jph1,
     $                                  gi1,gi2,ggi1,ggi2) ! 2-nd tree
               gf1 = 0.5d0      ! 0.5d0 for averaging over 2 choices
               gf2 = 0.5d0      ! of Born angles in final state
*---  O(alf2) ---, tree level---------
               dist20= (gi1*gf1*andi11 + gi1*gf2*andi12
     $                 +gi2*gf1*andi21 + gi2*gf2*andi22)
     $                 *hfac1*hfac2/ntree
* In beta20 we use beti10 instead of betx10,
* Reason: unusual definition of betx10, see relevant comment above
               beta20 = dist20
     $              -m_Beta00*m_xSfac(jph1)*m_xSfac(jph2)
     $              -beti10(jph1)*m_xSfac(jph2) -beti10(jph2)*m_xSfac(jph1)
               betxx20(jph1,jph2)=beta20
               m_xxBet20=m_xxBet20 +beta20 /m_xSfac(jph1)/m_xSfac(jph2)
*---  O(alf3) ---, one loop level ---------!!!!NEW!!!!
               dist21= (ggi1*gf1*andi11+ ggi1*gf2*andi12
     $                 +ggi2*gf1*andi21+ ggi2*gf2*andi22)
     $                 *hfac1*hfac2/ntree
               beta21 = dist21*(1+delf1)
     $              -m_Beta01*m_xSfac(jph1)*m_xSfac(jph2)
     $              -betx11(jph1)*m_xSfac(jph2) -betx11(jph2)*m_xSfac(jph1)
               m_xxBet21=m_xxBet21 +beta21 /m_xSfac(jph1)/m_xSfac(jph2)
***** Pure ISR *****
               m_sbti20=m_sbti20 +beta20 /m_xSfac(jph1)/m_xSfac(jph2)
               beti21 = dist21
     $              -m_beti01*m_xSfac(jph1)*m_xSfac(jph2)
     $              -beti11(jph1)*m_xSfac(jph2) -beti11(jph2)*m_xSfac(jph1)
               m_sbti21=m_sbti21 +beti21 /m_xSfac(jph1)/m_xSfac(jph2)
            ENDDO
         ENDDO
      ELSE
         DO  jph2=2,nphox
            DO  jph1=1,nphox
               betxx20(jph1,jph2)= 0d0
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta2 final-final
*-----------------------------------------------------------
      m_yyBet20=0d0
      m_yyBet21=0d0
      IF(IsFSR .NE. 0  .AND.  uu .GT. m_vlim2) THEN
         DO  jph2=2,nphoy
            DO jph1=1,jph2-1
               y1  = yfin(jph1) /(1 +yfin(jph1) +zfin(jph1) )
               z1  = zfin(jph1) /(1 +yfin(jph1) +zfin(jph1) )
               y2  = yfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
               z2  = zfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
*     Note y1,z1<1 (yfin,zfin cant be used directly in wmd(...))
               hfac1  =  m_ySfac(jph1)*wmd(delq,y1,z1)
               hfac2  =  m_ySfac(jph2)*wmd(delq,y2,z2)
*              sum over two FSR fragmentation trees
               ntree = 2  ! for 2 FSR fragmentation trees
               gf1 = 0d0
               gf2 = 0d0
               CALL QED3_Dfsr2(yfin,zfin,jph1,jph1,jph2,gf1,gf2) ! 1-st tree
               CALL QED3_Dfsr2(yfin,zfin,jph1,jph2,jph1,gf1,gf2) ! 2-nd tree
               gi1 = 0.5d0        ! 0.5d0 for averaging over 2 choices
               gi2 = 0.5d0        ! of Born angles in initial state
*---- O(alf2) ----, tree level
               dist20 =
     $              (gi1*gf1*andi11+ gi1*gf2*andi12
     $              +gi2*gf1*andi21+ gi2*gf2*andi22)
     $              *hfac1*hfac2/ntree
               beta20 = dist20 
     $              -m_Beta00*m_ySfac(jph1)*m_ySfac(jph2)
     $              -betf10(jph1)*m_ySfac(jph2) -betf10(jph2)*m_ySfac(jph1)
               betyy20(jph1,jph2)=beta20
               m_yyBet20=m_yyBet20 +beta20 /m_ySfac(jph1)/m_ySfac(jph2)
*---- O(alf3) ----, one loop level  !!!NEW
* Primitive ISR virtual correction only
               beta21 = (1d0+deli1)*beta20
               m_yyBet21=m_yyBet21 +beta21 /m_ySfac(jph1)/m_ySfac(jph2)
            ENDDO
         ENDDO
      ELSE
         DO  jph2=2,nphoy
            DO  jph1=1,nphoy
               betyy20(jph1,jph2)= 0d0
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta2 initial-final
*-----------------------------------------------------------
* or in other terminology   beta1_init - beta1_final
      m_xyBet20=0d0
      m_xyBet21=0d0
      IF(m_KeyISR*IsFSR .NE. 0 .AND. vv.GT.m_vlim1 .AND. uu.GT.m_vlim1) THEN
         DO jph1=1,nphox
            DO jph2=1,nphoy
               y1  = yini(jph1)
               z1  = zini(jph1)
               y2  = yfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
               z2  = zfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
               hfac1 =    m_xSfac(jph1) *wmd(delp,y1,z1)
               hfac2 =    m_ySfac(jph2) *wmd(delq,y2,z2)
               CALL QED3_Disr1(gami,yini,zini,jph1,
     $                  gi1,gi2,ggi1,ggi2,gggi1,gggi2)
               CALL QED3_Dfsr1(gamf,yfin,zfin,jph2,gf1,gf2,ggf1,ggf2)
*---- O(alf2) -----, tree level
               dist20 = 
     $              (gi1*gf1*andi11+ gi1*gf2*andi12
     $              +gi2*gf1*andi21+ gi2*gf2*andi22)*hfac1*hfac2
               beta20 = dist20 
     $              -m_Beta00*m_xSfac(jph1)*m_ySfac(jph2)
     $              -beti10(jph1)*m_ySfac(jph2) -betf10(jph2)*m_xSfac(jph1)
               betxy20(jph1,jph2)=beta20
               m_xyBet20=m_xyBet20 +beta20 /m_xSfac(jph1)/m_ySfac(jph2)
*---- O(alf3) -----, one loop level  !!!!!!!NEW
* Note that virtual correction is factorized ISR*FSR, as usual
               dist21 = 
     $              (ggi1*ggf1*andi11+ ggi1*ggf2*andi12
     $              +ggi2*ggf1*andi21+ ggi2*ggf2*andi22)*hfac1*hfac2
               beta21 = dist21 
     $              -m_Beta01*m_xSfac(jph1)*m_ySfac(jph2)
     $              -betx11(jph1)*m_ySfac(jph2) -bety11(jph2)*m_xSfac(jph1)
               m_xyBet21=m_xyBet21 +beta21 /m_xSfac(jph1)/m_ySfac(jph2)
            ENDDO
         ENDDO
      ELSE
         DO  jph1=1,nphox
            DO  jph2=1,nphoy
               betxy20(jph1,jph2)= 0d0
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta3 initial-initial-initial
*-----------------------------------------------------------
      m_xxxBet30=0d0
      m_sbti30=0d0
      IF(m_KeyISR .NE. 0  .AND.  vv .GT. m_vlim2) THEN
         DO jph3 = 3,nphox
            DO jph2 = 2,jph3-1
               DO jph1 = 1,jph2-1
                  hfac1  =  m_xSfac(jph1)*wmd(delp,yini(jph1),zini(jph1))
                  hfac2  =  m_xSfac(jph2)*wmd(delp,yini(jph2),zini(jph2))
                  hfac3  =  m_xSfac(jph3)*wmd(delp,yini(jph3),zini(jph3))
*      Summation over 6 LL fragmentation trees for 3 ISR photons,
*      photon jph1 is always harder because of low level M.C. generation
                  ntree = 6     ! for 2 ISR fragmentation trees
                  gi1 = 0d0
                  gi2 = 0d0
                  CALL QED3_Disr3(yini,zini,jph1, jph1,jph2,jph3, gi1,gi2)
                  CALL QED3_Disr3(yini,zini,jph1, jph2,jph1,jph3, gi1,gi2)
                  CALL QED3_Disr3(yini,zini,jph1, jph1,jph3,jph2, gi1,gi2)
                  CALL QED3_Disr3(yini,zini,jph1, jph2,jph3,jph1, gi1,gi2)
                  CALL QED3_Disr3(yini,zini,jph1, jph3,jph1,jph2, gi1,gi2)
                  CALL QED3_Disr3(yini,zini,jph1, jph3,jph2,jph1, gi1,gi2)
                  gf1 = 0.5d0   ! 0.5d0 for averaging over 2 choices
                  gf2 = 0.5d0   ! of Born angles in final state
*---- O(alf3) -----, tree level  !!!!!!!NEW
                  dist30 = 
     $                 (gi1*gf1*andi11+ gi1*gf2*andi12
     $                 +gi2*gf1*andi21+ gi2*gf2*andi22)
     $                 *hfac1*hfac2*hfac3/ntree
                  beta30 = dist30
     $                 -m_Beta00 *m_xSfac(jph1) *m_xSfac(jph2) *m_xSfac(jph3)
     $                 -beti10(jph1) *m_xSfac(jph2) *m_xSfac(jph3)
     $                 -beti10(jph2) *m_xSfac(jph1) *m_xSfac(jph3)
     $                 -beti10(jph3) *m_xSfac(jph1) *m_xSfac(jph2)
     $                 -betxx20(jph1,jph2) *m_xSfac(jph3)
     $                 -betxx20(jph1,jph3) *m_xSfac(jph2)
     $                 -betxx20(jph2,jph3) *m_xSfac(jph1)
                  m_xxxBet30 = m_xxxBet30 
     $                 +beta30/m_xSfac(jph1)/m_xSfac(jph2)/m_xSfac(jph3)
* Pure ISR, simply the same
                  m_sbti30 = m_sbti30 
     $                 +beta30/m_xSfac(jph1)/m_xSfac(jph2)/m_xSfac(jph3)
               ENDDO
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta3 initial-initial-final
*-----------------------------------------------------------
      m_xxyBet30 = 0d0
      IF(  m_KeyISR .NE. 0  .AND.  vv .GT. m_vlim2 .AND.
     $     IsFSR .NE. 0  .AND.  uu .GT. m_vlim1) THEN
         DO jph2=2,nphox
            DO jph1=1,jph2-1
               DO jph3=1,nphoy
                  hfac1  =  m_xSfac(jph1)*wmd(delp,yini(jph1),zini(jph1))
                  hfac2  =  m_xSfac(jph2)*wmd(delp,yini(jph2),zini(jph2))
                  y3  = yfin(jph3) /(1 +yfin(jph3) +zfin(jph3) )
                  z3  = zfin(jph3) /(1 +yfin(jph3) +zfin(jph3) )
                  hfac3  =  m_ySfac(jph3)*wmd(delq,y3,z3)
                  ntree = 2     ! for 2 ISR fragmentation trees
                  gi1  = 0d0    ! initialization
                  gi2  = 0d0    ! initialization
                  CALL QED3_Disr2(gami,yini,zini,jph1, jph1,jph2,
     $                                    gi1,gi2,ggi1,ggi2) ! 1-st tree
                  CALL QED3_Disr2(gami,yini,zini,jph1, jph2,jph1,
     $                                    gi1,gi2,ggi1,ggi2) ! 2-nd tree
                  CALL QED3_Dfsr1(gamf,yfin,zfin,jph3,gf1,gf2,ggf1,ggf2)
*---- O(alf3) -----, tree level  !!!!!!!NEW
                  dist30= (gi1*gf1*andi11 + gi1*gf2*andi12
     $                    +gi2*gf1*andi21 + gi2*gf2*andi22)
     $                    *hfac1*hfac2*hfac3/ntree
                  beta30 = dist30 
     $                 -m_Beta00 *m_xSfac(jph1) *m_xSfac(jph2) *m_ySfac(jph3)
     $                 -beti10(jph1) *m_xSfac(jph2) *m_ySfac(jph3)
     $                 -beti10(jph2) *m_xSfac(jph1) *m_ySfac(jph3)
     $                 -betf10(jph3) *m_xSfac(jph1) *m_xSfac(jph2)
     $                 -betxx20(jph1,jph2) *m_ySfac(jph3)
     $                 -betxy20(jph1,jph3) *m_xSfac(jph2)
     $                 -betxy20(jph2,jph3) *m_xSfac(jph1)
                  m_xxyBet30 = m_xxyBet30 
     $                 +beta30/m_xSfac(jph1)/m_xSfac(jph2)/m_ySfac(jph3)
               ENDDO
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------
*                beta3 initial-final-final
*-----------------------------------------------------------
      m_xyyBet30 = 0d0
      IF(  m_KeyISR .NE. 0  .AND.  vv .GT. m_vlim2 .AND.
     $      IsFSR .NE. 0  .AND.  uu .GT. m_vlim1) THEN
         DO  jph2=2,nphoy
            DO jph1=1,jph2-1
               DO jph3=1,nphox
                  y1  = yfin(jph1) /(1 +yfin(jph1) +zfin(jph1) )
                  z1  = zfin(jph1) /(1 +yfin(jph1) +zfin(jph1) )
                  y2  = yfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
                  z2  = zfin(jph2) /(1 +yfin(jph2) +zfin(jph2) )
                  hfac1  =  m_ySfac(jph1)*wmd(delq,y1,z1)
                  hfac2  =  m_ySfac(jph2)*wmd(delq,y2,z2)
                  hfac3  =  m_xSfac(jph3)*wmd(delp,yini(jph3),zini(jph3))
*     sum over two FSR fragmentation trees
                  ntree = 2    ! for 2 FSR fragmentation trees
                  gf1 = 0d0    ! initialization
                  gf2 = 0d0    ! initialization
                  CALL QED3_Dfsr2(yfin,zfin,jph1, jph1,jph2, gf1,gf2)
                  CALL QED3_Dfsr2(yfin,zfin,jph1, jph2,jph1, gf1,gf2)
                  CALL QED3_Disr1(gami,yini,zini,jph3,
     $                  gi1,gi2,ggi1,ggi2,gggi1,gggi2)
*---- O(alf3) -----, tree level  !!!!!!!NEW
                  dist30= (gi1*gf1*andi11 + gi1*gf2*andi12
     $                    +gi2*gf1*andi21 + gi2*gf2*andi22)
     $                    *hfac1*hfac2*hfac3/ntree
                  beta30 = dist30 
     $                 -m_Beta00 *m_ySfac(jph1) *m_ySfac(jph2) *m_xSfac(jph3)
     $                 -betf10(jph1) *m_ySfac(jph2) *m_xSfac(jph3)
     $                 -betf10(jph2) *m_ySfac(jph1) *m_xSfac(jph3)
     $                 -beti10(jph3) *m_ySfac(jph1) *m_ySfac(jph2)
     $                 -betyy20(jph1,jph2) *m_xSfac(jph3)
     $                 -betxy20(jph3,jph1) *m_ySfac(jph2)
     $                 -betxy20(jph3,jph2) *m_ySfac(jph1)
                  m_xyyBet30 = m_xyyBet30 
     $                 +beta30/m_ySfac(jph1)/m_ySfac(jph2)/m_xSfac(jph3)
               ENDDO
            ENDDO
         ENDDO
      ENDIF
*-----------------------------------------------------------------
*     Finite part of the YFS formfactor for the ISR/FSR
*-----------------------------------------------------------------
      CALL  BornV_GetYFSkon(ForIni)
      CALL KarFin_GetYFSkon(ForFin)
      IF(m_KeyISR .EQ. 0)   ForIni=1d0
      IF(   IsFSR .EQ. 0)   ForFin=1d0
      fYFS = ForIni*ForFin
*-----------------------------------------------------------------
*     and the rejection weights = (new.distr/crude.distr)
*-----------------------------------------------------------------
*     ============================================
*     ========== INITIAL + FINAL =================
*     ============================================
*
* Note that m_xyBet20 (which is genuine O(alf2)) is added to O(alf1),
* because our semianalytical programs are only able to deal 
* with factorized ini/fin, see also O(alf1) definitions of beta1's.
*
* Total's, all beta's ---------------------------------
      m_WtSet(71) =   fYFS*  m_Beta00/DisCru
      m_WtSet(72) =   fYFS*( m_Beta01 +m_xBet10 +m_yBet10 +m_xyBet20)/DisCru
      m_WtSet(73) =   fYFS*( m_Beta02 +m_xBet11 +m_yBet11 
     $                      +m_xxBet20 +m_xyBet20 +m_yyBet20 )/DisCru
* !!!NEW!!!
      m_WtSet(74) =   fYFS*( m_Beta03 +m_xBet12 +m_yBet12
     $                    +m_xxBet21 +m_xyBet21 +m_yyBet21
     $                    +m_xxxBet30 +m_xxyBet30 +m_xyyBet30 )/DisCru
* First order, individual beta's -------------
      m_WtSet(80) =   fYFS*m_Beta01/DisCru
      m_WtSet(81) =   fYFS*(m_xBet10+m_yBet10)/DisCru
      m_WtSet(82) =   fYFS*(m_xBet10)/DisCru
      m_WtSet(83) =   fYFS*(m_yBet10)/DisCru
      m_WtSet(84) =   fYFS*(m_xyBet20)/DisCru
* Second order, individual beta's ------------
      m_WtSet(90) =   fYFS*m_Beta02/DisCru
      m_WtSet(91) =   fYFS*(m_xBet11+m_yBet11)/DisCru
      m_WtSet(92) =   fYFS*(m_xxBet20+m_xyBet20+m_yyBet20)/DisCru
      m_WtSet(93) =   fYFS*(m_xBet11)/DisCru
      m_WtSet(94) =   fYFS*(m_yBet11)/DisCru
      m_WtSet(95) =   fYFS*(m_xxBet20)/DisCru
      m_WtSet(96) =   fYFS*(m_xyBet20)/DisCru
      m_WtSet(97) =   fYFS*(m_yyBet20)/DisCru
* Third order, individual beta's ------------!!!NEW!!!
      m_WtSet(100) =   fYFS*m_Beta03/DisCru
      m_WtSet(101) =   fYFS*(m_xBet12 +m_yBet12)/DisCru
      m_WtSet(102) =   fYFS*(m_xxBet21+m_xyBet21+m_yyBet21)/DisCru
      m_WtSet(103) =   fYFS*m_xBet12/DisCru
      m_WtSet(104) =   fYFS*m_yBet12/DisCru
      m_WtSet(105) =   fYFS*m_xxBet21/DisCru
      m_WtSet(106) =   fYFS*m_xyBet21/DisCru
      m_WtSet(107) =   fYFS*m_yyBet21/DisCru
      m_WtSet(108) =   fYFS*(m_xxxBet30+m_xxyBet30+m_xyyBet30)/DisCru
      m_WtSet(109) =   fYFS*m_xxxBet30/DisCru
      m_WtSet(110) =   fYFS*m_xxyBet30/DisCru
      m_WtSet(111) =   fYFS*m_xyyBet30/DisCru

*     ============================================
*     ========= INITIAL STATE ALONE ==============
*     ============================================
* Total's, all beta's ---------------------------------
      m_WtSet( 1) =   ForIni* m_beti00/DisCru
      m_WtSet( 2) =   ForIni*(m_beti01+m_sbti10)/DisCru
      m_WtSet( 3) =   ForIni*(m_beti02+m_sbti11+m_sbti20)/DisCru
!!!NEW
      m_WtSet( 4) =   ForIni*(m_beti03+m_sbti12+m_sbti21+m_sbti30)/DisCru
* First order, individual beta's -------------
      m_WtSet(10) =   ForIni*m_beti01/DisCru
      m_WtSet(11) =   ForIni*m_sbti10/DisCru
* Second order, individual beta's ------------
      m_WtSet(20) =   ForIni*m_beti02/DisCru
      m_WtSet(21) =   ForIni*m_sbti11/DisCru
      m_WtSet(22) =   ForIni*m_sbti20/DisCru
!!!NEW
* Third order, individual beta's ------------
      m_WtSet(30) =   ForIni*m_beti03/DisCru
      m_WtSet(31) =   ForIni*m_sbti12/DisCru
      m_WtSet(32) =   ForIni*m_sbti21/DisCru
      m_WtSet(33) =   ForIni*m_sbti30/DisCru
*
*//=================================================================//
*//            ISR   Non-exponentiated version                      //
*//            Not yet fully implemented......                      //
*//=================================================================//
* Entire 0,1,2-photon distributions
      fYFSu = exp( -gami*dlog(1/m_vvmin) )
      m_dis0   =0d0
      m_dis1   =0d0
      m_dis2   =0d0
      m_dig1   =0d0
      IF( (nphox+nphoy) .EQ. 0) THEN
         m_dis0 = 1
         m_dis1 = 1+gami*dlog(m_vvmin)
         m_dis2 = 1+gami*dlog(m_vvmin)+0.5*(gami*dlog(m_vvmin))**2
      ELSEIF( nphox .EQ. 1) THEN
         y = yini(1)
         z = zini(1)
         gf1 = 0.5d0
         gf2 = 0.5d0
         gi1 = ((1-y)**2)/2d0
         gi2 = ((1-z)**2)/2d0
         Bor1=  gi1*gf1*andi11   +gi1*gf2*andi12 
     $         +gi2*gf1*andi21   +gi2*gf2*andi22
         m_dis1 = Bor1  *wmd(delp,y,z)            !! S-factor divided off
* standard O(alf1) for comparisons with spinor methods
         m_dig1 = Bor1  *2d0/(y*z)*wm1(delp,y,z)*svar/svar1
         m_dis2 = m_dis1*(1 +gami*dlog(m_vvmin))
cc         m_dis1 = 1                       !!!! blank matrix elm.
cc         m_dis2 = 1 +gami*dlog(m_vvmin)   !!!! blank matrix elm.
      ELSEIF( nphoy .EQ. 1) THEN
         yy = yfin(1)
         zz = zfin(1)
         y  = yy/(1 +yy+zz)
         z  = zz/(1 +yy+zz)
         gi1 = 0.5d0
         gi2 = 0.5d0
         gf2 = ((1-y)**2 ) /2d0 !!! y,z are swapped! correct d_fsr !!!!
         gf1 = ((1-z)**2 ) /2d0
         Bor1=    gi1*gf1*andi11   +gi1*gf2*andi12 
     $           +gi2*gf1*andi21   +gi2*gf2*andi22
* standard O(alf1) for comparisons with spinor methods
         m_dig1 = Bor1  *2d0/(y*z)*wm1(delq,y,z)
         m_dis1 = Bor1  *wmd(delq,y,z)            !! S-factor divided off
c{{{
c         IF((y+z).GT.0.9d0) THEN
c            WRITE(*,'(a)') '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
c            DO k=1,4
c               ph(k) = yphot(1,k)
c            ENDDO
c            kq1 = 2*(ph(4)*qf1(4)-ph(3)*qf1(3)-ph(2)*qf1(2)-ph(1)*qf1(1))
c            kq2 = 2*(ph(4)*qf2(4)-ph(3)*qf2(3)-ph(2)*qf2(2)-ph(1)*qf2(1))
c            p1p2= 2*(pf1(4)*pf2(4)-pf1(3)*pf2(3)-pf1(2)*pf2(2)-pf1(1)*pf2(1))
c            q1q2= 2*(qf1(4)*qf2(4)-qf1(3)*qf2(3)-qf1(2)*qf2(2)-qf1(1)*qf2(1))
c            tt  = 2*(pf1(4)*qf1(4)-pf1(3)*qf1(3)-pf1(2)*qf1(2)-pf1(1)*qf1(1))
c            uu  = 2*(pf1(4)*qf2(4)-pf1(3)*qf2(3)-pf1(2)*qf2(2)-pf1(1)*qf2(1))
c            tt1 = 2*(pf2(4)*qf2(4)-pf2(3)*qf2(3)-pf2(2)*qf2(2)-pf2(1)*qf2(1))
c            uu1 = 2*(pf2(4)*qf1(4)-pf2(3)*qf1(3)-pf2(2)*qf1(2)-pf2(1)*qf1(1))
c            WRITE(*,'(a,5g20.10)') 'yy ',yy,kq1/q1q2
c            borc = (tt**2+uu**2+tt1**2+uu1**2)/p1p2**2
c            sofc = 2d0*p1p2**2/kq1/kq2
c            WRITE(*,'(a,5g20.10)') 'borc    ', borc,Bor1,borc/bor1
c            WRITE(*,'(a,5g20.10)') 'sofc    ', sofc, 2/(y*z)
c            dig1 =  2d0 *(tt**2+uu**2+tt1**2+uu1**2)/kq1/kq2
c            WRITE(*,'(a,5g20.10)')  'dig1  ', dig1, m_dig1, dig1/m_dig1
c         ENDIF
c}}}
      ELSEIF( nphox .EQ. 2) THEN
         m_dis2 = wm0(delp,yini(1),zini(1)) *wm0(delp,yini(2),zini(2))
cc         m_dis2 = 1             !!!! blank matrix elm.
      ENDIF
***
* UNEXP Total O(alf0),O(alf1),O(alf2)
      m_WtSet(160) =    m_dis0 /fYFSu
      m_WtSet(161) =    m_dis1 /fYFSu
      m_WtSet(162) =    m_dis2 /fYFSu

*|=================================================================|
*|        Model weight (the best)                                  |
*|=================================================================|
      m_WtBest = m_WtSet(m_IdeWgt)


*********[[[[[[[[[[[[*********DEBUG*********
c      wtm2= m_WtSet(73)*wtcrud
c      wtm1= m_WtSet(72)*wtcrud
c      wtm0= m_WtSet(71)*wtcrud
**      IF(wtm1  .LT.  0d0 .OR. wtm1  .GT.  5d0) THEN
c      IF(wtm2  .LT.  0d0 .OR. wtm2  .GT.  5d0) THEN
c         WRITE(6,*) '++++++++++++++++++++++++++++++++++++++++++++++++++'
c         WRITE(6,*) 'icont,kffin= ',icont,kffin
c         WRITE(6,*) 'nphox,nphoy,vv,uu=',nphox,nphoy,vv,uu
c         WRITE(6,*) 'wtm2,wtm1,wtm0= ',wtm2,wtm1,wtm0
c         WRITE(6,*) 'm_WtSet(71),wtcrud= ',m_WtSet(71),wtcrud
**         CALL dumps(6)
**         CALL dumpi(6)
**         CALL dumpf(6)
c      ENDIF
*********]]]]]]]]]]]]*********DEBUG*********
      END


      SUBROUTINE  QED3_wtPrint(txt,nout,iev,ie1,ie2,wt_ISR,wt_FSR,wtbest,wtset)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*// Prints out all weights                                                          //
*// and the serial number of event iev on unit nout                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER           nout,iev,ie1,ie2
      DOUBLE PRECISION  wt_ISR,wt_FSR,wtbest
      DOUBLE PRECISION  wtset(*)
      CHARACTER*8 txt
* locals
      INTEGER           i
      DOUBLE PRECISION  wtmain,wtcrud
*-------------------------------------------------------------------------------------
      IF( (iev .GE. ie1) .AND. (iev .LE. ie2) ) THEN
         WRITE(nout,*) 
     $        '=========== ',txt,' =======weights========>',iev
         wtcrud  = wt_ISR*wt_FSR
         wtmain  = wtcrud*wtbest
         WRITE(nout,3000) 'wtmain,wt_ISR,wt_FSR,wtbest= ',
     $                     wtmain,wt_ISR,wt_FSR,wtbest
         WRITE(nout,3100) (' (',i,')=',wtset(i)*wtcrud, i=1,150)
         WRITE(nout,*) '   '
      ENDIF
 3000 FORMAT(a,4f18.14)
 3100 FORMAT(4(a3,i3,a2,f18.14))
      END                       !!!QED3_wtPrint!!!

      SUBROUTINE ReaDataN(ninp,npar,imax)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Single data card is:    (a1,i4,i15,a60)                                        //
*//  First character * defines comment card!                                        //
*//                                                                                 //
*//  Note that this program does not clear xpar!!!                                  //
*//  one has to do it before calling it, if necessary!!!                            //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER          ninp,imax,npar(*)
*
      CHARACTER*6      beg6
      CHARACTER*4      end4
      CHARACTER*1      mark1
      CHARACTER*60     comm60
      CHARACTER*80     comm80   
      INTEGER          nvalue,index,line
*--------------------------------------------------------------------------------------
*      WRITE(  *,*) '***************************'
*      WRITE(  *,*) '* Parser  ReaDataN starts *'
*      WRITE(  *,*) '***************************'

* Search for 'BeginN'
      DO line =1,10000
         READ(ninp,'(a6,a)') beg6,comm60
         IF(beg6 .EQ. 'BeginN') THEN
            WRITE(  *,'(a6,a)') beg6,comm60
            GOTO 200
         ENDIF
      ENDDO
 200  CONTINUE

* Read data, 'EndN' terminates data, '*' marks comment
      DO line =1,1000
         READ(ninp,'(a)') mark1
         IF(mark1 .EQ. ' ') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a1,i4,i15,a60)') mark1,index,nvalue,comm60
            WRITE(  *,'(a1,i4,i15,a60)') mark1,index,nvalue,comm60
            IF( (index .LE. 0) .OR. (index .GE. imax)) GOTO 990
            npar(index) = nvalue
         ELSEIF(mark1 .EQ. 'E') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a4,a)') end4,comm60
            WRITE(  *,'(a4,a)') end4,comm60
            IF(end4 .EQ. 'EndN') GOTO 300
            GOTO 991
         ELSEIF(mark1 .EQ. '*') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a)') comm80
            WRITE(  *,'(a)') comm80
         ENDIF
      ENDDO
 300  CONTINUE

*      WRITE(  *,*) '***************************'
*      WRITE(  *,*) '* Parser ReaDataN ends    *'
*      WRITE(  *,*) '***************************'
      RETURN
 990  WRITE(*,*) '+++ ReaDataN: wrong index= ',index
      STOP
      RETURN
 991  WRITE(*,*) '+++ ReaDataN: wrong end of data '
      STOP
      END


      SUBROUTINE ReaDataX(ninp,xpar,imax)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Single data card is:    (a1,i4,d15.0,a60)                                      //
*//  First character * defines comment card!                                        //
*//                                                                                 //
*//  Note that this program does not clear xpar!!!                                  //
*//  one has to do it before calling it, if necessary!!!                            //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      DOUBLE PRECISION xpar(*)
      INTEGER          ninp,imax
*-------------------------------------------------------------------------------------
      CHARACTER*6      beg6
      CHARACTER*4      end4
      CHARACTER*1      mark1
      CHARACTER*60     comm60
      CHARACTER*80     comm80
      INTEGER          line,index
      DOUBLE PRECISION value
*-------------------------------------------------------------------------------------

*      WRITE(  *,*) '***************************'
*      WRITE(  *,*) '*  Parser ReaDataX starts *'
*      WRITE(  *,*) '***************************'

* Search for 'BeginX'
      DO line =1,10000
         READ(ninp,'(a6,a)') beg6,comm60
         IF(beg6 .EQ. 'BeginX') THEN
            WRITE(  *,'(a6,a)') beg6,comm60
            GOTO 200
         ENDIF
      ENDDO
 200  CONTINUE

* Read data, 'EndX' terminates data, '*' marks comment
      DO line =1,1000
         READ(ninp,'(a)') mark1
         IF(mark1 .EQ. ' ') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a1,i4,d15.0,a60)') mark1,index,value,comm60
            WRITE(  *,'(a1,i4,g15.6,a60)') mark1,index,value,comm60
            IF( (index .LE. 0) .OR. (index .GE. imax)) GOTO 990
            xpar(index) = value
         ELSEIF(mark1 .EQ. 'E') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a4,a)') end4,comm60
            WRITE(  *,'(a4,a)') end4,comm60
            IF(end4 .EQ. 'EndX') GOTO 300
            GOTO 991
         ELSEIF(mark1 .EQ. '*') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a)') comm80
            WRITE(  *,'(a)') comm80
         ENDIF
      ENDDO
 300  CONTINUE

*      WRITE(  *,*) '***************************'
*      WRITE(  *,*) '* Parser ReaDataX ends    *'
*      WRITE(  *,*) '***************************'
      RETURN
 990  WRITE(*,*) '+++ ReaDataX: wrong index= ',index
      STOP
      RETURN
 991  WRITE(*,*) '+++ ReaDataX: wrong end of data '
      STOP
      END

      SUBROUTINE Taupair_Clone
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   This routine is strongly interrelated with Tralor  !!!                        //
*//                                                                                 //
*//   Cloning tau decays by additional rotation tau decay products with respect     //
*//   to frames  initialy used in the decay simulation.                             //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
*
      DOUBLE PRECISION       KinLib_AngPhi
      DOUBLE PRECISION       Habs1,Habs2
      DOUBLE PRECISION       hb1(4),hb2(4)
      REAL                   rrr(10)
*-------------------------------------------------------------------------------------
      INTEGER icont
      DATA icont /0/
*-------------------------------------------------------------------------------------
*/////////////////////////////////////////////////////////////////////////////////////
*//   Generation of random two independent Euler rotations                          //
*/////////////////////////////////////////////////////////////////////////////////////
      CALL PseuMar_MakeVec(rrr,3)
      m_alfa1  = 2d0*m_pi*rrr(3)        ! azimuthal angle in (0,2*pi)
      m_beta1  = ACOS(2d0*rrr(1)-1d0)   ! polar angle     in (0,  pi)
      m_gamma1 = 2d0*m_pi*rrr(2)        ! azimuthal angle in (0,2*pi)
*------------------------------------------------
      CALL PseuMar_MakeVec(rrr,3)
      m_alfa2  = 2d0*m_pi*rrr(3)        ! azimuthal angle in (0,2*pi)
      m_beta2  = ACOS(2d0*rrr(1)-1d0)   ! polar angle     in (0,  pi)
      m_gamma2 = 2d0*m_pi*rrr(2)        ! azimuthal angle in (0,2*pi)
      IF(m_KeyClone .EQ. 1) THEN
*/////////////////////////////////////////////////////////////////////////////////////
*//   Cloning tau decay with help of  Euler rotations FIRST method                  //
*/////////////////////////////////////////////////////////////////////////////////////
         Habs1 = DSQRT( m_HvecTau1(1)**2 +m_HvecTau1(2)**2 +m_HvecTau1(3)**2 )
         Habs2 = DSQRT( m_HvecTau2(1)**2 +m_HvecTau2(2)**2 +m_HvecTau2(3)**2 )
* Standart phi, theta for polarimeter fectors, phi in (0,2*pi), theta in (0,pi)
         IF(Habs1 .GT. 1d-5) THEN
            m_phi1  = KinLib_AngPhi( m_HvecTau1(1), m_HvecTau1(2) )
            m_thet1 = KinLib_AngPhi( m_HvecTau1(3), DSQRT(m_HvecTau1(1)**2+m_HvecTau1(2)**2) )
         ELSE
            m_phi1  =0d0
            m_thet1 =0d0
         ENDIF
         IF(Habs2 .GT. 1d-5) THEN
            m_phi2  = KinLib_AngPhi( m_HvecTau2(1), m_HvecTau2(2) )
            m_thet2 = KinLib_AngPhi( m_HvecTau2(3), DSQRT(m_HvecTau2(1)**2+m_HvecTau2(2)**2) )
         ELSE
            m_phi2  =0d0
            m_thet2 =0d0
         ENDIF
*(((((((((((((
* Test of angle definition, resulting hb1,hb2 should be on z-axis
*         IF(icont .LE. 60 ) THEN
*            icont=icont+1
*            CALL  KinLib_RotEulInv( m_thet1, m_phi1, m_HvecTau1, hb1)
*            CALL  KinLib_RotEulInv( m_thet2, m_phi2, m_HvecTau2, hb2)
*            CALL KinLib_VecPrint(6,'hb1=    ',hb1)
*            CALL KinLib_VecPrint(6,'hb2=    ',hb2)
*         ENDIF
*)))))))))))))
         m_HvClone1(1) =0d0
         m_HvClone1(2) =0d0
         m_HvClone1(3) =Habs1
         m_HvClone1(4) =1d0
         m_HvClone2(1) =0d0
         m_HvClone2(2) =0d0
         m_HvClone2(3) =Habs2
         m_HvClone2(4) =1d0
         CALL  KinLib_RotEul( m_beta1, m_gamma1, m_HvClone1, m_HvClone1)
         CALL  KinLib_RotEul( m_beta2, m_gamma2, m_HvClone2, m_HvClone2)
      ELSEIF(m_KeyClone .EQ. 2) THEN
*/////////////////////////////////////////////////////////////////////////////////////
*//   Cloning tau decay with help of  Euler rotations, SECOND method                //
*/////////////////////////////////////////////////////////////////////////////////////
         CALL KinLib_RotEuler(m_alfa1, m_beta1, m_gamma1, m_HvecTau1, m_HvClone1)
         CALL KinLib_RotEuler(m_alfa2, m_beta2, m_gamma2, m_HvecTau2, m_HvClone2)
      ELSE
         WRITE(m_out,*) ' ##### STOP in Taupair_Clone: wrong KeyClone= ',m_KeyClone
         WRITE(    *,*) ' ##### STOP in Taupair_Clone: wrong KeyClone= ',m_KeyClone
         STOP
      ENDIF
      END

      SUBROUTINE Taupair_Finalize
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Printout of final statistics                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      INCLUDE 'BXformat.h'
      INCLUDE 'Taupair.h'
*
      DOUBLE PRECISION  HvecDummy(4)
      DOUBLE PRECISION   awt30,dwt30,WtSup30
*-------------------------------------------------------------------------------------
      IF( m_IsInitialized .EQ. 0) RETURN

      CALL DEKAY(100,HvecDummy)

      CALL  GLK_MgetAve(m_idyfs+30,awt30,dwt30,WtSup30)

      CALL  GLK_Mprint(m_idyfs+30)

      WRITE(m_out,bxope)
      WRITE(m_out,bxtxt) 'Tau Pair Finalize         '
      WRITE(m_out,bxl2f) awt30,dwt30,'Spin Imprint <wt1> ','wt1ave','a1'
      WRITE(m_out,bxl1f) WtSup30    ,'Maximum value wt1  ','wt1max','a2'
      WRITE(m_out,bxclo)

      END

      SUBROUTINE Taupair_GetHvectors(HvecFer1,HvecFer2)
*/////////////////////////////////////////////////////////////////////////////////////
*//   Geting clone of the tau lepton POLARIMETER vectors                            //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
      INTEGER k
      DOUBLE PRECISION  HvecFer1(4),HvecFer2(4)
*
      DO k=1,4
         HvecFer1( k) = m_HvClone1(k)
         HvecFer2( k) = m_HvClone2(k)
      ENDDO
      END

      SUBROUTINE Taupair_GetIsInitialized(IsInitialized)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Get to know if Tauola is active (IsInitialized=1)                             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
      INTEGER IsInitialized
*
      IsInitialized = m_IsInitialized
      END

      SUBROUTINE Taupair_ImprintSpin
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Impose spin effects in tau decays with rejection method.                      //
*//   In order to save CPU time each tau decay is cloned by Euler rotation.         //
*//   This is safe and mathematicaly correct!                                       //
*//   Remember:  the average weight due to introduction of spin effects             //
*//   in tau+ tau- system has be EXACTLY 1/4.                                       //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
*
      DOUBLE PRECISION       wt, wtmax, wt0,wt1,wt2
      DOUBLE PRECISION       HvecFer1(4), HvecFer2(4)
      INTEGER     loop
      REAL                   rvec(10)
*-------------------------------------------------------------------------------------
      INTEGER icont
      DATA icont /0/
*-------------------------------------------------------------------------------------
      IF( m_IsInitialized .EQ. 0) RETURN
      icont = icont+1
      loop=0
 1099 CONTINUE
         loop=loop+1
* Cloning tau decay by Euler rotation
         CALL   Taupair_Clone
         CALL   Taupair_GetHvectors( HvecFer1,HvecFer2)
         CALL      GPS_SetHvectors( HvecFer1,HvecFer2)
*
         CALL GPS_MakeRho2(wt0,wt1,wt2)
*        --------------------------
         wt = wt1
*****    IF(icont. LE. 10 ) WRITE(16,*) ' LOOP ,wt = ', loop, wt
         wtmax = 4d0
         CALL GLK_Mfill(m_idyfs+30, wt,  wtmax)
         CALL PseuMar_MakeVec(rvec,1)
      IF (wt .LT. wtmax*rvec(1)) GOTO 1099
      END
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                          THE END of                                             //
*//   Standard Tauola interface/initialization routines of functionality exactly    //
*//   as in Tauola CPC                                                              //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                                                                                 //
*//                         Pseudo-CLASS  TauPair                                   //
*//                                                                                 //
*//       Purpose:                                                                  //
*//       (a) Interface to Simulation of TWO tau decays                             //
*//       (b) Calculates spin weight wt using GPS_MakeRho2 and introduces           //
*//           spin effects in tau decays by means of rejection with <wt>=1          //
*//       (c) Transforms decay products to CMS frame                                //
*//       (d) Interfaces Photos to Tauola                                           //
*//                                                                                 //
*//   Notes:                                                                        //
*//   The class is initialized by KK2f_Initialize                                   //
*//   It is called from KK2f_Make                                                   //
*//   It needs GPS to be initialized in order to calculate spin weight (final)      //
*//                                                                                 //
*//                                                                                 //
*//   For the moment this file contains the interface to tauola                     //
*//   The rest of code is in tauface.f and tauola.f                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE Taupair_Initialize(xpar)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Class initialization                                                         //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      INCLUDE 'BXformat.h'
      INCLUDE 'Taupair.h'
*
      DOUBLE PRECISION  xpar(*)
      DOUBLE PRECISION  HvecDummy(4)
      DOUBLE PRECISION  xk0qed
      INTEGER Jak1,Jak2
      INTEGER ITAUXPAR
      PARAMETER ( ITAUXPAR=2000)
*=====================================================================================

      m_out   = xpar(4)
      m_idyfs = xpar(8)   ! pointer for internal histograming

      m_IsInitialized = xpar(415)  ! General mask for tau chanel

C switches of tau+ tau- decay modes !!
      m_IFPHOT        = xpar(ITAUXPAR+4)   ! QED rad. in hadronic decays (PHOTOS)
      Jak1            = xpar(ITAUXPAR+1)   ! Decay Mask for first tau
      Jak2            = xpar(ITAUXPAR+2)   ! Decay Mask for second tau
      IF( (Jak1.EQ.-1) .AND. (Jak2.EQ.-1) ) m_IsInitialized = 0

        m_KeyClone      = 1       ! dip-switch for cloning procedure, =1,2
        m_KeyClone      = 2       ! dip-switch for cloning procedure, =1,2
        WRITE(m_out,bxope)
        WRITE(m_out,bxtxt) ' KK interface of Tauola                  '
        WRITE(m_out,bxl1i) m_KeyClone,'Cloning procedure   ','KeyClone','t01'
        WRITE(m_out,bxclo)

* Initialisation of tau decay package TAUOLA; ITAUXPAR is for indirect adressing.
      CALL INIETC(ITAUXPAR,xpar)
      IF( m_IsInitialized .EQ. 0) THEN
         WRITE(m_out,bxope) 
         WRITE(m_out,bxtxt) ' !!!!! Tauola inhibited !!!!    '
         WRITE(m_out,bxclo)
      ELSE
        CALL INIMAS(ITAUXPAR,xpar)
        CALL INITDK(ITAUXPAR,xpar)
        xk0qed = 0.1D0            ! <=== It seems to be never used
        CALL INIPHY(xk0qed)
        CALL DEKAY(-1,HvecDummy)

* Initialization of PHOTOS
        IF(m_IFPHOT .EQ. 1)   CALL PHOINI

* control weight
        CALL GLK_Mbook(m_idyfs+30,'Tau Pair: wt1, Spin Imprint weight $', 40, 4d0)

      ENDIF

 
      END


      SUBROUTINE Taupair_Make1
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Main step in tau decau generation                                             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
*-------------------------------------------------------------------------------------
      IF( m_IsInitialized .EQ. 0) RETURN
      CALL DEKAY(1,m_HvecTau1)
      CALL DEKAY(2,m_HvecTau2)
      END
 
      SUBROUTINE Taupair_Make2
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//    Transform tau decay products to CMS, PDG book-keeping and Photos             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
      DOUBLE PRECISION     p3(4),p4(4)

      CALL KarFin_GetFermions( p3,p4)
      CALL GPS_tralorPrepare(p3,1)
      CALL GPS_tralorPrepare(p4,2)

      CALL DEKAY(1+10,m_HvecTau1)
      CALL DEKAY(2+10,m_HvecTau2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                    Photos comes last                                            //
*/////////////////////////////////////////////////////////////////////////////////////
      IF(m_IFPHOT .EQ. 1) THEN
         CALL PHOTOS(3)
         CALL PHOTOS(4)
      ENDIF
      CALL HepEvt_LuHepc(2) 
      END

*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//           Setters and Getters of CLASS  Tauola                                  //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*/////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE Taupair_SetKeyClone(KeyClone)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Setter to KeyClone                                                            //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
      INTEGER KeyClone
*
      m_KeyClone = KeyClone
      IF( KeyClone .LT. 1 .OR. KeyClone .GT. 2) THEN
         WRITE(m_out,*) ' ##### STOP in Taupair_SetKeyClone: wrong KeyClone= ',KeyClone
         WRITE(    *,*) ' ##### STOP in Taupair_SetKeyClone: wrong KeyClone= ',KeyClone
         STOP
      ENDIF
      END


      SUBROUTINE TAURDF(KTO)
* THIS ROUTINE CAN BE CALLED BEFORE ANY TAU+ OR TAU- EVENT IS GENERATED
* IT CAN BE USED TO GENERATE TAU+ AND TAU- SAMPLES OF DIFFERENT
* CONTENTS
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      COMMON / TAUBRA / GAMPRT(30),JLIST(30),NCHAN
      IF (KTO.EQ.1) THEN
*     ==================
* LIST OF BRANCHING RATIOS
      NCHAN = 19
      DO 1 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = .0000
        IF(I.EQ. 2) GAMPRT(I) = .0000
        IF(I.EQ. 3) GAMPRT(I) = .0000
        IF(I.EQ. 4) GAMPRT(I) = .0000
        IF(I.EQ. 5) GAMPRT(I) = .0000
        IF(I.EQ. 6) GAMPRT(I) = .0000
        IF(I.EQ. 7) GAMPRT(I) = .0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   1  CONTINUE
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
      ELSE
*     ====
* LIST OF BRANCHING RATIOS
      NCHAN = 19
      DO 2 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = .0000
        IF(I.EQ. 2) GAMPRT(I) = .0000
        IF(I.EQ. 3) GAMPRT(I) = .0000
        IF(I.EQ. 4) GAMPRT(I) = .0000
        IF(I.EQ. 5) GAMPRT(I) = .0000
        IF(I.EQ. 6) GAMPRT(I) = .0000
        IF(I.EQ. 7) GAMPRT(I) = .0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   2  CONTINUE
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
      ENDIF
*     =====
      END

      SUBROUTINE Tralo4(Kto,P,Q,AM)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   This routine is strongly interrelated with Taupair_Clone!!!                    //
*//                                                                                 //
*//  SUBSITUTE OF TRALO4                                                            // 
*//  TRALO4 is called in TAUOLA /hepevt/ interface to boost from tau+-              //
*//  restframe to lab. It includes rotations in tau restframe due to spin effect    //
*//  implementation                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Taupair.h'
*
      INTEGER   Kto
      REAL                 P(4),Q(4),AM
* locals
      DOUBLE PRECISION     Pd(4)
      INTEGER   k
* ------------------------------------------------------------
      AM = SQRT(ABS( P(4)**2 -P(3)**2 -P(2)**2 -P(1)**2 ))
* Translation from REAL              to DOUBLE PRECISION 
      DO k=1,4
         Pd(K)=P(K)
      ENDDO
      IF(m_KeyClone .EQ. 1) THEN
         IF(   Kto .EQ. 1) THEN
            CALL  KinLib_RotEulInv( m_thet1, m_phi1,   Pd,Pd)
            CALL  KinLib_RotEul(    m_beta1, m_gamma1, Pd,Pd)
         ELSEIF( Kto .EQ. 2) THEN
            CALL  KinLib_RotEulInv( m_thet2, m_phi2,   Pd,Pd)
            CALL  KinLib_RotEul(    m_beta2, m_gamma2, Pd,Pd)
         ELSE
            GOTO 900
         ENDIF
      ELSEIF(m_KeyClone .EQ. 2) THEN
         IF(     Kto .EQ. 1) THEN
            CALL KinLib_RotEuler( m_alfa1, m_beta1, m_gamma1, Pd,Pd)
         ELSEIF( Kto .EQ. 2) THEN
            CALL KinLib_RotEuler( m_alfa2, m_beta2, m_gamma2, Pd,Pd)
         ELSE
            GOTO 900
         ENDIF
      ELSE
         GOTO 901
      ENDIF
      CALL  GPS_TralorDoIt(KTO,Pd,Pd)
* Translation from DOUBLE PRECISION  to REAL             
      DO k=1,4
         Q(K)=Pd(K)
      ENDDO
      RETURN
*----------------------------------------------
 900  CONTINUE
      WRITE(*,*) ' ###### STOP in TRALO4: Wrong Kto = ',Kto
      WRITE(*,*) ' ###### STOP in TRALO4: Wrong Kto = ',Kto
      STOP
 901  CONTINUE
      WRITE(m_out,*) ' ##### STOP in Taupair_Tralo4: wrong KeyClone= ',m_KeyClone
      WRITE(    *,*) ' ##### STOP in Taupair_Tralo4: wrong KeyClone= ',m_KeyClone
      STOP
      END

      SUBROUTINE VegasA_Dump(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    Stores Vegas grid from last iter. on nuni  for later run                      //
*//    This is now obsolete because extra ENTRY has to be reintroduced in Make       //
*//    in order to profit from this tool.                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER           nunit
      INTEGER           i,j
*
      WRITE(nunit,200)   m_nDim,m_nBin,m_Iter
      WRITE(nunit,201)   m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasA_Finalize(IntegMC,ErrelMC)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
*
      DOUBLE PRECISION     IntegMC,ErrelMC
*-----------------------------------------------------------------------------
      IntegMC =0d0
      ErrelMC =0d0
      IF(m_NevGen .GT. 0) IntegMC=m_IntCrude*m_sumWt/m_NevGen
      IF(m_NevGen .GT. 0) ErrelMC=SQRT( m_sumWt2/m_sumWt**2 -1d0/m_NevGen )
***   WRITE(*,*) 'm_NevGen =', m_NevGen
***   WRITE(*,*) 'm_sumWt,m_sumWt2=    ', m_sumWt,m_sumWt2
***   WRITE(*,*) 'm_sumWt**2/m_sumWt2= ', m_sumWt**2/m_sumWt2
      END       ! VegasA_Finalize

      SUBROUTINE VegasA_Generate(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//    (post)Generation  of the vectors   m_MCvector                                 //
*//    MCvector and MCwt are available through corresponding getters                 //
*//    Grid has to be defined before, using VegasA_Make or read from disk            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*------------------------------------------------------------------
      REAL              Qrand(10)        ! rand. numb. vector
*------------------------------------------------------------------
      INTEGER           i,j,k,jstop
      DOUBLE PRECISION  rand,delran,delx,fun,rho
*
      m_MCwt =1d0
****  CALL ranlux(Qrand,m_nDim)
      CALL PseuMar_MakeVec(Qrand,m_nDim)
      DO k=1,m_nDim
         rand = Qrand(k)
         DO j=1,m_nBin
            jstop=j
            IF( m_Cumulus(j,k) .GT. rand) GOTO 216
         ENDDO
 216     CONTINUE
         IF(jstop .EQ. 1) THEN
            delran = rand/m_Cumulus(jstop,k)
            delx   = m_xi(jstop,k)
            rho    = delx*delran
            m_MCwt = m_MCwt *(delx/m_Cumulus(jstop,k))
         ELSE
            delran = (rand-m_Cumulus(jstop-1,k))/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k))
            delx   = m_xi(jstop,k) -m_xi(jstop-1,k)
            rho    = m_xi(jstop-1,k)  +delx*delran
            m_MCwt = m_MCwt *(delx/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k)))
         ENDIF
         m_MCvector(k) = m_xl(k) +rho*(m_xu(k)-m_xl(k))
         m_MCwt = m_MCwt *(m_xu(k)-m_xl(k))
      ENDDO
      Fun = Funx(m_MCvector)
      IF( fun .LT. 0d0 ) GOTO 900
      m_MCwt = m_MCwt *Fun
      m_MCwt = m_MCwt /m_IntCrude     ! apparently <MCwt> ~ IntCrude prior to this point
* statistics
      m_NevGen = m_NevGen+1
      m_sumWt  = m_sumWt   + m_MCwt
      m_sumWt2 = m_sumWt2  + m_MCwt*m_MCwt
      RETURN
 900  WRITE(*,*) ' +++++++ STOP in VegasA_Generate: '
      STOP
      END

      SUBROUTINE VegasA_GetChi2per(Chi2per)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  Chi2per
*-----------------------
      Chi2per    = m_Chi2per
      END

      SUBROUTINE VegasA_GetIntCrude(IntCrude)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  IntCrude
*-----------------------
      IntCrude    = m_IntCrude
      END


      SUBROUTINE VegasA_GetIntegral(Integral,Errabs)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  Integral,Errabs
*-----------------------
      Integral    = m_Integral
      Errabs      = m_Errabs
      END


      SUBROUTINE VegasA_GetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         xl(k) =  m_xl(k)
         xu(k) =  m_xu(k)
      ENDDO
      END

      SUBROUTINE  VegasA_GetMCvector(MCvector)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_nDim
         MCvector(k) = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE VegasA_GetMCwt(MCwt)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE VegasA_Grouping
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Preparatory steps, set all kind of integer constants for iteration              //
*//                                                                                  //
*//  Input params:  nDim, nBinReq, nCall                                             //
*//  Output :       nBin, nGroup, kTotal, nSeries,                                   //
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) nSeries = 2 is always by construction, I tried also nSeries=nDim+1           //
*//  b) the whole algorithm seems to be empirical and rather obscure                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER   ns
*--------------------------------------------------------------------------------------
      ns = m_nDim+1             !! alternative
      ns = 2                    !! <- original
      IF( m_nBinReq .GT. m_nBinMax) CALL VegasA_Stop1(' STOP BinReq> nBinMax ')
* define nGroup and kTotal
      m_kTotal = (m_nCall*(1d0/ns))**(1.d0/m_nDim)   ! expected no. of calls per dimension
      m_nGroup =  1
      IF( ns*m_kTotal .GE. m_nBinReq) THEN        ! m_kTotal big, bins grouped, adjust nBin
         m_nGroup = m_kTotal/m_nBinReq+1
      ENDIF
* define nBin, correct kTotal
      m_nBin    = m_kTotal/m_nGroup
      m_kTotal  = m_nGroup*m_nBin
* define nSeries
      m_nSeries = m_nCall/m_kTotal**m_nDim
      IF(m_nSeries .LT. 2) m_nSeries = 2
*
      END

*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                      End of CLASS  MBrB                                  //
*//////////////////////////////////////////////////////////////////////////////

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//          Pseudoclass VegasA                                                      //
*//                                                                                  //
*//   Performs n-dimensional Monte Carlo integration.                                //
*//      - by G.P. LEPAGE   Sept 1976/(rev)Apr 1978                                  //
*//      - Algorithm described in J.Comp.Phys. 27, 192 (1978)                        //
*//      - Customized by S. Jadach (1999)                                            //
*//      - Event generation added  by S. Jadach (1999)                               //
*//                                                                                  //
*//   Uses cernlib RanMar=PseuMar to generate random numbers.                        //
*//                                                                                  //
*//   Methods:                                                                       //
*//                   Making grid and calculating integral                           //
*//                                                                                  //
*//      VegasA_Initialize                     compulsory initialization             //
*//      VegasA_Make(Funx)                     Make grid, estimate integral          //
*//                                                                                  //
*//      VegasA_SetnDim(nDim)                  redefine nDim    dimension            //
*//      VegasA_SetPriLev(PriLev)              redefine PriLev  printout level       //
*//      VegasA_SetnCall(nCall)                redefine nCall   no of function calls //
*//      VegasA_SetIterMax(IterMax)            redefine IterMax max.no. of iterations//
*//      VegasA_SetAll(nDim, IterMax, nCall, Accur, PriLev)     redefine all         //
*//      VegasA_SetLimits(xl,xu)               set integration limits                //
*//      VegasA_SetnBinReq(nBinReq)            set preferred binning < m_nBinMax     //
*//      VegasA_SetAccur(Accur)                set requested accuracy, Accur=0=defau.//
*//                                                                                  //
*//      VegasA_GetIntegral(Integral,Errabs)   get value of integral                 //
*//      VegasA_GetChi2per(Chi2per)            get chi-squared per dimension         //
*//                                                                                  //
*//      VegasA_Dump(nunit)                    write grid on disk                    //
*//      VegasA_Restore(nunit)                 read  grid from disk                  //
*//                                                                                  //
*//                  Generation ov events using grid from previous step              //
*//                                                                                  //
*//      VegasA_PreGenerate                    initialize                            //
*//      VegasA_GetIntCrude(IntCrude)          get value of crude xsection           //
*//      VegasA_Generate(Funx)                 generate event                        //
*//      VegasA_GetMCvector(MCvector)          get generated event as vector         //
*//      VegasA_GetMCwt(MCwt)                  get MC weight                         //
*//      VegasA_Finalize(IntegMC,ErrelMC)      get final value of integral           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasA_Initialize
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  k,j
*-------------------------------
      m_Flag    = 1
      m_nDim    = 1
      m_IterMax = 5
      m_PriLev  = 2
      m_nCall   = 100000
      m_Accur   = 1d-6
*
      DO k=1,m_nDimMax
         m_xl(k) = 0d0
         m_xu(k) = 1d0
      ENDDO
*
      m_nBinOld  = 1
      DO j = 1,m_nDimMax
         m_xi(1,j) = m_one
      ENDDO

      m_nBinReq = m_nBinMax
      m_Flag   = -1                              !<-- Flag = 1 desabled
      END

      SUBROUTINE VegasA_Make(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) it seems that m_Flag=-1 is enough                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
*--------------------------------------------------------------------------------------
      DOUBLE PRECISION  d(  m_nBinMax,m_nDimMax) ! <-- 
      DOUBLE PRECISION  xin(m_nBinMax)
      DOUBLE PRECISION  r(  m_nBinMax)
      DOUBLE PRECISION  dx( m_nDimMax)
      DOUBLE PRECISION  dt( m_nDimMax)
      DOUBLE PRECISION  x(  m_nDimMax) 
      INTEGER           kounter( m_nDimMax)      ! counter vector over all subhypercubes
      INTEGER           iadr(    m_nDimMax)      ! adres vector of single hypercube
      DOUBLE PRECISION  xo, xn, xadr, delta, beta, random
      DOUBLE PRECISION  gfsum, gfsum2
      DOUBLE PRECISION  dr,wgt
      DOUBLE PRECISION  xjac0, xjac, rc, dv2g
      DOUBLE PRECISION  f,  fsum,fsum2
      INTEGER           nBinMinus1
      INTEGER           kGrand           ! grand total of subhipercubes = kTotal**nDim
      DOUBLE PRECISION  Calls            ! grand total of MC events per iter. = kGrand*nSeries
      INTEGER           k,i,j
*
      REAL              Qrand(10)        ! from PseuMar
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*--------------------------------------------------------------------------------------
      CALL VegasA_Grouping
* Important variables used below are:  m_nBin, m_kTotal, m_nSeries, m_nGroup
      Calls = m_nSeries*m_kTotal**m_nDim
      dv2g = (Calls*(1d0/m_kTotal)**m_nDim)**2/m_nSeries**2/(m_nSeries-m_one)
      xjac0 = 1d0/Calls
      DO j = 1,m_nDim
         dx(j) = m_xu(j)-m_xl(j)
         xjac0  = xjac0*dx(j)
      ENDDO
      nBinMinus1 = m_nBin-1
      m_Iter = 0
*//////////////////////////////////////////////////////////////////////////////////////
*//        initializes cummulative variables                                         //
*//////////////////////////////////////////////////////////////////////////////////////
      m_si   = 0d0
      m_si2  = 0d0
      m_swgt = 0d0
      m_schi = 0d0
*//////////////////////////////////////////////////////////////////////////////////////
*//         ====================================================                     //
*//               beginning of the main integration loop                             //
*//////////////////////////////////////////////////////////////////////////////////////
 9    CONTINUE
      m_Iter = m_Iter+1
      IF(m_nBin .NE. m_nBinOld) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//          initial binning different from rebinning after iteration                //
*//////////////////////////////////////////////////////////////////////////////////////
         rc = m_nBinOld*(1d0/m_nBin)
         DO j = 1,m_nDim
            xn = 0d0
            dr = 0d0
* [[[[[ double loop over i and k
            k  = 0
            i  = 0
 4          CONTINUE
            k = k+1
            dr = dr+m_one
            xo = xn
            xn = m_xi(k,j)
 5          CONTINUE
            IF(rc .GT. dr) GOTO 4
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr
            IF(i .LT. nBinMinus1) GOTO 5
* end of double loop over i and k ]]]]]
* store resulting grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
         IF(m_PriLev.NE.0) WRITE(6,200)   m_nDim, Calls,
     $        m_Iter, m_IterMax, m_Accur,
     $        m_nGroup, m_nSeries,   m_kTotal,
     $        m_Flag, m_nBin,
     $        (m_xl(j),m_xu(j), j = 1,m_nDim)
 200     FORMAT(' Input parameters for VegasA_: nDim = ',i7,'   Calls = ',f10.0
     $        /28x,'   Iter=  ',i7, '   IterMax= ',i7,'   Acccur= ',g9.3
     $        /28x,'   nGroup=',i7, '   nSeries= ',i7,'   kTotal= ',i9  
     $        /28x,'   Flag=  ',i7, '   nBin   = ',i7
     $        /28x,'  (xl,xu) = ',
     $        (t40,'( ',g12.6,' , ',g12.6,' )'))
         m_nBinOld = m_nBin
      ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*//          refine grid from previous iteration                                     //
*//////////////////////////////////////////////////////////////////////////////////////
* d(i,j) is redefined by averaging it over 3 adjacent bins (smoothing procedure?)
* dt is sum over columns (bins) in d, it is used in the subsequent loop, 
         DO j = 1,m_nDim
            xo = d(1,j)
            xn = d(2,j)
            d(1,j) = (xo+xn)/2.d0
            dt( j) = d(1,j)
            DO i = 2,nBinMinus1
               d(i,j) = xo+xn
               xo = xn
               xn = d(i+1,j)
               d(i,j) = (d(i,j)+xn)/3.d0
               dt(j)  = dt(j)+d(i,j)
            ENDDO
            d(m_nBin,j) = (xn+xo)/2.d0
            dt(j) = dt(j)+d(m_nBin,j)
         ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          rebin grid from previous iteration preserving bin density               //
*//////////////////////////////////////////////////////////////////////////////////////
* rebin along each j-th axis, rc is of order 1, and later 1/nBin
         DO j = 1,m_nDim
            rc = 0.d0
            DO i = 1,m_nBin
               r(i) = 0.d0
               IF(d(i,j) .GT. 0.d0) THEN
                  xo = dt(j)/d(i,j)
                  r(i) = ((xo-m_one)/xo/DLOG(xo))**m_alpha
               ENDIF
               rc = rc+r(i)
            ENDDO
            rc = rc/m_nBin
            xn = 0d0
            dr = 0d0
* [[[[[ overlapping loop over i and k
            k  = 0
            i  = 0
 25         CONTINUE
            k = k+1
            dr = dr+r(k)
            xo = xn
            xn = m_xi(k,j)
 26         CONTINUE
            IF(rc .GT. dr) GOTO 25
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr/r(k)
            IF(i .LT. nBinMinus1) GOTO 26
* end of overlapping loop over i and k ]]]]]
* store resulting new grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//          other initializations before main loop                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum  = 0.d0
      gfsum2 = 0.d0
      DO j = 1,m_nDim
         DO i = 1,m_nBin
            d(i,j)  = 0.d0
            m_di(i,j) = 0.d0
         ENDDO
      ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          main loop                                                               //
*//////////////////////////////////////////////////////////////////////////////////////
*--------------------------------------!
      DO j = 1,m_nDim                  !
         kounter(j) = 1                !  Loop over digit-vector kounter 
      ENDDO                            !  every digit in kounter runs from 1 to kTotal
 11   CONTINUE                         !  where kTotal=nGroup*nBin, nGroup>1
*--------------------------------------!
      fsum  = 0.d0
      fsum2 = 0.d0
* loop over random events in every (sub)hypercube defined by kounter
      DO k=1,m_nSeries
*****    CALL ranlux(Qrand,m_nDim)
         CALL PseuMar_MakeVec(Qrand,m_nDim)
         xjac = xjac0
* generate randomly vector x inside the given (sub)hypercube
* Qrand is mapped into (1/nGroup)**dDim hypercube insine each byperbin (1/nBin)**dDim
         DO j = 1,m_nDim
            random = Qrand(j)
            xadr = (kounter(j)-random)/m_nGroup +1d0
            iadr(j) = xadr
            beta    = xadr-iadr(j)
            IF(iadr(j) .GT. 1) THEN
               delta = m_xi( iadr(j)   ,j)  -m_xi( iadr(j)-1, j)
               rc    = m_xi( iadr(j)-1 ,j)  +beta*delta
            ELSE
               delta = m_xi(iadr(j),j)
               rc = beta*delta
            ENDIF
            x(j) = m_xl(j) +rc*dx(j)
            xjac  = xjac*delta*m_nBin
         ENDDO
* summing weights event per event
         f   = xjac*Funx(x)      !! <-- Integrand, x and wt are input for Funx
         fsum  = fsum  +f
         fsum2 = fsum2 +f*f
         DO j = 1,m_nDim
            m_di(iadr(j),j) = m_di(iadr(j),j)+f
         ENDDO
* is this approximate? the other one seems to work better
         IF(m_Flag .GE. 0) THEN
            DO j = 1,m_nDim
               d(iadr(j),j) = d(iadr(j),j)+f*f
            ENDDO
         ENDIF
      ENDDO
* bookkeeping weights globaly
      fsum2 = DSQRT(fsum2*m_nSeries)
      fsum2 = (fsum2-fsum)*(fsum2+fsum)    !!!=(fsum2*nSeries - fsum**2)
      gfsum  = gfsum  +fsum
      gfsum2 = gfsum2 +fsum2
* note that iadr(j) is inherited from previous loop, 
* seems correct, iadr depends only on kounter, not on random.
      IF(m_Flag .LT. 0) THEN
         DO j = 1,m_nDim
            d(iadr(j),j) = d(iadr(j),j)+fsum2
         ENDDO
      ENDIF
*----------------------------------------------!
      k = m_nDim                               ! Loop over all hypercubes ends here
 19   CONTINUE                                 ! kounter digit runs from (1111) to (kkkkk)
      kounter(k) = MOD(kounter(k),m_kTotal)+1  ! where k = kTotal.
      IF(kounter(k) .NE. 1) GOTO 11            ! Altogether kTotal*nSeries events
      k = k-1                                  !
      IF(k .GT. 0) GOTO 19                     !
*----------------------------------------------!
*//////////////////////////////////////////////////////////////////////////////////////
*//           final results for this iteration                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum2 = gfsum2*dv2g
      wgt    = gfsum**2/gfsum2
*
      m_si   = m_si   +gfsum *wgt
      m_si2  = m_si2  +gfsum**2
      m_swgt = m_swgt +wgt
      m_schi = m_schi +gfsum**2 *wgt
*
      m_Integral =  m_si/m_swgt                                           !!<- INTEGRAL estimate
      m_Errabs   =  m_swgt*m_Iter/m_si2
      m_Chi2per  =  m_Errabs*(m_schi/m_swgt-m_Integral**2)/(m_Iter -0.999d0)  !!<- CHI-Square
      m_Errabs   =  DSQRT(1d0/m_Errabs)                                   !!<- ERROR estimate
*-------------------------general printout-----------------------------
      IF(m_PriLev .NE. 0) THEN
         gfsum2 = DSQRT(gfsum2)
         WRITE(6,201) m_Iter, gfsum, gfsum2, m_Integral, m_Errabs, m_Chi2per
         IF(m_PriLev .LT. 0) THEN
            DO j = 1,m_nDim
               WRITE(6,202) j,(m_xi(i,j),m_di(i,j),d(i,j),i = 1,m_nBin)
            ENDDO
         ENDIF
      ENDIF
 201  FORMAT(///' Integration by VegasA_ ' / ' Iteration no.',i3,
     $    ':   Integral  = ',g14.8/21x,'Std.Dev.  = ',g10.4 /
     $    ' Accumulated results:   Integral  = ',g14.8 /
     $    24x,'Std.Dev.  = ',g10.4 / 24x,'chi**2 per it''n  = ',g10.4)
 202  FORMAT(' Data for axis',i2 /
     $  ' ',  6x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  '/
     $ (' ', 3g12.4,5x,3g12.4,5x,3g12.4))
*
      IF(m_Iter .GE. m_IterMax .OR.  m_Accur*DABS(m_Integral) .GE. m_Errabs) RETURN
      GOTO 9
*//////////////////////////////////////////////////////////////////////////////////////
*//                      end of big iteration loop                                   //
*//                =============================================                     //
*//////////////////////////////////////////////////////////////////////////////////////
      END

      SUBROUTINE VegasA_PreGenerate
*//////////////////////////////////////////////////////////////////////////////////////
*//    Debug and tests of facilities for generation                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER           i,j,k
      DOUBLE PRECISION  x,z,sum

      m_NevGen = 0
      m_sumWt  = 0d0
      m_sumWt2 = 0d0
      IF(m_PriLev .EQ. -1) THEN
         WRITE(6,*) ' '
         WRITE(6,*) ' ============================= VegasA_Play================================='
         WRITE(6,*) ' nDim, nBin =', m_nDim, m_nBin
         DO j = 1,m_nDim
            WRITE(6,*) 'Data for axis ', j
            WRITE(6,*)
     $           '     x           xi(i)            x            d(i)            x           xi(i)'
            WRITE(6,'(2g12.5,5x, 2g12.5,5x, 2g12.5)') 
     $           (m_xi(i,j),m_di(i,j),i = 1,m_nBin)
         ENDDO
      ENDIF

      m_IntCrude = 1d0
      DO j=1,m_nDim
         sum = 0d0
         DO i=1,m_nBin
            sum = sum + m_di(i,j)
            m_Cumulus(i,j) = sum
         ENDDO
         m_IntCrude=m_IntCrude*sum
      ENDDO
      m_IntCrude=m_IntCrude**(1d0/m_nDim)

      IF(m_PriLev .EQ. -1) THEN
         DO j=1,m_nDim
            WRITE(6,*) 'm_Cumulus(k,j) for axis j=', j
            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
         ENDDO
      ENDIF

      DO j=1,m_nDim
         DO i=1,m_nBin
            m_Cumulus(i, j) = m_Cumulus(i,j)/m_Cumulus(m_nBin ,j)
         ENDDO
      ENDDO

cc      IF(m_PriLev .EQ. -1) THEN
cc         DO j=1,m_nDim
cc            WRITE(6,*) 'm_Cumulus(k,j) normalized for axis j=', j
cc            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
cc         ENDDO
cc      ENDIF

      END

      SUBROUTINE VegasA_Restore(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    enters initialization DATA for Vegas                                          //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER           nunit
      INTEGER           i,j
*
      READ(nunit,200)    m_nDim,m_nBin,m_Iter
      READ(nunit,201)    m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasA_SetAccur(Accur)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  Accur
*-----------------------
      m_Accur    = Accur
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Getters and Setters                                                            //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasA_SetAll(nDim, IterMax, nCall, Accur, PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER           nDim,IterMax,PriLev,ncall
      DOUBLE PRECISION  Accur      
*-------------------------------------------
      m_nDim    = nDim
      m_IterMax = IterMax
      m_PriLev  = PriLev
      m_nCall   = nCall
      m_Accur   = Accur
      END

      SUBROUTINE VegasA_SetIterMax(IterMax)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  IterMax
*-----------------------
      m_IterMax    = IterMax
      END


      SUBROUTINE VegasA_SetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         m_xl(k) = xl(k)
         m_xu(k) = xu(k)
      ENDDO
      END

      SUBROUTINE VegasA_SetnBinReq(nBinReq)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  nBinReq
*--------------------
      m_nBinReq    = nBinReq
      IF( m_nBinReq .GT. m_nBinMax) 
     $     CALL VegasA_Stop1('STOP in VegasA_SetnBinReq, nBinReq>nBinMax')
      END

      SUBROUTINE VegasA_SetnCall(nCall)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  nCall
*--------------------
      m_nCall    = nCall
      END

      SUBROUTINE VegasA_SetnDim(nDim)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  nDim
*--------------------
      m_nDim    = nDim
      END

      SUBROUTINE VegasA_SetPriLev(PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      INTEGER  PriLev
*--------------------
      m_PriLev    = PriLev
      END

      SUBROUTINE VegasA_Stop1(mesage)
*     *******************************
      IMPLICIT NONE
      INCLUDE 'VegasA.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(*   ,'(a,a,a)')     '++++ ', mesage, ' ++++'
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END

      SUBROUTINE VegasB_Dump(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    Stores Vegas grid from last iter. on nuni  for later run                      //
*//    This is now obsolete because extra ENTRY has to be reintroduced in Make       //
*//    in order to profit from this tool.                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER           nunit
      INTEGER           i,j
*
      WRITE(nunit,200)   m_nDim,m_nBin,m_Iter
      WRITE(nunit,201)   m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasB_Finalize(IntegMC,ErrelMC)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
*
      DOUBLE PRECISION     IntegMC,ErrelMC
*-----------------------------------------------------------------------------
      IntegMC =0d0
      ErrelMC =0d0
      IF(m_NevGen .GT. 0) IntegMC=m_IntCrude*m_sumWt/m_NevGen
      IF(m_NevGen .GT. 0) ErrelMC=SQRT( m_sumWt2/m_sumWt**2 -1d0/m_NevGen )
***   WRITE(*,*) 'm_NevGen =', m_NevGen
***   WRITE(*,*) 'm_sumWt,m_sumWt2=    ', m_sumWt,m_sumWt2
***   WRITE(*,*) 'm_sumWt**2/m_sumWt2= ', m_sumWt**2/m_sumWt2
      END       ! VegasB_Finalize

      SUBROUTINE VegasB_Generate(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//    (post)Generation  of the vectors   m_MCvector                                 //
*//    MCvector and MCwt are available through corresponding getters                 //
*//    Grid has to be defined before, using VegasB_Make or read from disk            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*------------------------------------------------------------------
      REAL              Qrand(10)        ! rand. numb. vector
*------------------------------------------------------------------
      INTEGER           i,j,k,jstop
      DOUBLE PRECISION  rand,delran,delx,fun,rho
*
      m_MCwt =1d0
****  CALL ranlux(Qrand,m_nDim)
      CALL PseuMar_MakeVec(Qrand,m_nDim)
      DO k=1,m_nDim
         rand = Qrand(k)
         DO j=1,m_nBin
            jstop=j
            IF( m_Cumulus(j,k) .GT. rand) GOTO 216
         ENDDO
 216     CONTINUE
         IF(jstop .EQ. 1) THEN
            delran = rand/m_Cumulus(jstop,k)
            delx   = m_xi(jstop,k)
            rho    = delx*delran
            m_MCwt = m_MCwt *(delx/m_Cumulus(jstop,k))
         ELSE
            delran = (rand-m_Cumulus(jstop-1,k))/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k))
            delx   = m_xi(jstop,k) -m_xi(jstop-1,k)
            rho    = m_xi(jstop-1,k)  +delx*delran
            m_MCwt = m_MCwt *(delx/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k)))
         ENDIF
         m_MCvector(k) = m_xl(k) +rho*(m_xu(k)-m_xl(k))
         m_MCwt = m_MCwt *(m_xu(k)-m_xl(k))
      ENDDO
      Fun = Funx(m_MCvector)
      IF( fun .LT. 0d0 ) GOTO 900
      m_MCwt = m_MCwt *Fun
      m_MCwt = m_MCwt /m_IntCrude     ! apparently <MCwt> ~ IntCrude prior to this point
* statistics
      m_NevGen = m_NevGen+1
      m_sumWt  = m_sumWt   + m_MCwt
      m_sumWt2 = m_sumWt2  + m_MCwt*m_MCwt
      RETURN
 900  WRITE(*,*) ' +++++++ STOP in VegasB_Generate: '
      STOP
      END

      SUBROUTINE VegasB_GetChi2per(Chi2per)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  Chi2per
*-----------------------
      Chi2per    = m_Chi2per
      END

      SUBROUTINE VegasB_GetIntCrude(IntCrude)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  IntCrude
*-----------------------
      IntCrude    = m_IntCrude
      END


      SUBROUTINE VegasB_GetIntegral(Integral,Errabs)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  Integral,Errabs
*-----------------------
      Integral    = m_Integral
      Errabs      = m_Errabs
      END


      SUBROUTINE VegasB_GetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         xl(k) =  m_xl(k)
         xu(k) =  m_xu(k)
      ENDDO
      END

      SUBROUTINE  VegasB_GetMCvector(MCvector)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_nDim
         MCvector(k) = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE VegasB_GetMCwt(MCwt)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE VegasB_Grouping
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Preparatory steps, set all kind of integer constants for iteration              //
*//                                                                                  //
*//  Input params:  nDim, nBinReq, nCall                                             //
*//  Output :       nBin, nGroup, kTotal, nSeries,                                   //
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) nSeries = 2 is always by construction, I tried also nSeries=nDim+1           //
*//  b) the whole algorithm seems to be empirical and rather obscure                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER   ns
*--------------------------------------------------------------------------------------
      ns = m_nDim+1             !! alternative
      ns = 2                    !! <- original
      IF( m_nBinReq .GT. m_nBinMax) CALL VegasB_Stop1(' STOP BinReq> nBinMax ')
* define nGroup and kTotal
      m_kTotal = (m_nCall*(1d0/ns))**(1.d0/m_nDim)   ! expected no. of calls per dimension
      m_nGroup =  1
      IF( ns*m_kTotal .GE. m_nBinReq) THEN        ! m_kTotal big, bins grouped, adjust nBin
         m_nGroup = m_kTotal/m_nBinReq+1
      ENDIF
* define nBin, correct kTotal
      m_nBin    = m_kTotal/m_nGroup
      m_kTotal  = m_nGroup*m_nBin
* define nSeries
      m_nSeries = m_nCall/m_kTotal**m_nDim
      IF(m_nSeries .LT. 2) m_nSeries = 2
*
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//              End of VegasA_                                                      //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//          Pseudoclass VegasB                                                      //
*//                                                                                  //
*//   Performs n-dimensional Monte Carlo integration.                                //
*//      - by G.P. LEPAGE   Sept 1976/(rev)Apr 1978                                  //
*//      - Algorithm described in J.Comp.Phys. 27, 192 (1978)                        //
*//      - Customized by S. Jadach (1999)                                            //
*//      - Event generation added  by S. Jadach (1999)                               //
*//                                                                                  //
*//   Uses cernlib RanMar=PseuMar to generate random numbers.                        //
*//                                                                                  //
*//   Methods:                                                                       //
*//                   Making grid and calculating integral                           //
*//                                                                                  //
*//      VegasB_Initialize                     compulsory initialization             //
*//      VegasB_Make(Funx)                     Make grid, estimate integral          //
*//                                                                                  //
*//      VegasB_SetnDim(nDim)                  redefine nDim    dimension            //
*//      VegasB_SetPriLev(PriLev)              redefine PriLev  printout level       //
*//      VegasB_SetnCall(nCall)                redefine nCall   no of function calls //
*//      VegasB_SetIterMax(IterMax)            redefine IterMax max.no. of iterations//
*//      VegasB_SetAll(nDim, IterMax, nCall, Accur, PriLev)     redefine all         //
*//      VegasB_SetLimits(xl,xu)               set integration limits                //
*//      VegasB_SetnBinReq(nBinReq)            set preferred binning < m_nBinMax     //
*//      VegasB_SetAccur(Accur)                set requested accuracy, Accur=0=defau.//
*//                                                                                  //
*//      VegasB_GetIntegral(Integral,Errabs)   get value of integral                 //
*//      VegasB_GetChi2per(Chi2per)            get chi-squared per dimension         //
*//                                                                                  //
*//      VegasB_Dump(nunit)                    write grid on disk                    //
*//      VegasB_Restore(nunit)                 read  grid from disk                  //
*//                                                                                  //
*//                  Generation ov events using grid from previous step              //
*//                                                                                  //
*//      VegasB_PreGenerate                    initialize                            //
*//      VegasB_GetIntCrude(IntCrude)          get value of crude xsection           //
*//      VegasB_Generate(Funx)                 generate event                        //
*//      VegasB_GetMCvector(MCvector)          get generated event as vector         //
*//      VegasB_GetMCwt(MCwt)                  get MC weight                         //
*//      VegasB_Finalize(IntegMC,ErrelMC)      get final value of integral           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasB_Initialize
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  k,j
*-------------------------------
      m_Flag    = 1
      m_nDim    = 1
      m_IterMax = 5
      m_PriLev  = 2
      m_nCall   = 100000
      m_Accur   = 1d-6
*
      DO k=1,m_nDimMax
         m_xl(k) = 0d0
         m_xu(k) = 1d0
      ENDDO
*
      m_nBinOld  = 1
      DO j = 1,m_nDimMax
         m_xi(1,j) = m_one
      ENDDO

      m_nBinReq = m_nBinMax
      m_Flag   = -1                              !<-- Flag = 1 desabled
      END

      SUBROUTINE VegasB_Make(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) it seems that m_Flag=-1 is enough                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
*--------------------------------------------------------------------------------------
      DOUBLE PRECISION  d(  m_nBinMax,m_nDimMax) ! <-- 
      DOUBLE PRECISION  xin(m_nBinMax)
      DOUBLE PRECISION  r(  m_nBinMax)
      DOUBLE PRECISION  dx( m_nDimMax)
      DOUBLE PRECISION  dt( m_nDimMax)
      DOUBLE PRECISION  x(  m_nDimMax) 
      INTEGER           kounter( m_nDimMax)      ! counter vector over all subhypercubes
      INTEGER           iadr(    m_nDimMax)      ! adres vector of single hypercube
      DOUBLE PRECISION  xo, xn, xadr, delta, beta, random
      DOUBLE PRECISION  gfsum, gfsum2
      DOUBLE PRECISION  dr,wgt
      DOUBLE PRECISION  xjac0, xjac, rc, dv2g
      DOUBLE PRECISION  f,  fsum,fsum2
      INTEGER           nBinMinus1
      INTEGER           kGrand           ! grand total of subhipercubes = kTotal**nDim
      DOUBLE PRECISION  Calls            ! grand total of MC events per iter. = kGrand*nSeries
      INTEGER           k,i,j
*
      REAL              Qrand(10)        ! from PseuMar
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*--------------------------------------------------------------------------------------
      CALL VegasB_Grouping
* Important variables used below are:  m_nBin, m_kTotal, m_nSeries, m_nGroup
      Calls = m_nSeries*m_kTotal**m_nDim
      dv2g = (Calls*(1d0/m_kTotal)**m_nDim)**2/m_nSeries**2/(m_nSeries-m_one)
      xjac0 = 1d0/Calls
      DO j = 1,m_nDim
         dx(j) = m_xu(j)-m_xl(j)
         xjac0  = xjac0*dx(j)
      ENDDO
      nBinMinus1 = m_nBin-1
      m_Iter = 0
*//////////////////////////////////////////////////////////////////////////////////////
*//        initializes cummulative variables                                         //
*//////////////////////////////////////////////////////////////////////////////////////
      m_si   = 0d0
      m_si2  = 0d0
      m_swgt = 0d0
      m_schi = 0d0
*//////////////////////////////////////////////////////////////////////////////////////
*//         ====================================================                     //
*//               beginning of the main integration loop                             //
*//////////////////////////////////////////////////////////////////////////////////////
 9    CONTINUE
      m_Iter = m_Iter+1
      IF(m_nBin .NE. m_nBinOld) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//          initial binning different from rebinning after iteration                //
*//////////////////////////////////////////////////////////////////////////////////////
         rc = m_nBinOld*(1d0/m_nBin)
         DO j = 1,m_nDim
            xn = 0d0
            dr = 0d0
* [[[[[ double loop over i and k
            k  = 0
            i  = 0
 4          CONTINUE
            k = k+1
            dr = dr+m_one
            xo = xn
            xn = m_xi(k,j)
 5          CONTINUE
            IF(rc .GT. dr) GOTO 4
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr
            IF(i .LT. nBinMinus1) GOTO 5
* end of double loop over i and k ]]]]]
* store resulting grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
         IF(m_PriLev.NE.0) WRITE(6,200)   m_nDim, Calls,
     $        m_Iter, m_IterMax, m_Accur,
     $        m_nGroup, m_nSeries,   m_kTotal,
     $        m_Flag, m_nBin,
     $        (m_xl(j),m_xu(j), j = 1,m_nDim)
 200     FORMAT(' Input parameters for VegasB_: nDim = ',i7,'   Calls = ',f10.0
     $        /28x,'   Iter=  ',i7, '   IterMax= ',i7,'   Acccur= ',g9.3
     $        /28x,'   nGroup=',i7, '   nSeries= ',i7,'   kTotal= ',i9  
     $        /28x,'   Flag=  ',i7, '   nBin   = ',i7
     $        /28x,'  (xl,xu) = ',
     $        (t40,'( ',g12.6,' , ',g12.6,' )'))
         m_nBinOld = m_nBin
      ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*//          refine grid from previous iteration                                     //
*//////////////////////////////////////////////////////////////////////////////////////
* d(i,j) is redefined by averaging it over 3 adjacent bins (smoothing procedure?)
* dt is sum over columns (bins) in d, it is used in the subsequent loop, 
         DO j = 1,m_nDim
            xo = d(1,j)
            xn = d(2,j)
            d(1,j) = (xo+xn)/2.d0
            dt( j) = d(1,j)
            DO i = 2,nBinMinus1
               d(i,j) = xo+xn
               xo = xn
               xn = d(i+1,j)
               d(i,j) = (d(i,j)+xn)/3.d0
               dt(j)  = dt(j)+d(i,j)
            ENDDO
            d(m_nBin,j) = (xn+xo)/2.d0
            dt(j) = dt(j)+d(m_nBin,j)
         ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          rebin grid from previous iteration preserving bin density               //
*//////////////////////////////////////////////////////////////////////////////////////
* rebin along each j-th axis, rc is of order 1, and later 1/nBin
         DO j = 1,m_nDim
            rc = 0.d0
            DO i = 1,m_nBin
               r(i) = 0.d0
               IF(d(i,j) .GT. 0.d0) THEN
                  xo = dt(j)/d(i,j)
                  r(i) = ((xo-m_one)/xo/DLOG(xo))**m_alpha
               ENDIF
               rc = rc+r(i)
            ENDDO
            rc = rc/m_nBin
            xn = 0d0
            dr = 0d0
* [[[[[ overlapping loop over i and k
            k  = 0
            i  = 0
 25         CONTINUE
            k = k+1
            dr = dr+r(k)
            xo = xn
            xn = m_xi(k,j)
 26         CONTINUE
            IF(rc .GT. dr) GOTO 25
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr/r(k)
            IF(i .LT. nBinMinus1) GOTO 26
* end of overlapping loop over i and k ]]]]]
* store resulting new grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//          other initializations before main loop                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum  = 0.d0
      gfsum2 = 0.d0
      DO j = 1,m_nDim
         DO i = 1,m_nBin
            d(i,j)  = 0.d0
            m_di(i,j) = 0.d0
         ENDDO
      ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          main loop                                                               //
*//////////////////////////////////////////////////////////////////////////////////////
*--------------------------------------!
      DO j = 1,m_nDim                  !
         kounter(j) = 1                !  Loop over digit-vector kounter 
      ENDDO                            !  every digit in kounter runs from 1 to kTotal
 11   CONTINUE                         !  where kTotal=nGroup*nBin, nGroup>1
*--------------------------------------!
      fsum  = 0.d0
      fsum2 = 0.d0
* loop over random events in every (sub)hypercube defined by kounter
      DO k=1,m_nSeries
*****    CALL ranlux(Qrand,m_nDim)
         CALL PseuMar_MakeVec(Qrand,m_nDim)
         xjac = xjac0
* generate randomly vector x inside the given (sub)hypercube
* Qrand is mapped into (1/nGroup)**dDim hypercube insine each byperbin (1/nBin)**dDim
         DO j = 1,m_nDim
            random = Qrand(j)
            xadr = (kounter(j)-random)/m_nGroup +1d0
            iadr(j) = xadr
            beta    = xadr-iadr(j)
            IF(iadr(j) .GT. 1) THEN
               delta = m_xi( iadr(j)   ,j)  -m_xi( iadr(j)-1, j)
               rc    = m_xi( iadr(j)-1 ,j)  +beta*delta
            ELSE
               delta = m_xi(iadr(j),j)
               rc = beta*delta
            ENDIF
            x(j) = m_xl(j) +rc*dx(j)
            xjac  = xjac*delta*m_nBin
         ENDDO
* summing weights event per event
         f   = xjac*Funx(x)      !! <-- Integrand, x and wt are input for Funx
         fsum  = fsum  +f
         fsum2 = fsum2 +f*f
         DO j = 1,m_nDim
            m_di(iadr(j),j) = m_di(iadr(j),j)+f
         ENDDO
* is this approximate? the other one seems to work better
         IF(m_Flag .GE. 0) THEN
            DO j = 1,m_nDim
               d(iadr(j),j) = d(iadr(j),j)+f*f
            ENDDO
         ENDIF
      ENDDO
* bookkeeping weights globaly
      fsum2 = DSQRT(fsum2*m_nSeries)
      fsum2 = (fsum2-fsum)*(fsum2+fsum)    !!!=(fsum2*nSeries - fsum**2)
      gfsum  = gfsum  +fsum
      gfsum2 = gfsum2 +fsum2
* note that iadr(j) is inherited from previous loop, 
* seems correct, iadr depends only on kounter, not on random.
      IF(m_Flag .LT. 0) THEN
         DO j = 1,m_nDim
            d(iadr(j),j) = d(iadr(j),j)+fsum2
         ENDDO
      ENDIF
*----------------------------------------------!
      k = m_nDim                               ! Loop over all hypercubes ends here
 19   CONTINUE                                 ! kounter digit runs from (1111) to (kkkkk)
      kounter(k) = MOD(kounter(k),m_kTotal)+1  ! where k = kTotal.
      IF(kounter(k) .NE. 1) GOTO 11            ! Altogether kTotal*nSeries events
      k = k-1                                  !
      IF(k .GT. 0) GOTO 19                     !
*----------------------------------------------!
*//////////////////////////////////////////////////////////////////////////////////////
*//           final results for this iteration                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum2 = gfsum2*dv2g
      wgt    = gfsum**2/gfsum2
*
      m_si   = m_si   +gfsum *wgt
      m_si2  = m_si2  +gfsum**2
      m_swgt = m_swgt +wgt
      m_schi = m_schi +gfsum**2 *wgt
*
      m_Integral =  m_si/m_swgt                                           !!<- INTEGRAL estimate
      m_Errabs   =  m_swgt*m_Iter/m_si2
      m_Chi2per  =  m_Errabs*(m_schi/m_swgt-m_Integral**2)/(m_Iter -0.999d0)  !!<- CHI-Square
      m_Errabs   =  DSQRT(1d0/m_Errabs)                                   !!<- ERROR estimate
*-------------------------general printout-----------------------------
      IF(m_PriLev .NE. 0) THEN
         gfsum2 = DSQRT(gfsum2)
         WRITE(6,201) m_Iter, gfsum, gfsum2, m_Integral, m_Errabs, m_Chi2per
         IF(m_PriLev .LT. 0) THEN
            DO j = 1,m_nDim
               WRITE(6,202) j,(m_xi(i,j),m_di(i,j),d(i,j),i = 1,m_nBin)
            ENDDO
         ENDIF
      ENDIF
 201  FORMAT(///' Integration by VegasB_ ' / ' Iteration no.',i3,
     $    ':   Integral  = ',g14.8/21x,'Std.Dev.  = ',g10.4 /
     $    ' Accumulated results:   Integral  = ',g14.8 /
     $    24x,'Std.Dev.  = ',g10.4 / 24x,'chi**2 per it''n  = ',g10.4)
 202  FORMAT(' Data for axis',i2 /
     $  ' ',  6x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  '/
     $ (' ', 3g12.4,5x,3g12.4,5x,3g12.4))
*
      IF(m_Iter .GE. m_IterMax .OR.  m_Accur*DABS(m_Integral) .GE. m_Errabs) RETURN
      GOTO 9
*//////////////////////////////////////////////////////////////////////////////////////
*//                      end of big iteration loop                                   //
*//                =============================================                     //
*//////////////////////////////////////////////////////////////////////////////////////
      END

      SUBROUTINE VegasB_PreGenerate
*//////////////////////////////////////////////////////////////////////////////////////
*//    Debug and tests of facilities for generation                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER           i,j,k
      DOUBLE PRECISION  x,z,sum

      m_NevGen = 0
      m_sumWt  = 0d0
      m_sumWt2 = 0d0
      IF(m_PriLev .EQ. -1) THEN
         WRITE(6,*) ' '
         WRITE(6,*) ' ============================= VegasB_Play================================='
         WRITE(6,*) ' nDim, nBin =', m_nDim, m_nBin
         DO j = 1,m_nDim
            WRITE(6,*) 'Data for axis ', j
            WRITE(6,*)
     $           '     x           xi(i)            x            d(i)            x           xi(i)'
            WRITE(6,'(2g12.5,5x, 2g12.5,5x, 2g12.5)') 
     $           (m_xi(i,j),m_di(i,j),i = 1,m_nBin)
         ENDDO
      ENDIF

      m_IntCrude = 1d0
      DO j=1,m_nDim
         sum = 0d0
         DO i=1,m_nBin
            sum = sum + m_di(i,j)
            m_Cumulus(i,j) = sum
         ENDDO
         m_IntCrude=m_IntCrude*sum
      ENDDO
      m_IntCrude=m_IntCrude**(1d0/m_nDim)

      IF(m_PriLev .EQ. -1) THEN
         DO j=1,m_nDim
            WRITE(6,*) 'm_Cumulus(k,j) for axis j=', j
            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
         ENDDO
      ENDIF

      DO j=1,m_nDim
         DO i=1,m_nBin
            m_Cumulus(i, j) = m_Cumulus(i,j)/m_Cumulus(m_nBin ,j)
         ENDDO
      ENDDO

cc      IF(m_PriLev .EQ. -1) THEN
cc         DO j=1,m_nDim
cc            WRITE(6,*) 'm_Cumulus(k,j) normalized for axis j=', j
cc            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
cc         ENDDO
cc      ENDIF

      END

      SUBROUTINE VegasB_Restore(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    enters initialization DATA for Vegas                                          //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER           nunit
      INTEGER           i,j
*
      READ(nunit,200)    m_nDim,m_nBin,m_Iter
      READ(nunit,201)    m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasB_SetAccur(Accur)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  Accur
*-----------------------
      m_Accur    = Accur
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Getters and Setters                                                            //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasB_SetAll(nDim, IterMax, nCall, Accur, PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER           nDim,IterMax,PriLev,ncall
      DOUBLE PRECISION  Accur      
*-------------------------------------------
      m_nDim    = nDim
      m_IterMax = IterMax
      m_PriLev  = PriLev
      m_nCall   = nCall
      m_Accur   = Accur
      END

      SUBROUTINE VegasB_SetIterMax(IterMax)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  IterMax
*-----------------------
      m_IterMax    = IterMax
      END


      SUBROUTINE VegasB_SetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         m_xl(k) = xl(k)
         m_xu(k) = xu(k)
      ENDDO
      END

      SUBROUTINE VegasB_SetnBinReq(nBinReq)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  nBinReq
*--------------------
      m_nBinReq    = nBinReq
      IF( m_nBinReq .GT. m_nBinMax) 
     $     CALL VegasB_Stop1('STOP in VegasA_SetnBinReq, nBinReq>nBinMax')
      END

      SUBROUTINE VegasB_SetnCall(nCall)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  nCall
*--------------------
      m_nCall    = nCall
      END

      SUBROUTINE VegasB_SetnDim(nDim)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  nDim
*--------------------
      m_nDim    = nDim
      END

      SUBROUTINE VegasB_SetPriLev(PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      INTEGER  PriLev
*--------------------
      m_PriLev    = PriLev
      END

      SUBROUTINE VegasB_Stop1(mesage)
*     *******************************
      IMPLICIT NONE
      INCLUDE 'VegasB.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(*   ,'(a,a,a)')     '++++ ', mesage, ' ++++'
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END

      SUBROUTINE VegasC_Dump(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    Stores Vegas grid from last iter. on nuni  for later run                      //
*//    This is now obsolete because extra ENTRY has to be reintroduced in Make       //
*//    in order to profit from this tool.                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER           nunit
      INTEGER           i,j
*
      WRITE(nunit,200)   m_nDim,m_nBin,m_Iter
      WRITE(nunit,201)   m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasC_Finalize(IntegMC,ErrelMC)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
*
      DOUBLE PRECISION     IntegMC,ErrelMC
*-----------------------------------------------------------------------------
      IntegMC =0d0
      ErrelMC =0d0
      IF(m_NevGen .GT. 0) IntegMC=m_IntCrude*m_sumWt/m_NevGen
      IF(m_NevGen .GT. 0) ErrelMC=SQRT( m_sumWt2/m_sumWt**2 -1d0/m_NevGen )
***   WRITE(*,*) 'm_NevGen =', m_NevGen
***   WRITE(*,*) 'm_sumWt,m_sumWt2=    ', m_sumWt,m_sumWt2
***   WRITE(*,*) 'm_sumWt**2/m_sumWt2= ', m_sumWt**2/m_sumWt2
      END       ! VegasC_Finalize

      SUBROUTINE VegasC_Generate(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//    (post)Generation  of the vectors   m_MCvector                                 //
*//    MCvector and MCwt are available through corresponding getters                 //
*//    Grid has to be defined before, using VegasC_Make or read from disk            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*------------------------------------------------------------------
      REAL              Qrand(10)        ! rand. numb. vector
*------------------------------------------------------------------
      INTEGER           i,j,k,jstop
      DOUBLE PRECISION  rand,delran,delx,fun,rho
*
      m_MCwt =1d0
****  CALL ranlux(Qrand,m_nDim)
      CALL PseuMar_MakeVec(Qrand,m_nDim)
      DO k=1,m_nDim
         rand = Qrand(k)
         DO j=1,m_nBin
            jstop=j
            IF( m_Cumulus(j,k) .GT. rand) GOTO 216
         ENDDO
 216     CONTINUE
         IF(jstop .EQ. 1) THEN
            delran = rand/m_Cumulus(jstop,k)
            delx   = m_xi(jstop,k)
            rho    = delx*delran
            m_MCwt = m_MCwt *(delx/m_Cumulus(jstop,k))
         ELSE
            delran = (rand-m_Cumulus(jstop-1,k))/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k))
            delx   = m_xi(jstop,k) -m_xi(jstop-1,k)
            rho    = m_xi(jstop-1,k)  +delx*delran
            m_MCwt = m_MCwt *(delx/(m_Cumulus(jstop,k)-m_Cumulus(jstop-1,k)))
         ENDIF
         m_MCvector(k) = m_xl(k) +rho*(m_xu(k)-m_xl(k))
         m_MCwt = m_MCwt *(m_xu(k)-m_xl(k))
      ENDDO
      Fun = Funx(m_MCvector)
      IF( fun .LT. 0d0 ) GOTO 900
      m_MCwt = m_MCwt *Fun
      m_MCwt = m_MCwt /m_IntCrude     ! apparently <MCwt> ~ IntCrude prior to this point
* statistics
      m_NevGen = m_NevGen+1
      m_sumWt  = m_sumWt   + m_MCwt
      m_sumWt2 = m_sumWt2  + m_MCwt*m_MCwt
      RETURN
 900  WRITE(*,*) ' +++++++ STOP in VegasC_Generate: '
      STOP
      END

      SUBROUTINE VegasC_GetChi2per(Chi2per)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  Chi2per
*-----------------------
      Chi2per    = m_Chi2per
      END

      SUBROUTINE VegasC_GetIntCrude(IntCrude)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  IntCrude
*-----------------------
      IntCrude    = m_IntCrude
      END


      SUBROUTINE VegasC_GetIntegral(Integral,Errabs)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  Integral,Errabs
*-----------------------
      Integral    = m_Integral
      Errabs      = m_Errabs
      END


      SUBROUTINE VegasC_GetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         xl(k) =  m_xl(k)
         xu(k) =  m_xu(k)
      ENDDO
      END

      SUBROUTINE  VegasC_GetMCvector(MCvector)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_nDim
         MCvector(k) = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE VegasC_GetMCwt(MCwt)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE VegasC_Grouping
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Preparatory steps, set all kind of integer constants for iteration              //
*//                                                                                  //
*//  Input params:  nDim, nBinReq, nCall                                             //
*//  Output :       nBin, nGroup, kTotal, nSeries,                                   //
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) nSeries = 2 is always by construction, I tried also nSeries=nDim+1           //
*//  b) the whole algorithm seems to be empirical and rather obscure                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER   ns
*--------------------------------------------------------------------------------------
      ns = m_nDim+1             !! alternative
      ns = 2                    !! <- original
      IF( m_nBinReq .GT. m_nBinMax) CALL VegasC_Stop1(' STOP BinReq> nBinMax ')
* define nGroup and kTotal
      m_kTotal = (m_nCall*(1d0/ns))**(1.d0/m_nDim)   ! expected no. of calls per dimension
      m_nGroup =  1
      IF( ns*m_kTotal .GE. m_nBinReq) THEN        ! m_kTotal big, bins grouped, adjust nBin
         m_nGroup = m_kTotal/m_nBinReq+1
      ENDIF
* define nBin, correct kTotal
      m_nBin    = m_kTotal/m_nGroup
      m_kTotal  = m_nGroup*m_nBin
* define nSeries
      m_nSeries = m_nCall/m_kTotal**m_nDim
      IF(m_nSeries .LT. 2) m_nSeries = 2
*
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//              End of VegasB_                                                      //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//          Pseudoclass VegasC                                                      //
*//                                                                                  //
*//   Performs n-dimensional Monte Carlo integration.                                //
*//      - by G.P. LEPAGE   Sept 1976/(rev)Apr 1978                                  //
*//      - Algorithm described in J.Comp.Phys. 27, 192 (1978)                        //
*//      - Customized by S. Jadach (1999)                                            //
*//      - Event generation added  by S. Jadach (1999)                               //
*//                                                                                  //
*//   Uses cernlib RanMar=PseuMar to generate random numbers.                        //
*//                                                                                  //
*//   Methods:                                                                       //
*//                   Making grid and calculating integral                           //
*//                                                                                  //
*//      VegasC_Initialize                     compulsory initialization             //
*//      VegasC_Make(Funx)                     Make grid, estimate integral          //
*//                                                                                  //
*//      VegasC_SetnDim(nDim)                  redefine nDim    dimension            //
*//      VegasC_SetPriLev(PriLev)              redefine PriLev  printout level       //
*//      VegasC_SetnCall(nCall)                redefine nCall   no of function calls //
*//      VegasC_SetIterMax(IterMax)            redefine IterMax max.no. of iterations//
*//      VegasC_SetAll(nDim, IterMax, nCall, Accur, PriLev)     redefine all         //
*//      VegasC_SetLimits(xl,xu)               set integration limits                //
*//      VegasC_SetnBinReq(nBinReq)            set preferred binning < m_nBinMax     //
*//      VegasC_SetAccur(Accur)                set requested accuracy, Accur=0=defau.//
*//                                                                                  //
*//      VegasC_GetIntegral(Integral,Errabs)   get value of integral                 //
*//      VegasC_GetChi2per(Chi2per)            get chi-squared per dimension         //
*//                                                                                  //
*//      VegasC_Dump(nunit)                    write grid on disk                    //
*//      VegasC_Restore(nunit)                 read  grid from disk                  //
*//                                                                                  //
*//                  Generation ov events using grid from previous step              //
*//                                                                                  //
*//      VegasC_PreGenerate                    initialize                            //
*//      VegasC_GetIntCrude(IntCrude)          get value of crude xsection           //
*//      VegasC_Generate(Funx)                 generate event                        //
*//      VegasC_GetMCvector(MCvector)          get generated event as vector         //
*//      VegasC_GetMCwt(MCwt)                  get MC weight                         //
*//      VegasC_Finalize(IntegMC,ErrelMC)      get final value of integral           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasC_Initialize
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  k,j
*-------------------------------
      m_Flag    = 1
      m_nDim    = 1
      m_IterMax = 5
      m_PriLev  = 2
      m_nCall   = 100000
      m_Accur   = 1d-6
*
      DO k=1,m_nDimMax
         m_xl(k) = 0d0
         m_xu(k) = 1d0
      ENDDO
*
      m_nBinOld  = 1
      DO j = 1,m_nDimMax
         m_xi(1,j) = m_one
      ENDDO

      m_nBinReq = m_nBinMax
      m_Flag   = -1                              !<-- Flag = 1 desabled
      END

      SUBROUTINE VegasC_Make(Funx)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Notes:                                                                          //
*//  a) it seems that m_Flag=-1 is enough                                            //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
*--------------------------------------------------------------------------------------
      DOUBLE PRECISION  d(  m_nBinMax,m_nDimMax) ! <-- 
      DOUBLE PRECISION  xin(m_nBinMax)
      DOUBLE PRECISION  r(  m_nBinMax)
      DOUBLE PRECISION  dx( m_nDimMax)
      DOUBLE PRECISION  dt( m_nDimMax)
      DOUBLE PRECISION  x(  m_nDimMax) 
      INTEGER           kounter( m_nDimMax)      ! counter vector over all subhypercubes
      INTEGER           iadr(    m_nDimMax)      ! adres vector of single hypercube
      DOUBLE PRECISION  xo, xn, xadr, delta, beta, random
      DOUBLE PRECISION  gfsum, gfsum2
      DOUBLE PRECISION  dr,wgt
      DOUBLE PRECISION  xjac0, xjac, rc, dv2g
      DOUBLE PRECISION  f,  fsum,fsum2
      INTEGER           nBinMinus1
      INTEGER           kGrand           ! grand total of subhipercubes = kTotal**nDim
      DOUBLE PRECISION  Calls            ! grand total of MC events per iter. = kGrand*nSeries
      INTEGER           k,i,j
*
      REAL              Qrand(10)        ! from PseuMar
*------------------------------------------------------------------
* external function
      DOUBLE PRECISION  Funx
      EXTERNAL          Funx
*--------------------------------------------------------------------------------------
      CALL VegasC_Grouping
* Important variables used below are:  m_nBin, m_kTotal, m_nSeries, m_nGroup
      Calls = m_nSeries*m_kTotal**m_nDim
      dv2g = (Calls*(1d0/m_kTotal)**m_nDim)**2/m_nSeries**2/(m_nSeries-m_one)
      xjac0 = 1d0/Calls
      DO j = 1,m_nDim
         dx(j) = m_xu(j)-m_xl(j)
         xjac0  = xjac0*dx(j)
      ENDDO
      nBinMinus1 = m_nBin-1
      m_Iter = 0
*//////////////////////////////////////////////////////////////////////////////////////
*//        initializes cummulative variables                                         //
*//////////////////////////////////////////////////////////////////////////////////////
      m_si   = 0d0
      m_si2  = 0d0
      m_swgt = 0d0
      m_schi = 0d0
*//////////////////////////////////////////////////////////////////////////////////////
*//         ====================================================                     //
*//               beginning of the main integration loop                             //
*//////////////////////////////////////////////////////////////////////////////////////
 9    CONTINUE
      m_Iter = m_Iter+1
      IF(m_nBin .NE. m_nBinOld) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//          initial binning different from rebinning after iteration                //
*//////////////////////////////////////////////////////////////////////////////////////
         rc = m_nBinOld*(1d0/m_nBin)
         DO j = 1,m_nDim
            xn = 0d0
            dr = 0d0
* [[[[[ double loop over i and k
            k  = 0
            i  = 0
 4          CONTINUE
            k = k+1
            dr = dr+m_one
            xo = xn
            xn = m_xi(k,j)
 5          CONTINUE
            IF(rc .GT. dr) GOTO 4
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr
            IF(i .LT. nBinMinus1) GOTO 5
* end of double loop over i and k ]]]]]
* store resulting grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
         IF(m_PriLev.NE.0) WRITE(6,200)   m_nDim, Calls,
     $        m_Iter, m_IterMax, m_Accur,
     $        m_nGroup, m_nSeries,   m_kTotal,
     $        m_Flag, m_nBin,
     $        (m_xl(j),m_xu(j), j = 1,m_nDim)
 200     FORMAT(' Input parameters for VegasC_: nDim = ',i7,'   Calls = ',f10.0
     $        /28x,'   Iter=  ',i7, '   IterMax= ',i7,'   Acccur= ',g9.3
     $        /28x,'   nGroup=',i7, '   nSeries= ',i7,'   kTotal= ',i9  
     $        /28x,'   Flag=  ',i7, '   nBin   = ',i7
     $        /28x,'  (xl,xu) = ',
     $        (t40,'( ',g12.6,' , ',g12.6,' )'))
         m_nBinOld = m_nBin
      ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*//          refine grid from previous iteration                                     //
*//////////////////////////////////////////////////////////////////////////////////////
* d(i,j) is redefined by averaging it over 3 adjacent bins (smoothing procedure?)
* dt is sum over columns (bins) in d, it is used in the subsequent loop, 
         DO j = 1,m_nDim
            xo = d(1,j)
            xn = d(2,j)
            d(1,j) = (xo+xn)/2.d0
            dt( j) = d(1,j)
            DO i = 2,nBinMinus1
               d(i,j) = xo+xn
               xo = xn
               xn = d(i+1,j)
               d(i,j) = (d(i,j)+xn)/3.d0
               dt(j)  = dt(j)+d(i,j)
            ENDDO
            d(m_nBin,j) = (xn+xo)/2.d0
            dt(j) = dt(j)+d(m_nBin,j)
         ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          rebin grid from previous iteration preserving bin density               //
*//////////////////////////////////////////////////////////////////////////////////////
* rebin along each j-th axis, rc is of order 1, and later 1/nBin
         DO j = 1,m_nDim
            rc = 0.d0
            DO i = 1,m_nBin
               r(i) = 0.d0
               IF(d(i,j) .GT. 0.d0) THEN
                  xo = dt(j)/d(i,j)
                  r(i) = ((xo-m_one)/xo/DLOG(xo))**m_alpha
               ENDIF
               rc = rc+r(i)
            ENDDO
            rc = rc/m_nBin
            xn = 0d0
            dr = 0d0
* [[[[[ overlapping loop over i and k
            k  = 0
            i  = 0
 25         CONTINUE
            k = k+1
            dr = dr+r(k)
            xo = xn
            xn = m_xi(k,j)
 26         CONTINUE
            IF(rc .GT. dr) GOTO 25
            i = i+1
            dr = dr-rc
            xin(i) = xn-(xn-xo)*dr/r(k)
            IF(i .LT. nBinMinus1) GOTO 26
* end of overlapping loop over i and k ]]]]]
* store resulting new grid
            DO i = 1,nBinMinus1
               m_xi(i,j) = xin(i)
            ENDDO
            m_xi(m_nBin,j) = m_one
         ENDDO
      ENDIF
*//////////////////////////////////////////////////////////////////////////////////////
*//          other initializations before main loop                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum  = 0.d0
      gfsum2 = 0.d0
      DO j = 1,m_nDim
         DO i = 1,m_nBin
            d(i,j)  = 0.d0
            m_di(i,j) = 0.d0
         ENDDO
      ENDDO
*//////////////////////////////////////////////////////////////////////////////////////
*//          main loop                                                               //
*//////////////////////////////////////////////////////////////////////////////////////
*--------------------------------------!
      DO j = 1,m_nDim                  !
         kounter(j) = 1                !  Loop over digit-vector kounter 
      ENDDO                            !  every digit in kounter runs from 1 to kTotal
 11   CONTINUE                         !  where kTotal=nGroup*nBin, nGroup>1
*--------------------------------------!
      fsum  = 0.d0
      fsum2 = 0.d0
* loop over random events in every (sub)hypercube defined by kounter
      DO k=1,m_nSeries
*****    CALL ranlux(Qrand,m_nDim)
         CALL PseuMar_MakeVec(Qrand,m_nDim)
         xjac = xjac0
* generate randomly vector x inside the given (sub)hypercube
* Qrand is mapped into (1/nGroup)**dDim hypercube insine each byperbin (1/nBin)**dDim
         DO j = 1,m_nDim
            random = Qrand(j)
            xadr = (kounter(j)-random)/m_nGroup +1d0
            iadr(j) = xadr
            beta    = xadr-iadr(j)
            IF(iadr(j) .GT. 1) THEN
               delta = m_xi( iadr(j)   ,j)  -m_xi( iadr(j)-1, j)
               rc    = m_xi( iadr(j)-1 ,j)  +beta*delta
            ELSE
               delta = m_xi(iadr(j),j)
               rc = beta*delta
            ENDIF
            x(j) = m_xl(j) +rc*dx(j)
            xjac  = xjac*delta*m_nBin
         ENDDO
* summing weights event per event
         f   = xjac*Funx(x)      !! <-- Integrand, x and wt are input for Funx
         fsum  = fsum  +f
         fsum2 = fsum2 +f*f
         DO j = 1,m_nDim
            m_di(iadr(j),j) = m_di(iadr(j),j)+f
         ENDDO
* is this approximate? the other one seems to work better
         IF(m_Flag .GE. 0) THEN
            DO j = 1,m_nDim
               d(iadr(j),j) = d(iadr(j),j)+f*f
            ENDDO
         ENDIF
      ENDDO
* bookkeeping weights globaly
      fsum2 = DSQRT(fsum2*m_nSeries)
      fsum2 = (fsum2-fsum)*(fsum2+fsum)    !!!=(fsum2*nSeries - fsum**2)
      gfsum  = gfsum  +fsum
      gfsum2 = gfsum2 +fsum2
* note that iadr(j) is inherited from previous loop, 
* seems correct, iadr depends only on kounter, not on random.
      IF(m_Flag .LT. 0) THEN
         DO j = 1,m_nDim
            d(iadr(j),j) = d(iadr(j),j)+fsum2
         ENDDO
      ENDIF
*----------------------------------------------!
      k = m_nDim                               ! Loop over all hypercubes ends here
 19   CONTINUE                                 ! kounter digit runs from (1111) to (kkkkk)
      kounter(k) = MOD(kounter(k),m_kTotal)+1  ! where k = kTotal.
      IF(kounter(k) .NE. 1) GOTO 11            ! Altogether kTotal*nSeries events
      k = k-1                                  !
      IF(k .GT. 0) GOTO 19                     !
*----------------------------------------------!
*//////////////////////////////////////////////////////////////////////////////////////
*//           final results for this iteration                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      gfsum2 = gfsum2*dv2g
      wgt    = gfsum**2/gfsum2
*
      m_si   = m_si   +gfsum *wgt
      m_si2  = m_si2  +gfsum**2
      m_swgt = m_swgt +wgt
      m_schi = m_schi +gfsum**2 *wgt
*
      m_Integral =  m_si/m_swgt                                           !!<- INTEGRAL estimate
      m_Errabs   =  m_swgt*m_Iter/m_si2
      m_Chi2per  =  m_Errabs*(m_schi/m_swgt-m_Integral**2)/(m_Iter -0.999d0)  !!<- CHI-Square
      m_Errabs   =  DSQRT(1d0/m_Errabs)                                   !!<- ERROR estimate
*-------------------------general printout-----------------------------
      IF(m_PriLev .NE. 0) THEN
         gfsum2 = DSQRT(gfsum2)
         WRITE(6,201) m_Iter, gfsum, gfsum2, m_Integral, m_Errabs, m_Chi2per
         IF(m_PriLev .LT. 0) THEN
            DO j = 1,m_nDim
               WRITE(6,202) j,(m_xi(i,j),m_di(i,j),d(i,j),i = 1,m_nBin)
            ENDDO
         ENDIF
      ENDIF
 201  FORMAT(///' Integration by VegasC_ ' / ' Iteration no.',i3,
     $    ':   Integral  = ',g14.8/21x,'Std.Dev.  = ',g10.4 /
     $    ' Accumulated results:   Integral  = ',g14.8 /
     $    24x,'Std.Dev.  = ',g10.4 / 24x,'chi**2 per it''n  = ',g10.4)
 202  FORMAT(' Data for axis',i2 /
     $  ' ',  6x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  ',
     $       11x,'x',7x,'  delt i  ',2x,' conv''ce  '/
     $ (' ', 3g12.4,5x,3g12.4,5x,3g12.4))
*
      IF(m_Iter .GE. m_IterMax .OR.  m_Accur*DABS(m_Integral) .GE. m_Errabs) RETURN
      GOTO 9
*//////////////////////////////////////////////////////////////////////////////////////
*//                      end of big iteration loop                                   //
*//                =============================================                     //
*//////////////////////////////////////////////////////////////////////////////////////
      END

      SUBROUTINE VegasC_PreGenerate
*//////////////////////////////////////////////////////////////////////////////////////
*//    Debug and tests of facilities for generation                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER           i,j,k
      DOUBLE PRECISION  x,z,sum

      m_NevGen = 0
      m_sumWt  = 0d0
      m_sumWt2 = 0d0
      IF(m_PriLev .EQ. -1) THEN
         WRITE(6,*) ' '
         WRITE(6,*) ' ============================= VegasC_Play================================='
         WRITE(6,*) ' nDim, nBin =', m_nDim, m_nBin
         DO j = 1,m_nDim
            WRITE(6,*) 'Data for axis ', j
            WRITE(6,*)
     $           '     x           xi(i)            x            d(i)            x           xi(i)'
            WRITE(6,'(2g12.5,5x, 2g12.5,5x, 2g12.5)') 
     $           (m_xi(i,j),m_di(i,j),i = 1,m_nBin)
         ENDDO
      ENDIF

      m_IntCrude = 1d0
      DO j=1,m_nDim
         sum = 0d0
         DO i=1,m_nBin
            sum = sum + m_di(i,j)
            m_Cumulus(i,j) = sum
         ENDDO
         m_IntCrude=m_IntCrude*sum
      ENDDO
      m_IntCrude=m_IntCrude**(1d0/m_nDim)

      IF(m_PriLev .EQ. -1) THEN
         DO j=1,m_nDim
            WRITE(6,*) 'm_Cumulus(k,j) for axis j=', j
            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
         ENDDO
      ENDIF

      DO j=1,m_nDim
         DO i=1,m_nBin
            m_Cumulus(i, j) = m_Cumulus(i,j)/m_Cumulus(m_nBin ,j)
         ENDDO
      ENDDO

cc      IF(m_PriLev .EQ. -1) THEN
cc         DO j=1,m_nDim
cc            WRITE(6,*) 'm_Cumulus(k,j) normalized for axis j=', j
cc            WRITE(6,'(5g16.8)') (m_Cumulus(k,j),k=1,m_nBin)
cc         ENDDO
cc      ENDIF

      END

      SUBROUTINE VegasC_Restore(nunit)
*//////////////////////////////////////////////////////////////////////////////////////
*//    enters initialization DATA for Vegas                                          //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER           nunit
      INTEGER           i,j
*
      READ(nunit,200)    m_nDim,m_nBin,m_Iter
      READ(nunit,201)    m_si,m_si2,m_swgt,m_schi, 
     $                   ( m_xl(j), m_xu(j), j = 1,m_nDim),
     $                   ((m_xi(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   ((m_di(i,j),i = 1,m_nBin), j = 1,m_nDim),
     $                   m_Integral, m_Errabs
 200  FORMAT(3i8)
 201  FORMAT(3d24.16)
      END

      SUBROUTINE VegasC_SetAccur(Accur)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  Accur
*-----------------------
      m_Accur    = Accur
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Getters and Setters                                                            //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////

      SUBROUTINE VegasC_SetAll(nDim, IterMax, nCall, Accur, PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER           nDim,IterMax,PriLev,ncall
      DOUBLE PRECISION  Accur      
*-------------------------------------------
      m_nDim    = nDim
      m_IterMax = IterMax
      m_PriLev  = PriLev
      m_nCall   = nCall
      m_Accur   = Accur
      END

      SUBROUTINE VegasC_SetIterMax(IterMax)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  IterMax
*-----------------------
      m_IterMax    = IterMax
      END


      SUBROUTINE VegasC_SetLimits(xl,xu)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      DOUBLE PRECISION  xl(*),xu(*)
      INTEGER  k
*-----------------------
      DO k=1,m_nDimMax
         m_xl(k) = xl(k)
         m_xu(k) = xu(k)
      ENDDO
      END

      SUBROUTINE VegasC_SetnBinReq(nBinReq)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  nBinReq
*--------------------
      m_nBinReq    = nBinReq
      IF( m_nBinReq .GT. m_nBinMax) 
     $     CALL VegasC_Stop1('STOP in VegasA_SetnBinReq, nBinReq>nBinMax')
      END

      SUBROUTINE VegasC_SetnCall(nCall)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  nCall
*--------------------
      m_nCall    = nCall
      END

      SUBROUTINE VegasC_SetnDim(nDim)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  nDim
*--------------------
      m_nDim    = nDim
      END

      SUBROUTINE VegasC_SetPriLev(PriLev)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      INTEGER  PriLev
*--------------------
      m_PriLev    = PriLev
      END

      SUBROUTINE VegasC_Stop1(mesage)
*     *******************************
      IMPLICIT NONE
      INCLUDE 'VegasC.h'
      SAVE
      CHARACTER*(*) mesage
      INTEGER id
*-----------------------------
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(*   ,'(a,a,a)')     '++++ ', mesage, ' ++++'
      WRITE(*   ,'(a)')         '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END


      SUBROUTINE Vesk1_Divide(funsko,jdiv)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*// this routine belongs to vesko1 package                                   //
*// it sudivides into two equal parts the interval                           //
*// (xx(jdiv),xx(jdiv+1))  in the 1-dim. latice                              //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Vesk1.h'
*
      DOUBLE PRECISION  funsko
      EXTERNAL          funsko
      DOUBLE PRECISION  xnew
      INTEGER           j,jdiv
*----------------------------------------------------------------------------
      xnew=.5d0*(xx(jdiv) +xx(jdiv+1))
      DO j=jmax,jdiv,-1
         xx(j+2)  =xx(j+1)
         yy(j+2)  =yy(j+1)
         zint(j+1)=zint(j)
      ENDDO
      xx(jdiv+1)= xnew
      yy(jdiv+1)= funsko(xnew)
      IF(yy(jdiv+1) .LT. 0.) GOTO 999
      zint(jdiv)  =.5d0*(yy(jdiv+1)+yy(jdiv)  )*(xx(jdiv+1)-xx(jdiv)  )
      zint(jdiv+1)=.5d0*(yy(jdiv+2)+yy(jdiv+1))*(xx(jdiv+2)-xx(jdiv+1))
      jmax=jmax+1
      RETURN
 999  CONTINUE
      WRITE(*,'(a)') ' *** STOP Vesk1_Divide, negative value of funsko '
      STOP
      END



      SUBROUTINE Vesk1_Finalize(cinteg,errint,zcrude)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Vesk1.h'
*
      DOUBLE PRECISION     cinteg,errint,zcrude
*-----------------------------------------------------------------------------
      cinteg =0d0
      errint =0d0
      zcrude =0d0
      IF(nevs .GT. 0) cinteg=zsum*swt/float(nevs)
      IF(nevs .GT. 0) errint=sqrt(sswt/swt**2-1.d0/float(nevs))
      IF(nevs .GT. 0) zcrude=  zsum
      END       ! Vesk1_Finalize

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//              End of VegasC_                                                      //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Pseudo-CLASS  Vesk1                                  //
*//                                                                          //
*//   Purpose: generate one-dimensional arbitrary distribution rho(x)        //
*//   where x is in the range (0,1).                                         //
*//   Now Denser grid!!!!                                                    //
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
*
*
*
      SUBROUTINE Vesk1_Initialize(funsko,crude)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                                                                          //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Vesk1.h'
*
      DOUBLE PRECISION  funsko, crude
      EXTERNAL funsko
*
      DOUBLE PRECISION      drvec(10)
      DOUBLE PRECISION      wt,sum,zmx,ymax
      INTEGER    j,k,jdiv
      INTEGER    iniran
*-----------------------------------------------------------------------------
* initialisation part, see vinsko for more comments

      wt   = 0.d0
      swt  = 0.d0
      sswt = 0.d0
      nevs=  -911119
* initialisation part, sampling distribution funsko
* and filling matrices xx,yy,zint etc.
      jmax =1
      xx(1)=0.d0
      xx(2)=1.d0

      yy(1)=funsko(xx(1))
      yy(2)=funsko(xx(2))

      IF(yy(1) .LT. 0.d0 .OR. yy(2) .LT. 0.d0) go to 999
      zint(1)=.5d0*(yy(2)+yy(1))*(xx(2)-xx(1))
*
      jdiv=1

      DO k=1,jlim2-1
         IF(jmax .LT. jlim1) THEN
*  note that Vesk1_Divide increments jmax=jmax+1 in every CALL
            CALL Vesk1_Divide(funsko,jdiv)
            jdiv=jdiv+2
            IF(jdiv .GT. jmax) jdiv=1
         ELSE
            jdiv=1
            zmx=zint(1)
            DO j=1,jmax
               IF(zmx .LT. zint(j)) THEN
                  zmx=zint(j)
                  jdiv=j
               ENDIF
            ENDDO
            CALL Vesk1_Divide(funsko,jdiv)
         ENDIF
      ENDDO

*     
*...  final administration, normalizing zint etc.
      zsum =0.d0
      DO j=1,jmax
         ymax= max( yy(j+1),yy(j))

         zint(j)=ymax*(xx(j+1)-xx(j))
         zsum=zsum+zint(j)
      ENDDO

      sum=0.
      DO j=1,jmax
         sum=sum+zint(j)
         zint(j)=sum/zsum
      ENDDO
      crude = zsum
      RETURN
*
 999  WRITE(*,'(a)') ' **** STOP in vesk01, negative value of funsko '
      STOP
      END       ! Vesk1_Initialize


      SUBROUTINE Vesk1_Make(funsko,x,fn,wt)
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'Vesk1.h'
*
      DOUBLE PRECISION  funsko
      EXTERNAL funsko
*
      DOUBLE PRECISION      fn,x,d,yymax,wt,rnumb
      REAL                  rvec(10)
      INTEGER    j,jstop,iwarm
      INTEGER    klower,krange,kurrent
*
      DATA iwarm /0/

* check if initialization was done (not trivial in old poor fortran)
      IF(iwarm .EQ. 0) THEN
         iwarm=1
         IF(nevs .EQ.  -911119 ) THEN
            nevs = 0
         ELSE
            GOTO 901
         ENDIF
      ENDIF
      
      CALL PseuMar_MakeVec(rvec,1)
      rnumb = rvec(1)
****----------------------------------------------
**   Old simple search method
****----------------------------------------------
**      DO j=1,jmax
**         jstop=j
**         IF(zint(j) .GT. rnumb) GOTO 216
**      ENDDO
** 216  CONTINUE
*====================================================
**  Equivalent faster Weierstrass-type search method
*====================================================
      klower   = 0
      krange   = jmax
 330  CONTINUE
      krange   = krange/2
      kurrent  = klower +krange
      IF(kurrent.EQ.0) GOTO 350
      IF(zint(kurrent) .LE. rnumb) THEN
         klower = kurrent
      ENDIF
      IF(krange.EQ.0) GOTO 350
      GOTO 330
 350  CONTINUE
      jstop = kurrent+1
*====================================================
      IF(jstop .EQ. 1) THEN
         d=rnumb/zint(1)
      ELSE
         d =(rnumb-zint(jstop-1))/(zint(jstop)-zint(jstop-1))
      ENDIF
      x=xx(jstop)*(1.d0 -d )+xx(jstop+1)*d
      fn=funsko(x)
      IF(fn .LT. 0.d0) GOTO 999
      yymax=max(yy(jstop+1),yy(jstop))
      wt=fn/yymax
      nevs=nevs+1
      swt=swt+wt
      sswt=sswt+wt*wt
*
      RETURN
 901  WRITE(*,'(a)') ' **** STOP in vesko1, lack of initialisation'
      STOP
 999  WRITE(*,'(a)') ' **** STOP in vesk01, negative value of funsko '
      STOP
      END       ! Vesk1_Make

      SUBROUTINE YFSini2_AngBre(am2,del1,del2,costhg,sinthg,dist0,dist1)
*     *****************************************************************
* This routine generates photon angular distribution
* in the rest frame of the fermion pair.
* The distribution is the S-factor without mass term,
* i.e. without terms 2p_1p_2/(kp_1)(kp_2)
* Fermion mass is treated exactly!
* INPUT:  
*     am2 = 4*massf**2/s where massf is fermion mass
*     and s is effective mass squared of the parent fermion-pair.
* OUTPUT:
*     del1= 1-beta*cos(theta)
*     del2= 1+beta*cos(theta)
*     costhg, sinthg, cos and sin of the photon
*     angle with respect to fermions direction
*     dist0 = distribution generated, without m**2/(kp)**2 terms
*     dist1 = distribution with m**2/(kp)**2 terms
*     ***************************************
      IMPLICIT NONE
      DOUBLE PRECISION  am2,del1,del2,costhg,sinthg,dist0,dist1
* locals
      REAL              rn(10)
      DOUBLE PRECISION  a,eps,beta
*------------------------------------------------------------------------------
      CALL PseuMar_MakeVec(rn,2)
      beta =sqrt(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=sqrt(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

      SUBROUTINE YFSini2_angbre2(iph,am2,del1,del2,costhg,sinthg,dist0,dist1)
*     **********************************************************
* modified version of angbre, added iph argument which enforces
* forward or backward peak in photon distribution
*     ***************************************
      IMPLICIT NONE
      INTEGER           iph
      DOUBLE PRECISION  am2,del1,del2,costhg,sinthg,dist0,dist1
* locals
      REAL              rn(10)
      DOUBLE PRECISION  a,eps,beta
*---------------------------------------------------------------------------------
      CALL PseuMar_MakeVec(rn,2)

cccc[[[[ very special tests
*      IF( iph .LE. 2) rn(2)=1d0 ! both photons 1 and 2 are forward
* lub
*      IF( iph .EQ. 1) rn(2)=1d0 ! photons 1 forward
*      IF( iph .EQ. 2) rn(2)=0d0 ! photons 2 backward
cccc]]]]

      beta =sqrt(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=sqrt(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                End of   Pseudo-CLASS  Taoula                                    //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//                     Pseudo-CLASS  YFSini2                                //
*//                                                                          //
*//                  !!!!! SPECIAL TESTS !!!!!!                              //
*//                                                                          //
*//   Purpose:  ISR photon emission, photon multiplicity and momenta         //
*//   ====================================================================== //
*//   Simplistic ISR generation without modulation of s', for SPECIAL TESTS. //
*//   (!!!!No dilatation !!!!)                                               //
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//  The algorithm in this subprogram was ALSO described in:                 //
*//  ``Yennie-Frautschi-Suura soft photons in Monte Carlo event generators'' //
*//             Unpublished report by S. Jadach,                             //
*//          MPI-Munchen, MPI-PAE/PTh 6/87, Jan. 1987.                       //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////


      SUBROUTINE YFSini2_Initialize( amel,alfinv,vvmin,nmax,out,KeyWtm,MltISR)
*
      INCLUDE 'YFSini2.h'
      SAVE
*
      DOUBLE PRECISION    amel,alfinv,vvmin
      INTEGER  nmax,out,KeyWtm,MltISR
*
      m_amel    = amel
      m_alfinv  = alfinv
      m_vvmin   = vvmin
      m_nmax    = nmax
      m_out     = out
      m_KeyWtm  = KeyWtm
      m_MltISR  = MltISR
      END


      SUBROUTINE YFSini2_Make(CMSene,                   ! Input
     $     vv,p1,p2,nphot,sphot,sphum,ygr,zet,qq,wtini) ! Output
*     *************************************************************
      IMPLICIT NONE
      DOUBLE PRECISION  pi
      PARAMETER( pi=3.1415926535897932d0)
      DOUBLE PRECISION  CMSene,vv,sphum(4),sphot(100,4),ygr(100),zet(100)
*
      INCLUDE 'KarLud.h'
*
      DOUBLE PRECISION  xphot(100,4)    ! photon momenta before rescaling
      DOUBLE PRECISION  pp(4),pk(4)
      DOUBLE PRECISION  p1(4),p2(4),qq(4),xph(100)
      DOUBLE PRECISION  rrdummy(100)
      REAL              rr(100)
      SAVE
*
      DOUBLE PRECISION   eta1,eta2,beta
      DOUBLE PRECISION   dist0,dist1,cg,sg,sprim,gami,gami2
      DOUBLE PRECISION   wtm,xk,vmax,am2,ene,average
      DOUBLE PRECISION   phi,wt_cut,wtini,wt_mas
      DOUBLE PRECISION   alf1,del1,del2
      REAL               rvec(10)
      INTEGER i,j,k,nphot
*
      alf1 = 1d0/pi/m_alfinv
      ene  = CMSene/2d0
* Define 4-momenta of the initial charged particles (emitters)
      CALL KinLib_givpair(CMSene,m_amel,m_amel,p1,p2,beta,eta1,eta2)
* Here gami2 must be used instead of gami (mass term neglected)
      am2  = (m_amel/ene)**2
      beta = sqrt(1d0-am2)
      gami  = 2d0*alf1* (dlog((1+beta)**2/am2) - 1d0)
      gami2 = 2d0*alf1*  dlog((1+beta)**2/am2)
      IF(m_KeyWtm .EQ. 1) gami2 = gami
      wt_mas  = (1d0/m_vvmin)**(gami2-gami)
      DO i=1,m_nmax
         xph(i)=0d0
         ygr(i)=0d0
         zet(i)=0d0
         DO j=1,4
            xphot(i,j)=0d0
            sphot(i,j)=0d0
         ENDDO
      ENDDO
* generate photon multiplicity
      average = gami2*dlog(1d0/m_vvmin)
      CALL YFSini2_PoissGen(average,m_nmax,nphot,rrdummy)

* refill rr in order to avoid ordering
      IF(nphot .GT. 0) CALL PseuMar_MakeVec(rr,nphot)

      wt_cut  = 1d0
      DO i=1,nphot
         xph(i)=(m_vvmin)**rr(i)
      ENDDO
      DO i=1,nphot
         xk=xph(i)
*****    CALL YFSini2_angbre(am2,del1,del2,cg,sg,dist0,dist1)    ! standard
         CALL YFSini2_angbre2(i,am2,del1,del2,cg,sg,dist0,dist1) ! test
         wtm=dist1/dist0
         wt_mas    =wt_mas*wtm
         CALL PseuMar_MakeVec(rvec,1)
         phi=2d0*pi*rvec(1)
         xphot(i,1)=xk*sg*cos(phi)
         xphot(i,2)=xk*sg*sin(phi)
         xphot(i,3)=xk*cg
         xphot(i,4)=xk
         ygr(i)    =xk*del1/2d0
         zet(i)    =xk*del2/2d0
      ENDDO
*
* photon momenta rescaled into GEV units
      DO j=1,4
         sphum(j)=0d0
      ENDDO
      DO  i=1,nphot
         DO  j=1,4
            sphot(i,j)=xphot(i,j)*ene
            sphum(j)=sphum(j)+sphot(i,j)
         ENDDO
      ENDDO

* 4-momentum left after photon emission
      DO k=1,4
         qq(k)=-sphum(k)
      ENDDO
      qq(4)=qq(4)+CMSene
      sprim = qq(4)**2 -qq(3)**2 -qq(2)**2 -qq(1)**2
      vv = 1d0 -sprim/CMSene**2
      IF( qq(4) .LE. 0d0) wt_cut  = 0d0  !!!! important !!!!
      IF( vv .GT. vmax)   wt_cut  = 0d0

* Total ISR weight
      IF(m_KeyWtm .EQ. 1) wt_mas=1d0
      wtini = wt_mas *wt_cut   ! =ypar(251)
*------------------------------------
*  for debug
      CALL KK2f_SetOneY(252,wt_mas)
      CALL KK2f_SetOneY(254,wt_cut)
      CALL KK2f_SetOneY( 10,vv)
      CALL KK2f_SetOneY(255,vv)
*------------------------------------
      END  !yfs_ini2


      SUBROUTINE YFSini2_PoissGen(average,nmax,mult,rr)
*     ************************************************
* Last corr. nov. 91
* This generates photon multipl. nphot according to poisson distr.
* Input:  average = average multiplicity
*         nmax  = maximum multiplicity
* Output: mult = generated multiplicity
*         rr(1:100) list of ordered uniform random numbers,
*         a byproduct result, to be eventually used for some further
*         purpose (i.e.  generation of photon energies).
*     ************************
      IMPLICIT NONE
      DOUBLE PRECISION  average
      DOUBLE PRECISION  rr(*)
      INTEGER           nmax,mult
* locals
      DOUBLE PRECISION  y,sum
      INTEGER           it,nfail,nn
      REAL              rvec(10)
      DATA nfail/0/
*----------------------------------------------------------------
 50   nn=0
      sum=0d0
      DO it=1,nmax
         CALL PseuMar_MakeVec(rvec,1)
         y= log(rvec(1))
         sum=sum+y
         nn=nn+1
         rr(nn)=sum/(-average)
         IF(sum .LT. -average) GOTO 130
      ENDDO
      nfail=nfail+1
      IF(nfail .GT. 100) GOTO 900
      GOTO 50
 130  mult=nn-1
      RETURN
 900  WRITE(*,*) ' YFSini2_PoissGen: to small nmax ',nmax
      STOP
      END
