c
c A.Valassi 20/06/2001
c - Remove all calls to Photos, Tauola, Jetset
c - Include TAUOLA subroutines angfi,rotod1,rotod2, rotod3
c A.Valassi 20/06/2001
c - Remove KORWAN from linked libraries (it is not called in original code!)
c A.Valassi 20/06/2001
c - Cleanup SAVE statements
c
      SUBROUTINE FILEXP(XPAR,NPAR)   
*     ***********************************   
*************************************************************************
* This version of FILEXP is taken from KoralW and customized for YFSWW3 *
*************************************************************************
C TRANSFERS AND DEFINES INPUT PARAMS, PRINTS INPUT PARAMETERS 
! Modified by Wieslaw Placzek,            CERN, July 1999
! Last update: 26.01.2001       by: WP
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      DIMENSION  XPAR( *),NPAR( *)          
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW
! This common contains parameters of non-established particles such as higgs
! Which need to be used by pre-sampler (to be activated by dipswitch IHIG
      COMMON / WEKIN3 / AMHIG,GAMHIG,IHIG
      COMMON / Higtop / amH,amt
      COMMON / DECDAT / AMAFIN(20), BR(20) 
! Cumulant of branching ratios
      COMMON / BrCumF / BrCum(20)
      COMMON / DECCOD / ICOD(20)
      COMMON / WT_MAX / WTMAX,WTMAX_CC03     
! This common can be everywhere, contains various switches
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT    
      COMMON / SPISET / POLAR1,POLAR2,POLFI1,POLFI2           
      COMMON / UUREC  / UU,EPS,DELTA        
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI                   
      COMMON / INOUT  / NINP,NOUT 
      COMMON / MATPAR / PI,CEULER     
      COMMON / PHYPAR / ALFINV,GPICOB  
! Some useful formats
      COMMON / BXFMTS / BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G 
      CHARACTER*80      BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G 
      CHARACTER*80      BXL2C            
      COMMON / RANPAR / KEYRND
! TAUOLA, PHOTOS and JETSET overall switches
cav   COMMON / LIBRA  / JAK1,JAK2,ITDKRC,IFPHOT,IFHADM,IFHADP
!   --Anomalous WWV Couplings
      COMMON / AnCoCo / g1(2),kap(2),lam(2),g4(2),g5(2),kapt(2),lamt(2)
      COMPLEX*16 g1,kap,lam,g4,g5,kapt,lamt
! user mask on final states
      COMMON /cumask/ user_umask(202)
      SAVE / WEKING /,/ KEYYFS /,/ SPISET /,/ UUREC  /,/ VVREC  /
cav   SAVE / INOUT  /,/ BXFMTS /,/ RANPAR /,/ WEKIN2 /,/ LIBRA  /
      SAVE / INOUT  /,/ BXFMTS /,/ RANPAR /,/ WEKIN2 / !cav
      SAVE / DECDAT /,/ DECCOD /,/ KeyOth /,/ AnCoCo /,/ WT_MAX /
      SAVE / MATPAR /,/ PHYPAR /,/ KeyKey /,/ Higtop /,/cumask/
      SAVE / WEKIN3 /,/ BrCumF /
!-- The CKM mixing matrix and VV+ which should be =1 (V - unitary) 
      DIMENSION VCKM(3,3),VVH(3,3)
!
! ...BX-formats for nice and flexible outputs                 
      BXOPE =  '(//1X,15(5H*****)    )'     
      BXTXT =  '(1X,1H*,                  A48,25X,    1H*)'   
      BXL1I =  '(1X,1H*,I17,                 16X, A20,A12,A7, 1X,1H*)'
      BXL1F =  '(1X,1H*,F17.8,               16X, A20,A12,A7, 1X,1H*)' 
      BXL2F =  '(1X,1H*,F17.8, 4H  +-, F11.8, 1X, A20,A12,A7, 1X,1H*)'
      BXL1G =  '(1X,1H*,G17.8,               16X, A20,A12,A7, 1X,1H*)'
      BXL2G =  '(1X,1H*,G17.8, 4H  +-, F11.8, 1X, A20,A12,A7, 1X,1H*)'
      BXCLO =  '(1X,15(5H*****)/   )'  
      BXL2C ='(1X,1H*,1H(,F14.8,3H +i,F13.7,1H),1X,A20,A12,A7,1X,1H*)' 
*///////////////////////////////////////////////////////////
*//   Math. constants, should go to PARAMETER !!!
      PI=3.1415926535897932D0
      CEULER = 0.57721566D0                  
      ZET2= PI**2/6D0  
      ZET3= 1.2020569031595942854D0
*///////////////////////////////////////////////////////////
*//                                                       //
*//  Npar is now pure internal object (obsolete)          //
*//  below we translate xpar--> npar fot internal use     //
*//                                                       //
*///////////////////////////////////////////////////////////
*     KeyRad = 1000*KeyCul +100*KeyNLL +10*KeyFSR +KeyISR
      npar(1)= 
     $           +NINT(xpar(1011))  ! KeyISR
     $        +10*NINT(xpar(1012))  ! KeyFSR
     $       +100*NINT(xpar(1013))  ! KeyNLL
     $      +1000*NINT(xpar(1014))  ! KeyCul
*
* KeyPhy = 100000*KeyWu +10000*KeyRed +1000*KeySpn+100*KeyZet+10*KeyMas+KeyBra 
      npar(2)= 
     $           +NINT(xpar(1021))  ! KeyBra 
     $        +10*NINT(xpar(1022))  ! KeyMas
     $       +100*NINT(xpar(1023))  ! KeyZet
     $      +1000*NINT(xpar(1024))  ! KeySpn
     $     +10000*NINT(xpar(1025))  ! KeyRed
     $    +100000*NINT(xpar(1026))  ! KeyWu
*     KeyTek = 100*KeySmp +10*KeyRnd +KeyWgt
      xpar(1033) = 0d0              ! KeySmp = 0 in YFSWW3
      npar(3)= 
     $           +NINT(xpar(1031))  ! KeyWgt
     $        +10*NINT(xpar(1032))  ! KeyRnd
     $       +100*NINT(xpar(1033))  ! KeySmp  
     $      +1000*NINT(xpar(2002))  ! KeyLPA   ! YFSWW specific
*     KeyMis = 10000*KeyWon +1000*KeyZon+100*KeyAcc+10*Key4f +KeyMix
      npar(4)= 
     $           +NINT(xpar(1041))  ! KeyMix
     $        +10*NINT(xpar(1042))  ! Key4f
     $       +100*NINT(xpar(1043))  ! KeyAcc
     $      +1000*NINT(xpar(1044))  ! KeyZon
     $     +10000*NINT(xpar(1045))  ! KeyWon
*
      npar( 5)= NINT(xpar(1055))  ! KeyDWM
      npar( 6)= NINT(xpar(1056))  ! KeyDWP
      npar( 7)= NINT(xpar(1057))  ! Nout
*
      npar(21)= NINT(xpar(1071))  ! JAK1
      npar(22)= NINT(xpar(1072))  ! JAK2
      npar(23)= NINT(xpar(1073))  ! ITDKRC
      npar(24)= NINT(xpar(1074))  ! IFPHOT
      npar(25)= NINT(xpar(1075))  ! IFHADM
      npar(26)= NINT(xpar(1076))  ! IFHADP
* Anomalous couplings
      DO i=101,302
         npar(i)=NINT(xpar(i+1000))
      ENDDO
*///////////////////////////////////////////////////////////
*//         end of translation xpar-->npar                //
*///////////////////////////////////////////////////////////
*  Some phys. constants
      amel    =xpar(100)
      AlfInv  =xpar(101)
      gpicob  =xpar(102)
!-----------------------------------------------------------------------
! Physics switches 
! KeyRad =  1000*KeyCul+100*KeyNLL+10*KeyFSR+KeyISR
      KeyRad = NPAR(1)
      KeyISR = MOD(KeyRad,10)
      KeyFSR = MOD(KeyRad,100)/10
      KeyNLL = MOD(KeyRad,1000)/100
      KeyCul = MOD(KeyRad,10000)/1000
!
! KeyPhy = 100000*KeyWu +10000*KeyRed +1000*KeySpn 
!                       +100*KeyZet +10*KeyMas +KeyBra
      KeyPhy = NPAR(2)
      KeyBra = MOD(KeyPhy,10)
      KeyMas = MOD(KeyPhy,100)/10
      KeyZet = MOD(KeyPhy,1000)/100
      KeySpn = MOD(KeyPhy,10000)/1000
      KeyRed = MOD(KeyPhy,100000)/10000
      KeyWu  = MOD(KeyPhy,1000000)/100000
!>>> It has to be KeyMas=1 and KeyRed=0 in YFSWW3
      KeyMaK = KeyMas
      KeyReK = KeyRed
      KeyMas = 1
      KeyRed = 0
      xpar(1022) = KeyMas
      xpar(1025) = KeyRed
      npar(2)= 
     $           +NINT(xpar(1021))  ! KeyBra 
     $        +10*NINT(xpar(1022))  ! KeyMas
     $       +100*NINT(xpar(1023))  ! KeyZet
     $      +1000*NINT(xpar(1024))  ! KeySpn
     $     +10000*NINT(xpar(1025))  ! KeyRed
     $    +100000*NINT(xpar(1026))  ! KeyWu
      KeyPhK = KeyPhy
      KeyPhy = NPAR(2)
!-----------------------------------------------------------------------
! Technical switches
! KeyTek = 100*KeySmp +10*KeyRnd +KeyWgt
      KeyTek = NPAR(3)
      KeyWgt = MOD(KeyTek,10)
      KeyRnd = MOD(KeyTek,100)/10
      KeySmp = MOD(KeyTek,1000)/100 
      KeyLPA = MOD(KeyTek,10000)/1000
!>>> KeySmp has to be =0 in YFSWW3
      KeySmK = KeySmp
      KeySmp = 0
      xpar(1033) = KeySmp
      npar(3)= 
     $           +NINT(xpar(1031))  ! KeyWgt
     $        +10*NINT(xpar(1032))  ! KeyRnd
     $       +100*NINT(xpar(1033))  ! KeySmp  
     $      +1000*NINT(xpar(2002))  ! KeyLPA   ! YFSWW specific
      KeyTkK = KeyTek
      KeyTek = NPAR(3)
!-----------------------------------------------------------------------
! Miscelaneous, for future develoment
! KeyMis = 10000*KeyWon +1000*KeyZon+100*KeyAcc +10*Key4f +KeyMix
      KeyMis = NPAR(4)
      KeyMix = MOD(KeyMis,10)
      Key4f  = MOD(KeyMis,100)/10
      KeyAcc = MOD(KeyMis,1000)/100
      KeyZon = MOD(KeyMis,10000)/1000
      KeyWon = MOD(KeyMis,100000)/10000
!>>> It has to be Key4f=0, KeyZon=0 and KeyWon=1 in YFSWW3
      Key4fK = Key4f
      KeyZoK = KeyZon 
      KeyWoK = KeyWon
      Key4f  = 0
      KeyZon = 0
      KeyWon = 1
      xpar(1042) = Key4f
      xpar(1044) = KeyZon
      xpar(1045) = KeyWon
      npar(4)= 
     $           +NINT(xpar(1041))  ! KeyMix
     $        +10*NINT(xpar(1042))  ! Key4f
     $       +100*NINT(xpar(1043))  ! KeyAcc
     $      +1000*NINT(xpar(1044))  ! KeyZon
     $     +10000*NINT(xpar(1045))  ! KeyWon
      KeyMiK = KeyMis
      KeyMis = NPAR(4)
! Higgs pre-sampler dipswitch: =0 in YFSWW3
      IHIG=0
!-----------------------------------------------------------------------
      KEYDWM = NPAR(5)     
      KEYDWP = NPAR(6)     
      IF((KeyWon*KeyZon*(KEYDWP+KEYDWM) .NE. 0) .OR.
     $   (KeyWon .EQ. 0 .AND. KeyZon.eq.0       )     ) THEN
          WRITE(6,*) 'FILEXP==> inconsistent input: '
          WRITE(6,*) 'KeyWon=',KeyWon,'KeyZon=',KeyZon
          WRITE(6,*) 'KeyDWP=',KeyDWP,'KeyDWM=',KeyDWM
          STOP
      ENDIF
      nout = npar(7)
      IF(nout. LE. 0) nout=16     
cav   jak1 = npar(21)
cav   jak2 = npar(22)
cav   itdkrc = npar(23)
cav   ifphot = npar(24)
cav   ifhadm = npar(25)
cav   ifhadp = npar(26)
      cmsene = xpar(1)      
      gmu    = xpar(2)   
      alfwin = xpar(3)
      amaz   = xpar(4)
      gammz  = xpar(5)
      amaw   = xpar(6)
      gammw  = xpar(7)
      vvmin  = xpar(8)
      vvmax  = xpar(9)
      wtmax  = xpar(10)
      amhig  = xpar(11)
      gamhig = xpar(12)
      alpha_s= xpar(13)
      arbitr = xpar(14)
      arbitr1= xpar(15)
      themin = xpar(16)
      arbitr2= xpar(17)
      wtmax_cc03= xpar(18)
      PReco  = xpar(19)
      Ene    = CMSene/2d0      
* ?????????????  too small for yfs3 !!!!!!!!!!!!!!!!!!!!!
      vvmax  = MIN( vvmax, 1d0-(amel/ene)**2 )                   
c?????????????????????????????????????????????
c re-used in YFSWW
      XPAR(9) =VVMAX ! send it back !!!
c?????????????????????????????????????????????

*/////////////////////////////////////////////////////////////////////////
*//               If arbitr2=<0 reset it to the maximum value           //
      IF (arbitr2 .LE. 0d0) THEN
        arbitr2 = cmsene**2
c?????????????????????????????????????????????
c seems to be unused
        xpar(17) = arbitr2
c?????????????????????????????????????????????
      ENDIF
      IDE=2               
      IDF=2               
      XK0=3.D-3         
*/////////////////////////////////////////////////////////////////////////
*//                       users mask                                    //
      DO i=1,202
         user_umask(i)=npar(100+i)
      ENDDO
*/////////////////////////////////////////////////////////////////////////
*//                         alpha_w                                     //
      alphaw = 1d0/ AlfWin
*/////////////////////////////////////////////////////////////////////////
*//         Electroweak Input Parameters Schemes                        //
*/////////////////////////////////////////////////////////////////////////
      IF(KeyMix .EQ. 2) THEN
* this option is turned into 'bare Born' 
* so, we reset ALFWIN to alfa_QED
         SINW2 = 1D0 -AMAW**2/AMAZ**2
         ALFWIN = alfinv
c??????????????????????????????????????
c re-used 
         xpar(3) = alfwin
c??????????????????????????????????????
         ALPHAW = 1D0/ ALFWIN
      ELSEIF(KeyMix .EQ. 1) THEN
!.. this option is turned into G_mu scheme, 
!.. so, we recalculate ALFWIN
         SINW2 = 1D0 -AMAW**2/AMAZ**2
         ALFWIN = pi/( sqrt(2d0)*gmu*amaw**2*sinw2 )
c??????????????????????????????????????
c re-used 
         xpar(3) = alfwin
c??????????????????????????????????????
         ALPHAW = 1D0/ ALFWIN
      ELSE 
* LEP2 workshop definition
         sinw2 = pi * alphaw /( sqrt(2d0) * amaw**2 * gmu )
      ENDIF
*/////////////////////////////////////////////////////////////////////////
*//            cuts for selecto removed for CC03                        //
*/////////////////////////////////////////////////////////////////////////
      IF (Key4f .EQ. 0) THEN
* no cuts for CC03 presampler
        arbitr = 0d0  !  min. vis p_t**2 
        arbitr1= 0d0  !  add. cut for e+e-ch+ 
        themin = 0d0  !  min. theta [rad] with beam   
        arbitr2= cmsene**2  !  max p_t**2 of photons for e+e-ch+ 
c????????????????????????????????????????
c seems to be unused - WP: unused in YFSWW3
        xpar(14)=arbitr    
        xpar(15)=arbitr1   
        xpar(16)=themin    
        xpar(17)=arbitr2  
c????????????????????????????????????????
      ENDIF
*/////////////////////////////////////////////////////////////////////////
*//             alpha_s/pi for naive QCD corrections                    //
*/////////////////////////////////////////////////////////////////////////
      aspi = alpha_s/pi
*/////////////////////////////////////////////////////////////////////////
*//                                                                     //
*//           Branching ratios for W decay channels:                    //
*//                                                                     //
*/////////////////////////////////////////////////////////////////////////
      IF(  KeyBra .EQ. 0 )THEN
*/////////////////////////////////////////////////////////////////////////
*//                    Born values                                      //
*/////////////////////////////////////////////////////////////////////////
         BR(1)=(1D0/3D0)*(1D0+aspi)/(1D0+2D0/3D0*aspi) !  <== ud
         BR(2)=0D0                                     !  <== cd
         BR(3)=0D0                                     !  <== us
         BR(4)=(1D0/3D0)*(1D0+aspi)/(1D0+2D0/3D0*aspi) !  <== cs
         BR(5)=0D0                                     !  <== ub
         BR(6)=0D0                                     !  <== cb
         BR(7)=(1D0/9D0)           /(1D0+2D0/3D0*aspi) !  <== e
         BR(8)=(1D0/9D0)           /(1D0+2D0/3D0*aspi) !  <== mu
         BR(9)=(1D0/9D0)           /(1D0+2D0/3D0*aspi) !  <== tau
      ELSEIF(  KeyBra .EQ. 1 )THEN
*/////////////////////////////////////////////////////////////////////////
*//          Values of CKM and BRanchings for KeyBra = 1                //
*// note that these br ratios correspond to alfa_s=0.12 (gamma_W->el    //
*// constant) and to nontrivial CKM matrix simultaneously               //
*/////////////////////////////////////////////////////////////////////////
!WP         ALPHA_S = 0.12d0  ! make sure alpha_s is consistent
c??????????????????????????????????????????????
c re-used 
!WP         xpar(13)=alpha_s  ! <== send it back
c??????????????????????????????????????????????
         aspi = alpha_s/pi
!WP         gammw=-1d0        ! make sure W width will be recalculated
         DO i=1,9
            BR(i) = xpar(130 +i)
         ENDDO
      ELSEIF( KeyBra .EQ. 2 ) THEN
*/////////////////////////////////////////////////////////////////////////
*//              Default values of CKM and BRanchings                   //
*// Recalculate br. ratios from the CKM matrix and alpha_s according to //
*// theoretical formula of A. Denner, Fortschr. Phys. 41 (1993) 307.    //
*// Values of the CKM matrix elements from 1996 PDG Review:             //
*//  http://www-pdg.lbl.gov/pdg.html (mean values of given ranges)      //
*/////////////////////////////////////////////////////////////////////////
         VCKM(1,1) =xpar(111)   ! V_ud  real part
         VCKM(1,2) =xpar(112)   ! V_us  real part
         VCKM(1,3) =xpar(113)   ! V_ub  real part
         VCKM(2,1) =xpar(114)   ! V_cd  real part
         VCKM(2,2) =xpar(115)   ! V_cs  real part
         VCKM(2,3) =xpar(116)   ! V_cb  real part
         VCKM(3,1) =xpar(117)   ! V_td  real part
         VCKM(3,2) =xpar(118)   ! V_ts  real part
         VCKM(3,3) =xpar(119)   ! V_tb  real part
* Unitarity check of the CKM matrix: VVH should be =1
         DO i = 1,3
         DO j = 1,3
           sum = 0d0
           DO k = 1,3
             sum = sum + VCKM(i,k)*VCKM(j,k)
           ENDDO
           VVH(i,j) = sum
         ENDDO
         ENDDO
* IBA formulae for branching ratios
         brlep = 1d0/9d0/(1 + 2d0/3d0*aspi)
         brqua = 3*brlep*(1 + aspi)
         BR(1) = VCKM(1,1)**2 *brqua  !  <== ud
         BR(2) = VCKM(2,1)**2 *brqua  !  <== cd
         BR(3) = VCKM(1,2)**2 *brqua  !  <== us
         BR(4) = VCKM(2,2)**2 *brqua  !  <== cs
         BR(5) = VCKM(1,3)**2 *brqua  !  <== ub
         BR(6) = VCKM(2,3)**2 *brqua  !  <== cb
         BR(7) = brlep                !  <== e
         BR(8) = brlep                !  <== mu
         BR(9) = brlep                !  <== tau  
* make sure W width will be recalculated       
         gammw =-1d0        
      ELSE
        WRITE(6,*)'filexp=> wrong KeyBra: ',keybra
        STOP
      ENDIF
*///////////////////////////////////////////////////////////
*//  Check if requested final state has a ZERO br. ratio  //
      IF(KeyWon.NE.0 .AND. KeyZon.EQ.0) THEN
        IF(KeyDWm.NE.0 .AND. KeyDWp.NE.0 .AND. KeyDWp.NE.KeyDWm) THEN
          IF(br(KeyDWm) .EQ.0d0 .OR. br(KeyDWp) .EQ. 0d0 ) THEN
           WRITE(6,*)'Filexp=> requested CKM-nondiagonal WW final state'
           WRITE(6,*)'has zero xsect if used with br. ratios specified'
           STOP
          ENDIF
        ENDIF
      ENDIF
*/////////////////////////////////////////////////////////////////////////
*//             W width recalculated on request                         //
*/////////////////////////////////////////////////////////////////////////
      IF ( GammW .LE. 0d0 ) THEN
         gwc  =  9d0 * Gmu * amaw**2 /( 6d0 * sqrt(2d0) * pi)
         gammw = amaw * gwc
*-- Naive QCD correction to the width
         gammw=gammw*(1D0+2D0/3D0*ASPI) 
c????????????????????????????????????????????
c re-used
         XPAR(7) = GAMMW  ! send it back !!!
c????????????????????????????????????????????
      ENDIF
*///////////////////////////////////////////////////////////////////
*//               final fermions masses                           //
*///////////////////////////////////////////////////////////////////
      DO i = 1,6
         amafin(   i) = xpar(500+i*10 +6) ! quarks
         amafin(10+i) = xpar(600+i*10 +6) ! leptons
      ENDDO
      amel   = amafin(11)       
      IF(  KeyMas .EQ. 0 ) THEN
         DO i = 1,6
            amafin(   i) = 0d0
            amafin(10+i) = 0d0
         ENDDO
      ENDIF
cccc*///////////////////////////////////////////////////////////////////
cccc*// Not necessary because default wtmax is in data_DEFAUTS anyway //
cccc*///////////////////////////////////////////////////////////////////
!!!!!!   NECESSARY this is a part of algorithm, not data   !!!!!!!  m.s.
      IF(wtmax.LE.0d0) THEN
        wtmax=2d0
        xpar(10) = wtmax   ! send it back !!!
      ENDIF
ccccc??????????????????????????????????????????????
ccccc seems to be unused
ccccc        xpar(10) = wtmax   ! send it back !!!
ccccc???????????????????????????????????????????????
      IF(wtmax_cc03 .LE. 0d0) THEN
        wtmax_cc03 = xpar(151)
        IF(cmsene.GT.162) wtmax_cc03 = xpar(152)
        IF(cmsene.GT.175) wtmax_cc03 = xpar(153)
        IF(cmsene.GT.200) wtmax_cc03 = xpar(154)
        IF(cmsene.GT.250) wtmax_cc03 = xpar(155)
        IF(cmsene.GT.350) wtmax_cc03 = xpar(156)
        IF(cmsene.GT.700) wtmax_cc03 = xpar(157)
c?????????????????????????????????????????????
c seems to be unused
        xpar(18) = wtmax_cc03   ! send it back !!!
c?????????????????????????????????????????????
      ENDIF
!-- if WW-CC03 matrix el. is requested, use wtmax_cc03 instead of wtmax
!WP      IF(key4f .EQ. 0) THEN
!WP        wtmax=wtmax_cc03
c?????????????????????????????????????????????
c seems to be unused
!WP        xpar(10) = wtmax   ! send it back !!!
c?????????????????????????????????????????????
!WP      ENDIF
      IF (wtmax_cc03.GT.wtmax) THEN
         wtmax = wtmax_cc03
         xpar(10) = wtmax   ! send it back !!!
      ENDIF
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! YFSWW3 specific input parameters
!----------   
      npar(11)= NINT(xpar(2001))  ! KeyCor
      KeyCor = npar(11)
! Re-set KeyISR and KeyCul according to KeyCor  
      KeyRaK = KeyRad
      KeyISK = KeyISR
      IF (KeyCor.EQ.0) THEN
         KeyISR = 0
      ELSE
         KeyISR = 1
      ENDIF
      xpar(1011) = KeyISR
      IF (KeyCor.LE.1) KeyCul = 0
      xpar(1014) = KeyCul
      npar(1)= 
     $           +NINT(xpar(1011))  ! KeyISR
     $        +10*NINT(xpar(1012))  ! KeyFSR
     $       +100*NINT(xpar(1013))  ! KeyNLL
     $      +1000*NINT(xpar(1014))  ! KeyCul
!     KeyRad = 1000*KeyCul +100*KeyNLL +10*KeyFSR +KeyISR
      KeyRad = npar(1)
! YFSWW3 internal W decay-channel switches
      KeyDW1 = KEYDWM
      KeyDW2 = KEYDWP
! Additional Input parameters:
! Higgs and top masses
      amH = amhig 
      amt = AMAFIN(6)
! Set-up original YFS3 switches     
      IF (KeyCor.EQ.0) THEN
        KEYBRM = 1000000  
      ELSEIF(KeyCor.LE.3) THEN
        KEYBRM = 1000001
      ELSE
        KEYBRM = 1000011
      ENDIF
      KEYFIX = 0           
      KEYRED = 1 
      KEYZEE = 2 
!-------------------------------    
      ENE    = CMSENE/2D0      
      EPS    = VVMIN       
      DELTA  = EPS*1D-3    
      POLAR1 = 0D0          
      POLAR2 = 0D0          
      POLFI1 = 0D0          
      POLFI2 = 0D0          
      AMEL   = amafin(11)
      AMFIN  = amaW
      IDE=2               
      IDF=2               
      XK0=3D-3           
!
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) '           YFSWW3 version 1.16,  January 2001 '
      WRITE(NOUT,BXTXT) '           S. Jadach, W. Placzek, M. Skrzypek,'
      WRITE(NOUT,BXTXT) '                   B.F.L. Ward, Z. Was        '
      WRITE(NOUT,BXTXT) '                                              '
      WRITE(NOUT,BXTXT) '                      INPUT PARAMATERS:       '
      WRITE(NOUT,BXL1F) CMSENE,     'CMS energy total   ','CMSEne','I.0'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KeyCor,     'Rad. Corr. switch  ','KeyCor','IR1'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KeyRaK,     'QED super-switch   ','KeyRad','IQ1'
      WRITE(NOUT,BXL1I) KeyISK,     'Init. state Rad.   ','KeyISR','IQ2'
      WRITE(NOUT,BXL1I) KeyFSR,     'Final state Rad.   ','KeyFSR','IQ3'
      WRITE(NOUT,BXL1I) KeyNLL,     'Next-To-Leading    ','KeyNLL','IQ4'
      WRITE(NOUT,BXL1I) KeyCul,     'Coulomb corr.      ','KeyCul','IQ5'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KeyPhK,     'Physics super-switc','KeyPhy','IP1'
      WRITE(NOUT,BXL1I) KeyReK,     'FS mass reduction  ','KeyRed','IP2'
      WRITE(NOUT,BXL1I) KeySpn,     'Spin in W decays   ','KeySpn','IP3'
      WRITE(NOUT,BXL1I) KeyZet,     'Z propag.          ','KeyZet','IP4'
      WRITE(NOUT,BXL1I) KeyMaK,     'Mass kinematics.   ','KeyMas','IP5'
      WRITE(NOUT,BXL1I) KeyBra,     'Branching Rat.     ','KeyBra','IP6'
      WRITE(NOUT,BXL1I) KeyWu,      'W propag.          ','KeyWu ','IP7'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KeyTkK,     'Technical super-swi','KeyTek','IT1'
      WRITE(NOUT,BXL1I) KeyLPA,     'LPA_a or LPA_b mode','KeyLPA','IT2'
      WRITE(NOUT,BXL1I) KeySmK,     'Presampler type    ','KeySmp','IT3'
      WRITE(NOUT,BXL1I) KeyRnd,     'Rand. Numb. Gen.   ','KeyRnd','IT4'
      WRITE(NOUT,BXL1I) KeyWgt,     'Weighting  switch  ','KeyWgt','IT5'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KeyMiK,     'Miscelaneous       ','KeyMis','IM1'
      WRITE(NOUT,BXL1I) KeyMix,     'EW Input Par. Schem','KeyMix','IM2'
      WRITE(NOUT,BXL1I) Key4fK,     '4 fermion matr el  ','Key4f ','IM3'
      WRITE(NOUT,BXL1I) KeyAcc,     'Anomalous couplings','KeyAcc','IM4'
      WRITE(NOUT,BXL1I) KeyWoK,     'WW type final state','KeyWon','IM5'
      WRITE(NOUT,BXL1I) KeyZoK,     'ZZ type final state','KeyZon','IM6'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1I) KEYDWM,     'W- decay mode      ','KeyDWm','ID1'
      WRITE(NOUT,BXL1I) KEYDWP,     'W+ decay mode      ','KeyDWp','ID2'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1F) GMU*1d5,    'G_mu * 1d5         ','Gmu   ','I.1'
      WRITE(NOUT,BXL1F) ALFWIN,     'Inverse alpha_w    ','alfWin','I.2'
      WRITE(NOUT,BXL1F) AMAZ,       'Z mass   [GeV]     ','aMaZ  ','I.3'
      WRITE(NOUT,BXL1F) GAMMZ,      'Z width  [GeV]     ','GammZ ','I.4'
      WRITE(NOUT,BXL1F) AMAW,       'W mass   [GeV]     ','aMaW  ','I.5'
      WRITE(NOUT,BXL1F) GAMMW,      'W width  [GeV]     ','GammW ','I.6'
      WRITE(NOUT,BXL1F) VVMIN,      'Dummy infrared cut ','VVmin ','I.7'
      WRITE(NOUT,BXL1F) VVMAX,      'v_max ( =1 )       ','VVmax ','I.8'
      WRITE(NOUT,BXL1F) WTMAX,      'Max wt for rejectn.','WtMax ','I.9'
      WRITE(NOUT,BXL1F) WTMAX_CC03, 'Max wt for CC03 rej','WtMax ','I10'
      WRITE(NOUT,BXL1F) alpha_s,    'alpha_s: QCD coupl.','alphas','I11'
      WRITE(NOUT,BXL1F) PReco  ,    'Color Re-Con. Prob.','PReco ','I12'
      WRITE(NOUT,BXTXT)'***********************************************'
      WRITE(NOUT,BXL1F) SINW2,      'sin(theta_W)**2    ','sinW2 ','I13'
      WRITE(NOUT,BXTXT)'***********************************************'

*!-----------------------------------------------------------------------
*! Feynman rules and their printout, LEP200 style
*!-----------------------------------------------------------------------
*c      QE =-1
*c      VEI= 1-4*SINW2
*c      AEI= 1
*c      EEW = SQRT(4D0*PI*ALPHAW)
*c      GAE =-EEW/sqrt(16D0*SinW2*(1d0-SinW2))
*c      GVE = GAE*VEI
*c      GWF = EEW/(2D0*sqrt(2d0)*sqrt(SinW2))
*c      GWWG= EEW
*c      GWWZ= EEW * sqrt(1d0-SinW2) /sqrt(SinW2)
*c      WRITE(NOUT,BXL1F) GVE,        'LEP200 workshop      ','GVE ','***'
*c      WRITE(NOUT,BXL1F) GAE,        'LEP200 workshop      ','GAE ','***'
*c      WRITE(NOUT,BXL1F) GWF,        'LEP200 workshop      ','GWF ','***'
*c      WRITE(NOUT,BXL1F) GWWG,       'LEP200 workshop      ','GWWG','***'
*c      WRITE(NOUT,BXL1F) GWWZ,       'LEP200 workshop      ','GWWZ','***'
*!-----------------------------------------------------------------------
      WRITE(NOUT,BXTXT)'***********************************************'
c>    WRITE(NOUT,BXTXT) '       sin(th_W) from G_mu, alpha_w and M_Z: '
c>    WRITE(NOUT,BXTXT) '        A2 = PI / ( ALFWIN*SQRT(2D0)*GMU )   '
c>    WRITE(NOUT,BXTXT) '     SINW2 = ( 1-SQRT( 1-(4*A2/AMAZ**2) ) )/2'
c>    WRITE(NOUT,BXL1F) SINW2,      'sin(theta_W)**2    ','SINW2 ','A6'
c>    WRITE(NOUT,BXTXT)'***********************************************'
      IF(KeyZet.eq.0) THEN 
        WRITE(NOUT,BXTXT) '  Z width in Z propagator: s/M_Z *GAMM_Z '
      ELSEIF(KeyZet.eq.1) THEN 
        WRITE(NOUT,BXTXT) '  Z width in Z propagator:   M_Z *GAMM_Z '
      ELSEIF(KeyZet.eq.2) THEN 
        WRITE(NOUT,BXTXT) '  Z width in Z propagator:   0           '
      ELSE
        WRITE(NOUT,BXTXT) '  FILEXP ==> wrong KeyZet =',keyzet
        STOP
      ENDIF
      WRITE(NOUT,BXTXT)'***********************************************'
      IF(KeySpn.NE.1) THEN 
        WRITE(NOUT,BXTXT) '         WARNING!  spin in decays is OFF: '
        WRITE(NOUT,BXL1I) KeySpn, 'spin in decays switch','KeySpn','A13'
      WRITE(NOUT,BXTXT)'***********************************************'
      ENDIF
      IF (KeyBra.EQ.2) THEN
       WRITE(NOUT,BXTXT) '                                    '
       WRITE(NOUT,BXTXT) '                CKM matrix elements:'
       WRITE(NOUT,BXL1F) VCKM(1,1),       'V_ud','VCKM(1,1)','IV1'
       WRITE(NOUT,BXL1F) VCKM(1,2),       'V_us','VCKM(1,2)','IV2'
       WRITE(NOUT,BXL1F) VCKM(1,3),       'V_ub','VCKM(1,3)','IV3'
       WRITE(NOUT,BXL1F) VCKM(2,1),       'V_cd','VCKM(2,1)','IV4'
       WRITE(NOUT,BXL1F) VCKM(2,2),       'V_cs','VCKM(2,2)','IV5'
       WRITE(NOUT,BXL1F) VCKM(2,3),       'V_cb','VCKM(2,3)','IV6'
       WRITE(NOUT,BXL1F) VCKM(3,1),       'V_td','VCKM(3,1)','IV7'
       WRITE(NOUT,BXL1F) VCKM(3,2),       'V_ts','VCKM(3,2)','IV8'
       WRITE(NOUT,BXL1F) VCKM(3,3),       'V_tb','VCKM(3,3)','IV9'
       WRITE(NOUT,BXTXT)
     $          '              Unitarity check of the CKM matrix:'
       WRITE(NOUT,'(1X,1H*,20X,3f10.5,23X,1H*)')(VVH(1,j),j=1,3)
       WRITE(NOUT,'(1X,1H*,15X,5HVV+ =,3f10.5,23X,1H*)')(VVH(2,j),j=1,3)     
       WRITE(NOUT,'(1X,1H*,20X,3f10.5,23X,1H*)')(VVH(3,j),j=1,3)
      ENDIF
      WRITE(NOUT,BXTXT) '                                             '
      WRITE(NOUT,BXTXT) '                Branching ratios of W decays:'
      WRITE(NOUT,BXL1F) BR(1),            'ud','BR(1)','IB1'
      WRITE(NOUT,BXL1F) BR(2),            'cd','BR(2)','IB2'
      WRITE(NOUT,BXL1F) BR(3),            'us','BR(3)','IB3'
      WRITE(NOUT,BXL1F) BR(4),            'cs','BR(4)','IB4'
      WRITE(NOUT,BXL1F) BR(5),            'ub','BR(5)','IB5'
      WRITE(NOUT,BXL1F) BR(6),            'cb','BR(6)','IB6'
      WRITE(NOUT,BXL1F) BR(7),            ' e','BR(7)','IB7'
      WRITE(NOUT,BXL1F) BR(8),           ' mu','BR(8)','IB8'
      WRITE(NOUT,BXL1F) BR(9),          ' tau','BR(9)','IB9'

      WRITE(NOUT,BXTXT) '                              fermion masses:'
      WRITE(NOUT,BXL1F) AMAFIN(1),     ' d','amafin(1)','IM1'
      WRITE(NOUT,BXL1F) AMAFIN(2),     ' u','amafin(2)','IM2'
      WRITE(NOUT,BXL1F) AMAFIN(3),     ' s','amafin(3)','IM3'
      WRITE(NOUT,BXL1F) AMAFIN(4),     ' c','amafin(4)','IM4'
      WRITE(NOUT,BXL1F) AMAFIN(5),     ' b','amafin(5)','IM5'
      WRITE(NOUT,BXL1F) AMAFIN(6),     ' t','amafin(6)','IM6'
      WRITE(NOUT,BXL1F) AMAFIN(11),    ' e','amafin(11)','IM7'
      WRITE(NOUT,BXL1F) AMAFIN(12),    've','amafin(12)','IM8'
      WRITE(NOUT,BXL1F) AMAFIN(13),    'mu','amafin(13)','IM9'
      WRITE(NOUT,BXL1F) AMAFIN(14),   'vmu','amafin(14)','IM10'
      WRITE(NOUT,BXL1F) AMAFIN(15),   'tau','amafin(15)','IM11'
      WRITE(NOUT,BXL1F) AMAFIN(16),  'vtau','amafin(16)','IM12'
      WRITE(NOUT,BXTXT) '                      Higgs mass:           '
      WRITE(NOUT,BXL1F) amH       , 'Higgs','     aMHig','IMH'      
      WRITE(NOUT,BXTXT) '                                            '
      IF (KeySmp.NE.0) THEN
        WRITE(NOUT,BXTXT) ' Predefined cuts on final state fermions'
        WRITE(NOUT,BXL1F)arbitr, 'min. vis p_t**2    ','GeV^2','X2'
        WRITE(NOUT,BXL1F)arbitr1,'add. cut for e+e-ch+ch-','GeV^2','X3'
        WRITE(NOUT,BXL1G)themin, 'min. theta with beam','rad ','X6'
        WRITE(NOUT,BXL1F)arbitr2,'max. p_t**2 phot eexx','GeV^2','X3'
      ENDIF
      IF( KeyAcc .NE.0 ) THEN 
*!----------------------------------------------------------------------!
*! Setting up the anomalous couplings as given in the paper:            !
*!     K. Hagiwara, R.D. Peccei, D. Zeppenfeld and K. Hikasa,           !
*!                 Nucl. Phys. B282 (1987) 253;                         !
*!     see also: YR CERN-96-01, "Physics at LEP2" Vol. 1, p. 525.       !
*! The variables used in this routine correspond to the following       !
*! contants defined in the above paper:                                 !
*!           constant name     corresponding variable                   ! 
*!                g_1^V                g1(2)                            !
*!                kappa_V              kap(2)                           !
*!                lambda_V             lam(2)                           !
*!                g_4^V                g4(2)                            !
*!                g_5^V                g5(2)                            !
*!                kappa-tilde_V        kapt(2)                          !
*!                lambda-tilde_V       lamt(2)                          ! 
*!----------------------------------------------------------------------!      
         IF( KeyAcc .EQ. 1) THEN 
*!-- Set 1:
*!       --Set up constants OTHER than SM:
*!       --for WWgamma vertex
          g1(1)   = DCMPLX(xpar(21),xpar(31))
          kap(1)  = DCMPLX(xpar(22),xpar(32))
          lam(1)  = DCMPLX(xpar(23),xpar(33))
          g4(1)   = DCMPLX(xpar(24),xpar(34))
          g5(1)   = DCMPLX(xpar(25),xpar(35))
          kapt(1) = DCMPLX(xpar(26),xpar(36))
          lamt(1) = DCMPLX(xpar(27),xpar(37))
*!       --WWZ vertex
          g1(2)   = DCMPLX(xpar(41),xpar(51))
          kap(2)  = DCMPLX(xpar(42),xpar(52))
          lam(2)  = DCMPLX(xpar(43),xpar(53))
          g4(2)   = DCMPLX(xpar(44),xpar(54))
          g5(2)   = DCMPLX(xpar(45),xpar(55))
          kapt(2) = DCMPLX(xpar(46),xpar(56))
          lamt(2) = DCMPLX(xpar(47),xpar(57))
*!======================================================
*!====== Other TGC parametrizations disussed in: ======= 
*!== YR CERN-96-01, "Physics at LEP2" Vol. 1, p. 525. ==
*!======================================================
        ELSEIF (KeyAcc.EQ.2) THEN
*!-- Set 2:  
	  delta_Z = xpar(61)
	  x_gamma = xpar(62)
	  x_Z     = xpar(63)
	  y_gamma = xpar(64)
	  y_Z     = xpar(65)
*!... Calculate general (internal) TGC's (cf. Hagiwara et al.)  
          tW = SQRT(SINW2/(1-SINW2))
*!       --for WWgamma vertex
          g1(1)   = 1
          kap(1)  = 1 + x_gamma 
          lam(1)  = y_gamma
          g4(1)   = 0
          g5(1)   = 0
          kapt(1) = 0
          lamt(1) = 0
*!       --WWZ vertex
          g1(2)   = 1 + tW*delta_Z 
          kap(2)  = 1 + tW*(x_Z + delta_Z)
          lam(2)  = y_Z
          g4(2)   = 0
          g5(2)   = 0
          kapt(2) = 0
          lamt(2) = 0
        ELSEIF (KeyAcc.EQ.3) THEN
*!-- Set 3:  
	  alpha_Wphi = xpar(71)
	  alpha_Bphi = xpar(72)
	  alpha_W    = xpar(73)
*!... Calculate general (internal) TGC's (cf. Hagiwara et al.)  
          sW2 = SINW2
          cW2 = 1 - SINW2
*!       --for WWgamma vertex
          g1(1)   = 1
          kap(1)  = 1 + alpha_Wphi + alpha_Bphi
          lam(1)  = alpha_W
          g4(1)   = 0
          g5(1)   = 0
          kapt(1) = 0
          lamt(1) = 0
*!       --WWZ vertex
          g1(2)   = 1 + alpha_Wphi/cW2 
          kap(2)  = 1 + alpha_Wphi - sW2/cW2*alpha_Bphi
          lam(2)  = alpha_W
          g4(2)   = 0
          g5(2)   = 0
          kapt(2) = 0
          lamt(2) = 0
        ELSE
          write(6,*)'FILEXP==> Wrong KeyAcc: ',keyacc
          STOP
        ENDIF
*!
        WRITE(NOUT,BXTXT)' '
	IF (KeyAcc.EQ.2) THEN
          WRITE(NOUT,BXTXT)'Anomalous Couplings - set 2; YR CERN 96-01'
          WRITE(NOUT,BXTXT)'******************************************'
          WRITE(NOUT,BXL1F) delta_Z,'delta_Z','delta_Z','IA21'
          WRITE(NOUT,BXL1F) x_gamma,'x_gamma','x_gamma','IA22'
          WRITE(NOUT,BXL1F) x_Z    ,'x_Z    ','x_Z    ','IA23'
          WRITE(NOUT,BXL1F) y_gamma,'y_gamma','y_gamma','IA24'
          WRITE(NOUT,BXL1F) y_Z    ,'y_Z    ','y_Z    ','IA25'
	ELSEIF (KeyAcc.EQ.3) THEN
          WRITE(NOUT,BXTXT)'Anomalous Couplings - set 3; YR CERN 96-01'
          WRITE(NOUT,BXTXT)'******************************************'
          WRITE(NOUT,BXL1F) alpha_Wphi,'alpha_Wphi','alpha_Wphi','IA21'
          WRITE(NOUT,BXL1F) alpha_Bphi,'alpha_Bphi','alpha_Bphi','IA22'
          WRITE(NOUT,BXL1F) alpha_W   ,'alpha_W   ','alpha_W   ','IA23'
	ENDIF
        WRITE(NOUT,BXTXT)' '
*!
        WRITE(NOUT,BXTXT)'Internal Anomalous Couplings Activated'
        WRITE(NOUT,BXTXT)'Convention from:'
        WRITE(NOUT,BXTXT)
     $         'K.Hagiwara, R.D.Peccei, D.Zeppenfeld, K.Hikasa,'
        WRITE(NOUT,BXTXT)'                Nucl. Phys. B282 (1987) 253.'
        WRITE(NOUT,BXTXT)'                        for WWZ vertex'  
        WRITE(NOUT,BXL2C) g1(2),             'g_1^Z','g1(2)  ','IC21'
        WRITE(NOUT,BXL2C) kap(2),          'kappa_Z','kap(2) ','IC22'
        WRITE(NOUT,BXL2C) lam(2),         'lambda_Z','lam(2) ','IC23' 
        WRITE(NOUT,BXL2C) g4(2),             'g_4^Z','g4(2)  ','IC24'
        WRITE(NOUT,BXL2C) g5(2),             'g_5^Z','g5(2)  ','IC25'     
        WRITE(NOUT,BXL2C) kapt(2),   'kappa-tilde_Z','kapt(2)','IC26'       
        WRITE(NOUT,BXL2C) lamt(2),  'lambda-tilde_Z','lamt(2)','IC27'          
        WRITE(NOUT,BXTXT)'                    for WWg vertex (gamma)'  
        WRITE(NOUT,BXL2C) g1(1),             'g_1^g','g1(1)  ','IC21'
        WRITE(NOUT,BXL2C) kap(1),          'kappa_g','kap(1) ','IC22'
        WRITE(NOUT,BXL2C) lam(1),         'lambda_g','lam(1) ','IC23' 
        WRITE(NOUT,BXL2C) g4(1),             'g_4^g','g4(1)  ','IC24'
        WRITE(NOUT,BXL2C) g5(1),             'g_5^g','g5(1)  ','IC25'     
        WRITE(NOUT,BXL2C) kapt(1),   'kappa-tilde_g','kapt(1)','IC26'       
        WRITE(NOUT,BXL2C) lamt(1),  'lambda-tilde_g','lamt(1)','IC27'          
        WRITE(NOUT,BXTXT)' '
      ENDIF

cav   WRITE(NOUT,BXTXT) '                              DECAY LIBRARIES'
cav   WRITE(NOUT,BXL1I) JAK1,         'TAUOLA for W+' ,'Jak1','IL1'
cav   WRITE(NOUT,BXL1I) JAK2,         'TAUOLA for W-' ,'Jak2','IL2'
cav   WRITE(NOUT,BXL1I) ITDKRC,   'TAUOLA Ord(alpha)' ,'Itdkrc','IL3'
cav   WRITE(NOUT,BXL1I) IFPHOT,              'PHOTOS' ,'IfPhot','IL4'
cav   WRITE(NOUT,BXL1I) IFHADM,       'JETSET for W-' ,'IfHadM','IL5'
cav   WRITE(NOUT,BXL1I) IFHADP,       'JETSET for W+' ,'IfHadP','IL6'
      WRITE(NOUT,BXCLO)         
!
! Codes and masses of final state fermions (exclusive mode)
      IF (KeyDWm.GE.1 .AND. KeyDWp.GE.1 .AND.
     &    KeyDWm.LE.9 .AND. KeyDWp.LE.9) THEN
         CALL FsfCodes(KeyDWm,KeyDWp) 
      ELSE
! Branching ratio cumulant for channel generation (inclusive mode)
         brsum = 0d0
         DO i = 1,9
            brsum = brsum + br(i)
            BrCum(i) = brsum
         ENDDO
! Make sure that the total probability =1
         DO i = 1,9
            BrCum(i) = BrCum(i)/brsum
         ENDDO
! Dummy initialization of final state fermions
         CALL FsfCodes(7,7) 
      ENDIF
      END 
      SUBROUTINE YFSWW_ReaDataX(DiskFile,iReset,imax,xpar)
*///////////////////////////////////////////////////////////////////
*//                                                               //
*//   DiskFile  = input file to read                              //
*//   imax   = maximum index in xpar                              //
*//   iReset = 1, resets xpar to 0d0                              //
*//   iTalk=1,     prints echo into standard input                //
*//                                                               //
*//   Single data card is:    (a1,i4,d15.0,a60)                   //
*//   First data card: BeginX                                     //
*//   Last  data card: EndX                                       //
*//   First character * defines comment card!                     //
*//                                                               //
*///////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      CHARACTER*80 DiskFile
      REAL*8 xpar(*)
      CHARACTER*6 beg6
      CHARACTER*4 end4
      CHARACTER*1 mark1
      CHARACTER*60 comm60
      CHARACTER*80 comm80
      INTEGER  imax,iReset,iTalk
*
      INTEGER   ninp,i,line,index
      REAL*8   value
*
*////////////////////////////////////////
*//  Clear xpar and read default Umask //
*////////////////////////////////////////
      iTalk = 1
      IF(iReset .EQ. 1 ) THEN
         iTalk = 0
         DO i=1,imax
            xpar(i)=0d0
         ENDDO
         CALL YFSWW_ReadMask(DiskFile,iTalk,xpar)
      ENDIF
      ninp = 13
      OPEN(ninp,file=DiskFile)
      IF(iTalk .EQ. 1) THEN
         WRITE(  *,*) '**************************'
         WRITE(  *,*) '*  YFSWW_ReaDataX starts *'
         WRITE(  *,*) '**************************'
      ENDIF
* Search for 'BeginX'
      DO line =1,10000
         READ(ninp,'(a6,a)') beg6,comm60
         IF(beg6 .EQ. 'BeginX') THEN
            IF(iTalk .EQ. 1)   WRITE( *,'(a6,a)') beg6,comm60
            GOTO 200
         ENDIF
      ENDDO
 200  CONTINUE
* Read data, 'EndX' terminates data, '*' marks comment
      DO line =1,1000
         READ(ninp,'(a)') mark1
         IF(mark1 .EQ. ' ') THEN
            BACKSPACE(ninp)
            READ(ninp,'(a1,i4,d15.0,a60)') mark1,index,value,comm60
            IF(iTalk .EQ. 1) 
     $           WRITE( *,'(a1,i4,g15.6,a60)') mark1,index,value,comm60
            IF( (index .LE. 0) .OR. (index .GE. imax)) GOTO 990
            xpar(index) = value
         ELSEIF(mark1 .EQ. 'E') THEN
            BACKSPACE(ninp)
            READ(  ninp,'(a4,a)') end4,comm60
            IF(iTalk .EQ. 1)   WRITE( *,'(a4,a)') end4,comm60
            IF(end4 .EQ. 'EndX') GOTO 300
            GOTO 991
         ELSEIF(mark1 .EQ. '*') THEN
            BACKSPACE(ninp)
            READ(  ninp,'(a)') comm80
            IF(iTalk .EQ. 1)    WRITE( *,'(a)') comm80
         ENDIF
      ENDDO
 300  CONTINUE
      IF(iTalk .EQ. 1)  THEN
         WRITE(  *,*) '************************'
         WRITE(  *,*) '* YFSWW_ReaDataX ends  *'
         WRITE(  *,*) '************************'
      ENDIF
      CLOSE(ninp)
      RETURN
*-----------
 990  WRITE(    *,*) '+++ YFSWW_ReaDataX: wrong index= ',index
      STOP
 991  WRITE(    *,*) '+++ YFSWW_ReaDataX: wrong end of data '
      STOP
      END

      SUBROUTINE YFSWW_ReadMask(DiskFile,iTalk,xpar)
*///////////////////////////////////////////////////////////////////
*//                                                               //
*//   DiskFile  = input file to read                              //
*///////////////////////////////////////////////////////////////////
      IMPLICIT NONE
*
      CHARACTER*80 DiskFile
      REAL*8 xpar(*)
      INTEGER iTalk
*
* User mask on final states 
      INTEGER i_umask(202)
      CHARACTER*1 chdum
      CHARACTER*60 comm60
      CHARACTER*6  beg6
      INTEGER ninp,i,j,line
*--------------------------------------------
      IF(iTalk .EQ. 1) THEN
         WRITE(  *,*) '**************************'
         WRITE(  *,*) '* YFSWW_ReadMask starts  *'
         WRITE(  *,*) '**************************'
      ENDIF
* read user umask from file only here 
      ninp=13
      OPEN(unit=ninp, file=DiskFile, status='unknown')

* Search for 'BeginM'
      DO line =1,10000
         READ(ninp,'(a6,a)') beg6,comm60
         IF(beg6 .EQ. 'BeginM') THEN
            IF(iTalk .EQ. 1)   WRITE( *,'(a6,a)') beg6,comm60
            GOTO 200
         ENDIF
      ENDDO
 200  CONTINUE
*
      READ(ninp,'(a1)') chdum
      READ(ninp,'(a1)') chdum
      DO i=1,9
         READ(ninp,*) (i_umask((i-1)*9+j),j=1,9)
         IF(iTalk .EQ. 1) WRITE( *,'(20i5)') 
     $                (i_umask((i-1)*9+j),j=1,9)
      ENDDO
      READ(ninp,'(a1)') chdum
      READ(ninp,'(a1)') chdum
      DO i=1,11
         READ(ninp,*) (i_umask(81+(i-1)*11+j),j=1,11)
         IF(iTalk .EQ. 1) WRITE( *,'(20i5)') 
     $                (i_umask(81+(i-1)*11+j),j=1,11)
      ENDDO
*
      DO i=1,202
         xpar(1100+i)=i_umask(i)
      ENDDO
      CLOSE(ninp)
      IF(iTalk .EQ. 1) THEN
         WRITE(  *,*) '**************************'
         WRITE(  *,*) '*  YFSWW_ReadMask Ends   *'
         WRITE(  *,*) '**************************'
      ENDIF
      END
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! this file contains analytic photonic spectra extracted from KoralW
!!! originally for YFSWW.
!!!
!!! tot_born_crud(svar,sprim)  is the ACTUAL function used in
!!!     calculation. it does not include branching ratios, so it is
!!!     channel independent and it can be used directly. however to ease
!!!     transition to 'inclusive' setting it may be reasonable to keep 
!!!     the outer layers as well.
!!!
!!!  sincerely yours, maciek, 8/13/99
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      FUNCTION WW_Born_Crud(svar,sprim)
*     ***********************************
* total crude born xsection for photonic spectra
*-----------------------------------------------
* Modified by: W. Placzek
* Last update: 18.08.1999     by: WP
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / matpar / pi,ceuler
      COMMON / wekin2 / amaw,gammw,gmu,alphaw
      COMMON / DECDAT / AMAFIN(20), BR(20) 
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE / matpar /,/ wekin2 /,/ DECDAT /,/ KeyKey /
! good old CC03
      CALL ww_resspec(svar,sprim,amaw,gammw,prnorm)
! W-decay branching ratio factor
      IF (KeyDWm.GE.1 .AND. KeyDWp.GE.1 .AND.
     &    KeyDWm.LE.9 .AND. KeyDWp.LE.9) THEN
         icwm = KeyDWm
         icwp = KeyDWp
         brfac = br(icwm)*br(icwp)
      ELSE
         brfac = 1d0
      ENDIF
      born_crud = prnorm *ww_borcru(sprim,1) *brfac 
      WW_Born_Crud = born_crud 
      END

      SUBROUTINE ww_resspec(svar,sprim,rmas,rgam,prnorm)
*     ***************************************************************
*crude FUNCTION for spectrum normalization
*prnorm calculates the value of integral
* ds_1d_s2 w(s_1)w(s_2) over theta crude region (see koralw 1.02) manual.
*its results cancels out in final results.
* this FUNCTION is arbitrary up to the problems with maximum weight and
* algorithm efficiency.
* note: both resonances have the same mass distribution FUNCTION
*         svar    - max sprim
*         sprim   - actual s
*         rmas    - central value of a resonance mass distribution
*         rgam    - width of a resonance
*         prnorm  - value of the integral of crude distr.
*
* written by: m. skrzypek            date: 2/16/95
* last update: 5/07/96                        by: z.was
*
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      SAVE a,b,winf,wmi,wma,wsqr,wrec,prsqr,prrec
      SAVE uma,umi,uinf,usqr,urec
      SAVE
*
*        WRITE(6,*)'resms2',rmas,rgam
      a=rmas**2
      b=rmas*rgam
* arctg
      winf = 1/b*atan((svar   -a)/b)
      wma  = 1/b*atan((sprim/4d0-a)/b)
      wmi  = 1/b*atan(        -a /b)
* logarithm
      uinf =1/2d0/a*dlog((svar   -a)**2 +b**2)
      uma  =1/2d0/a*dlog((sprim/4d0-a)**2 +b**2)
      umi  =1/2d0/a*dlog(                b**2)
* thetas
      thespr=1d0
      thesvr=1d0
      IF((sprim/4d0) .LT. a) thespr=0d0
      IF( svar       .LT. a) thesvr=0d0
      ulo= thespr*uma +(1d0-thespr)*umi
* normalisations
      wsqr=wma-wmi
      usqr=thespr*(uma-umi)
      prsqr=(wsqr+usqr)**2
      wrec=winf-wma
      urec=thesvr*(uinf -ulo)
      prrec=(wsqr+usqr)*(wrec+urec)
      prnorm=prsqr+2*prrec
      END

      FUNCTION ww_borcru(svari,mode)
*     ***********************************
* this routine provides born crude cross section
* mode = 1 : normalized to total(s) 
*        2 : not normalized
*        difference is only in normalization !!!!?????
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / matpar / pi,ceuler
      COMMON / phypar / alfinv,gpicob
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / wekin2 / amaw,gammw,gmu,alphaw
      SAVE / weking /,/ wekin2 /
      SAVE
!
cc      bss= pi/alfinv**2 /2d0 /sinw2**2
      bss = pi*alphaw**2 /2d0 /sinw2**2
cc      bbwign=amaw**2/alfinv/pi/sinw2 *3d0/4d0
      bbwign = 3d0/4d0 *amaw**2 *alphaw/pi/sinw2 
      thr=1d0/svari/4d0
      IF(svari .GT. 8*amaw**2) THEN
        bs = 1d0/svari*(1+4*amaw**2/svari)/2d0*log(svari/amaw**2)
      ELSEIF(svari .GT. 4*amaw**2) THEN
        beta = dsqrt(1-4*amaw**2/svari)
        IF(beta .LT. pi/alfinv) beta = pi/alfinv ! coulomb!
        bsr = 1d0/svari*(1+4*amaw**2/svari)/2d0*log(svari/amaw**2)
        bs = bsr*(thr/bsr+beta*(1-thr/bsr))
      ELSE
        bs = thr*svari/4/amaw**2
      ENDIF
      bs=bs*(1+svari/sqrt((svari-amaz**2)**2+(svari*gammz/amaz)**2))/2d0
      bnorto = bss*gpicob*bbwign**2
      IF(mode .EQ. 2) THEN
         ww_borcru = bs*4*amaw**2 *2
      ELSEIF(mode .EQ. 1) THEN
         ww_borcru = bs *bnorto 
      ELSE
        WRITE(6,*)'ww_borcru => wrong mode:',mode
        STOP
      ENDIF
      END


*#########################################################################
*#  THIS FILE CONTAINS SOME UTILITY-ROUTINES WHICH FACILITATE ACCESSING  #
*#  SOME USEFUL INFORMATION FROM YFSWW3 (see comments below).            #
*#########################################################################

      SUBROUTINE YFSWW_GetWtMain(WtMain)
*//////////////////////////////////////////////////////////////////
*//   Main weight:  WtMain                                       //
*//////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      REAL*8      WtMain
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)         
      REAL*8            WTMOD,WTCRU1,WTCRU2,WTSET
*--------------------------------------------------------------
      WtMain = WtMod   ! the best total weight
*
      END                       !!! YFSWW_GetWtMain

      SUBROUTINE YFSWW_GetWtISR(WtISR)
*//////////////////////////////////////////////////////////////////
*//   ISR weight:  WtISR                                         //
*//////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      REAL*8      WtISR
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)         
      REAL*8            WTMOD,WTCRU1,WTCRU2,WTSET
*--------------------------------------------------------------
      WtISR = WTCRU1*WTSET(4)    ! the best ISR weight
*
      END                       !!! YFSWW_GetWtISR

      SUBROUTINE YFSWW_GetWtAll(WtMain,WtCrud,WtSetAll)
*///////////////////////////////////////////////////////////////////
*//   Weights ALL                                                 //
*///////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)         
      REAL*8            WTMOD,WTCRU1,WTCRU2,WTSET
*
      INTEGER  j
      REAL*8   WtMain,WtCrud,WtSetAll(*)
*--------------------------------------------------------------
      WtMain = WtMod   ! the best total weight
      WtCrud = WTCRU1*WTCRU2  ! Crude weight (helps to avoid bad events)
      DO j=1,100
         WtSetAll(j) = WtSet(j)
      ENDDO
      END                       !!! YFSWW_GetWtAll

      SUBROUTINE YFSWW_Get4f(flav,p1,p2,p3,p4)
*//////////////////////////////////////////////////////////////////////
*//   Final 4-fermion flavours and momenta                           //
*//////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER flav(4)
      REAL*8          p1(4), p2(4), p3(4), p4(4)   
*
      COMMON / DECAYS / IFLAV(4),AMDEC(4)
      INTEGER           IFLAV
      REAL*8                     AMDEC
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),nphot
      REAL*8            pf1   ,pf2   ,pf3   ,pf4   ,phot
      INTEGER           nphot
      INTEGER  j
*--------------------------------------------------------------
      DO j=1,4
         flav(j) = IFLAV(j)
         p1(j) = pf1(j)
         p2(j) = pf2(j)
         p3(j) = pf3(j)
         p4(j) = pf4(j)
      ENDDO
      END                       !!! YFSWW_Get4f

      SUBROUTINE YFSWW_GetBeams(q1,q2)
*///////////////////////////////////////////////////////////////////////
*//   Four-momenta of beams                                           //
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      REAL*8  q1(4),q2(4)
*
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      REAL*8            ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2
      INTEGER           IDE,IDF
*--------------------------------------------------------------
      q1(1) = 0d0 
      q1(2) = 0d0
      q1(3) = SQRT( (ENE - AMEL)*(ENE + AMEL) )
      q1(4) = ENE
      q2(1) = 0d0
      q2(2) = 0d0
      q2(3) = -q1(3)
      q2(4) = ENE
      END                       !!! YFSWW_GetBeams

      SUBROUTINE YFSWW_GetPhotAll(NphAll,PhoAll)
*///////////////////////////////////////////////////////////////////////
*//                                                                   //
*//   Get all photons, note that they are ordered in energy (except   //
*//   the ones generated by PHOTOS)
*//                                                                   //
*///////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER  NphAll
      REAL*8   PhoAll(100,4)
*
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),nphot
      REAL*8            pf1   ,pf2   ,pf3   ,pf4   ,phot
      INTEGER           nphot
*
      INTEGER  j,k
*------------------
      NphAll = nphot
      DO j=1,100
         DO k=1,4
            PhoAll(j,k) = phot(j,k)
         ENDDO
      ENDDO
      END                       !!! YFSWW_GetPhotAll !!!

      SUBROUTINE YFSWW_GetEvtISR(Ifl,pf1,pf2,pf3,pf4,Phot,Nphot)
*//////////////////////////////////////////////////////////////////////*
*----------------------------------------------------------------------*
* This routine provides 4-momenta of fermions and photons after ISR.   *
* They can be stored on a disk/tape and then used e.g as an input for  *
* KoralW - for reweighting YFSWW generated events with KoralW weights. *
* OUTPUT: Ifl - flavours of final state fermions in PDG convention     *
*         pf1,pf2,pf3,pf3 - 4-momenta of fermions                      *
*         Phot, Nphot - 4-momenta and number of ISR photons            *
* When using this function make the following declarations:            *
*      INTEGER Ifl(4),Nphot                                            *
*      DOUBLE PRECISION pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)        *  
*----------------------------------------------------------------------*
* Written by:  Wieslaw Placzek                        CERN, Sept. 2000 *  
* Last update: 23.11.2000                by: W.P.                      *
*//////////////////////////////////////////////////////////////////////*
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0 )
      DIMENSION Ifl(4),pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)  
* W-,W+ and photon 4-momenta after ISR
      COMMON / MOMINI / xw1(4),xw2(4),xphum(4),xphot(100,4),nphox 
      COMMON / DECAYS / Iflav(4),AMDEC(4)
      SAVE   /MOMINI/,/ WGTALL /, / DECAYS /
* Angles from Born-level presampler
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWANGL /
      DIMENSION q1w(4),q2w(4),h(4),hx(4)
*
      Nphot  = 0
      DO k = 1,4
        Ifl(k) = Iflav(k)
        pf1(k) = 0d0
        pf2(k) = 0d0
        pf3(k) = 0d0
        pf4(k) = 0d0
      ENDDO
      IF (WTCRU1.EQ.0d0) RETURN
      DO k = 1,4
         q1w(k) = xw1(k)
         q2w(k) = xw2(k)
      ENDDO
* Calculate W-,W+ invariant masses
      sv1 = xw1(4)**2 - xw1(3)**2 - xw1(2)**2 - xw1(1)**2
      sv2 = xw2(4)**2 - xw2(3)**2 - xw2(2)**2 - xw2(1)**2
      xm1 = SQRT(sv1)
      xm2 = SQRT(sv2)
* Angular variables
      f1 = fi1n
      f2 = fi2n
      c1 = ct1n
      c2 = ct2n
* Construct pf1 in rest frame of W-             
      p1sq = AMDEC(1)**2
      p2sq = AMDEC(2)**2
      den = 1/(2*xm1)
      h(4) = (sv1 + p1sq - p2sq)*den
      s1s = MAX(0d0,(1d0 - c1)*(1d0 + c1))
      s1 = SQRT(s1s)
      hv = SQRT(h(4)**2 - p1sq)
      h(3) = hv*c1
      h(2) = hv*s1*COS(f1)
      h(1) = hv*s1*SIN(f1)
* Boost vector h to its LAB frame value pf1
      CALL BOSTDQ(-1,q1w,h,pf1)
* Construct pf2 from momentum conservation
      DO k = 1,4
        pf2(k) = q1w(k) - pf1(k)
      ENDDO
* Construct pf3 in rest frame of W+             
      p3sq = AMDEC(3)**2
      p4sq = AMDEC(4)**2
      den = 1/(2*xm2)
      h(4) = (sv2 + p3sq - p4sq)*den
      s2s = MAX(0d0,(1d0 - c2)*(1d0 + c2))
      s2 = SQRT(s2s)
      hv = SQRT(h(4)**2 - p3sq)
      h(3) = hv*c2
      h(2) = hv*s2*COS(f2)
      h(1) = hv*s2*SIN(f2)
* Boost vector h to its LAB frame value pf3
      CALL BOSTDQ(-1,q2w,h,pf3)
* Construct pf4 from momentum conservation
      DO k = 1,4
        pf4(k) = q2w(k) - pf3(k)
      ENDDO
* Copy photons 4-momenta
      Nphot = nphox
      DO i = 1,Nphot
        DO k = 1,4
          Phot(i,k) = xphot(i,k)
        ENDDO
      ENDDO
      END            !!! YFSWW_GetEvtISR

      SUBROUTINE YFSWW_GetNevMC(NevMC)
*/////////////////////////////////////////////////////////////////////////
*//   Number of generated events from MC generator                      //
*//   CALL YFSWW_Finalize before !!!                                    //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER       NevMC
*
      COMMON / GenFin / Xsecpb,Errsec,Xscrud,Errcru,NevTot,IdGene
      REAL*8            Xsecpb,Errsec,Xscrud,Errcru
      INTEGER                                       NevTot,IdGene
*
*--------------------------------------------------------------
      NevMC = NevTot
      END                       !!! YFSWW_GetNevMC

      SUBROUTINE YFSWW_GetXSecNR(XSecNR,XErrNR)
*////////////////////////////////////////////////////////////////////////
*//   Normalization Monte Carlo Cross Section [pb] and its error       //
*//   To be used for normalization of histograms                       //
*//   CALL YFSWW_Finalize before !!!                                   //
*//   For KeyWgt = 0    XSecNR =    Xsecpb                             //
*//   For KeyWgt = 1    XSecNR =    Xscrud                             //
*////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      REAL*8        XSecNR,XErrNR
*
      COMMON / GenFin / Xsecpb,Errsec,Xscrud,Errcru,NevTot,IdGene
      REAL*8            Xsecpb,Errsec,Xscrud,Errcru
      INTEGER                                       NevTot,IdGene
*--------------------------------------------------------------
      XSecNR = Xscrud
      XErrNR = Errcru
      END                       !!! YFSWW_GetXSecNR

      SUBROUTINE YFSWW_GetXSecMC(XSecMC,XErrMC)
*////////////////////////////////////////////////////////////////////////
*//   Final Main Best Monte Carlo Cross Section [pb] and its error     //
*//   CALL YFSWW_Finalize before !!!                                   //
*////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      REAL*8        XSecMC,XErrMC
*
      COMMON / GenFin / Xsecpb,Errsec,Xscrud,Errcru,NevTot,IdGene
      REAL*8            Xsecpb,Errsec,Xscrud,Errcru
      INTEGER                                       NevTot,IdGene
*--------------------------------------------------------------
      XSecMC = Xsecpb
      XErrMC = Errsec
      END                       !!! YFSWW_GetXSecMC

      SUBROUTINE YFSWW_GetIdGen(IdGen)
*/////////////////////////////////////////////////////////////////////////
*//   Generator ID number (important for storing overall normalization) //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER       IdGen
*
      COMMON / GenFin / Xsecpb,Errsec,Xscrud,Errcru,NevTot,IdGene
      REAL*8            Xsecpb,Errsec,Xscrud,Errcru
      INTEGER                                       NevTot,IdGene
*
*-----------------------------------------------------------------
      IdGen = IdGene
      END                       !!! YFSWW_GetIdGen 

      SUBROUTINE YFSWW_VecPrint(nunit,word,pp)
*/////////////////////////////////////////////////////////////////////////
*//                                                                     //
*//   prints single momentum "pp" on unit "nunit" with comment "word"   //
*//                                                                     //
*/////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INTEGER      nunit
      CHARACTER*8  word
      REAL*8       pp(4),ams
      INTEGER      i
*----
      ams = pp(4)**2 -pp(3)**2 -pp(2)**2 -pp(1)**2
      IF(ams .GT. 0.0) ams = SQRT(ams)
      WRITE(nunit,'(a8,5(1x,f20.13))') word,(pp(i),i=1,4),ams
      END

*****************************************************************
*          Born-level CC03 Presampler from KoralW               *
*****************************************************************    

      SUBROUTINE ww_make_phsp_point_z
     $      (msdump,ambeam,svar,sprim,fak_phsp,
     $       effbeam1,effbeam2,effp1,effp2,effp3,effp4)
*     **************************************
* msdump=0 : generates the phase space point
* msdump=1 : point is red from the disk
* fak_phsp  : weight 
*     **************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION drvec(1)
      DIMENSION
     $      effbeam1(4),effbeam2(4),effp1(4),effp2(4),effp3(4),effp4(4)

      itype=1

      CALL ww_spacegen(0,itype,svar,sprim,fak_phsp,
     $                       effp1,effp2,effp3,effp4)
      CALL ww_set_eff_beams(sprim,ambeam,effbeam1,effbeam2)

      END

      subroutine ww_spacegen(mode,itype,svar,sprim,fakir,
     $                       bp1,bp2,bp3,bp4)
********************************************************
! ================================================================
! mode=0                                                         =
!        generates 4-momenta accordingly to itype of generation, =
!        calculates jacobian (out from 4-momenta)                =
! mode=1                                                         =
!        calculates jacobian (out from 4-momenta)                =
!        for itype generation branch                             =
! ================================================================
      implicit DOUBLE PRECISION (a-h,o-z)
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW 
      COMMON / MATPAR / PI,CEULER       
      COMMON / DECAYS / IFLAV(4), AMDEC(4) 
! This common can be everywhere, contains various switches
      COMMON / KeyKey/  KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      save  / WEKING /,/ WEKIN2 /,/ MATPAR /,/ KeyKey/
      save  / DECAYS /

      dimension bq1(4),bq2(4),bp1(4),bp2(4),bp3(4),bp4(4)
      common /nevik/ nevtru,ifprint
      save /nevik/
      SAVE
!
      igcl=1    
      CALL ww_kinchce(IGCL,MODE,Amaw,gammw,svar,SPRIM,fakir,
     $     bP1,amdec(1),bP2,amdec(2),bP3,amdec(3),bP4,amdec(4))

c.. 4momenta for born, in effective CMS, z+ along qeff1
      if (mode.eq.0) then
        do i=1,4
          bq1(i)=bp1(i)+bp2(i)
          bq2(i)=bp3(i)+bp4(i)
        enddo
      endif 
      RETURN
      end

      subroutine ww_kinchce(IGCL,MODE,AMAW,GAMMW,pr,SPRIM,fakir,
     $     bP1,amd1,bP2,amd2,bP3,amd3,bP4,amd4)
**************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension bp1(4),bp2(4),bp3(4),bp4(4)

        svar=pr

        call ww_spaceold(mode,igcl,AMAW,GAMMW,svar,sprim,fakir,
     $     bP1,amd1,bP2,amd2,bP3,amd3,bP4,amd4)

      end

      subroutine ww_spaceold(mode,itype,amx,gamx,svar,sprim,fakir,
     $     bP1,amd1,bP2,amd2,bP3,amd3,bP4,amd4)
********************************************************
! ================================================================
! mode=0                                                         =
!        generates 4-momenta accordingly to itype of generation, =
!        writes them down into / bormom/.                        =
!        calculates jacobian (out from 4-momenta from / bormom/) =
! mode=1                                                         =
!        calculates jacobian (out from 4-momentafrom / bormom/)  =
!        for itype generation branch                             =
! ================================================================
      implicit DOUBLE PRECISION (a-h,o-z)
! we take just amel from this common
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / MATPAR / PI,CEULER
      SAVE   / WEKING /,/ MATPAR /
!WP: Save angles for later use (kinematics after FSR)
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWANGL /
!WP: W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
      SAVE   / WWINVM /
! This common can be everywhere, contains various switches
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE   / KeyKey /
      dimension amdet(4)
      dimension bq1(4),bq2(4),bp1(4),bp2(4),bp3(4),bp4(4)
      common /nevik/ nevtru,ifprint
      save /nevik/
      SAVE
!!!
!     itype=1 WW kinematics with appropriate breit wigners to be set,
!     itype=2    kinematics with flatened breit wigners to be set, obsolete
!     itype=3    kinematics with appropriate breit wigners to be set, ini pairs
!     itype=4-6  kinematics with approp. b-wigners to set, t-chan. Obsolete?
! 
!
!#############################################################
!    GENERAL INITIALIZATION:                                 #
!    SETTING PRESAMPLER PARAMETERS AND MASSES IN ORDER       #
!    FOR PARTICULAR >ITYPE< SLOT-SPACE                       #
!    most of ITYPES differ by order of 4-vectors only        #
!#############################################################
       amdet(1)=amd1
       amdet(2)=amd2
       amdet(3)=amd3
       amdet(4)=amd4


      IF (MODE.EQ.1) THEN 
!##############################################
! INITIALIZATION FOR RECALCULATION MODE:      #
!  ANGLES AND S-i's FROM FOUR VECTORS         #
!##############################################
        call ww_invkin(ctn,fin,ct1n,fi1n,ct2n,fi2n,
     $                  amwmn,amwpn,  bp1,bp2,bp3,bp4)
!
        s1=amwmn**2
        s2=amwpn**2
      ENDIF

!##############################################
! BASIC PART:                                 #
! MODE=0 GENERATION AND JACOBIAN CALCULATION  #
! MODE=1 JACOBIAN CALCULATION ONLY            #
!##############################################
!... s1,s2 subspace
       CALL ww_RES2GN(mode,SVAR,SPRIM,AMx,GAMx,amdet,S1,S2,SSCRU)

      if (ifprint.eq.1) then
        write(*,*) 'invariants old-t ',s1,s2,sscru
      endif
!
! rejection
      if(mode.eq.0.and.sscru.eq.0d0)  then
!-- short-out ... 
         fakir=0D0
         return
      endif

! lambda factors, can be moved to res2/3-s or even out.
      x1=s1/sprim
      x2=s2/sprim
      bmain=sqrt( (1-x1-x2)**2 - 4*x1*x2 )
      xwm1=amdet(1)**2/s1
      xwm2=amdet(2)**2/s1
      bwm=sqrt( (1-xwm1-xwm2)**2 - 4*xwm1*xwm2 )
      xwp1=amdet(3)**2/s2
      xwp2=amdet(4)**2/s2
      bwp=sqrt( (1-xwp1-xwp2)**2 - 4*xwp1*xwp2 )
      wjac=bmain*bwp*bwm

!... production angles
      CALL ww_cospro(mode,sprim,s1,s2,ctn,fin,xccos)
      if (ifprint.eq.1) then
        write(*,*) 'prod',ctn,xccos
      endif

! decay angles
      ifl=1
      CALL ww_cosdecc(mode,ifl,sprim,ct1n,fi1n,xccos1)
      CALL ww_cosdecc(mode,ifl,sprim,ct2n,fi2n,xccos2)

      if (ifprint.eq.1) then
        write(*,*) 'dec1 ',ct1n,xccos1
        write(*,*) 'dec2 ',ct2n,xccos2
      endif

!... WE CALCULATE OVERALL JACOBIAN ...
      fak= 1D0/32D0*xccos1*xccos2*xccos*sscru*wjac
!...  EN_pi=(2*pi)**4/(2*(2*PI)**3)**(r;r=4) 
      ENPI=(2*PI)**4/(2*(2*PI)**3)**4
      fakir=fak*ENPI

      if (ifprint.eq.1) then
        write(*,*) 'fakir ',fakir
      endif



      if (mode.eq.0) then 
!##############################################
!  KONSTRUCT FINAL 4-VECTORS etc:             #
!  MODE=0 ONLY                                #
!##############################################
!
!WP: LPA_a mode or LPA_b mode
        KeyLPA = MOD(KeyTek,10000)/1000
        IF (KeyLPA.EQ.0) THEN
           CALL ww_kineww(sprim,ctn,fin,ct1n,fi1n,ct2n,fi2n,
     $          sqrt(s1),sqrt(s2),amdet,bq1,bq2,bp1,bp2,bp3,bp4)
        ELSE
           IF (sprim.GT.4*amx**2) THEN
              CALL ww_kineww(sprim,ctn,fin,ct1n,fi1n,ct2n,fi2n,
     $             amx,amx,amdet,bq1,bq2,bp1,bp2,bp3,bp4)
! Outside phase space
           ELSE
              DO k = 1,4
                 bp1(k) = 0d0
                 bp2(k) = 0d0
                 bp3(k) = 0d0
                 bp4(k) = 0d0
              ENDDO
              fakir = 0d0
              RETURN
           ENDIF
        ENDIF
!
      endif   

! security check
      if (fak.eq.0d0) then
        write(*,*) 'spacegen: we have troubles; fakir=',
     $  xccos1,xccos2,xccos,sscru,wjac
        write(*,*) 'please contact Z.Was '
        write(*,*) 'this effect is irrelevant or serious ...'
        write(*,*) 'spacegen: itype=',itype,' mode=',mode
        write(*,*) 'division by zero will be protected'
        write(*,*) 'bp1=',bp1
        write(*,*) 'bp2=',bp2
        write(*,*) 'bp3=',bp3
        write(*,*) 'bp4=',bp4
        write(*,*) amdet
        write(*,*) sqrt(s1),sqrt(s2)
!... WE Re-CALCULATE OVERALL JACOBIAN ...
!... this event was outside phase space, the only justifiable config.
!... is if s1 or s2 is just under threshold defined by electron and neutrino
!... masses
       sscru=1d-40
       fak= 1D0/32D0*xccos1*xccos2*xccos*sscru*wjac
!...   EN_pi=(2*pi)**4/(2*(2*PI)**3)**(r;r=4) 
       ENPI=(2*PI)**4/(2*(2*PI)**3)**4
       fakir=fak*ENPI
      endif

      end

      SUBROUTINE ww_cosdecc(mode,iflag,svar,cdec,phi,wt)
*     ***************************************
! Crude generation of decay costhe according to a simplified distribution.
!   mode: 0-generation
!         1-xccos of given cdec
!   cdec:  value of generated cosine
!   xccos: value of distribution function
      implicit DOUBLE PRECISION (a-h,o-z)
      common / matpar / pi,ceuler     
      common / wekin2 / amaw,gammw,gmu,alphaw   
! This common can be everywhere, contains various switches
      COMMON / KeyKey/  KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      DOUBLE PRECISION drvec(100)
      save

      if (iflag.eq.0) then
       KeySpn = 0
      else
       KeySpn = MOD(KeyPhy,10000)/1000
      endif

      IF(keyspn.eq.1) THEN                        !1002=.78
        IF(svar.gt.500**2) THEN                    !502=.4
          delta=0.4d0+ (svar/500**2 -1)/8d0
        ELSEIF(svar.gt.4*amaw**2) THEN             !162=.4
          delta=.4d0
        ELSEIF(svar.gt.4*(amaw-5*gammw)**2) THEN   !142=.78
          delta=.4d0+ (1-svar/(4*amaw**2))*2d0
        ELSEIF(svar.gt.4*(amaw-10*gammw)**2) THEN  !122=40
          delta=.844d0+ (1-svar/(4*(amaw-5*gammw)**2))*100d0
        ELSE
          delta=40d0
        ENDIF

        IF(mode.eq.0)THEN
 11       call varran(drvec,3)
          cdec=2*drvec(1)-1
          xccos=(1+delta+cdec)/(1+delta)
          IF((2+delta)/(1+delta)*drvec(2).gt.xccos) goto 11
          phi =2*pi*drvec(3)
        ELSE
          xccos=(1+delta+cdec)/(1+delta)
        ENDIF
      ELSEIF(keyspn.eq.0) THEN
        IF(mode.eq.0)THEN
          call varran(drvec,3)
          cdec=2*drvec(1)-1
          phi =2*pi*drvec(3)
        ENDIF
        xccos=1D0
      ENDIF
      wt= 4*pi/xccos
      end

      SUBROUTINE ww_set_eff_beams(sprim,ambeam,qeff1,qeff2)
!     ***************************************************
!-- sets effective beams (CMS')
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION qeff1(4),qeff2(4)
      SAVE
        qeff1(1)=0d0
        qeff1(2)=0d0
        qeff1(3)=dsqrt(sprim/4d0  - ambeam**2)
        qeff1(4)=dsqrt(sprim/4d0)

        qeff2(1)=0d0
        qeff2(2)=0d0
        qeff2(3)=-dsqrt(sprim/4d0  - ambeam**2)
        qeff2(4)=dsqrt(sprim/4d0)

      END

      subroutine ww_invkin(ctn,fin,ct1n,fi1n,ct2n,fi2n,
     $                  amwmn,amwpn,  bp1,bp2,bp3,bp4)
*     **********************************************************
c This routine calculates inverse kinematics for W-W+ pair production
c and decay 
c OUTPUT:
c         ctn,fin - W-  production angles 
c         ct1n,fi1n - W- decay products angles
c         ct2n,fi2n - W+ decay products angles
c         amwm, amwp - masses of W- and W+ resonances
c INPUT:
c         bp1(4), bp2(4) - four-momenta of W- decay products
c         bp3(4), bp4(4) - four-momenta of W+ decay products
c
c Written by: Wieslaw Placzek            date: 22.07.1994
c Rewritten by: M. Skrzypek              date: 3/15/95
c Last update: 9/5/96                    by: Z.W.
c
      implicit DOUBLE PRECISION (a-h,o-z)
      common / matpar / pi,ceuler     
      save   / matpar /
      save
      DOUBLE PRECISION bq1(4),bq2(4),aa(4)
      dimension bp1(4),bp2(4),bp3(4),bp4(4)

      do i=1,4
           aa(i)= bp1(i)+bp2(i)
          bq1(i)= bp1(i)+bp2(i)
      enddo
        amwmn=sqrt(dmas2(aa))
      do i=1,4
           aa(i)= bp3(i)+bp4(i)
          bq2(i)= bp3(i)+bp4(i)
      enddo
        amwpn=sqrt(dmas2(aa))
cc ms      qq=dsqrt( (bq1(4)-amwmn)*(bq1(4)+amwmn) )      
      qq=dsqrt(bq1(1)**2+bq1(2)**2+bq1(3)**2)
      qqt=dsqrt(bq1(1)**2+bq1(2)**2)
cc ms
      ctn=bq1(3)/qq
      stn=sqrt(1d0-ctn**2)
cc ms      cfi=bq1(1)/stn/qq
cc ms      sfi=bq1(2)/stn/qq
      IF (QQT.GT.0D0) THEN                                             !cav
        cfi=bq1(1)/qqt
        sfi=bq1(2)/qqt
      ELSE                                                             !cav
        CFI=1D0                                                        !cav
        SFI=0D0                                                        !cav
!        WRITE (6,*)                                                    !cav
!     &    '+++ INVKIN +++ Warning: ThetaW=0. Phi undefined, set=0.'    !cav
      ENDIF                                                            !cav
cc ms
      fin=acos(cfi)
      if(sfi.le.0d0) fin=2*pi-fin
!
      call boostv(1,bq1,bp1,aa)
      qq=sqrt(aa(1)**2+aa(2)**2+aa(3)**2)
      ct1n=aa(3)/qq
cc ms      stn=sqrt(1d0-ct1n**2)
cc ms      cfi=aa(1)/stn/qq
cc ms      sfi=aa(2)/stn/qq
      qqt=sqrt(aa(1)**2+aa(2)**2)
      IF (QQT.GT.0D0) THEN                                             !cav
        cfi=aa(1)/qqt
        sfi=aa(2)/qqt
      ELSE                                                             !cav
        CFI=1D0                                                        !cav
        SFI=0D0                                                        !cav
!        WRITE (6,*)                                                    !cav
!     &    '+++ INVKIN +++ Warning: ThetaW1=0. Phi undefined, set=0.'   !cav
      ENDIF                                                            !cav
cc ms
      fi1n=acos(cfi)
      if(sfi.le.0d0) fi1n=2*pi-fi1n
!
      call boostv(1,bq2,bp3,aa)
      qq=sqrt(aa(1)**2+aa(2)**2+aa(3)**2)
      ct2n=aa(3)/qq
cc ms      stn=sqrt(1d0-ct2n**2)
cc ms      cfi=aa(1)/stn/qq
cc ms      sfi=aa(2)/stn/qq
      qqt=sqrt(aa(1)**2+aa(2)**2)
      IF (QQT.GT.0D0) THEN                                             !cav
        cfi=aa(1)/qqt
        sfi=aa(2)/qqt
      ELSE                                                             !cav
        CFI=1D0                                                        !cav
        SFI=0D0                                                        !cav
!        WRITE (6,*)                                                    !cav
!     &    '+++ INVKIN +++ Warning: ThetaW2=0. Phi undefined, set=0.'   !cav
      ENDIF                                                            !cav

cc ms
      fi2n=acos(cfi)
      if(sfi.le.0d0) fi2n=2*pi-fi2n
! 
      end

      subroutine ww_kineww(sprim,ct,fi,ct1,fi1,ct2,fi2,
     $            amwm,amwp,amdec,  q1,q2,p1,p2,p3,p4)
*     **********************************************************
c This routine calculates kinematics for W-W+ pair production
c and decay in e+e- collision in the CMS with z-axis pointing 
c in the e- direction.
c fixes also the 'effective beams', qeff1,qeff2
c INPUT:  s    - beams energy squared (in GeV**2) !THIS IS DUMMY
                                                  !!!!!!!!!!! ms
c         sprim - actual center mass energy squared (in GeV**2)
c         cthe,fi - W-  production angles 
c         cdec1,fi1 - W- decay products angles
c         cdec2,fi2 - W+ decay products angles
c         amwm, amwp - masses of W- and W+ resonances
c         amdec(4) - decay products masses
c OUTPUT:
c         qeff1(4)      -effective (massless) e- beam in /MOMSET/
c         qeff2(4)      -effective (massless) e+ beam in /MOMSET/
c         q1(4)        - four-momentum of W-  
c         q2(4)        - four-momentum of W+
c         p1(4), p2(4) - four-momenta of W- decay products
c         p3(4), p4(4) - four-momenta of W+ decay products
c
c Written by: Wieslaw Placzek            date: 22.07.1994
c Rewritten by: M. Skrzypek              date: 3/15/95
c Last update: 4/1/95                by: M.S.
c
      implicit DOUBLE PRECISION (a-h,o-z)
      common / matpar / pi,ceuler     
! sphum,sphot and nphot are almost-dummy (used for printout only)!!!! ms
      common / momset / qeff1(4),qeff2(4),sphum(4),sphot(100,4),nphot  
      save   / matpar /,/ momset /
      save
      DOUBLE PRECISION ef1(4),ef2(4)
      dimension amdec(4),  q1(4),q2(4),p1(4),p2(4),p3(4),p4(4)
!
c to activate dumps KINDMP=1
      KINDMP=0

      do i=1,4
        q1(i)=0d0      
        q2(i)=0d0      
        p1(i)=0d0      
        p2(i)=0d0      
        p3(i)=0d0      
        p4(i)=0d0      
        ef1(i)=0d0      
        ef2(i)=0d0      
      enddo
      ecm=sqrt(sprim)
      amwm2=amwm**2
      amwp2=amwp**2
      s1=amwm2
      s2=amwp2
      amp1s=amdec(1)**2
      amp2s=amdec(2)**2
      amp3s=amdec(3)**2
      amp4s=amdec(4)**2
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*) AMDEC(1),AMDEC(2),AMDEC(3),AMDEC(4)
        WRITE(6,*) AMP1S,AMP2S,AMP3S,AMP4S
        WRITE(6,*)'S,SPRIM,S1,S2',S,SPRIM,S1,S2
        WRITE(6,*)'DECAY COS1,2',CT1,CT2
      ENDIF
      st =sqrt(max(0D0,((1d0-ct )*(1d0+ct ))))
c..
      st1=sqrt(max(0D0,((1d0-ct1)*(1d0+ct1))))
      st2=sqrt(max(0D0,((1d0-ct2)*(1d0+ct2))))
c..
!... Momentum q1 of the first resonance
      q1(4)=(sprim+amwm2-amwp2)/(2d0*ecm)
!      qq=dsqrt( (q1(4)-amwm)*(q1(4)+amwm) )
      qq=dsqrt( (sprim-amwm2-amwp2)**2 -4*amwm2*amwp2 )/(2*ecm)
      q1(1)=qq*st*cos(fi)
      q1(2)=qq*st*sin(fi)
      q1(3)=qq*ct
      q1(4)=dsqrt(amwm2+q1(1)**2+q1(2)**2+q1(3)**2)
!... Momentum p1 in the rest frame of the first resonance
      ppene=(s1+amp1s-amp2s)/(2d0*amwm)
!      ppe=dsqrt( (ppene-amdec(1))*(ppene+amdec(1)) )
      ppe=dsqrt( (s1-amp1s-amp2s)**2 -4*amp1s*amp2s )/(2d0*amwm)
      p1(1)=ppe*st1*cos(fi1)
      p1(2)=ppe*st1*sin(fi1)
      p1(3)=ppe*ct1
c      p1(4)=ppene
      p1(4)=dsqrt(amdec(1)**2+p1(1)**2+p1(2)**2+p1(3)**2)
c...
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*)'Q1,P1 '
        CALL ww_dumpl(6,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)
      ENDIF
!... Boost to CMS-WW frame
      call boostv(-1,q1,p1,p1)
!... Momentum p2 of the second product of first resonance decay
      do 10 k=1,4
 10   p2(k)=q1(k)-p1(k)
c.. fine tuning on masses
      p1(4)=dsqrt(amdec(1)**2+p1(1)**2+p1(2)**2+p1(3)**2)
      p2(4)=dsqrt(amdec(2)**2+p2(1)**2+p2(2)**2+p2(3)**2)
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*)'Q1,P1,P2 '
        CALL ww_dumpl(6,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)
      ENDIF
!... Momentum q2 of the second resonance
!ms      q2(4)=ecm-q1(4)
      do 20 k=1,3
 20   q2(k)=-q1(k)
      q2(4)=dsqrt(amwp2+q2(1)**2+q2(2)**2+q2(3)**2)
!... Momentum p3 in the rest frame of the second resonance
      ppene=(s2+amp3s-amp4s)/(2d0*amwp)
!      ppe=dsqrt( (ppene-amdec(3))*(ppene+amdec(3)) )
      ppe=dsqrt( (s2-amp3s-amp4s)**2 -4*amp3s*amp4s )/(2d0*amwp)
      p3(1)=ppe*st2*cos(fi2)
      p3(2)=ppe*st2*sin(fi2)
      p3(3)=ppe*ct2
c      p3(4)=ppene
      p3(4)=dsqrt(amdec(3)**2+p3(1)**2+p3(2)**2+p3(3)**2)
c...
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*)'Q1,P1,P2,Q2,P3 '
        CALL ww_dumpl(6,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)
      ENDIF
!... Boost to CMS-WW frame
      call boostv(-1,q2,p3,p3)
!... Momentum p2 of the second product of first resonance decay
      do 30 k=1,4
 30   p4(k)=q2(k)-p3(k)
c.. fine tuning on masses
      p4(4)=dsqrt(amdec(4)**2+p4(1)**2+p4(2)**2+p4(3)**2)
      p3(4)=dsqrt(amdec(3)**2+p3(1)**2+p3(2)**2+p3(3)**2)
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*)'Q1,P1,P2,Q2,P3,P4, WW frame '
        CALL ww_dumpl(6,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)
      ENDIF
      IF(KINDMP.EQ.1)THEN
        WRITE(6,*)'LAB NO PHOTS'
        CALL ww_dumpl(6,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)
      ENDIF

      end

      SUBROUTINE ww_res2gn(mode,svar,sprim,rmas,rgam,amdec,s1,s2,wt)
! #############################################
! LIBRARY of angular etc sub-generators start #
! #############################################

!     ***************************************************************
! Generation of ds_1ds_2 distribution within phase space boundaries
! using weighted (pre-sampled) events
!---------------------
! note:
! so far generation is within theta_crude and fine tuning is added at the
! end. For non-acceptable events weight is set to zero.
!---------------------
! breit-wigners pre-samplers in both s_1 and s_2 channels are set.
! total volume 'prnorm' ( S(s') defined in formula 31 of koralw 1.02 manual) 
! is calculated including additional W(s_1)*W(s_2) factor 
! (see koralw 1.02 manual). To obtain proper ds_1ds_2 distribution
! weight wt=prnorm/W(s_1)/W(s_2) must be included, and this will help later
! cancelling singularities of matrix element
! 
! note: both resonances have the same mass distribution function
!         svar    - max sprim
!         sprim   - actual s
!         rmas    - central value of a resonance mass distribution
!         rgam    - width of a resonance
! OUTPUT: s1, s2  - svar's of two resonances
!         wt      - weight
! for mode=1
! INPUT:  s1, s2  - no generation,  just calculation of weight. 
!
! Written by: M. Skrzypek            date: 2/16/95
! Last update: 5/5/96                  by: Z. Was
!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / matpar / pi,ceuler     
      DOUBLE PRECISION AMDEC(4)
      DOUBLE PRECISION drvec(100)
      SAVE a,b,winf,wmi,wma,wsqr,wrec,prsqr,prrec
      SAVE uma,umi,uinf,usqr,urec
      SAVE
!
!        write(6,*)'resms2',rmas,rgam
      a=rmas**2
      b=rmas*rgam
! arctg
      winf = 1/b*atan((svar   -a)/b)
      wma  = 1/b*atan((sprim/4d0-a)/b)
      wmi  = 1/b*atan(        -a /b)
! logarithm
      uinf =1/2d0/a*dlog((svar   -a)**2 +b**2)
      uma  =1/2d0/a*dlog((sprim/4d0-a)**2 +b**2)
      umi  =1/2d0/a*dlog(                b**2)
! thetas
      thespr=1d0
      thesvr=1d0
      IF((sprim/4d0).lt.a) thespr=0d0
      IF( svar      .lt.a) thesvr=0d0
      ulo= thespr*uma +(1d0-thespr)*umi
! normalisations
      wsqr=wma-wmi 
      usqr=thespr*(uma-umi)
      prsqr=(wsqr+usqr)**2
      wrec=winf-wma 
      urec=thesvr*(uinf -ulo)
      prrec=(wsqr+usqr)*(wrec+urec)
      prnorm=prsqr+2*prrec
!
!     ====================
      if (mode.ne.1) then 
!     ====================
!
 10   call varran(drvec,5)
      r1=drvec(1)
      r2=drvec(2)
      r3=drvec(3)
      r4=drvec(4)
      r5=drvec(5)

      IF(r3.le.prsqr/prnorm) THEN
!     ..square

!     ....s1
        IF(r4.ge.usqr/(wsqr+usqr)) THEN
!       ..arctg
          w1=r1*(wma-wmi) +wmi
          s1=b*tan(b*w1) +a
        ELSE
!       ..log
          u1=r1*(uma-umi) +umi
          s1=dsqrt(exp(2*a*u1) -b**2)+a
        ENDIF
!     ....s2
        IF(r5.ge.usqr/(wsqr+usqr)) THEN
!       ..arctg
          w2=r2*(wma-wmi) +wmi
          s2=b*tan(b*w2) +a
        ELSE
!       ..log
          u2=r2*(uma-umi) +umi
          s2=dsqrt(exp(2*a*u2) -b**2)+a
        ENDIF

      ELSEIF(r3.le.(prsqr+prrec)/prnorm) THEN
!     ..rectangle 1

!     ....s1
        IF(r4.ge.usqr/(wsqr+usqr)) THEN
!       ..arctg
          w1=r1*(wma-wmi) +wmi
          s1=b*tan(b*w1) +a
        ELSE
!       ..log
          u1=r1*(uma-umi) +umi
          s1=dsqrt(exp(2*a*u1) -b**2)+a
        ENDIF
!     ....s2
        IF(r5.ge.urec/(wrec+urec)) THEN
!       ..arctg
          w2=r2*(winf-wma) +wma     
          s2=b*tan(b*w2) +a
        ELSE
!       ..log
          u2=r2*(uinf-ulo) +ulo
          s2=dsqrt(exp(2*a*u2) -b**2)+a
        ENDIF

      ELSE
!     ..rectangle 2
!         write(6,*)'rect 1'
!     ....s1
        IF(r4.ge.urec/(wrec+urec)) THEN
!       ..arctg
          w1=r1*(winf-wma) +wma     
          s1=b*tan(b*w1) +a
        ELSE
!       ..log
          u1=r1*(uinf-ulo) +ulo
          s1=dsqrt(exp(2*a*u1) -b**2)+a
        ENDIF
!     ....s2
        IF(r5.ge.usqr/(wsqr+usqr)) THEN
!       ..arctg
          w2=r2*(wma-wmi) +wmi
          s2=b*tan(b*w2) +a
        ELSE
!       ..log
          u2=r2*(uma-umi) +umi
          s2=dsqrt(exp(2*a*u2) -b**2)+a
        ENDIF

      ENDIF
!
!     =====
      endif
!     =====

!
! crude distrib. value is 1/W(s_1)*1/W(s_2) see manual for definition
      xcrud=1d0
      IF(s1.gt.a) xcrud=xcrud*a/s1
      IF(s2.gt.a) xcrud=xcrud*a/s2
      xcrud=xcrud
     $  *((s1-rmas**2)**2 +(rmas*rgam)**2)
     $  *((s2-rmas**2)**2 +(rmas*rgam)**2)
!
      wt=prnorm*xcrud
! thresholds
      IF(sqrt(s1)+sqrt(s2).gt.sqrt(sprim)) THEN
        wt=0d0
      ENDIF
!-- check thresholds on decays
      IF(amdec(1)+amdec(2).gt.sqrt(s1)) THEN
        wt=0D0
      ENDIF
      IF(amdec(3)+amdec(4).gt.sqrt(s2)) THEN
        wt=0D0
      ENDIF
      END

      SUBROUTINE ww_cospro(mode,s,s1,s2,costhe,phipro,wt)
*     ***************************************************
! Crude generation of costhe according to a simplified distribution.
! OUTPUT: costhe - cos(theta), theta - polar angle of W- in the CMS 
!         of the incoming beams (+z axis along e- direction)
!         xccos - value of the function
!                      (for mode=1 costhe becames input for xccos
!                                     - no generation)
c
! Written by: M. Skrzypek            date: 3/1/95
! Last update:                         by: 
c
      implicit DOUBLE PRECISION (a-h,o-z)
      common / matpar / pi,ceuler     
      DOUBLE PRECISION drvec(100)
      save
!
CC==>>

!ms      wlambd=s**2+s1**2+s2**2-2*s*s1-2*s*s2-2*s1*s2
      wlambd=max(0d0,(s-s1-s2)**2 -4*s1*s2)
!      write(6,*)s,s1,s2,wlambd
      aa=(s-s1-s2)/2d0
      bb=-dsqrt(wlambd)/2d0
      ymi=dlog(aa-bb)/bb
      yma=dlog(s1*s2/(aa-bb))/bb

!      z=.4d0/s*(aa-bb)*2/s
      z=0d0  ! auxilliary, supposed to be 0


! this was `dead code' 05.06.96 ZW:      wt=2*pi/xccos
!
      IF(mode.ne.1) then
      call varran(drvec,3)
      y=drvec(1)*(yma-ymi)+ymi
      costhe=(exp(bb*y)-aa)/bb
      IF( drvec(2).gt.(yma-ymi)/(z+yma-ymi) )  costhe=2*drvec(1)-1  !
c++      write(6,*)'tran cosgen',aa+bb*costhe
      phipro=2*pi*drvec(3)
      endif
!
      xccos=(1/((s1*s2/(aa-bb))+(bb*costhe-bb)) +z/2d0)/(yma-ymi+z) 
      wt=2*pi/xccos 
      end

      subroutine ww_dumpl(nout,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)     
*     ****************************************************************     
c Prints out four-momenta and flavors of inermediate and 
c final particles on output unit nout
c 
c Written by: M.Skrzypek        date: 17.03.95
c Last update:             by:  
c
      implicit DOUBLE PRECISION (a-h,o-z)
      common / decays / iflav(4), amdec(4) 
      save   / decays /
      DOUBLE PRECISION sum(4),pho(4),sphot(100,4)     
      dimension p1(4),p2(4),p3(4),p4(4),qeff1(4),qeff2(4)

      p4mass=dmas2(p4)
      p3mass=dmas2(p3)
      p2mass=dmas2(p2)
      p1mass=dmas2(p1)
      e2mass=dmas2(qeff2)
      e1mass=dmas2(qeff1)

      p1mass=dsign(dsqrt(abs(p1mass)),p1mass)
      p2mass=dsign(dsqrt(abs(p2mass)),p2mass)
      p3mass=dsign(dsqrt(abs(p3mass)),p3mass)
      p4mass=dsign(dsqrt(abs(p4mass)),p4mass)
      e1mass=dsign(dsqrt(abs(e1mass)),e1mass)
      e2mass=dsign(dsqrt(abs(e2mass)),e2mass)


      write(nout,*) '=====================dumpl===================='
      write(nout,3200) ' p(1)',' p(2)',' p(3)',' p(4)','  sign*mass'

      do 100 i=1,nphot    
      do 110 k=1,4    
 110  pho(k)=sphot(i,k)
      amphot=dmas2(pho)
      phmass=dsign(dsqrt(abs(amphot)),amphot)
  100 write(nout,3100) 'PHO',(sphot(i,k),k=1,4),phmass
      write(nout,3100) ' p1',(p1(k),k=1,4),p1mass,iflav(1)  
      write(nout,3100) ' p2',(p2(k),k=1,4),p2mass,iflav(2)
      write(nout,3100) ' p3',(p3(k),k=1,4),p3mass,iflav(3)
      write(nout,3100) ' p4',(p4(k),k=1,4),p4mass,iflav(4)
      write(nout,3100) 'qf1',(qeff1(k),k=1,4),e1mass  
      write(nout,3100) 'qf2',(qeff2(k),k=1,4),e2mass
      do 101 k=1,4      
 101  sum(k)=p1(k)+p2(k)+p3(k)+p4(k)         
      do 210 i=1,nphot                       
      do 210 k=1,4                           
  210 sum(k)=sum(k)+sphot(i,k)               
      isfla=iflav(1)+iflav(2)+iflav(3)+iflav(4)
      e2mass=dmas2(sum)
      sumas=dsign(dsqrt(abs(e2mass)),e2mass)
      write(nout,3100) 'sum',(sum(k),k=1,4), sumas !,isfla 
      write(nout,*) '=============================================='  
 3100 format(1x,a3,5f21.15,i4)   
c 3100 format(1x,a3,1x,5f18.14)               
 3200 format(5x,4a22,a10)
      end   

*********************************************************
*           LIBRARY OF SOME KINEMATICS TOOLS            *
*********************************************************

      subroutine boostv(idir,vv,pp,q)
*     *******************************
c Boost along arbitrary vector v (see eg. J.D. Jacson, "Classical 
c Electrodynamics).
c Four-vector pp is boosted from an actual frame to the rest frame 
c of the four-vector v (for idir=1) or back (for idir=-1). 
c q is a resulting four-vector.
c Note: v must be time-like, pp may be arbitrary.
c
c Written by: Wieslaw Placzek            date: 22.07.1994
c Last update: 3/29/95                     by: M.S.
c 
      implicit DOUBLE PRECISION (a-h,o-z)
      parameter (nout=6)
      DOUBLE PRECISION v(4),p(4),q(4),pp(4),vv(4)  
      save
!
      do 1 i=1,4
      v(i)=vv(i)
 1    p(i)=pp(i)
      amv=(v(4)**2-v(1)**2-v(2)**2-v(3)**2)
      if (amv.le.0d0) then
        write(6,*) 'boostv: warning amv**2=',amv
      endif
      amv=sqrt(abs(amv))
      if (idir.eq.-1) then
        q(4)=( p(1)*v(1)+p(2)*v(2)+p(3)*v(3)+p(4)*v(4))/amv
        wsp =(q(4)+p(4))/(v(4)+amv)
      elseif (idir.eq.1) then
        q(4)=(-p(1)*v(1)-p(2)*v(2)-p(3)*v(3)+p(4)*v(4))/amv
        wsp =-(q(4)+p(4))/(v(4)+amv)
      else
        write(nout,*)' >>> boostv: wrong value of idir = ',idir
      endif
      q(1)=p(1)+wsp*v(1)
      q(2)=p(2)+wsp*v(2)
      q(3)=p(3)+wsp*v(3)
      end
              
      subroutine rotatv(mode,qq,pp,r)        
c     *******************************        
c rotation along arbitrary axis.
c pp rotated into r  from actual frame to frame with z-axis along qq  
c NOT TRUE 7/8/96 ms: (mode = 1) or back (mode = -1).      
c     TRUE 7/8/96 ms: (mode = -1) or back (mode = 1).      
c Written by: M. Skrzypek           date: 04.1995
c Last update: 7/9/96               by: M.S.   
      implicit double precision (a-h,o-z) 
      dimension qq(4),pp(4),r(4),tt(4)   
      parameter (pi = 3.1415926535897932D0)
      save
      the= asin(qq(1)/sqrt(qq(1)**2+qq(2)**2+qq(3)**2))
      phi= asin(qq(2)/sqrt(qq(2)**2+qq(3)**2))   
! ms 7/8/96, following line was missing (plus definition of PI)
      if(qq(3).lt.0d0) phi=pi-phi
      if(mode.eq.-1)then
        call rxtod1(phi,pp,tt)
        call rxtod2(-the,tt,r)
      elseif(mode.eq. 1)then
        call rxtod2(the,pp,tt)
        call rxtod1(-phi,tt,r)
      else
        write(6,*)'rotatv==> wrong mode:',mode
      endif
      end
 
      FUNCTION ANGLE(P,Q)
*     ******************
*  ANGLE BETWEEN TWO 3-COMPONENTS OF FOUR-VECTORS
*     ******************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION P(4),Q(4)
      PQ=P(3)*Q(3)+P(2)*Q(2)+P(1)*Q(1)
      PP=P(3)*P(3)+P(2)*P(2)+P(1)*P(1)
      QQ=Q(3)*Q(3)+Q(2)*Q(2)+Q(1)*Q(1)
      ARG=PQ/SQRT(PP*QQ)
      IF(ARG.GT. 1D0) ARG= 1D0
      IF(ARG.LT.-1D0) ARG=-1D0
      ANGLE=ACOS(ARG)
      END

      function dmas2(p)
c     *******************
      implicit DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION p(4)
      d3m = dsqrt(p(3)**2 +p(2)**2 +p(1)**2)  
      dmas2= (p(4)-d3m)*(p(4)+d3m)
      end

      function dot(p,q)
c     *******************
      implicit DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION p(4),q(4)  
      dot= p(4)*q(4) -p(3)*q(3) -p(2)*q(2) -p(1)*q(1)
      end

      FUNCTION dd2(x,y)
!     *********************************
      implicit double precision (a-h,o-z) 
      dimension x(4),y(4)   
      dd2 = (x(4)+y(4))**2 -(x(3)+y(3))**2 -(x(2)+y(2))**2
     %     -(x(1)+y(1))**2 
      end

      SUBROUTINE KineKW
*     *****************
!----------------------------------------------------------------------!
! KorlaW-like kinematics (for tests).                                  !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek,                       CERN, Sept. 2000  !
! Last update: 02.09.2000                   by: WP                     ! 
!----------------------------------------------------------------------!
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( PI=3.1415926535897932D0 )
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / MOMWWP / q1(4),q2(4),sphum(4),sphot(100,4),nphot
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),npho
      COMMON / cms_eff_momdec /
     $      effbeam1(4),effbeam2(4),effp1(4),effp2(4),effp3(4),effp4(4)
      SAVE / WEKING /,/ MOMWWP /,/ MOMDEC /,/ cms_eff_momdec /
      DIMENSION qq(4),effq1(4),effq2(4),effb1(4),effb2(4)
!
      ambeam = AMEL
      svar   = 4*ENE**2
      DO k = 1,4
         effq1(k) = effp1(k) + effp2(k)
         effq2(k) = effp3(k) + effp4(k)
         qq(k)    = effq1(k) + effq2(k)
      ENDDO
      sprim = qq(4)**2 - qq(3)**2 - qq(2)**2 - qq(1)**2
      CALL from_cms_eff(1,svar,sprim,ambeam,sphum,sphot,nphot,
     $                  effq1,effq2,effp1,effp2,effp3,effp4,
     $                  effb1,effb2,q1,q2,pf1,pf2,pf3,pf4)

      END

      SUBROUTINE from_cms_eff(mode,svar,sprim,ambeam,sphum,sphot,
     $      nphot, bq1,bq2,bp1,bp2,bp3,bp4,
     $      qeff1,qeff2,q1,q2,p1,p2,p3,p4)
*     **********************************************************
* this routine transforms 4momenta between cms (lab) and
*      effective cms (p_final)
*
* mode =  1   from cms_eff to cms
* mode = -1   from cms to cms_eff
* bq1,bq2,bp1,bp2,bp3,bp4   arbitrary 4momenta to be transformed
*
* output
*  q1, q2, p1, p2, p3, p4   transformed 4momenta
*  qeff1,qeff2              effective beams in cms (mode=1)
*                                           in cms_eff (mode=-1)
*
* written by: m. skrzypek              date: 7/6/96
*
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION qeff1(4),qeff2(4),sphum(4),sphot(100,4)
      DIMENSION bq1(4),bq2(4),bp1(4),bp2(4),bp3(4),bp4(4)
      DIMENSION q1(4),q2(4),p1(4),p2(4),p3(4),p4(4)
      DIMENSION qsu(4),ef1(4),ef2(4),photd(4),sphotd(100,4)
      DIMENSION def1(4),def2(4)

* to activate dumps kindmp=1
      kindmp=0

      DO 124, i=1,4
      q1(i)=bq1(i)
      q2(i)=bq2(i)
      p1(i)=bp1(i)
      p2(i)=bp2(i)
      p3(i)=bp3(i)
 124  p4(i)=bp4(i)


      IF(nphot .EQ. 0) THEN
*     ===================

* define effective beams (massive) in cms''

        qeff1(4)= sqrt(svar)/2d0
        qeff1(3)= dsqrt(svar/4d0-ambeam**2)
        qeff1(2)= 0d0
        qeff1(1)= 0d0
        qeff2(4)= sqrt(svar)/2d0
        qeff2(3)=-dsqrt(svar/4d0-ambeam**2)
        qeff2(2)= 0d0
        qeff2(1)= 0d0

      ELSEIF(nphot .GE. 1) THEN
*     =======================

* effective beams (in lab)
        ef1(4)= sqrt(svar)/2d0
        ef1(3)= dsqrt(svar/4d0-ambeam**2)
        ef1(2)= 0d0
        ef1(1)= 0d0
        ef2(4)= sqrt(svar)/2d0
        ef2(3)=-dsqrt(svar/4d0-ambeam**2)
        ef2(2)= 0d0
        ef2(1)= 0d0
        DO 11 ii=1,nphot
        IF(sphot(ii,3) .GE. 0d0) THEN
          DO 12 jj=1,4
 12       ef1(jj)= ef1(jj)-sphot(ii,jj)
        ELSE
          DO 13 jj=1,4
 13       ef2(jj)= ef2(jj)-sphot(ii,jj)
        ENDIF
 11     CONTINUE

      IF(kindmp .EQ. 1)THEN
        WRITE(6,*)'__lab0, ef1,ef2'
        CALL dumpl(6,p1,p2,p3,p4,ef1,ef2,sphot,nphot)
      ENDIF

* qsu is 4momentum of decay products (p1-p4) in cms
        DO 110 k=1,4
  110 qsu(k)=-sphum(k)
        qsu(4)=qsu(4)+sqrt(svar)

* transform ef1,2 to rest frame (cms')
* cms' is rotated cms_eff (z+ not along qeff1) !!!
        CALL boostv(1,qsu,ef1,ef1)
        CALL boostv(1,qsu,ef2,ef2)

      IF(kindmp .EQ. 1)THEN
        WRITE(6,*)'__cms ef1,2, phots lab'
        CALL dumpl(6,p1,p2,p3,p4,ef1,ef2,sphot,nphot)
        DO 70 i=1,nphot
        DO 71 j=1,4
 71     photd(j)=sphot(i,j)
*.. photons to cms'
        CALL boostv( 1,qsu,photd,photd)
*.. photons to cms''
        CALL rotatv(1,ef1,photd,photd)
        DO 72 j=1,4
 72     sphotd(i,j)=photd(j)
 70     CONTINUE
        WRITE(6,*)'cms ef1,2 phots cmsbis'
        CALL dumpl(6,p1,p2,p3,p4,ef1,ef2,sphotd,nphot)
* control
        CALL rotatv(-1,ef1,ef2,def2)
        WRITE(6,*)'__control'
        CALL dumpl(6,p1,p2,p3,p4,ef1,def2,sphot,nphot)
        CALL rotatv( 1,ef1,ef2,def2)
        WRITE(6,*)'__control'
        CALL dumpl(6,p1,p2,p3,p4,ef1,def2,sphot,nphot)
      ENDIF

*++++++++++++++++++++++++
      IF(mode .EQ. 1) THEN
*       from cms_eff to cms
*++++++++++++++++++++++++

* define effective beams (massive) in cms'' (cms_eff, z+ along qeff1)
        qeff1(4)= sqrt(sprim)/2d0
        qeff1(3)= dsqrt(sprim/4d0-ambeam**2)
        qeff1(2)= 0d0
        qeff1(1)= 0d0
        qeff2(4)= sqrt(sprim)/2d0
        qeff2(3)=-dsqrt(sprim/4d0-ambeam**2)
        qeff2(2)= 0d0
        qeff2(1)= 0d0

        IF(kindmp .EQ. 1)THEN
          WRITE(6,*)'___cmsbis, qeff1,qeff2'
          CALL dumpl(6,p1,p2,p3,p4,qeff1,qeff2,sphotd,nphot)
        ENDIF

* rotate from cms'' (z along ef1) to cms' (z along e- beam)
          CALL rotatv(-1,ef1,qeff1,qeff1)
          CALL rotatv(-1,ef1,qeff2,qeff2)
          CALL rotatv(-1,ef1,q1,q1)
          CALL rotatv(-1,ef1,q2,q2)
          CALL rotatv(-1,ef1,p1,p1)
          CALL rotatv(-1,ef1,p2,p2)
          CALL rotatv(-1,ef1,p3,p3)
          CALL rotatv(-1,ef1,p4,p4)

        IF(kindmp .EQ. 1)THEN
          WRITE(6,*)'__cmsprim'
          CALL dumpl(6,p1,p2,p3,p4,qeff1,qeff2,sphot,nphot)
        ENDIF

* transform back to lab
          CALL boostv(-1,qsu,qeff1,qeff1)
          CALL boostv(-1,qsu,qeff2,qeff2)
          CALL boostv(-1,qsu,q1,q1)
          CALL boostv(-1,qsu,q2,q2)
          CALL boostv(-1,qsu,p1,p1)
          CALL boostv(-1,qsu,p2,p2)
          CALL boostv(-1,qsu,p3,p3)
          CALL boostv(-1,qsu,p4,p4)
*.. fine tuning on masses
          qeff1(4)=dsqrt(ambeam**2+qeff1(1)**2+qeff1(2)**2+qeff1(3)**2)
          qeff2(4)=dsqrt(ambeam**2+qeff2(1)**2+qeff2(2)**2+qeff2(3)**2)

        IF(kindmp .EQ. 1)THEN
          WRITE(6,*)'__lab, qeff'
          CALL dumpl(6,p1,p2,p3,p4,qeff1,qeff2,sphot,nphot)
* transform ef1 back to lab
          CALL boostv(-1,qsu,ef1,def1)
          CALL boostv(-1,qsu,ef2,def2)
          WRITE(6,*)'__lab all, ef'
          CALL dumpl(6,p1,p2,p3,p4,def1,def2,sphot,nphot)
        ENDIF
*++++++++++++++++++++++++
        ELSEIF(mode .EQ. -1) THEN
*       to cms_eff from cms
*++++++++++++++++++++++++
          CALL boostv(1,qsu,q1,q1)
          CALL boostv(1,qsu,q2,q2)
          CALL boostv(1,qsu,p1,p1)
          CALL boostv(1,qsu,p2,p2)
          CALL boostv(1,qsu,p3,p3)
          CALL boostv(1,qsu,p4,p4)
          CALL rotatv(1,ef1,q1,q1)
          CALL rotatv(1,ef1,q2,q2)
          CALL rotatv(1,ef1,p1,p1)
          CALL rotatv(1,ef1,p2,p2)
          CALL rotatv(1,ef1,p3,p3)
          CALL rotatv(1,ef1,p4,p4)
*++++++++++++++++++++++++
        ELSE
*++++++++++++++++++++++++
          WRITE(6,*)'from_cms_eff==> wrong mode: ',mode
          STOP
*++++++++++++++++++++++++
        ENDIF
*++++++++++++++++++++++++
      ELSE
*     ====
        WRITE(6,*)'from_cms_eff==> wrong no of phots: ',nphot
        STOP
      ENDIF
*     =====
      END

      subroutine dumpl(nout,P1,P2,P3,P4,QEFF1,QEFF2,SPHOT,nphot)     
*     ****************************************************************     
c Prints out four-momenta and flavors of inermediate and 
c final particles on output unit nout
c 
c Written by: M.Skrzypek        date: 17.03.95
c Last update:             by:  
c
      implicit DOUBLE PRECISION (a-h,o-z)
      common / decays / iflav(4), amdec(4) 
      save   / decays /
      DOUBLE PRECISION sum(4),pho(4),sphot(100,4)     
      dimension p1(4),p2(4),p3(4),p4(4),qeff1(4),qeff2(4)

      p4mass=dmas2(p4)
      p3mass=dmas2(p3)
      p2mass=dmas2(p2)
      p1mass=dmas2(p1)
      e2mass=dmas2(qeff2)
      e1mass=dmas2(qeff1)

      p1mass=dsign(dsqrt(abs(p1mass)),p1mass)
      p2mass=dsign(dsqrt(abs(p2mass)),p2mass)
      p3mass=dsign(dsqrt(abs(p3mass)),p3mass)
      p4mass=dsign(dsqrt(abs(p4mass)),p4mass)
      e1mass=dsign(dsqrt(abs(e1mass)),e1mass)
      e2mass=dsign(dsqrt(abs(e2mass)),e2mass)


      write(nout,*) '=====================dumpl===================='
      write(nout,3200) ' p(1)',' p(2)',' p(3)',' p(4)','  sign*mass'

      do 100 i=1,nphot    
      do 110 k=1,4    
 110  pho(k)=sphot(i,k)
      amphot=dmas2(pho)
      phmass=dsign(dsqrt(abs(amphot)),amphot)
  100 write(nout,3100) 'PHO',(sphot(i,k),k=1,4),phmass
      write(nout,3100) ' p1',(p1(k),k=1,4),p1mass,iflav(1)  
      write(nout,3100) ' p2',(p2(k),k=1,4),p2mass,iflav(2)
      write(nout,3100) ' p3',(p3(k),k=1,4),p3mass,iflav(3)
      write(nout,3100) ' p4',(p4(k),k=1,4),p4mass,iflav(4)
      write(nout,3100) 'qf1',(qeff1(k),k=1,4),e1mass  
      write(nout,3100) 'qf2',(qeff2(k),k=1,4),e2mass
      do 101 k=1,4      
 101  sum(k)=p1(k)+p2(k)+p3(k)+p4(k)         
      do 210 i=1,nphot                       
      do 210 k=1,4                           
  210 sum(k)=sum(k)+sphot(i,k)               
      isfla=iflav(1)+iflav(2)+iflav(3)+iflav(4)
      e2mass=dmas2(sum)
      sumas=dsign(dsqrt(abs(e2mass)),e2mass)
      write(nout,3100) 'sum',(sum(k),k=1,4), sumas !,isfla 
      write(nout,*) '=============================================='  
 3100 format(1x,a3,5f21.15,i4)   
c 3100 format(1x,a3,1x,5f18.14)               
 3200 format(5x,4a22,a10)
      end   
      FUNCTION WtStYf(CMSEne,ame,amWm,amWp,epsCM) 
*     *******************************************
!----------------------------------------------------------------------!
! This FUNCTION provides a weight for corrected YFS Formfactor and     !
! S-tilde factor for the process:                                      !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! where radiation from W's is also included.                           !
! INPUT: CMSEne - Energy in the CMS [GeV];                             !
!        ame - electron mass [in GeV];                                 !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        epsCM - soft photon cut-of in the CMS, i.e. maximum value of  !
!                the energy allowed for soft photons divided by the    !
!                beam energy (in the center-of-mass system).           !
! NOTE: Coulomb correction is also included with proper interpolation. !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                    Knoxville, July 1996 !  
! Last update: 17.08.1999                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW
      COMMON / MOMSET / q1(4),q2(4),phsum(4),phot(100,4),nphot
      SAVE   / WEKIN2 /,/ MOMSET /
!
      sprim = ( q1(4) + q2(4) )**2 - ( q1(3) + q2(3) )**2 
     &      - ( q1(2) + q2(2) )**2 - ( q1(1) + q2(1) )**2  
      s1 = q1(4)**2 - q1(3)**2 - q1(2)**2 - q1(1)**2
      s2 = q2(4)**2 - q2(3)**2 - q2(2)**2 - q2(1)**2
      wtf = WTfmfa(CMSEne,ame,amWm,amWp,epsCM)
      wts = WTStil(CMSEne,ame,amWm,amWp)
      WtStYf = wtf*wts
      END

      FUNCTION WTfmfa(CMSEne,ame,amWm,amWp,epsCM) 
*     *******************************************
!----------------------------------------------------------------------!
! This FUNCTION provides a weight for corrected YFS Formfactor for     !
! the process:                                                         !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! where radiation from W's is also included.                           !
! INPUT: CMSEne - Energy in the CMS [GeV];                             !
!        ame - electron mass [in GeV];                                 !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        epsCM - soft photon cut-of in the CMS, i.e. maximum value of  !
!                the energy allowed for soft photons divided by the    !
!                beam energy (in the center-of-mass system).           !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                 Knoxville, October 1995 !  
! Last update: 13.05.1997                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
! Dummy photon mass (IR regulator)
      PARAMETER ( amgam = 1d-12 )
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      COMMON / MOMSET / q1(4),q2(4),phsum(4),phot(100,4),nphot
      SAVE   / KeyOth /,/ MOMSET /
      REAL*8 p1(4),p2(4)
      DATA nbad /0/
      SAVE nbad
!
      WTfmfa = 1
      p1(4) = CMSEne/2
      p1(3) = SQRT(p1(4)**2 - ame**2)
      p1(2) = 0
      p1(1) = 0
      p2(4) = p1(4)
      p2(3) =-p1(3)
      p2(2) = 0
      p2(1) = 0
      aKmax = epsCM*p1(4)
      IF (KeyCor.GE.4) THEN
        Ysf = 0d0
      ELSE
! Final state s-channel (W-W+)
        s1 = ( q1(4) + q2(4) )**2 - ( q1(3) + q2(3) )**2 
     &     - ( q1(2) + q2(2) )**2 - ( q1(1) + q2(1) )**2 
        ReBsf = ReBsch(s1,amWm,amWp,amgam)
        Btisf = Btilde(q1,q2,amWm,amWp,aKmax,amgam)
!...alternative calculation
cc        q1q2 = q1(4)*q2(4) -q1(3)*q2(3) -q1(2)*q2(2) -q1(1)*q2(1)
cc        Btisf = alfpi*BBBENI(q1q2,amWm,amWp,q1(4),q2(4),aKmax,amgam)
        Ysf = ReBsf + Btisf
      ENDIF
! t and u channels 
      ReBtu = ReBJtu(p1,p2,q1,q2,ame,amWm,amWp,amgam)
      Btitu = Btiltu(p1,p2,q1,q2,ame,amWm,amWp,amgam,aKmax)
      Ytu = ReBtu + Btitu
! YFS infrared function
      WTfmfa = EXP(Ysf + Ytu)
      END

      FUNCTION YFSfmf(p1,p2,q1,q2,ame,amWm,amWp,epsCM)
*     ************************************************
!----------------------------------------------------------------------!
! This FUNCTION provides a value of YFS FormFactor for the process:    !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! where radiation from W's is also included.                           !
! INPUT: p1,p2 - four-momenta of initial e- and e+, respectively;      !
!        q1,q2 - four-momenta of W- and W+ respectively;               !
!        ame - electron mass [in GeV];                                 !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        epsCM - soft photon cut-of in the CMS, i.e. maximum value of  !
!                the energy allowed for soft photons divided by the    !
!                beam energy (in the center-of-mass system).           !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                 Knoxville, October 1995 !  
! Last update: 08.11.1995                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 p1(4),p2(4),q1(4),q2(4)
!
      Ytot = BtiReb(p1,p2,q1,q2,ame,amWm,amWp,epsCM)
      YFSfmf = EXP(Ytot)
      END

      SUBROUTINE Yfirem(p1,p2,result)
*     *******************************
!----------------------------------------------------------------------!
! Remaining (without soft cut-off) part of the YFS formfactor for      !
! final state s-channel (W+W-).                                        !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, May 1996      !  
! Last update: 22.01.2001                     by: W.P.                 !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
! Value of transition velocity for Coulomb correction
      PARAMETER (betat = 0.382d0)
      COMMON / Coutra / KeyCou
      SAVE   / Coutra /
      REAL*8 p1(4),p2(4)
!
      E1 = p1(4)
      E2 = p2(4)
      am1s = p1(4)**2 - p1(3)**2 - p1(2)**2 - p1(1)**2
      am2s = p2(4)**2 - p2(3)**2 - p2(2)**2 - p2(1)**2
      am1  = SQRT(am1s)
      am2  = SQRT(am2s)
      am12 = am1*am2
      p1p2 = p1(4)*p2(4) - p1(3)*p2(3) - p1(2)*p2(2) - p1(1)*p2(1) 
      s    = 2*p1p2 + am1s + am2s
      beta = SQRT( 1 - 2*(am1s+am2s)/s + ((am1s-am2s)/s)**2 )
      rho   = SQRT( (1 + am12/p1p2)*(1 - am12/p1p2) )
      pro   = 2*p1p2*rho
      opr   = p1p2*(1 + rho)
      oprm1 = opr + am1s 
      oprm2 = opr + am2s
      Bigl  = LOG(opr/am12)
! Function ReB(s) - without IR singularity
      ReB2pi = 0.5*pro/s *Bigl + 0.5*(am1s-am2s)/s *LOG(am1/am2) 
     &       - ( LOG(opr/am1s)*LOG(opr/am2s)/2 + LOG(oprm1/oprm2)**2/2
     &         + DILOGY(pro/oprm1) + DILOGY(pro/oprm2) )/rho - 1
!WP     &       + pi**2/rho
! Interpolation - to match with Coulomb correction
      IF (beta.GT.betat) THEN
        KeyCou = 0
        ReB2pi = ReB2pi + pi**2/rho
      ELSE
        KeyCou = 1
        ReB2pi = ReB2pi + pi**2*beta/2
      ENDIF 
      ReBsch = alfpi*ReB2pi
! Preparation for B-tilde calculation
      bet1 = SQRT(1-am1**2/E1**2)
      bet2 = SQRT(1-am2**2/E2**2)
      b1ln = 2*LOG( (1+bet1)*E1/am1 )
      b2ln = 2*LOG( (1+bet2)*E2/am2 )
      IF (am1**2/p1p2.GT.1d-10 .AND. am2**2/p1p2.GT.1d-10) THEN
         A4   = A4anal(p1p2,E1,E2,am1,am2)
      ELSE
         A4   = A4lite(p1p2,E1,E2,am1,am2)
      ENDIF
! Function B-tilde - without IR singularity and soft cut-off dependence 
      Bti2pi = (Bigl/rho -1)*LOG(4*E1*E2/am1/am2) 
     &       + 0.5/bet1*b1ln + 0.5/bet2*b2ln + p1p2*A4
      Btilde = alfpi*Bti2pi
! Formfactor (remaining part)
      result = EXP(ReBsch + Btilde)
      END

      SUBROUTINE Yfire1(p1,p2,result)
*     *******************************
!----------------------------------------------------------------------!
! Remaining (without soft cut-off) part of the YFS formfactor for      !
! final state s-channel (W+W-) - another version, for tests only!      !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, Aug. 1997     !  
! Last update: 07.08.1997                     by: W.P.                 !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
! Dummy photon mass
      PARAMETER ( amgam = 1d-12 )
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / UUREC  / UU,EPS,DELTA    
      SAVE   / WEKING /,/ UUREC  / 
      REAL*8 p1(4),p2(4)
!
      aKmax = EPS*ENE
      am1 = SQRT(p1(4)**2 - p1(3)**2 - p1(2)**2 - p1(1)**2)
      am2 = SQRT(p2(4)**2 - p2(3)**2 - p2(2)**2 - p2(1)**2)
      am12 = am1*am2
      p1p2 = p1(4)*p2(4) - p1(3)*p2(3) - p1(2)*p2(2) - p1(1)*p2(1)
      xlam = SQRT( (p1p2 - am12)*(p1p2 + am12) )
! Function A(p1,p2)
      A  = 1/xlam *LOG( (p1p2 + xlam)/am12 )
! Soft cut-off dependent part of YFS formfactor
      Yscut = alfpi*(p1p2*A - 1) *LOG(aKmax**2/p1(4)/p2(4))
! Total YFS formfactor
      s1 = ( p1(4) + p2(4) )**2 - ( p1(3) + p2(3) )**2 
     &   - ( p1(2) + p2(2) )**2 - ( p1(1) + p2(1) )**2  
      ReBsf = ReBsch(s1,am1,am2,amgam)
      Btisf = Btilde(p1,p2,am1,am2,aKmax,amgam)
      Ytot = ReBsf + Btisf
! Cut-off independent part of the formfactor
      result = EXP(Ytot - Yscut)
      END

      FUNCTION BtiReb(p1,p2,q1,q2,ame,amWm,amWp,epsCM)
*     ************************************************
!----------------------------------------------------------------------!
! This FUNCTION provides a value of YFS infrared function Btilde+ReB   !
! for the process:                                                     !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! where radiation from W's is also included.                           !
! INPUT: p1,p2 - four-momenta of initial e- and e+, respectively;      !
!        q1,q2 - four-momenta of W- and W+ respectively;               !
!        ame - electron mass [in GeV];                                 !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        epsCM - soft photon cut-of in the CMS, i.e. maximum value of  !
!                the energy allowed for soft photons divided by the    !
!                beam energy (in the center-of-mass system).           !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                 Knoxville, October 1995 !  
! Last update: 08.11.1995                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.0359895d0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
! Dummy photon mass
      PARAMETER ( amgam = 1d-12 )
      REAL*8 p1(4),p2(4),q1(4),q2(4)
!
      aKmax = epsCM*p1(4)
! Initial state s-channel (e-e+)
      s = ( p1(4) + p2(4) )**2 - ( p1(3) + p2(3) )**2 
     &  - ( p1(2) + p2(2) )**2 - ( p1(1) + p2(1) )**2 
      bigs = LOG(s/ame**2)
      Ysi = alfpi*( 2*(bigs -1)*LOG(epsCM) + 0.5*bigs + pi**2/3 - 1)
! Final state s-channel (W-W+)
      s1 = ( q1(4) + q2(4) )**2 - ( q1(3) + q2(3) )**2 
     &   - ( q1(2) + q2(2) )**2 - ( q1(1) + q2(1) )**2  
      ReBsf = ReBsWW(s1,amWm,amWp,amgam)
      Btisf = Btilde(q1,q2,amWm,amWp,aKmax,amgam)
      Ysf = ReBsf + Btisf
! t and u channels 
      ReB = ReBJtu(p1,p2,q1,q2,ame,amWm,amWp,amgam)
      Bti = Btiltu(p1,p2,q1,q2,ame,amWm,amWp,amgam,aKmax)
      Ytu = ReB + Bti
! YFS infrared function
      BtiReB = Ysi + Ysf + Ytu
      END

      FUNCTION ReBsch(s,am1,am2,amg)
*     ******************************
!----------------------------------------------------------------------!
! The s-channel virtual infrared YFS function ReB for any pair of      !
! massive charged particles.                                           !
! INPUT: s = (p_1 + p_2)**2, where p_1, p_2 are particles 4-momenta;   !
!        am1, am2 - masses of particles;                               !
!        amg - dummy "photon mass" (IR regulator).                     !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, January 1996  !  
! Last update: 18.07.1996                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
! Value of transition velocity for Coulomb correction
      PARAMETER (betat = 0.382d0)
      COMMON / Coutra / KeyCou
      SAVE   / Coutra /
!
      am1s  = am1**2
      am2s  = am2**2
      am12  = am1*am2
      beta  = SQRT( 1 - 2*(am1s+am2s)/s + ((am1s-am2s)/s)**2 ) 
      p1p2  = (s - am1s - am2s)/2
      rho   = SQRT( (1 + am12/p1p2)*(1 - am12/p1p2) )
      pro   = 2*p1p2*rho
      opr   = p1p2*(1 + rho)
      oprm1 = opr + am1s 
      oprm2 = opr + am2s
      Bigl  = LOG(opr/am12)
      regl  = -2*LOG(SQRT(am12)/amg) 
! function ReB(s)
      ReB2pi = (Bigl/rho - 1)*regl + 0.5*pro/s *Bigl 
     &       + 0.5*(am1s-am2s)/s *LOG(am1/am2) 
     &       - ( LOG(opr/am1s)*LOG(opr/am2s)/2 + LOG(oprm1/oprm2)**2/2
     &         + DILOGY(pro/oprm1) + DILOGY(pro/oprm2) )/rho - 1
!WP     &       + pi**2/rho 
! Interpolation - to match with Coulomb correction
      IF (beta.GT.betat) THEN
        KeyCou = 0
        ReB2pi = ReB2pi + pi**2/rho
      ELSE
        KeyCou = 1
        ReB2pi = ReB2pi + pi**2*beta/2
      ENDIF
      ReBsch = alfpi*ReB2pi
      END

      FUNCTION ReBsWW(s,am1,am2,amg)
*     ******************************
!----------------------------------------------------------------------!
! The s-channel virtual infrared YFS function ReB for any pair of      !
! massive charged particles.                                           !
! INPUT: s = (p_1 + p_2)**2, where p_1, p_2 are particles 4-momenta;   !
!        am1, am2 - masses of particles;                               !
!        amg - dummy "photon mass" (IR regulator).                     !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, January 1996  !  
! Last update: 03.09.1996                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
!
      am1s  = am1**2
      am2s  = am2**2
      am12  = am1*am2
      p1p2  = (s - am1s - am2s)/2
      rho   = SQRT( (1 + am12/p1p2)*(1 - am12/p1p2) )
      pro   = 2*p1p2*rho
      opr   = p1p2*(1 + rho)
      oprm1 = opr + am1s 
      oprm2 = opr + am2s
      Bigl  = LOG(opr/am12)
      regl  = -2*LOG(SQRT(am12)/amg) 
! function ReB(s)
      ReB2pi = (Bigl/rho - 1)*regl + 0.5*pro/s *Bigl 
     &       + 0.5*(am1s-am2s)/s *LOG(am1/am2) 
     &       - ( LOG(opr/am1s)*LOG(opr/am2s)/2 + LOG(oprm1/oprm2)**2/2
     &         + DILOGY(pro/oprm1) + DILOGY(pro/oprm2) )/rho - 1
     &       + pi**2/rho 
      ReBsWW = alfpi*ReB2pi
      END

      FUNCTION ReBJtu(p1,p2,q1,q2,ame,amWm,amWp,amgam)
*     ************************************************
!----------------------------------------------------------------------!
! Virtual InfraRed YFS function ReB summed over t and u channels for   !
! the process:                                                         !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2),                    !
! INPUT: p1,p2 - four-momenta of initial e- and e+, respectively;      !
!        q1,q2 - four-momenta of W- and W+ respectively;               !
!        ame  - electron mass [in GeV];                                !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        amgam - dummy photon mass [GeV];                              !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, December 1995 !  
! Last update: 05.12.1995                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
      REAL*8 p1(4),p2(4),q1(4),q2(4)
!
      ame2  = ame**2
      amWm2 = amWm**2
      amWp2 = amWp**2
      amg2  = amgam**2
! Mandelstam invariants
      t1 = ( p1(4) - q1(4) )**2 - ( p1(3) - q1(3) )**2 
     &   - ( p1(2) - q1(2) )**2 - ( p1(1) - q1(1) )**2 
      t2 = ( p2(4) - q2(4) )**2 - ( p2(3) - q2(3) )**2 
     &   - ( p2(2) - q2(2) )**2 - ( p2(1) - q2(1) )**2 
      u1 = ( p1(4) - q2(4) )**2 - ( p1(3) - q2(3) )**2 
     &   - ( p1(2) - q2(2) )**2 - ( p1(1) - q2(1) )**2 
      u2 = ( p2(4) - q1(4) )**2 - ( p2(3) - q1(3) )**2 
     &   - ( p2(2) - q1(2) )**2 - ( p2(1) - q1(1) )**2
! t-channels
      ReBt1 = ReBJeW(t1,ame2,amWm2,amg2)
      ReBt2 = ReBJeW(t2,ame2,amWp2,amg2)
! u-channels
      ReBu1 = ReBJeW(u1,ame2,amWp2,amg2)
      ReBu2 = ReBJeW(u2,ame2,amWm2,amg2)
! total ReB
      ReBJtu = ReBt1 + ReBt2 - Rebu1 - Rebu2
      END

      FUNCTION ReBJeW(q2,ame2,amW2,amg2)
*     **********************************
!----------------------------------------------------------------------!
! The t or u channel virtual infrared YFS function for any pair of     !
! the initial state e-, e+ and final state W-, W+.                     !
! INPUT: q2 - any (pi - qj)**2, where pi, qj are four-momenta of       !
!             the initial and final state particles, respectively;     !
!        ame2, amW2 - electron and W squared masses, respectively;     !
!        amg2 - "photon mass" squared.                                 !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, November 1995 !  
! Last update: 28.01.1996                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
!
      ReBJeW = 0
      tr = ABS(q2)
      IF (tr.lt.1d-10) RETURN
      eln  = LOG(tr/ame2)
      Wln  = LOG(tr/amW2)
      bigl = 0.5*(eln + Wln)
      eta  = 1 + amW2/tr
      etal = LOG(eta)
      amal = 0.5*LOG(amW2/ame2)
! virtual IR function ReB2eW
      ReBJeW = alfpi*( -(bigl + etal - 1)*LOG(ame2/amg2) 
     &               + eta/2*(bigl + etal) - 0.5*eln*Wln 
     &               - 0.5*LOG(amW2/ame2)*( bigl + etal + (eta-3)/2 )
     &               - etal*( bigl + etal/2) + DILOGY(1/eta) - 1 )
      END

      FUNCTION Btiltu(p1,p2,q1,q2,ame,amWm,amWp,amgam,aKmax)
*     ******************************************************
!----------------------------------------------------------------------!
! Real photon InfraRed YFS function B-tilde for the process:           !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! for t+u channels.                                                    !
! INPUT: p1,p2 - four-momenta of initial e- and e+, respectively;      !
!        q1,q2 - four-momenta of W- and W+ respectively;               !
!        ame  - electron mass [in GeV];                                !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!        amgam - dummy photon mass [GeV];                              !    
!        aKmax - maximum soft photon energy [GeV].                     !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, December 1995 !  
! Last update: 05.12.1995                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
      PARAMETER ( precis = 1d-4 )
      REAL*8 p1(4),p2(4),q1(4),q2(4)
!
! scalar products of particles four-momenta
cc      p1q1 = p1(4)*q1(4) -p1(3)*q1(3) -p1(2)*q1(2) -p1(1)*q1(1)
cc      p2q2 = p2(4)*q2(4) -p2(3)*q2(3) -p2(2)*q2(2) -p2(1)*q2(1)
cc      p1q2 = p1(4)*q2(4) -p1(3)*q2(3) -p1(2)*q2(2) -p1(1)*q2(1)
cc      p2q1 = p2(4)*q1(4) -p2(3)*q1(3) -p2(2)*q1(2) -p2(1)*q1(1)
! t-channels
      Bt1 = Btilde(p1,q1,ame,amWm,aKmax,amgam)
      Bt2 = Btilde(p2,q2,ame,amWp,aKmax,amgam)
!...alternative calculation
cc      Bt1 = alfpi*BBBENI(p1q1,ame,amWm,p1(4),q1(4),aKmax,amgam)
cc      Bt2 = alfpi*BBBENI(p2q2,ame,amWp,p2(4),q2(4),aKmax,amgam)
! u-channels
      Bu1 = Btilde(p1,q2,ame,amWp,aKmax,amgam)
      Bu2 = Btilde(p2,q1,ame,amWm,aKmax,amgam)
!...alternative calculation
cc      Bu1 = alfpi*BBBENI(p1q2,ame,amWp,p1(4),q2(4),aKmax,amgam)
cc      Bu2 = alfpi*BBBENI(p2q1,ame,amWm,p2(4),q1(4),aKmax,amgam)
! total B-tilde
      Btiltu = Bt1 + Bt2 - Bu1 - Bu2
      END

      FUNCTION Btilde(p1,p2,am1,am2,aKmax,amgam)
*     ******************************************
!----------------------------------------------------------------------!
! This function provides a value of YFS real photon IR function        !
! B-tilde for any pair of charged particles.                           !
! INPUT: p1,p2   - particles 4-momenta;                                !
!        am1,am2 - particles masses;                                   !
!        amgam   - "photon mass" (IR regulator)                        !
!        aKmax   - maximum soft photon energy [GeV]                    !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, January  1996 !  
! Last update: 23.01.2001                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
      REAL*8 p1(4),p2(4)
!
      Btilde = 0
      E1 = p1(4)
      E2 = p2(4)
      am12 = am1*am2
      p1p2 = p1(4)*p2(4) - p1(3)*p2(3) - p1(2)*p2(2) - p1(1)*p2(1)
      IF (p1p2-am12.lt.1d-10) RETURN
      xlam = SQRT( (p1p2 - am12)*(p1p2 + am12) )
! Function A(p1,p2)
      A  = 1/xlam *LOG( (p1p2 + xlam)/am12 )
      bet1 = SQRT(1-am1**2/E1**2)
      bet2 = SQRT(1-am2**2/E2**2)
      b1ln = 2*LOG( (1+bet1)*E1/am1 )
      b2ln = 2*LOG( (1+bet2)*E2/am2 )
! Function A4(p1,p2)
      IF (am1**2/p1p2.GT.1d-10 .AND. am2**2/p1p2.GT.1d-10) THEN
         A4   = A4anal(p1p2,E1,E2,am1,am2)
      ELSE
         A4   = A4lite(p1p2,E1,E2,am1,am2)
      ENDIF
! B-tilde(p1,p2;aKmax,amgam)
      Btian = (p1p2*A - 1) *2*LOG(2*aKmax/amgam)
     &      + 0.5/bet1*b1ln + 0.5/bet2*b2ln + p1p2*A4
      Btilde = alfpi*Btian
      END

      FUNCTION A4anal(p1p2,En1,En2,xm1,xm2)
*     *************************************
!----------------------------------------------------------------------!
! This FUNCTION provides an analytical result for the integral         !
! A4(p1,p2) being a part of the YFS IR function B-tilde.               !
! Note: This is a general case without any approximation!              !
! INPUT: p1p2    - scalar product of the 4-momenta p1 and p2;          !
!        E1,E2   - particles energies;                                 !
!        xm1,xm2 - particles masses;                                   !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, January  1996 !  
! Last update: 30.01.1996                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(a-h,o-z)
! Statement FUNCTION
      etaln(x1,x2,x3,x4,z) = LOG(ABS( (z-x1)*(z-x2)/(z-x3)/(z-x4) ))
! Some auxiliary variables
      E1 = En1
      E2 = En2
      am1 = xm1
      am2 = xm2
      p1s = E1**2 - am1**2
      p2s = E2**2 - am2**2
      IF (p1s.lt.p2s) THEN
        am1 = xm2
        am2 = xm1
        E1 = En2
        E2 = En1
      ENDIF
      Ep  = E1 + E2
      Em  = E1 - E2
      sm  = am1 + am2 
      dm  = am1 - am2
      Q2  = 2*p1p2 - am1**2 - am2**2
      xl  = SQRT( (Q2 + sm**2)*(Q2 + dm**2) )
      xq  = SQRT(Q2 + Em**2)
      qp = xq + Em
      qm = xq - Em
      et0 = SQRT(E2**2 - am2**2)
      IF (p1p2.gt.E1*E2) et0 = -et0
      et1 = SQRT(E1**2 - am1**2) + xq
      y1  = 0.5*( (xq - Ep) + (sm*dm + xl)/qp )
      y2  = y1 - xl/qp
      y3  = 0.5*( (xq + Ep) + (sm*dm + xl)/qm )
      y4  = y3 - xl/qm       
! Some auxiliary functions
      IF (ABS(Em).gt.1d-10) THEN
        Eln = LOG(ABS(qm/qp))*( etaln(y1,y4,y2,y3,et1) 
     &                        - etaln(y1,y4,y2,y3,et0) )
      ELSE
        Eln = 0
      ENDIF
      Vet0 = Yijeta(y1,y4,et0) + Yijeta(y2,y1,et0)
     &     + Yijeta(y3,y2,et0) - Yijeta(y3,y4,et0)
     &     + 0.5*etaln(y1,y2,y3,y4,et0)*etaln(y2,y3,y1,y4,et0)
      Vet1 = Yijeta(y1,y4,et1) + Yijeta(y2,y1,et1)
     &     + Yijeta(y3,y2,et1) - Yijeta(y3,y4,et1)
     &     + 0.5*etaln(y1,y2,y3,y4,et1)*etaln(y2,y3,y1,y4,et1)
! Function A4(p1,p2) 
      A4anal = 1/xl*(Eln + Vet1 - Vet0 )
      END

      FUNCTION A4lite(p1p2,En1,En2,xm1,xm2)
*     *************************************
!----------------------------------------------------------------------!
! This FUNCTION provides an analytical result for the integral         !
! A4(p1,p2) being a part of the YFS IR function B-tilde for very light !
! particles: xm1**2,xm2**2 << p1p2.                                    !
! INPUT: p1p2    - scalar product of the 4-momenta p1 and p2;          !
!        E1,E2   - particles energies;                                 !
!        xm1,xm2 - particles masses;                                   !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                     CERN, January  2001 !  
! Last update: 23.01.2001                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER ( pi = 3.1415926535897932D0 )
!
! Auxiliary variables
      Ep  = En1 + En2
      Em  = En1 - En2
      Ecm = 4*En1*En2
      xm12 = xm1*xm2
      Q2 = 2*p1p2
      Del = SQRT(Q2 + Em**2)
      DmEm = Del - Em 
      DpEm = Del + Em 
      DmEp = Del - Ep 
      DpEp = Del + Ep 
! Combination of logs and dilogs      
      p1p2A4 = - LOG(Q2/xm12)*LOG(Ecm/xm12) + 0.5*LOG(Q2/xm12)**2
     &         - 0.5*LOG(xm1/xm2)**2 + LOG(En1/En2)*LOG(xm1/xm2)
     &         - 0.25*LOG(DpEm**2/Ecm)**2 - 0.25*LOG(DmEm**2/Ecm)**2
     &         - 0.5*LOG(En1/En2)**2 + pi**2/6
     &         - DILOGY(DpEp/DpEm) - DILOGY(DpEp/DmEm)
     &         - DILOGY(DmEp/DpEm) - DILOGY(DmEp/DmEm)
! Final result
      A4lite = p1p2A4/p1p2
      END

      FUNCTION Yijeta(yi,yj,eta)
*     **************************
!----------------------------------------------------------------------!
! Some auxiliary function (combination of Logs and Dilogs) used in     !
! the function A4anal for A4(p1,p2).                                   !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                Knoxville, January  1996 !  
! Last update: 30.01.1996                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(a-h,o-z)
!
      Yijeta = 2*DILOGY( (yj-yi)/(eta-yi) ) 
     &       + 0.5*LOG(ABS( (eta-yi)/(eta-yj) ))**2
      END

C=======================================================================
C=======================================================================
C This is the formula of Bennie Ward (for 2*pi*BTILDA) 
      FUNCTION BBBENI(Z,AM1,AM2,E1,E2,AKMAX,AMGAM)
*     ********************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON /COEFF/ETA1,ETA0,ALAM1,ALAM2,Y1,Y0,amit
      COMMON /CCOST/COST,be2,bf2
      DATA PI /3.1415926535897932D0/ 
 
      BE2=AM1**2/E1**2
      BF2=AM2**2/E2**2
      BEBF=Z/E1/E2
      ALM1=BE2-BEBF
      ALM2=BE2+BF2-2D0*BEBF
      ALAM1=ALM1
      ALAM2=ALM2
!WP(((
      COST = (1-BEBF)/SQRT( (1-BE2)*(1-BF2) )
      IF (COST.LT.-1D0) COST =-1D0
      IF (COST.GT. 1D0) COST = 1D0
!WP)))
      zl=z
      if(be2.eq.bf2.and. cost.gt.0.9999d0)then
         alam1=-(1d0-be2)
         alm1=alam1
         alam2=-2d0*(1d0-be2)
         alm2=alam2
         ami=dsqrt(1d0+cost)/2d0
         tanr0=-dsqrt(1d0-cost)/2d0
         tanr1=-tanr0
         secr0=ami*dsqrt(1d0+(1d0-cost)/(1d0+cost))
         secr1=secr0
         zl=z
         else
CWW   AMI=SQRT(ABS((BE2-1D0)/ALM2-ALM1**2/ALM2**2))
      AMI=DSQRT(1D0-BE2)*DSQRT(1D0-BF2)/(-ALM2)
      ami=ami*dsqrt(1d0-cost**2)
      amit=ami
      te1=max(dabs(ami*alm2/alm1),dabs(ami*dsqrt(-alm2)))
      if(-alm1.gt.-alm2)  te1=max(te1,dabs(ami*alm2/(alm1-alm2)))
cww   write(6,*) ami, te1
      if(te1.lt.5d-2)ami=0d0
      if(dabs(bf2-be2).gt.0d0)then
      IF(DABS(DABS(COST)-1D0).LT.1D-14)AMI=0D0
	    else
		  endif
      TANR1=(1D0-ALM1/ALM2)
      TANR0=-ALM1/    ALM2
      SECR0=SQRT(    TANR0**2+AMI*AMI)
      SECR1=SQRT(    TANR1**2+AMI*AMI)
          endif
      IF(DABS(SECR0+TANR0).LT.1D-8)THEN
      ETA0=20D0
      ELSE
      ETA0=LOG(SECR0+TANR0)
      ENDIF
      IF(DABS(SECR1+TANR1).LT.1D-8)THEN
      ETA1=20D0
      ELSE
      ETA0=LOG(SECR1+TANR1)
      ENDIF
CWW   ETA1=LOG(SECR1+TANR1)
      Y0=SECR0+TANR0
      Y1=SECR1+TANR1
      IF(BE2.EQ.BF2.AND.COST.GT..9999D0)THEN
 
      alfp=-alm1*(1d0-cost)+sqrt(alm1**2*(1d0-cost)**2-be2*alm2*(1d0
     $  -COST))
 
      ALFM=-ALM1*(1D0-COST)-SQRT(ALM1**2*(1D0-COST)**2-BE2*ALM2*(1D0
     $  -COST))
      ELSE
      ALFP=ALM1/(-1D0)
     $     +SQRT(ABS((ALM1)**2+(0D0-BE2)*ALM2))
 
      ALFM=ALM1/(-1D0)
     $     -SQRT(ABS((ALM1)**2+(0D0-BE2)*ALM2))
         ENDIF
!WP      X0=SQRT(ABS(1D0-AMGAM**2/(AKMAX**2+AMGAM**2)))
      X0T=1D0
CWW   XI1P=XI1(X0,AMI)
      XI1P=0D0
CWW   XI1M=XI1(-X0,AMI)
      XI1M=0D0
      XI2P=XI2(X0T,AMI,1D0)
      XI2M=XI2(-X0T,AMI,1D0)
CWW   XI3P=XI2(X0,AMI,-1D0)+2D0*XI1(X0,AMI)
      XI3P=XI2(X0T,AMI,-1D0)
CWW   XI3M=XI2(-X0,AMI,-1D0)+2D0*XI1(-X0,AMI)
      XI3M=XI2(-X0T,AMI,-1D0)
c      print*,'y0,y1=',y0,y1
c      print*,'xi2p,xi2m=',xi2p,xi2m
c      print*,'xi3p,xi3m=',xi3p,xi3m
!WP
      xir = 2*LOG(2*AKMAX/AMGAM) 

       IF(BE2.EQ.BF2.AND.COST.GT.(1D0-2D-5*BE2/(1D0-BE2)))THEN
!WP      bb=(dlog(1d0+x0t)-dlog(1d0-x0))/be2
         bb=xir/be2
       ELSEIF(BE2.EQ.BF2    .AND.COST.GT..9999D0.AND.
     $            COST.LE.(1D0-2D-5*BE2/(1D0-BE2)))THEN
      bb=-1d0/2d0/sqrt(alm1**2*(1d0-cost)**2-be2*alm2*(1d0-cost))
     $     *(LOG(ABS(-ALM2*(1D0-COST)-ALFP))-LOG(ABS(ALFP))
     $       -LOG(ABS(-ALM2*(1D0-COST)-ALFM))
!WP     $       +LOG(ABS(ALFM)))*(LOG(1D0+X0T)-LOG(1D0-X0))
     $       +LOG(ABS(ALFM)))*xir
C        WRITE(6,*)' BB=',BB
                 ELSE
      BB=-1D0/2D0/SQRT(ABS(ALM1**2+ALM2*(0D0-BE2)))
     $*(LOG(ABS(-ALM2-ALFP))-LOG(ABS(ALFP))-LOG(ABS(-ALM2-ALFM))
!WP     $    +LOG(ABS(ALFM)))*(LOG(1D0+X0)-LOG(1D0-X0))
     $    +LOG(ABS(ALFM)))*xir
       endif
       bb=bb +XI1P+0.5D0*XI2P-0.5D0*XI3P-XI1M
     $     -0.5D0*XI2M+0.5D0*XI3M
 
c     BB=-1D0/2D0/SQRT(ABS(ALM1**2+ALM2*(0D0-BE2)))
c     $*(LOG(ABS(-ALM2-ALFP))-LOG(ABS(ALFP))-LOG(ABS(-ALM2-ALFM))
c!WP  $    +LOG(ABS(ALFM)))*(LOG(1D0+X0)-LOG(1D0-X0))
c     $    +LOG(ABS(ALFM)))*XIR
c     $     +XI1P+0.5D0*XI2P-0.5D0*XI3P-XI1M
c     $     -0.5D0*XI2M+0.5D0*XI3M
 
      BET1=SQRT(E1**2-AM1**2)/E1
      BET2=SQRT(E2**2-AM2**2)/E2
!WP      TET=SQRT(1D0-AMGAM**2/(AKMAX**2+AMGAM**2))
      TET=1
!WP      tet0 = 1d0     
!WP      B1=0.5D0*AM1**2/E1/E1/BET1*(
!WP     $   -0.5D0/(1D0-BET1)*LOG(1D0-TET)
!WP     $   -0.5D0/(1D0+BET1)*LOG(1D0+TET)
!WP     $   +1D0/(1D0-BET1**2)*LOG(1D0-BET1*TET0))
!WP     $  -0.5D0*AM1**2/E1/E1/BET1*(
!WP     $   -0.5D0/(1D0+BET1)*LOG(1D0-TET)
!WP     $   -0.5D0/(1D0-BET1)*LOG(1D0+TET)
!WP     $   +1D0/(1D0-BET1**2)*LOG(1D0+BET1*TET0))
!WP      B2=0.5D0*AM2**2/E2/E2/BET2*(
!WP     $   -0.5D0/(1D0-BET2)*LOG(1D0-TET)
!WP     $   -0.5D0/(1D0+BET2)*LOG(1D0+TET)
!WP     $   +1D0/(1D0-BET2**2)*LOG(1D0-BET2*TET0))
!WP     $ - 0.5D0*AM2**2/E2/E2/BET2*(
!WP     $   -0.5D0/(1D0+BET2)*LOG(1D0-TET)
!WP     $   -0.5D0/(1D0-BET2)*LOG(1D0+TET)
!WP     $   +1D0/(1D0-BET2**2)*LOG(1D0+BET2*TET0))
!WPC      WRITE(6,*)XI2P,XI2M,XI3P,XI3M
!WPC      WRITE(6,*)ZL,B1,B2,BB
!WP      BBBENI=ZL/E1/E2*BB-B1-B2
!WP: Corrected (for large masses) B1 and B2 functions
      B1 = 0.5*( xir + 1/BET1*LOG( (1-BET1*TET)/(1+BET1*TET) ) )
      B2 = 0.5*( xir + 1/BET2*LOG( (1-BET2*TET)/(1+BET2*TET) ) )

      BBBENI=Z/E1/E2*BB-B1-B2
c      WRITE(6,*)COST,B1,B2,BB,BBBENI
      if (BBBENI.ge.-1d3 .and.BBBENI.le.1d3) then
         BBBENI = BBBENI
      else
         print *,' am1,am2,E1,E2=',am1,am2,E1,E2
c         print*,' tanr0,tanr1,secr0,secr1=',tanr0,tanr1,secr0,secr1
c         print *,'y0,y1=',y0,y1
         print *,'COST,AMI,BBBENI',COST,AMI,BBBENI
        call dumps(6)
        BBBENI = 0
      endif
      END

      FUNCTION  XI2(X0,AMI,AMII)
*     **************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON /COEFF/ETA1,ETA0,ALAM3,ALAM4,Y1,Y0,amit
      common /ccost/ cost,be2,bf2
      DATA PI /3.1415926535897932D0/
      alam2=alam4
      alam1=alam3
      ALAMT=-ALAM2
      abe=dsqrt(1d0-be2)
      abf=dsqrt(1d0-bf2)
           if(cost.lt.0d0)then
      alm20=-(abe+abf)**2
      alm10=-abe*(abe+abf)
           elseif(cost.gt.0d0)then
      alm20=-(abe-abf)*(abe-abf)
      alm10=-abe*(abe-abf)
           endif
      HP=1D0/AMII/SQRT(ABS(ALAM2))
     $  +SQRT(ABS(1D0/ALAMT/AMII**2-AMI*AMI))
 
      HM=1D0/AMII/SQRT(ABS(ALAM2))
     $  -SQRT(ABS(1D0/ALAMT/AMII**2-AMI*AMI))
 
        HPMHM=2D0*
     $   SQRT(ABS(1D0/ALAMT/AMII**2-AMI*AMI))
 
C     IF(DABS(HM).LT.1D-7)HM=0D0
C     IF(DABS(HP).LT.1D-7)HP=0D0
      IF(AMII.LT.0D0.AND. AMI.EQ.0D0)then
             HP=0D0
             ALAMT=-alm20
             HM=-2d0/dsqrt(alamt)
             alam2=alm20
             alam1=alm10
             hpmhm=dsqrt(alam4/alm20)*hpmhm
             endif
      IF(AMII.GT.0D0.AND.AMI.EQ.0D0)then
             HM=0D0
             alamt=-alm20
             alam2=alm20
             alam1=alm10
             HP=2d0/dsqrt(alamt)
             hpmhm=dsqrt(alam4/alm20)*hpmhm
             endif
              IF(BE2.EQ.BF2.AND. COST.GT..9999D0.AND.COST.LE.
     $        (1D0-2D-5* BE2/ABE**2    ))THEN
              HPMHM=HPMHM*SQRT(1D0-COST)
              ENDIF
C     WRITE(6,222)HM,HP,AMI,Y0,Y1
C 222 FORMAT(1X,5D10.4)
      HPX=1D0/    X0/SQRT(ABS(ALAM2))
     $     +SQRT(ABS(1D0/X0**2/ALAMT       -AMI*AMI))
 
      HMX=1D0/    X0/SQRT(ABS(ALAM2))
     $     -SQRT(ABS(1D0/X0**2/ALAMT       -AMI*AMI))
 
CW    XI1=1D0/SQRT(ABS(ALAM2))*(
CW   $     (ETA1-ETA0)*LOG(ABS((-X0*SQRT(ABS(ALAM2))    /2D0)))
CW   $     +(ETA1**2-ETA0**2)/2D0+DILOGY(HPX*EXP(-ETA1))
CW   $     -DILOGY(HPX*EXP(-ETA0))+DILOGY(HMX*EXP(-ETA1))
CW   $     -DILOGY(HMX*EXP(-ETA0)))
       XI1=0D0
 
CW    A1=DILOGY(-(Y1-HP)/HP)-DILOGY(-(Y0-HP)/HP)
CW   $     -LOG(ABS(HP))*LOG(ABS((Y1-HP)/(Y0-HP)))
CW   $-DILOGY(-(Y1-HM)/HM)+DILOGY(-(Y0-HM)/HM)
CW   $     +LOG(ABS(HM))*LOG(ABS((Y1-HM)/(Y0-HM)))
       A1=0D0
          IF(-ALAM1.LT.ALAMT)THEN
      IF(HP.EQ.0D0)THEN
         RAL2=1D0+ DSQRT(ABS(ALAM2))/ABS(ALAM1)
         IF(X0.GT.0D0)THEN
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(RAL2 )))
     $                             -LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((Y1-HP)/(RAL2 )))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(1D0+X0))*LOG(ABS((Y1-HP)/(RAL2 )))
     $+DILOGY((HMX-HP)/(Y1-HP))+.5D0*DLOG((1D0+X0)/(Y1-HP))**2-PI*PI/3D0
     $                        +DILOGY(RAL2   /(1D0+X0))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
         ELSEIF(X0.LT.0D0)THEN
        ZAL1=-(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(RAL2 )))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
CWW   A3=  LOG(ABS(1D0+X0))*LOG(ABS((Y1-HP)/(RAL2 )))
CWW  $+DILOGY((HPX-HP)/(Y1-HP))+.5D0*DLOG((1D0+X0)/(Y1-HP))**2-PI*PI/3D0
      A3= -DILOGY(Y1-HP)-DILOGY(1D0/(Y1-HP))
CC   $
     $                        +DILOGY((RAL2 ))+DILOGY(1D0/RAL2)
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(RAL2 )))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(ZAL1  ))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/( ZAL1 ))+DILOGY((Y0-HM)/( ZAL1 ))
     $-DILOGY(ZAL1/(Y1-HM))+DILOGY(ZAL1/(Y0-HM))
         ENDIF
       ELSEIF(HM.EQ.0D0)THEN
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c       RAL2=-1D0+(DSQRT(ABS(ALAM2))/ABS(ALAM1))*(1d0-((alam2/alam1)**2
c    $          +alam2)*amit*amit/4d0)
        RAL2=(1d0-dsqrt(1d0-be2))*dsqrt(abs(alam2))/abs(alam1)
         IF(X0.GT.0D0)THEN
        ZAL1= (1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
C       WRITE(6,*) 'RAL2=',RAL2,ZAL1,HMX,HPX
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(RAL2 ))))
 
      A3=  LOG(ABS(ZAL1  ))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(ZAL1  ))+DILOGY((Y0-HP)/(ZAL1  ))
     $-DILOGY(ZAL1/(Y1-HP))+DILOGY(ZAL1/(Y0-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(RAL2 )))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
CWW  $     +LOG(ABS(1D0-X0))*LOG(ABS((Y1-HM)/(RAL2 )))
CWW  $+DILOGY((HMX-HM)/(Y1-HM))+.5D0*DLOG((1-X0)/(Y1-HM))**2+PI*PI/6D0
     $-DILOGY(-Y1+HM)          +DILOGY(-RAL2) -DILOGY(-1D0/(Y1-HM))
     $                        +DILOGY(-1D0/RAL2)
           ELSEIF(X0.LT.0D0)THEN
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(RAL2 ))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(1D0-X0))*LOG(ABS((Y1-HM)/(RAL2 )))
     $+DILOGY((HPX-HM)/(Y1-HM))+.5D0*DLOG((1D0-X0)/(Y1-HM))**2+PI*PI/6D0
     $                        +DILOGY( RAL2  /(-1D0+X0))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((Y1-HM)/(RAL2 )))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
             ENDIF
        ELSE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
           IF( AMII*X0.LT.0D0)THEN
c              write(6,*)' HERE'
               IF(BE2.EQ.BF2.AND.COST.GT.(1D0-2D-5*BE2/ABE**2))THEN
 
 
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    1d0/(Y0-HP)-1d0/(Y0-HM))
 
      A3=  LOG(ABS(HP-HPX))/(Y0-HP)
     $+DLOG(abs(1d0-(Y0-HP)/(HPX-HP)))/(y0-hp)
     $    +LOG(ABS(HP-HMX))/(Y0-HP)
     $+DLOG(abs(1d0-(Y0-HP)/(HMX-HP)))/(y0-hp)
 
       A4=   LOG(ABS(HM-HPX))/(Y0-HM)
     $+DLOG(abs(1d0-(Y0-HM)/(HPX-HM)))/(y0-hm)
     $     +LOG(ABS(HM-HMX))/(Y0-HM)
     $+DLOG(abs(1d0-(Y0-HM)/(HMX-HM)))/(y0-hm)
 
                     else
 
 
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
                         endif
             ELSE
          IF(AMII.GT.0D0)THEN
        ZAL1=-(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
        ZAL2=-(1D0-1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
                         ELSE
         ZAL1=(1D0-1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
         ZAL2=(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
                         ENDIF
                IF(BE2.EQ.BF2.AND.COST.GT.(1D0-2D-5*BE2/ABE**2))THEN
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    1d0/(Y0-HP)-1d0/(Y0-HM))
 
      A3=  LOG(ABS(ZAL1  ))/(Y0-HP)
     $+DLOG(abs(1d0-(Y0-HP)/(-ZAL1 )))/(y0-hp)
     $- DLOG(abs(1d0+ZAL1/(Y0-HP)))/(y0-hp)
     $    +LOG(ABS(HP-HMX))/(Y0-HP)
     $+DLOG(abs(1d0-(Y0-HP)/(HMX-HP)))/(y0-hp)
 
      A4=   LOG(ABS(HM-HPX))/(Y0-HM)
     $+DLOG(abs(1d0-(Y0-HM)/(HPX-HM)))/(y0-hm)
     $     +LOG(ABS(ZAL2  ))/(Y0-HM)
     $+DLOG(abs(1d0-(Y0-HM)/(-ZAL2 )))/(y0-hm)
     $-DLOG(abs(1d0+ZAL2/(Y0-HM)))/(y0-hm)
                          else
 
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(ZAL1  ))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(-ZAL1 ))+DILOGY((Y0-HP)/(-ZAL1 ))
     $-DILOGY(-ZAL1/(Y1-HP))   +DILOGY(-ZAL1/(Y0-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(ZAL2  ))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(-ZAL2 ))+DILOGY((Y0-HM)/(-ZAL2 ))
     $-DILOGY(-ZAL2/(Y1-HM))   +DILOGY(-ZAL2/(Y0-HM))
                          endif
            ENDIF
        ENDIF
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
         ELSE
      IF(HP.EQ.0D0)THEN
         RAL2=1D0+ DSQRT(ABS(ALAM2))/ABS(ALAM1)
         RAL3=1D0+ DSQRT(ABS(ALAM2))/ABS(ALAM1-ALAM2)
         IF(X0.GT.0D0)THEN
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((RAL3 )/(RAL2 )))
     $                             -LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((RAL3 )/(RAL2 )))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(1D0+X0))*LOG(ABS((RAL3 )/(RAL2 )))
CCC  $+DILOGY((HMX-HP)/(Y1-HP))+.5D0*DLOG((1D0+X0)/(Y1-HP))**2-PI*PI/3D0
     $-DILOGY(RAL3/(1D0+X0))   +DILOGY(RAL2   /(1D0+X0))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
         ELSEIF(X0.LT.0D0)THEN
        ZAL1=-(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((RAL3 )/(RAL2 )))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
CWW   A3=  LOG(ABS(1D0+X0))*LOG(ABS((RAL3 )/(RAL2 )))
CCC  $+DILOGY((HPX-HP)/(Y1-HP))+.5D0*DLOG((1D0+X0)/(Y1-HP))**2-PI*PI/3D0
      A3=-DILOGY(1D0/RAL3)     +DILOGY(1D0/RAL2)
     $-DILOGY(RAL3)   +DILOGY((RAL2 ))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((RAL3 )/(RAL2 )))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(ZAL1))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(ZAL1))+DILOGY((Y0-HM)/(ZAL1))
     $-DILOGY(ZAL1/(Y1-HM))  +DILOGY(ZAL1/(Y0-HM))
         ENDIF
       ELSEIF(HM.EQ.0D0)THEN
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c       RAL2=-1D0+DSQRT(ABS(ALAM2))/ABS(ALAM1)
        RAL2=(1d0-dsqrt(1d0-be2))*dsqrt(abs(alam2))/abs(alam1)
        RAL3=-1D0+DSQRT(ABS(ALAM2))/ABS(ALAM1-ALAM2)
         IF(X0.GT.0D0)THEN
        ZAL1= (1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((RAL3 )/(RAL2 ))))
 
      A3=  LOG(ABS(ZAL1  ))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(ZAL1  ))+DILOGY((Y0-HP)/(ZAL1  ))
     $-DILOGY(ZAL1/(Y1-HP))    +DILOGY(ZAL1/(Y0-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((RAL3 )/(RAL2 )))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
CWW  $     +LOG(ABS(1D0-X0))*LOG(ABS((RAL3 )/(RAL2 )))
CCC  $+DILOGY((HMX-HM)/(Y1-HM))+.5D0*DLOG((1-X0)/(Y1-HM))**2+PI*PI/6D0
     $-DILOGY(-RAL3     )      +DILOGY(-RAL2   )
     $-DILOGY(-1D0/RAL3)       +DILOGY(-1D0/RAL2)
           ELSEIF(X0.LT.0D0)THEN
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((RAL3 )/(RAL2 ))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(1D0-X0))*LOG(ABS((RAL3 )/(RAL2 )))
CCC  $+DILOGY((HPX-HM)/(Y1-HM))+.5D0*DLOG((1D0-X0)/(Y1-HM))**2+PI*PI/6D0
     $-DILOGY(RAL3/(-1D0+X0))  +DILOGY( RAL2  /(-1D0+X0))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((RAL3 )/(RAL2 )))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
             ENDIF
        ELSE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
           IF( AMII*X0.LT.0D0)THEN
 
 
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(HP-HPX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HPX-HP))+DILOGY((Y0-HP)/(HPX-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(HM-HMX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HMX-HM))+DILOGY((Y0-HM)/(HMX-HM))
 
             ELSE
          IF(AMII.GT.0D0)THEN
        ZAL1=-(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
        ZAL2=-(1D0-1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
                         ELSE
         ZAL1=(1D0-1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
         ZAL2=(1D0+1D0/DSQRT(1D0+ALAM2*AMI*AMI))/(DSQRT(-ALAM2)*ABS(X0))
                         ENDIF
 
      A2= LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))*(
     $    LOG(ABS((Y1-HP)/(Y0-HP)))-LOG(ABS((Y1-HM)/(Y0-HM))))
 
      A3=  LOG(ABS(ZAL1  ))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(-ZAL1 ))+DILOGY((Y0-HP)/(-ZAL1 ))
     $-DILOGY(-ZAL1/(Y1-HP))   +DILOGY(-ZAL1/(Y0-HP))
     $    +LOG(ABS(HP-HMX))*LOG(ABS((Y1-HP)/(Y0-HP)))
     $-DILOGY((Y1-HP)/(HMX-HP))+DILOGY((Y0-HP)/(HMX-HP))
 
      A4=   LOG(ABS(HM-HPX))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(HPX-HM))+DILOGY((Y0-HM)/(HPX-HM))
     $     +LOG(ABS(ZAL2  ))*LOG(ABS((Y1-HM)/(Y0-HM)))
     $-DILOGY((Y1-HM)/(-ZAL2 ))+DILOGY((Y0-HM)/(-ZAL2 ))
     $-DILOGY(-ZAL2/(Y1-HM))   +DILOGY(-ZAL2/(Y0-HM))
 
             ENDIF
        ENDIF
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            ENDIF
      XI2=-XI1-2D0/    ALAMT*(1D0/(HPMHM))*(A1+A2+A3-A4)
 
      END
 
      FUNCTION XI1(X0,AMI)
*     ******************
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON /COEFF/ETA1,ETA0,ALAM1,ALAM2,Y1,Y0,amit
      ALAMT=-ALAM2
      HPX=1D0/    X0/SQRT(ABS(ALAM2))
     $     +SQRT(ABS(1D0/X0**2/ALAMT       -AMI*AMI))
 
      HMX=1D0/    X0/SQRT(ABS(ALAM2))
     $     -SQRT(ABS(1D0/X0**2/ALAMT       -AMI*AMI))
 
      XI1=1D0/SQRT(ABS(ALAM2))*(
     $  (ETA1-ETA0)*LOG(ABS(-X0*SQRT(ABS(ALAM2))    /2D0))
     $ +(ETA1**2-ETA0**2)/2D0+DILOGY(HPX*EXP(-ETA1))
     $ -DILOGY(HPX*EXP(-ETA0))+DILOGY(HMX*EXP(-ETA1))
     $ -DILOGY(HMX*EXP(-ETA0)))
 
      END
C=======================================================================

      FUNCTION WTStil(CMSEne,ame,amWm,amWp)
*     *************************************
!----------------------------------------------------------------------!
! This FUNCTION provides a weight for corrected real photon infrared   !
! factor S-tilde for the process:                                      !
!              e-(p1) e+(p2)  ---->  W-(q1) W+(q2)                     !
! where radiation from W's is also included.                           !
! INPUT: CMSEne - Energy in the CMS [GeV];                             !
!        ame - electron mass [in GeV];                                 !
!        amWm,amWp - masses of W-,W+ resonances, resp. [in GeV];       !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                 Knoxville, October 1995 !  
! Last update: 13.05.1997                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      COMMON / MOMSET / q1(4),q2(4),phsum(4),phot(100,4),nphot
      SAVE   / KeyOth /,/ MOMSET /
      REAL*8 p1(4),p2(4)
!
      WTstil = 1
      IF (nphot.eq.0) RETURN
      p1(4) = CMSEne/2
      p1(3) = SQRT(p1(4)**2 - ame**2)
      p1(2) = 0
      p1(1) = 0
      p2(4) = p1(4)
      p2(3) =-p1(3)
      p2(2) = 0
      p2(1) = 0
! Scalar products of lepton and W 4-momenta
      p1q1 = p1(4)*q1(4)-p1(3)*q1(3)-p1(2)*q1(2)-p1(1)*q1(1)
      p1p2 = p1(4)*p2(4)-p1(3)*p2(3)-p1(2)*p2(2)-p1(1)*p2(1)
      p1q2 = p1(4)*q2(4)-p1(3)*q2(3)-p1(2)*q2(2)-p1(1)*q2(1)
      q1p2 = q1(4)*p2(4)-q1(3)*p2(3)-q1(2)*p2(2)-q1(1)*p2(1)
      q1q2 = q1(4)*q2(4)-q1(3)*q2(3)-q1(2)*q2(2)-q1(1)*q2(1)
      p2q2 = p2(4)*q2(4)-p2(3)*q2(3)-p2(2)*q2(2)-p2(1)*q2(1)
      wt = 1
      DO i = 1,nphot
! Scalar products of photon 4-momentum with other 4-momenta
        p1k = p1(4)*phot(i,4) -p1(3)*phot(i,3)
     &       -p1(2)*phot(i,2) -p1(1)*phot(i,1)
        q1k = q1(4)*phot(i,4) -q1(3)*phot(i,3)
     &       -q1(2)*phot(i,2) -q1(1)*phot(i,1)
        p2k = p2(4)*phot(i,4) -p2(3)*phot(i,3)
     &       -p2(2)*phot(i,2) -p2(1)*phot(i,1)
        q2k = q2(4)*phot(i,4) -q2(3)*phot(i,3)
     &       -q2(2)*phot(i,2) -q2(1)*phot(i,1) 
! IR factors S-tilde (factor alpha/4pi^2 omitted!)
! Initial state (e-e+)
        sist = 2*p1p2/(p1k*p2k) -(ame/p1k)**2 -(ame/p2k)**2
! Final state (W-W+)
        sfst = 2*q1q2/(q1k*q2k) -(amWm/q1k)**2 -(amWp/q2k)**2
! Interference terms 
        sint = 2*( p1q1/(p1k*q1k) -p1q2/(p1k*q2k) 
     &            -q1p2/(q1k*p2k) +p2q2/(p2k*q2k) )
! weight
        IF (KeyCor.GE.4) THEN
          wt = wt *( 1 + sint/(sist+sfst) )  
        ELSE
          wt = wt *( 1 + (sint+sfst)/sist )
        ENDIF
      ENDDO
      WTStil = wt
      END
      SUBROUTINE  YFSWW_Initialize(xpar)
*     **********************************
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   Compulsory initialization of YFSWW Mote Carlo Generator                //
*//                                                                          //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION  xpar(10000) ! in main program
      COMMON / inout  / ninp,nout     
      DIMENSION  npar( 1000) ! only internal parameter now!
      SAVE   
*//
*/////////////////////////////////////////////////////////////////
*//  Initialization of steering parameters, COMMON blocks, etc. //
*/////////////////////////////////////////////////////////////////
      CALL FILEXP(xpar,npar)
*/////////////////////////////////////////////////////////////////
*//          Compulsory Initialization of GLIBK                 //
*/////////////////////////////////////////////////////////////////
      CALL glimit(50000)
      CALL goutpu(nout)
*/////////////////////////////////////////////////////////////////
*//          Compulsory Initialization of MC generator          //
*////////////  ///////////////////////////////////////////////////
      CALL yfsww3(-1,xpar,npar)
      END

      SUBROUTINE YFSWW_Make
*//////////////////////////////////////////////////////////////////
*//                                                              //
*//   Generation of single Monte Carlo event                     //
*//                                                              //
*//                                                              //
*//////////////////////////////////////////////////////////////////
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION  xpar(10000) ! in main program
      DIMENSION  npar( 1000) ! only internal parameter now!
      SAVE   
*//
      CALL yfsww3( 0,xpar,npar)
      END

      SUBROUTINE YFSWW_Finalize
*//////////////////////////////////////////////////////////////////
*//                                                              //
*//   Final printouts and calculation of the total Xsection      //
*//                                                              //
*//   Final Xsections and statistics available from getters:     //
*//   YFSWW_GetXSecMC(XSecMC,XErrMC)                             //
*//   YFSWW_GetXSecNR(XSecNR,XErrNR)                             //
*//   YFSWW_GetNevMC(NevMC)                                      //
*//                                                              //
*//////////////////////////////////////////////////////////////////
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION  xpar(10000) ! in main program
      DIMENSION  npar( 1000) ! only internal parameter now!
      SAVE   
*//
      CALL yfsww3( 2,xpar,npar)
      END
      
      SUBROUTINE yfsww3(MODE,XPAR,NPAR)
*     *********************************
!=======================================================================
!=======================================================================
!============================= YFSWW3 ==================================
!=======================================================================
!======================= YFS EXPONENTIATION ============================
!======================== IN e+e- --> W+W- =============================
!==================== AND DECAYS W+W- --> 4-fermions ===================
!================= WITH O(ALPHA) EWRC FOR WW-PRODUCTION ================
!=======================================================================
!=======================================================================
!========================= YFSWW3 VERSION 1.16 =========================
!=======================================================================
!============================ JANUARY  2001 ============================
!=======================================================================
!=======================================================================
!= HISTORY: ============================================================
!= 1. YFSWW2 VERSION 1.00, AUGUST 1990 =================================
!= 2. YFSWW2 VERSION 2.xx, AUGUST 1995 -- MAY 1996 =====================
!= 3. YFSWW3 VERSION 1.00, JUNE   1996 =================================
!= 4. YFSWW3 VERSION 1.10, NOV.   1996 =================================
!= 5. YFSWW3 VERSION 1.11, AUG.   1997 =================================
!= 6. YFSWW3 VERSION 1.12, MARCH  1998 =================================
!= 7. YFSWW3 VERSION 1.13, AUGUST 1999 =================================
!= 8. YFSWW3 VERSION 1.14, APRIL  2000 =================================
!= 9. YFSWW3 VERSION 1.15, NOV.   2000 =================================
!=======================================================================
!=======================================================================
! AUTHORS:
!    S. JADACH,   INSTITUTE OF NUCLEAR PHYSICS, CRACOW, POLAND
!    W. PLACZEK,  JAGIELLONIAN UNIVERSITY, CRACOW, POLAND
!    M. SKRZYPEK, INSTITUTE OF NUCLEAR PHYSICS, CRACOW, POLAND
!    B.F.L. WARD, UNIVERSITY OF TENNESSEE, KNOXVILLE, TENNESSEE
!    Z. WAS,      INSTITUTE OF NUCLEAR PHYSICS, CRACOW, POLAND
!=======================================================================
! This program is based on the following papers:
! ----------------------------------------------
! [1] S. Jadach & B.F.L. Ward, Comp. Phys. Commun. 56 (1990) 351.
! [2] S. Jadach & B.F.L. Ward, YFS3 - the source code, unpublished.
! [3] S. Jadach, W. Placzek, M. Skrzypek & B.F.L. Ward, 
!     Phys. Rev. D54 (1996) 5434; UTHEP-95-0801, August 1995.
! [4] S. Jadach, W. Placzek, M. Skrzypek, B.F.L. Ward, Z. Was,
!     Phys. Lett. B417 (1998) 326; UTHEP-96-1101, Nov. 1996.
! [5] S. Jadach, W. Placzek, M. Skrzypek & B.F.L. Ward,  Z. Was,
!     Phys. Rev. D61 (2000) 113010; CERN-TH/99-222; hep-ph/9907436.
! [6] S. Jadach, W. Placzek, M. Skrzypek & B.F.L. Ward,  Z. Was,
!     UTHEP-00-0101, CERN-TH/2000-337; hep-ph/0007012;
!     to be submitted to Phys. Lett. B.
! [7] S. Jadach, W. Placzek, M. Skrzypek, B.F.L. Ward, Z. Was
!     `The Monte Carlo Event Generator YFSWW3 version 1.16
!     for W-Pair Production and Decay at LEP2/LC Energies',
!     CERN-TH/2001-017, UTHEP-01-0101, January 2001;
!     to be submitted to Comput. Phys. Commun.
!======================================================================    
! --------------------
! New in version 1.16:
! --------------------
! 1) Radiation of photons in W deacys into quarks can be activated
!    with the help of the input parameter IFPHOT:
!    IFPHOT =0: PHOTOS off (no radiation in W decays)
!           =1: radiation in leptonic W decays only (recommended)
!           =2: radiation in leptonic and quarkonic W decays (for tests)
! 2) Fixed order, no exponentiation, calculations added in the routine Model:
!    WTSET(65/66/67/68): Born/O(alpha^1)/Born+virtual+soft/1 real hard photon 
! 3) Improvements in the YFS formfactor calculation in the small mass limit
!    (the file: yfsww/yfsfmf.f).
! 4) Some technical improvements in the code, e.g. in the files: rewt_K.f, 
!    filexp.f, model.f, virsof.f
! --------------------
! New in version 1.15:
! --------------------
! 1) Previous approximate option for EW NL corrections replaced by the
!    "fast" version of the exact calculation in which pretabulation of
!    EW NL corrections is made in the initialization mode of the program
!    and then linear interpolation is used in the generation mode.
! 2) In the directory wdeclib there are now two version of PHOTOS: the
!    original one: photos-orig.f with radiation from leptons only (DEFAULT) 
!    and the the new one: photos-quarks.f where photon radiation from quarks 
!    is also switched on (this is mainly for some tests). In order to use
!    it one has to copy one of these files into the file: photos.f 
! 3) ISR option KeyCor=2 is emulated in the "Best" mode, i.e. apprioprate 
!    ISR weights/event are calculated in parallel to "Best" weights/events.
! 4) An interface for re-weighting KoralW or YFSWW3 generated events is added;
!    see directory: rewt
! 5) Some improvements in photon radiation off W's (a new routine Piatek).
! 6) Routine FILEXP moved to the file filexp.f, getter-routines moved
!    to the file ww_get.f 
! 7) Fixed some numerical instabilities spotted on Linux. 
! --------------------
! New in version 1.14:
! --------------------
! 1) Improved treatment of QED versus non-QED corrections for WW-production
!    in the G_mu scheme
! --------------------
! New in version 1.13:
! --------------------
! 1) KoralW-like INPUT
! 2) CC03 crude-level presampler from KoralW
! 3) Born-level CC03 matrix element from KoralW  
!***********************************************************************
! OBSOLETE! OBSOLETE! OBSOLETE! OBSOLETE! OBSOLETE! OBSOLETE! OBSOLETE!
!***********************************************************************
!=======================================================================
!======================== INPUT PARAMETERS =============================     
!=======================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! For the CURRENT INPUT PARAMETERS see: data_files/data_DEFAULTS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! MODE =-1/0/1/2 defines       
!       initialization/generation/give-xsection/final-report  
! npar(1) =KeyCor=0 Born, without any radiative corrections  
!          KeyCor=1 O(alpha^2) LL initial state radiation (ISR) only 
!          KeyCor=2 Above + Coulomb correction  
!          KeyCor=3 Above + complete YFS formfactor for e+e- --> W+W- 
!          KeyCor=4 Above + W+W- state radiation 
!                   (complete YFS formfactor & Coulomb corr. included) 
!          KeyCor=5 Above + exact O(alpha^1) radiative corrections for
!                   e+e- --> W+W- according to Refs. [7,8,9]
!                   (i.e. 1st order exact + 2nd order LL ISR).
!                   NOTE: This option is slow numerically!
!          KeyCor=6 As above but a pretabulation of EW corrections is used 
!                   NOTE: This option is much faster than KeyCor=5 !!!
! npar(2) =KeyDWm   decay channel of W- 
! npar(3) =KeyDWp   decay channel of W+ 
!                 = 1-e, 2-mu, 3-tau 4-ud,  5-cs 
!                   (Only diagonal CKM channels includes in this version!)
! npar(4) =KeyAcc=0,1 Anomalous WWV (V=gamma,Z) couplings OFF/ON  
!               NOTE: Anomalous couplings are included at the Born level only!
! npar(5) =KeyWgt=0,1 unweighted/weighted events 
! npar(21) =Jak1     TAUOLA, tau of W+ decay channel
! npar(22) =Jak2     TAUOLA, tau of W- decay channel
!                =-1    NO tau decays!
!                = 0    INCLUSIVE tau decays (all channels according to BR's)
!                = 1..8 EXCLUSIVE tau decays (e,mu,pi,rho,A1,K,K*,npi)
!                       (see the TAUOLA manual for more details)
! npar(23) =Itdkrc =0/1 TAUOLA, radiative corr. in leponic tau decays switch
! napr(24) =IfPhot =0/1 PHOTOS, activation switch (OFF/ON)
! npar(25) =IfHadm =0/1 JETSET, W- hadronization activation switch (OFF/ON)
! npar(26) =IfHadp =0/1 JETSET, W+ hadronization activation switch (OFF/ON)
!                       In the current version, for hadronic W-decays both 
!                       IfHadm, IfHadp should be =0 or =1.
! Note: Switching ON tau decays and/or hadronization is recommended for
!       unweighted events, i.e. KeyWgt=0.
!----------------------------------------------------------------- 
! xpar( 1) =CMSEne  =  CMS energy 
! xpar( 2) =amaZ    =  mass of Z  
! xpar( 3) =GammZ   =  width of Z 
! xpar( 4) =amaW    =  mass of W
! xpar( 5) =GammW   =  width of W  
! xpar( 6) =sinW2   =  sin^2(theta_Weinberg) 
! xpar( 7) =alfWin  =  1/alpha_W, where alpha_W is alpha QED at WW scale
! xpar( 8) =vvmin   =  minimum v-variable (dimesionless) =epsilon 
! xpar( 9) =vvmax   =  maximum v-variable   
! xpar(10) =WTMAX   =  maximum weight for rejection (unweighted events)
! xpar(21) - xpar(57) = values of anomalous WWV couplings
!   (convention of K. Hagiwara, R.D. Peccei, D. Zeppenfeld and K. Hikasa, 
!                  Nucl. Phys. B282 (1987) 253):
!         g1(1)   = DCMPLX(xpar(21),xpar(31))
!         kap(1)  = DCMPLX(xpar(22),xpar(32))
!         lam(1)  = DCMPLX(xpar(23),xpar(33))
!         g4(1)   = DCMPLX(xpar(24),xpar(34))
!         g5(1)   = DCMPLX(xpar(25),xpar(35))
!         kapt(1) = DCMPLX(xpar(26),xpar(36))
!         lamt(1) = DCMPLX(xpar(27),xpar(37))
!         ---------
!         g1(2)   = DCMPLX(xpar(41),xpar(51))
!         kap(2)  = DCMPLX(xpar(42),xpar(52))
!         lam(2)  = DCMPLX(xpar(43),xpar(53))
!         g4(2)   = DCMPLX(xpar(44),xpar(54))
!         g5(2)   = DCMPLX(xpar(45),xpar(55))
!         kapt(2) = DCMPLX(xpar(46),xpar(56))
!         lamt(2) = DCMPLX(xpar(47),xpar(57))
! where                                                         (SM value)
!
!   g1(1)  : g_1^g, anomalous coupling for WWg vertex            (1.0,0.0)
!   kap(1) : kappa_g, anomalous coupling for WWg vertex          (1.0,0.0)
!   lam(1) : lambda_g, anomalous coupling for WWg vertex         (0.0,0.0)
!   g4(1)  : g_4^g, anomalous coupling for WWg vertex            (0.0,0.0)
!   g5(1)  : g_5^g, anomalous coupling for WWg vertex            (0.0,0.0)
!   kapt(1): kappa-tilde_g, anomalous coupling for WWg vertex    (0.0,0.0)
!   lamt(1): lambda-tilde_g, anomalous coupling for WWg vertex   (0.0,0.0)
!-------
!   g1(2)  : g_1^Z, anomalous coupling for WWZ vertex            (1.0,0.0)
!   kap(2) : kappa_Z, anomalous coupling for WWZ vertex          (1.0,0.0)
!   lam(2) : lambda_Z, anomalous coupling for WWZ vertex         (0.0,0.0) 
!   g4(2)  : g_4^Z, anomalous coupling for WWZ vertex            (0.0,0.0)
!   g5(2)  : g_5^Z, anomalous coupling for WWZ vertex            (0.0,0.0)
!   kapt(2): kappa-tilde_Z, anomalous coupling for WWZ vertex    (0.0,0.0)
!   lamt(2): lambda-tilde_Z, anomalous coupling for WWZ vertex   (0.0,0.0)
!
! Other inputs in subroutine FILEXP.
!
!***********************************************************************
!                        END OF OBSOLETE! 
!***********************************************************************
!
!********************** OUTPUT *******************************************  
!
! Four-momenta and flavours of all particles in standard COMMON hepevt:
!
!      PARAMETER (NMXHEP=2000)
!      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
!     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
!
! They are also in:
!      COMMON / MOMSET / Q1(4),Q2(4),PHSUM(4),PHOT(100,4),NPHOT
! where Q1, Q2 are 4-momenta of W-, W+, resp., PHSUM is a sum of
! photon 4-momenta, while PHOT is an array of foton 4-momenta
! for NPHOT photon multiplicity. 
! The 4-momenta of WW-decay products can be found in:
!      COMMON / MOMDEC / PF1(4),PF2(4),PF3(4),PF4(4),PHOT(100,4),NPHOT 
! where PF1, PF2 are 4-momenta of W- decay products, and PF3, PF4 are
! ones of W+ decay products (PHOT and NPHOT as above).
!
! For KeyWgt=1 weighted events are generated and the user should   
! use the weight WTMOD from the common block:               
!     COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)
! WTMOD is the actual model weight depending on the input parameters.       
! A lot of parallel weights calculated during a run of the program   
! can be found in WTSET(100), see routine Model for details
! (file: model.f).
!
! The total cross section, its relative error, the number of generated 
! events are provided in a post-generation mode (MODE=1,2) through:
! xpar(10)=XSECPB = cross section in picobarns        
! xpar(11)=ERREL  = relative error (dimensionless)  
! xpar(12)=XSMC   = cross section in R-units   
! npar(10)=NEVGEN = number of generated events      
!----------------------------------------------------------------------
! Last update: 29.01.2001              by: W.P.   
!======================================================================
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / INOUT  / NINP,NOUT
      DIMENSION  XPAR(*),NPAR(*)
!
      IF(MODE.EQ.-1) 
     $WRITE(NOUT,6900)
     $'  *************************************************************',
     $'  *  ###   ### ########  ######  ###   ### ###   ###   #####  *',
     $'  *  ###   ### ######## ######## ###   ### ###   ###  ####### *',
     $'  *   ### ###  ###      ####     ###   ### ###   ###      ### *',
     $'  *     ###    ######     ####   ###   ### ###   ###    ###   *',
     $'  *     ###    ######       #### ### # ### ### # ###      ### *',
     $'  *     ###    ###      ######## #### #### #### ####  ####### *',
     $'  *     ###    ###       ######  ###   ### ###   ###   #####  *',
     $'  *************************************************************',
     $' '
 6900 FORMAT('1',10(/,10X,A))
      CALL EXPAND(MODE,XPAR,NPAR)
      END

      SUBROUTINE EXPAND(MODE,XPAR,NPAR)     
C     ****************************************     
C  !!!!! LOGBOOK OF CORRECTIONS starting Nov. 91 !!!!!
C  R1 and R2 in KINEKR undefined
C  BREMKF, VVDIST moved to yfs3mod.f
C  VVDIST replaced with VVRHO from YFSFIG
C  VESK8A replaced by VESK1W
C  FUNSKO replaced by RHOSKO (change of name)
C  GAUSS replaced by GAUSJD
C  CMSENE shiftet to XPAR !!! 3 first entries in XPAR changed
C  CHBIN2 replaced by CHBIN1
C  XPAR(10,12) in output are swapped (to bhlumi convention)
*  Initialization of GLIBK in the generator
*  Bug with parameter(pi=...) corrected
C=======================================================================
C=======================================================================
C=============================YFS3======================================
C=====================FERMION PAIR PRODUCTION===========================
C===============INITIAL AND FINAL STATE EXPONENTIATION==================
C=======================================================================
C=======================================================================
C=======================YFS VERSION 3.3.0===============================
C=======================================================================
C=========================FEBRUARY  1993================================
C=======================================================================
C AUTHORS: 
C    S. JADACH, JAGELLONIAN UNIVERSITY, CRACOW, POLAND      
C    B.F.L. WARD, UNIVERSITY OF TENNESSEE, KNOXVILLE, TENNESSEE        
C=======================================================================
C  Adapted for W-pair production by Wieslaw Placzek,   June 1996
C  Last update: 26.11.2000         by: W.P.
C=======================================================================
C          
C SOME CONTROL HISTOGRAMMING STILL IN PROGRAM      
C          
C generator of Yennie-Fautschi-Suura type         
C with exponentiated single bremsstrahlung         
C********* input    
C mode =-1/0/1/2 defines       
C       initialization/generation/give-xsection/final-report  
C cmsene   = centre of mass energy (gev)  
C npar(1)=keyrad=1000001 initial state only        
C         keyrad=1000010 final state only          
C         keyrad=1000011 initial + final state     
C         keyrad=1000000 born without any bremss.  
C         keyrad=100n001 fixed initial state multiplicity (tests)      
C         keyrad=10k0010 fixed final   state multiplicity (tests)      
C npar(2)=keyred=0,1,2   three different reduction procedures          
C npar(3)=keywgt=0,1   unweighted/weighted events  
C xpar(1)=cmsene  =  mass of z0  
C xpar(2)=amaz    =  mass of z0  
C xpar(3)=sinw2   =  sin(thetaweinberg)**2  
C xpar(4)=gammz   =  width of z0 
C xpar(5)=amfin   =  mass of final fermion  
C xpar(6)=vvmin   =  minimum v-variable (dimesionless) =epsilon 
C xpar(7)=vvmax   =  maximum v-variable   
C********* output   
C Four-momenta of and photon multiplicity in /momset/  
C xpar(10)=xsecnb = cross section in nanobarns        
C xpar(11)=errel  = relative error (dimensionless)  
C xpar(12)=xsmc   = cross section in r-units   
C npar(10)=nevacc = number of generated events      
C**************************    
C For advanced users only:     
C (1) One may use KEYRAD < 0  for running at fixed v-variable,         
C in this case all events have  v=VMAX precisely.  
C (2) For KEYWGT=1 weighted events are generated and the user should   
C use the weight WTMOD from the common block /WGTALL/.      
C WTMOD is the actual model weight depending on other input params.    
C The other interesting possibility is to use      
C     WT=WTCRU1*WTCRU2*WTSET(i) where   
C     WTSET(71) =   zero-th order initial+final    
C     WTSET(72) =   first order   initial+final    
C     WTSET(73) =   second order  initial+final    
C and the following provide the corresponding components of x-section. 
C     WTSET(80) =   First order, beta0 contribution alone   
C     WTSET(81) =   First order, beta1 contribution alone   
C     WTSET(90) =   Second order, beta0 contribution alone  
C     WTSET(91) =   Second order, beta1 contribution alone  
C     WTSET(92) =   Second order, beta2 contribution alone  
C furthermore, for the initial state alone we provide       
C     WTSET( 1) =   zero-th order initial          
C     WTSET( 2) =   first order   initial          
C     WTSET( 3) =   second order  initial          
C and the corresponding components      
C     WTSET(20) =   First order, beta0 contribution alone   
C     WTSET(21) =   First order, beta1 contribution alone   
C     WTSET(30) =   Second order, beta0 contribution alone  
C     WTSET(31) =   Second order, beta1 contribution alone  
C     WTSET(32) =   Second order, beta2 contribution alone  
C N.B. WTMOD=WTCRU1*WTCRU2*WTSET(71)    
C     ************************ 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)          
      PARAMETER(PI=3.1415926535897932D0) 
      DIMENSION  XPAR( *),NPAR( *)      
      COMMON / PHYPAR / ALFINV,GPICOB  
      COMMON / MOMSET / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT      
      COMMON / MOMINI / XF1(4),XF2(4),XPHUM(4),XPHOT(100,4),NPHOX      
      COMMON / MOMFIN / YF1(4),YF2(4),YPHUM(4),YPHOT(100,4),NPHOY      
      COMMON / cms_eff_momdec /
     $      effbeam1(4),effbeam2(4),effp1(4),effp2(4),effp3(4),effp4(4)
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)      
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT
! This common can be everywhere, contains various switches
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
cav   COMMON / LIBRA  / JAK1,JAK2,ITDKRC,IFPHOT,IFHADM,IFHADP
      COMMON / INOUT  / NINP,NOUT   
      COMMON / BXFMTS / BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G 
      CHARACTER*80      BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G 
      DIMENSION XXF(4)
      SAVE   / MOMSET /,/ MOMINI /,/ MOMFIN /,/ WEKING /
      SAVE   / WGTALL /,/ KEYYFS /,/ INOUT  /,/ BXFMTS /
cav   SAVE   / WEKIN2 /,/ KeyOth /,/ LIBRA  /,/ cms_eff_momdec /
      SAVE   / WEKIN2 /,/ KeyOth /,/ cms_eff_momdec / !cav
      SAVE   NEVGEN,KEYBIN,KEYBFI,CMSENE
      SAVE   IDGEN, IDYFS, WTMAX
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI
      SAVE   / VVREC  /
! This common stores final x-section, crude x-section, their absolute errors,
! total number of generated events and generator ID 
      COMMON / GenFin / Xsecpb,Errsec,Xscrud,Errcru,NevTot,IdGene
      SAVE   / GenFin /
! Switch for matching YFS FormFactor with Coulomb correction
      COMMON / Coutra / KeyCou      
      SAVE   / Coutra /
      DOUBLE PRECISION P1(4),P2(4)
      DOUBLE PRECISION DRVEC(100)
! Single precision parameter for TAUOLA
      REAL pol(4)
      SAVE
!
      IF(MODE.EQ.-1) THEN      
C     ==================================================================
C     =====================INITIALIZATION===============================
C     ==================================================================

!6900 FORMAT('1',10(/,10X,A)) 
!     WRITE(NOUT,6900)  
!    $'  *************************************************************',
!    $'  *  ****   ****  **********    *******          ***********  *',
!    $'  *  ****   ****  **********  **********         **********   *',
!    $'  *   **** ****   ****        *****                 ******    *',
!    $'  *    ******     ********      ******    *****    ******     *',
!    $'  *     ****      ********         *****  *****      ******   *',
!    $'  *     ****      ****        **********         ***********  *',
!    $'  *     ****      ****         *******           **********   *',
!    $'  *************************************************************',
!    $' '   

!WP* ==========================================================
!WP* Initialization of internal histogramming package GLIBK
!WP* Let us keep for YFS3 the GLIBK ID-ent range from 2 to 1000 
!WP* ==========================================================
!WP: moved to YFSWW_Initialize
!WP      CALL GLIMIT(20000)
!WP      CALL GOUTPU(NOUT)  
!WP      CALL FILEXP(XPAR,NPAR)
      CMSENE = 2D0*ENE
      SVAR   = CMSENE**2
      WTMAX  = XPAR(10)
      KEYBIN = MOD(KEYBRM,10)   
      KEYBFI = MOD(KEYBRM,100)/10       
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
! Generator's ID
!WP      IDGEN = 7 + KEYBIN
      IDGEN = 8
!WP: Store it in common / GenFin /
      IdGene = IDGEN
! Important histo which remembers total x-section
      CALL GMONIT(  -1, IDGEN,1d0,1d0,1d0)
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
      IDYFS = 0
!WP      CALL GBOOK1(IDYFS +5,'WT EXPAND  NPHOT.NE.0  $', 60 ,-1D0, 5D0)
!WP      CALL GBOOK1(IDYFS+11,'PHOTON MULTIPLICITY    $', 50,  0D0,50D0)
C GMONIT MONITORS WEIGHTS       
!WP      CALL GMONIT(-1,IDYFS+71,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+72,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+73,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+74,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+75,0D0,1D0,1D0) 
      CALL GMONIT(-1,IDYFS+76,0D0,1D0,1D0) 
      CALL GMONIT(-1,IDYFS+77,0D0,1D0,1D0)    
      CALL GMONIT(-1,IDYFS+78,0D0,1D0,1D0)  
      CALL GMONIT(-1,IDYFS+79,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+80,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+81,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+90,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+91,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+92,0D0,1D0,1D0)  
      IF(KEYBIN.EQ.1) THEN
         CALL KarLud(-1,XCRUD,DUMM)
         XCRUPB = XCRUD
      ELSE
         XCRUD  = BORNY(SVAR,SVAR)
         XCRUPB = XCRUD
      ENDIF
      IF(KEYBFI.EQ.1) CALL KarFin(-1, XXF,DUMM1,DUMM2,DUMM3,DUMM4)     
      PAR1 = IDYFS
      PAR2 = XCRUD
      CALL  Model(-1,PAR1,PAR2) 
      NEVGEN=0 
cccccccccccccccccccccccccccccccccc
cccccccccccccccccccccccccccccccccc
*  Initialization of TAUOLA, PHOTOS, etc.
cav   WRITE(6,*) '>>>>>>>> Initialization TAUOLA, PHOTOS, etc.'
cav   CALL  inietc(Jak1,Jak2,Itdkrc,IfPhot)
cav   CALL  inimas
cav   CALL  iniphx(0.01d0)
cav   CALL  initdk
cav   CALL  phoini
cav   IF (IfPhot.GE.1) THEN
C Routine IPHQRK switches OFF/ON (IFPHOT=1/2) PHOTOS radiation from quarks 
cav      IDUM= IPHQRK(IfPhot)
cav   ENDIF

cccccccccccccccccccccccccccccccccc
     
      ELSEIF(MODE.EQ.0) THEN    
C     ==================================================================
C     =====================GENERATION===================================
C     ==================================================================
      NEVGEN=NEVGEN+1   
 100  CONTINUE      
C ===================   
!WP: Generate W-decay channels in an inclusive mode
      IF (KeyDwm*KeyDwp.EQ.0) CALL ChaPik
C ...Initial state YFS2 type generator  
      IF(KEYBIN.EQ.1) THEN   
         CALL KarLud( 0,WTKARL,DUM2)     
      ELSE       
!WP          CALL GIBEA(CMSENE,AMFIN,XF1,XF2)        
!WP          CALL KINEKR
!WP: CC03 Presampler
         CALL WW_Presam(WT_PS)
!WP: Photon spectrum weight
         WT_BS  = WtShape(SVAR,SVAR) 
         WTKARL = WT_PS * WT_BS       
         NPHOX  = 0  
      ENDIF      
! Sum of "effective" beams 4-momenta (after ISR) 
      DO K = 1,4    
         XXF(K) = XF1(K) + XF2(K)  
      ENDDO
      sprim =  XXF(4)**2 - XXF(3)**2 - XXF(2)**2 - XXF(1)**2
!WP: Masses of W-resonances and some auxiliary (dummy) mass
      s1 = xf1(4)**2 -xf1(3)**2 -xf1(2)**2 -xf1(1)**2
      s2 = xf2(4)**2 -xf2(3)**2 -xf2(2)**2 -xf2(1)**2
      amWm = SQRT(s1) 
      amWp = SQRT(s2) 
!WP         amW0 = (amWm+amWp)/2 
      amW0 = DMIN1(amWm,amWp)
C ===================   
C ...Final state momenta in the Z frame     
      IF(KEYBFI.EQ.1 .AND. WTKARL.NE.0D0) THEN   
!WP            CALL KarFin(0, XXF,AMFIN,WTCFIN)
         CALL KarFin(0, XXF,amW0,amWm,amWp,WTCFIN)
      ELSE       
C ...No final state bremss, fermion momenta defined in Z frame  
!WP            CALL KINF2( XXF,AMFIN,YF1,YF2)  
         DO K = 1,4
            YF1(K) = XF1(K)
            YF2(K) = XF2(K)
            XXF(K) = YF1(K) + YF2(K)
         ENDDO
!
         WTCFIN = 1D0        
         NPHOY  = 0  
      ENDIF      
C ...Merging momenta and transform to CMS frame     
      CALL MERGIF 
      WTCRU1 = WTKARL *(1d0 - VV) 
      WTCRU2 = WTCFIN       
      WTCRUD = WTCRU1*WTCRU2
! Kinematics of W+W- decays
      CALL KinDec    
C =================== All kinematics is fixed at this point =======     
*--- Some YFS form-factor and S-factors weights
      WtYIn = 1d0
      WtYFi = 1d0
      WtIFi = 1d0
      WtCis = 1d0
      WtCbe = 1d0
      IF (WTCRU1.NE.0d0 .AND. KeyCor.GT.0) THEN
! YFS Form-Factor weight (correcting for missing non-IR parts)
         CALL GIBEA(CMSENE,AMEL,P1,P2)        
         CALL GIFYFS(P1,P2,WtYIn)
! Weight of Coulomb effect for ISR-type result
         KeyCou = 1
         IF (KeyCor.GE.2) WtCis = WTCoul(sprim,s1,s2,amaW,GammW)
         IF (WTCRUD.NE.0D0 .AND. KeyCor.GE.3) THEN
! YFS Form-Factor weight for WW-state radiation
            IF (KeyCor.GE.4) CALL Yfirem(QF1,QF2,WtYFi)
! Weight correcting for I-F interferences in YFS formfactor and S-factors
            WtIFi = WtStYf(CMSENE,AMEL,amWm,amWp,VVMIN)
! Weight of Coulomb effect
            WtCbe = WTCoul(sprim,s1,s2,amaW,GammW)/WtCis
         ENDIF
      ENDIF
      WTCRU1 = WTCRU1*WtYIn*WtCis
      WTCRU2 = WTCRU2*WtYFi*WtIFi*WtCbe
      WTCRUD = WTCRU1*WTCRU2
C ...Model weight  
      CALL Model(0,WTCRUD,WTMDL)
!---------------------------------------------------------------------
! ...Principal model weight for WT=1 events (after rejection)   
      WT     = WTCRUD*WTMDL 
C ...Weigt monitoring   
!WP         CALL GMONIT(0,IDYFS+73,WTCRUD*WTSET(73),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+72,WTCRUD*WTSET(72),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+71,WTCRUD*WTSET(71),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+75,WTCRUD*(WTSET(73)-WTSET(72)),WTMAX,0D0)
!WP         CALL GMONIT(0,IDYFS+74,WTCRUD*(WTSET(72)-WTSET(71)),WTMAX,0D0)
!WP         CALL GMONIT(0,IDYFS+80,WTCRUD*WTSET(80),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+81,WTCRUD*WTSET(81),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+90,WTCRUD*WTSET(90),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+91,WTCRUD*WTSET(91),WTMAX,0D0)       
!WP         CALL GMONIT(0,IDYFS+92,WTCRUD*WTSET(92),WTMAX,0D0)
!WP: Monitoring WT>WTMAX and WT<0 
      WTOVR = MAX(0D0,WT-WTMAX) 
      CALL GMONIT(0,IDYFS+76,WTOVR,0D0,0D0)
      WTNEG = MIN(WT,0D0)
      CALL GMONIT(0,IDYFS+77,WTNEG,0D0,0D0)  
C ...test histograms    
!WP         XMULT=FLOAT(NPHOT)+.1D0        
!WP         CALL GF1(IDYFS+11,XMULT,1D0)  
!WP         IF(NPHOT.GE.0) CALL GF1(IDYFS+5,WT,1D0)
C ...Rejection according to principal weight  
      IF(KEYWGT.EQ.0) THEN    
C ...unweihgted events with WT=1 
         CALL GMONIT(0,IDGEN,XCRUPB*WTMAX,WTMAX,1d0)
         CALL VARRAN(DRVEC,1)
         RN = DRVEC(1)
         CALL GMONIT(0,IDYFS+79,WT ,WTMAX,RN)
         IF(RN.GT.WT/WTMAX) GOTO 100       
         WTMOD=1.D0    
C ...WTCRU1,2  weights are RESET to one 
         WTCRU1=1D0    
         WTCRU2=1D0    
      ELSE       
C ...weighted events      
         WTMOD  = WT 
         CALL GMONIT(0,IDGEN,XCRUPB,WTMAX,1d0)
         CALL GMONIT(0,IDYFS+79,WT     ,WTMAX,0D0)      
         CALL GMONIT(0,IDYFS+78,WTCRUD ,WTMAX,0D0)      
      ENDIF 
* ccccccccccccccccccccccccccccccccc
      IF (WTCRUD.NE.0d0) THEN
* ccccccccccccccccccccccccccccccccc
* TOHEP sets into HEPEVT all generated particles.
* It decays taus and generates bremsstrahlung in tau and W decays.
cav      CALL TOHEP
* And TOHAD moves to LUND format. It hadronizes whatever requires.
cav      CALL TOHAD(IfHadm,IfHadp,0d0)
      ELSE
* Some routine to set HEPEVT to 0 should be here <<<<<============
        CONTINUE
* ccccccccccccccccccccccccccccccccc
      ENDIF
* ccccccccccccccccccccccccccccccccc
         
      ELSEIF(MODE.EQ.1.OR.MODE.EQ.2) THEN     
C     ==================================================================
C     =====================FINAL WEIGHT ANALYSIS========================
C     ==================================================================
      NPAR(10)= NEVGEN  
      NPAR(20)= NEVGEN   
      SIG0PB =  4D0*PI/(ALFINV**2*3D0*CMSENE**2)*GPICOB     
      XBORPB =  BORNY(SVAR,SVAR) 
      IF(KEYBIN.EQ.1) THEN       
         CALL KarLud(MODE,XKARL,ERKARL)       
      ELSE   
         XKARL  = BORNY(SVAR,SVAR)      
         ERKARL = 0D0     
      ENDIF  
      IF(KEYBFI.EQ.1) CALL KarFin(MODE,XXF,DUMM1,DUMM2,DUMM3,DUMM4)     
C     
      CALL GMONIT(1,IDYFS+79,AWTOT,DWTOT,XNTOT)     
      NPAR(10)= NEVGEN  
      AWTER = AWTOT*DWTOT
!WP      XSMC   =  XKARL*AVERWT     
!WP      EREL   =  SQRT(ERKARL**2+ERRELA**2)     
!WP      ERABS  =  XSMC*EREL        
!WP      XSMCPB =  XSMC*SIG0PB      
!WP      ERABS2 =  XSMCPB*EREL  
!WP: Different normalization of WW Born x-section 
      XSMCPB =  XKARL*AWTOT
      EREL   =  SQRT(ERKARL**2+DWTOT**2) 
      ERABS2 =  XSMCPB*EREL 
      XSMC   =  XSMCPB/SIG0PB 
      ERABS  =  XSMC*EREL 
!WP:  Store number od events and x-sections in COMMON block / GenFin /
      NevTot = NEVGEN
      Xsecpb = XSMCPB
      Errsec = ERABS2
! Normalization x-section, e.g. for histograms
      IF (KeyWgt.EQ.1) THEN
! ... Weighted events: crude x-section
         Xscrud = XKARL
         Errcru = Xscrud*ERKARL
      ELSE
! ... Un-Weighted events: exact x-section
         Xscrud = Xsecpb
         Errcru = Errsec
      ENDIF
!
      NEVT = XNTOT
      CALL GMONIT(2,IDYFS+79,XNACC,XNNEG,XNOVE) 
      NEVA = XNACC
      NEVN = XNNEG
      NEVO = XNOVE
!        
      XPAR(10) = XSMCPB
      XPAR(11) = EREL      
      XPAR(12) = XSMC 
! Crude x-section
      XPAR(20) = XKARL 
!WP: x-sections for WT>WTMAX and WT<0 
      CALL GMONIT(1,IDYFS+76,AWT76,DWT76,DUMM3)
      xsove = AWT76/AWTOT
      dsove = xsove*DWT76
      CALL GMONIT(1,IDYFS+77,AWT77,DWT77,DUMM3)
      xsneg = AWT77/AWTOT
      dsneg = xsneg*DWT77
      IF(KEYWGT.EQ.0) THEN              
C ...Un-weighted events, normal option     
         XPAR(20)=XSMCPB            
         XPAR(21)=EREL                  
         XPAR(22)=XSMC
      ELSE          
C ...Weighted events, additional information on x-sections  
         CALL GMONIT(1,IDYFS+78,AWT78,DWT78,DUMM3)     
!WP         XPAR(20)= XKARL*SIG0PB     
         XPAR(20)= XKARL
         XPAR(21)= DWT78               
!WP         XPAR(22)= XKARL   
         XPAR(22)= XKARL /SIG0PB  
      ENDIF         
C NO PRINTOUT FOR MODE =1               
      IF(MODE.EQ.1) RETURN              
* ccccccccccccccccccccccccccccccccc
*     Final printouts of TAUOLA
      IF(KEYWGT.EQ.0) THEN
cav     CALL dexay(100,pol)
      ENDIF
* ccccccccccccccccccccccccccccccccc

!WP    CALL GPRINT(IDYFS+11)                 
!WP    CALL GPRINT(IDYFS+ 5)                 
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) '         YFSWW3  Final  Report '
      WRITE(NOUT,BXTXT) '               Window A        '
      WRITE(NOUT,BXTXT) '                               '
      WRITE(NOUT,BXL1F) CMSENE,       'CMS energy total  ','CMSENE','A0'
      WRITE(NOUT,BXL2F) XSMCPB,ERABS2,'xs_tot [pb]       ','XSMCPB','A1'
      WRITE(NOUT,BXL1F) EREL,         'relative error    ','EREL  ','A2'
      WRITE(NOUT,BXL1I) NEVT,         'total no of events','NEVTOT','A3'
      WRITE(NOUT,BXL1I) NEVA,         'accepted    events','NEVACC','A4'
      WRITE(NOUT,BXL1I) NEVN,         'WT<0        events','NEVNEG','A5'
      WRITE(NOUT,BXL2F) xsneg,dsneg,  'xsec/xtot: WT<0   ','XSNEG ','A6'
      WRITE(NOUT,BXL1I) NEVO,         'WT>WTMAX    events','NEVOVE','A7'
      WRITE(NOUT,BXL2F) xsove,dsove,  'xsec/xtot:WT>WTMAX','XSOVE ','A8'
      WRITE(NOUT,BXL1F) WTMAX ,       'WTMAX             ','WTMAX ','A9'
      WRITE(NOUT,BXL2F) AWTOT,AWTER, '    <WT>          ','AWTOT ','A10'
      IF (KeyCor.EQ.0)
     &WRITE(NOUT,BXL1F) XBORPB,      'xs_Born_crude [pb]','XBORPB','A11'
      WRITE(NOUT,BXCLO)         
C     ==================================================================
C     =============SUPPL. FINAL WEIGHT ANALYSIS=========================
C     ==================================================================
!WP      WRITE(NOUT,BXOPE)                 
!WP      WRITE(NOUT,BXTXT) '        EXPAND output - window B ' 
!WP      WRITE(NOUT,BXTXT) '           X-sections in pb   ' 
!WP      CALL GMONIT(1,IDYFS+73,AVERWT,ERRELA,DUMM3)                   
!WP      XS03   =  XKARL*AVERWT            
!WP      DXS03  =  XKARL*AVERWT*SQRT(ERKARL**2+ERRELA**2)      
!WP      CALL GMONIT(1,IDYFS+72,AVERWT,ERRELA,DUMM3)                   
!WP      XS02   =  XKARL*AVERWT            
!WP      DXS02  =  XKARL*AVERWT*SQRT(ERKARL**2+ERRELA**2)      
!WP      CALL GMONIT(1,IDYFS+71,AVERWT,ERRELA,DUMM3)                   
!WP      XS01   =  XKARL*AVERWT            
!WP      DXS01  =  XKARL*AVERWT*SQRT(ERKARL**2+ERRELA**2)      
!WP      CALL GMONIT(1,IDYFS+75,AVERWT,ERRELA,DUMM3)                   
!WP      XS05   =  XKARL*AVERWT            
!WP      DXS05  =  XKARL*AVERWT*SQRT(ERKARL**2+ERRELA**2)      
!WP      CALL GMONIT(1,IDYFS+74,AVERWT,ERRELA,DUMM3)                   
!WP      XS04   =  XKARL*AVERWT            
!WP      DXS04  =  XKARL*AVERWT*SQRT(ERKARL**2+ERRELA**2)      
!WP      WRITE(NOUT,BXL2F) XS03,DXS03,'X-section','O(alf2)',  'B1'
!WP      WRITE(NOUT,BXL2F) XS02,DXS02,'X-section','O(alf1)',  'B2'
!WP      WRITE(NOUT,BXL2F) XS01,DXS01,'X-section','O(alf0)',  'B3'
!WP      IF(XS02.NE.0D0) WRITE(NOUT,BXL2F)                     
!WP     $ XS05/XS02,DXS05/XS02,'(O(alf2)-O(alf1))','/O(alf1)','B4'
!WP      IF(XS01.NE.0D0) WRITE(NOUT,BXL2F)                     
!WP     $ XS04/XS01,DXS04/XS01,'(O(alf1)-O(alf0))','/O(alf0)','B5'
!WP      WRITE(NOUT,BXCLO)                 
C -------------     
      WTCRU1 = XKARL                    
      WTCRU2 = ERKARL                   
      CALL  Model(MODE,DUMM1,DUMM2)     
C -------------     
      ELSE          
C     ====          
      WRITE(NOUT,*) '===>EXPAND: WRONG MODE'                
      STOP          
      ENDIF         
C     =====         
      END
                 
      SUBROUTINE MERGIF   
C     *****************   
C Merging two commons all photons together  
C Transformation to common (CMS) trame is supposed to be already done  
C     ************************************  
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      COMMON / MOMSET / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT  
      COMMON / MOMINI / XF1(4),XF2(4),XPHUM(4),XPHOT(100,4),NPHOX 
      COMMON / MOMFIN / YF1(4),YF2(4),YPHUM(4),YPHOT(100,4),NPHOY 
C ...Photons              
      NPHOT  = 0          
      DO 130 I=1,NPHOX    
        NPHOT  =NPHOT+1   
        DO 130 K=1,4      
  130   SPHOT(NPHOT,K)=XPHOT(I,K)           
      DO 140 I=1,NPHOY    
        NPHOT  =NPHOT+1   
        DO 140 K=1,4      
  140   SPHOT(NPHOT,K)=YPHOT(I,K)           
C ...Final state fermions                   
      DO 145 K=1,4        
        QF1(K)= YF1(K)    
  145   QF2(K)= YF2(K)    
C ...Axiliary             
      DO 150 K=1,4        
  150    SPHUM(K)= XPHUM(K)+YPHUM(K)        
      END 
                
      SUBROUTINE ChaPik   
*     *****************   
!----------------------------------------------------------------------!
! Generate W-decay channel in an inclusive mode.                       !
! Written by: Wieslaw Placzek,                       CERN, August 1999 !
! Last update: 18.08.1999       by: WP                                 !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      COMMON / BrCumF / BrCum(20)
      SAVE   / BrCumF /
      DOUBLE PRECISION DRVEC(100)
!
      CALL VARRAN(DRVEC,2)
      rm = DRVEC(1)
      rp = DRVEC(2)
! Pick W- decay channel
      icwm = 9
      DO i = 1,9
         IF (BrCum(i).GE.rm) THEN
            icwm = i
            GOTO 10
         ENDIF
      ENDDO
 10   CONTINUE
! Pick W- decay channel
      icwp = 9
      DO j = 1,9
         IF (BrCum(j).GE.rp) THEN
            icwp = j
            GOTO 20
         ENDIF
      ENDDO
 20   CONTINUE
! Codes and masses of final state fermions 
      CALL FsfCodes(icwm,icwp)
      END

      SUBROUTINE FsfCodes(icwm,icwp)   
*     ******************************   
!----------------------------------------------------------------------!
! Codes and masses of the final state fermions.                        !
! INPUT: icwm,icwp -- W- and W+ decay channels                         !
! Written by: Wieslaw Placzek,                     Cracow, March 1996  !
! Last update: 10.08.1999       by: WP                                 !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      COMMON / DECDAT / AMAFIN(20), BR(20) 
      COMMON / DECCOD / ICOD(20)
      COMMON / DECAYS / IFLAV(4),AMDEC(4)
      COMMON / DeChan / IchaWm,IchaWp
      SAVE   / DECDAT /, / DECCOD /, / DECAYS /, / DeChan /
      DATA Init /0/
      SAVE Init
!
      IF (Init.EQ.0) THEN
         Init = 1
!... Codes for W decay channels
         icod(1)= 102           ! d,u
         icod(2)= 104           ! d,c
         icod(3)= 302           ! s,u
         icod(4)= 304           ! s,c
         icod(5)= 502           ! b,u
         icod(6)= 504           ! b,c
         icod(7)=1112           ! e,v_e
         icod(8)=1314           ! mu,v_mu
         icod(9)=1516           ! tau,v_tau 
      ENDIF
! Store decay channels for later use
      IchaWm = icwm
      IchaWp = icwp
!... Assigning codes to final particles according to PDG
!    coding convention (1992)
      iflav(1)= icod(icwm)/100
      iflav(2)=-mod(icod(icwm),100)
      iflav(3)= mod(icod(icwp),100)
      iflav(4)=-icod(icwp)/100
!... Masses of the corresponding final state fermions
      DO i = 1,4
        ifa = IABS(iflav(i))
        amdec(i) = amafin(ifa)
      ENDDO
      END
                
      SUBROUTINE KarLud(MODE,PAR1,PAR2)     
C     *********************************     
C LOW LEVEL  MONTE-CARLO GENERATOR          
C ADMINISTRATES DIRECTLY GENERATION OF V-VARIABLE             
C AND INDIRECTLY OF ALL OTHER VARIABLES.    
C     ************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER (PI=3.1415926535897932D0)      
      PARAMETER (CEULER =0.57721566D0)                  
      PARAMETER (NMAX= 40)   
      COMMON / PHYPAR / ALFINV,GPICOB  
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT    
C COMMUNICATES WITH VESKO/RHOSKO            
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI                   
      COMMON / INOUT  / NINP,NOUT     
      COMMON / BXFMTS / BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G
      CHARACTER*80      BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G
      DOUBLE PRECISION DRVEC(100)
      SAVE / PHYPAR /,/ WEKING /,/ KEYYFS /,/ VVREC  /,/ INOUT  /
      SAVE / BXFMTS /
      SAVE SVAR,BETI2,GAMFAP,GAMFAC,GAMFA2,PREC,XCGAUS,XDEL,XCVESK
      SAVE IDYFS
      EXTERNAL RHOSKO
C MAXIMUM PHOTON MULTIPLICITY               
C       
      IF(MODE.EQ.-1) THEN                   
C     ==================================================================
C     ===================INITIALIZATION=================================
C     ==================================================================
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) 'Initialize KarLud  start'              
      SVAR = 4D0*ENE**2
      BETI = 2D0/ALFINV/PI*(DLOG(4D0*ENE**2/AMEL**2)-1D0)     
      BETI2= 2D0/ALFINV/PI* DLOG(4D0*ENE**2/AMEL**2)          
      GAMFAP =1D0-PI**2*BETI**2/12D0        
      GAMFAC =EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)               
      GAMFA2 =EXP(-CEULER*BETI2)/DPGAMM(1D0+BETI2)             
      IDYFS = 0
!WP      CALL GBOOK1(IDYFS+ 7,'WT IN KarLud         $', 50 , 0D0,5D0)
!WP      CALL GMONIT(-1,IDYFS+51,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+52,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+53,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+54,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+55,0D0,1D0,1D0)  
!WP      CALL GMONIT(-1,IDYFS+56,0D0,1D0,1D0)  
      CALL GMONIT(-1,IDYFS+59,0D0,1D0,1D0)  
      CALL VESK1W(-1,RHOSKO,XCVESK,DUM1,DUM2)             
      PAR1 = XCVESK
      PAR2 = 0D0
      PREC = 1D-6
      XCGAUS =BREMKF(1,PREC)   
      XDEL = XCVESK/XCGAUS-1
      WRITE(NOUT,BXL1F) XCVESK,     'xs_crude  VESKO    ','XCVESK','  '
      WRITE(NOUT,BXL1F) XCGAUS,     'xs_crude  GAUSS    ','XCGAUS','  '
      WRITE(NOUT,BXL1F) XDEL       ,'XCVESK/XCGAUS-1    ','      ','  '
      WRITE(NOUT,BXTXT) 'Initialize KarLud  end  '              
      WRITE(NOUT,BXCLO)         
      ELSEIF(MODE.EQ.0) THEN                
C     ==================================================================
C     ====================GENERATION====================================
C     ==================================================================
   30 CONTINUE            
C GENERATE VV             
      IF(KEYFIX.EQ.0) THEN                  
        CALL VESK1W( 0,RHOSKO,DUM1,DUM2,WTVES)           
      ELSE                
        WTVES=1D0
        VV=VVMAX          
      ENDIF               
C LOW-LEVEL MULTIPHOTON GENERATOR           
      CALL YFSGEN(VV,VVMIN,NMAX,WT1,WT2,WT3,WT_PS)    
C--------------TESTS ON INTERNAL WEIGHTS    
C--------------DOES NOT INTERFERE WITH THE EVENT GENERATION !!! 
!WP: Some old tests ...
!WP      REF  = VVRHO(50,SVAR,AMEL,VV,VVMIN)                   
!WP      WTR  = REF/VVRHO(1,SVAR,AMEL,VV,VVMIN)                
!WP      CALL VARRAN(DRVEC,1)
!WP      RN = DRVEC(1)
!WP      CALL GMONIT(0,IDYFS+56,WTR,1D0,RN)          
C PSEUDOREJECTION IN ORDER TO INTRODUCE REFERENCE XSECTION
!WP      IF(KEYFIX.EQ.0 .AND. RN.GT.WTR) GOTO 110                
!WP      WF1  = WT1*VVRHO(51,SVAR,AMEL,VV,VVMIN)/REF           
!WP      WF2  = WT2*VVRHO(52,SVAR,AMEL,VV,VVMIN)/REF           
!WP      WF3  = WT3          
!WP      WF13 = WF1*WF3      
!WP      WF123= WF1*WF2*WF3                    
!WP      CALL GMONIT(0,IDYFS+51,WF1,  1D0,1D0)       
!WP      CALL GMONIT(0,IDYFS+52,WF2,  1D0,1D0)       
!WP      CALL GMONIT(0,IDYFS+53,WF3,  1D0,1D0)       
!WP      CALL GMONIT(0,IDYFS+54,WF13, 1D0,1D0)       
!WP      CALL GMONIT(0,IDYFS+55,WF123,1D0,1D0)       
!WP  110 CONTINUE            
!WPC--------------  
! Weight from crude photon spectrum 
      SVAR1 = SVAR*(1 - VV)
      WT_BS = WtShape(SVAR,SVAR1)
! Total KarLud weight
      WT=WTVES*WT1*WT2*WT3 *WT_PS * WT_BS    
      WTKARL=WT           
      CALL GMONIT(0,IDYFS+59,WT,  1D0,1D0)        
      CALL GF1(IDYFS+ 7,WT,1D0)           
      PAR1=WT             
      ELSE                
C     ==================================================================
C     ====================FINAL WEIGHT ANALYSIS=========================
C     ==================================================================
!WP      CALL GPRINT(IDYFS+ 7)   
      CALL GMONIT(1,IDYFS+59,AVERWT,ERRELA,XNTOT)   
      WTKARL = AVERWT      
      ERKRL  = ERRELA 
      NEVTOT = XNTOT
      PREC   = 1D-6
      XSGS   = BREMKF(1,PREC)
      ERGS   = XSGS*PREC
      CALL VESK1W( 1,RHOSKO,XSVE,ERELVE,XCVESK)
      ERVE   = XSVE*ERELVE       
      IF(KEYFIX.EQ.1)  XCVESK=XCGAUS     
C Note that since VESK1W produces weighted events we are sending
C up the crude x-section (from VESK1W) to the calling program
      PAR1   = XCVESK         
      PAR2   = 0D0         
C NO PRINTOUT FOR MODE = 2                  
      IF(MODE.EQ.1) RETURN    
      CALL GMONIT(2,IDYFS+59,XNACC,XNNEG,XNOVE)  
      NEVNEG = XNNEG            
      DDV    = XSVE/XSGS-1D0
      DDR    = ERELVE + 1D-6
      XSKR   = XCVESK*WTKARL
      ERKR   = XSKR*ERKRL
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) '     KarLud  FINAL  REPORT     '
      WRITE(NOUT,BXTXT) '         window A              '
      WRITE(NOUT,BXL1I) NEVTOT,     'total no of events ','NEVTOT','A0'
      WRITE(NOUT,BXL1I) NEVNEG,     'WT<0        events ','NEVNEG','A1'
      WRITE(NOUT,BXL1F) XCVESK,     'xs_cru VESKO [pb]  ','XCVESK','A2'
      WRITE(NOUT,BXL2F) XSVE,ERVE,  'xs_est VESKO [pb]  ','XSVE  ','A3'
      WRITE(NOUT,BXL2F) XSGS,ERGS,  'xs_est Gauss [pb]  ','XSGS  ','A4'
      WRITE(NOUT,BXL2F) DDV,DDR,    'XCVE/XCGS-1        ','      ','A5'
      WRITE(NOUT,BXL2F) WTKARL,ERKRL,'   <WTKARL>       ','WTKARL','A6'
!WP      WRITE(NOUT,BXL2F) XSKR,ERKR,  'sigma_prim   [pb]  ','XSKARL','A7'
      WRITE(NOUT,BXCLO)         
C     ==================================================================
C     =============SUPPL. FINAL WEIGHT ANALYSIS=========================
C     ==================================================================
!WP      CALL GMONIT(1,IDYFS+51,AVERWT,ERRELA,DUMM3)   
!WP      DEL1   = AVERWT-1D0                   
!WP      DWT1   = ERRELA     
!WP      CALL GMONIT(1,IDYFS+52,AVERWT,ERRELA,DUMM3)   
!WP      AWF2   = AVERWT     
!WP      DWT2   = ERRELA     
!WP      CALL GMONIT(1,IDYFS+53,AVERWT,ERRELA,DUMM3)   
!WP      AWF3   = AVERWT     
!WP      DEL3   = AVERWT-GAMFA2                
!WP      DWT3   = ERRELA     
!WP      CALL GMONIT(1,IDYFS+54,AVERWT,ERRELA,DUMM3)   
!WP      AWF4   = AVERWT     
!WP      DEL4   = AVERWT-GAMFAC                
!WP      DWT4   = ERRELA     
!WP      WRITE(NOUT,BXOPE)         
!WP      WRITE(NOUT,BXTXT) '     KarLud  FINAL  REPORT     '
!WP      WRITE(NOUT,BXTXT) '         window B              '
!WP      WRITE(NOUT,BXL2F) DEL1,DWT1,  '<WF1>-1  mass wt   ','DEL1  ','B1'
!WP      WRITE(NOUT,BXL2F) AWF2,DWT2,  '<WF2> dilat. weight','AWF2  ','B2'
!WP      WRITE(NOUT,BXL2F) AWF3,DWT3,  '<WF3> dilat. weight','AWF3  ','B3'
!WP      WRITE(NOUT,BXL2F) DEL3,DWT3,  '<WF3>-YGF(BETI2)   ','DEL3  ','B4'
!WP      WRITE(NOUT,BXL2F) AWF4,DWT4,  '<WF1*WF3>          ','AWF4  ','B5'
!WP      WRITE(NOUT,BXL2F) DEL4,DWT4,  '<WF1*WF3>-YGF(BETI)','DEL4  ','B6'
!WP      WRITE(NOUT,BXCLO)         
C     ==================================================================
!WP      CALL GMONIT(1,IDYFS+55,AVERWT,ERRELA,DUMM3)   
!WP      AWF5   = AVERWT     
!WP      DEL5   = AVERWT-GAMFAC                
!WP      DWT5   = ERRELA     
!WP      CALL GMONIT(1,IDYFS+56,AVERWT,ERRELA,DUMM3)   
!WP      AWF6   = AVERWT     
!WP      PREC = 1D-6
!WP      XREFER = BREMKF(50,PREC)                   
!WP      DELKAR = XREFER*AWF5/XSKR  -1D0       
!WP      DELREF = XCVESK*AWF6/XREFER-1D0       
!WP      WRITE(NOUT,BXOPE)         
!WP      WRITE(NOUT,BXTXT) '     KarLud  FINAL  REPORT CONT.   '
!WP      WRITE(NOUT,BXTXT) '         WINDOW C                  '
!WP      WRITE(NOUT,BXTXT) 'BETI= 2*ALFA/PI*(LOG(S/MEL**2)-1)       '
!WP      WRITE(NOUT,BXTXT) 'GAMFAP= 1-PI**2*BETI**2/12              '
!WP      WRITE(NOUT,BXTXT) 'GAMFAC=EXP(-CEULER*BETI)/GAMMA(1+BETI)  '
!WP      WRITE(NOUT,BXTXT) 'GAMFA2=EXP(-CEULER*BETI2)/GAMMA(1+BETI2)'
!WP      WRITE(NOUT,BXL1F)  BETI,        '                =','BETI  ','C1'
!WP      WRITE(NOUT,BXL1F)  GAMFAP,      '                =','GAMFAP','C2'
!WP      WRITE(NOUT,BXL1F)  GAMFAC,      '                =','GAMFAC','C3'
!WP      WRITE(NOUT,BXL1F)  GAMFA2,      '                =','GAMFA2','C4'
!WP      WRITE(NOUT,BXL2F) AWF5,DWT5, ' <WF1*WF3*WF4>      ','AWF5  ','C5'
!WP      WRITE(NOUT,BXL2F) DEL5,DWT5, ' <WF1*WF3>-YGF(BETI)','DEL5  ','C6'
!WP      WRITE(NOUT,BXTXT) 'DELKAR=XREFER*AVER(WF1*WF1*WF3)/XSKARL-1'
!WP      WRITE(NOUT,BXTXT) 'DELREF=XCRUDE*AVER(WTR)/XREFER-1        '
!WP      WRITE(NOUT,BXL1F) XREFER,    'reference x_sect.   ','XREFER','C7'
!WP      WRITE(NOUT,BXL1F) DELKAR,    'XREFER*AWF5/XSKR  -1','DELKAR','C8'
!WP      WRITE(NOUT,BXL1F) DELREF,    'XCVESK*AWF6/XREFER-1','DELREF','C9'
!WP      WRITE(NOUT,BXCLO)         
      ENDIF               
C     =====               
      END

      FUNCTION WtShape(s,s1) 
*     **********************
!-------------------------------------------------------------------------!
! This functions provides "crude" weight corresponding to s'-dependence   !
! generation of the Born total cross section sigma_crude(s').             !
!-------------------------------------------------------------------------!
! Written by: Wieslaw Placzek                      Skawina, November 1999 !
! Last update: 06.11.1999         by: WP                                  !
!-------------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)   
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      COMMON / DeChan / IchaWm,IchaWp
      COMMON / decdat / amafin(20), br(20)
      SAVE / KeyKey /,/ DeChan /,/ decdat /
! 
! Normalization factor for the crude weight
      IF (KeyDWm*KeyDWp.EQ.0) THEN
         BRfac = br(IchaWm)*br(IchaWp)
      ELSE
         BRfac = 1d0
      ENDIF
      BorCru = BRfac*BORNY(s,s1)
      WtShape = 1d0/BorCru
      END

      FUNCTION RHOSKO(R)                    
C     ********************                  
C CALLED IN VESK1W        
C PROVIDES V OR K DISTRIBUTION TO BE GENERATED                
C     ********************                  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER (FLEPS = 1D-35)
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT     
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI                   
C MAPPING  R => VV CHANGE  TO IMPROVE ON EFFICIENCY
C Note that the replacement below makes program more precise
C and bulet-proof with respect numerical instabilities close to VV=0    
      X = MAX(R,FLEPS**BETI)                
      BBT = -0.5D0          
      CALL CHBIN1(X,BETI,BBT,VVMAX,VV,RJAC)               
C BORN XSECTION           
C NOTE 1/(1-VV) FACTOR BECAUSE BORNY IS IN R-UNITS            
      SVAR   = 4D0*ENE**2
      SVAR1  = SVAR*(1D0-VV)                 
      XBORN  = BORNY(SVAR,SVAR1)/(1D0-VV)         
C constant x-section for tests 
      IF(KEYZEE.EQ.-2) XBORN = XBORN * (1D0-VV)
      RHOSKO = RJAC*XBORN* VVRHO(1,SVAR,AMEL,VV,VVMIN)
      END                 

      FUNCTION BORNY(SVAR,SVAR1)     
C     **************************      
C THIS ROUTINE CALCULATES TOTAL BORN CROSS SECTION AS A FUNCION OF SVAR1
* Adapted to WW-process by W. Placzek,       CERN, August 1999
*     ********************      
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z) 
      BORNY = WW_Born_Crud(SVAR,SVAR1) *SVAR1/SVAR
      END       

      SUBROUTINE YFSGEN(VV,VMIN,NMAX,WT1,WT2,WT3,WT_PS)               
C     *************************************************               
C======================================================================
C================== Y F S G E N =======================================
C======================================================================
C*********INPUT                 
C VV    = V VARIABLE            
C VMIN  = MINIMUM V VARIABLE (INFRARED CUTOFF)  
C NMAX  = MAXIMUM PHOTON MULTIPLICITY           
C*********OUTPUT                
C WT1  = WEIGHT DUE TO NEGLECTED MASS TERMS     
C WT2  = WEIGHT DUE TO DILATATION OF PHOTON MOMENTA             
C WT3  = ANOTHER DILATATION WEIGHT  
C WT_PS = Phase-space weight from CC03 Presampler (WP)             
C OTHER OUTPUT RESULTS IN /MOMINI/, /MOMDEC/               
*****************************************************                  
* Modified by W. Placzek: adapted for WW-production *
*****************************************************          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)       
      PARAMETER( PI=3.1415926535897932D0)
      COMMON / PHYPAR / ALFINV,GPICOB  
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT 
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT   
      SAVE / PHYPAR /,/ WEKING /,/ MOMINI /,/ KEYYFS /
      DIMENSION XPH(100),RR(100)                
C               
C HERE BETI2 MUST BE USED INSTEAD OF BETI (MASS TERM NEGLECTED) 
      BETI2 = 2D0/ALFINV/PI*DLOG(4D0*ENE**2/AMEL**2)            
      AM2=(AMEL/ENE)**2         
      DO 10 I=1,NMAX            
      XPH(I)=0D0                
      DO 10 J=1,4               
   10 SPHOT(I,J)=0D0            
      IF(VV.LE.VMIN) THEN       
C NO PHOTON ABOVE DETECTABILITY THRESHOLD       
         WT1=1D0                
         WT2=1D0                
         WT3=1D0                
         NPHOT=0                
      ELSE      
C ONE OR MORE PHOTONS, GENERATE PHOTON MULTIPLICITY             
C NPHOT = POISSON(WITH AVERAGE = AVERG) + 1     
         AVERG=BETI2*DLOG(VV/VMIN)              
  100    CALL POISSG(AVERG,NMAX,MULTP,RR)       
         NPHOT = MULTP+1        
C This is for tests of program at fixed multiplicity (for adv. users)
         NPHFIX =  MOD(KEYBRM,10000)/1000       
         IF(NPHFIX.NE.0.AND.NPHOT.NE.NPHFIX) GOTO 100           
         IF(NPHOT.EQ.1) THEN    
            XPH(1)=VV           
            CALL BREMUL(XPH,AM2,WT1)            
            DJAC0=(1D0+1D0/SQRT(1D0-VV))/2D0    
            WT2  = 1D0/DJAC0    
            WT3  = 1D0          
         ELSE                   
            XPH(1)=VV           
            DO 200 I=2,NPHOT    
  200       XPH(I)=VV*(VMIN/VV)**RR(I-1)        
            CALL BREMUL(XPH,AM2,WT1)            
            CALL RESOLH(VV,EXPY,DJAC)           
            DJAC0=(1D0+1D0/SQRT(1D0-VV))/2D0    
            WT2  = DJAC/DJAC0   
            WT3  = 1D0          
C SCALE DOWN PHOTON ENERGIES AND MOMENTA        
            DO 300 I=1,NPHOT    
            DO 300 K=1,4        
  300       SPHOT(I,K)=SPHOT(I,K)/EXPY          
C CHECK ON LOWER ENERGY CUT-OFF                 
            IF(SPHOT(NPHOT,4).LT.VMIN) WT3 =0D0                 
         ENDIF                  
      ENDIF     
C PHOTON MOMENTA IN GEV UNITS   
      DO 420 J=1,4              
  420 SPHUM(J)=0D0              
      DO 480 I=1,NPHOT          
      DO 480 J=1,4              
      SPHOT(I,J)=SPHOT(I,J)*ENE                 
  480 SPHUM(J)=SPHUM(J)+SPHOT(I,J)              
C DEFINE FERMION MOMENTA        
!WP:      CALL KINEKR
!WP: CC03 Presampler
      CALL WW_Presam(WT_PS)
      END 
      
      SUBROUTINE RESOLH(VV,EXPY,DJAC)           
C     *******************************           
C THIS SOLVES CONSTRAINT EQUATION ON PHOTON MOMENTA             
C ALSO CALCULATES CORRESPONDING JACOBIAN FACTOR                 
C INPUT:  VV    = COSTRAINT PARAMETER V         
C OUTPUT  EXPY  = RESCALING FACTOR - A SOLUTION OF THE EQUATION 
C         DJAC  = JACOBIAN FACTOR               
C     ************************                  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)       
      DIMENSION PP(4),PK(4)     
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT
      SAVE   / MOMINI /
C               
      DO 210 K=1,4              
      PK(K)=0D0                 
  210 PP(K)=0D0                 
      PP(4)=2D0                 
      DO 215 I=1,NPHOT          
      DO 215 K=1,4              
  215 PK(K)=PK(K)+SPHOT(I,K)    
      PPDPP=PP(4)**2-PP(3)**2-PP(2)**2-PP(1)**2                 
      PKDPK=PK(4)**2-PK(3)**2-PK(2)**2-PK(1)**2                 
      PPDPK=PP(4)*PK(4)-PP(3)*PK(3)-PP(2)*PK(2)-PP(1)*PK(1)     
      AA=PPDPP*PKDPK/(PPDPK)**2                 
      EXPY=2D0*PPDPK/PPDPP/VV   
C SOLUTION FOR CONSTRAINT ON PHOTON FOUR MOMENTA                
      EXPY=EXPY*.5D0*(1D0+SQRT(1D0-VV*AA))      
C JACOBIAN FACTOR               
      DJAC=(1D0+1D0/SQRT(1D0-VV*AA))/2D0        
      END 
      
      SUBROUTINE BREMUL(XPH,AM2,WT)             
C     *****************************             
C PROVIDES PHOTON FOURMOMENTA   
C INPUT  : XPH    = LIST OF PHOTON ENERGIES     
C OUTPUT : SPHOT  = LIST OF PHPTON FOUR-MOMENTA                 
C          WT     = WEIGHT DUE TO MASS TERMS    
C     ************************                  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)       
      PARAMETER( PI =3.1415926535897932D0)           
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT
      SAVE   / MOMINI /
      DIMENSION XPH(*) 
      DOUBLE PRECISION DRVEC(100)

      WT=1D0    
      DO 100 I=1,NPHOT          
      XK=XPH(I)                 
      CALL VARRAN(DRVEC,1)
      RN = DRVEC(1)
      CALL ANGBRE(RN,AM2,CG,SG,DIST0,DIST1)     
      WTM   =DIST1/DIST0        
      WT    =WT*WTM             
      CALL VARRAN(DRVEC,1)
      RNUMB = DRVEC(1)
      PHI=2D0*PI*RNUMB          
      SPHOT(I,1)=XK*SG*COS(PHI)                 
      SPHOT(I,2)=XK*SG*SIN(PHI)                 
      SPHOT(I,3)=XK*CG          
      SPHOT(I,4)=XK             
  100 CONTINUE                  
      END 
      
      SUBROUTINE WW_Presam(Wt_ps)
*     ***************************
!--------------------------------------------------------------!
! Born-level CC03 presampler (from KoralW):                    !
! Generates 4-momenta of W-,W+ and their decay products at the !
! crude level and calculates a phase-space weight Wt_ps        !
!--------------------------------------------------------------!
! Written by: Wieslaw Placzek,              CERN, August 1999  !
! Last update: 10.08.1999           by: WP                     ! 
!--------------------------------------------------------------!
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER ( PI=3.1415926535897932D0 )
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),npho
      COMMON / cms_eff_momdec /
     $      effbeam1(4),effbeam2(4),effp1(4),effp2(4),effp3(4),effp4(4)
      REAL*8 QSU(4)
      SAVE / WEKING /,/ MOMINI /,/ MOMDEC /,/ cms_eff_momdec /
!
      ambeam = AMEL
      svar   = 4*ENE**2
      IF (NPHOT.GE.1) THEN
* QSU is 4-momentum of W-pair (after ISR)
         DO K=1,4
            QSU(K) =-SPHUM(K)
         ENDDO
         QSU(4) = QSU(4) + 2D0*ENE
         sprim  = QSU(4)**2 - QSU(3)**2 - QSU(2)**2 - QSU(1)**2
      ELSE
         sprim = svar
      ENDIF
! Born-level CC03 Presampler   
      msdump = 0 
      CALL ww_make_phsp_point_z
     $     (msdump,ambeam,svar,sprim,Wt_ps,
     $      effbeam1,effbeam2,effp1,effp2,effp3,effp4)
      IF (WT_ps.EQ.0d0) THEN
         DO k = 1,4
            QF1(k) = 0d0
            QF2(k) = 0d0
            pf1(k) = 0d0
            pf2(k) = 0d0
            pf3(k) = 0d0
            pf4(k) = 0d0
         ENDDO
         NPHOT = 0
         npho  = 0
         RETURN
      ENDIF
! Construct W- and W+ 4-momenta
      DO k = 1,4
         QF1(k) = effp1(k) + effp2(k)
         QF2(k) = effp3(k) + effp4(k)
      ENDDO
* TRANSFORM BACK TO CMS
      IF(NPHOT.GE.1) THEN
        CALL BOSTDQ(-1,QSU,QF1,QF1)
        CALL BOSTDQ(-1,QSU,QF2,QF2)
        CALL BOSTDQ(-1,QSU,effp1,pf1)
        CALL BOSTDQ(-1,QSU,effp2,pf2)
        CALL BOSTDQ(-1,QSU,effp3,pf3)
        CALL BOSTDQ(-1,QSU,effp4,pf4)
        DO i = 1,NPHOT
           DO k = 1,4
              phot(i,k) = SPHOT(i,k)
           ENDDO
        ENDDO
      ENDIF
      npho = NPHOT
      END
      
      SUBROUTINE KarFin(MODE, XXF,am0,am1,am2,WT)
!WP      SUBROUTINE KarFin(MODE, XXF,AMFIN,WT)     
C     ***************************************   
C ======================================================================
C ... Low level Monte Carlo for final state multibremsstrahlung 
C ======================================================================
C Input:        
C         XXF    = CMS four momentum of the entire final state  
C  system i.e. fermions + photons               
C         AMFIN  = mass of final state fermion  
C Hidden input:  EPS, DELTA in /VVREC/, formats in /BXFMTS/     
C Output:       
C            WT  = crude MC weight              
C         Momenta in /MOMFIN/   
!----------------------------------------------------------------------   
! Adapted for WW process by: Wieslaw Placzek     Knoxville, June 1996
! Last update: 20.11.2000       by: WP
!----------------------------------------------------------------------   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)       
      PARAMETER(PI=3.1415926535897932D0)     
      DIMENSION XXF(4) 
      COMMON / PHYPAR / ALFINV,GPICOB  
      SAVE   / PHYPAR /
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT      
      SAVE   / KEYYFS /
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF  
      SAVE   / WEKING /
      COMMON / MOMFIN / Q1(4),Q2(4),SPHUM(4),SPHOT(100,4),NPHOT
      COMMON / UUREC  / UU,EPS,DELTA            
      COMMON / INOUT  / NINP,NOUT         
      DIMENSION Q1C(4),Q2C(4)
      DIMENSION  MK(100), WTMAS(100)            
      COMMON / BXFMTS / BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G
      CHARACTER*80      BXOPE,BXCLO,BXTXT,BXL1I,BXL1F,BXL2F,BXL1G,BXL2G
      SAVE / MOMFIN /,/ UUREC  /,/ INOUT  /,/ BXFMTS /
      SAVE NEVGEN,MARTOT,IDYFS
C               
      IF(MODE.EQ.-1) THEN       
C     ===================       
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) 'Initialize KarFin  start'              
      KEYPIA = KEYRED 
      IDYFS = 0
      CALL GBOOK1(IDYFS+20,'KarFin: log10(k/eps) marked $',50, 0D0, 5D0)
C ...Additional check on WTCTRL, plot of its u-dependence       
      CALL GBOOK1(IDYFS+31,'KarFin:     U  WTCTRL       $',27,.1D0, 1D0)
      CALL GBOOK1(IDYFS+32,'KarFin:     U  WT=1         $',27,.1D0, 1D0)
      CALL GMONIT(-1,IDYFS+60,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+61,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+62,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+63,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+64,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+65,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+66,0D0,1D0,1D0)      
      CALL GMONIT(-1,IDYFS+69,0D0,1D0,1D0)      
      NEVGEN=0                  
      MARTOT=0                  
      WRITE(NOUT,BXTXT) 'Initialize KarFin  end  '              
      WRITE(NOUT,BXCLO)         
      ELSEIF(MODE.EQ.0) THEN    
C     ======================    
      NEVGEN=NEVGEN+1           
      SVAR = XXF(4)**2-XXF(3)**2-XXF(2)**2-XXF(1)**2  
!WP      CMSENE = SQRT(SVAR) 
!WP      EMIN = EPS*CMSENE/2     
      EMIN = EPS*ENE       
      CALL MBREF(SVAR,am0,am1,am2,DELTA,              
     $           UU,NPHOT,SPHOT,SPHUM,MK,Q1,Q2,Q1C,Q2C,WT1,WT2,WTMAS) 
      CALL KINF1(XXF,Q1,Q2,Q1C,Q2C,NPHOT,SPHOT,SPHUM)
      WT3=1D0                   
      WCTRL=1D0                 
      WTREM=1D0   
      IF(WT1.NE.0.D0) THEN  
C ...optionally remove photons below epsilon from the record    
C ...and reorganize mass weights                
!WP: OLD    CALL PIATEK(am0,am1,am2,EMIN,DELTA,WTMAS,WTREM,WT3,WCTRL) 
         CALL Piatek(KEYPIA,am1,am2,EMIN,DELTA,1d0,ALFINV,
     $        Q1,Q2,Q1C,Q2C,SPHUM,SPHOT,NPHOT,WTMAS,WTREM,WT3,WCTRL)
      ENDIF     
      XMUL= NPHOT               
      CALL GMONIT(0,IDYFS+64,XMUL,20D0,0D0)           
      CALL GMONIT(0,IDYFS+65,WCTRL,1D0,0D0)           
      CALL GF1(IDYFS+31, UU  ,WCTRL)          
      CALL GF1(IDYFS+32, UU  ,  1D0)          
      CALL GMONIT(0,IDYFS+66,WTREM,1D0,0D0)           
C ...Monitoring weights         
      XML = NPHOT               
      CALL GMONIT(0,IDYFS+60,XML,20D0,0D0)            
      CALL GMONIT(0,IDYFS+61,WT1,1D0,0D0)             
      CALL GMONIT(0,IDYFS+62,WT2,1D0,0D0)             
      CALL GMONIT(0,IDYFS+63,WT3,1D0,0D0)             
C ...marked photons             
      IF(NPHOT.GE.1) THEN       
         DO 60 I=1,NPHOT        
         XK= SPHOT(I,4)/EMIN    
         UL= LOG10(XK)          
         IF(MK(I).EQ.1)   CALL GF1(IDYFS+20,   UL,1.D0)       
         IF(MK(I).EQ.1)   MARTOT=MARTOT+1       
   60    CONTINUE               
      ENDIF     
C ...Main weight                
      WT = WT1*WT2*WT3 
      CALL GMONIT(0,IDYFS+69,WT ,1D0,0D0)             
      ELSE      
C     ====      
C ...no printout for MODE=1     
      IF(MODE.EQ.1) RETURN      
C-----------------------------------------------------------------------
C.........................Output window A...............................
      CALL GMONIT(1,IDYFS+60,AVMULT,DUMM2,DUMM3)      
      CALL GMONIT(1,IDYFS+61,AWT61,DWT61,DUMM3)       
      CALL GMONIT(1,IDYFS+62,AWT62,DWT62,DUMM3)       
      CALL GMONIT(1,IDYFS+63,AWT63,DWT63,DUMM3)       
      CALL GMONIT(1,IDYFS+69,AWT69,DWT69,XNTOT)   
      NEVGEN = XNTOT
C ...General information on weights             
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) 'KarFin output - window A'              
      WRITE(NOUT,BXTXT) '    Weight Statistics   '              
      WRITE(NOUT,BXL2F) AWT69,DWT69,' general weight    ','WT    ','A1'
      WRITE(NOUT,BXL1I) NEVGEN,     ' generated events  ','NEVGEN','A2'
      WRITE(NOUT,BXL1F) AVMULT,     ' aver. ph. multi.  ','AVMULT','A3'
      WRITE(NOUT,BXL1I) MARTOT,     ' Marked photons    ','MARTOT','A4'
      WRITE(NOUT,BXL2F) AWT61,DWT61,' Kinematics, smin  ','WT1   ','A5'
      WRITE(NOUT,BXL2F) AWT62,DWT62,' Jacobian          ','WT2   ','A6'
      WRITE(NOUT,BXL2F) AWT63,DWT63,' Photon ang. dist. ','WT3   ','A7'
      WRITE(NOUT,BXCLO)         
C ...Specific details on mass weight rearrangenment, and rejection
      CALL GMONIT(1,IDYFS+64,AVMLT,DWT65,DUMM3)       
      CALL GMONIT(1,IDYFS+65,AWT65,DWT65,DUMM3)       
      CALL GMONIT(1,IDYFS+66,AWT66,DWT66,XNTOT)    
      CALL GMONIT(3,IDYFS+66,XNNEG,XNZER,DUMM3)   
      NTOT66 = XNTOT           
      NZER66 = XNZER           
      WRITE(NOUT,BXOPE)         
      WRITE(NOUT,BXTXT) 'KarFin output - window B'              
      WRITE(NOUT,BXTXT) '    on mass weights     '              
      WRITE(NOUT,BXL2F) AWT66,DWT66,' removal wgt WTREM ','WT6 ','B1'
      WRITE(NOUT,BXL1I) NTOT66,     ' no. of raw events ','    ','B2'
      WRITE(NOUT,BXL1I) NZER66,     ' WT6=0      events ','    ','B3'
      WRITE(NOUT,BXL1F) AVMLT,      ' raw ph. multipl.  ','    ','B4'
      WRITE(NOUT,BXL2F) AWT65,DWT65,' control wgt WCTRL ','WT5 ','B5'
      WRITE(NOUT,BXL1G) EPS,        ' epsilon           ','    ','B6'
      WRITE(NOUT,BXL1G) DELTA,      ' delta             ','    ','B7'
      WRITE(NOUT,BXCLO)         
C ...Histograms                 
cc      CALL GPRINT(IDYFS+20)         
cc      CALL GOPERA(IDYFS+31,'/',IDYFS+32,IDYFS+33,1D0,1D0)   
cc      CALL GPRINT(IDYFS+33)         
      ENDIF     
C     =====     
      END 

      SUBROUTINE Piatek(KeyPia,amch1,amch2,emin,delta,charg2,alfinv,
     $     qf1,qf2,qf1c,qf2c,phsu,phot,nphot,wtmas,wtrem,wtm3a,wctrl)
*     *****************************************************************
* Written CERN, piatek, 22 sept. 1989  (S.J.)
* This routine calculates YFS form-factor and optionaly 
* removes some of soft photons (below emin in CMS), calculating
* compensating weight.
* Note the action of this routine is not Loretnz invariant !!!!
* Input:  
*     KeyPia   = 0, NO removal of photons below emin
*              = 1, with removal of photons below emin
*     amch1,2  = fermion masses
*     emin     = emin minimum-energy of photons to be kept (GeV)
*     delta    = infrared cut-off in generation (dimensionless)
*     charg2   = FSR charge squared
*     alfinv   = 1/alpha_QED
*     qf1,2    = fermion momenta
*     qf1c,2c  = ghost fermion momenta in crude S-factor
*     phsu     = sum of photon momenta
*     phot     = list of photon momenta
*     amch1,2  = final state masses (GeV)
*     wtmas    = list of mass-weights for all photons
* Output: 
*     wtrem    = 1,  for KeyPia=0
*              = mass-weight of removed photons, for KeyPia=1
*     wtm3a    = mass-weight for all photons, see comments below
*     wctrl    = control-weight for remowed photons
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0)
      DIMENSION  qf1(4),qf2(4),qf1c(4),qf2c(4),phsu(4),phot(100,4)
      DIMENSION  wtmas(100)
      SAVE
      DIMENSION qq(4),pp(4)

      alf1 = 1d0/pi/alfinv
      alfc = alf1*charg2
      amfin = MIN(amch1,amch2)
      DO k=1,4
         pp(k) = qf1(k)+qf2(k) +phsu(k)
         qq(k) = qf1(k)+qf2(k)
      ENDDO
      svar = pp(4)**2-pp(3)**2 -pp(2)**2 -pp(1)**2
      sprim= qq(4)**2-qq(3)**2 -qq(2)**2 -qq(1)**2
      wtm1=1d0
      wtm2=1d0
* mass weight below and above emin calculated separately
      DO i=1,nphot
         IF(phot(i,4) .LT. emin) THEN
            wtm1=wtm1*wtmas(i)
            IF(wtm1 .LE. 1d-90) wtm1=0d0
         ELSE
            wtm2=wtm2*wtmas(i)
            IF(wtm2 .LE. 1d-90) wtm2=0d0
         ENDIF
      ENDDO
* Delt1 and eps1 are cutoffs located in YFS formfactor
* Note that xfact=(1+2*qqk/sprim) is EXACTLY the same as in yfs_fin
      qqk  = qq(4)*phsu(4)-qq(3)*phsu(3)-qq(2)*phsu(2)-qq(1)*phsu(1)
      delt1 =  delta*(1+ 2*qqk/sprim)
      eps1  =  sqrt(emin**2/qf1(4)/qf2(4))
* The total phase space integral for crude x-section,
* Note that delta is a lower limit on y-variables in crude generation
      amc2  =  4d0*amfin**2/svar
      betc  =  dsqrt(1d0-amc2)
      fphs  =  2*alfc
     $     *(1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
     $     *dlog(1/delta)
* YFS formfactor cut-off dependend part: 
* delt1 = 2*Emin/sqrt(s'), where Emin is infrared cut-off in QMS
      q1q2= qf1(4)*qf2(4) -qf1(3)*qf2(3) -qf1(2)*qf2(2) -qf1(1)*qf2(1)
      fyfs  = -2d0*alfc
     $     *( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
     $     *dlog(1/delt1)
      delb  =  fyfs + fphs
* The average mass-weight for removed photon = exp(delb2)
* It can be calculated analyticaly as a  ratio of YFS formfactors
* On the other hand, it is checked by MC, see control weight wtctrl
* Ultrarelativistic (small mass) old version
      delb2u = -2*alfc*(dlog(svar/sprim)+1) *dlog(eps1/delt1)
* Delb2 used actualy
      IF( (amch1+amch2)**2/svar .LT. 1d-5) THEN
         delb2 = delb2u
      ELSE
* Complete delb2 for finite amfin
         delb2 = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
      ENDIF
* Approximate version of delb2 without A4 function for tests
*      delb2w = -2*alfc*(
*     $     (1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
*     $     -( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
*     $     ) *dlog(eps1/delt1)
*****[[[[[[*********DEBUG****
*      IF((1-sprim/svar) .gt. 0.01d0) THEN
*         delb2m = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
*         WRITE(*,'(a,5f20.10)')
*     $  'piatek: ',1-sprim/svar,delb2m,delb2u/delb2m,delb2w/delb2m
*      ENDIF
*****]]]]]]*********DEBUG****
* Control weight - its average should be =1 within statist. error
      wctrl =wtm1*exp(-delb2)
      IF(KeyPia .EQ. 0) THEN
         IF(abs(delb) .GT. 100d0 ) WRITE(*,*) ' delb= ',delb
         wtrem = 1d0
         wtm3a = wtm1*wtm2*exp(delb)
      ELSE
* Optional removal of photons below emin from the record
* in such a case wtm3a includes exp(belb2)= <wt3> for removed ph.
         nph=nphot
         DO j=nphot,1,-1
            IF(phot(j,4) .LT. emin) THEN
               DO i=j+1,nph
                  DO k=1,4
                     phot(i-1,k)=phot(i,k)
                  ENDDO
               ENDDO
               nph=nph-1
            ENDIF
         ENDDO
* Correction of Alex Read
         DO j=nph+1,nphot
            DO k=1,4
               phot(j,k) = 0.d0
            ENDDO
         ENDDO
         nphot=nph
* wtmas includes here average weight of removed photons exp(delb2)
         wtrem = wtm1
         wtm3a = wtm2*exp(delb+delb2)
      ENDIF
      END ! Piatek

      FUNCTION delb2f(emin,delta,am1,am2,q1,q2,r1,r2,sphum)
*     ******************************************************
!----------------------------------------------------------------------!
* Exact formula for delb2 in the compensating weight exp(delb2)
* necessary in the case of erasing soft photons below emin, 
* version for the case of finite mass.
* It is a linear combination of 4 Breal function:
* 1 exact and 1 crude, for 2 boundries.
* Remark on r1, r2:
* They are ghost-fermion momenta in the definition of the crude 
* distribution, i.e. truncated S-factor is r1*r2/(k*r1)/(k*r2) 
* as generated in the crude MC.
* In QMS frame 4-momenta r1, r2 have the same energy 
* and directions as q1, q2
* but different masses am1c, am2c and therefore longer 3-momenta.
* They are usefull because we may use the same analytical
* expression for the exact Breal and  for "crude Breal"
!----------------------------------------------------------------------!
      IMPLICIT REAL*8(a-h,o-z)
      REAL*8 q1(4),q2(4),r1(4),r2(4),sphum(4)
      REAL*8 qq(4),pp(4)
*
      amf=min(am1,am2)          ! basic mass in crude MC
      DO k=1,4
         pp(k) = q1(k)+q2(k) +sphum(k)
         qq(k) = q1(k)+q2(k)
      ENDDO
      svar = pp(4)**2-pp(3)**2 -pp(2)**2 -pp(1)**2
      sprim= qq(4)**2-qq(3)**2 -qq(2)**2 -qq(1)**2
      Eqq = 0.5d0*sqrt(sprim)
      Eq1 = (sprim +am1**2 -am2**2)/(2*sqrt(sprim))
      Eq2 = (sprim -am1**2 +am2**2)/(2*sqrt(sprim))
      qqk  = qq(4)*sphum(4)-qq(3)*sphum(3)-qq(2)*sphum(2)-qq(1)*sphum(1)
      delt1 =  delta*(1+ 2*qqk/sprim)
      eming = Eqq*delt1
      amgam =1d-60 ! dummy photon mass
********* various input parameters for Btildc and Btildf
      am1c = amf*sqrt(sprim/svar)
      am2c = amf*sqrt(sprim/svar)
      q1q2  = q1(4)*q2(4) - q1(3)*q2(3) - q1(2)*q2(2) - q1(1)*q2(1)
      r1r2  = r1(4)*r2(4) - r1(3)*r2(3) - r1(2)*r2(2) - r1(1)*r2(1)
********* CMS boundry, difference crude-exact
      dcms2c = Btildc(r1r2,  r1(4),r2(4), am1c,am2c, emin,amgam) !crude
      dcms2f = Btildf(q1q2,  q1(4),q2(4),  am1, am2, emin,amgam) !exact
********* QMS boundry, difference crude-exact
      dqms2c = Btildc(r1r2,   Eqq,Eqq, am1c,am2c, eming,amgam) !crude
      dqms2f = Btildf(q1q2,   Eq1,Eq2, am1 , am2, eming,amgam) !exact
********* QMS - CMS, result should be negative ( delta<<epsilon )
      delb2f = (dqms2c-dqms2f) - (dcms2c-dcms2f)
*****[[[[[[*********DEBUG****
c      IF((1-sprim/svar) .gt. 0.2d0) THEN
c         x = Ttildf(q1q2,   Eq1,Eq2, am1 , am2, eming,amgam)
c         WRITE(6,'(a,6f20.10)')
c     $  '==: ',dqms2c,dcms2c,dqms2f,dcms2f
c      ENDIF
*****]]]]]]*********DEBUG****
      END

      FUNCTION Btildf(p1p2,E1,E2,am1,am2,aKmax,amgam)
*     ***********************************************
!----------------------------------------------------------------------!
! Full/Complete 2-particle Btilde function.
! Equivalent of routine Btilde programmed by W. Placzek (S.J.)
!----------------------------------------------------------------------!
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
!
      Btildf = alfpi*(
     $     (p1p2*Aanal( p1p2,am1,am2) -1 )*2*LOG(2*aKmax/amgam)
     $     +p1p2*A4anal(p1p2,E1,E2,am1,am2)
     $     -0.5d0*am1**2*A4snal(E1,am1)
     $     -0.5d0*am2**2*A4snal(E2,am2)
     $     )
      END

      FUNCTION Btildc(p1p2,E1,E2,am1,am2,aKmax,amgam)
*     ***********************************************
!----------------------------------------------------------------------!
! Crude/Truncated (crude MC) 2-particle Btilde equivalent S.J.
!----------------------------------------------------------------------!
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER ( pi = 3.1415926535897932D0, alfinv = 137.03599976D0 )
      PARAMETER ( alfpi = 1/alfinv/pi )
!
      Btildc = alfpi*(
     $      p1p2*Aanal( p1p2      ,am1,am2)*2*LOG(2*aKmax/amgam)
     $     +p1p2*A4anal(p1p2,E1,E2,am1,am2)
     $     )
      END

      FUNCTION Aanal(p1p2,am1,am2)
*     ****************************
!----------------------------------------------------------------------!
! Function A(p1,p2)
!----------------------------------------------------------------------!
      IMPLICIT REAL*8(a-h,o-z)
      am12 = am1*am2
      IF (p1p2-am12.lt.1d-10) THEN
         Aanal=0d0
         RETURN
      ENDIF
      xlam = SQRT( (p1p2 - am12)*(p1p2 + am12) )
      Aanal  = 1/xlam *LOG( (p1p2 + xlam)/am12 )
      END

      FUNCTION A4snal(E1,am1)
*     ***********************
      IMPLICIT REAL*8(a-h,o-z)
!----------------------------------------------------------------------!
! Function (p1*p1)*A4(p1,p1)
!----------------------------------------------------------------------!
      bet1 = SQRT(1-am1**2/E1**2)
      b1ln = 2*LOG( (1+bet1)*E1/am1 )
      A4snal = -1/am1**2/bet1 *b1ln
      END
      
      SUBROUTINE WFORM(CMSENE,Q1,Q2,AMF,DELTA,EPS,DYFS)         
C     *************************************************         
C Not used, kept for some future tests          
C Yennie-Fraytschi-Suura Formfactors for the final state ferm. pair
C     ***********************************       
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)       
      PARAMETER(PI=3.1415926535897932D0,ALFINV=137.03599976D0)     
      PARAMETER(ALF1=1/ALFINV/PI)         
      DIMENSION Q1(4),Q2(4)     

      SVAR  = CMSENE**2         
      ENE= CMSENE/2             
C ...Momenta q1,q2 should be in CMS             
      E1 = Q1(4)                
      E2 = Q2(4)                
      BETF2 = 2*ALF1* DLOG(SVAR /AMF**2)        
      DELB  = BETF2*DLOG(ENE/SQRT(E1*E2)*EPS/DELTA)             
      EP    = E1+E2             
      EM    = E1-E2             
      Q1Q2  = Q1(4)*Q2(4)-Q1(3)*Q2(3)-Q1(2)*Q2(2)-Q1(1)*Q2(1)   
      DL    = SQRT( 2*Q1Q2 +EM**2 )             
      REMN  = PI**2/2           
     $        -0.50*DLOG(E1/E2)**2              
     $        -0.25*DLOG((DL+EM)**2/(4*E1*E2))**2               
     $        -0.25*DLOG((DL-EM)**2/(4*E1*E2))**2               
     $        - DILOGY((DL+EP)/(DL+EM)) -DILOGY((DL-EP)/(DL-EM))  
     $        - DILOGY((DL-EP)/(DL+EM)) -DILOGY((DL+EP)/(DL-EM))  
      DYFS  = EXP( DELB +ALF1*REMN )            
      END 

      SUBROUTINE MBREF(SVAR,xm0,xm1,xm2,DELTA,        
     $                 UU,NPHOT,PHOT,PHSU,MK,Q1,Q2,Q1C,Q2C,WT1,WT2,WTM)       
!WP      SUBROUTINE MBREF(SVAR,AMFIN,DELTA,
!WP     $                 UU,NPHOT,PHOT,PHSU,MK,Q1,Q2,WT1,WT2,WTM) 
C     *****************************************************************
C SIMULATES FINAL STATE BREMSSTRAHLUNG (11 MARCH 1989)         
C INPUT  : SVAR   = S VARIABLE  (GEV)         
C          AMFIN  = MASS OF FINAL FERMION     
C          DELTA  = LOWER ENERGY BOUND (DIMENSIONLESS)         
C OUTPUT : UU     = 1-s'/s   
C          NPHOT  = PHOTON MULTIPLICITY       
C          PHOT   = PHOTON FOUR MOMENTA (GEV) IN CMS           
C          PHSU   = SUM OF PHOTON MOMENTA     
C          MK     = MARKS ON PHOTONS CLOSE TO LOWER ENERGY BOUND 
C          Q1     = FINAL FERMION FOUR MOMENTUM (GEV)          
C          Q2     = FINAL FERMION FOUR MOMENTUM                
C          Q1C    = CRUDE FINAL FERMION FOUR MOMENTUM (GEV)          
C          Q2C    = CRUDE FINAL FERMION FOUR MOMENTUM                
C          WT1    = THE WEIGHT - PHASE SPACE LIMITS FOR VERY HARD PHOT.
C          WT2    = THE WEIGHT - TRANSLATION JACOBIAN.         
C          WTM    = The list of mass weights. 
!----------------------------------------------------------------------   
! Adapted for WW process by: Wieslaw Placzek     Knoxville, June 1996
! Last update: 26.11.2000       by: WP
!----------------------------------------------------------------------    
C     **************************************  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)     
      PARAMETER(PI=3.1415926535897932D0)    
      DIMENSION PHOT(100,4),PHSU(4),MK(100),WTM(100),Q1(4),Q2(4)
      DIMENSION Q1C(4),Q2C(4)
      DIMENSION RR(100),XK(100),CGX(100),SGX(100)              
      COMMON / INOUT  / NINP,NOUT       
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT
      COMMON / PHYPAR / ALFINV,GPICOB  
      SAVE / INOUT  /,/ KEYYFS /,/ PHYPAR /
      DOUBLE PRECISION DRVEC(100)

C KEYCMS =0 INHIBITS TRANSFORMATION TO CMS    
C INITIALIZATIONS            
      UU= -1D0               
      WT1=1.D0               
      WT2=1.D0               
      AMFIN = xm0
      AM2= 4.D0*AMFIN**2/SVAR                 
      DO 10 I=1,100          
      RR(I)=0.D0             
   10 MK(I)=0                
      DO 20 K=1,4            
      PHSU(K)=0.D0           
      Q1(K)=0.D0             
      Q2(K)=0.D0             
      Q1C(K)=0.D0             
 20   Q2C(K)=0.D0             
      DO 21 I=1,100          
      DO 21 K=1,4            
   21 PHOT(I,K)=0.D0         
C GENERATE PHOTON MULTIPLICITY, AVERG = AVERAGE MULTIPLICITY (CRUDE)
!WP      BETF2 = 2/PI/ALFINV*DLOG(SVAR/AMFIN**2)
!WP----------------------------------------------------                  
      bt0 = SQRT(1 - AM2)
      bb0 = (1 + bt0**2)/2/bt0
      BETF2 = 2/PI/ALFINV *bb0*LOG( (1+bt0)/(1-bt0) )
!------------------------------------------------------
      AVERG = BETF2*DLOG(1/DELTA)             
      NMAX=50                
    5 CONTINUE               
      CALL POISSG(AVERG,NMAX,NPHOT,RR) 
C This is for tests of program at fixed multiplicity (for adv. users)
      NPHFIX =  MOD(KEYBRM,100000)/10000      
      IF(NPHFIX.NE.0.AND.NPHOT.NE.NPHFIX) GOTO 5               
      IF(NPHOT.EQ.0) THEN    
          SPRIM=SVAR 
!WP: Real particle 4-momenta
          xm1s = xm1**2
          xm2s = xm2**2  
          Ene1 = (SPRIM + xm1s - xm2s)/2/SQRT(SPRIM)
          qmod = SQRT(Ene1**2 - xm1s)
          Q1(3) = qmod
          Q1(4) = Ene1
          Q2(3) =-qmod
          Q2(4) = SQRT(SPRIM) - Ene1
!WP: Crude particle 4-momenta
          Ene0 = SQRT(SPRIM)/2
          qmd0 = SQRT(Ene0**2 - xm0**2)
          Q1C(3) = qmd0
          Q1C(4) = Ene0
          Q2C(3) =-qmd0
          Q2C(4) = Ene0
      ELSE                   
C BEGIN WITH PHOTON ENERGY   
          XSUM=0.D0          
          DO  50 I=1,NPHOT   
          XK(I)=DELTA**RR(I)                  
          IF(XK(I).LT.SQRT(10.D0)*DELTA) MK(I)=1               
   50     XSUM=XSUM+XK(I)    
          IF(XSUM.GE.1.D0) GOTO 900           
          DO 60 I=1,NPHOT    
   60     XK(I)=XK(I)/(1.D0-XSUM)             
          DO 100 I=1,NPHOT   
C ...Photons close to low energy boundry marked for further control
          CALL VARRAN(DRVEC,2)
          RN1 = DRVEC(1)
          RN2 = DRVEC(2)
C ...Simplified photon angular distribution,  
C ...s'->s and m**2/(kp)**2 dropped           
C ...CG=cos(theta) and SG=sin(theta) memorized to avoid rounding err.
!WP          CALL ANGBRE(RN1,AM2,CG,SG,WTM(I),DIS1)
!WP----------------------------------------------------   
          CALL ANGBRE(RN1,AM2,CG,SG,DIS0,DIS1)  
          WTM(I) = DIS0 *2*(1+bt0**2)
!------------------------------------------------------
          PHI=2.D0*PI*RN2    
C ...Define photon momenta (in units of sqrt(s')/2 )           
          PHOT(I,1)=XK(I)*SG*COS(PHI)         
          PHOT(I,2)=XK(I)*SG*SIN(PHI)         
          PHOT(I,3)=XK(I)*CG                  
          PHOT(I,4)=XK(I)    
          DO 70 K=1,4        
   70     PHSU(K)=PHSU(K)+PHOT(I,K)           
          CGX(I)=CG          
          SGX(I)=SG          
  100     CONTINUE           
C ...Determine rescaling factor and s', WT2 is dilatation Jacobian 
          XMK2 = PHSU(4)**2-PHSU(3)**2-PHSU(2)**2-PHSU(1)**2   
          YY   = 1.D0/(1.D0 +PHSU(4) +XMK2/4.D0 )              
          WT2  = YY*(1.D0+PHSU(4))            
          SPRIM= SVAR*YY   
C ...reject events with too hard photons      
!WP          SMINI= 4*AMFIN**2  
          SMINI = (xm1 + xm2)**2
          IF(SPRIM.LE.SMINI) GOTO 900  
C ...rescale properly all photon momenta      
          ENER = SQRT(SPRIM)/2.D0             
          DO 120 K=1,4       
          PHSU(K)= PHSU(K)*ENER               
          DO 120 I=1,NPHOT   
  120     PHOT(I,K)=PHOT(I,K)*ENER 
!WP---------------------------------------------------------
! Final particle 4-momenta
          xm1s = xm1**2
          xm2s = xm2**2  
          Ene1 = (SPRIM + xm1s - xm2s)/2/SQRT(SPRIM)
          qmod = SQRT(Ene1**2 - xm1s)
          Q1(3) = qmod
          Q1(4) = Ene1
          Q2(3) =-qmod
          Q2(4) = SQRT(SPRIM) - Ene1
!WP: Crude particle 4-momenta
          Ene0 = SQRT(SPRIM)/2
          qmd0 = SQRT(Ene0**2 - xm0**2)
          Q1C(3) = qmd0
          Q1C(4) = Ene0
          Q2C(3) =-qmd0
          Q2C(4) = Ene0
!------------------------------------------------------------           
C-----------Mass weight---------------------  
C ...This weight compensates for s->s' and droping terms -m**2/(k.q)**2 
C ...care is taken of machine rounding errors                  
!WP          AMF= 4.D0*AMFIN**2/SPRIM            
!WP          BTF =SQRT(1.D0-AMF)
!WP-------------------------------------------------------------------- 
          rm1 = ( xm1/Q1(4) )**2
          rm2 = ( xm2/Q2(4) )**2
          bt1 = SQRT(1 - rm1)
          bt2 = SQRT(1 - rm2)
          rq12 = 2*(1 + bt1*bt2)
!----------------------------------------------------------------------
          DO 200 I=1,NPHOT   
!WP          IF( CGX(I).GT.0.D0 ) THEN           
!WP              DEL2=1.D0+BTF*CGX(I)            
!WP              DEL1= (SGX(I)**2 + AMF*CGX(I)**2)/DEL2           
!WP          ELSE               
!WP              DEL1=1.D0-BTF*CGX(I)            
!WP              DEL2= (SGX(I)**2 + AMF*CGX(I)**2)/DEL1           
!WP          ENDIF              
!WP          DIST1=1/DEL1/DEL2                   
!WP     $            -AMF/(1.D0+BTF )/2.D0*(1.D0/DEL1**2+1.D0/DEL2**2)
!WP--------------------------------------------------------------------
             del1 = 1 - bt1*CGX(I)
             del2 = 1 + bt2*CGX(I)
             rdel = del1/del2
             DIST1 = rq12/del1/del2 *( 1 - (rm1/rdel + rm2*rdel)/rq12 )
!----------------------------------------------------------------------
          IF(DIST1.LT.0.D0) THEN              
              DIST1=0D0 
              WRITE(NOUT,*) ' +++++++ MBREF: NEGATIVE WTMAS =',DIST1
              WRITE(   6,*) ' +++++++ MBREF: NEGATIVE WTMAS =',DIST1
          ENDIF              
          WTM(I)= DIST1/WTM(I)                
          IF(WTM(I).LT. 1.D-20) WTM(I)= 0.D0  
  200     CONTINUE           
      ENDIF   
      UU   = 1 - SPRIM/SVAR                   
!WP      ENER= SQRT(SPRIM)/2.D0                  
!WPC FINAL FERMION MOMENTA      
!WP      Q1(4)=ENER             
!WP      Q1(3)=SQRT(ENER**2-AMFIN**2)            
!WP      Q2(4)=ENER             
!WP      Q2(3)=-Q1(3)
      RETURN                 
C EVENT OUTSIDE PHASE SPACE                   
  900 WT1=0.D0               
      WT2=1.D0               
      NPHOT=-1               
      END 
                   
      SUBROUTINE KINF1(XXF,Q1,Q2,Q1C,Q2C,NPHOT,PHOT,PHSU)              
C     ***************************************************              
C Transforms to CMS: PHOT, PHSU, Q1,Q2,Q1C,Q2C        
C with random Euler rotation in XXF frame 
!----------------------------------------------------------------------   
! Adapted for WW process by: Wieslaw Placzek     Knoxville, June 1996
! Last update: 20.11.2000       by: WP
!----------------------------------------------------------------------    
C     ***********************************     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)     
      PARAMETER( PI = 3.1415926535897932D0)
!WP: Angles from Born-level presampler
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWANGL /
      DIMENSION XXF(4),PHOT(100,4),PHSU(4),Q1(4),Q2(4)         
      DIMENSION Q1C(4),Q2C(4)
      DIMENSION PH(4),PP(4),DRVEC(100)                   

      IF(NPHOT.EQ.-1) RETURN                  
!WP      CALL VARRAN(DRVEC,2)
!WP      RN1 = DRVEC(1)
!WP      RN2 = DRVEC(2)
!WP      CTH= 1.D0 -2.D0*RN1 
      CTH = ctn
      THE= ACOS(CTH)         
!WP      PHI= 2.D0*PI*RN2
      PHI = PI/2 + fin
      DO 210 K=1,4           
  210 PP(K)=Q1(K)+Q2(K)+PHSU(K)               
      DO 230 I=1,NPHOT       
          DO 220 K=1,4       
  220     PH(K)=PHOT(I,K)    
          CALL BOSTDQ(  1, PP,PH,PH)          
          CALL ROTEUL(THE,PHI,PH,PH)          
          CALL BOSTDQ( -1,XXF,PH,PH)          
          DO 225 K=1,4       
  225     PHOT(I,K)= PH(K)   
  230 CONTINUE               
!WP: Real particles 4-momenta
      CALL BOSTDQ(  1, PP,Q1,Q1)              
      CALL ROTEUL(THE,PHI,Q1,Q1)              
      CALL BOSTDQ( -1,XXF,Q1,Q1)              
      CALL BOSTDQ(  1, PP,Q2,Q2)              
      CALL ROTEUL(THE,PHI,Q2,Q2)              
      CALL BOSTDQ( -1,XXF,Q2,Q2)              
!WP: Crude particles 4-momenta
      CALL BOSTDQ(  1, PP,Q1C,Q1C)              
      CALL ROTEUL(THE,PHI,Q1C,Q1C)              
      CALL BOSTDQ( -1,XXF,Q1C,Q1C)              
      CALL BOSTDQ(  1, PP,Q2C,Q2C)              
      CALL ROTEUL(THE,PHI,Q2C,Q2C)              
      CALL BOSTDQ( -1,XXF,Q2C,Q2C)              
!WP: Photon sum 4-momentum
      CALL BOSTDQ(  1, PP,PHSU,PHSU)          
      CALL ROTEUL(THE,PHI,PHSU,PHSU)          
      CALL BOSTDQ( -1,XXF,PHSU,PHSU)          
      END  
                  
      SUBROUTINE ROTEUL(THE,PHI,PVEC,QVEC)    
C     ************************************    
C EULER ROTATION             
      IMPLICIT REAL*8(A-H,O-Z)                
      REAL*8 PVEC(4),QVEC(4)                  
      CALL ROTOD1(THE,PVEC,QVEC)              
      CALL ROTOD3(PHI,QVEC,QVEC)              
      END 
                   
      SUBROUTINE GIBEA(CMSENE,AMEL,P1,P2)     
C     ***********************************     
C GIVEN CMS ENERGY (CMSENE) DEFINES BEAM MOMENTA IN CMS        
C     ***********************************     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)     
      DIMENSION P1(*),P2(*)                   
      BETEL=SQRT(1D0-4D0*AMEL**2/CMSENE**2)   
      P1(1)=  0D0            
      P1(2)=  0D0            
      P1(3)=  CMSENE/2D0*BETEL                
      P1(4)=  CMSENE/2D0     
      P2(1)=  0D0            
      P2(2)=  0D0            
      P2(3)= -CMSENE/2D0*BETEL                
      P2(4)=  CMSENE/2D0     
      END 
                   
      SUBROUTINE KINF2(XXF,AMFIN,Q1,Q2)       
C     ************************************    
C ...Generates two body phase space with uniform spherical density 
C ...For pure Born case (no bremss.)          
C     ***********************************     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)     
      PARAMETER( PI = 3.1415926535897932D0)               
      DIMENSION XXF(*),Q1(*),Q2(*),DRVEC(100)            

      CMSENE= SQRT(XXF(4)**2-XXF(3)**2-XXF(2)**2-XXF(1)**2)    
      CALL VARRAN(DRVEC,2)
      RN1 = DRVEC(1)
      RN2 = DRVEC(2)
      CTH= 1.D0 -2.D0*RN1    
      THE= ACOS(CTH)         
      PHI= 2.D0*PI*RN2       
      CALL GIBEA(CMSENE,AMFIN,Q1,Q2)          
      CALL ROTEUL(THE,PHI,Q1,Q1)              
      CALL BOSTDQ( -1,XXF,Q1,Q1)              
      CALL ROTEUL(THE,PHI,Q2,Q2)              
      CALL BOSTDQ( -1,XXF,Q2,Q2)              
C======================================================================
C=====================End of KarFin part===============================
C======================================================================
      END
                    
      SUBROUTINE POISSG(AVERG,NMAX,MULT,RR)
C     ************************************** 
C Last corr. Nov. 91              
C This generates photon multipl. NPHOT according to Poisson distr. 
C INPUT:  AVERG = AVERAGE MULTIPLICITY   
C         NMAX  = MAXIMUM MULTIPLICITY   
C OUTPUT: MULT = GENERATED MULTIPLICITY 
C         RR(1:100) LIST OF ORDERED UNIFORM RANDOM NUMBERS, 
C         A BYPRODUCT RESULT, TO BE EVENTUALLY USED FOR SOME FURTHER
C         PURPOSE (I.E.  GENERATION OF PHOTON ENERGIES). 
C     ************************           
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DIMENSION RR(*)                    
      COMMON / INOUT  / NINP,NOUT  
      SAVE   / INOUT  /
      DOUBLE PRECISION DRVEC(100)
      SAVE NFAIL
      DATA NFAIL/0/                      
   50 NN=0                               
      SUM=0D0                            
      DO 100 IT=1,NMAX                   
      CALL VARRAN(DRVEC,1)
      RN = DRVEC(1)
      Y= LOG(RN)                         
      SUM=SUM+Y                          
      NN=NN+1                            
      RR(NN)=SUM/(-AVERG)                
      IF(SUM.LT.-AVERG) GOTO 130         
  100 CONTINUE                           
      NFAIL=NFAIL+1                      
      IF(NFAIL.GT.100) GOTO 900          
      GOTO 50                            
  130 MULT=NN-1                         
      RETURN                             
  900 WRITE(NOUT,*) ' POISSG: TO SMALL NMAX'
      STOP                               
      END                                

      SUBROUTINE ANGBRE(RN1,AM2,COSTHG,SINTHG,DIST0,DIST1)
C     **************************************************** 
C THIS ROUTINE GENERATES PHOTON ANGULAR DISTRIBUTION 
C IN THE REST FRAME OF THE FERMION PAIR. 
C THE DISTRIBUTION IS TAKEN IN THE INFRARED LIMIT.
C GENERATES WEIGHTED EVENTS              
C INPUT:  AM2 = 4*MASSF**2/S WHERE MASSF IS FERMION MASS
C         AND S IS FERMION PAIR EFFECTIVE MASS.
C OUTPUT: COSTHG, SINTHG, COS AND SIN OF THE PHOTON 
C         ANGLE WITH RESPECT TO FERMIONS DIRECTION 
C         DIST0 = distribution  generated without m**2/(kp)**2 terms
C         DIST1 = distribution  with m**2/(kp)**2 terms 
C     *************************************** 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION DRVEC(100)
      BETA=SQRT(1.D0-AM2)                
      EPS=AM2/(1.D0+BETA)      
      DEL1=(2.D0-EPS)*(EPS/(2.D0-EPS))**RN1 
      DEL2=2.D0-DEL1                     
C SYMMETRIZATION                         
      CALL VARRAN(DRVEC,1)
      RN2 = DRVEC(1)
      IF(RN2.LE.0.5D0) THEN              
        A=DEL1                           
        DEL1=DEL2                        
        DEL2=A                           
      ENDIF                              
      DIST0=1D0/DEL1/DEL2                
      DIST1=DIST0-EPS/2.D0*(1D0/DEL1**2+1D0/DEL2**2)
C CALCULATION OF SIN AND COS THETA FROM INTERNAL VARIABLES 
      COSTHG=(1.D0-DEL1)/BETA            
      SINTHG=SQRT(DEL1*DEL2-AM2)/BETA    
      END                                

      SUBROUTINE GIFYFS(P1,P2,FYFS)       
C     *****************************       
C YFS formfactor       
C     *****************************       
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DIMENSION P1(*),P2(*)               
      PARAMETER( PI=3.1415926535897932D0, ALFINV=137.03599976D0)
      PARAMETER( ALF1=1D0/ALFINV/PI)
                  
      SVAR   = (P1(4)+P2(4))**2-(P1(3)+P2(3))**2             
     $        -(P1(2)+P2(2))**2-(P1(1)+P2(1))**2             
      AMS    = P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2           
      BILG  =  DLOG(SVAR/AMS)             
      BETA  =  2*ALF1*(BILG-1)            
      DELB  =  BETA/4 + ALF1*(-0.5D0  + PI**2/3D0)            
      FYFS  =  EXP(DELB)                  
      END              

      FUNCTION BREMKF(KEY,EREL)                  
C     *************************         
C NON-MONTECARLO INTEGRATION OF THE V-DISTRIBUTION            
C GAUSS METHOD, CHANGE OF VARIABLES WITH HELP OF CHBIN1       
C SEE VVDISB              
C KEY= 1,2,3,...FOR VARIOUS DISTRIBUTIONS   
C KEY= 3 FOR MC GENERATION, OTHER FOR TESTS                   
C FOR KEYFIX=1, EXEPTIONALLY, IT PROVIDES INTEGRAND AT VV=VVMAX 
C WITH BORN OMITTED       
C     ************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON / KEYYFS / KEYZEE,KEYBRM,KEYFIX,KEYRED,KEYWGT    
C COMMON KEYDST COMMUNICATES ONLY WITH VVDISB - INTEGRAND FUNCTION 
      COMMON / KEYDST / KEYDIS              
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI                   
      SAVE / KEYYFS /,/ KEYDST /,/ WEKING /,/ VVREC  /
      EXTERNAL VVDISB     
C       
      KEYDIS=KEY          
      IF(KEYFIX.EQ.0) THEN  
         SVAR  = 4D0*ENE**2
         SVAR1 = SVAR
         XBORN  =BORNY(SVAR,SVAR1)          
         PREC=  XBORN*EREL                  
         XA= 0D0          
         XB= 1D0
         CALL GAUSJD(VVDISB,XA,XB,PREC,RESULT)
         BREMKF=RESULT          
      ELSE                
         SVAR  = 4D0*ENE**2
         BREMKF= VVRHO(KEYDIS,SVAR,AMEL,VVMAX,VVMIN)
     $          /VVRHO(     9,SVAR,AMEL,VVMAX,VVMIN)          
      ENDIF               
      END                 

      FUNCTION VVDISB(R)                    
C     ******************                    
C INTEGRAND FOR BREMKF    
C MAPPING XX => VV CHANGE  TO IMPROVE ON EFFICIENCY           
C     ************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER( FLEPS =1D-35)              
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI                   
      COMMON / KEYDST / KEYDIS              
      SAVE / WEKING /,/ VVREC  /,/ KEYDST /
C       
      KEYD=KEYDIS         
      X = MAX(R,FLEPS**BETI)                
      ALF=  BETI          
      BET=  1D0           
C ...SPECIAL CASES        
C ...Monte Carlo crude distr                
      IF    (KEYD.EQ.1)  THEN               
        BET=  -0.5D0      
C ...YFS exponentiation beta0,1,2 contribs  
      ELSEIF(KEYD.EQ.310)  THEN              
        ALF=  BETI        
      ELSEIF(KEYD.EQ.311)  THEN             
        ALF=  BETI +1     
      ELSEIF(KEYD.EQ.320)  THEN              
        ALF=  BETI        
      ELSEIF(KEYD.EQ.321)  THEN             
        ALF=  BETI +1     
      ELSEIF(KEYD.EQ.322)  THEN             
        ALF=  BETI +2     
C ...Reference distr including dilatation factor DAMEL        
      ELSEIF(KEYD.EQ.12) THEN               
        BET=  -0.5        
      ENDIF               
      CALL CHBIN1(X,ALF,BET,VVMAX,VV,RJAC)                
C BORN XSECTION           
C NOTE 1/(1-VV) FACTOR BECAUSE BORNY IS IN R-UNITS            
      SVAR   = 4D0*ENE**2
      SVAR1  = SVAR*(1D0-VV)                 
      XBORN  = BORNY(SVAR,SVAR1)/(1D0-VV)         
      VVDISB = VVRHO(KEYD,SVAR,AMEL,VV,VVMIN) *RJAC*XBORN          
      END                 

      FUNCTION VVRHO(KEYDIS,SVAR,AMEL,VV,VVMIN) 
C     *****************************************
C-------------------------------------------------------------
C Convention for KEYDIS      
C Pedagogical exercises
C     KEYDIS   =  1      crude distribution for initial state MC
C     KEYDIS   =  9      reference distr.  of YFS2 CPC paper 
C     KEYDIS   =  50-52  obsolete test distr. for YFS2 CPC paper 
C     KEYDIS   =  101    soft part YFS       First  Order
C     KEYDIS   =  102    soft part YFS       Second Order
C     KEYDIS   =  105    hard non-exp.       First  Order
C     KEYDIS   =  106    hard non-exp.       Second Order
C Total results
C     KEYDIS   =  0 + R*100                  Zero   Order     
C     KEYDIS   =  1 + R*100                  First  Order     
C     KEYDIS   =  2 + R*100                  Second Order     
C     KEYDIS   = 15     reference distr. of YFS paper
C Beta contributions
C     KEYDIS   = 10 + R*100      Beta0       Zero   Order        
C     KEYDIS   = 11 + R*100      Beta0       First  Order        
C     KEYDIS   = 12 + R*100      Beta1            
C     KEYDIS   = 20 + R*100      Beta0       Second Order        
C     KEYDIS   = 21 + R*100      Beta1            
C     KEYDIS   = 22 + R*100      Beta2        
C     R = 200 Kuraev-Fadin   
C     R = 300 YFS (pragmatic)           
C     R = 400 YFS single electron LL str. funct.          
C-------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(PI= 3.1415926535897932D0, ALFINV=137.03599976D0) 
      PARAMETER(ALF1   = 1D0/PI/ALFINV)
      PARAMETER(CEULER =0.57721566D0)       
      COMMON / INOUT  / NINP,NOUT     
      SAVE   / INOUT  /
C           
      KEYD = KEYDIS           
      BILG   = DLOG(SVAR/AMEL**2)           
      BETI   = 2D0*ALF1*(BILG-1D0)          
C===================================================================
C ---------------------- KEYD = 1 ----------------------------------
C ---- Crude distribution in YFS2 initial state Monte Carlo --------
C ------------------------------------------------------------------
c dilat is related to dilatation jacobian in yfsgen                
c damel is responsible for modification of photon ang. distribution
c see also weight wt=wt1 in   angbre                               
      IF(KEYD.GE.1.AND.KEYD.LT.100) THEN
         DILAT=1D0           
         IF(VV.GT.VVMIN) DILAT=(1D0+1D0/SQRT(1D0-VV))/2D0        
         BETI2  = 2D0*ALF1*BILG                
         DAMEL=1D0           
         IF(VV.GT.VVMIN) DAMEL=BETI2/BETI*(VV/VVMIN)**(BETI2-BETI)
C---------
         IF    (KEYD.EQ.1)  THEN               
            DISTR= BETI*VV**(BETI-1D0)*DILAT*DAMEL       
C ...Reference distribution used in YFS2 paper --------------------
         ELSEIF(KEYD.EQ. 9)  THEN   
            DISTR= BETI*VV**(BETI-1D0)*(1+(1-VV)**2)/2               
C basic reference distribution  xrefer=sigma-ref                
         ELSEIF(KEYD.EQ.50) THEN   
            DISTR= BETI*VV**(BETI-1D0)             
C XREFER TIMES DAMEL            
         ELSEIF(KEYD.EQ.51) THEN   
            DISTR= BETI*VV**(BETI-1D0)*DAMEL       
C XREFER TIMES DILATATION FACTOR DILAT          
         ELSEIF(KEYD.EQ.52) THEN   
            DISTR= BETI*VV**(BETI-1D0)*DILAT
         ENDIF       
C ------------------------------------------------------------
C ------------- Soft part only  -- YFS exponentiation         
C ------------------------------------------------------------
      ELSEIF(KEYD.GE. 101.AND.KEYD.LE.102) THEN     
         DELB   = ALF1*(0.5D0*BILG -1D0  +PI**2/3D0)          
         GAMFAC =EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)           
C ....first order             
         IF(KEYD  .EQ. 101) THEN              
            DELS = ALF1*(BILG-1D0)          
C ....Second Order            
         ELSEIF(KEYD  .EQ. 102) THEN          
            DELS = ALF1*(BILG-1D0) +0.5D0*(ALF1*BILG)**2      
         ENDIF                
         DISTR=  GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*( 1D0+DELS)
C ---------------------------------------------------------------
C ------------- Hard part only - no exponentiation              
C ---------------------------------------------------------------
      ELSEIF(KEYD.GE. 105.AND.KEYD.LE.106 ) THEN   
         Z=1D0-VV                
C ....First  Order               
         IF(KEYD  .EQ. 105) THEN   
            DISTR =  BETI*(1D0 +Z**2)/2D0/VV   
C ....Second Order               
         ELSEIF(KEYD  .EQ. 106) THEN             
            DIST1 =  BETI*(1D0 +Z**2)/2D0/VV   
            DELH2 =  (ALF1*BILG)**2*(          
     $             -(1D0+Z*Z)/VV*DLOG(Z)       
     $              +(1D0+Z)*(0.5D0*DLOG(Z)-2D0*DLOG(VV))        
     $              -2.5D0-0.5D0*Z  )          
            DIST2 =  (ALF1*BILG)**2*( 3 +4*DLOG(VV))/VV +DELH2   
            DISTR =  DIST1+DIST2 
         ENDIF 
C ---------------------------------------------------------------
C ---------------------------------------------------------------
C ----- exponentiation following Kuraiev Fadin prescription 
C ---------------------------------------------------------------
      ELSEIF(KEYD.GE.201.AND.KEYD.LE.202) THEN 
C First Order  from Gerrit Burgers (POLARIZATION BOOK)           
         DZ2 = PI**2/6D0         
         Z=1D0-VV                
         IF(KEYD  .EQ.201) THEN  
            DELVS= ALF1*(1.5D0*BILG +2D0*DZ2-2D0)                
            DELH=  -ALF1*(1D0+Z)*(BILG-1D0)    
         ELSEIF(KEYD  .EQ.202) THEN            
            DELVS= ALF1*(1.5D0*BILG +2D0*DZ2-2D0)                
     $            +ALF1**2*(9D0/8D0-2D0*DZ2)*BILG**2             
            DELH=  -ALF1*(1D0+Z)*(BILG-1D0)    
     $      +ALF1**2*( -(1D0+Z*Z)/VV     *DLOG(Z)                
     $              +(1D0+Z)*(0.5D0*DLOG(Z)-2D0*DLOG(VV))        
     $              -2.5D0-0.5D0*Z)*BILG**2    
         ENDIF 
         DISTR=  BETI*VV**(BETI-1D0)*( 1D0+DELVS) +DELH          
C ---------------------------------------------------------------
C ------------- YFS ad-hoc exponentiation -----------------------
C ---------------------------------------------------------------
      ELSEIF(KEYD.GE.300.AND.KEYD.LE.302) THEN 
         DELB   = ALF1*(0.5D0*BILG -1D0  +PI**2/3D0)             
         GAMFAC =EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)              
C ....Zero   Order               
         IF(KEYD  .EQ.300)  THEN 
            DELS = 0D0           
            DELH = -BETI/4 *LOG(1-VV)          
C ....First  Order               
         ELSEIF(KEYD  .EQ.301)  THEN           
            DELS = BETI/2        
            DELH = VV*(-1 +VV/2) 
     $      -BETI/2*VV**2 - BETI/4*(1-VV)**2*LOG(1-VV)           
C ....Second Order               
         ELSEIF(KEYD  .EQ.302)  THEN           
            DELS = ALF1*(BILG-1D0) +0.5D0*(ALF1*BILG)**2         
            DELH = VV*(-1D0+VV/2D0)            
     $      +ALF1*BILG*(-0.25D0*(4D0-6D0*VV+3D0*VV**2)*DLOG(1D0-VV) -VV)
         ENDIF        
         DISTR= GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*(1 +DELS + DELH )  
C----------------------------------------------------------------   
C-------------- YFS ad-hoc exponentiation -----------------------
C-------------Contributions  from various beta's ---------------- 
C---------------------------------------------------------------- 
      ELSEIF(KEYD.GE.310.AND.KEYD.LE.322)  THEN       
         DELB   = ALF1*(0.5D0*BILG -1D0  +PI**2/3D0)  
         GAMFAC = EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)  
         SOFT   = 0D0 
         DELH   = 0D0 
C ...Beta0 First  Order                 
         IF(KEYD.EQ.310) THEN           
            SOFT = 1 + BETI/2           
            DELH = -BETI/4 *LOG(1-VV)   
C ...Beta1 First  Order                 
         ELSEIF(KEYD.EQ. 311)  THEN     
            DELH =    
     $      VV*(-1D0+VV/2/(1+BETI))*(1-0.5*BETI*LOG(1-VV)) 
C ...Beta0 Second Order                 
         ELSEIF(KEYD.EQ.320) THEN       
            SOFT = 1 + BETI/2  +BETI**2/8             
            DELH = -BETI/4 *LOG(1-VV)   
C ...Beta1 Second Order                 
         ELSEIF(KEYD.EQ. 321)  THEN     
            DELH = VV*(-1+VV/2)         
     $      -BETI*VV/2 -BETI*VV**2/4 +BETI/8*(-2+6*VV-3*VV**2)*LOG(1-VV)
C ...Beta2 Second Order                 
         ELSEIF(KEYD.EQ. 322)  THEN     
            DELH =    BETI*  VV**2/4D0  
         ENDIF        
         DISTR=  GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*(SOFT+DELH)       
C -------------------------------------------------------------------   
C -------------------YFS formula-------------------------------------   
C -------------Single fermion LL fragmentation ----------------------   
C -------------------------------------------------------------------   
      ELSEIF(KEYD.GE.400.AND.KEYD.LE.402)  THEN       
C&&&&&&  DELB   = BETI/4                
         DELB   = BETI/4  +ALF1*(-0.5D0  +PI**2/3D0)  
         GAMFAC = EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)  
         SOFT   = 0D0 
         DELH   = 0D0 
C ...Zero   Order     
         IF(KEYD.EQ.400) THEN           
            SOFT = 1  
C ...First  Order     
         ELSEIF(KEYD.EQ.401) THEN       
            SOFT = 1 + BETI/2           
            DELH =    
     $      VV*(-1D0+VV/2/(1+BETI))     
C ...Second Order     
         ELSEIF(KEYD.EQ.402) THEN       
            SOFT = 1 + BETI/2  +BETI**2/8             
C           DELH =    
C    $      VV*(1+0.5*BETI)*(-1D0+VV/2/(1+BETI))      
C    $      -0.50*BETI*LOG(1-VV)*0.5*(1+(1-VV)**2)    
C    $      + BETI/4D0*VV*(VV +(1-VV/2)*DLOG(1D0-VV)) 
            DELH =    
     $      VV*(-1D0+VV/2)              
     $      + BETI*(-VV/2 -(1+3*(1-VV)**2)/8*DLOG(1D0-VV))              
         ENDIF  
         DISTR=  GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*(SOFT+DELH)       
C -------------------------------------------------------------------   
C -------------Single fermion LL fragmentation ----------------------   
C -------------Contributions  from various beta's -------------------   
C -------------------------------------------------------------------   
      ELSEIF(KEYD.GE.400.AND.KEYD.LE.422)  THEN       
C&&&&&   DELB   = BETI/4                
         DELB   = BETI/4  +ALF1*(-0.5D0  +PI**2/3D0)  
         GAMFAC = EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)  
         SOFT   = 0D0 
         DELH   = 0D0 
C ...Beta0 zero   Order                 
         IF(KEYD.EQ.400) THEN           
            SOFT = 1  
C ...Beta0 First  Order                 
         ELSEIF(KEYD.EQ.410) THEN       
            SOFT = 1 + BETI/2           
C ...Beta1 First  Order                 
         ELSEIF(KEYD.EQ. 411)  THEN     
            DELH =    
     $      VV*(-1D0+VV/2/(1+BETI))     
C ...Beta0 Second Order                 
         ELSEIF(KEYD.EQ.420) THEN       
            SOFT = 1 + BETI/2  +BETI**2/8             
C ...Beta1 Second Order                 
         ELSEIF(KEYD.EQ. 421)  THEN     
            DELH =    
     $      VV*(1+0.5*BETI)*(-1D0+VV/2/(1+BETI))      
     $      -0.50*BETI*LOG(1-VV)*0.5*(1+(1-VV)**2)    
C ...Beta2 Second Order                 
         ELSEIF(KEYD.EQ. 422)  THEN     
            DELH = BETI/4D0*VV*(VV +(1-VV/2)*DLOG(1D0-VV))              
         ELSE   
            GOTO 900          
         ENDIF  
         DISTR=  GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*(SOFT+DELH) 
C ----------------------------------------------------------------
C -------------Single fermion LL fragmentation -------------------
C -------------I N F I N I T E   O R D E R -----------------------
C ----------------------------------------------------------------
      ELSEIF(KEYD.EQ.502)  THEN   
         DELB   = BETI*0.75D0     
         GAMFAC = EXP(-CEULER*BETI)/DPGAMM(1D0+BETI)               
         SOFT   = 1           
         DELH =  
     $   VV*(-1D0+VV/2)            
     $   + BETI*(-VV**2/4 -(1+3*(1-VV)**2)/8*DLOG(1D0-VV))         
         DISTR=  GAMFAC*EXP(DELB)*BETI*VV**(BETI-1D0)*(SOFT+DELH)  
      ELSE       
         GOTO 900             
      ENDIF      
      VVRHO = DISTR                
      RETURN    
 900  WRITE(6,*) ' ===--->  WRONG KEYDIS IN VVRHO',KEYD 
      STOP       
      END        

      SUBROUTINE DUMPS(NOUT)                 
C     **********************                 
C THIS PRINTS OUT FOUR MOMENTA OF PHOTONS    
C ON UNIT NO. NOUT   
!WP: This is for Off-Shell WW                        
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      COMMON / MOMWWP / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT  
      SAVE   / MOMWWP /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=====================DUMPS===================='
      WRITE(NOUT,3100) 'Q1 ',(  QF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'Q2 ',(  QF2(  K),K=1,4) 
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(SPHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=QF1(K)+QF2(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+SPHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.12)               
      END                                    

      SUBROUTINE DUMPW(NOUT)                 
C     **********************                 
C THIS PRINTS OUT FOUR MOMENTA OF PHOTONS    
C ON UNIT NO. NOUT                           
!WP: This is for On-Shell WW                        
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      COMMON / MOMSET / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT  
      SAVE   / MOMSET /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=====================DUMPW===================='
      WRITE(NOUT,3100) 'Q1 ',(  QF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'Q2 ',(  QF2(  K),K=1,4) 
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(SPHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=QF1(K)+QF2(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+SPHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.12)               
      END                                    

      SUBROUTINE DUMPF(NOUT)                 
C     **********************                 
C THIS PRINTS OUT FOUR MOMENTA OF PHOTONS    
C ON UNIT NO. NOUT                           
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      COMMON / MOMFIN / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT
      SAVE   / MOMFIN /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=====================DUMPF====================' 
      WRITE(NOUT,3100) 'QF1',(  QF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'QF2',(  QF2(  K),K=1,4)  
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(SPHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=QF1(K)+QF2(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+SPHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.14)               
      END                                    

      SUBROUTINE DUMPI(NOUT)                 
C     **********************                 
C THIS PRINTS OUT FOUR MOMENTA OF PHOTONS    
C ON UNIT NO. NOUT                           
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT 
      SAVE   / MOMINI /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=====================DUMPI===================='
      WRITE(NOUT,3100) 'QF1',(  QF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'QF2',(  QF2(  K),K=1,4) 
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(SPHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=QF1(K)+QF2(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+SPHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.14)               
      END                                    

      SUBROUTINE DUMPN(NOUT,IEV)                 
C     **************************                 
C THIS PRINTS OUT FOUR MOMENTA OF final state     
C and the serial number of event IEV on unit NOUT
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      COMMON / MOMINI / QF1(4),QF2(4),SPHUM(4),SPHOT(100,4),NPHOT 
      SAVE   / MOMINI /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=============DUMPNEW====================>',IEV
      WRITE(NOUT,3100) 'QF1',(  QF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'QF2',(  QF2(  K),K=1,4) 
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(SPHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=QF1(K)+QF2(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+SPHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.14)               
      END   

      SUBROUTINE KinDec 
*     *****************
!----------------------------------------------------------------------!
! This routine calculates the kinematics of W+W- decays, i.e.          !
! provides 4-momenta of final state fermions (products of W-decays).   !
! The final state fermions 4-momenta are located in:                   !
!     COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),nphot  !
! where pf1, pf2 are 4-momenta of W- decay products, while pf3, pf4    !
! are 4-momenta of W+ decay products.                                  !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                    Knoxville, July 1996 !  
! Last update: 17.10.1999                by: W.P.                      !
!----------------------------------------------------------------------! 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0 )
! This common can be everywhere, contains various switches
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE   / KeyKey /
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)  
!WP: In LPS_a mode /MOMSET/ and / MOMWWP / are identical
!WP: In LPA_b mode /MOMSET/ constains on-shell W 4-momenta (for internal use) 
!WP: while / MOMWWP / the off-shell ones (for constructing the event)
      COMMON / MOMSET / q1(4),q2(4),phsum(4),sphot(100,4),nsphot
      COMMON / MOMWWP / q1w(4),q2w(4),phsos(4),phos(100,4),nphos
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),nphot
      COMMON / DECAYS / IFLAV(4),AMDEC(4)
cav   SAVE   /MOMENT/,/ WGTALL /,/ MOMSET /,/ MOMDEC /
      SAVE   / WGTALL /,/ MOMSET /,/ MOMDEC / !cav
      SAVE   / DECAYS /,/ MOMWWP /
! Angles from Born-level presampler
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWANGL /
! W-/W+ invariant masses squared
      COMMON / WWINVM / sv1,sv2
      SAVE   / WWINVM /
      DIMENSION qww(4),h(4)
!
      nphot  = 0
      DO k = 1,4
        pf1(k) = 0d0
        pf2(k) = 0d0
        pf3(k) = 0d0
        pf4(k) = 0d0
      ENDDO
      IF (WTCRU1*WTCRU2.EQ.0d0) RETURN
      xm1 = SQRT(sv1)
      xm2 = SQRT(sv2)
*! LPA_a mode or LPA_b mode
      KeyLPA = MOD(KeyTek,10000)/1000
!... LPA_a 
      IF (KeyLPA.EQ.0) THEN
         DO k = 1,4
            q1w(k) = q1(k)
            q2w(k) = q2(k)
         ENDDO
!... LPA_b 
      ELSE
         DO k = 1,4
            qww(k) = q1(k) + q2(k)
         ENDDO
         sww = qww(4)**2 - qww(3)**2 - qww(2)**2 - qww(1)**2
         xmww = SQRT(sww)
         IF (xm1+xm2.GE.xmww) THEN
            WTCRU2 = 0
            RETURN
         ENDIF
! Construct off-shell WW 4-momenta in LPA_b mode:
! 1) Find W- angles in WW rest frame
! 2) Calculate momenta of off-shell W's for above angles in WW-frame
! 3) Boost off-shell W's 4-momenta to CMS
         CALL BOSTDQ(1,qww,q1,q1w)
         ct1w = q1w(3)/SQRT(q1w(1)**2 + q1w(2)**2 + q1w(3)**2)
         st1w  = SQRT(1d0 - ct1w**2)
         fi1w = ANGFIX(q1w(1),q1w(2))
         E1w  = (sww + sv1 - sv2)/(2*xmww)
         q1wm = SQRT(E1w**2 - xm1**2)
         q1w(4) = E1w
         q1w(3) = q1wm*ct1w
         q1w(2) = q1wm*st1w*SIN(fi1w)
         q1w(1) = q1wm*st1w*COS(fi1w)
         q2w(4) = xmww - E1w
         q2w(3) =-q1w(3)
         q2w(2) =-q1w(2)
         q2w(1) =-q1w(1)
         CALL BOSTDQ(-1,qww,q1w,q1w)
         CALL BOSTDQ(-1,qww,q2w,q2w)
      ENDIF
! Angular variables
      f1 = fi1n
      f2 = fi2n
      c1 = ct1n
      c2 = ct2n
! Construct pf1 in rest frame of W-             
      p1sq = AMDEC(1)**2
      p2sq = AMDEC(2)**2
      den = 1/(2*xm1)
      h(4) = (sv1 + p1sq - p2sq)*den
      s1s = MAX(0d0,(1d0 - c1)*(1d0 + c1))
      s1 = SQRT(s1s)
      hv = SQRT(h(4)**2 - p1sq)
      h(3) = hv*c1
      h(2) = hv*s1*COS(f1)
      h(1) = hv*s1*SIN(f1)
! Boost vector h to its LAB frame value pf1
      CALL BOSTDQ(-1,q1w,h,pf1)
! Construct pf2 from momentum conservation
      DO k = 1,4
        pf2(k) = q1w(k) - pf1(k)
      ENDDO
! Construct pf3 in rest frame of W+             
      p3sq = AMDEC(3)**2
      p4sq = AMDEC(4)**2
      den = 1/(2*xm2)
      h(4) = (sv2 + p3sq - p4sq)*den
      s2s = MAX(0d0,(1d0 - c2)*(1d0 + c2))
      s2 = SQRT(s2s)
      hv = SQRT(h(4)**2 - p3sq)
      h(3) = hv*c2
      h(2) = hv*s2*COS(f2)
      h(1) = hv*s2*SIN(f2)
! Boost vector h to its LAB frame value pf3
      CALL BOSTDQ(-1,q2w,h,pf3)
! Construct pf4 from momentum conservation
      DO k = 1,4
        pf4(k) = q2w(k) - pf3(k)
      ENDDO
! Copy photons 4-momenta
      nphot = nsphot
      nphos = nsphot
      DO i = 1,nphot
        DO k = 1,4
          phot(i,k) = sphot(i,k)
          phos(i,k) = sphot(i,k)
        ENDDO
      ENDDO
      DO k = 1,4
        phsos(k) = phsum(k)
      ENDDO
      END

      SUBROUTINE DUMPD(NOUT)                 
C     **********************                 
C THIS PRINTS OUT FOUR MOMENTA OF PHOTONS    
C ON UNIT NO. NOUT                           
C     **********************                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),phot(100,4),nphot    
      SAVE   / MOMDEC /
      DIMENSION SUM(4)                       
      WRITE(NOUT,*) '=====================DUMPD===================='
      WRITE(NOUT,3100) 'PF1',(  PF1(  K),K=1,4) 
      WRITE(NOUT,3100) 'PF2',(  PF2(  K),K=1,4)
      WRITE(NOUT,3100) 'PF3',(  PF3(  K),K=1,4) 
      WRITE(NOUT,3100) 'PF4',(  PF4(  K),K=1,4) 
      DO 100 I=1,NPHOT                       
  100 WRITE(NOUT,3100) 'PHO',(PHOT(I,K),K=1,4) 
      DO 200 K=1,4                           
  200 SUM(K)=PF1(K)+PF2(K)+PF3(K)+PF4(K)                   
      DO 210 I=1,NPHOT                       
      DO 210 K=1,4                           
  210 SUM(K)=SUM(K)+PHOT(I,K)               
      WRITE(NOUT,3100) 'SUM',(  SUM(  K),K=1,4) 
 3100 FORMAT(1X,A3,1X,5F18.12)               
      END                                    
      DOUBLE COMPLEX FUNCTION VPOIN4(M1,M2,M3,M4,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3,M4
      DOUBLE COMPLEX D0,D11,D12,D13,D21,D22,D23,D24,D25,D26,D27,
     X                  D31,D32,D33,D34,D35,D36,D37,D38,D39,
     X                  D310,D311,D312,D313
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX T0,T1,T2,T3
      COMMON /PIR/ ZIPI2
      COMMON /IMD/ IMAX,IND,IREM
      COMMON /CAL/ T0(20),T1(20,3),T2(20,7),T3(20,13)
C
      VPOIN4=(0.D0,0.D0)
      RETURN
C
      ENTRY D0 (M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T0(IND   )/ZIPI2
      RETURN
C
      ENTRY D11(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T1(IND, 1)/ZIPI2
      RETURN
C
      ENTRY D12(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T1(IND, 2)/ZIPI2
      RETURN
C
      ENTRY D13(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T1(IND, 3)/ZIPI2
      RETURN
C
      ENTRY D21(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 1)/ZIPI2
      RETURN
C
      ENTRY D22(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 2)/ZIPI2
      RETURN
C
      ENTRY D23(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 3)/ZIPI2
      RETURN
C
      ENTRY D24(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 4)/ZIPI2
      RETURN
C
      ENTRY D25(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 5)/ZIPI2
      RETURN
C
      ENTRY D26(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 6)/ZIPI2
      RETURN
C
      ENTRY D27(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T2(IND, 7)/ZIPI2
      RETURN
C
      ENTRY D31(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 1)/ZIPI2
      RETURN
C
      ENTRY D32(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 2)/ZIPI2
      RETURN
C
      ENTRY D33(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 3)/ZIPI2
      RETURN
C
      ENTRY D34(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 4)/ZIPI2
      RETURN
C
      ENTRY D35(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 5)/ZIPI2
      RETURN
C
      ENTRY D36(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 6)/ZIPI2
      RETURN
C
      ENTRY D37(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 7)/ZIPI2
      RETURN
C
      ENTRY D38(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 8)/ZIPI2
      RETURN
C
      ENTRY D39(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND, 9)/ZIPI2
      RETURN
C
      ENTRY D310(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND,10)/ZIPI2
      RETURN
C
      ENTRY D311(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND,11)/ZIPI2
      RETURN
C
      ENTRY D312(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND,12)/ZIPI2
      RETURN
C
      ENTRY D313(M1,M2,M3,M4,ICH,fac)
	if ( fac.eq.0 ) then
		VPOIN4 = 0
		return
	endif
      CALL CHECK4(M1,M2,M3,M4,ICH)
      VPOIN4=T3(IND,13)/ZIPI2
      RETURN
C
      END
      SUBROUTINE CHECK4(M1,M2,M3,M4,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3,M4
      DIMENSION ASS(10,4)
      LOGICAL NOFIRU
      COMMON /IMD/ IMAX,IND,IREM
      DATA ASS /40*0.D0/
C
      IF(ICH.NE.IREM) NOFIRU=.FALSE.
      IF(NOFIRU) GOTO 1
      NOFIRU=.TRUE.
      IMAX=1
      IREM=ICH
      GOTO 20
C
    1 DO 10 I=1,IMAX
      IF((ABS(ASS(I,1)-M1).LT.1.D-8).AND.(ABS(ASS(I,2)-M2).LT.1.D-8).AND
     X.  (ABS(ASS(I,3)-M3).LT.1.D-8).AND.(ABS(ASS(I,4)-M4).LT.1.D-8))
     X   GOTO 5
      GOTO 10
    5 IND  =I
      RETURN
   10 CONTINUE
C
      IMAX =IMAX+1
      IF(IMAX.GT.10) WRITE(6,100)
      IF(IMAX.GT.10) STOP
   20 IND  =IMAX
      ASS(IND,1)=M1
      ASS(IND,2)=M2
      ASS(IND,3)=M3
      ASS(IND,4)=M4
      CALL CALCU4(M1,M2,M3,M4,ICH)
      RETURN
C
  100 FORMAT( / 10X, 'JETZT HAST DU ES ZU WEIT GETRIEBEN ')
      END
      SUBROUTINE CALCU4(M1,M2,M3,M4,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3,M4
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX T0,T1,T2,T3
      DOUBLE COMPLEX AA0,BB0,BB0PM,BB1,BB1PM,BB2,
     X               C0,C1,C2,C3,D0,D1,D2,D3,D4
      COMMON /blank/ 
     +	BB0,BB0PM,BB1,BB1PM,BB2(2),C0,C1(2),C2(4),C3(6),
     +	D0,D1(3),D2(7),D3(13),D4(22),
     +  PX(6),RM(4),DEL
      COMMON /CAL/ T0(20),T1(20,3),T2(20,7),T3(20,13)
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /PIR/ ZIPI2
      COMMON /IMD/ IMAX,IND,IREM
C
      GOTO(1,2),ICH
C
    1 PX(1)=-S1
      PX(2)=-S2
      PX(3)=-S3
      PX(4)=-S4
      PX(5)=-S5
      PX(6)=-S6
      GOTO 9

    2 PX(1)=-S1
      PX(2)=-S2
      PX(3)=-S4
      PX(4)=-S3
      PX(5)=-S5
      PX(6)=-S7
C
    9 RM(1)=M1**2
      RM(2)=M2**2
      RM(3)=M3**2
      RM(4)=M4**2
C
      CALL NPOIN(4)
C     INFRAROT - DIVERGENZ; ANNAHME M1 = MP
C
      DO 10 J=1,13
      T3(IND,J)=D3(J)
      IF(J.GT. 7) GOTO 10
      T2(IND,J)=D2(J)
      IF(J.GT. 3) GOTO 10
      T1(IND,J)=D1(J)
      IF(J.GT. 1) GOTO 10
      T0(IND  )=D0
   10 CONTINUE
C
      RETURN
      END
      DOUBLE COMPLEX FUNCTION VPOIN3(M1,M2,M3,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3
      DOUBLE COMPLEX C0,C11,C12,C21,C22,C23,C24,C31,C32,C33,C34,C35,C36
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX T0,T1,T2,T3
      COMMON /PIR/ ZIPI2
      COMMON /IMD/ IMAX,IND,IREM
      COMMON /CAL/ T0(20),T1(20,3),T2(20,7),T3(20,13)
C
      VPOIN3=(0.D0,0.D0)
      RETURN
C
      ENTRY C0 (M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T0(IND   )/ZIPI2
      RETURN
C
      ENTRY C11(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T1(IND, 1)/ZIPI2
      RETURN
C
      ENTRY C12(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T1(IND, 2)/ZIPI2
      RETURN
C
      ENTRY C21(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T2(IND, 1)/ZIPI2
      RETURN
C
      ENTRY C22(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T2(IND, 2)/ZIPI2
      RETURN
C
      ENTRY C23(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T2(IND, 3)/ZIPI2
      RETURN
C
      ENTRY C24(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T2(IND, 4)/ZIPI2
      RETURN
C
      ENTRY C31(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 1)/ZIPI2
      RETURN
C
      ENTRY C32(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 2)/ZIPI2
      RETURN
C
      ENTRY C33(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 3)/ZIPI2
      RETURN
C
      ENTRY C34(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 4)/ZIPI2
      RETURN
C
      ENTRY C35(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 5)/ZIPI2
      RETURN
C
      ENTRY C36(M1,M2,M3,ICH)
      CALL CHECK3(M1,M2,M3,ICH)
      VPOIN3=T3(IND, 6)/ZIPI2
      RETURN
C
      END
      SUBROUTINE CHECK3(M1,M2,M3,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3
      DIMENSION ASS(20,3)
      LOGICAL NOFIRU
      COMMON /IMD/ IMAX,IND,IREM
      DATA ASS /60*0.D0/
C
      IF(ICH.NE.IREM) NOFIRU=.FALSE.
      IF(NOFIRU) GOTO 1
      NOFIRU=.TRUE.
      IMAX=1
      IREM=ICH
      GOTO 20
C
    1 DO 10 I=1,IMAX
      IF((ABS(ASS(I,1)-M1).LT.1.D-9).AND.(ABS(ASS(I,2)-M2).LT.1.D-9).AND
     X.  (ABS(ASS(I,3)-M3).LT.1.D-9))
     X   GOTO 5
      GOTO 10
    5 IND  =I
      RETURN
   10 CONTINUE
C
      IMAX =IMAX+1
      IF(IMAX.GT.20) WRITE(6,100)
      IF(IMAX.GT.20) STOP
   20 IND  =IMAX
      ASS(IND,1)=M1
      ASS(IND,2)=M2
      ASS(IND,3)=M3
      CALL CALCU3(M1,M2,M3,ICH)
      RETURN
C
  100 FORMAT( / 10X, 'JETZT HAST DU ES ZU WEIT GETRIEBEN ')
      END
      SUBROUTINE CALCU3(M1,M2,M3,ICH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2,M3
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX T0,T1,T2,T3
      DOUBLE COMPLEX AA0,BB0,BB0PM,BB1,BB1PM,BB2,
     X               C0,C1,C2,C3,D0,D1,D2,D3,D4
      COMMON /blank/ 
     +	BB0,BB0PM,BB1,BB1PM,BB2(2),C0,C1(2),C2(4),C3(6),
     +	D0,D1(3),D2(7),D3(13),D4(22),
     +  PX(6),RM(4),DEL
      COMMON /CAL/ T0(20),T1(20,3),T2(20,7),T3(20,13)
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /PIR/ ZIPI2
      COMMON /IMD/ IMAX,IND,IREM
C
      GOTO(1,2,3,4,5,6),ICH
C
    1 PX(1)=-S2
      PX(2)=-S6
      PX(5)=-S3
      GOTO 9

    2 PX(1)=-S5
      PX(2)=-S3
      PX(5)=-S4
      GOTO 9

    3 PX(1)=-S1
      PX(2)=-S6
      PX(5)=-S4
      GOTO 9

    4 PX(1)=-S1
      PX(2)=-S2
      PX(5)=-S5
      GOTO 9

    5 PX(1)=-S4
      PX(2)=-S2
      PX(5)=-S7
      GOTO 9

    6 PX(1)=-S7
      PX(2)=-S3
      PX(5)=-S1
C
    9 RM(1)=M1**2
      RM(2)=M2**2
      RM(3)=M3**2
C
      CALL NPOIN(3)
C     INFRAROT - DIVERGENZ; ANNAHME M1 = MP
C
      DO 10 J=1,6
      T3(IND,J)=C3(J)
      IF(J.GT.4) GOTO 10
      T2(IND,J)=C2(J)
      IF(J.GT. 2) GOTO 10
      T1(IND,J)=C1(J)
      IF(J.GT. 1) GOTO 10
      T0(IND  )=C0
   10 CONTINUE
C
      RETURN
      END
      DOUBLE COMPLEX FUNCTION VPOIN2(M1,M2,S)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1,M2
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX AA0,BB0,BB0PM,BB1,BB1PM,BB2,
     X               C0,C1,C2,C3,D0,D1,D2,D3,D4
      DOUBLE COMPLEX B0,fredAB0,AB0,B1,AB1,B21,B22
      COMMON /blank/ 
     +	BB0,BB0PM,BB1,BB1PM,BB2(2),C0,C1(2),C2(4),C3(6),
     +	D0,D1(3),D2(7),D3(13),D4(22),
     +  PX(6),RM(4),DEL
      COMMON /PIR/ ZIPI2
	double precision delta,delsav
	common /ffcut/ delta
C
      VPOIN2=(0.D0,0.D0)
      RETURN
C
      ENTRY B0(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
      CALL NPOIN(2)
      VPOIN2= BB0   /ZIPI2
      RETURN
C
      ENTRY AB0(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
*	
*	the IR divergences have already been cancelled
*	
	delsav = delta
	if ( m1.lt.1.1d-8 .and. abs(s-RM(2)).lt.1.d-8*RM(2) ) then
	   RM(1) = 0
	   delta = RM(2)
	endif
      CALL NPOIN(2)
	delta = delsav
      VPOIN2= BB0PM /ZIPI2
      RETURN
C
      ENTRY B1(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
      CALL NPOIN(2)
      VPOIN2= BB1   /ZIPI2
      RETURN
C
      ENTRY AB1(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
      CALL NPOIN(2)
      VPOIN2= BB1PM /ZIPI2
      RETURN
C
      ENTRY B21(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
      CALL NPOIN(2)
      VPOIN2= BB2(1)/ZIPI2
      RETURN
C
      ENTRY B22(M1,M2,S)
      PX(1)=-S
      RM(1)= M1**2
      RM(2)= M2**2
      CALL NPOIN(2)
      VPOIN2= BB2(2)/ZIPI2
      RETURN
C
      END

      FUNCTION A0(M1)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 M1
      DOUBLE COMPLEX ZIPI2
      DOUBLE COMPLEX AA0,BB0,BB0PM,BB1,BB1PM,BB2,
     X               C0,C1,C2,C3,D0,D1,D2,D3,D4
      COMMON /blank/ 
     +	BB0,BB0PM,BB1,BB1PM,BB2(2),C0,C1(2),C2(4),C3(6),
     +	D0,D1(3),D2(7),D3(13),D4(22),
     +  PX(6),RM(4),DEL
      COMMON /PIR/ ZIPI2
C
      X  = M1**2
      A0 = AA0(X,DEL)/ZIPI2
C
      RETURN
      END
      FUNCTION AA(X)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /REG/ REG
C     INFRAROT - DIVERGENZ IN AA  ELIMINIERT
      IF (X.LT.1.01D-8) THEN
         AA=-(REG+1.D0- LOG(S6))
      ELSE
         AA=A0(X)/X**2
      ENDIF
      RETURN
      END
      FUNCTION RIDE(SX,SY,SZ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      RIDE=1.D0/(4.D0*SX*SY-(SX+SY-SZ)**2)
C
      RETURN
      END

      SUBROUTINE SET
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON /IMD/ IMAX,IND,IREM
C
      IMAX =0
      IND  =1
      IREM =0
C
      RETURN
      END
      SUBROUTINE AMPLI(S01,S02,S03,T01,T02,I)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 MH,MH2,MH4,MH6,MH8,MH10,MH12,MH14
      REAL*8 MZ,MZ2,MZ4,MZ6,MZ8
      REAL*8 MW,MW2,MW4,MW6,MW8
      REAL*8 ME,ME2,ME4,ME6,ME8
      REAL*8 MN,MP,MP2,MH0
      REAL*8 MF1,MF2
      REAL*8 K09,K10,K11,K18,K19,K21,K22,K23,K24,K28,K29,K30,K31,KEE
      REAL*8 K0N,KZZ,KAZ,KNZ,KZ1
      REAL*8 IDE01,IDE02,IDE03,MW10,MW12,MW14
      DIMENSION SD01(7),SD02(7),SD03(7),TD01(7),TD02(7)
      DIMENSION ST01(7),ST02(7),ST03(7),TT01(7),TT02(7)
      DIMENSION SX01(7),SX02(7),SX03(7),TX01(7),TX02(7)
      DOUBLE COMPLEX AB0,AB1
      DOUBLE COMPLEX B0,B1,B21,B22
      DOUBLE COMPLEX C0,C11,C12,C21,C22,C23,C24,C31,C32,C33,C34,C35,C36
      DOUBLE COMPLEX D0,D11,D12,D13,D21,D22,D23,D24,D25,D26,D27,D31,D32,
     X               D33,D34,D35,D36,D37,D38,D39,D310,D311,D312,D313
      DOUBLE COMPLEX SD011,SD012,SD013,TD011,TD012
      DOUBLE COMPLEX SD021,SD022,SD023,TD021,TD022
      DOUBLE COMPLEX SX011,SX012,SX013,TX011,TX012
      DOUBLE COMPLEX S1ZWW,S2ZWW,S3ZWW,
     X               S1ZWH,S2ZWH,S3ZWH,
     X               S1GWW,S2GWW,S3GWW,
     X               S1GWH,S2GWH,S3GWH,
     X               T1WEN,T2WEN,
     X               S1ZEE,S1GEE,
     X               AS01,AT01
      DOUBLE COMPLEX SEZWW,SZZWW,SDZWW,SVZWW,
     X               SEZWH,SZZWH,SDZWH,SVZWH,
     X               SEGWW,SZGWW,SDGWW,
     X               SEGWH,SZGWH,SDGWH,
     X               TEWEN,TZWEN,
     X               SEZEE,SEGEE,
     X               ASN1,ATN1
      CHARACTER*4 SCHEME
	logical lwrite
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /INP/ MH,COST,SX
      COMMON /OVR/ ME,MP,MW,MZ,MN,
     1             ME2,ME4,ME6,ME8,MP2,MW2,MW4,MW6,MW8,MZ2,MZ4,MZ6,MZ8,
     1             MH2,MH4,MH6,MH8,MH10,MH12,MH14,
     1             RE2,RE4,RE6,RE8,RP2,RW2,RW4,RW6,RW8,RZ2,RZ4,RZ6,RZ8,
     1             RH2,SI2,SI2I,AW,AW2,AW3,A20,A40,QE2,EE,XI,
     1             E,PP,QQ,EW,TT,UU,S5R,S6R,S7R,R11,R21,R31,R41,R51,R61
     1            ,R12,R22,R32,R42,R52,R62,AME5,AME6,AME7,AMZ5,AMZ6,AMP6
     1            ,AMZ7,P1DP2,P1DP3,P1DP4,P2DP3,P2DP4,P3DP4,
     1             DMH2,DMZ2,DMW2,DME1,DE1,DVI1
      COMMON /COE/ K0N,KZZ,KEE,KAZ,KNZ,KZ1,K22,K23,K24,K28,K29,K30,K31
      COMMON /DAX/ DAB,XAB
      COMMON /ANO/ ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
      COMMON /APH/ APHNO
      COMMON /REG/ REG
      COMMON /XTR/ E0Z,E0X
      COMMON/SCHEM/SCHEME
C
      DATA SD01(4),SD02(4),SD03(4),TD01(4),TD02(4),
     1     SD01(6),SD02(6),SD03(6),TD01(6),TD02(6),
     1     ST01(4),ST02(4),ST03(4),TT01(4),TT02(4),
     1     ST01(6),ST02(6),ST03(6),TT01(6),TT02(6),
     1     SX01(4),SX02(4),SX03(4),TX01(4),TX02(4),
     1     SX01(6),SX02(6),SX03(6),TX01(6),TX02(6)
     1     /30*0.D0/
	data lwrite /.FALSE./
C
      DAB2=DAB**2
      XAB2=XAB**2
      AC  =AW
      BC  =0.25D0
C
C     SD01I-AMPL. HABEN NUR CPP, SD02I-AMPL. HABEN CPP U. CPM
C     ENTSPRECHENDES FUER SD0I(J) U. ST0I(J)
C
      DO 100 ICR=1,2
      K09=K0N
      K10=KZZ
      K11=0.
      K18=KAZ
      K19=KNZ
      K21=KZ1
      IF(ICR.EQ.1) GOTO 1
      K09=0.
      K10=0.
      K11=KEE
      K18=0.
      K19=0.
      K21=0.
    1 CONTINUE
      IF(ICR.EQ.1) GOTO 2
C     SCALAR CROSSING
      T    =S5
      S5   =S7
      S7   =T
      P1DP2=(S5-S1-S2)/2.D0
      P1DP3=(S7-S1-S3)/2.D0
      P2DP4=(S7-S2-S4)/2.D0
      P3DP4=(S5-S3-S4)/2.D0
    2 CONTINUE
C
      CALL SET
      IF(I.EQ.2) GOTO 5
C
	if ( lwrite ) print *,'ampli: SD011'
       SD011=
     1 -16.D0*D312(MN,MW,MP,MW,1,K19)*K19
     1 -16.D0*D312(MN,MW,MZ,MW,1,K18)*K18
     1 +16.D0*D312(MP,ME,MN,ME,1,K10)*K10
     1 +16.D0*D312(MW,MN,ME,MN,1,K11)*K11
     1 +D312(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2)
     1 +16.D0*D313(MN,MW,MP,MW,1,K19)*K19
     1 +16.D0*D313(MN,MW,MZ,MW,1,K18)*K18
       SD011 = SD011
     1 -16.D0*D313(MP,ME,MN,ME,1,K10)*K10
     1 -16.D0*D313(MW,MN,ME,MN,1,K11)*K11
     1 +D313(MZ,ME,MN,ME,1,K09)*K09*(-16.D0*DAB2)
     1 -32.D0*D27(MN,MW,MP,MW,1,K19)*K19
     1 -32.D0*D27(MN,MW,MZ,MW,1,K18)*K18
     1 -16.D0*D27(MP,ME,MN,ME,1,K10)*K10
       SD011 = SD011
     1 -16.D0*D27(MW,MN,ME,MN,1,K11)*K11
     1 +D27(MZ,ME,MN,ME,1,K09)*K09*(-16.D0*DAB2)
     1 +D12(MN,MW,MP,MW,1,K19)*K19*(8.D0*MW2+16.D0*P1DP2)
     1 +D12(MN,MW,MZ,MW,1,K18)*K18*(8.D0*MW2+16.D0*P1DP2)
     1 +D12(MP,ME,MN,ME,1,K10)*K10*(-8.D0*MW2-16.D0*P1DP2)
     1 +D12(MW,MN,ME,MN,1,K11)*K11*(-8.D0*MW2-16.D0*P1DP2)
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2*MW2-16.D0*DAB2*P1DP2)
       SD011 = SD011
     1 +D13(MN,MW,MP,MW,1,K19)*K19*(-8.D0*MW2-16.D0*P1DP2)
     1 +D13(MN,MW,MZ,MW,1,K18)*K18*(-8.D0*MW2-16.D0*P1DP2)
     1 +D13(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2+16.D0*P1DP2)
     1 +D13(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2+16.D0*P1DP2)
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2+16.D0*DAB2*P1DP2)
     1 +D0(MN,MW,MP,MW,1,K19)*K19*(8.D0*MW2+16.D0*P1DP2)
     1 +D0(MN,MW,MZ,MW,1,K18)*K18*(8.D0*MW2-8.D0*MZ2+16.D0*P1DP2)
     1 +D0(MW,MN,ME,MN,1,K11)*K11*(-8.D0*MW2)
       SD011 = SD011
     1 +D0(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2*MZ2)
	if ( lwrite ) print *,'ampli: SD012'
       SD012=
     1 +4.D0*D34(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D34(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D34(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D34(MW,MN,ME,MN,1,K11)*K11
     1 +D34(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D35(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D35(MN,MW,MZ,MW,1,K18)*K18
       SD012 = SD012
     1 +4.D0*D35(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D35(MW,MN,ME,MN,1,K11)*K11
     1 +D35(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 -8.D0*D36(MN,MW,MP,MW,1,K19)*K19
     1 -8.D0*D36(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D36(MP,ME,MN,ME,1,K10)*K10
       SD012 = SD012
     1 +8.D0*D36(MW,MN,ME,MN,1,K11)*K11
     1 +D36(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
     1 +8.D0*D37(MN,MW,MP,MW,1,K19)*K19
     1 +8.D0*D37(MN,MW,MZ,MW,1,K18)*K18
     1 -8.D0*D37(MP,ME,MN,ME,1,K10)*K10
     1 -8.D0*D37(MW,MN,ME,MN,1,K11)*K11
     1 +D37(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2)
       SD012 = SD012
     1 +16.D0*D38(MN,MW,MP,MW,1,K19)*K19
     1 +16.D0*D38(MN,MW,MZ,MW,1,K18)*K18
     1 -16.D0*D38(MP,ME,MN,ME,1,K10)*K10
     1 -16.D0*D38(MW,MN,ME,MN,1,K11)*K11
     1 +D38(MZ,ME,MN,ME,1,K09)*K09*(-16.D0*DAB2)
     1 -16.D0*D39(MN,MW,MP,MW,1,K19)*K19
     1 -16.D0*D39(MN,MW,MZ,MW,1,K18)*K18
     1 +16.D0*D39(MP,ME,MN,ME,1,K10)*K10
       SD012 = SD012
     1 +16.D0*D39(MW,MN,ME,MN,1,K11)*K11
     1 +D39(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2)
     1 -8.D0*D22(MN,MW,MP,MW,1,K19)*K19
     1 -8.D0*D22(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D22(MP,ME,MN,ME,1,K10)*K10
     1 +8.D0*D22(MW,MN,ME,MN,1,K11)*K11
     1 +D22(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
       SD012 = SD012
     1 -8.D0*D23(MN,MW,MP,MW,1,K19)*K19
     1 -8.D0*D23(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D23(MP,ME,MN,ME,1,K10)*K10
     1 +8.D0*D23(MW,MN,ME,MN,1,K11)*K11
     1 +D23(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
     1 +8.D0*D24(MN,MW,MP,MW,1,K19)*K19
     1 +8.D0*D24(MN,MW,MZ,MW,1,K18)*K18
     1 +4.D0*D24(MP,ME,MN,ME,1,K10)*K10
       SD012 = SD012
     1 +4.D0*D24(MW,MN,ME,MN,1,K11)*K11
     1 +D24(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 -8.D0*D25(MN,MW,MP,MW,1,K19)*K19
     1 -8.D0*D25(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D25(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D25(MW,MN,ME,MN,1,K11)*K11
     1 +D25(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
       SD012 = SD012
     1 +16.D0*D26(MN,MW,MP,MW,1,K19)*K19
     1 +16.D0*D26(MN,MW,MZ,MW,1,K18)*K18
     1 -16.D0*D26(MP,ME,MN,ME,1,K10)*K10
     1 -16.D0*D26(MW,MN,ME,MN,1,K11)*K11
     1 +D26(MZ,ME,MN,ME,1,K09)*K09*(-16.D0*DAB2)
     1 +4.D0*D12(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D12(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D12(MP,ME,MN,ME,1,K10)*K10
       SD012 = SD012
     1 +8.D0*D12(MW,MN,ME,MN,1,K11)*K11
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
     1 -4.D0*D13(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D13(MN,MW,MZ,MW,1,K18)*K18
     1 -8.D0*D13(MP,ME,MN,ME,1,K10)*K10
     1 -8.D0*D13(MW,MN,ME,MN,1,K11)*K11
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2)
	if ( lwrite ) print *,'ampli: SD013'
       SD013=
     1 -16.D0*D311(MN,MW,MP,MW,1,K19)*K19
     1 -16.D0*D311(MN,MW,MZ,MW,1,K18)*K18
     1 +16.D0*D311(MP,ME,MN,ME,1,K10)*K10
     1 +16.D0*D311(MW,MN,ME,MN,1,K11)*K11
     1 +D311(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2)
     1 +48.D0*D312(MN,MW,MP,MW,1,K19)*K19
     1 +48.D0*D312(MN,MW,MZ,MW,1,K18)*K18
       SD013 = SD013
     1 -48.D0*D312(MP,ME,MN,ME,1,K10)*K10
     1 -48.D0*D312(MW,MN,ME,MN,1,K11)*K11
     1 +D312(MZ,ME,MN,ME,1,K09)*K09*(-48.D0*DAB2)
     1 -48.D0*D313(MN,MW,MP,MW,1,K19)*K19
     1 -48.D0*D313(MN,MW,MZ,MW,1,K18)*K18
     1 +48.D0*D313(MP,ME,MN,ME,1,K10)*K10
       SD013 = SD013
     1 +48.D0*D313(MW,MN,ME,MN,1,K11)*K11
     1 +D313(MZ,ME,MN,ME,1,K09)*K09*(48.D0*DAB2)
     1 +D21(MN,MW,MP,MW,1,K19)*K19*(32.D0*P1DP2)
     1 +D21(MN,MW,MZ,MW,1,K18)*K18*(32.D0*P1DP2)
     1 +D21(MP,ME,MN,ME,1,K10)*K10*(16.D0*P1DP2)
     1 +D21(MW,MN,ME,MN,1,K11)*K11*(16.D0*P1DP2)
     1 +D21(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2*P1DP2)
       SD013 = SD013
     1 +D22(MN,MW,MP,MW,1,K19)*K19*(-16.D0*MW2)
     1 +D22(MN,MW,MZ,MW,1,K18)*K18*(-16.D0*MW2)
     1 +D22(MP,ME,MN,ME,1,K10)*K10*(-8.D0*MW2)
     1 +D22(MW,MN,ME,MN,1,K11)*K11*(-8.D0*MW2)
     1 +D22(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2*MW2)
     1 +D23(MN,MW,MP,MW,1,K19)*K19*(16.D0*MW2+32.D0*P1DP2)
     1 +D23(MN,MW,MZ,MW,1,K18)*K18*(16.D0*MW2+32.D0*P1DP2)
     1 +D23(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2+16.D0*P1DP2)
       SD013 = SD013
     1 +D23(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2+16.D0*P1DP2)
     1 +D23(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2+16.D0*DAB2*P1DP2)
     1 +D24(MN,MW,MP,MW,1,K19)*K19*(16.D0*MW2-32.D0*P1DP2)
     1 +D24(MN,MW,MZ,MW,1,K18)*K18*(16.D0*MW2-32.D0*P1DP2)
     1 +D24(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2-16.D0*P1DP2)
     1 +D24(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2-16.D0*P1DP2)
     1 +D24(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2-16.D0*DAB2*P1DP2)
       SD013 = SD013
     1 +D25(MN,MW,MP,MW,1,K19)*K19*(-16.D0*MW2-64.D0*P1DP2)
     1 +D25(MN,MW,MZ,MW,1,K18)*K18*(-16.D0*MW2-64.D0*P1DP2)
     1 +D25(MP,ME,MN,ME,1,K10)*K10*(-8.D0*MW2-32.D0*P1DP2)
     1 +D25(MW,MN,ME,MN,1,K11)*K11*(-8.D0*MW2-32.D0*P1DP2)
     1 +D25(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2*MW2-32.D0*DAB2*P1DP2)
     1 +D26(MN,MW,MP,MW,1,K19)*K19*(32.D0*P1DP2)
     1 +D26(MN,MW,MZ,MW,1,K18)*K18*(32.D0*P1DP2)
     1 +D26(MP,ME,MN,ME,1,K10)*K10*(16.D0*P1DP2)
       SD013 = SD013
     1 +D26(MW,MN,ME,MN,1,K11)*K11*(16.D0*P1DP2)
     1 +D26(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2*P1DP2)
     1 +64.D0*D27(MN,MW,MP,MW,1,K19)*K19
     1 +64.D0*D27(MN,MW,MZ,MW,1,K18)*K18
     1 +32.D0*D27(MP,ME,MN,ME,1,K10)*K10
     1 +32.D0*D27(MW,MN,ME,MN,1,K11)*K11
     1 +D27(MZ,ME,MN,ME,1,K09)*K09*(32.D0*DAB2)
       SD013 = SD013
     1 +D11(MN,MW,MP,MW,1,K19)*K19*(16.D0*MW2+16.D0*P1DP2)
     1 +D11(MN,MW,MZ,MW,1,K18)*K18*(16.D0*MW2-8.D0*MZ2+16.D0*P1DP2)
     1 +D11(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2+32.D0*P1DP2)
     1 +D11(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2+32.D0*P1DP2)
     1 +D11(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2+32.D0*DAB2*P1DP2)
     1 +D12(MN,MW,MP,MW,1,K19)*K19*(-32.D0*MW2-48.D0*P1DP2)
     1 +D12(MN,MW,MZ,MW,1,K18)*K18*(-32.D0*MW2+8.D0*MZ2-48.D0*P1DP2)
     1 +D12(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2)
       SD013 = SD013
     1 +D12(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2)
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2)
     1 +D13(MN,MW,MP,MW,1,K19)*K19*(16.D0*MW2+16.D0*P1DP2)
     1 +D13(MN,MW,MZ,MW,1,K18)*K18*(16.D0*MW2+8.D0*MZ2+16.D0*P1DP2)
     1 +D13(MP,ME,MN,ME,1,K10)*K10*(16.D0*P1DP3+16.D0*P2DP3)
     1 +D13(MW,MN,ME,MN,1,K11)*K11*(-8.D0*MW2+16.D0*P1DP3+16.D0*P2DP3)
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2*MZ2+16.D0*DAB2*P1DP3
     1                                        +16.D0*DAB2*P2DP3)
       SD013 = SD013
     1 +D0(MN,MW,MP,MW,1,K19)*K19*(-8.D0*MW2-16.D0*P1DP2)
     1 +D0(MN,MW,MZ,MW,1,K18)*K18*(-8.D0*MW2+8.D0*MZ2-16.D0*P1DP2)
     1 +D0(MP,ME,MN,ME,1,K10)*K10*(8.D0*MW2+16.D0*P1DP2)
     1 +D0(MW,MN,ME,MN,1,K11)*K11*(16.D0*MW2+16.D0*P1DP2)
     1 +D0(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MW2+8.D0*DAB2*MZ2
     1                                        +16.D0*DAB2*P1DP2)
	if ( lwrite ) print *,'ampli: TD011'
       TD011=
     1 +64.D0*D27(MN,MW,MP,MW,1,K19)*K19
     1 +64.D0*D27(MN,MW,MZ,MW,1,K18)*K18
     1 +32.D0*D27(MP,ME,MN,ME,1,K10)*K10
     1 +32.D0*D27(MW,MN,ME,MN,1,K11)*K11
     1 +D27(MZ,ME,MN,ME,1,K09)*K09*(32.D0*DAB2)
     1 +D12(MN,MW,MP,MW,1,K19)*K19*(-16.D0*P2DP3)
     1 -4.D0*D12(MN,MW,MH,MW,1,K21)*K21
       TD011 = TD011
     1 +D12(MN,MW,MZ,MW,1,K18)*K18*(-4.D0*MZ2-16.D0*P2DP3)
     1 +D12(MP,ME,MN,ME,1,K10)*K10*(24.D0*MW2+48.D0*P1DP2+16.D0*P2DP3)
     1 +D12(MW,MN,ME,MN,1,K11)*K11*(24.D0*MW2+48.D0*P1DP2+16.D0*P2DP3)
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(24.D0*DAB2*MW2+48.D0*DAB2*P1DP2
     1                                        +16.D0*DAB2*P2DP3)
     1 +D13(MN,MW,MP,MW,1,K19)*K19*(16.D0*P2DP3)
       TD011 = TD011
     1 +4.D0*D13(MN,MW,MH,MW,1,K21)*K21
     1 +D13(MN,MW,MZ,MW,1,K18)*K18*(4.D0*MZ2+16.D0*P2DP3)
     1 +D13(MP,ME,MN,ME,1,K10)*K10*(-24.D0*MW2-48.D0*P1DP2-16.D0*P2DP3)
     1 +D13(MW,MN,ME,MN,1,K11)*K11*(-24.D0*MW2-48.D0*P1DP2-16.D0*P2DP3)
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(-24.D0*DAB2*MW2-48.D0*DAB2*P1DP2
     1                                         -16.D0*DAB2*P2DP3)
     1 +D0(MP,ME,MN,ME,1,K10)*K10*(-16.D0*P1DP2-16.D0*P1DP3)
     1 +D0(MW,MN,ME,MN,1,K11)*K11*(24.D0*MW2-16.D0*P1DP2-16.D0*P1DP3)
     1 +D0(MZ,ME,MN,ME,1,K09)*K09*(24.D0*DAB2*MZ2-16.D0*DAB2*P1DP2
     1                                       -16.D0*DAB2*P1DP3)
	if ( lwrite ) print *,'ampli: TD012'
       TD012=
     1 +32.D0*D311(MN,MW,MP,MW,1,K19)*K19
     1 +32.D0*D311(MN,MW,MZ,MW,1,K18)*K18
     1 -32.D0*D311(MP,ME,MN,ME,1,K10)*K10
     1 -32.D0*D311(MW,MN,ME,MN,1,K11)*K11
     1 +D311(MZ,ME,MN,ME,1,K09)*K09*(-32.D0*DAB2)
     1 -64.D0*D27(MN,MW,MP,MW,1,K19)*K19
     1 -64.D0*D27(MN,MW,MZ,MW,1,K18)*K18
       TD012 = TD012
     1 -80.D0*D27(MP,ME,MN,ME,1,K10)*K10
     1 -80.D0*D27(MW,MN,ME,MN,1,K11)*K11
     1 +D27(MZ,ME,MN,ME,1,K09)*K09*(-80.D0*DAB2)
     1 +D11(MN,MW,MP,MW,1,K19)*K19*(-16.D0*MW2-16.D0*P2DP3)
     1 -4.D0*D11(MN,MW,MH,MW,1,K21)*K21
     1 +D11(MN,MW,MZ,MW,1,K18)*K18*(-16.D0*MW2-4.D0*MZ2-16.D0*P2DP3)
       TD012 = TD012
     1 +D11(MP,ME,MN,ME,1,K10)*K10*(-16.D0*P1DP2-16.D0*P1DP3)
     1 +D11(MW,MN,ME,MN,1,K11)*K11*(8.D0*MW2-16.D0*P1DP2-16.D0*P1DP3)
     1 +D11(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2*MZ2-16.D0*DAB2*P1DP2
     1                                       -16.D0*DAB2*P1DP3)
     1 +D12(MN,MW,MP,MW,1,K19)*K19*(16.D0*P2DP3)
     1 +4.D0*D12(MN,MW,MH,MW,1,K21)*K21
     1 +D12(MN,MW,MZ,MW,1,K18)*K18*(4.D0*MZ2+16.D0*P2DP3)
       TD012 = TD012
     1 +D12(MP,ME,MN,ME,1,K10)*K10*(-24.D0*MW2-48.D0*P1DP2-16.D0*P2DP3)
     1 +D12(MW,MN,ME,MN,1,K11)*K11*(-24.D0*MW2-48.D0*P1DP2-16.D0*P2DP3)
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(-24.D0*DAB2*MW2-48.D0*DAB2*P1DP2
     1                                         -16.D0*DAB2*P2DP3)
     1 +D13(MN,MW,MP,MW,1,K19)*K19*(-16.D0*P2DP3)
     1 -4.D0*D13(MN,MW,MH,MW,1,K21)*K21
     1 +D13(MN,MW,MZ,MW,1,K18)*K18*(-4.D0*MZ2-16.D0*P2DP3)
     1 +D13(MP,ME,MN,ME,1,K10)*K10*(24.D0*MW2+48.D0*P1DP2+16.D0*P2DP3)
       TD012 = TD012
     1 +D13(MW,MN,ME,MN,1,K11)*K11*(24.D0*MW2+48.D0*P1DP2+16.D0*P2DP3)
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(24.D0*DAB2*MW2+48.D0*DAB2*P1DP2
     1                                        +16.D0*DAB2*P2DP3)
     1 +D0(MN,MW,MP,MW,1,K19)*K19*(-16.D0*MW2)
     1 +D0(MN,MW,MZ,MW,1,K18)*K18*(-16.D0*MW2)
     1 +D0(MW,MN,ME,MN,1,K11)*K11*(-16.D0*MW2)
     1 +D0(MZ,ME,MN,ME,1,K09)*K09*(-16.D0*DAB2*MZ2)
	if ( lwrite ) print *,'ampli: A1PQM'
       A1PQM=
     1 +4.D0*D36(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D36(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D36(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D36(MW,MN,ME,MN,1,K11)*K11
     1 +D36(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 +4.D0*D37(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D37(MN,MW,MZ,MW,1,K18)*K18
       A1PQM = A1PQM
     1 -4.D0*D37(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D37(MW,MN,ME,MN,1,K11)*K11
       A1PQM = A1PQM
     1 +D37(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -8.D0*D310(MN,MW,MP,MW,1,K19)*K19
     1 -8.D0*D310(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D310(MP,ME,MN,ME,1,K10)*K10
     1 +8.D0*D310(MW,MN,ME,MN,1,K11)*K11
     1 +D310(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
     1 +4.D0*D22(MN,MW,MP,MW,1,K19)*K19
       A1PQM = A1PQM
     1 +4.D0*D22(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D22(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D22(MW,MN,ME,MN,1,K11)*K11
       A1PQM = A1PQM
     1 +D22(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 +4.D0*D23(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D23(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D23(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D23(MW,MN,ME,MN,1,K11)*K11
     1 +D23(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D24(MN,MW,MP,MW,1,K19)*K19
       A1PQM = A1PQM
     1 -4.D0*D24(MN,MW,MZ,MW,1,K18)*K18
     1 -8.D0*D24(MP,ME,MN,ME,1,K10)*K10
     1 -8.D0*D24(MW,MN,ME,MN,1,K11)*K11
       A1PQM = A1PQM
     1 +D24(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2)
     1 -12.D0*D25(MN,MW,MP,MW,1,K19)*K19
     1 -12.D0*D25(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D26(MN,MW,MP,MW,1,K19)*K19
     1 +8.D0*D26(MN,MW,MZ,MW,1,K18)*K18
     1 +16.D0*D26(MP,ME,MN,ME,1,K10)*K10
     1 +16.D0*D26(MW,MN,ME,MN,1,K11)*K11
       A1PQM = A1PQM
     1 +D26(MZ,ME,MN,ME,1,K09)*K09*(16.D0*DAB2)
     1 -4.D0*D12(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D12(MN,MW,MZ,MW,1,K18)*K18
     1 -8.D0*D12(MP,ME,MN,ME,1,K10)*K10
     1 -8.D0*D12(MW,MN,ME,MN,1,K11)*K11
       A1PQM = A1PQM
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2)
     1 +4.D0*D13(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D13(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D13(MP,ME,MN,ME,1,K10)*K10
     1 +8.D0*D13(MW,MN,ME,MN,1,K11)*K11
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
	if ( lwrite ) print *,'ampli: A1PQP'
       A1PQP=
     1 +4.D0*D34(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D34(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D34(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D34(MW,MN,ME,MN,1,K11)*K11
     1 +D34(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D35(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D35(MN,MW,MZ,MW,1,K18)*K18
       A1PQP = A1PQP
     1 +4.D0*D35(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D35(MW,MN,ME,MN,1,K11)*K11
       A1PQP = A1PQP
     1 +D35(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 -4.D0*D36(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D36(MN,MW,MZ,MW,1,K18)*K18
     1 +4.D0*D36(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D36(MW,MN,ME,MN,1,K11)*K11
     1 +D36(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 +4.D0*D37(MN,MW,MP,MW,1,K19)*K19
       A1PQP = A1PQP
     1 +4.D0*D37(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D37(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D37(MW,MN,ME,MN,1,K11)*K11
       A1PQP = A1PQP
     1 +D37(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D22(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D22(MN,MW,MZ,MW,1,K18)*K18
     1 +4.D0*D22(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D22(MW,MN,ME,MN,1,K11)*K11
     1 +D22(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 +4.D0*D23(MN,MW,MP,MW,1,K19)*K19
       A1PQP = A1PQP
     1 +4.D0*D23(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D23(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D23(MW,MN,ME,MN,1,K11)*K11
       A1PQP = A1PQP
     1 +D23(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 +4.D0*D24(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D24(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D24(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D24(MW,MN,ME,MN,1,K11)*K11
     1 +D24(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D25(MN,MW,MP,MW,1,K19)*K19
       A1PQP = A1PQP
     1 -4.D0*D25(MN,MW,MZ,MW,1,K18)*K18
     1 +4.D0*D25(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D25(MW,MN,ME,MN,1,K11)*K11
       A1PQP = A1PQP
     1 +D25(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
	if ( lwrite ) print *,'ampli: A1QQS'
       A1QQS=
     1 +4.D0*D34(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D34(MN,MW,MZ,MW,1,K18)*K18
     1 -4.D0*D34(MP,ME,MN,ME,1,K10)*K10
     1 -4.D0*D34(MW,MN,ME,MN,1,K11)*K11
     1 +D34(MZ,ME,MN,ME,1,K09)*K09*(-4.D0*DAB2)
     1 -4.D0*D35(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D35(MN,MW,MZ,MW,1,K18)*K18
       A1QQS = A1QQS
     1 +4.D0*D35(MP,ME,MN,ME,1,K10)*K10
     1 +4.D0*D35(MW,MN,ME,MN,1,K11)*K11
       A1QQS = A1QQS
     1 +D35(MZ,ME,MN,ME,1,K09)*K09*(4.D0*DAB2)
     1 -12.D0*D24(MP,ME,MN,ME,1,K10)*K10
     1 -12.D0*D24(MW,MN,ME,MN,1,K11)*K11
     1 +D24(MZ,ME,MN,ME,1,K09)*K09*(-12.D0*DAB2)
     1 +12.D0*D25(MP,ME,MN,ME,1,K10)*K10
     1 +12.D0*D25(MW,MN,ME,MN,1,K11)*K11
     1 +D25(MZ,ME,MN,ME,1,K09)*K09*(12.D0*DAB2)
       A1QQS = A1QQS
     1 -4.D0*D12(MN,MW,MP,MW,1,K19)*K19
     1 -4.D0*D12(MN,MW,MZ,MW,1,K18)*K18
     1 -8.D0*D12(MP,ME,MN,ME,1,K10)*K10
     1 -8.D0*D12(MW,MN,ME,MN,1,K11)*K11
       A1QQS = A1QQS
     1 +D12(MZ,ME,MN,ME,1,K09)*K09*(-8.D0*DAB2)
     1 +4.D0*D13(MN,MW,MP,MW,1,K19)*K19
     1 +4.D0*D13(MN,MW,MZ,MW,1,K18)*K18
     1 +8.D0*D13(MP,ME,MN,ME,1,K10)*K10
     1 +8.D0*D13(MW,MN,ME,MN,1,K11)*K11
     1 +D13(MZ,ME,MN,ME,1,K09)*K09*(8.D0*DAB2)
C
    5 CONTINUE
C
	if ( lwrite ) print *,'ampli: SD021'
       SD021=
     1 -4.D0*D312(ME,MP,MW,MP,1,K23)*K23
     1 -4.D0*D312(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -4.D0*D312(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D312(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2)
     1 +4.D0*D313(ME,MP,MW,MP,1,K23)*K23
     1 +4.D0*D313(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +4.D0*D313(ME,MZ,MW,MP,1,K24)*K24*XAB
       SD021 = SD021
     1 +D313(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2)
     1 -8.D0*D27(ME,MP,MW,MP,1,K23)*K23
     1 -8.D0*D27(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -8.D0*D27(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D27(ME,MZ,MW,MZ,1,K22)*K22*(-8.D0*XAB2)
     1 +D12(ME,MP,MW,MP,1,K23)*K23*(2.D0*MW2+4.D0*P1DP2)
       SD021 = SD021
     1 +D12(ME,MP,MW,MZ,1,K24)*K24*XAB*(2.D0*MW2+4.D0*P1DP2)
     1 +D12(ME,MZ,MW,MP,1,K24)*K24*XAB*(2.D0*MW2+4.D0*P1DP2)
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(2.D0*XAB2*MW2+4.D0*XAB2*P1DP2)
     1 +D13(ME,MP,MW,MP,1,K23)*K23*(-2.D0*MW2-4.D0*P1DP2)
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB*(-2.D0*MW2-4.D0*P1DP2)
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB*(-2.D0*MW2-4.D0*P1DP2)
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2*MW2-4.D0*XAB2*P1DP2)
       SD021 = SD021
     1 +D0(ME,MP,MW,MP,1,K23)*K23*(4.D0*P1DP2)
     1 +D0(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*P1DP2)
     1 +D0(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*P1DP2)
     1 +D0(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2*P1DP2)
	if ( lwrite ) print *,'ampli: SD022'
       SD022=
     1 +D34(ME,MP,MW,MP,1,K23)*K23
     1 +D34(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D35(ME,MP,MW,MP,1,K23)*K23
     1 -D35(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D35(ME,MZ,MW,MP,1,K24)*K24*XAB
       SD022 = SD022
     1 +D35(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 -2.D0*D36(ME,MP,MW,MP,1,K23)*K23
     1 -2.D0*D36(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -2.D0*D36(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D36(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2)
     1 +2.D0*D37(ME,MP,MW,MP,1,K23)*K23
       SD022 = SD022
     1 +2.D0*D37(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +2.D0*D37(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D37(ME,MZ,MW,MZ,1,K22)*K22*(2.D0*XAB2)
     1 +4.D0*D38(ME,MP,MW,MP,1,K23)*K23
     1 +4.D0*D38(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +4.D0*D38(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D38(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2)
       SD022 = SD022
     1 -4.D0*D39(ME,MP,MW,MP,1,K23)*K23
     1 -4.D0*D39(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -4.D0*D39(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D39(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2)
     1 -2.D0*D22(ME,MP,MW,MP,1,K23)*K23
     1 -2.D0*D22(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -2.D0*D22(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D22(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2)
       SD022 = SD022
     1 -2.D0*D23(ME,MP,MW,MP,1,K23)*K23
     1 -2.D0*D23(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -2.D0*D23(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D23(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2)
     1 +2.D0*D24(ME,MP,MW,MP,1,K23)*K23
     1 +2.D0*D24(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +2.D0*D24(ME,MZ,MW,MP,1,K24)*K24*XAB
       SD022 = SD022
     1 +D24(ME,MZ,MW,MZ,1,K22)*K22*(2.D0*XAB2)
     1 -2.D0*D25(ME,MP,MW,MP,1,K23)*K23
     1 -2.D0*D25(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -2.D0*D25(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D25(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2)
     1 +4.D0*D26(ME,MP,MW,MP,1,K23)*K23
     1 +4.D0*D26(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +4.D0*D26(ME,MZ,MW,MP,1,K24)*K24*XAB
       SD022 = SD022
     1 +D26(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2)
     1 +D12(ME,MP,MW,MP,1,K23)*K23
     1 +D12(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D12(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D13(ME,MP,MW,MP,1,K23)*K23
     1 -D13(ME,MP,MW,MZ,1,K24)*K24*XAB
       SD022 = SD022
     1 -D13(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
	if ( lwrite ) print *,'ampli: SD023'
       SD023=
     1 -4.D0*D311(ME,MP,MW,MP,1,K23)*K23
     1 -4.D0*D311(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -4.D0*D311(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D311(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2)
     1 +12.D0*D312(ME,MP,MW,MP,1,K23)*K23
     1 +12.D0*D312(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +12.D0*D312(ME,MZ,MW,MP,1,K24)*K24*XAB
       SD023 = SD023
     1 +D312(ME,MZ,MW,MZ,1,K22)*K22*(12.D0*XAB2)
     1 -12.D0*D313(ME,MP,MW,MP,1,K23)*K23
     1 -12.D0*D313(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -12.D0*D313(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D313(ME,MZ,MW,MZ,1,K22)*K22*(-12.D0*XAB2)
     1 +D21(ME,MP,MW,MP,1,K23)*K23*(8.D0*P1DP2)
       SD023 = SD023
     1 +D21(ME,MP,MW,MZ,1,K24)*K24*XAB*(8.D0*P1DP2)
     1 +D21(ME,MZ,MW,MP,1,K24)*K24*XAB*(8.D0*P1DP2)
     1 +D21(ME,MZ,MW,MZ,1,K22)*K22*(8.D0*XAB2*P1DP2)
     1 +D22(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2)
     1 +D22(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2)
     1 +D22(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2)
     1 +D22(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2*MW2)
       SD023 = SD023
     1 +D23(ME,MP,MW,MP,1,K23)*K23*(4.D0*MW2+8.D0*P1DP2)
     1 +D23(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*MW2+8.D0*P1DP2)
     1 +D23(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*MW2+8.D0*P1DP2)
     1 +D23(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2*MW2+8.D0*XAB2*P1DP2)
     1 +D24(ME,MP,MW,MP,1,K23)*K23*(4.D0*MW2-8.D0*P1DP2)
     1 +D24(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*MW2-8.D0*P1DP2)
     1 +D24(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*MW2-8.D0*P1DP2)
     1 +D24(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2*MW2-8.D0*XAB2*P1DP2)
       SD023 = SD023
     1 +D25(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2-16.D0*P1DP2)
     1 +D25(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2-16.D0*P1DP2)
     1 +D25(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2-16.D0*P1DP2)
     1 +D25(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2*MW2-16.D0*XAB2*P1DP2)
     1 +D26(ME,MP,MW,MP,1,K23)*K23*(8.D0*P1DP2)
     1 +D26(ME,MP,MW,MZ,1,K24)*K24*XAB*(8.D0*P1DP2)
     1 +D26(ME,MZ,MW,MP,1,K24)*K24*XAB*(8.D0*P1DP2)
       SD023 = SD023
     1 +D26(ME,MZ,MW,MZ,1,K22)*K22*(8.D0*XAB2*P1DP2)
     1 +16.D0*D27(ME,MP,MW,MP,1,K23)*K23
     1 +16.D0*D27(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +16.D0*D27(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D27(ME,MZ,MW,MZ,1,K22)*K22*(16.D0*XAB2)
     1 +D11(ME,MP,MW,MP,1,K23)*K23*(4.D0*P1DP2)
     1 +D11(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*P1DP2)
     1 +D11(ME,MZ,MW,MP,1,K24)*K24*XAB*(2.D0*MZ2+4.D0*P1DP2)
       SD023 = SD023
     1 +D11(ME,MZ,MW,MZ,1,K22)*K22*(2.D0*XAB2*MZ2+4.D0*XAB2*P1DP2)
     1 +D12(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2-12.D0*P1DP2)
     1 +D12(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2-12.D0*P1DP2)
     1 +D12(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2-2.D0*MZ2-12.D0*P1DP2)
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2*MW2-2.D0*XAB2*MZ2
     1                                       -12.D0*XAB2*P1DP2)
     1 +D13(ME,MP,MW,MP,1,K23)*K23*(4.D0*MW2+4.D0*P1DP2)
       SD023 = SD023
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*MW2+2.D0*MZ2+4.D0*P1DP2)
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*MW2+4.D0*P1DP2)
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(4.D0*XAB2*MW2+2.D0*XAB2*MZ2
     1                                       +4.D0*XAB2*P1DP2)
     1 +D0(ME,MP,MW,MP,1,K23)*K23*(-4.D0*P1DP2)
     1 +D0(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*P1DP2)
     1 +D0(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*P1DP2)
     1 +D0(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2*P1DP2)
	if ( lwrite ) print *,'ampli: TD021'
       TD021=
     1 +16.D0*D27(ME,MP,MW,MP,1,K23)*K23
     1 +16.D0*D27(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +16.D0*D27(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D27(ME,MZ,MW,MZ,1,K22)*K22*(16.D0*XAB2)
     1 +D12(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2-4.D0*P2DP3)
     1 +D12(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2+2.D0*MZ2-4.D0*P2DP3)
     1 +D12(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2+2.D0*MZ2-4.D0*P2DP3)
       TD021 = TD021
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(-MW**(-2)*MZ**4*XAB2-4.D0*XAB2*MW2
     1                                +4.D0*XAB2*MZ2-4.D0*XAB2*P2DP3)
     1 +D13(ME,MP,MW,MP,1,K23)*K23*(4.D0*MW2+4.D0*P2DP3)
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*MW2-2.D0*MZ2+4.D0*P2DP3)
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*MW2-2.D0*MZ2+4.D0*P2DP3)
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(MW**(-2)*MZ**4*XAB2+4.D0*XAB2*MW2
     1                               -4.D0*XAB2*MZ2+4.D0*XAB2*P2DP3)
	if ( lwrite ) print *,'ampli: TD022'
       TD022=
     1 +8.D0*D311(ME,MP,MW,MP,1,K23)*K23
     1 +8.D0*D311(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +8.D0*D311(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D311(ME,MZ,MW,MZ,1,K22)*K22*(8.D0*XAB2)
     1 -16.D0*D27(ME,MP,MW,MP,1,K23)*K23
     1 -16.D0*D27(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -16.D0*D27(ME,MZ,MW,MP,1,K24)*K24*XAB
       TD022 = TD022
     1 +D27(ME,MZ,MW,MZ,1,K22)*K22*(-16.D0*XAB2)
     1 +D11(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2-4.D0*P2DP3)
     1 +D11(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2-4.D0*P2DP3)
     1 +D11(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2-4.D0*P2DP3)
     1 +D11(ME,MZ,MW,MZ,1,K22)*K22*(-MW**(-2)*MZ**4*XAB2-4.D0*XAB2*MW2
     1                                              -4.D0*XAB2*P2DP3)
       TD022 = TD022
     1 +D12(ME,MP,MW,MP,1,K23)*K23*(4.D0*MW2+4.D0*P2DP3)
     1 +D12(ME,MP,MW,MZ,1,K24)*K24*XAB*(4.D0*MW2-2.D0*MZ2+4.D0*P2DP3)
     1 +D12(ME,MZ,MW,MP,1,K24)*K24*XAB*(4.D0*MW2-2.D0*MZ2+4.D0*P2DP3)
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(MW**(-2)*MZ**4*XAB2+4.D0*XAB2*MW2
     1                               -4.D0*XAB2*MZ2+4.D0*XAB2*P2DP3)
     1 +D13(ME,MP,MW,MP,1,K23)*K23*(-4.D0*MW2-4.D0*P2DP3)
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB*(-4.D0*MW2+2.D0*MZ2-4.D0*P2DP3)
       TD022 = TD022
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB*(-4.D0*MW2+2.D0*MZ2-4.D0*P2DP3)
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(-MW**(-2)*MZ**4*XAB2-4.D0*XAB2*MW2
     1                                +4.D0*XAB2*MZ2-4.D0*XAB2*P2DP3)
     1 +D0(ME,MP,MW,MZ,1,K24)*K24*XAB*(-2.D0*MZ2)
     1 +D0(ME,MZ,MW,MP,1,K24)*K24*XAB*(-2.D0*MZ2)
     1 +D0(ME,MZ,MW,MZ,1,K22)*K22*(-4.D0*XAB2*MZ2)
	if ( lwrite ) print *,'ampli: A2PQM'
       A2PQM=
     1 +D36(ME,MP,MW,MP,1,K23)*K23
     1 +D36(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D36(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D36(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 +D37(ME,MP,MW,MP,1,K23)*K23
     1 +D37(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D37(ME,MZ,MW,MP,1,K24)*K24*XAB
       A2PQM = A2PQM
     1 +D37(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -2.D0*D310(ME,MP,MW,MP,1,K23)*K23
     1 -2.D0*D310(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -2.D0*D310(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D310(ME,MZ,MW,MZ,1,K22)*K22*(-2.D0*XAB2)
     1 +D22(ME,MP,MW,MP,1,K23)*K23
     1 +D22(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D22(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D22(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
       A2PQM = A2PQM
     1 +D23(ME,MP,MW,MP,1,K23)*K23
     1 +D23(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D23(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D23(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D24(ME,MP,MW,MP,1,K23)*K23
     1 -D24(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D24(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D24(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 -3.D0*D25(ME,MP,MW,MP,1,K23)*K23
     1 -3.D0*D25(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -3.D0*D25(ME,MZ,MW,MP,1,K24)*K24*XAB
       A2PQM = A2PQM
     1 +D25(ME,MZ,MW,MZ,1,K22)*K22*(-3.D0*XAB2)
     1 +2.D0*D26(ME,MP,MW,MP,1,K23)*K23
     1 +2.D0*D26(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +2.D0*D26(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D26(ME,MZ,MW,MZ,1,K22)*K22*(2.D0*XAB2)
     1 -D12(ME,MP,MW,MP,1,K23)*K23
     1 -D12(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D12(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
       A2PQM = A2PQM
     1 +D13(ME,MP,MW,MP,1,K23)*K23
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
	if ( lwrite ) print *,'ampli: A2PQP'
       A2PQP=
     1 +D34(ME,MP,MW,MP,1,K23)*K23
     1 +D34(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D35(ME,MP,MW,MP,1,K23)*K23
     1 -D35(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D35(ME,MZ,MW,MP,1,K24)*K24*XAB
       A2PQP = A2PQP
     1 +D35(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 -D36(ME,MP,MW,MP,1,K23)*K23
     1 -D36(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D36(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D36(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 +D37(ME,MP,MW,MP,1,K23)*K23
     1 +D37(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D37(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D37(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
       A2PQP = A2PQP
     1 -D22(ME,MP,MW,MP,1,K23)*K23
     1 -D22(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D22(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D22(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 +D23(ME,MP,MW,MP,1,K23)*K23
     1 +D23(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D23(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D23(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 +D24(ME,MP,MW,MP,1,K23)*K23
       A2PQP = A2PQP
     1 +D24(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D24(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D24(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D25(ME,MP,MW,MP,1,K23)*K23
     1 -D25(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D25(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D25(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
	if ( lwrite ) print *,'ampli: A2QQS'
       A2QQS=
     1 +D34(ME,MP,MW,MP,1,K23)*K23
     1 +D34(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D34(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)
     1 -D35(ME,MP,MW,MP,1,K23)*K23
     1 -D35(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D35(ME,MZ,MW,MP,1,K24)*K24*XAB
       A2QQS = A2QQS
     1 +D35(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 -D12(ME,MP,MW,MP,1,K23)*K23
     1 -D12(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 -D12(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D12(ME,MZ,MW,MZ,1,K22)*K22*(-XAB2)
     1 +D13(ME,MP,MW,MP,1,K23)*K23
     1 +D13(ME,MP,MW,MZ,1,K24)*K24*XAB
     1 +D13(ME,MZ,MW,MP,1,K24)*K24*XAB
     1 +D13(ME,MZ,MW,MZ,1,K22)*K22*(XAB2)+0.
C
      IF(ICR.EQ.2) GOTO 30
C     NUMERISCHES CROSSING NUR FUER D'S (C'S SIND ANAL. GECR.).
      K11=KEE
	if ( lwrite ) print *,'ampli: calling set'
      CALL SET
      IF(I.EQ.2) GOTO 6
C
	if ( lwrite ) print *,'ampli: SD01'
       SD01(1)=
     1 +C0(MN,ME,ME,1)*(8.D0*K09*DAB2+8.D0*K10)
     1 +C0(MP,MW,MW,1)*(-2.D0*K19)
     1 +C0(ME,MN,MN,1)*(16.D0*K11)
     1 +C0(MZ,MW,MW,1)*(-2.D0*K18)
     1 +C11(MP,MW,MW,1)*(-2.D0*K19)
     1 +C11(MZ,MW,MW,1)*(-2.D0*K18)
       SD01(2)=0.
      CALL SET
       SD01(3)=+C0(MN,MW,MW,3)*(8.D0*K18+8.D0*K19)
      CALL SET
       SD01(5)=+C0(MW,MN,ME,5)*(-16.D0*K11)
	if ( lwrite ) print *,'ampli: SD02'
       SD02(1)=0.
       SD02(2)=0.
       SD02(3)=0.
       SD02(5)=0.
      CALL SET
	if ( lwrite ) print *,'ampli: SD03'
       SD03(1)=
     1 +C0(MN,ME,ME,1)*(-8.D0*K09*DAB2-8.D0*K10)
     1 +C0(MP,MW,MW,1)*(4.D0*K19)
     1 +C0(ME,MN,MN,1)*(-16.D0*K11)
     1 +C0(MZ,MW,MW,1)*(4.D0*K18)
     1 +C11(MP,MW,MW,1)*(-2.D0*K19)
     1 +C11(MZ,MW,MW,1)*(-2.D0*K18)
     1 +C12(MN,ME,ME,1)*(8.D0*K09*DAB2+8.D0*K10)
     1 +C12(MP,MW,MW,1)*(16.D0*K19)
     1 +C12(ME,MN,MN,1)*(-8.D0*K11)
     1 +C12(MZ,MW,MW,1)*(16.D0*K18)
       SD03(2)=0.
      CALL SET
       SD03(3)=
     1 +C0(MN,MW,MW,3)*(-8.D0*K18-8.D0*K19)
     1 +C0(MP,ME,ME,3)*(8.D0*K10)
     1 +C0(MW,MN,MN,3)*(-8.D0*K11)
     1 +C0(MZ,ME,ME,3)*(8.D0*K09*DAB2)
     1 +C11(MN,MW,MW,3)*(8.D0*MW**(-2)*MZ**2*K18+8.D0*K18+8.D0*K19)
     1 +C11(MP,ME,ME,3)*(8.D0*K10)
     1 +C11(MW,MN,MN,3)*(-8.D0*K11)
     1 +C11(MZ,ME,ME,3)*(8.D0*K09*DAB2)
     1 +C12(MN,MW,MW,3)*(-16.D0*K18-16.D0*K19)
     1 +C12(MP,ME,ME,3)*(-8.D0*K10)
     1 +C12(MW,MN,MN,3)*(8.D0*K11)
     1 +C12(MZ,ME,ME,3)*(-8.D0*K09*DAB2)
      CALL SET
       SD03(5)=+C11(MW,MN,ME,5)*(-16.D0*K11)
      CALL SET
	if ( lwrite ) print *,'ampli: TD01'
       TD01(1)=
     1 +C0(MN,ME,ME,1)*(-24.D0*K09*DAB2-24.D0*K10)
     1 +C0(ME,MN,MN,1)*(-24.D0*K11)
      CALL SET
       TD01(2)=
     1 +C0(MP,MN,ME,2)*(16.D0*K10)
     1 +C0(MZ,MN,ME,2)*(16.D0*K09*DAB2)
     1 +C11(MN,MP,MW,2)*(-8.D0*K19)
     1 +C11(MN,MZ,MW,2)*(-8.D0*K18)
     1 +C12(MN,MP,MW,2)*(8.D0*K19)
     1 +C12(MN,MZ,MW,2)*(8.D0*K18)
       TD01(3)=0.
      CALL SET
       TD01(5)=+C0(MW,MN,ME,5)*(16.D0*K11)
      CALL SET
	if ( lwrite ) print *,'ampli: TD02'
       TD02(1)=
     1 +C0(MN,ME,ME,1)*(24.D0*K09*DAB2+24.D0*K10)
     1 +C0(ME,MN,MN,1)*(24.D0*K11)
      CALL SET
       TD02(2)=
     1 +C0(MN,MP,MW,2)*(16.D0*K19)
     1 +C0(MN,MZ,MW,2)*(16.D0*K18)
     1 +C11(MN,MP,MW,2)*(16.D0*K19)
     1 +C11(MN,MZ,MW,2)*(16.D0*K18)
     1 +C11(MP,MN,ME,2)*(16.D0*K10)
     1 +C11(MZ,MN,ME,2)*(16.D0*K09*DAB2)
     1 +C12(MN,MP,MW,2)*(-8.D0*K19)
     1 +C12(MN,MZ,MW,2)*(-8.D0*K18)
      CALL SET
       TD02(3)=
     1 +C11(MN,MW,MW,3)*(-4.D0*MW**(-2)*MZ**2*K18+4.D0*K18+4.D0*K19)
      CALL SET
       TD02(5)=+C11(MW,MN,ME,5)*(16.D0*K11)
C
    6 CONTINUE
C
	if ( lwrite ) print *,'ampli: ST01'
       ST01(1)=0.
       ST01(2)=0.
       ST01(3)=0.
      CALL SET
       ST01(5)=
     1 +C12(ME,MP,MW,5)*(2.D0*K23+2.D0*K24*XAB)
     1 +C12(ME,MZ,MW,5)*(2.D0*K22*XAB2+2.D0*K24*XAB)
	if ( lwrite ) print *,'ampli: ST02'
       ST02(1)=0.
       ST02(2)=0.
       ST02(3)=0.
       ST02(5)=0.
	if ( lwrite ) print *,'ampli: ST03'
       ST03(1)=0.
       ST03(2)=0.
       ST03(3)=0.
       ST03(5)=
     1 +C0(ME,MP,MW,5)*(-4.D0*K23-4.D0*K24*XAB)
     1 +C0(ME,MZ,MW,5)*(-4.D0*K22*XAB2-4.D0*K24*XAB)
     1 +C11(ME,MP,MW,5)*(-2.D0*K23-2.D0*K24*XAB)
     1 +C11(ME,MZ,MW,5)*(-2.D0*K22*XAB2-2.D0*K24*XAB)
     1 +C12(ME,MP,MW,5)*(-2.D0*K23-2.D0*K24*XAB)
     1 +C12(ME,MZ,MW,5)*(-2.D0*K22*XAB2-2.D0*K24*XAB)
	if ( lwrite ) print *,'ampli: TT01'
       TT01(1)=0.
      CALL SET
       TT01(2)=
     1 +C11(ME,MW,MP,2)*(-2.D0*K23-2.D0*K24*XAB)
     1 +C11(ME,MW,MZ,2)*(-2.D0*K22*XAB2-2.D0*K24*XAB)
     1 +C12(ME,MW,MP,2)*(2.D0*K23+2.D0*K24*XAB)
     1 +C12(ME,MW,MZ,2)*(2.D0*K22*XAB2+2.D0*K24*XAB)
       TT01(3)=0.
      CALL SET
       TT01(5)=
     1 +C12(ME,MP,MW,5)*(-2.D0*K23-2.D0*K24*XAB)
     1 +C12(ME,MZ,MW,5)*(-2.D0*K22*XAB2-2.D0*K24*XAB)
	if ( lwrite ) print *,'ampli: TT02'
       TT02(1)=0.
      CALL SET
       TT02(2)=
     1 +C0(ME,MW,MP,2)*(4.D0*K23+4.D0*K24*XAB)
     1 +C0(ME,MW,MZ,2)*(4.D0*K22*XAB2+4.D0*K24*XAB)
     1 +C11(ME,MW,MP,2)*(4.D0*K23+4.D0*K24*XAB)
     1 +C11(ME,MW,MZ,2)*(4.D0*K22*XAB2+4.D0*K24*XAB)
     1 +C12(ME,MW,MP,2)*(-2.D0*K23-2.D0*K24*XAB)
     1 +C12(ME,MW,MZ,2)*(-2.D0*K22*XAB2-2.D0*K24*XAB)
       TT02(3)=0.
      CALL SET
       TT02(5)=
     1 +C0(ME,MP,MW,5)*(4.D0*K23+4.D0*K24*XAB)
     1 +C0(ME,MZ,MW,5)*(4.D0*K22*XAB2+4.D0*K24*XAB)
     1 +C11(ME,MP,MW,5)*(2.D0*K23+2.D0*K24*XAB)
     1 +C11(ME,MZ,MW,5)*(2.D0*K22*XAB2+2.D0*K24*XAB)
     1 +C12(ME,MP,MW,5)*(2.D0*K23+2.D0*K24*XAB)
     1 +C12(ME,MZ,MW,5)*(2.D0*K22*XAB2+2.D0*K24*XAB)
C
      IF(I  .EQ.1) GOTO 10
      IF(I  .EQ.2) GOTO 20
   10 U01=   +SD011    +SD021
      U02=   +SD012    +SD022
      U03=   +SD013    +SD023
      V01=   +TD011    +TD021
      V02=   +TD012    +TD022
      V0X=A1PQM+A2PQM
      V0Y=A1PQP+A2PQP
      V0Z=A1QQS+A2QQS
      DO 15 ICH=1,6
      U01=U01+SD01(ICH)+ST01(ICH)
      U02=U02+SD02(ICH)+ST02(ICH)
      U03=U03+SD03(ICH)+ST03(ICH)
      V01=V01+TD01(ICH)+TT01(ICH)
      V02=V02+TD02(ICH)+TT02(ICH)
   15 CONTINUE
      GOTO 100
   20 U01=             +SD021
      U02=             +SD022
      U03=             +SD023
      V01=             +TD021
      V02=             +TD022
      V0X=      A2PQM
      V0Y=      A2PQP
      V0Z=      A2QQS
      DO 25 ICH=1,6
      U01=U01          +ST01(ICH)
      U02=U02          +ST02(ICH)
      U03=U03          +ST03(ICH)
      V01=V01          +TT01(ICH)
      V02=V02          +TT02(ICH)
   25 CONTINUE
      GOTO 100
   30 CONTINUE
      IF(I  .EQ.1) GOTO 40
      IF(I  .EQ.2) GOTO 50
   40 S01=U01-(SD011+SD021)-(TD011+TD021)
      S02=U02-(SD012+SD022)
      S03=U03-(SD013+SD023)-(TD012+TD022)
      T01=V01+TD011+TD021
      T02=V02+TD012+TD022
      E0X=V0X+A1PQM+A2PQM
      E0Y=V0Y-A1PQP-A2PQP
      E0Z=V0Z-A1QQS-A2QQS
      GOTO 100
   50 S01=U01-       SD021 -       TD021
      S02=U02-       SD022
      S03=U03-       SD023 -       TD022
      T01=V01      +TD021
      T02=V02      +TD022
      E0X=V0X+      A2PQM
      E0Y=V0Y-      A2PQP
      E0Z=V0Z-      A2QQS
  100 CONTINUE
C
C     SCALAR RE-CROSSING
      U    =S5
      S5   =S7
      S7   =U
      P1DP2=(S5-S1-S2)/2.D0
      P1DP3=(S7-S1-S3)/2.D0
      P2DP4=(S7-S2-S4)/2.D0
      P3DP4=(S5-S3-S4)/2.D0
C
C
C
      IF(I.EQ.2) GOTO 200
C
      CALL SET
C
	if ( lwrite ) print *,'ampli: SX011'
       SX011=
     1 +D312(MN,MW,MP,ME,2,K29)*(16.D0*K29)
     1 +D312(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28)
     1 -16.D0*D312(MP,ME,MN,MW,2,K31)*K31
     1 -16.D0*D312(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D27(MN,MW,MP,ME,2,K29)*(32.D0*K29)
     1 +D27(MN,MW,MZ,ME,2,K28)*DAB*(32.D0*K28)
     1 +16.D0*D27(MP,ME,MN,MW,2,K31)*K31
       SX011 = SX011
     1 +16.D0*D27(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D12(MN,MW,MP,ME,2,K29)*(-8.D0*K29*MW2-16.D0*K29*P1DP2)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MW2-16.D0*K28*P1DP2)
     1 +D12(MP,ME,MN,MW,2,K31)*K31*(8.D0*MW2+16.D0*P1DP2)
     1 +D12(MZ,ME,MN,MW,2,K30)*K30*DAB*(8.D0*MW2+16.D0*P1DP2)
     1 +D0(MN,MW,MP,ME,2,K29)*(-8.D0*K29*MW2-16.D0*K29*P1DP2)
       SX011 = SX011
     1 +D0(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MW2+8.D0*K28*MZ2
     1                                     -16.D0*K28*P1DP2)
     1 +D0(MZ,ME,MN,MW,2,K30)*K30*DAB*(8.D0*MZ2)
	if ( lwrite ) print *,'ampli: SX012'
       SX012=
     1 +D34(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D34(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D34(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D34(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D36(MN,MW,MP,ME,2,K29)*(8.D0*K29)
     1 +D36(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28)
     1 -8.D0*D36(MP,ME,MN,MW,2,K31)*K31
       SX012 = SX012
     1 -8.D0*D36(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D38(MN,MW,MP,ME,2,K29)*(8.D0*K29)
     1 +D38(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28)
     1 -8.D0*D38(MP,ME,MN,MW,2,K31)*K31
     1 -8.D0*D38(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D39(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
       SX012 = SX012
     1 +D39(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D39(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D39(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D310(MN,MW,MP,ME,2,K29)*(-8.D0*K29)
     1 +D310(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28)
     1 +8.D0*D310(MP,ME,MN,MW,2,K31)*K31
     1 +8.D0*D310(MZ,ME,MN,MW,2,K30)*K30*DAB
       SX012 = SX012
     1 +D22(MN,MW,MP,ME,2,K29)*(8.D0*K29)
     1 +D22(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28)
     1 -8.D0*D22(MP,ME,MN,MW,2,K31)*K31
     1 -8.D0*D22(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D23(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D23(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D23(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D23(MZ,ME,MN,MW,2,K30)*K30*DAB
       SX012 = SX012
     1 +D24(MN,MW,MP,ME,2,K29)*(-8.D0*K29)
     1 +D24(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28)
     1 -4.D0*D24(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D24(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D25(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D25(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D25(MP,ME,MN,MW,2,K31)*K31
       SX012 = SX012
     1 +4.D0*D25(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D26(MN,MW,MP,ME,2,K29)*(8.D0*K29)
     1 +D26(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28)
     1 +4.D0*D26(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D26(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D12(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 -8.D0*D12(MP,ME,MN,MW,2,K31)*K31
       SX012 = SX012
     1 -8.D0*D12(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D13(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D13(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 +8.D0*D13(MP,ME,MN,MW,2,K31)*K31
     1 +8.D0*D13(MZ,ME,MN,MW,2,K30)*K30*DAB
	if ( lwrite ) print *,'ampli: SX013'
       SX013=
     1 +D311(MN,MW,MP,ME,2,K29)*(16.D0*K29)
     1 +D311(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28)
     1 -16.D0*D311(MP,ME,MN,MW,2,K31)*K31
     1 -16.D0*D311(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D312(MN,MW,MP,ME,2,K29)*(-48.D0*K29)
     1 +D312(MN,MW,MZ,ME,2,K28)*DAB*(-48.D0*K28)
     1 +48.D0*D312(MP,ME,MN,MW,2,K31)*K31
       SX013 = SX013
     1 +48.D0*D312(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D313(MN,MW,MP,ME,2,K29)*(-16.D0*K29)
     1 +D313(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28)
     1 +16.D0*D313(MP,ME,MN,MW,2,K31)*K31
     1 +16.D0*D313(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D21(MN,MW,MP,ME,2,K29)*(-32.D0*K29*P1DP2)
       SX013 = SX013
     1 +D21(MN,MW,MZ,ME,2,K28)*DAB*(-32.D0*K28*P1DP2)
     1 +D21(MP,ME,MN,MW,2,K31)*K31*(-16.D0*P1DP2)
     1 +D21(MZ,ME,MN,MW,2,K30)*K30*DAB*(-16.D0*P1DP2)
     1 +D22(MN,MW,MP,ME,2,K29)*(16.D0*K29*MW2)
     1 +D22(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28*MW2)
     1 +D22(MP,ME,MN,MW,2,K31)*K31*(8.D0*MW2)
     1 +D22(MZ,ME,MN,MW,2,K30)*K30*DAB*(8.D0*MW2)
       SX013 = SX013
     1 +D24(MN,MW,MP,ME,2,K29)*(-16.D0*K29*MW2+32.D0*K29*P1DP2)
     1 +D24(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*MW2+32.D0*K28*P1DP2)
     1 +D24(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2+16.D0*P1DP2)
     1 +D24(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2+16.D0*P1DP2)
     1 +D25(MN,MW,MP,ME,2,K29)*(-16.D0*K29*P1DP2)
     1 +D25(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*P1DP2)
     1 +D25(MP,ME,MN,MW,2,K31)*K31*(-32.D0*P1DP2)
     1 +D25(MZ,ME,MN,MW,2,K30)*K30*DAB*(-32.D0*P1DP2)
       SX013 = SX013
     1 +D26(MN,MW,MP,ME,2,K29)*(-8.D0*K29*MW2)
     1 +D26(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MW2)
     1 +D26(MP,ME,MN,MW,2,K31)*K31*(-16.D0*MW2)
     1 +D26(MZ,ME,MN,MW,2,K30)*K30*DAB*(-16.D0*MW2)
     1 +D27(MN,MW,MP,ME,2,K29)*(-64.D0*K29)
     1 +D27(MN,MW,MZ,ME,2,K28)*DAB*(-64.D0*K28)
     1 -32.D0*D27(MP,ME,MN,MW,2,K31)*K31
       SX013 = SX013
     1 -32.D0*D27(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D11(MN,MW,MP,ME,2,K29)*(-16.D0*K29*MW2-16.D0*K29*P1DP2)
     1 +D11(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*MW2+8.D0*K28*MZ2
     1                                       -16.D0*K28*P1DP2)
     1 +D11(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2-32.D0*P1DP2)
     1 +D11(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2-32.D0*P1DP2)
     1 +D12(MN,MW,MP,ME,2,K29)*(32.D0*K29*MW2+48.D0*K29*P1DP2)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(32.D0*K28*MW2-8.D0*K28*MZ2
     1                                      +48.D0*K28*P1DP2)
     1 +D12(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2)
       SX013 = SX013
     1 +D12(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2)
     1 +D13(MN,MW,MP,ME,2,K29)*(-8.D0*K29*MW2-32.D0*K29*P1DP2)
     1 +D13(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MW2+8.D0*K28*MZ2
     1                                      -32.D0*K28*P1DP2)
     1 +D13(MP,ME,MN,MW,2,K31)*K31*(16.D0*P1DP3+16.D0*P2DP3)
     1 +D13(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MZ2+16.D0*P1DP3+
     +		16.D0*P2DP3) 
     1 +D0(MN,MW,MP,ME,2,K29)*(8.D0*K29*MW2+16.D0*K29*P1DP2)
       SX013 = SX013
     1 +D0(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28*MW2-8.D0*K28*MZ2
     1                                    +16.D0*K28*P1DP2)
     1 +D0(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2-16.D0*P1DP2)
     1 +D0(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2-8.D0*MZ2-16.D0*P1DP2)
	if ( lwrite ) print *,'ampli: TX011'
       TX011=
     1 +D27(MN,MW,MP,ME,2,K29)*(-48.D0*K29)
     1 +D27(MN,MW,MZ,ME,2,K28)*DAB*(-48.D0*K28)
     1 -48.D0*D27(MP,ME,MN,MW,2,K31)*K31
     1 -48.D0*D27(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D12(MN,MW,MP,ME,2,K29)*(8.D0*K29*MW2+24.D0*K29*P1DP2-
     +		8.D0*K29*P1DP3+8.D0*K29*P2DP3)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28*MW2+24.D0*K28*P1DP2
     1                        -8.D0*K28*P1DP3+8.D0*K28*P2DP3)
       TX011 = TX011
     1 +D12(MP,ME,MN,MW,2,K31)*K31*(-16.D0*MW2-32.D0*P1DP2-16.D0*P2DP3)
     1 +D12(MZ,ME,MN,MW,2,K30)*K30*DAB*(-16.D0*MW2-32.D0*P1DP2-
     +		16.D0*P2DP3)
     1 +D0(MN,MW,MP,ME,2,K29)*(16.D0*K29*P1DP2)
     1 +D0(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MZ2+16.D0*K28*P1DP2)
     1 +D0(MP,ME,MN,MW,2,K31)*K31*(16.D0*P1DP3)
       TX011 = TX011
     1 +D0(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MZ2+16.D0*P1DP3)
	if ( lwrite ) print *,'ampli: TX012'
       TX012=
     1 +D311(MN,MW,MP,ME,2,K29)*(-32.D0*K29)
     1 +D311(MN,MW,MZ,ME,2,K28)*DAB*(-32.D0*K28)
     1 +32.D0*D311(MP,ME,MN,MW,2,K31)*K31
     1 +32.D0*D311(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D313(MN,MW,MP,ME,2,K29)*(32.D0*K29)
     1 +D313(MN,MW,MZ,ME,2,K28)*DAB*(32.D0*K28)
     1 -32.D0*D313(MP,ME,MN,MW,2,K31)*K31
       TX012 = TX012
     1 -32.D0*D313(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D21(MN,MW,MP,ME,2,K29)*(16.D0*K29*P1DP2)
     1 +D21(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28*P1DP2)
     1 +D21(MP,ME,MN,MW,2,K31)*K31*(-16.D0*P1DP2)
     1 +D21(MZ,ME,MN,MW,2,K30)*K30*DAB*(-16.D0*P1DP2)
     1 +D24(MN,MW,MP,ME,2,K29)*(8.D0*K29*MW2)
       TX012 = TX012
     1 +D24(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28*MW2)
     1 +D24(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2)
     1 +D24(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2)
     1 +D25(MN,MW,MP,ME,2,K29)*(-16.D0*K29*P1DP2)
     1 +D25(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*P1DP2)
     1 +D25(MP,ME,MN,MW,2,K31)*K31*(16.D0*P1DP2)
     1 +D25(MZ,ME,MN,MW,2,K30)*K30*DAB*(16.D0*P1DP2)
       TX012 = TX012
     1 +D26(MN,MW,MP,ME,2,K29)*(-8.D0*K29*MW2)
     1 +D26(MN,MW,MZ,ME,2,K28)*DAB*(-8.D0*K28*MW2)
     1 +D26(MP,ME,MN,MW,2,K31)*K31*(8.D0*MW2)
     1 +D26(MZ,ME,MN,MW,2,K30)*K30*DAB*(8.D0*MW2)
     1 +D27(MN,MW,MP,ME,2,K29)*(48.D0*K29)
     1 +D27(MN,MW,MZ,ME,2,K28)*DAB*(48.D0*K28)
     1 +96.D0*D27(MP,ME,MN,MW,2,K31)*K31
     1 +96.D0*D27(MZ,ME,MN,MW,2,K30)*K30*DAB
       TX012 = TX012
     1 +D11(MN,MW,MP,ME,2,K29)*(16.D0*K29*MW2-8.D0*K29*P1DP2-
     +		8.D0*K29*P1DP3+8.D0*K29*P2DP3)
     1 +D11(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28*MW2-8.D0*K28*P1DP2
     1                        -8.D0*K28*P1DP3+8.D0*K28*P2DP3)
     1 +D11(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2-32.D0*P1DP2+16.D0*P1DP3)
     1 +D11(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2-8.D0*MZ2-32.D0*P1DP2
     1                                                +16.D0*P1DP3)
       TX012 = TX012
     1 +D12(MN,MW,MP,ME,2,K29)*(-16.D0*K29*MW2-24.D0*K29*P1DP2
     1                      +8.D0*K29*P1DP3-8.D0*K29*P2DP3)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*MW2-24.D0*K28*P1DP2
     1                          +8.D0*K28*P1DP3-8.D0*K28*P2DP3)
     1 +D12(MP,ME,MN,MW,2,K31)*K31*(32.D0*P1DP2+16.D0*P2DP3)
     1 +D12(MZ,ME,MN,MW,2,K30)*K30*DAB*(32.D0*P1DP2+16.D0*P2DP3)
     1 +D13(MN,MW,MP,ME,2,K29)*(-16.D0*K29*MW2-8.D0*K29*P1DP2
     1                     +8.D0*K29*P1DP3-8.D0*K29*P2DP3)
     1 +D13(MN,MW,MZ,ME,2,K28)*DAB*(-16.D0*K28*MW2-8.D0*K28*P1DP2
     1                         +8.D0*K28*P1DP3-8.D0*K28*P2DP3)
       TX012 = TX012
     1 +D13(MP,ME,MN,MW,2,K31)*K31*(8.D0*MW2-16.D0*P1DP3)
     1 +D13(MZ,ME,MN,MW,2,K30)*K30*DAB*(8.D0*MW2+8.D0*MZ2-16.D0*P1DP3)
     1 +D0(MN,MW,MP,ME,2,K29)*(-32.D0*K29*P1DP2)
     1 +D0(MN,MW,MZ,ME,2,K28)*DAB*(16.D0*K28*MZ2-32.D0*K28*P1DP2)
     1 +D0(MP,ME,MN,MW,2,K31)*K31*(-8.D0*MW2-16.D0*P1DP2)
     1 +D0(MZ,ME,MN,MW,2,K30)*K30*DAB*(-8.D0*MW2-16.D0*P1DP2)
	if ( lwrite ) print *,'ampli: A1PQM'
       A1PQM=
     1 +D36(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D36(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D36(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D36(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D38(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D38(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D38(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D38(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1PQM = A1PQM
     1 +D22(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D22(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D22(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D22(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D24(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D24(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 +8.D0*D24(MP,ME,MN,MW,2,K31)*K31
     1 +8.D0*D24(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D25(MN,MW,MP,ME,2,K29)*(-12.D0*K29)
       A1PQM = A1PQM
     1 +D25(MN,MW,MZ,ME,2,K28)*DAB*(-12.D0*K28)
     1 -12.D0*D25(MP,ME,MN,MW,2,K31)*K31
     1 -12.D0*D25(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D26(MN,MW,MP,ME,2,K29)*(12.D0*K29)
     1 +D26(MN,MW,MZ,ME,2,K28)*DAB*(12.D0*K28)
     1 +D12(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 +8.D0*D12(MP,ME,MN,MW,2,K31)*K31
     1 +8.D0*D12(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1PQM = A1PQM
     1 +D13(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D13(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 -8.D0*D13(MP,ME,MN,MW,2,K31)*K31
     1 -8.D0*D13(MZ,ME,MN,MW,2,K30)*K30*DAB
	if ( lwrite ) print *,'ampli: A1PQP'
       A1PQP=
     1 +D34(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D34(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D34(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D34(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D36(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D36(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D36(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D36(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1PQP = A1PQP
     1 +D38(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D38(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D38(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D38(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D39(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D39(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D39(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D39(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D22(MN,MW,MP,ME,2,K29)*(4.D0*K29)
       A1PQP = A1PQP
     1 +D22(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D22(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D22(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D23(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D23(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D23(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D23(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D24(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D24(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D24(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D24(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1PQP = A1PQP
     1 +D26(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D26(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D26(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D26(MZ,ME,MN,MW,2,K30)*K30*DAB
	if ( lwrite ) print *,'ampli: A1QQS'
       A1QQS=
     1 +D34(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D34(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D34(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D34(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D39(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D39(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D39(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D39(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1QQS = A1QQS
     1 +D310(MN,MW,MP,ME,2,K29)*(8.D0*K29)
     1 +D310(MN,MW,MZ,ME,2,K28)*DAB*(8.D0*K28)
     1 -8.D0*D310(MP,ME,MN,MW,2,K31)*K31
     1 -8.D0*D310(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D23(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D23(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 +4.D0*D23(MP,ME,MN,MW,2,K31)*K31
     1 +4.D0*D23(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +12.D0*D24(MP,ME,MN,MW,2,K31)*K31
     1 +12.D0*D24(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1QQS = A1QQS
     1 +D25(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D25(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 -4.D0*D25(MP,ME,MN,MW,2,K31)*K31
     1 -4.D0*D25(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 -12.D0*D26(MP,ME,MN,MW,2,K31)*K31
     1 -12.D0*D26(MZ,ME,MN,MW,2,K30)*K30*DAB
     1 +D12(MN,MW,MP,ME,2,K29)*(4.D0*K29)
     1 +D12(MN,MW,MZ,ME,2,K28)*DAB*(4.D0*K28)
     1 +8.D0*D12(MP,ME,MN,MW,2,K31)*K31
     1 +8.D0*D12(MZ,ME,MN,MW,2,K30)*K30*DAB
       A1QQS = A1QQS
     1 +D13(MN,MW,MP,ME,2,K29)*(-4.D0*K29)
     1 +D13(MN,MW,MZ,ME,2,K28)*DAB*(-4.D0*K28)
     1 -8.D0*D13(MP,ME,MN,MW,2,K31)*K31
     1 -8.D0*D13(MZ,ME,MN,MW,2,K30)*K30*DAB+0.
C
      S01= S01+SX011
      S02= S02+SX012
      S03= S03+SX013
      T01= T01+TX011
      T02= T02+TX012
      E0X= E0X+A1PQM
      E0Y= E0Y+A1PQP
      E0Z= E0Z+A1QQS
C
      CALL SET
C
	if ( lwrite ) print *,'ampli: SX01'
       SX01(1)=0.
       SX01(2)=0.
       SX01(3)=0.
       SX01(5)=
     1 +C0(MW,MN,ME,5)*(-8.D0*K29-8.D0*K31)
     1 +C0(MW,MN,ME,5)*DAB*(-8.D0*K28-8.D0*K30)
     1 +C12(ME,MP,MW,5)*(4.D0*K29+4.D0*K31)
     1 +C12(ME,MZ,MW,5)*DAB*(4.D0*K28+4.D0*K30)
	if ( lwrite ) print *,'ampli: SX02'
       SX02(1)=0.
       SX02(2)=0.
       SX02(3)=0.
       SX02(5)=0.
	if ( lwrite ) print *,'ampli: SX03'
       SX03(1)=0.
       SX03(2)=0.
       SX03(3)=0.
      CALL SET
       SX03(5)=
     1 +C0(ME,MP,MW,5)*(-8.D0*K29)
     1 +C0(ME,MZ,MW,5)*DAB*(-8.D0*K28)
     1 +C0(MW,MN,ME,5)*(16.D0*K29)
     1 +C0(MW,MN,ME,5)*DAB*(16.D0*K28)
     1 +C11(ME,MP,MW,5)*(-4.D0*K29+4.D0*K31)
     1 +C11(ME,MZ,MW,5)*DAB*(-4.D0*K28+4.D0*K30)
     1 +C11(MW,MN,ME,5)*(8.D0*K29-8.D0*K31)
     1 +C11(MW,MN,ME,5)*DAB*(8.D0*K28-8.D0*K30)
     1 +C12(ME,MP,MW,5)*(-4.D0*K29-20.D0*K31)
     1 +C12(ME,MZ,MW,5)*DAB*(-4.D0*K28-20.D0*K30)
     1 +C12(MW,MN,ME,5)*(-8.D0*K29)
     1 +C12(MW,MN,ME,5)*DAB*(-8.D0*K28)
      CALL SET
	if ( lwrite ) print *,'ampli: TX01'
       TX01(1)=0.
      CALL SET
       TX01(2)=
     1 +C0(MP,MN,ME,2)*(8.D0*K29+8.D0*K31)
     1 +C0(MZ,MN,ME,2)*DAB*(8.D0*K28+8.D0*K30)
     1 +C11(MN,MP,MW,2)*(-4.D0*K29-4.D0*K31)
     1 +C11(MN,MZ,MW,2)*DAB*(-4.D0*K28-4.D0*K30)
     1 +C12(MN,MP,MW,2)*(4.D0*K29+4.D0*K31)
     1 +C12(MN,MZ,MW,2)*DAB*(4.D0*K28+4.D0*K30)
       TX01(3)=0.
      CALL SET
       TX01(5)=
     1 +C0(MW,MN,ME,5)*(8.D0*K29+8.D0*K31)
     1 +C0(MW,MN,ME,5)*DAB*(8.D0*K28+8.D0*K30)
     1 +C12(ME,MP,MW,5)*(-4.D0*K29-4.D0*K31)
     1 +C12(ME,MZ,MW,5)*DAB*(-4.D0*K28-4.D0*K30)
	if ( lwrite ) print *,'ampli: TX02'
       TX02(1)=0.
      CALL SET
       TX02(2)=
     1 +C0(MN,MP,MW,2)*(8.D0*K29+8.D0*K31)
     1 +C0(MN,MZ,MW,2)*DAB*(8.D0*K28+8.D0*K30)
     1 +C11(MN,MP,MW,2)*(8.D0*K29+8.D0*K31)
     1 +C11(MN,MZ,MW,2)*DAB*(8.D0*K28+8.D0*K30)
     1 +C11(MP,MN,ME,2)*(8.D0*K29+8.D0*K31)
     1 +C11(MZ,MN,ME,2)*DAB*(8.D0*K28+8.D0*K30)
     1 +C12(MN,MP,MW,2)*(-4.D0*K29-4.D0*K31)
     1 +C12(MN,MZ,MW,2)*DAB*(-4.D0*K28-4.D0*K30)
       TX02(3)=0.
      CALL SET
       TX02(5)=
     1 +C0(ME,MP,MW,5)*(8.D0*K29)
     1 +C0(ME,MZ,MW,5)*DAB*(8.D0*K28)
     1 +C0(MW,MN,ME,5)*(-16.D0*K29)
     1 +C0(MW,MN,ME,5)*DAB*(-16.D0*K28)
     1 +C11(ME,MP,MW,5)*(4.D0*K29+12.D0*K31)
     1 +C11(ME,MZ,MW,5)*DAB*(4.D0*K28+12.D0*K30)
     1 +C11(MW,MN,ME,5)*(8.D0*K31)
     1 +C11(MW,MN,ME,5)*DAB*(8.D0*K30)
     1 +C12(ME,MP,MW,5)*(4.D0*K29+4.D0*K31)
     1 +C12(ME,MZ,MW,5)*DAB*(4.D0*K28+4.D0*K30)
      CALL SET
C
      DO 35 ICH=1,6
      S01= S01+SX01(ICH)
      S02= S02+SX02(ICH)
      S03= S03+SX03(ICH)
      T01= T01+TX01(ICH)
      T02= T02+TX02(ICH)
   35 CONTINUE
C
  200 CONTINUE
      RMZ2 =RZ2
      RMZ4=RZ4
      RMZ6=RZ6
      RMH2=RH2
      AMN5 =1.D0/(S5-MN**2)
      XBORN=0.D0
      S5R2 =S5R**2
      S6R2=S6R**2
      FDMW2=DMW2
      FDMZ2=DMZ2
      FDE1=DE1
      FDVI1=DVI1
      MW10=MW**10
      MW12=MW**12
      MW14=MW**14
      CALL SET
	if ( lwrite ) print *,'ampli: S1ZWW'
       S1ZWW=
     1 +AMZ6*AW*(-32.D0/3.D0*RMZ2*MW6)
     1 +B0(MW,MW,S6)*AMZ6*AW*(32.D0*RMZ2*MW6)
     1 +B0(MZ,MW,MW2)*AMZ6*AW*(-64.D0*RMZ2*MW6)
     1 +C35(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4
     1                                       +128.D0*RMZ2*MW6)
     1 +C24(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4
     1                                       +128.D0*RMZ2*MW6)
     1 +C11(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ4+48.D0*MW4*MZ2-72.D0*MW6
     1                      +56.D0*S6*RMZ2*MW6-64.D0*RMZ2*MW8)
     1 +C0(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ4+16.D0*MW4*MZ2-40.D0*MW6
     1                     +24.D0*S6*RMZ2*MW6-64.D0*RMZ2*MW8)
	if ( lwrite ) print *,'ampli: S2ZWW'
       S2ZWW=
     1 +C34(MZ,MW,MW,1)*AMZ6*AW*(8.D0*MW2*MZ2-16.D0*MW4-128.D0*RMZ2*MW6)
     1 +C33(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4
     1                                       +128.D0*RMZ2*MW6)
     1 +C23(MZ,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4
     1                                       +128.D0*RMZ2*MW6)
     1 +C22(MZ,MW,MW,1)*AMZ6*AW*(8.D0*MW2*MZ2-16.D0*MW4-128.D0*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: S3ZWW'
       S3ZWW=
     1 +B0(MW,MW,S6)*AMZ6*AW*(-72.D0*MW4-56.D0*RMZ2*MW6)
     1 +B0(MZ,MW,MW2)*AMZ6*AW*(128.D0*RMZ2*MW6)
     1 +C35(MZ,MW,MW,1)*AMZ6*AW*(24.D0*MW2*MZ2-48.D0*MW4
     1                                       -384.D0*RMZ2*MW6)
     1 +C24(MZ,MW,MW,1)*AMZ6*AW*(16.D0*MW2*MZ2-32.D0*MW4
     1                                       -256.D0*RMZ2*MW6)
     1 +C11(MZ,MW,MW,1)*AMZ6*AW*(16.D0*MW2*MZ4-88.D0*MW4*MZ2+136.D0*MW6
     1                     -72.D0*S6*RMZ2*MW6+128.D0*RMZ2*MW8)
     1 +C0(MZ,MW,MW,1)*AMZ6*AW*(16.D0*MW2*MZ4-64.D0*MW4*MZ2+144.D0*MW6
     1                                       -16.D0*S6*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: S1ZWH'
       S1ZWH=
     1 +C35(MH,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4)
     1 +C35(MW,MH,MZ,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C35(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C24(MH,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4)
     1 +C24(MW,MH,MZ,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C24(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C11(MH,MW,MW,1)*AMZ6*AW*(16.D0*MW6)
     1 +C11(MW,MH,MZ,1)*AMZ6*AW*(-8.D0*MW4*MZ2)
     1 +C11(MW,MZ,MH,1)*AMZ6*AW*(-8.D0*MW4*MZ2)
     1 +C0(MH,MW,MW,1)*AMZ6*AW*(16.D0*MW6)
     1 +C0(MW,MH,MZ,1)*AMZ6*AW*(8.D0*MW4*MZ2)
     1 +C0(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW4*MZ2)
	if ( lwrite ) print *,'ampli: S2ZWH'
       S2ZWH=
     1 +C34(MH,MW,MW,1)*AMZ6*AW*(8.D0*MW2*MZ2-16.D0*MW4)
     1 +C34(MW,MH,MZ,1)*AMZ6*AW*(-8.D0*MW2*MZ2)
     1 +C34(MW,MZ,MH,1)*AMZ6*AW*(-8.D0*MW2*MZ2)
     1 +C33(MH,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4)
     1 +C33(MW,MH,MZ,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C33(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C23(MH,MW,MW,1)*AMZ6*AW*(-8.D0*MW2*MZ2+16.D0*MW4)
     1 +C23(MW,MH,MZ,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C23(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW2*MZ2)
     1 +C22(MH,MW,MW,1)*AMZ6*AW*(8.D0*MW2*MZ2-16.D0*MW4)
     1 +C22(MW,MH,MZ,1)*AMZ6*AW*(-8.D0*MW2*MZ2)
     1 +C22(MW,MZ,MH,1)*AMZ6*AW*(-8.D0*MW2*MZ2)
	if ( lwrite ) print *,'ampli: S3ZWH'
       S3ZWH=
     1 +C35(MH,MW,MW,1)*AMZ6*AW*(24.D0*MW2*MZ2-48.D0*MW4)
     1 +C35(MW,MH,MZ,1)*AMZ6*AW*(-24.D0*MW2*MZ2)
     1 +C35(MW,MZ,MH,1)*AMZ6*AW*(-24.D0*MW2*MZ2)
     1 +C24(MH,MW,MW,1)*AMZ6*AW*(16.D0*MW2*MZ2-32.D0*MW4)
     1 +C24(MW,MH,MZ,1)*AMZ6*AW*(-16.D0*MW2*MZ2)
     1 +C24(MW,MZ,MH,1)*AMZ6*AW*(-16.D0*MW2*MZ2)
     1 +C11(MH,MW,MW,1)*AMZ6*AW*(8.D0*MW4*MZ2-32.D0*MW6)
     1 +C11(MW,MZ,MH,1)*AMZ6*AW*(-8.D0*MW2*MZ4+32.D0*MW4*MZ2)
     1 +C12(MW,MH,MZ,1)*AMZ6*AW*(-8.D0*MW2*MZ4+32.D0*MW4*MZ2)
     1 +C12(MW,MZ,MH,1)*AMZ6*AW*(8.D0*MW2*MZ4-32.D0*MW4*MZ2)
	if ( lwrite ) print *,'ampli: S1GWW'
       S1GWW=
     1 +AMP6*QE2*(8.D0/3.D0*RMZ2*MW4)
     1 +B0(MW,MW,S6)*AMP6*QE2*(-8.D0*RMZ2*MW4)
     1 +B0(MZ,MW,MW2)*AMP6*QE2*(16.D0*RMZ2*MW4)
     1 +C35(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2-32.D0*RMZ2*MW4)
     1 +C24(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2-32.D0*RMZ2*MW4)
     1 +C11(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2*MZ2+12.D0*MW4
     1                       -14.D0*S6*RMZ2*MW4+16.D0*RMZ2*MW6)
     1 +C0(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2*MZ2+12.D0*MW4
     1                       -6.D0*S6*RMZ2*MW4+16.D0*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: S2GWW'
       S2GWW=
     1 +C34(MZ,MW,MW,1)*AMP6*QE2*(4.D0*MW2+32.D0*RMZ2*MW4)
     1 +C33(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2-32.D0*RMZ2*MW4)
     1 +C23(MZ,MW,MW,1)*AMP6*QE2*(-4.D0*MW2-32.D0*RMZ2*MW4)
     1 +C22(MZ,MW,MW,1)*AMP6*QE2*(4.D0*MW2+32.D0*RMZ2*MW4)
	if ( lwrite ) print *,'ampli: S3GWW'
       S3GWW=
     1 +B0(MW,MW,S6)*AMP6*QE2*(18.D0*MW2+14.D0*RMZ2*MW4)
     1 +B0(MZ,MW,MW2)*AMP6*QE2*(-32.D0*RMZ2*MW4)
     1 +C35(MZ,MW,MW,1)*AMP6*QE2*(12.D0*MW2+96.D0*RMZ2*MW4)
     1 +C24(MZ,MW,MW,1)*AMP6*QE2*(8.D0*MW2+64.D0*RMZ2*MW4)
     1 +C11(MZ,MW,MW,1)*AMP6*QE2*(8.D0*MW2*MZ2-24.D0*MW4
     1                      +18.D0*S6*RMZ2*MW4-32.D0*RMZ2*MW6)
     1 +C0(MZ,MW,MW,1)*AMP6*QE2*(8.D0*MW2*MZ2-32.D0*MW4
     1                                       + 4.D0*S6*RMZ2*MW4)
	if ( lwrite ) print *,'ampli: S1GWH'
       S1GWH=
     1 +C35(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW2)
     1 +C24(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW2)
     1 +C11(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW4)
     1 +C0(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW4)
	if ( lwrite ) print *,'ampli: S2GWH'
       S2GWH=
     1 +C34(MH,MW,MW,1)*AMP6*QE2*(4.D0*MW2)
     1 +C33(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW2)
     1 +C23(MH,MW,MW,1)*AMP6*QE2*(-4.D0*MW2)
     1 +C22(MH,MW,MW,1)*AMP6*QE2*(4.D0*MW2)
	if ( lwrite ) print *,'ampli: S3GWH'
       S3GWH=
     1 +C35(MH,MW,MW,1)*AMP6*QE2*(12.D0*MW2)
     1 +C24(MH,MW,MW,1)*AMP6*QE2*(8.D0*MW2)
     1 +C11(MH,MW,MW,1)*AMP6*QE2*(8.D0*MW4)
	if ( lwrite ) print *,'ampli: T1WEN'
       T1WEN=
     1 +AMN5*(4.D0*MW2*MZ2-8.D0*MW4-2.D0*XBORN*MW2+16.D0*RMZ2*MW6)
     1 +B0(MW,MZ,MW2)*AMN5*(16.D0/3.D0*MW2*MZ2+8.D0*MW4+2.D0/3.D0*MZ4)
     1 +B0(MZ,MW,MW2)*AMN5*(-16.D0/3.D0*MW2*MZ2-8.D0*MW4-2.D0/3.D0*MZ4
     1                                        +32.D0*RMZ2*MW6)
     1 +B0(ME,MW,S5)*AMN5*(16.D0*MW4-32.D0*RMZ2*MW6)
     1 +B0(ME,MZ,ME2)*AMN5*(-8.D0*MW2*MZ2+32.D0*MW4-32.D0*RMZ2*MW6)
     1 +B0(MN,MW,ME2)*AMN5*(-16.D0*MW4)
     1 +B0(MN,MZ,S5)*AMN5*(-8.D0*MW2*MZ2)
     1 +B0(MN,ME,MW2)*AMN5*(8.D0*MW2*MZ2-16.D0*MW4)
     1 +C24(MZ,MN,ME,2)*AMN5*(16.D0*MW2*MZ2-32.D0*MW4)
     1 +C24(ME,MW,MZ,2)*AMN5*(32.D0*MW4-64.D0*RMZ2*MW6)
     1 +C24(MN,MZ,MW,2)*AMN5*(-32.D0*MW4)
     1 +C11(MZ,MN,ME,2)*AMN5*(-8.D0*S5*MW2*MZ2+16.D0*S5*MW4)
       T1WEN = T1WEN
     1 +C11(ME,MW,MZ,2)*AMN5*(24.D0*S5*MW4-48.D0*S5*RMZ2*MW6)
     1 +C11(MN,MZ,MW,2)*AMN5*(-24.D0*S5*MW4)
     1 +C0(MZ,MN,ME,2)*AMN5*(-8.D0*MW2*MZ4+8.D0*MW4*MZ2+16.D0*MW6)
     1 +C0(ME,MW,MZ,2)*AMN5*(-16.D0*MW4*MZ2+16.D0*MW6+16.D0*S5*MW4
     1                             -32.D0*S5*RMZ2*MW6+32.D0*RMZ2*MW8)
     1 +C0(MN,MZ,MW,2)*AMN5*(16.D0*MW4*MZ2+16.D0*MW6-16.D0*S5*MW4)
     1 +C12(MZ,MN,ME,2)*AMN5*(8.D0*S5*MW2*MZ2-16.D0*S5*MW4)
     1 +C12(ME,MW,MZ,2)*AMN5*(-24.D0*S5*MW4+48.D0*S5*RMZ2*MW6)
     1 +C12(MN,MZ,MW,2)*AMN5*(24.D0*S5*MW4)
	if ( lwrite ) print *,'ampli: T2WEN'
       T2WEN=
     1 +C11(MZ,MN,ME,2)*AMN5*(-16.D0*S5*MW2*MZ2+32.D0*S5*MW4)
     1 +C0(MZ,MN,ME,2)*AMN5*(-8.D0*S5*MW2*MZ2+16.D0*S5*MW4)
     1 +C23(MZ,MN,ME,2)*AMN5*(8.D0*S5*MW2*MZ2-16.D0*S5*MW4)
     1 +C23(ME,MW,MZ,2)*AMN5*(16.D0*S5*MW4-32.D0*S5*RMZ2*MW6)
     1 +C23(MN,MZ,MW,2)*AMN5*(-16.D0*S5*MW4)
     1 +C12(MZ,MN,ME,2)*AMN5*(8.D0*S5*MW2*MZ2-16.D0*S5*MW4)
     1 +C12(ME,MW,MZ,2)*AMN5*(8.D0*S5*MW4-16.D0*S5*RMZ2*MW6)
     1 +C12(MN,MZ,MW,2)*AMN5*(-8.D0*S5*MW4)
     1 +C21(MZ,MN,ME,2)*AMN5*(-8.D0*S5*MW2*MZ2+16.D0*S5*MW4)
     1 +C21(ME,MW,MZ,2)*AMN5*(-16.D0*S5*MW4+32.D0*S5*RMZ2*MW6)
     1 +C21(MN,MZ,MW,2)*AMN5*(16.D0*S5*MW4)
	if ( lwrite ) print *,'ampli: S1ZEE'
       S1ZEE=
     1 +AMZ6*(-9.D0*MW2*MZ2+28.D0*MW4-32.D0*RMZ2*MW6+16.D0*RMZ4*MW8)
     1 +AMZ6*AW*(4.D0*XBORN*MW2)
     1 +AMP6*QE2*(-XBORN)
     1 +B0(MW,MW,S6)*AMZ6*(8.D0*RMZ2*MW6)
     1 +B0(ME,MZ,ME2)*AMZ6*(36.D0*MW2*MZ2-120.D0*MW4+144.D0*RMZ2*MW6
     1                                               -64.D0*RMZ4*MW8)
     1 +B0(ME,ME,S6)*AMZ6*(-18.D0*MW2*MZ2+60.D0*MW4-72.D0*RMZ2*MW6
     1                                             +32.D0*RMZ4*MW8)
     1 +B0(MN,MW,ME2)*AMZ6*(8.D0*MW4-16.D0*RMZ2*MW6)
     1 +B0(MN,MN,S6)*AMZ6*(-4.D0*MW4)
     1 +C24(MW,MN,MN,3)*AMZ6*(-8.D0*MW4)
     1 +C24(MZ,ME,ME,3)*AMZ6*(-36.D0*MW2*MZ2+120.D0*MW4-144.D0*RMZ2*MW6
     1                                                  +64.D0*RMZ4*MW8)
       S1ZEE = S1ZEE
     1 +C24(MN,MW,MW,3)*AMZ6*(-16.D0*RMZ2*MW6)
     1 +C0(MW,MN,MN,3)*AMZ6*(4.D0*MW6+4.D0*S6*MW4)
     1 +C0(MZ,ME,ME,3)*AMZ6*(18.D0*MW2*MZ4-60.D0*MW4*MZ2+72.D0*MW6
     1                      +18.D0*S6*MW2*MZ2-60.D0*S6*MW4
     1                      +72.D0*S6*RMZ2*MW6-32.D0*S6*RMZ4*MW8
     1                                        -32.D0*RMZ2*MW8)
     1 +C0(MN,MW,MW,3)*AMZ6*(16.D0*RMZ2*MW8)
	if ( lwrite ) print *,'ampli: S1GEE'
       S1GEE=
     1 +AMZ6*AW*(4.D0*XBORN*MW2)
     1 +AMP6*QE2*(-5.D0*MW2+5.D0/2.D0*MZ2-XBORN+4.D0*RMZ2*MW4)
     1 +B0(MW,MW,S6)*AMP6*QE2*(2.D0*MW2)
     1 +B0(ME,MZ,ME2)*AMP6*QE2*(24.D0*MW2-10.D0*MZ2-16.D0*RMZ2*MW4)
     1 +B0(ME,ME,S6)*AMP6*QE2*(-12.D0*MW2+5.D0*MZ2+8.D0*RMZ2*MW4)
     1 +B0(MN,MW,ME2)*AMP6*QE2*(-4.D0*MW2)
     1 +C24(MZ,ME,ME,3)*AMP6*QE2*(-24.D0*MW2+10.D0*MZ2+16.D0*RMZ2*MW4)
     1 +C24(MN,MW,MW,3)*AMP6*QE2*(-4.D0*MW2)
     1 +C0(MZ,ME,ME,3)*AMP6*QE2*(12.D0*MW2*MZ2-8.D0*MW4-5.D0*MZ4
     1               +12.D0*S6*MW2-5.D0*S6*MZ2-8.D0*S6*RMZ2*MW4)
     1 +C0(MN,MW,MW,3)*AMP6*QE2*(4.D0*MW4)+0.
      SEZWW=ANO*S1ZWW
      SZZWW=ANO*S2ZWW
      SDZWW=ANO*S3ZWW
      SVZWW=0.D0
      SEZWH=ANO*S1ZWH
      SZZWH=ANO*S2ZWH
      SDZWH=ANO*S3ZWH
      SEGWW=ANO*S1GWW
      SZGWW=ANO*S2GWW
      SDGWW=ANO*S3GWW
      SEGWH=ANO*S1GWH
      SZGWH=ANO*S2GWH
      SDGWH=ANO*S3GWH
      TEWEN=ANO*T1WEN
      TZWEN=ANO*T2WEN
      SEZEE=ANO*S1ZEE
      SEGEE=ANO*S1GEE
      IDE01=RIDE(MW2,MW2,S6)
      CALL SET
	if ( lwrite ) print *,'ampli: S1ZWP'
       S1ZWP=
     1 +AMZ6*AW*QE2*(16.D0/9.D0*MW2)
     1 +B0(MW,MW,S6)*AMZ6*AW*QE2*(-52.D0/3.D0*MW2-12.D0*S6*IDE01*MW2*MZ2
     1                                           +80.D0*S6*IDE01*MW4)
     1 +B0(MP,MW,MW2)*AMZ6*AW*QE2*(12.D0*MW2+12.D0*S6*IDE01*MW2*MZ2
     1                                      -80.D0*S6*IDE01*MW4)
     1 +C0(MP,MW,MW,1)*AMZ6*AW*QE2*(2.D0*MW2*MZ2-16.D0*MW4+6.D0*S6*MW2)
	if ( lwrite ) print *,'ampli: S2ZWP'
       S2ZWP=
     1 +AMZ6*AW*QE2*(16.D0/3.D0*S6*IDE01*MW2-32.D0/3.D0*IDE01*MW4)
     1 +AA(MW)*AMZ6*AW*QE2*(-32.D0/3.D0*IDE01*MW4)
     1 +B0(MW,MW,S6)*AMZ6*AW*QE2*(-32.D0/3.D0*IDE01*MW4)
	if ( lwrite ) print *,'ampli: S3ZWP'
       S3ZWP=
     1 +AMZ6*AW*QE2*(-16.D0/3.D0*MW2)
     1 +B0(MW,MW,S6)*AMZ6*AW*QE2*(22.D0*MW2+20.D0*S6*IDE01*MW2*MZ2
     1                                     -80.D0*S6*IDE01*MW4)
     1 +B0(MP,MW,MW2)*AMZ6*AW*QE2*(-4.D0*MW2-20.D0*S6*IDE01*MW2*MZ2
     1                                      +80.D0*S6*IDE01*MW4)
     1 +C0(MP,MW,MW,1)*AMZ6*AW*QE2*(4.D0*MW2*MZ2-4.D0*S6*MW2)
	if ( lwrite ) print *,'ampli: S1GWP'
       S1GWP=
     1 -4.D0/9.D0*AMP6*QE2**2
     1 +B0(MW,MW,S6)*AMP6*QE2**2*(13.D0/3.D0-20.D0*S6*IDE01*MW2)
     1 +B0(MP,MW,MW2)*AMP6*QE2**2*(-3.D0+20.D0*S6*IDE01*MW2)
     1 +C0(MP,MW,MW,1)*AMP6*QE2**2*(4.D0*MW2-3.D0/2.D0*S6)
	if ( lwrite ) print *,'ampli: S2GWP'
       S2GWP=
     1 +AMP6*QE2**2*(-4.D0/3.D0*S6*IDE01+8.D0/3.D0*IDE01*MW2)
     1 +AA(MW)*AMP6*QE2**2*(8.D0/3.D0*IDE01*MW2)
     1 +B0(MW,MW,S6)*AMP6*QE2**2*(8.D0/3.D0*IDE01*MW2)
	if ( lwrite ) print *,'ampli: S3GWP'
       S3GWP=
     1 +4.D0/3.D0*AMP6*QE2**2
     1 +B0(MW,MW,S6)*AMP6*QE2**2*(-11.D0/2.D0+20.D0*S6*IDE01*MW2)
     1 +B0(MP,MW,MW2)*AMP6*QE2**2*(1.D0-20.D0*S6*IDE01*MW2)
     1 +C0(MP,MW,MW,1)*AMP6*QE2**2*(S6)
      IDE02=RIDE(S5,MW2,ME2)
      CALL SET
	if ( lwrite ) print *,'ampli: T1WEN'
       T1WEN=
     1 +AMN5*(-2.D0*XBORN*MW2)
     1 +B0(MP,MW,MW2)*AMN5*QE2*(-4.D0*MW2-12.D0*IDE02*MW6
     1                                   +12.D0*S5*IDE02*MW4)
     1 +B0(ME,MW,S5)*AMN5*QE2*(12.D0*IDE02*MW6-12.D0*S5*IDE02*MW4)
     1 +B0(ME,MP,ME2)*AMN5*QE2*(-8.D0*MW2)
     1 +C0(ME,MW,MP,2)*AMN5*QE2*(8.D0*MW4-8.D0*S5*MW2)
	if ( lwrite ) print *,'ampli: T2WEN'
       T2WEN=
     1 +AMN5*QE2*(4.D0*S5*IDE02*MW4-4.D0*S5**2*MW2*IDE02)
     1 +AA(MW)*AMN5*QE2*(-4.D0*IDE02*MW6+4.D0*S5*IDE02*MW4)
     1 +AA(ME)*AMN5*QE2*(4.D0*ME**2*IDE02*MW4+4.D0*ME**2*S5*MW2*IDE02)
     1 +B0(MP,MW,MW2)*AMN5*QE2*(-12.D0*S5*IDE02*MW4
     1                          + 4.D0*S5**2*MW2*IDE02)
     1 +B0(ME,MW,S5)*AMN5*QE2*(-4.D0*IDE02*MW6+12.D0*S5*IDE02*MW4)
     1 +B0(ME,MP,ME2)*AMN5*QE2*(4.D0*S5*IDE02*MW4-4.D0*S5**2*MW2*IDE02)
     1 +C0(ME,MW,MP,2)*AMN5*QE2*(4.D0*S5*MW2)
      CALL SET
	if ( lwrite ) print *,'ampli: S1ZEE'
       S1ZEE=
     1 +AMZ6*QE2*(-6.D0*MW2+8.D0*RMZ2*MW4)
     1 +AMZ6*AW*(4.D0*XBORN*MW2)
     1 +AMP6*QE2*(-XBORN)
     1 +B0(MP,ME,ME2)*AMZ6*QE2*(12.D0*MW2-16.D0*RMZ2*MW4)
     1 +B0(ME,ME,S6)*AMZ6*QE2*(-9.D0*MW2+12.D0*RMZ2*MW4)
     1 +C0(MP,ME,ME,3)*AMZ6*QE2*(6.D0*S6*MW2-8.D0*S6*RMZ2*MW4)
	if ( lwrite ) print *,'ampli: S1GEE'
       S1GEE=
     1 +AMZ6*AW*(4.D0*XBORN*MW2)
     1 +AMP6*QE2*(-XBORN)
     1 +2.D0*AMP6*QE2**2
     1 -4.D0*B0(MP,ME,ME2)*AMP6*QE2**2
     1 +3.D0*B0(ME,ME,S6)*AMP6*QE2**2
     1 +C0(MP,ME,ME,3)*AMP6*QE2**2*(-2.D0*S6)+0.
      S4ZWP=0.
      AST=ANO
      IF(SCHEME.EQ.'ALFA') THEN
      ANO=ANO
      ELSE
      ANO=ANO*SQRT(APHNO/ANO)
      END IF
      SEZWW=SEZWW+ANO*S1ZWP
      SZZWW=SZZWW+ANO*S2ZWP
      SDZWW=SDZWW+ANO*S3ZWP
      SVZWW=SVZWW+ANO*S4ZWP
      SEGWW=SEGWW+ANO*S1GWP
      SZGWW=SZGWW+ANO*S2GWP
      SDGWW=SDGWW+ANO*S3GWP
      TEWEN=TEWEN+ANO*T1WEN
      TZWEN=TZWEN+ANO*T2WEN
      SEZEE=SEZEE+ANO*S1ZEE
      SEGEE=SEGEE+ANO*S1GEE
C     T01 IST DIREKT PROPORTIONAL ZU CPP, T02=0 !!!
      ANO=AST
      CALL SET
	if ( lwrite ) print *,'ampli: S1ZWW'
       S1ZWW=
     1 +AMZ6*(8.D0/3.D0*RMZ2*MW6)
     1 +B0(MW,MW,S6)*AMZ6*(-8.D0*RMZ2*MW6)
     1 +B0(MZ,MW,MW2)*AMZ6*(16.D0*RMZ2*MW6)
     1 +C35(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4-32.D0*RMZ2*MW6)
     1 +C24(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4-32.D0*RMZ2*MW6)
     1 +C11(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ4-12.D0*MW4*MZ2+18.D0*MW6
     1                  -14.D0*S6*RMZ2*MW6+16.D0*RMZ2*MW8)
     1 +C0(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ4-4.D0*MW4*MZ2+10.D0*MW6
     1                      -6.D0*S6*RMZ2*MW6+16.D0*RMZ2*MW8)
	if ( lwrite ) print *,'ampli: S2ZWW'
       S2ZWW=
     1 +C34(MZ,MW,MW,1)*AMZ6*(-2.D0*MW2*MZ2+4.D0*MW4+32.D0*RMZ2*MW6)
     1 +C33(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4-32.D0*RMZ2*MW6)
     1 +C23(MZ,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4-32.D0*RMZ2*MW6)
     1 +C22(MZ,MW,MW,1)*AMZ6*(-2.D0*MW2*MZ2+4.D0*MW4+32.D0*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: S3ZWW'
       S3ZWW=
     1 +B0(MW,MW,S6)*AMZ6*(18.D0*MW4+14.D0*RMZ2*MW6)
     1 +B0(MZ,MW,MW2)*AMZ6*(-32.D0*RMZ2*MW6)
     1 +C35(MZ,MW,MW,1)*AMZ6*(-6.D0*MW2*MZ2+12.D0*MW4+96.D0*RMZ2*MW6)
     1 +C24(MZ,MW,MW,1)*AMZ6*(-4.D0*MW2*MZ2+8.D0*MW4+64.D0*RMZ2*MW6)
     1 +C11(MZ,MW,MW,1)*AMZ6*(-4.D0*MW2*MZ4+22.D0*MW4*MZ2-34.D0*MW6
     1                   +18.D0*S6*RMZ2*MW6-32.D0*RMZ2*MW8)
     1 +C0(MZ,MW,MW,1)*AMZ6*(-4.D0*MW2*MZ4+16.D0*MW4*MZ2-36.D0*MW6
     1                       +4.D0*S6*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: S1ZWH'
       S1ZWH=
     1 +C35(MH,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4)
     1 +C35(MW,MH,MZ,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C35(MW,MZ,MH,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C24(MH,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4)
     1 +C24(MW,MH,MZ,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C24(MW,MZ,MH,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C11(MH,MW,MW,1)*AMZ6*(-4.D0*MW6)
     1 +C11(MW,MH,MZ,1)*AMZ6*(2.D0*MW4*MZ2)
     1 +C11(MW,MZ,MH,1)*AMZ6*(2.D0*MW4*MZ2)
     1 +C0(MH,MW,MW,1)*AMZ6*(-4.D0*MW6)
     1 +C0(MW,MH,MZ,1)*AMZ6*(-2.D0*MW4*MZ2)
     1 +C0(MW,MZ,MH,1)*AMZ6*(-2.D0*MW4*MZ2)
	if ( lwrite ) print *,'ampli: S2ZWH'
       S2ZWH=
     1 +C34(MH,MW,MW,1)*AMZ6*(-2.D0*MW2*MZ2+4.D0*MW4)
     1 +C34(MW,MH,MZ,1)*AMZ6*(2.D0*MW2*MZ2)
     1 +C34(MW,MZ,MH,1)*AMZ6*(2.D0*MW2*MZ2)
     1 +C33(MH,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4)
     1 +C33(MW,MH,MZ,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C33(MW,MZ,MH,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C23(MH,MW,MW,1)*AMZ6*(2.D0*MW2*MZ2-4.D0*MW4)
     1 +C23(MW,MH,MZ,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C23(MW,MZ,MH,1)*AMZ6*(-2.D0*MW2*MZ2)
     1 +C22(MH,MW,MW,1)*AMZ6*(-2.D0*MW2*MZ2+4.D0*MW4)
     1 +C22(MW,MH,MZ,1)*AMZ6*(2.D0*MW2*MZ2)
     1 +C22(MW,MZ,MH,1)*AMZ6*(2.D0*MW2*MZ2)
	if ( lwrite ) print *,'ampli: S3ZWH'
       S3ZWH=
     1 +C35(MH,MW,MW,1)*AMZ6*(-6.D0*MW2*MZ2+12.D0*MW4)
     1 +C35(MW,MH,MZ,1)*AMZ6*(6.D0*MW2*MZ2)
     1 +C35(MW,MZ,MH,1)*AMZ6*(6.D0*MW2*MZ2)
     1 +C24(MH,MW,MW,1)*AMZ6*(-4.D0*MW2*MZ2+8.D0*MW4)
     1 +C24(MW,MH,MZ,1)*AMZ6*(4.D0*MW2*MZ2)
     1 +C24(MW,MZ,MH,1)*AMZ6*(4.D0*MW2*MZ2)
     1 +C11(MH,MW,MW,1)*AMZ6*(-2.D0*MW4*MZ2+8.D0*MW6)
     1 +C11(MW,MZ,MH,1)*AMZ6*(2.D0*MW2*MZ4-8.D0*MW4*MZ2)
     1 +C12(MW,MH,MZ,1)*AMZ6*(2.D0*MW2*MZ4-8.D0*MW4*MZ2)
     1 +C12(MW,MZ,MH,1)*AMZ6*(-2.D0*MW2*MZ4+8.D0*MW4*MZ2)
       S1GWW=0.
       S2GWW=0.
       S3GWW=0.
       S1GWH=0.
       S2GWH=0.
       S3GWH=0.
       T1WEN=0.
       T2WEN=0.
	if ( lwrite ) print *,'ampli: S1ZEE'
       S1ZEE=
     1 +AMZ6*(7.D0*MW2*MZ2-20.D0*MW4-XBORN*MW2+16.D0*RMZ2*MW6)
     1 +B0(MW,MW,S6)*AMZ6*(8.D0*RMZ2*MW6)
     1 +B0(ME,MZ,ME2)*AMZ6*(-28.D0*MW2*MZ2+72.D0*MW4-48.D0*RMZ2*MW6)
     1 +B0(ME,ME,S6)*AMZ6*(14.D0*MW2*MZ2-36.D0*MW4+24.D0*RMZ2*MW6)
     1 +B0(MN,MW,ME2)*AMZ6*(8.D0*MW4-16.D0*RMZ2*MW6)
     1 +B0(MN,MN,S6)*AMZ6*(-4.D0*MW4)
     1 +C24(MW,MN,MN,3)*AMZ6*(-8.D0*MW4)
     1 +C24(MZ,ME,ME,3)*AMZ6*(28.D0*MW2*MZ2-72.D0*MW4+48.D0*RMZ2*MW6)
     1 +C24(MN,MW,MW,3)*AMZ6*(-16.D0*RMZ2*MW6)
     1 +C0(MW,MN,MN,3)*AMZ6*(4.D0*MW6+4.D0*S6*MW4)
     1 +C0(MZ,ME,ME,3)*AMZ6*(-14.D0*MW2*MZ4+36.D0*MW4*MZ2-24.D0*MW6
     1                -14.D0*S6*MW2*MZ2+36.D0*S6*MW4-24.D0*S6*RMZ2*MW6)
     1 +C0(MN,MW,MW,3)*AMZ6*(16.D0*RMZ2*MW8)
	if ( lwrite ) print *,'ampli: S1GEE'
       S1GEE=
     1 +AMZ6*(-XBORN*MW2)
     1 +AMP6*QE2*(3.D0*MW2-3.D0/2.D0*MZ2)
     1 +B0(MW,MW,S6)*AMP6*QE2*(2.D0*MW2)
     1 +B0(ME,MZ,ME2)*AMP6*QE2*(-8.D0*MW2+6.D0*MZ2)
     1 +B0(ME,ME,S6)*AMP6*QE2*(4.D0*MW2-3.D0*MZ2)
     1 +B0(MN,MW,ME2)*AMP6*QE2*(-4.D0*MW2)
     1 +C24(MZ,ME,ME,3)*AMP6*QE2*(8.D0*MW2-6.D0*MZ2)
     1 +C24(MN,MW,MW,3)*AMP6*QE2*(-4.D0*MW2)
     1 +C0(MZ,ME,ME,3)*AMP6*QE2*(-4.D0*MW2*MZ2+3.D0*MZ4-4.D0*S6*MW2
     1                                                 +3.D0*S6*MZ2)
     1 +C0(MN,MW,MW,3)*AMP6*QE2*(4.D0*MW4)+0.
      S1ZWW=ANO*S1ZWW
      S2ZWW=ANO*S2ZWW
      S3ZWW=ANO*S3ZWW
      S1ZWH=ANO*S1ZWH
      S2ZWH=ANO*S2ZWH
      S3ZWH=ANO*S3ZWH
      S1GWW=ANO*S1GWW
      S2GWW=ANO*S2GWW
      S3GWW=ANO*S3GWW
      S1GWH=ANO*S1GWH
      S2GWH=ANO*S2GWH
      S3GWH=ANO*S3GWH
      T1WEN=ANO*T1WEN
      T2WEN=ANO*T2WEN
      S1ZEE=ANO*S1ZEE
      S1GEE=ANO*S1GEE
      CALL SET
	if ( lwrite ) print *,'ampli: G1ZWP'
      G1ZWP=
     1 +AMZ6*QE2*(-4.D0/9.D0*MW2)
     1 +B0(MW,MW,S6)*AMZ6*QE2*(13.D0/3.D0*MW2+ 3.D0*S6*IDE01*MW2*MZ2
     1                                       -20.D0*S6*IDE01*MW4)
     1 +B0(MP,MW,MW2)*AMZ6*QE2*(-3.D0*MW2- 3.D0*S6*IDE01*MW2*MZ2
     1                                   +20.D0*S6*IDE01*MW4)
     1 +C0(MP,MW,MW,1)*AMZ6*QE2*(-1.D0/2.D0*MW2*MZ2+4.D0*MW4
     1                           -3.D0/2.D0*S6*MW2)
	if ( lwrite ) print *,'ampli: G2ZWP'
      G2ZWP=
     1 +AMZ6*QE2*(-4.D0/3.D0*S6*IDE01*MW2+8.D0/3.D0*IDE01*MW4)
     1 +AA(MW)*AMZ6*QE2*(8.D0/3.D0*IDE01*MW4)
     1 +B0(MW,MW,S6)*AMZ6*QE2*(8.D0/3.D0*IDE01*MW4)
	if ( lwrite ) print *,'ampli: G3ZWP'
      G3ZWP=
     1 +AMZ6*QE2*(4.D0/3.D0*MW2)
     1 +B0(MW,MW,S6)*AMZ6*QE2*(-11.D0/2.D0*MW2- 5.D0*S6*IDE01*MW2*MZ2
     1                                        +20.D0*S6*IDE01*MW4)
     1 +B0(MP,MW,MW2)*AMZ6*QE2*(MW2+ 5.D0*S6*IDE01*MW2*MZ2
     1                             -20.D0*S6*IDE01*MW4)
     1 +C0(MP,MW,MW,1)*AMZ6*QE2*(-MW2*MZ2+S6*MW2)
      G1GWP=0.
      G2GWP=0.
      G3GWP=0.
      T1WEN=0.
      T2WEN=0.
      CALL SET
	if ( lwrite ) print *,'ampli: G1ZEE'
      G1ZEE=
     1 +AMZ6*(-XBORN*MW2)
     1 +AMZ6*QE2*(2.D0*MW2)
     1 +B0(MP,ME,ME2)*AMZ6*QE2*(-4.D0*MW2)
     1 +B0(ME,ME,S6)*AMZ6*QE2*(3.D0*MW2)
     1 +C0(MP,ME,ME,3)*AMZ6*QE2*(-2.D0*S6*MW2)
      G1GEE=+AMZ6*(-XBORN*MW2)
      AST=ANO
      IF(SCHEME.EQ.'ALFA') THEN
      ANO=ANO
      ELSE
      ANO=ANO*SQRT(APHNO/ANO)
      END IF
      S1ZWW=S1ZWW+ANO*G1ZWP
      S2ZWW=S2ZWW+ANO*G2ZWP
      S3ZWW=S3ZWW+ANO*G3ZWP
      S1GWW=S1GWW+ANO*G1GWP
      S2GWW=S2GWW+ANO*G2GWP
      S3GWW=S3GWW+ANO*G3GWP
      S1ZEE=S1ZEE+ANO*G1ZEE
      S1GEE=S1GEE+ANO*G1GEE
      ANO=AST
      IF(I.EQ.1) VZ=+1.D0
      IF(I.EQ.2) VZ=-1.D0
      S1ZWW=SEZWW+VZ*S1ZWW
      S2ZWW=SZZWW+VZ*S2ZWW
      S3ZWW=SDZWW+VZ*S3ZWW
      S1ZWH=SEZWH+VZ*S1ZWH
      S2ZWH=SZZWH+VZ*S2ZWH
      S3ZWH=SDZWH+VZ*S3ZWH
      S1GWW=SEGWW+VZ*S1GWW
      S2GWW=SZGWW+VZ*S2GWW
      S3GWW=SDGWW+VZ*S3GWW
      S1GWH=SEGWH+VZ*S1GWH
      S2GWH=SZGWH+VZ*S2GWH
      S3GWH=SDGWH+VZ*S3GWH
      T1WEN=0.
      T2WEN=0.
      IF(I.EQ.1) T1WEN=TEWEN
                             IF(I.EQ.1) T2WEN=TZWEN
      S1ZEE=SEZEE+VZ*S1ZEE
      S1GEE=SEGEE+VZ*S1GEE
	if ( lwrite ) print *,'ampli: AS01'
       AS01= +128.D0*RMZ2*S6R2*MW8+8.D0*RMZ2*S6R*MW4*FDE1
     1  -410.D0/3.D0*RMZ2*S6R*MW6-64.D0*RMZ4*S6R2*MW10
     1 +2024.D0/9.D0*RMZ4*S6R*MW8-128.D0*RMZ6*S6R*MW10
     1 -64.D0*S6R2*MW6-15.D0*S6R*MW2*MZ2-8.D0*S6R*MW2*FDE1
     1  +493.D0/9.D0*S6R*MW4
     1 +AMZ6*(27.D0/2.D0*MW2*MZ2-466.D0/9.D0*MW4+4.D0*FDMZ2*RMZ2*MW4
     1 +3.D0*FDMW2*MW2
     1 -8.D0*FDMW2*RMZ2*MW4+6.D0*FDVI1*MW2-8.D0*FDVI1*RMZ2*MW4
     1 +1168.D0/9.D0*RMZ2*MW6-2024.D0/9.D0*RMZ4*MW8+128.D0*RMZ6*MW10)
       AS01 = AS01
     1 +AMZ6**2*(2.D0*MW2*MZ2*MH2+2.D0/3.D0*MW2*MZ4+52.D0/9.D0*MZ2*MW4
     1 -8.D0/3.D0*MW4*MH2-224.D0/9.D0*MW6+3.D0*FDMZ2*MW2*MZ2
     1 -4.D0*FDMZ2*MW4+208.D0/3.D0*RMZ2*MW8-64.D0*RMZ4*MW10
     1 -12.D0*RMH2*MW2*MZ6-24.D0*RMH2*MZ2*MW6+16.D0*RMH2*MW4*MZ4
     1 +32.D0*RMH2*MW8)
       AS01 = AS01
     1 +AA(MH)*(1.D0/3.D0*RMZ2*S6R*MW2*MH4-8.D0/3.D0*RMZ2*S6R*MW4*MH2
     1 +4.D0/3.D0*RMZ4*S6R*MW4*MH4+7.D0/3.D0*S6R*MW2*MH2
     1 -4.D0/3.D0*S6R*MH4)
     1 +AA(MH)*AMZ6*(-2.D0*MW2*MH2+MH4-1.D0/3.D0*RMZ2*MW2*MH4
     1 +8.D0/3.D0*RMZ2*MW4*MH2-4.D0/3.D0*RMZ4*MW4*MH4)
     1 +AA(MH)*AMZ6**2*(-6.D0*MW2*MZ2*MH2-MW2*MH4+8.D0*MW4*MH2
     1 +4.D0/3.D0*RMZ2*MW4*MH4)
       AS01 = AS01
     1 +AA(MW)*(128.D0*RMZ2*S6R2*MW8-4.D0/3.D0*RMZ2*S6R*MW4*MH2
     1 -92.D0*RMZ2*S6R*MW6-64.D0*RMZ4*S6R2*MW10+208.D0*RMZ4*S6R*MW8
     1 -128.D0*RMZ6*S6R*MW10-64.D0*S6R2*MW6+4.D0/3.D0*S6R*MW2*MZ2
     1 +4.D0/3.D0*S6R*MW2*MH2+32.D0/3.D0*S6R*MW4)
     1 +AA(MW)*AMZ6*(-MW2*MZ2-MW2*MH2-32.D0/3.D0*MW4
     1 +4.D0/3.D0*RMZ2*MW4*MH2+268.D0/3.D0*RMZ2*MW6-208.D0*RMZ4*MW8
     1 +128.D0*RMZ6*MW10)
       AS01 = AS01
     1 +AA(MW)*AMZ6**2*(-2.D0*MZ2*MW4-40.D0/3.D0*MW6
     1 +208.D0/3.D0*RMZ2*MW8-64.D0*RMZ4*MW10-36.D0*RMH2*MZ2*MW6
     1 +48.D0*RMH2*MW8)
     1 +AA(MZ)*(-4.D0/3.D0*RMZ2*S6R*MW4*MH2-152.D0/3.D0*RMZ2*S6R*MW6
     1 +16.D0*RMZ4*S6R*MW8-19.D0*S6R*MW2*MZ2+S6R*MW2*MH2
     1 +166.D0/3.D0*S6R*MW4-4.D0/3.D0*S6R*MZ4)
     1 +AA(MZ)*AMZ6*(47.D0/3.D0*MW2*MZ2-MW2*MH2-146.D0/3.D0*MW4+MZ4
     1 +4.D0/3.D0*RMZ2*MW4*MH2+140.D0/3.D0*RMZ2*MW6-16.D0*RMZ4*MW8)
       AS01 = AS01
     1 +AA(MZ)*AMZ6**2*(MW2*MZ2*MH2-2.D0*MW2*MZ4+8.D0/3.D0*MZ2*MW4
     1 -4.D0/3.D0*MW4*MH2-18.D0*RMH2*MW2*MZ6+24.D0*RMH2*MW4*MZ4)
     1 +B0(MW,MH,MW2)*(4.D0/3.D0*RMZ2*S6R*MW2*MH4
     1 -8.D0/3.D0*RMZ2*S6R*MW4*MH2+8.D0/3.D0*S6R*MW2*MH2
     1 -4.D0/3.D0*S6R*MH4)
       AS01 = AS01
     1 +B0(MW,MH,MW2)*AMZ6*(-2.D0*MW2*MH2+MH4-4.D0/3.D0*RMZ2*MW2*MH4
     1 +8.D0/3.D0*RMZ2*MW4*MH2)
     1 +B0(MW,MW,S6)*(128.D0*RMZ2*S6R2*MW8+320.D0/3.D0*RMZ2*S6R*MW6
     1 -64.D0*RMZ4*S6R2*MW10+256.D0/3.D0*RMZ4*S6R*MW8
     1 -128.D0*RMZ6*S6R*MW10-64.D0*S6R2*MW6-64.D0*S6R*MW4)
     1 +B0(MW,MW,S6)*AMZ6*(MW2*MZ2+50.D0*MW4-320.D0/3.D0*RMZ2*MW6
     1 -256.D0/3.D0*RMZ4*MW8+128.D0*RMZ6*MW10)
       AS01 = AS01
     1 +B0(MW,MW,S6)*AMZ6**2*(-MW2*MZ4-44.D0/3.D0*MZ2*MW4
     1 +268.D0/3.D0*MW6-128.D0/3.D0*RMZ2*MW8-64.D0*RMZ4*MW10)
     1 +B0(MW,MZ,MW2)*(-256.D0/3.D0*RMZ2*S6R*MW6+64.D0*RMZ4*S6R*MW8
     1 -20.D0/3.D0*S6R*MW2*MZ2+88.D0/3.D0*S6R*MW4-4.D0/3.D0*S6R*MZ4)
       AS01 = AS01
     1 +B0(MW,MZ,MW2)*AMZ6*(14.D0/3.D0*MW2*MZ2-24.D0*MW4+MZ4
     1 +208.D0/3.D0*RMZ2*MW6-64.D0*RMZ4*MW8)
     1 +B0(MZ,MH,S6)*(-RMZ2*S6R*MW2*MH4-8.D0/3.D0*RMZ2*S6R*MW4*MH2
     1 +4.D0/3.D0*RMZ4*S6R*MW4*MH4-S6R*MW2*MZ2+2.D0*S6R*MW2*MH2
     1 +4.D0/3.D0*S6R*MW4)
     1 +B0(MZ,MH,S6)*AMZ6*(-2.D0*MW2*MH2+RMZ2*MW2*MH4
     1 +8.D0/3.D0*RMZ2*MW4*MH2-4.D0/3.D0*RMZ4*MW4*MH4)
       AS01 = AS01
     1 +B0(MZ,MH,S6)*AMZ6**2*(4.D0*MW2*MZ2*MH2-12.D0*MW2*MZ4-MW2*MH4
     1 +16.D0*MZ2*MW4-16.D0/3.D0*MW4*MH2+4.D0/3.D0*RMZ2*MW4*MH4)
     1 +AB0(MW,MH,MW2)*(-4.D0/3.D0*RMZ2*S6R*MW4*MH4
     1 +16.D0/3.D0*RMZ2*S6R*MW6*MH2
     1 -16.D0*RMZ2*S6R*MW8+4.D0/3.D0*S6R*MW2*MH4-16.D0/3.D0*S6R*MW4*MH2
     1 +16.D0*S6R*MW6)
       AS01 = AS01
     1 +AB0(MW,MH,MW2)*AMZ6*(-MW2*MH4+4.D0*MW4*MH2-12.D0*MW6
     1 +4.D0/3.D0*RMZ2*MW4*MH4-16.D0/3.D0*RMZ2*MW6*MH2+16.D0*RMZ2*MW8)
     1 +AB0(MW,MZ,MW2)*(80.D0/3.D0*RMZ2*S6R*MW8+64.D0*RMZ4*S6R*MW10
     1 +4.D0/3.D0*S6R*MW2*MZ4+20.D0*S6R*MZ2*MW4-112.D0*S6R*MW6)
     1 +AB0(MW,MZ,MW2)*AMZ6*(-MW2*MZ4-44.D0/3.D0*MZ2*MW4+268.D0/3.D0*MW6
     1 -128.D0/3.D0*RMZ2*MW8-64.D0*RMZ4*MW10)
	if ( lwrite ) print *,'ampli: AT01'
       AT01=-2.D0*FDMW2*S5R*MW2-4.D0*FDVI1*S5R*MW2
     1 -124.D0/9.D0*RMZ2*S5R*MW6-5.D0*S5R*MW2*MZ2+26.D0/9.D0*S5R*MW4
     1 +AA(MH)*(2.D0/3.D0*S5R*MW2*MH2-2.D0/3.D0*S5R*MH4)
     1 +AA(MW)*(-16.D0/3.D0*RMZ2*S5R*MW6-4.D0*S5R2*MW6
     1 +2.D0/3.D0*S5R*MW2*MZ2+2.D0/3.D0*S5R*MW2*MH2)
     1 +AA(MZ)*(-8.D0*RMZ2*S5R*MW6-2.D0*S5R2*MW2*MZ4
     1 -20.D0/3.D0*S5R*MW2*MZ2+40.D0/3.D0*S5R*MW4-2.D0/3.D0*S5R*MZ4)
     1 +B0(MW,MH,MW2)*(4.D0/3.D0*S5R*MW2*MH2-2.D0/3.D0*S5R*MH4)
       AT01 = AT01
     1 +B0(MW,MZ,MW2)*(-32.D0*RMZ2*S5R*MW6-4.D0*S5R*MW2*MZ2
     1 +32.D0/3.D0*S5R*MW4-2.D0/3.D0*S5R*MZ4)
       AT01 = AT01
     1 +B0(ME,MW,S5)*(-4.D0*S5R2*MW6+4.D0*S5R*MW4)
     1 +B0(MN,MZ,S5)*(-2.D0*S5R2*MW2*MZ4+2.D0*S5R*MW2*MZ2)
     1 +AB0(MW,MH,MW2)*(2.D0/3.D0*S5R*MW2*MH4-8.D0/3.D0*S5R*MW4*MH2
     1 +8.D0*S5R*MW6)
     1 +AB0(MW,MZ,MW2)*(-32.D0*RMZ2*S5R*MW8+2.D0/3.D0*S5R*MW2*MZ4
     1 +32.D0/3.D0*S5R*MZ2*MW4-136.D0/3.D0*S5R*MW6)
      ASN1 =ANO*AS01
      ATN1 =ANO*AT01
	if ( lwrite ) print *,'ampli: AS01'
       AS01=
     1 +QE2*(-100.D0/9.D0*RMZ2*S6R*MW4+100.D0/9.D0*S6R*MW2)
     1 +AMZ6*QE2*(-25.D0/3.D0*MW2+100.D0/9.D0*RMZ2*MW4)
     1 +AA(MW)*QE2*(8.D0/3.D0*RMZ2*S6R*MW4-8.D0/3.D0*S6R*MW2)
     1 +AA(MW)*AMZ6*QE2*(2.D0*MW2-8.D0/3.D0*RMZ2*MW4)
     1 +AA(MP)*QE2*(-8.D0*RMZ2*S6R*MW4+8.D0*S6R*MW2)
     1 +AA(MP)*AMZ6*QE2*(-6.D0*MW2+8.D0*RMZ2*MW4)
     1 +AA(ME)*QE2*(12.D0*RMZ2*S6R*MW4-12.D0*S6R*MW2)
       AS01 = AS01
     1 +AA(ME)*AMZ6*QE2*(9.D0*MW2-12.D0*RMZ2*MW4)
       AS01 = AS01
     1 +B0(MP,MW,MW2)*QE2*(16.D0*RMZ2*S6R*MW4-16.D0*S6R*MW2)
     1 +B0(MP,MW,MW2)*AMZ6*QE2*(12.D0*MW2-16.D0*RMZ2*MW4)
     1 +AB0(MP,MW,MW2)*QE2*(16.D0*RMZ2*S6R*MW6-16.D0*S6R*MW4)
     1 +AB0(MP,MW,MW2)*AMZ6*QE2*(12.D0*MW4-16.D0*RMZ2*MW6)
	if ( lwrite ) print *,'ampli: AT01'
       AT01=
     1 +QE2*(50.D0/9.D0*S5R*MW2)
     1 +AA(MW)*QE2*(-4.D0/3.D0*S5R*MW2)
     1 +AA(MP)*QE2*(4.D0*S5R*MW2)
     1 +AA(ME)*QE2*(-6.D0*S5R*MW2)
     1 +B0(MP,MW,MW2)*QE2*(-8.D0*S5R*MW2)
     1 +AB0(MP,MW,MW2)*QE2*(-8.D0*S5R*MW4)
      AST=ANO
      IF(SCHEME.EQ.'ALFA') THEN
      ANO=ANO
      ELSE
      ANO=ANO*SQRT(APHNO/ANO)
      END IF
      ASN1=ASN1+ANO*AS01
      ATN1=ATN1+ANO*AT01
      ANO=AST
	if ( lwrite ) print *,'ampli: AS01'
       AS01=+110.D0/3.D0*RMZ2*S6R*MW6-16.D0*RMZ4*S6R*MW8
     1 +9.D0*S6R*MW2*MZ2-89.D0/3.D0*S6R*MW4
     1 +AMZ6*(-21.D0/2.D0*MW2*MZ2+98.D0/3.D0*MW4-FDMW2*MW2
     1 -2.D0*FDVI1*MW2-392.D0/9.D0*RMZ2*MW6+16.D0*RMZ4*MW8)
     1 +AMZ6**2*(-2.D0/3.D0*MW2*MZ2*MH2-2.D0/9.D0*MW2*MZ4
     1 -20.D0/9.D0*MZ2*MW4+16.D0/3.D0*MW6-FDMZ2*MW2*MZ2
     1 -16.D0*RMZ2*MW8+4.D0*RMH2*MW2*MZ6+8.D0*RMH2*MZ2*MW6)
     1 +AA(MH)*(1.D0/3.D0*RMZ2*S6R*MW2*MH4-1.D0/3.D0*S6R*MW2*MH2)
       AS01 = AS01
     1 +AA(MH)*AMZ6*(2.D0/3.D0*MW2*MH2-1.D0/3.D0*MH4
     1 -1.D0/3.D0*RMZ2*MW2*MH4)
     1 +AA(MH)*AMZ6**2*(2.D0*MW2*MZ2*MH2+1.D0/3.D0*MW2*MH4)
       AS01 = AS01
     1 +AA(MW)*(68.D0/3.D0*RMZ2*S6R*MW6-16.D0*RMZ4*S6R*MW8
     1 -20.D0/3.D0*S6R*MW4)
     1 +AA(MW)*AMZ6*(1.D0/3.D0*MW2*MZ2+1.D0/3.D0*MW2*MH2+20.D0/3.D0*MW4
     1 -76.D0/3.D0*RMZ2*MW6+16.D0*RMZ4*MW8)
     1 +AA(MW)*AMZ6**2*(2.D0/3.D0*MZ2*MW4+16.D0/3.D0*MW6-16.D0*RMZ2*MW8
     1 +12.D0*RMH2*MZ2*MW6)
     1 +AA(MZ)*(8.D0*RMZ2*S6R*MW6+19.D0/3.D0*S6R*MW2*MZ2
     1 -1.D0/3.D0*S6R*MW2*MH2-14.D0*S6R*MW4)
       AS01 = AS01
     1 +AA(MZ)*AMZ6*(-29.D0/3.D0*MW2*MZ2+1.D0/3.D0*MW2*MH2
     1 +62.D0/3.D0*MW4-1.D0/3.D0*MZ4-12.D0*RMZ2*MW6)
     1 +AA(MZ)*AMZ6**2*(-1.D0/3.D0*MW2*MZ2*MH2+2.D0/3.D0*MW2*MZ4
     1 +6.D0*RMH2*MW2*MZ6)
       AS01 = AS01
     1 +B0(MW,MH,MW2)*AMZ6*(2.D0/3.D0*MW2*MH2-1.D0/3.D0*MH4)
     1 +B0(MW,MW,S6)*(32.D0/3.D0*RMZ2*S6R*MW6-16.D0*RMZ4*S6R*MW8
     1 +16.D0/3.D0*S6R*MW4)
     1 +B0(MW,MW,S6)*AMZ6*(-1.D0/3.D0*MW2*MZ2-18.D0*MW4
     1 -32.D0/3.D0*RMZ2*MW6+16.D0*RMZ4*MW8)
     1 +B0(MW,MW,S6)*AMZ6**2*(1.D0/3.D0*MW2*MZ4+16.D0/3.D0*MZ2*MW4
     1 -68.D0/3.D0*MW6-16.D0*RMZ2*MW8)
       AS01 = AS01
     1 +B0(MW,MZ,MW2)*AMZ6*(-2.D0*MW2*MZ2+16.D0/3.D0*MW4-1.D0/3.D0*MZ4
     1 -16.D0*RMZ2*MW6)
     1 +B0(MZ,MH,S6)*(1.D0/3.D0*RMZ2*S6R*MW2*MH4+1.D0/3.D0*S6R*MW2*MZ2
     1 -2.D0/3.D0*S6R*MW2*MH2)
       AS01 = AS01
     1 +B0(MZ,MH,S6)*AMZ6*(2.D0/3.D0*MW2*MH2-1.D0/3.D0*RMZ2*MW2*MH4)
     1 +B0(MZ,MH,S6)*AMZ6**2*(-4.D0/3.D0*MW2*MZ2*MH2+4.D0*MW2*MZ4
     1 +1.D0/3.D0*MW2*MH4)
     1 +AB0(MW,MH,MW2)*AMZ6*(1.D0/3.D0*MW2*MH4-4.D0/3.D0*MW4*MH2
     1 +4.D0*MW6)
     1 +AB0(MW,MZ,MW2)*AMZ6*(1.D0/3.D0*MW2*MZ4+16.D0/3.D0*MZ2*MW4
     1 -68.D0/3.D0*MW6-16.D0*RMZ2*MW8)
       AT01=0.
      AS01 =ANO*AS01
      AT01 =ANO*AT01
	if ( lwrite ) print *,'ampli: GAS01'
      GAS01=
     1 +AMZ6*QE2*(25.D0/9.D0*MW2)
     1 +AA(MW)*AMZ6*QE2*(-2.D0/3.D0*MW2)
     1 +AA(MP)*AMZ6*QE2*(2.D0*MW2)
     1 +AA(ME)*AMZ6*QE2*(-3.D0*MW2)
     1 +B0(MP,MW,MW2)*AMZ6*QE2*(-4.D0*MW2)
     1 +AB0(MP,MW,MW2)*AMZ6*QE2*(-4.D0*MW4)
      AST=ANO
      IF(SCHEME.EQ.'ALFA') THEN
      ANO=ANO
      ELSE
      ANO=ANO*SQRT(APHNO/ANO)
      END IF
      AS01=AS01+ANO*GAS01
      ANO=AST
      IF(I.EQ.1) VZ=+1.D0
      IF(I.EQ.2) VZ=-1.D0
      AS01=ASN1+VZ*AS01
      AT01=0.
      IF(I.EQ.1) AT01=ATN1
C
      S01=CFD*S01+CFC*(S1ZWW+S1ZWH+S1GWW+S1GWH+S1ZEE+S1GEE)+CFR*AS01
      S02=CFD*S02+CFC*(S2ZWW+S2ZWH+S2GWW+S2GWH            )
      S03=CFD*S03+CFC*(S3ZWW+S3ZWH+S3GWW+S3GWH            )
      T01=CFD*T01+CFC* T1WEN                               +CFR*AT01
      T02=CFD*T02+CFC* T2WEN
      RETURN
      END
*###[ CSS0:
	double precision FUNCTION CSS0(X,level)
*
*	compute lowest order differntial cross section
*	d\sigma/d\cos\theta at \cos\theta  =  X and return a lot of
*	things in common.  Uses W,S,CFIW,SFIW and overall factors in
*	common.  The form factors are also given in common, this allow
*	this routine to compute the virtual corrections and anomalous
*	couplings if these are set appropriately (see virt.f).
*	8-4-1994: changed so the virtual call no longer includes the
*	Born cross section: level=0: born; level=1: virtual.
*
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer level
	double precision x
*
*	local variables
*
	integer i,j,l,ls,lm,lp
	logical lcor
	double precision Q(4),em,qm,cp,sp,cros,abs2,cnorm
	double complex MM0,matxy(3,3),matxyd(3,3),ICOM,MHEL(-1:1,3,3),
     +		DMHEL(-1:1,3,3),c,matpm(3,3),matpmd(3,3),xi
	parameter(xi=(0d0,1d0))
*
*	common
*
	double precision W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	COMMON/BEZNAZ/ W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	double precision PM(4),PP(4),P(4)
	COMMON/MOMENT/PM,PP,P
	double precision EPSM(3,4),EPSP(3,4),P1(4),QM4(4),QP4(4)
	COMMON/VECT/EPSM,EPSP,P1,QM4,QP4
	double precision sprim,TPRIM
	COMMON/MANDEL/sprim,TPRIM
	double complex M01(3,3),M0D(3,3),OS1(3,3),OS2(3,3),OS3(3,3),
     +		OS4(3,3),OT1(3,3),OX7(3,3)
	COMMON/EM01/M01,M0D,OS1,OS2,OS3,OS4,OT1,OX7
	double precision COEF9,COEF10,DOEF9,DOEF10
	COMMON/COEFF3/COEF9,COEF10,DOEF9,DOEF10
	double precision GAMA0,GAMA,GAMA1,GAMA2,NCP
	COMMON/GAMAS/GAMA0,GAMA,GAMA1,GAMA2,NCP
	double precision DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,
     &		X7M0,X7P0
	COMMON/FORMFA/DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,
     &		X7M0,X7P0
	double precision ceww(-1:1,3,3)
	COMMON/POLCRO/ceww
	double precision COEF0,SCHCON,RALFA
	COMMON/COEFF0/COEF0,SCHCON,RALFA
	integer IAPP,IDEN,IDTM,IBFC,IDTMZ
	COMMON/APPROX/IAPP,IDEN,IDTM,IBFC,IDTMZ
	double precision PI,PI2
	COMMON/PIATAN/PI,PI2
	double precision FIW,CFIW,SFIW,dfi
	COMMON/AZIMUT/FIW,CFIW,SFIW,dfi
	double precision PLM,PLP,PTM,PTP,fim,fip
	COMMON/POLVEC/PLM,PLP,PTM,PTP,fim,fip
	CHARACTER*11 POLE
	COMMON/POLINI/POLE
	CHARACTER*12 POLWM,POLWP,polwmi,polwpi
	COMMON/POLFIN/POLWM,POLWP,polwmi,polwpi
	integer LS1,LS2,IAVER
	COMMON/POLELE/LS1,LS2,IAVER
	integer LM1,LM2,LMSTEP
	COMMON/POLWMI/LM1,LM2,LMSTEP
	integer LP1,LP2,LPSTEP
	COMMON/POLWPL/LP1,LP2,LPSTEP
	double precision d1z,dkapg,dkapz,lamg,lamz,xig,xiz
	logical lanoma
	common /anomal/d1z,dkapg,dkapz,lamg,lamz,xig,xiz,lanoma
*
*	statement function
*
	abs2(c) = dble(c)**2 + dimag(c)**2
*
*  #] declarations:
	EM = W/2
	QM = EM*DSQRT(1-4*MW2/S)
	CP = X
CCC	CP = (GAMA0-GAMA1*(GAMA2/GAMA1)**X)/GAMA
*...	SP = DSIN(DACOS(CP))
	sp  =  sqrt(1-cp**2)
C 4-MOMENTUM OF W MINUS:
	QM4(1) = EM
	QM4(2) = QM*SP*CFIW
	QM4(3) = QM*SP*SFIW
	QM4(4) = QM*CP
C 4-MOMENTUM OF W PLUS:
	QP4(1) = EM
	QP4(2) = -QM4(2)
	QP4(3) = -QM4(3)
	QP4(4) = -QM4(4)

C POLARIZATION VECTORS OF W MINUS:
	EPSM(1,1) = 0
	EPSM(1,2) = CP*CFIW
	EPSM(1,3) = CP*SFIW
	EPSM(1,4) = -SP
	EPSM(3,1) = QM/MW
	EPSM(3,2) = EM/MW*SP*CFIW
	EPSM(3,3) = EM/MW*SP*SFIW
	EPSM(3,4) = EM/MW*CP
	EPSM(2,1) = 0
	EPSM(2,2) = -SFIW
	EPSM(2,3) = CFIW
	EPSM(2,4) = 0
C POLARIZATION VECTORS OF W PLUS, CONVENTION OF FJZ:
	EPSP(1,1) = 0
	EPSP(1,2) = CP*CFIW
	EPSP(1,3) = CP*SFIW
	EPSP(1,4) = -SP
	EPSP(3,1) = QM/MW
	EPSP(3,2) = -EM/MW*SP*CFIW
	EPSP(3,3) = -EM/MW*SP*SFIW
	EPSP(3,4) = -EM/MW*CP
	EPSP(2,1) = 0
	EPSP(2,2) = SFIW
	EPSP(2,3) = -CFIW
	EPSP(2,4) = 0
C SUMS OF MOMENTA NEEDED:
C	P1 = QP-PP
	DO 10 I = 1,4
   10	    P1(I) = QP4(I)-PP(I)
C TPRIM = (QP-PP).2
	TPRIM = P1(1)**2
	DO 20 I = 2,4
	    TPRIM = TPRIM-P1(I)**2
   20	continue
	COEF9 = -2D0/s+2D0/(s-MZ2)*CW/SW*(A0+C0)
	COEF10= -2D0/s+2D0/(s-MZ2)*CW/SW*(A0-C0)
	lcor = level.eq.1 .or. lanoma
	if ( lcor ) then
	    DOEF9 = -2D0/s*      (DG0-s/2.D0/MW2*YG0)
     &		    +2D0/(s-MZ2)*(DZ0-s/2.D0/MW2*YZ0)*(A0+C0)
	    DOEF10= -2D0/s*      (DG0-s/2.D0/MW2*YG0)
     &		    +2D0/(s-MZ2)*(DZ0-s/2.D0/MW2*YZ0)*(A0-C0)
	elseif ( level.eq.0 ) then
	    doef9 = 0
	    doef10= 0
	else
	    print *,'CSS0: error: level should 0 (born) or 1 (virtual)'
	    print *,'      but is ',level
	    stop
	endif
C CROSS SECTION
	ICOM = DCMPLX(0.D0,1.D0)
	CNORM = 4*PM(1)*PP(1)
	cros = 0
	DO 130 LS = ls1,ls2,2
	    DO 120 LM = lm1,lm2,lmstep
		DO 120 LP = lp1,lp2,lpstep
		    IF ( LS.EQ.ls1 ) THEN
			matxy(LM,LP) = MM0(LS,LM,LP,level)
			if ( lcor ) matxyd(LM,LP) = M0D(LM,LP)
		    ELSE
			matxy(LM,LP) = COEF10*M01(LM,LP)
			matxy(LM,LP) = -DCONJG(matxy(LM,LP))
			if ( lcor ) then
			    matxyd(LM,LP) = DOEF10*M01(LM,LP)-
     +			    		OT1(LM,LP)/2D0/SW2/TPRIM*T1P0
     &				+(-(XG0+(s/MW2-1.D0)*YG0)/s
     &				+(A0-C0)/(s-MZ2)*(XZ0+(s/MW2-
     +					1.D0)*YZ0))*OS2(LM,LP)
     &				+(-YG0/MW2+(A0-C0)/(s-MZ2)*s/MW2
     +					*YZ0)*OS3(LM,LP)
     &				-(-ZG0/MW2+(A0-C0)/(s-MZ2)*s/MW2
     +					*ZZ0)*OS4(LM,LP)
     &				+X7P0*OX7(LM,LP)
			    matxyd(LM,LP) = -DCONJG(matxyd(LM,LP))
			endif
		    END IF
  120	    CONTINUE
*
*	    rewrite the ME from the basis (X,Y,L) to (-1,+1,0)
*
	    matpm(1,1) = (matxy(1,1) - xi*matxy(1,2) - xi*matxy(2,1)
     +		- matxy(2,2))/2
	    matpm(1,2) = (matxy(1,1) + xi*matxy(1,2) - xi*matxy(2,1)
     +		+ matxy(2,2))/2
	    matpm(1,3) = (matxy(1,3) - xi*matxy(2,3))/sqrt(2d0)
	    matpm(2,1) = (matxy(1,1) - xi*matxy(1,2) + xi*matxy(2,1)
     +		+ matxy(2,2))/2
	    matpm(2,2) = (matxy(1,1) + xi*matxy(1,2) + xi*matxy(2,1)
     +		- matxy(2,2))/2
	    matpm(2,3) = (matxy(1,3) + xi*matxy(2,3))/sqrt(2d0)
	    matpm(3,1) = (matxy(3,1) - xi*matxy(3,2))/sqrt(2d0)
	    matpm(3,2) = (matxy(3,1) + xi*matxy(3,2))/sqrt(2d0)
	    matpm(3,3) = matxy(3,3)
	    if ( lcor ) then
	    matpmd(1,1) = (matxyd(1,1) - xi*matxyd(1,2) - xi*matxyd(2,1)
     +		- matxyd(2,2))/2
	    matpmd(1,2) = (matxyd(1,1) + xi*matxyd(1,2) - xi*matxyd(2,1)
     +		+ matxyd(2,2))/2
	    matpmd(1,3) = (matxyd(1,3) - xi*matxyd(2,3))/sqrt(2d0)
	    matpmd(2,1) = (matxyd(1,1) - xi*matxyd(1,2) + xi*matxyd(2,1)
     +		+ matxyd(2,2))/2
	    matpmd(2,2) = (matxyd(1,1) + xi*matxyd(1,2) + xi*matxyd(2,1)
     +		- matxyd(2,2))/2
	    matpmd(2,3) = (matxyd(1,3) + xi*matxyd(2,3))/sqrt(2d0)
	    matpmd(3,1) = (matxyd(3,1) - xi*matxyd(3,2))/sqrt(2d0)
	    matpmd(3,2) = (matxyd(3,1) + xi*matxyd(3,2))/sqrt(2d0)
	    matpmd(3,3) = matxyd(3,3)
	    endif
*
*	    and square
*
	    do lm=lm1,lm2,lmstep
	        do lp=lp1,lp2,lpstep
		    if ( .not.lcor ) then
*			just the lowest order
			ceww(ls,lm,lp) = abs2(matpm(LM,LP))
		    elseif ( level.eq.1 ) then
*			just the interference term between LO and virt
			ceww(ls,lm,lp) = 2*dble(matpm(LM,LP)*
     +				DCONJG(matpmd(LM,LP)))
		    else
*			the full result
			ceww(ls,lm,lp) = abs2(matpm(LM,LP) + 
     +				matpmd(LM,LP)) 
		    endif
		    ceww(ls,lm,lp) = ceww(ls,lm,lp)/2*cnorm
		    if ( pole(1:1).eq.'P' ) then
			MHEL(LS,LM,LP) = matpm(LM,LP)
			if ( level.eq.1 ) DMHEL(LS,LM,LP) =matpmd(LM,LP)
		    else
			CROS = CROS + ceww(ls,lm,lp)
		    endif
		enddo
	    enddo
  130	CONTINUE
*
	if ( pole(1:1).eq.'P' ) then
	    do 184 lp=lp1,lp2,lpstep
		do 184 lm=lm1,lm2,lmstep
		    ceww(0,lm,lp) =
     +			(1-plm*plp)*(ceww(+1,lm,lp)+ceww(-1,lm,lp))
     +			+ (plm-plp)*(ceww(+1,lm,lp)-ceww(-1,lm,lp))
		    if ( .not.lcor ) then
*			just the lowest order
			ceww(0,lm,lp) = ceww(0,lm,lp) +
     +			( 2*ptm*ptp*cos(fim-fip-2*fiw)*
     +			  dble(mhel(+1,lm,lp)*dconjg(mhel(-1,lm,lp)))
     +			+ 2*ptm*ptp*sin(fim-fip-2*fiw)*
     +			 dimag(mhel(+1,lm,lp)*dconjg(mhel(-1,lm,lp)))
     +			)/2*cnorm
		    elseif ( level.eq.1 ) then
*			just the interference term between LO and virt
			ceww(0,lm,lp) = ceww(0,lm,lp) +
     +			 ( 2*ptm*ptp*cos(fim-fip-2*fiw)*(
     +			 + dble(mhel(+1,lm,lp)*dconjg(dmhel(-1,lm,lp)))
     +			 + dble(dmhel(+1,lm,lp)*dconjg(mhel(-1,lm,lp))))
     +			+ 2*ptm*ptp*sin(fim-fip-2*fiw)*(
     +			 +dimag(mhel(+1,lm,lp)*dconjg(dmhel(-1,lm,lp)))
     +			 +dimag(dmhel(+1,lm,lp)*dconjg(mhel(-1,lm,lp))))
     +			)/2*cnorm
		    else
*			the full result
			ceww(0,lm,lp) = ceww(0,lm,lp) +
     +			( 2*ptm*ptp*cos(fim-fip-2*fiw)*
     +			   dble((mhel(+1,lm,lp) + dmhel(+1,lm,lp))*
     +				(mhel(-1,lm,lp) + dmhel(-1,lm,lp)))
     +			+ 2*ptm*ptp*sin(fim-fip-2*fiw)*
     +			   dimag((mhel(+1,lm,lp) + dmhel(+1,lm,lp))*
     +				 (mhel(-1,lm,lp) + dmhel(-1,lm,lp)))
     +			)/2*cnorm
		    endif
		    cros = cros + ceww(0,lm,lp)
  184	    continue
	elseif ( pole(1:1).eq.'U' ) then
	    do lp=lp1,lp2,lpstep
		do lm=lm1,lm2,lmstep
		    ceww(0,lm,lp) = ceww(-1,lm,lp) + ceww(+1,lm,lp)
		enddo
	    enddo
	endif
*
*	oops - the total is wrong in the case of +/- polarizations
*	
	lm = index('-+L',polwm(1:1))
	lp = index('-+L',polwp(1:1))
	if ( lm.ne.0 .and. lp.ne.0 ) then
	    cros = ceww(0,lm,lp)
	endif
	css0 = 2*cros/iaver
	END
*###] CSS0:
*###[ MM0:
C MATRIX ELEMENT OF THE NONRADIATIVE PROCESS:
	FUNCTION MM0(LS,LM,LP,level)
*
	IMPLICIT COMPLEX*16(F,O),REAL*8(A-E,G-H,M,P-Z)
	integer level
	COMPLEX*16 MM0,M01(3,3),M0D(3,3)
	DIMENSION EPSM(3,4),EPSP(3,4),EM(4),EP(4),QP4(4),QM4(4),P1(4),
     &		PM(4),PP(4),P(4)
	DIMENSION OS1(3,3),OS2(3,3),OS3(3,3),OS4(3,3),OT1(3,3),OX7(3,3)
	COMMON/BEZNAZ/ W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	COMMON/VECT/EPSM,EPSP,P1,QM4,QP4
	COMMON/MANDEL/sprim,TPRIM
	COMMON/EM01/M01,M0D,OS1,OS2,OS3,OS4,OT1,OX7
	COMMON/COEFF3/COEF9,COEF10,DOEF9,DOEF10
	COMMON/FORMFA/ DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,
     &		X7M0,X7P0
	COMMON/MOMENT/PM,PP,P
	COMMON/APPROX/IAPP,IDEN,IDTM,IBFC,IDTMZ
	double precision d1z,dkapg,dkapz,lamg,lamz,xig,xiz
	logical lanoma
	common /anomal/d1z,dkapg,dkapz,lamg,lamz,xig,xiz,lanoma
*
	DO 10 I=1,4
	    EM(I)=EPSM(LM,I)
   10	    EP(I)=EPSP(LP,I)
C SCALAR PRODUCTS NEEDED:
C S1=QP.EM, S2=QM.EP, S3=EP.EM, S4=PP.EM, S5=PM.EP, S6=PP.EP, S7=PM.EM
	S1=QP4(1)*EM(1)
	S2=QM4(1)*EP(1)
	S3=EP(1)*EM(1)
	S4=PP(1)*EM(1)
	S5=PM(1)*EP(1)
	DO 20 I=2,4
	    S1=S1-QP4(I)*EM(I)
	    S2=S2-QM4(I)*EP(I)
	    S3=S3-EP(I)*EM(I)
	    S4=S4-PP(I)*EM(I)
   20	    S5=S5-PM(I)*EP(I)
	S6=S2-S5
	S7=S1-S4
	FF1EP=FF1(EP)
	FF1QP4=FF1(QP4)
	FF1EM=FF1(EM)
	M01(LM,LP)=S1*FF1EP-S3*FF1(P1)-S2*FF1EM
	OS1(LM,LP)=2.D0*M01(LM,LP)
	OS2(LM,LP)=S1*FF1EP-S2*FF1EM
	OS3(LM,LP)=-2.D0/s*S2*S1*FF1QP4
	OT1(LM,LP)=F3(EP,P1,EM)
	OS4(LM,LP)=LS*(2.D0*(OT1(LM,LP)-(S7*FF1EP-S6*FF1EM))
     &		-(OS1(LM,LP)-OS2(LM,LP)))
	OX7(LM,LP)=-2.D0/s*(S6-S5)*(S4-S7)*FF1QP4

	IF(LS.EQ.-1) THEN
	    MM0=COEF9*M01(LM,LP)-OT1(LM,LP)/2D0/SW2/TPRIM
	    if ( level.eq.1 .or. lanoma ) then
		M0D(LM,LP)=DOEF9*M01(LM,LP)
     +		    -OT1(LM,LP)/2D0/SW2/TPRIM*DT1M0
     &		    +(-(XG0+(s/MW2-1.D0)*YG0)/s
     &		      +(A0+C0)/(s-MZ2)*(XZ0+(s/MW2-1.D0)*YZ0)
     +		     )*OS2(LM,LP)
     &		    +(-YG0/MW2+(A0+C0)/(s-MZ2)*s/MW2*YZ0)*
     +			OS3(LM,LP)
     &		    +(-ZG0/MW2+(A0+C0)/(s-MZ2)*s/MW2*ZZ0)*
     +			OS4(LM,LP)
     &		    +X7M0*OX7(LM,LP)
	    endif
	    IF((IAPP.EQ.1).AND.(IDEN.EQ.1)) THEN
		if ( level.eq.1 ) then
		    M0D(LM,LP)=DOEF9*M01(LM,LP)
     +			-OT1(LM,LP)/2D0/SW2/TPRIM*DT1M0
		endif
	    END IF
	ELSE
	    MM0=COEF10*M01(LM,LP)
	    if ( level.eq.1 .or. lanoma ) then
		M0D(LM,LP)=DOEF10*M01(LM,LP)
     +		    -OT1(LM,LP)/2D0/SW2/TPRIM*T1P0
     &		    +(-(XG0+(s/MW2-1.D0)*YG0)/s
     &		    +(A0-C0)/(s-MZ2)*(XZ0+(s/MW2-1.D0)*YZ0))*
     +			OS2(LM,LP)
     &		    +(-YG0/MW2+(A0-C0)/(s-MZ2)*s/MW2*YZ0)*
     +			OS3(LM,LP)
     &		    +(-ZG0/MW2+(A0-C0)/(s-MZ2)*s/MW2*ZZ0)*
     +			OS4(LM,LP)
     &		    +X7P0*OX7(LM,LP)
	    endif
	    IF((IAPP.EQ.1).AND.(IDEN.EQ.1)) THEN
		if ( level.eq.1 ) then
		    M0D(LM,LP)=DOEF10*M01(LM,LP)
     +			-OT1(LM,LP)/2D0/SW2/TPRIM*T1P0
		endif
	    END IF
	END IF
	END
*###] MM0:
*###[ FF1:
	FUNCTION FF1(A)
	COMPLEX*16 FF1
	REAL*8 A(4)
	FF1=DCMPLX(A(2),-A(3))
	END
*###] FF1:
*###[ F3:
	FUNCTION F3(A,B,C)
	COMPLEX*16 F3,AM,BP,BM,CM
	REAL*8 A(4),B(4),C(4),ABP,BBP,BBM,CBM
	ABP=A(1)+A(4)
	AM=DCMPLX(A(2),-A(3))
	BBP=B(1)+B(4)
	BBM=B(1)-B(4)
	BP=DCMPLX(B(2),B(3))
	BM=DCONJG(BP)
	CBM=C(1)-C(4)
	CM=DCMPLX(C(2),-C(3))
	F3=ABP*(BBM*CM-BM*CBM)
     &	  +AM*(-BP*CM+BBP*CBM)
	END
*###] F3:
*###[ F5:
	FUNCTION F5(A,B,C,D,E)
	COMPLEX*16 F5,AM,BP,BM,CP,CM,DP,DM,EM
	REAL*8 A(4),B(4),C(4),D(4),E(4),ABP,BBP,BBM,CBP,CBM,DBP,
     &		DBM,EBM
	ABP=A(1)+A(4)
	AM=DCMPLX(A(2),-A(3))
	BBP=B(1)+B(4)
	BBM=B(1)-B(4)
	BP=DCMPLX(B(2),B(3))
	BM=DCONJG(BP)
	CBP=C(1)+C(4)
	CBM=C(1)-C(4)
	CP=DCMPLX(C(2),C(3))
	CM=DCONJG(CP)
	DBP=D(1)+D(4)
	DBM=D(1)-D(4)
	DP=DCMPLX(D(2),D(3))
	DM=DCONJG(DP)
	EBM=E(1)-E(4)
	EM=DCMPLX(E(2),-E(3))
	F5=(ABP*(BBM*CBP-BM*CP)
     &	   +AM*(-BP*CBP+BBP*CP))
     &		*(DBM*EM-DM*EBM)
     &	+(ABP*(BBM*CM-BM*CBM)
     &	 +AM*(-BP*CM+BBP*CBM))
     &		*(-DP*EM+DBP*EBM)
	END
*###] F5:
*###[ DSOFT0:
	FUNCTION DSOFT0(CP)
	REAL*8 W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,ME,ME2,BETAW,
     &	EM,QM,T,U,DELTAE,PI,PI2,CP,WWW,XR,XNOT,KMIN,KMAX,DSOFT0
	COMPLEX*16 SPENCE
	COMMON/BEZNAZ/ W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	COMMON/SOFCUT/XR,XNOT,KMIN,KMAX
	COMMON/PIATAN/PI,PI2

	EM=W/2
	QM=EM*BETAW
	T=MW2-2*EM*(EM-QM*CP)
	U=MW2-2*EM*(EM+QM*CP)
	DELTAE=KMIN
C SOFT BREMSSTRAHLUNG WITHOUT EXPONENTIATION OF THE IR DIVERGENCE:
	DSOFT0=-ALFA/PI*(2.D0*DLOG(2.D0*DELTAE/MW)
     &		+2.D0*DLOG(2.D0*DELTAE/W)*(1.D0-DLOG(S/ME2))
     &		+4.D0*DLOG(2.D0*DELTAE/W)*DLOG((MW2-U)/(MW2-T))+
     &		(S-2.D0*MW2)/S/BETAW*2.D0*DLOG(2.D0*DELTAE/W)
     &		*DLOG((1.D0-BETAW)/(1.D0+BETAW))
     &		+DLOG(ME2/S)+DLOG((1.D0-BETAW)/(1.D0+BETAW))/BETAW+
     +			PI2/3.D0-(S-2.D0*MW2)/S/BETAW
     &		*(2.D0*SPENCE(DCMPLX((1.D0-BETAW)/(1.D0+BETAW),0.D0))-
     &		(DLOG((1.D0-BETAW)/(1.D0+BETAW)))**2/2.D0-PI2/3.D0+
     &		2.D0*DLOG((1.D0-BETAW)/(1.D0+BETAW))
     &		*DLOG(2.D0*BETAW/(1.D0+BETAW)))
     &		+2.D0*(
     +		 SPENCE(DCMPLX(1.D0-S*(1.D0-BETAW)/2.D0/(MW2-T),0.D0))
     &		+SPENCE(DCMPLX(1.D0-S*(1.D0+BETAW)/2.D0/(MW2-T),0.D0))
     &		-SPENCE(DCMPLX(1.D0-S*(1.D0-BETAW)/2.D0/(MW2-U),0.D0))
     &		-SPENCE(DCMPLX(1.D0-S*(1.D0+BETAW)/2.D0/(MW2-U),0.D0))))

	END
*###] DSOFT0:
      SUBROUTINE ELWEAK(XR,COSTin)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 MH,MH2,MH4,MH6,MH8,MH10,MH12,MH14
      REAL*8 MZ,MZ2,MZ4,MZ6,MZ8
      REAL*8 MW,MW2,MW4,MW6,MW8
      REAL*8 ME,ME2,ME4,ME6,ME8
      REAL*8 MN,MP,MP2,MH0,MT0
      REAL*8 MF1,MF2
      REAL*8 K09,K10,K11,K18,K19,K21,K22,K23,K24,K28,K29,K30,K31
      REAL*8 GAMA0,GAMA,GAMA1,GAMA2,NCP
CKK
	REAL*8 S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
      REAL*8 MUP(8),MDOWN(8),QUP(8),QDOWN(8)
      REAL*8 MW0,MW20,MZ0,MZ20,ME0,ME20
CKK
      COMPLEX*16 AB0,AB1,B0,ZIPI2,B19,B20,PROPZ
      COMPLEX*16 FS01,FS02,FS03,FS04,FS01P,FS02P,FS03P,FS04P,FT01,FF5,
     &           FF5P
      COMPLEX*16 AA0,BB0,B0PM,BB1,B1PM,P2,Z0,C1,C2,C3,D0,D1,D2,D3,D4
      CHARACTER*4 SCHEME
      LOGICAL WEIGH
      DIMENSION TH(180)
      COMMON /blank/ 
     +	BB0,B0PM,BB1,B1PM,P2(2),Z0,C1(2),C2(4),C3(6),
     +	D0,D1(3),D2(7),D3(13),D4(22),
     +  PX(6),RM(4),DEL
      COMMON /OVR/ ME,MP,MW,MZ,MN,
     1             ME2,ME4,ME6,ME8,MP2,MW2,MW4,MW6,MW8,MZ2,MZ4,MZ6,MZ8,
     1             MH2,MH4,MH6,MH8,MH10,MH12,MH14,
     1             RE2,RE4,RE6,RE8,RP2,RW2,RW4,RW6,RW8,RZ2,RZ4,RZ6,RZ8,
     1             RH2,SI2,SI2I,AW,AW2,AW3,A20,A40,QE2,EE,XI,
     1             E,PP,QQ,EW,T,U,S5R,S6R,S7R,R11,R21,R31,R41,R51,R61
     1            ,R12,R22,R32,R42,R52,R62,AME5,AME6,AME7,AMZ5,AMZ6,AMP6
     1            ,AMZ7,P1DP2,P1DP3,P1DP4,P2DP3,P2DP4,P3DP4,
     1             DMH2,DMZ2,DMW2,DME1,DE1,DVI1
      COMMON /PIR/ ZIPI2
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /IMD/ IMAX,IND,IREM
      COMMON /BRE/ EEX,XOM,PI,XBREM
      COMMON /INP/ MH,COST,S
      COMMON /QQQ/ Q1,Q2
      COMMON /AMP/ S01I ,S02I ,S03I ,T01I ,T02I ,
     X             S01PI,S02PI,S03PI,T01PI,T02PI,F5I,F5PI
CKK   COMMON /AMP1/XL7,XL8,XR7,XR8,CBR
CKK
	COMMON /AMPT/S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
      COMMON/FMANDQ/MUP,MDOWN,QUP,QDOWN,FN,QCDF,IFERM
CKK
      COMMON /COE/ K09,K10,K11,K18,K19,K21,K22,K23,K24,K28,K29,K30,K31
      COMMON /DAX/ DAB,XAB
      COMMON /WGH/ WEIGH
      COMMON /ANO/ ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
      COMMON /APH/ APHNO
      COMMON /BOE/ EEY
      COMMON /REG/ REG
      COMMON /XTR/ AQQS,APQM
      COMMON /WMW/ WWW,OM
      COMMON /ZBR/ GZ
      COMMON/SCHEM/SCHEME
      COMMON/BEZNAZ/ W0,SS,MW0,MZ0,MW20,MZ20,CW,SW,CW2,SW2,A00,C00,ALFA,
     &               ME0,ME20,BETAW
      COMMON/TOPHIG/MT0,MH0
      COMMON/FERMIC/GF
      COMMON/PIATAN/PIAT,PIAT2
	double precision delta
	common/ffcut/delta
C
C     DATA PI /3.14159265358979D0/
C
C DEL is UV-cutoff (arbritary);
C Switches for debugging: Default (full result) is
C     DATA CFD,CFC,CFR     /1.D0,1.D0,1.D0/
C     DATA CTB,CTF,CFF,CSF /1.D0,1.D0,1.D0,1.D0/
C CFD=0.0 switch off bare Boxes  
C CFC=0.0 switch off bare Form-factors (GEE,ZEE,WEN,GWW,ZWW)
C CFR=0.0 switch off remaining 1-loop corrections
C CTB=0.0 switch off bosonic   contributions to counterterms
C CTF=0.0 switch off fermionic contributions to counterterms
C CFF=0.0 switch off fermionic contributions from bare form-factors
C CSF=0.0 switch off fermionic contributions from bare self-energies
C
Ctest 10-MAR-94 now read from input.dat(unit=2) in 'eewwm'
C      DATA CFD,CFC,CFR     /1.D0,1.D0,1.D0/
C      DATA CTB,CTF,CFF,CSF /1.D0,1.D0,1.D0,1.D0/
Ctest 
C
	cost = costin
      DEL = 0
      PI=PIAT
      E=W0
	MP = 0d0
      MW=MW0
      MZ=MZ0
      ME=ME0
      SI2=SW2
      QE2  = 4.D0*MW**2/MZ**2*(MZ**2-MW**2)
      V    = DSQRT(QE2/(ALFA*4.D0*PI))
C
      MN   =FN*ME
      ZPI2 = PIAT2
      ZIPI2=DCMPLX(0.D0,ZPI2)
      REG  =DEL/PIAT2
      WWW  =MW
CKK
      XOM=XR
C
      ME2  = ME**2
      ME4  = ME**4
      ME6  = ME**6
      ME8  = ME**8
      MP2  = MP**2
      MW2  = MW**2
      MW4  = MW**4
      MW6  = MW**6
      MW8  = MW**8
      MZ2  = MZ**2
      MZ4  = MZ**4
      MZ6  = MZ**6
      MZ8  = MZ**8

      RE2  = 1.D0/ME2
      RE4  = 1.D0/ME4
      RE6  = 1.D0/ME6
      RE8  = 1.D0/ME8
***      RP2  = 1.D0/MP2
      RW2  = 1.D0/MW2
      RW4  = 1.D0/MW4
      RW6  = 1.D0/MW6
      RW8  = 1.D0/MW8
      RZ2  = 1.D0/MZ2
      RZ4  = 1.D0/MZ4
      RZ6  = 1.D0/MZ6
      RZ8  = 1.D0/MZ8
C
      S1   = ME2
      S2   = MW2
      S3   = MW2
      S4   = ME2
C
      MH   = MH0
C
      ZS01I =0.
      ZS02I =0.
      ZS03I =0.
      ZT01I =0.
      ZT02I =0.
      ZS01PI=0.
      ZS02PI=0.
      ZS03PI=0.
      ZT01PI=0.
      ZT02PI=0.
      ZF5I  =0.
      ZF5PI =0.
C
      MH2  = MH**2
      MH4  = MH**4
      MH6  = MH**6
      MH8  = MH**8
      MH10 = MH**10
      MH12 = MH**12
      MH14 = MH**14

      RH2  = 1.D0/MH2
C
      SI2I = 1.D0/SI2
      AW   = SI2-.25D0
      AW2  = AW**2
      AW3  = AW**3
      A20  = CTB
      ANO  = V**(-4)/(16.D0*PIAT2)
      EE   = QE2/V**2
      EEX  = EE
      IF(SCHEME.EQ.'GMU') THEN
      APHNO=ANO
      V  =(DSQRT(2.D0)*GF)**(-0.5D0)
      EE =QE2/V**2
      EEY=EE
      ANO=V**(-4)/(16.D0*PIAT2)
      CI2=1.D0-SI2
      END IF
C
      XI   = 1.D0
C
      CALL SET
C
      S=SS
      PP   = S/4.D0-ME2
      QQ   = S/4.D0-MW2
      EW   = SQRT(QQ+MW2)
      T=MW2-S/2.D0*(1.D0-BETAW*COST)
      U=MW2-S/2.D0*(1.D0+BETAW*COST)
      S5   = T
      S6   = S
      S7   = U
      S5R  = 1.D0/S5
      S6R  = 1.D0/S6
      S7R  = 1.D0/S7
      R11  = RIDE(S2,S3,S6)
      R21  = RIDE(S5,S3,S4)
      R31  = RIDE(S1,S6,S4)
      R41  = RIDE(S1,S2,S5)
      R51  = RIDE(S4,S2,S7)
      R61  = RIDE(S7,S3,S1)
      R12  = R11**2
      R22  = R21**2
      R32  = R31**2
      R42  = R41**2
      R52  = R51**2
      R62  = R61**2
      AME5 = 1.D0/(S5-ME2)
      AME6 = 1.D0/(S6-ME2)
      AME7 = 1.D0/(S7-ME2)
      AMZ5 = 1.D0/(S5-MZ2)
      AMZ6 = 1.D0/(S6-MZ2)
      AMP6 = 1.D0/(S6-MP2)
      AMZ7 = 1.D0/(S7-MZ2)

      P1DP2=(S5-S1-S2)/2.
      P1DP3=(S7-S1-S3)/2.
      P1DP4=(S6-S1-S4)/2.
      P2DP3=(S6-S2-S3)/2.
      P2DP4=(S7-S2-S4)/2.
      P3DP4=(S5-S3-S4)/2.
C
CKK TREE LEVEL AMPLITUDES:
      FIS=1.D0/2.D0/SI2-1.D0
      GMZ=GZ*SQRT(MZ2)
      PROPZ=S/(S-MZ2+DCMPLX(0.D0,GMZ))
      BCOS =1.D0+BETAW**2-2.D0*BETAW*COST
      B19  =-EE/S*(1.D0+PROPZ*FIS)
      B20  =-EE/S*(1.D0-PROPZ)
      B21  = EE*2.D0/S/SI2/BCOS

C     CBE=BREMS(ME,MP)
C     CBW=BREMS(MW,MP)
C     FT =F1(ME,MW,T)* LOG(2.D0*OM/E )+FX2(ME,MW,T)
C     FU =F1(ME,MW,U)* LOG(2.D0*OM/E )+FX2(ME,MW,U)
C     CBM=(1.D0-(ME2+MW2)/T)*FT-(1.D0-(ME2+MW2)/U)*FU
C     CBR=CBE+CBW-2.D0*CBM
      CBR=0.D0
C
C     MASSEN - COUNTERTERME
C
      DMH2=-A20*(
     X      A0(MH)       *(-3.D0*MH2)
     X     +A0(MZ)       *(-MH2-6.D0*MZ2)
     X     +B0(MH,MH,MH2)*(-9.D0/2.D0*MH4)
     X     +B0(MZ,MZ,MH2)*(2.D0*MH2*MZ2-1.D0/2.D0*MH4-6.D0*MZ4)
     X     +A0(MW)       *(-2.D0*MH2-12.D0*MW2)
     X     +B0(MW,MW,MH2)*(4.D0*MH2*MW2-MH4-12.D0*MW4)             )/MH2
      DMZ2=-A20*(
     X      2.D0/3.D0*MH2*MZ2-4.D0/MH2*MZ6+4.D0/9.D0*MZ4
     X     +A0(MH)       *(-1.D0/3.D0*MH2-2.D0*MZ2)
     X     +A0(MZ)       *(1.D0/3.D0*MH2-6.D0/MH2*MZ4-2.D0/3.D0*MZ2)
     X     +B0(MZ,MH,MZ2)*(4.D0/3.D0*MH2*MZ2-1.D0/3.D0*MH4-4.D0*MZ4)
     X     - 8.D0/MH2*MW4*MZ2+20.D0/9.D0*MW2*MZ2-16.D0/3.D0*MW4
     X     +16.D0*MW6/MZ2-2.D0/9.D0*MZ4
     X     +A0(MW)       *(-12.D0/MH2*MW2*MZ2-16.D0/3.D0*MW2
     X                     +16.D0*MW4/MZ2-2.D0/3.D0*MZ2)
     X     +B0(MW,MW,MZ2)*(-16.D0/3.D0*MW2*MZ2+68.D0/3.D0*MW4
     X                     +16.D0*MW6/MZ2-1.D0/3.D0*MZ4)           )/MZ2
      DMW2=-A20*MW2*(
     X      2.D0/3.D0*MH2-8.D0/MH2*MW4-4.D0/MH2*MZ4+112.D0/9.D0*MW2
     X     +2.D0/3.D0*MZ2
     X     +A0(MH)       *(-2.D0-1.D0/3.D0*MH2/MW2)
     X     +A0(MW)       *(4.D0+1.D0/3.D0*MH2/MW2-12.D0/MH2*MW2
     X                         +1.D0/3.D0/MW2*MZ2)
     X     +A0(MZ)       *(-8.D0/3.D0-6.D0/MH2*MZ2+8.D0*MW2/MZ2
     X                     -1.D0/3.D0/MW2*MZ2)
     X     +B0(MH,MW,MW2)*(4.D0/3.D0*MH2-1.D0/3.D0*MH4/MW2-4.D0*MW2)
     X     +B0(MZ,MW,MW2)*(68.D0/3.D0*MW2+16.D0*MW4/MZ2
     X                     -1.D0/3.D0/MW2*MZ4-16.D0/3.D0*MZ2)
     X     +B0(MP,MW,MW2)*(16.D0*MW2-16.D0*MW4/MZ2)                )/MW2
      DME1= A20*(
     X      4.D0/MH2*MW4*ME2+2.D0/MH2*MZ4*ME2-3.D0*MW2*ME2
     X     +3.D0/2.D0*MZ2*ME2
     X     +A0(MH)       *ME2
     X     +A0(MW)       *(6.D0/MH2*MW2*ME2-MW2+1.D0/2.D0*ME2)
     X     +A0(MZ)       *(3.D0/MH2*MZ2*ME2+6.D0*MW2-4.D0*MW4/MZ2
     X                    -5.D0/2.D0*MZ2)
     X     +A0(ME)       *(-2.D0*MW2+5.D0/2.D0*MZ2+ME2)
     X     +B0(ME,MH,ME2)*(-1.D0/2.D0*MH2*ME2+2.D0*ME4)
     X     +B0(ME,MZ,ME2)*(6.D0*MW2*MZ2+12.D0*MW2*ME2-8.D0*MW4/MZ2*ME2
     X                     -4.D0*MW4-7.D0/2.D0*MZ2*ME2-5.D0/2.D0*MZ4)
     X     +B0(ME,MP,ME2)*(-8.D0*MW2*ME2+8.D0*MW4/MZ2*ME2)
     X     +B0(MN,MW,ME2)*(1.D0/2.D0*MW2*ME2-MW4+1.D0/2.D0*ME4)    )/ME2
      DE1=A20*(MZ2-MW2)/MZ2*(38.D0/3.D0*MW2+14.D0*A0(MW))
      DVI1 = DE1-A20/2.D0*SI2I*((MZ2-2.D0*MW2)/MZ2*DMW2+MW2/MZ2*DMZ2)
      IF(SCHEME.EQ.'GMU') THEN
      DVI1 = A20*(1.D0/2.D0*MH2-8.D0*MW4/MH2-4.D0*MZ4/MH2+9.D0*MW2
     1      +1.D0/2.D0*MZ2
     1      -6.D0*A0(MH)+(-12.D0*MW2/MH2-18.D0)*A0(MW)+(-6.D0*MZ2/MH2
     1      +8.D0*MW2/MZ2+20.D0)*A0(MZ)-3.D0*MH2*B0(MW,MH,0.D0)
     1                            +17.D0*MZ2*B0(MW,MZ,0.D0)
     1      +4.D0*MW2*(4.D0* LOG(MW2)- 4.D0*REG
     1                     -(4.D0*CI2+3.D0)/2.D0/SI2* LOG(CI2)-6.D0))
      DVI1 = DVI1/2.D0
      DE1  = DVI1+A20/2.D0*SI2I*((MZ2-2.D0*MW2)/MZ2*DMW2+MW2/MZ2*DMZ2)
      END IF
C
      AS01I =0.
      AS02I =0.
      AS03I =0.
      AT01I =0.
      AT02I =0.
      AS01PI=0.
      AS02PI=0.
      AS03PI=0.
      AT01PI=0.
      AT02PI=0.
      AF5I  =0.
      AF5PI =0.
C
      K09 = 2.D0*MW2*MZ2   *ANO
      K10 =    MW2*QE2/2.D0*ANO
      K11 =    MW4       *ANO
      K18 = 2.D0*MW6/MZ2   *ANO
      K19 =    MW2*QE2/2.D0*ANO
      K21 = 2.D0*MW6       *ANO
      K22 =16.D0*MW4       *ANO
      K23 =    QE2**2    *ANO
      K24 =-4.D0*MW2*QE2   *ANO
      K28 = 2.D0*MW4       *ANO
      K29 =-   MW2*QE2/2.D0*ANO
C     NUR PHOTONISCHE BOXEN (NICHT-PHOT. B. = 0)
C     K09=0. $ K11=0. $ K18=0. $ K21=0. $ K22=0. $ K28=0.
C     K09=0.
C     K11=0
C     K18=0.
C     K21=0.
C     K22=0.
C     K28=0.
C     NUR NICHT-PHOTONISCHE BOXEN (PHOT. B. = 0)
C     K10=0. $ K19=0. $ K23=0. $ K24=0. $ K29=0.
C     K10=0.
C     K19=0.
C     K23=0.
C     K24=0.
C     K29=0.
C
      IF(SCHEME.EQ.'GMU') THEN
      AGO=SQRT(APHNO/ANO)
C     AGO=0.
      K10=AGO*K10
      K19=AGO*K19
      K23=AGO*K23
      K24=AGO*K24
      K29=AGO*K29
      END IF
      K30 = K28
      K31 = K29
C
      DAB = AW-0.25
      XAB = DAB
      CALL AMPLI(AS01I ,AS02I ,AS03I ,AT01I ,AT02I ,1)
      XL7=S6*AQQS
      XL8=S6*APQM

      XAB = AW+0.25
      CALL AMPLI(AS01PI,AS02PI,AS03PI,AT01PI,AT02PI,2)
      XR7=S6*AQQS
      XR8=S6*APQM

      YW=4.D0*MW2/S6
      BW=SQRT(1.D0-YW)
      XIW=(1.D0-BW)/(1.D0+BW)
      IF(SCHEME.EQ.'ALFA') THEN
      CBRSNG=
     +EE /PIAT2*(- LOG(E/sqrt(delta))*( LOG(ME2/S6)/2.D0+(1.D0-YW/2.D0)
     +/2.D0/BW*LOG(XIW)+ LOG((MW2-S7)/(MW2-S5)))-( LOG(ME2/S6))**2/8.D0)
      ELSE
      CBRSNG=
     +EEX/PIAT2*(- LOG(E/sqrt(delta))*( LOG(ME2/S6)/2.D0+(1.D0-YW/2.D0)
     +/2.D0/BW*LOG(XIW)+ LOG((MW2-S7)/(MW2-S5)))-( LOG(ME2/S6))**2/8.D0)
      END IF
C     CBRSNG=0.
      AS01I =AS01I +0.5D0*B19*CBRSNG
      AS01PI=AS01PI+0.5D0*B20*CBRSNG
      AT01I =AT01I +0.5D0*B21*CBRSNG
C
      FS01I =0.
      FS02I =0.
      FS03I =0.
      FT01I =0.
      FT02I =0.
      FS01PI=0.
      FS02PI=0.
      FS03PI=0.
      FT01PI=0.
      FT02PI=0.
      FF5I  =0.
      FF5PI =0.
C
      STA40=ANO
      DO 98 IFER=1,IFERM

      MF1=MDOWN(IFER)
      MF2=MUP(IFER)
      Q1=QDOWN(IFER)
      Q2=QUP(IFER)

      IF(Q2.EQ.0.D0) THEN
      A40  =    STA40
      ELSE IF((IFER.EQ.4).OR.(IFER.EQ.5)) THEN
      A40  = 3.D0*STA40*QCDF
      ELSE
      A40  = 3.D0*STA40
      END IF

      WEIGH=.TRUE.

      CALL FREAM(MF1,MF2,Q1,Q2)
      FS01I =FS01I - FS01(MF1,MF2,Q1,Q2)
      FS02I =FS02I - FS02(MF1,MF2,Q1,Q2)
      FS03I =FS03I - FS03(MF1,MF2,Q1,Q2)
C
      FS01PI=FS01PI-FS01P(MF1,MF2,Q1,Q2)
      FS02PI=FS02PI-FS02P(MF1,MF2,Q1,Q2)
      FS03PI=FS03PI-FS03P(MF1,MF2,Q1,Q2)
C

      FT01I =FT01I + FT01(MF1,MF2,Q1,Q2)
C
      FF5I  =FF5I  -  FF5(MF1,MF2,Q1,Q2)
      FF5PI =FF5PI - FF5P(MF1,MF2,Q1,Q2)
C
C
   98 CONTINUE

      A40  =STA40
C
      AS01I =AS01I +FS01I
      AS02I =AS02I +FS02I
      AS03I =AS03I +FS03I
      AT01I =AT01I +FT01I
      AT02I =AT02I +FT02I
      AS01PI=AS01PI+FS01PI
      AS02PI=AS02PI+FS02PI
      AS03PI=AS03PI+FS03PI
      AT01PI=AT01PI+FT01PI
      AT02PI=AT02PI+FT02PI
      AF5I  =       FF5I
      AF5PI =       FF5PI
C
      S01I =AS01I
      S02I =AS02I
      S03I =AS03I
      T01I =AT01I
      T02I =AT02I
      S01PI=AS01PI
      S02PI=AS02PI
      S03PI=AS03PI
      T01PI=AT01PI
      T02PI=AT02PI
      F5I  =AF5I
      F5PI =AF5PI

      S01IT=S01I
      S02IT=S02I
      S03IT=S03I
      T01IT=T01I
      T02IT=T02I
      S01PIT=S01PI
      S02PIT=S02PI
      S03PIT=S03PI
      T01PIT=T01PI
      T02PIT=T02PI
      F5IT=F5I
      F5PIT=F5PI
      XL7T=XL7
      XL8T=XL8
      XR7T=XR7
      XR8T=XR8
      CBRT=CBR
CKK
      END
      SUBROUTINE FREAM(MB,MT,QB,QT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      REAL*8 MH,MH2,MH4,MH6,MH8,MH10,MH12,MH14
      REAL*8 MZ,MZ2,MZ4,MZ6,MZ8
      REAL*8 MW,MW2,MW4,MW6,MW8
      REAL*8 ME,ME2,ME4,ME6,ME8
      REAL*8 MN,MP,MP2
      REAL*8 MB,MT,MB2,MT2,MB4,MT4,MZW2I,IDE01
      REAL*8 MF1,MF2
      DOUBLE COMPLEX B0,AB0,C0,C11,C12,C21,C22,C23,C24,C25,C26,C27
      DOUBLE COMPLEX C31,C32,C33,C34,C35,C36
      DOUBLE COMPLEX  SREN1,S1ZWF,S2ZWF,S3ZWF,S4ZWF,S5ZWF,
     1                GREN1,G1ZWF,G2ZWF,G3ZWF,G4ZWF,G5ZWF,
     1                S1GWF,S2GWF,S3GWF,S4GWF,S5GWF
      DOUBLE COMPLEX  FHR1,FHR2,FH3N,FHR4,FHR5,FLR1,
     1                FLR2,FL3N,FLR4,FLR5
      DOUBLE COMPLEX  GHR1,GHR2,GH3N,GHR4,GHR5
      DOUBLE COMPLEX  XDMZ2,XZVZ,XZZPU,XDMZG,XOMZG,XZGPU,XZVG,
     1                XGGPU,XDMW2,XZVW,XDE1
      CHARACTER*4 SCHEME
      LOGICAL      WEIGH
      COMMON /OVR/ ME,MP,MW,MZ,MN,
     1             ME2,ME4,ME6,ME8,MP2,MW2,MW4,MW6,MW8,MZ2,MZ4,MZ6,MZ8,
     1             MH2,MH4,MH6,MH8,MH10,MH12,MH14,
     1             RE2,RE4,RE6,RE8,RP2,RW2,RW4,RW6,RW8,RZ2,RZ4,RZ6,RZ8,
     1             RH2,SI2,SI2I,AC,AW2,AW3,A20,A40,QE2,EE,XI,
     1             E,PP,QQ,EW,T,U,S5R,S6R,S7R,R11,R21,R31,R41,R51,R61
     1            ,R12,R22,R32,R42,R52,R62,AME5,AME6,AME7,AMZ5,AMZ6,AMP6
     1            ,AMZ7,P1DP2,P1DP3,P1DP4,P2DP3,P2DP4,P3DP4,
     1             XMH2,XMZ2,XMW2,XME1,XE1,XVI1
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /AMF/ SREN1,S1ZWF,S2ZWF,S3ZWF,S4ZWF,S5ZWF,
     1             GREN1,G1ZWF,G2ZWF,G3ZWF,G4ZWF,G5ZWF,
     1                   S1GWF,S2GWF,S3GWF,S4GWF,S5GWF
      COMMON /RNS/ XDMZ2,XZVZ,XZZPU,XDMZG,XOMZG,XZGPU,XZVG,
     1             XGGPU,XDMW2,XZVW,XDE1,DQI1
      COMMON /FHL/ FHR1,FHR2,FH3N,FHR4,FHR5
      COMMON /GHL/ GHR1,GHR2,GH3N,GHR4,GHR5
      COMMON /WGH/ WEIGH
      COMMON /FER/ BC,MZW2I
      COMMON /ANO/ AXY,CFD,CFC,CFR,CTB,CTF,CFF,CSF
      COMMON /INP/ MH,COST,S
      COMMON/SCHEM/SCHEME
C
      MT2=MT**2
      MB2=MB**2
      MB4=MB**4
      MT4=MT**4
      RMZ2=RZ2
      RMZ4=RZ4
      RMW2=RW2
      RMW4=RW4
      MF1=MB
      MF2=MT
      QB4=QB**2
      QT4=QT**2
      SI4=SI2**2
      BC =0.25D0
      MZW2I=1.D0/(MZ2-MW2)
      IDE01=R11
      SIDE1=S6*IDE01
      SIDE2=SIDE1**2
      SIDE3=SIDE1**3
C
       XDMZ2=+4.D0/9.D0*MZ2-4.D0/3.D0*MT2-4.D0/3.D0*MB2
     1 -8.D0/9.D0*QT*SI2*MZ2+16.D0/3.D0*QT*SI2*MT2+8.D0/9.D0*SI2*QB*MZ2
     1 -16.D0/3.D0*SI2*QB*MB2+16.D0/9.D0*SI4*QT4*MZ2
     1 -32.D0/3.D0*SI4*QT4*MT2+16.D0/9.D0*SI4*QB4*MZ2
     1 -32.D0/3.D0*SI4*QB4*MB2
     1 +A0(MB)*(-4.D0/3.D0+8.D0*MH**(-2)*MB2-16.D0/3.D0*SI2*QB
     1 -32.D0/3.D0*SI4*QB4)
     1 +A0(MT)*(-4.D0/3.D0+8.D0*MH**(-2)*MT2+16.D0/3.D0*QT*SI2
     1 -32.D0/3.D0*SI4*QT4)
     1 +B0(MB,MB,MZ2)*(-2.D0/3.D0*MZ2+2.D0/3.D0*MB2
     1  -8.D0/3.D0*SI2*QB*MZ2-16.D0/3.D0*SI2*QB*MB2
     1 -16.D0/3.D0*SI4*QB4*MZ2-32.D0/3.D0*SI4*QB4*MB2)
     1 +B0(MT,MT,MZ2)*(-2.D0/3.D0*MZ2+2.D0/3.D0*MT2
     1  +8.D0/3.D0*QT*SI2*MZ2+16.D0/3.D0*QT*SI2*MT2
     1 -16.D0/3.D0*SI4*QT4*MZ2-32.D0/3.D0*SI4*QT4*MT2)
       XZVZ=+4.D0/9.D0-8.D0/9.D0*QT*SI2+8.D0/9.D0*SI2*QB
     1 +16.D0/9.D0*SI4*QT4+16.D0/9.D0*SI4*QB4
     1 +B0(MB,MB,MZ2)*(-2.D0/3.D0-8.D0/3.D0*SI2*QB-16.D0/3.D0*SI4*QB4)
     1 +B0(MT,MT,MZ2)*(-2.D0/3.D0+8.D0/3.D0*QT*SI2-16.D0/3.D0*SI4*QT4)
     1 +AB0(MB,MB,MZ2)*(-2.D0/3.D0*MZ2+2.D0/3.D0*MB2
     1  -8.D0/3.D0*SI2*QB*MZ2-16.D0/3.D0*SI2*QB*MB2
     1 -16.D0/3.D0*SI4*QB4*MZ2-32.D0/3.D0*SI4*QB4*MB2)
     1 +AB0(MT,MT,MZ2)*(-2.D0/3.D0*MZ2+2.D0/3.D0*MT2
     1  +8.D0/3.D0*QT*SI2*MZ2+16.D0/3.D0*QT*SI2*MT2
     1 -16.D0/3.D0*SI4*QT4*MZ2-32.D0/3.D0*SI4*QT4*MT2)
       XZZPU=-4.D0/3.D0*MT2-4.D0/3.D0*MB2+4.D0/9.D0*S6
     1  -8.D0/9.D0*S6*QT*SI2+8.D0/9.D0*S6*SI2*QB
     1 +16.D0/9.D0*S6*SI4*QT4+16.D0/9.D0*S6*SI4*QB4
     1 +16.D0/3.D0*QT*SI2*MT2-16.D0/3.D0*SI2*QB*MB2
     1 -32.D0/3.D0*SI4*QT4*MT2-32.D0/3.D0*SI4*QB4*MB2
     1 +A0(MB)*(-4.D0/3.D0+8.D0*MH**(-2)*MB2-16.D0/3.D0*SI2*QB
     1 -32.D0/3.D0*SI4*QB4)
     1 +A0(MT)*(-4.D0/3.D0+8.D0*MH**(-2)*MT2+16.D0/3.D0*QT*SI2
     1 -32.D0/3.D0*SI4*QT4)
     1 +B0(MB,MB,S6)*(2.D0/3.D0*MB2-2.D0/3.D0*S6-8.D0/3.D0*S6*SI2*QB
     1 -16.D0/3.D0*S6*SI4*QB4-16.D0/3.D0*SI2*QB*MB2
     1 -32.D0/3.D0*SI4*QB4*MB2)
     1 +B0(MT,MT,S6)*(2.D0/3.D0*MT2-2.D0/3.D0*S6+8.D0/3.D0*S6*QT*SI2
     1 -16.D0/3.D0*S6*SI4*QT4+16.D0/3.D0*QT*SI2*MT2
     1 -32.D0/3.D0*SI4*QT4*MT2)
       XDMZG=0.D0
       XOMZG=+2.D0/9.D0*QT*MZ2-4.D0/3.D0*QT*MT2-8.D0/9.D0*SI2*QT4*MZ2
     1 +16.D0/3.D0*SI2*QT4*MT2-8.D0/9.D0*SI2*QB4*MZ2
     1 +16.D0/3.D0*SI2*QB4*MB2-2.D0/9.D0*QB*MZ2+4.D0/3.D0*QB*MB2
     1 +A0(MB)*(16.D0/3.D0*SI2*QB4+4.D0/3.D0*QB)
     1 +A0(MT)*(-4.D0/3.D0*QT+16.D0/3.D0*SI2*QT4)
     1 +B0(MB,MB,MZ2)*(8.D0/3.D0*SI2*QB4*MZ2+16.D0/3.D0*SI2*QB4*MB2
     1 +2.D0/3.D0*QB*MZ2+4.D0/3.D0*QB*MB2)
     1 +B0(MT,MT,MZ2)*(-2.D0/3.D0*QT*MZ2-4.D0/3.D0*QT*MT2
     1 +8.D0/3.D0*SI2*QT4*MZ2+16.D0/3.D0*SI2*QT4*MT2)
       XZGPU=+2.D0/9.D0*S6*QT-8.D0/9.D0*S6*SI2*QT4
     1 -8.D0/9.D0*S6*SI2*QB4-2.D0/9.D0*S6*QB
     1 -4.D0/3.D0*QT*MT2+16.D0/3.D0*SI2*QT4*MT2+16.D0/3.D0*SI2*QB4*MB2
     1 +4.D0/3.D0*QB*MB2
     1 +A0(MB)*(16.D0/3.D0*SI2*QB4+4.D0/3.D0*QB)
     1 +A0(MT)*(-4.D0/3.D0*QT+16.D0/3.D0*SI2*QT4)
     1 +B0(MB,MB,S6)*(8.D0/3.D0*S6*SI2*QB4+2.D0/3.D0*S6*QB
     1 +16.D0/3.D0*SI2*QB4*MB2+4.D0/3.D0*QB*MB2)
     1 +B0(MT,MT,S6)*(-2.D0/3.D0*S6*QT+8.D0/3.D0*S6*SI2*QT4
     1 -4.D0/3.D0*QT*MT2+16.D0/3.D0*SI2*QT4*MT2)
      XZGPU=-XZGPU
       XZVG=+4.D0/3.D0*QT4+4.D0/3.D0*QB4
     1 +AA(MB)*(4.D0/3.D0*QB4)
     1 +AA(MT)*(4.D0/3.D0*QT4)
       XGGPU=+4.D0/9.D0*S6*QT4+4.D0/9.D0*S6*QB4-8.D0/3.D0*QT4*MT2
     1 -8.D0/3.D0*QB4*MB2
     1 +A0(MB)*(-8.D0/3.D0*QB4)
     1 +A0(MT)*(-8.D0/3.D0*QT4)
     1 +B0(MB,MB,S6)*(-4.D0/3.D0*S6*QB4-8.D0/3.D0*QB4*MB2)
     1 +B0(MT,MT,S6)*(-4.D0/3.D0*S6*QT4-8.D0/3.D0*QT4*MT2)
       XDMW2=+4.D0/9.D0*MW2-4.D0/3.D0*MT2-4.D0/3.D0*MB2
     1 +A0(MB)*(-4.D0/3.D0+8.D0*MH**(-2)*MB2-2.D0/3.D0*RMW2*MT2
     1 +2.D0/3.D0*RMW2*MB2)
     1 +A0(MT)*(-4.D0/3.D0+8.D0*MH**(-2)*MT2+2.D0/3.D0*RMW2*MT2
     1 -2.D0/3.D0*RMW2*MB2)
     1 +B0(MT,MB,MW2)*(-4.D0/3.D0*MW2+2.D0/3.D0*MT2+2.D0/3.D0*MB2
     1 -4.D0/3.D0*RMW2*MT2*MB2+2.D0/3.D0*RMW2*MT4+2.D0/3.D0*RMW2*MB4)
       XZVW=+4.D0/9.
     1 D0+A0(MB)*(2.D0/3.D0*RMW4*MT2-2.D0/3.D0*RMW4*MB2)
     1 +A0(MT)*(-2.D0/3.D0*RMW4*MT2+2.D0/3.D0*RMW4*MB2)
     1 +B0(MT,MB,MW2)*(-4.D0/3.D0+4.D0/3.D0*RMW4*MT2*MB2
     1 -2.D0/3.D0*RMW4*MT4-2.D0/3.D0*RMW4*MB4)
     1 +AB0(MT,MB,MW2)*(-4.D0/3.D0*MW2+2.D0/3.D0*MT2+2.D0/3.D0*MB2
     1 -4.D0/3.D0*RMW2*MT2*MB2+2.D0/3.D0*RMW2*MT4+2.D0/3.D0*RMW2*MB4)
       XDE1=-2.D0/3.D0*QE2*QT4-2.D0/3.D0*QE2*QB4
     1 +AA(MB)*(-2.D0/3.D0*QE2*QB4)
     1 +AA(MT)*(-2.D0/3.D0*QE2*QT4)
      DQI1=XDE1+1.D0/2.D0*SI2I*((MZ2-2.D0*MW2)/MZ2*XDMW2+MW2/MZ2*XDMZ2)
      IF(SCHEME.EQ.'GMU') THEN
      DQI1 = 8.D0*MF1**2/MH2*A0(MF1)+8.D0*MF2**2/MH2*A0(MF2)
     1           -(MF1**2+MF2**2)
     1      -2.D0*(MF1**2*A0(MF1)-MF2**2*A0(MF2))/(MF1**2-MF2**2)
      DQI1 = DQI1/2.D0
      XDE1 = DQI1-1.D0/2.D0*SI2I*((MZ2-2.D0*MW2)/MZ2*XDMW2
     1      +MW2/MZ2*XDMZ2)
      END IF
      IF (CTF.EQ.0.D0) THEN
        XDMZ2=0.D0
        XDMW2=0.D0
        XDE1 =0.D0
        DQI1 =0.D0
        XZVZ =0.D0
        XZVW =0.D0
        XZVG =0.D0
      END IF
      IF (CSF.EQ.0.D0) THEN
        XZZPU=0.D0
        XDMZG=0.D0
        XOMZG=0.D0
        XZGPU=0.D0
        XZGPU=0.D0
        XGGPU=0.D0
      END IF
C
C     IPA=1 : Z , IPA=2 : G
C
      DO 22 IPA=1,2
      CALL SET
      BX=0.25D0
      ATX=-QT*SI2+BX
      ABX=-QB*SI2-BX
      IF(IPA.EQ.1) GOTO 15
      BX=0.D0
      ATX=+QT
      ABX=+QB
   15 CONTINUE
C
      IF (CFF.EQ.0.D0) THEN
        FHR1=0.D0
        FHR2=0.D0
        FH3N=0.D0
        FHR4=0.D0
        FHR5=0.D0
        GHR1=0.D0
        GHR2=0.D0
        GH3N=0.D0
        GHR4=0.D0
        GHR5=0.D0
        RETURN
      END IF
      IF(.NOT.WEIGH) GOTO 10
C
       FHR1=
     1 +B0(MT,MB,MW2)*(-4.D0*ATX-8.D0*BX+4.D0*ABX)
     1 +C35(MB,MT,MT,1)*(16.D0*ATX+16.D0*BX)
     1 +C35(MT,MB,MB,1)*(16.D0*BX-16.D0*ABX)
     1 +C24(MB,MT,MT,1)*(16.D0*ATX+16.D0*BX)
     1 +C24(MT,MB,MB,1)*(16.D0*BX-16.D0*ABX)
     1 +C11(MB,MT,MT,1)*(2.D0*S6*ATX+2.D0*S6*BX-4.D0*ATX*MW2
     1 +4.D0*ATX*MT2-8.D0*ATX*MB2-4.D0*BX*MW2-4.D0*BX*MT2-8.D0*BX*MB2)
       FHR1 = FHR1
     1 +C11(MT,MB,MB,1)*(2.D0*S6*BX-2.D0*S6*ABX-4.D0*BX*MW2+4.D0*BX*MT2
     1 -4.D0*BX*MB2+4.D0*ABX*MW2-4.D0*ABX*MT2-4.D0*ABX*MB2)
     1 +C0(MB,MT,MT,1)*(-4.D0*ATX*MW2+4.D0*ATX*MT2-8.D0*ATX*MB2
     1 -4.D0*BX*MW2+4.D0*BX*MT2-8.D0*BX*MB2)
     1 +C0(MT,MB,MB,1)*(-4.D0*BX*MW2+4.D0*BX*MT2+4.D0*BX*MB2
     1 +4.D0*ABX*MW2-4.D0*ABX*MT2-4.D0*ABX*MB2)
       FHR2=
     1 +C34(MB,MT,MT,1)*(16.D0*ATX*MW2+16.D0*BX*MW2)
     1 +C34(MT,MB,MB,1)*(16.D0*BX*MW2-16.D0*ABX*MW2)
     1 +C33(MB,MT,MT,1)*(-16.D0*ATX*MW2-16.D0*BX*MW2)
     1 +C33(MT,MB,MB,1)*(-16.D0*BX*MW2+16.D0*ABX*MW2)
     1 +C23(MB,MT,MT,1)*(-16.D0*ATX*MW2-16.D0*BX*MW2)
     1 +C23(MT,MB,MB,1)*(-16.D0*BX*MW2+16.D0*ABX*MW2)
     1 +C22(MB,MT,MT,1)*(16.D0*ATX*MW2+16.D0*BX*MW2)
     1 +C22(MT,MB,MB,1)*(16.D0*BX*MW2-16.D0*ABX*MW2)
       FH3N=
     1 +B0(MB,MB,S6)*(-4.D0*BX+4.D0*ABX)
     1 +B0(MT,MB,MW2)*(4.D0*ATX+8.D0*BX-4.D0*ABX)
     1 +B0(MT,MT,S6)*(-4.D0*ATX-4.D0*BX)
     1 +C35(MB,MT,MT,1)*(-48.D0*ATX-48.D0*BX)
     1 +C35(MT,MB,MB,1)*(-48.D0*BX+48.D0*ABX)
     1 +C24(MB,MT,MT,1)*(-32.D0*ATX-32.D0*BX)
     1 +C24(MT,MB,MB,1)*(-32.D0*BX+32.D0*ABX)
     1 +C11(MB,MT,MT,1)*(-2.D0*S6*ATX-2.D0*S6*BX+8.D0*ATX*MW2
     1 -8.D0*ATX*MT2+16.D0*ATX*MB2+8.D0*BX*MW2+16.D0*BX*MB2)
       FH3N = FH3N
     1 +C11(MT,MB,MB,1)*(-2.D0*S6*BX+2.D0*S6*ABX+8.D0*BX*MW2
     1 -8.D0*BX*MT2-8.D0*ABX*MW2+8.D0*ABX*MT2+8.D0*ABX*MB2)
     1 +C0(MB,MT,MT,1)*(4.D0*ATX*MW2-4.D0*ATX*MT2+20.D0*ATX*MB2
     1 +4.D0*BX*MW2-4.D0*BX*MT2+20.D0*BX*MB2)
     1 +C0(MT,MB,MB,1)*(4.D0*BX*MW2-4.D0*BX*MT2-4.D0*BX*MB2
     1 -4.D0*ABX*MW2+4.D0*ABX*MT2+4.D0*ABX*MB2)
       FHR4=0.D0
       FHR5=
     1 +A0(MB)*(2.D0*ATX*RMW2+4.D0*BX*RMW2-2.D0*ABX*RMW2)
     1 +A0(MT)*(-2.D0*ATX*RMW2-4.D0*BX*RMW2+2.D0*ABX*RMW2)
     1 +B0(MT,MB,MW2)*(2.D0*ATX-2.D0*ATX*RMW2*MT2+2.D0*ATX*RMW2*MB2
     1 -4.D0*BX*RMW2*MT2+4.D0*BX*RMW2*MB2+2.D0*ABX+2.D0*ABX*RMW2*MT2
     1 -2.D0*ABX*RMW2*MB2)
     1 +C24(MB,MT,MT,1)*(-8.D0*ATX-8.D0*BX)
     1 +C24(MT,MB,MB,1)*(8.D0*BX-8.D0*ABX)
     1 +C11(MB,MT,MT,1)*(-2.D0*S6*ATX-2.D0*S6*BX+8.D0*BX*MT2)
     1 +C11(MT,MB,MB,1)*(-2.D0*S6*BX+2.D0*S6*ABX-8.D0*BX*MB2)
       FHR5 = FHR5
     1 +C23(MB,MT,MT,1)*(4.D0*S6*ATX+4.D0*S6*BX)
     1 +C23(MT,MB,MB,1)*(4.D0*S6*BX-4.D0*S6*ABX)
     1 +C12(MB,MT,MT,1)*(4.D0*S6*ATX+4.D0*S6*BX)
     1 +C12(MT,MB,MB,1)*(4.D0*S6*BX-4.D0*S6*ABX)
     1 +C21(MT,MB,MB,1)*(-4.D0*S6*BX+4.D0*S6*ABX)
      IF(IPA.EQ.2) GOTO 18
      FLR1=FHR1
      FLR2=FHR2
      FL3N=FH3N
      FLR4=FHR4
      FLR5=FHR5
      GOTO 20
C
   10 CONTINUE
C
       FLR1=
     1 +20.D0/9.D0*ATX-8.D0/3.D0*ATX*MW2*SIDE1+40.D0/9.D0*BX
     1 -16.D0/3.D0*BX*MW2*SIDE1-20.D0/9.D0*ABX
     1 +8.D0/3.D0*ABX*MW2*SIDE1
     1 +A0(MB)*(-8.D0/3.D0*ATX*SIDE1-8.D0/3.D0*ABX*SIDE1)
     1 +A0(MT)*(8.D0/3.D0*ATX*SIDE1+8.D0/3.D0*ABX*SIDE1)
     1 +B0(MB,MB,S6)*(-8.D0/3.D0*BX+8.D0/3.D0*BX*MW2*SIDE1
     1 +16.D0*BX*MW4*SIDE2+8.D0/3.D0*ABX-8.D0/3.D0*ABX*MW2*SIDE1
     1 -16.D0*ABX*MW4*SIDE2)
     1 +B0(MT,MB,MW2)*(-8.D0/3.D0*ATX*MW2*SIDE1-16.D0*ATX*MW4*SIDE2
     1 -16.D0/3.D0*BX*MW2*SIDE1-32.D0*BX*MW4*SIDE2
     1  +8.D0/3.D0*ABX*MW2*SIDE1+16.D0*ABX*MW4*SIDE2)
       FLR1 = FLR1
     1 +B0(MT,MT,S6)*(-8.D0/3.D0*ATX+8.D0/3.D0*ATX*MW2*SIDE1
     1 +16.D0*ATX*MW4*SIDE2-8.D0/3.D0*BX+8.D0/3.D0*BX*MW2*SIDE1
     1 +16.D0*BX*MW4*SIDE2)
     1 +C0(MB,MT,MT,1)*(-16.D0*ATX*MW6*SIDE2-16.D0*BX*MW6*SIDE2)
     1 +C0(MT,MB,MB,1)*(-16.D0*BX*MW6*SIDE2+16.D0*ABX*MW6*SIDE2)
       FLR2=+8.D0*IDE01*ATX*MW4+16.D0*IDE01*BX*MW4-8.D0*IDE01*ABX*MW4
     1  -8.D0/3.D0*ATX*MW2*SIDE1+40.D0/3.D0*ATX*MW4*SIDE2
     1 -16.D0/3.D0*BX*MW2*SIDE1+80.D0/3.D0*BX*MW4*SIDE2
     1  +8.D0/3.D0*ABX*MW2*SIDE1-40.D0/3.D0*ABX*MW4*SIDE2
     1 +A0(MB)*(-64.D0/3.D0*IDE01*ATX*MW2
     1 +160.D0/3.D0*IDE01*ATX*MW4*SIDE1-32.D0/3.D0*IDE01*BX*MW2
     1  -32.D0/3.D0*IDE01*ABX*MW2+160.D0/3.D0*IDE01*ABX*MW4*SIDE1)
     1 +A0(MT)*(32.D0/3.D0*IDE01*ATX*MW2
     1 -160.D0/3.D0*IDE01*ATX*MW4*SIDE1-32.D0/3.D0*IDE01*BX*MW2
     1  +64.D0/3.D0*IDE01*ABX*MW2-160.D0/3.D0*IDE01*ABX*MW4*SIDE1)
     1 +B0(MB,MB,S6)*(4.D0*IDE01*BX*MW4-4.D0*IDE01*ABX*MW4
     1 +44.D0/3.D0*BX*MW4*SIDE2-80.D0*BX*MW6*SIDE3
     1 -44.D0/3.D0*ABX*MW4*SIDE2+80.D0*ABX*MW6*SIDE3)
       FLR2 = FLR2
     1 +B0(MT,MB,MW2)*(-4.D0*IDE01*ATX*MW4-8.D0*IDE01*BX*MW4
     1   +4.D0*IDE01*ABX*MW4-44.D0/3.D0*ATX*MW4*SIDE2
     1  +80.D0*ATX*MW6*SIDE3-88.D0/3.D0*BX*MW4*SIDE2
     1 +160.D0*BX*MW6*SIDE3+44.D0/3.D0*ABX*MW4*SIDE2
     1  -80.D0*ABX*MW6*SIDE3)
     1 +B0(MT,MT,S6)*(4.D0*IDE01*ATX*MW4+4.D0*IDE01*BX*MW4
     1 +44.D0/3.D0*ATX*MW4*SIDE2-80.D0*ATX*MW6*SIDE3
     1 +44.D0/3.D0*BX*MW4*SIDE2-80.D0*BX*MW6*SIDE3)
     1 +C0(MB,MT,MT,1)*(4.D0*IDE01*ATX*MW6+4.D0*IDE01*BX*MW6
     1 -28.D0*ATX*MW6*SIDE2+80.D0*ATX*MW8*SIDE3-28.D0*BX*MW6*SIDE2
     1 +80.D0*BX*MW8*SIDE3)
     1 +C0(MT,MB,MB,1)*(4.D0*IDE01*BX*MW6-4.D0*IDE01*ABX*MW6
     1 -28.D0*BX*MW6*SIDE2+80.D0*BX*MW8*SIDE3+28.D0*ABX*MW6*SIDE2
     1 -80.D0*ABX*MW8*SIDE3)
       FL3N=-8.D0/3.D0*ATX+8.D0*ATX*MW2*SIDE1-16.D0/3.D0*BX
     1 +16.D0*BX*MW2*SIDE1+8.D0/3.D0*ABX-8.D0*ABX*MW2*SIDE1
     1 +A0(MB)*(8.D0*ATX*SIDE1+8.D0*ABX*SIDE1)
     1 +A0(MT)*(-8.D0*ATX*SIDE1-8.D0*ABX*SIDE1)
     1 +B0(MB,MB,S6)*(8.D0*BX*MW2*SIDE1-48.D0*BX*MW4*SIDE2
     1  -8.D0*ABX*MW2*SIDE1+48.D0*ABX*MW4*SIDE2)
     1 +B0(MT,MB,MW2)*(-8.D0*ATX*MW2*SIDE1+48.D0*ATX*MW4*SIDE2
     1 -16.D0*BX*MW2*SIDE1+96.D0*BX*MW4*SIDE2+8.D0*ABX*MW2*SIDE1
     1 -48.D0*ABX*MW4*SIDE2)
     1 +B0(MT,MT,S6)*(8.D0*ATX*MW2*SIDE1-48.D0*ATX*MW4*SIDE2
     1 +8.D0*BX*MW2*SIDE1-48.D0*BX*MW4*SIDE2)
       FL3N = FL3N
     1 +C0(MB,MT,MT,1)*(-16.D0*ATX*MW4*SIDE1+48.D0*ATX*MW6*SIDE2
     1 -16.D0*BX*MW4*SIDE1+48.D0*BX*MW6*SIDE2)
     1 +C0(MT,MB,MB,1)*(-16.D0*BX*MW4*SIDE1+48.D0*BX*MW6*SIDE2
     1 +16.D0*ABX*MW4*SIDE1-48.D0*ABX*MW6*SIDE2)
       FLR4=0.D0
       FLR5=-4.D0*ATX+8.D0*ATX*MW2*SIDE1-4.D0*ABX+8.D0*ABX*MW2*SIDE1
     1 +A0(MB)*(8.D0*ATX*SIDE1+16.D0*BX*SIDE1-8.D0*ABX*SIDE1)
     1 +A0(MT)*(-8.D0*ATX*SIDE1-16.D0*BX*SIDE1+8.D0*ABX*SIDE1)
     1 +B0(MB,MB,S6)*(-8.D0*BX*MW2*SIDE1+48.D0*BX*MW4*SIDE2
     1 +8.D0*ABX*MW2*SIDE1-48.D0*ABX*MW4*SIDE2)
     1 +B0(MT,MB,MW2)*(-8.D0*ATX*MW2*SIDE1+48.D0*ATX*MW4*SIDE2
     1 -8.D0*ABX*MW2*SIDE1+48.D0*ABX*MW4*SIDE2)
     1 +B0(MT,MT,S6)*(8.D0*ATX*MW2*SIDE1-48.D0*ATX*MW4*SIDE2
     1 +8.D0*BX*MW2*SIDE1-48.D0*BX*MW4*SIDE2)
       FLR5 = FLR5
     1 +C0(MB,MT,MT,1)*(-16.D0*ATX*MW4*SIDE1+48.D0*ATX*MW6*SIDE2
     1 -16.D0*BX*MW4*SIDE1+48.D0*BX*MW6*SIDE2)
     1 +C0(MT,MB,MB,1)*(16.D0*BX*MW4*SIDE1-48.D0*BX*MW6*SIDE2
     1 -16.D0*ABX*MW4*SIDE1+48.D0*ABX*MW6*SIDE2)+0.
C
      IF(IPA.EQ.2) GOTO 19
      FHR1=FLR1
      FHR2=FLR2
      FH3N=FL3N
      FHR4=FLR4
      FHR5=FLR5
      GOTO 20
   18 GHR1=FHR1
      GHR2=FHR2
      GH3N=FH3N
      GHR4=FHR4
      GHR5=FHR5
      GOTO 20
   19 GHR1=FLR1
      GHR2=FLR2
      GH3N=FL3N
      GHR4=FLR4
      GHR5=FLR5
C
   20 CONTINUE
      IF((IPA.EQ.2).AND.(.NOT.WEIGH)) GOTO 22
      FHR1=FLR1
      FHR2=FLR2
      FH3N=FL3N
      FHR4=FLR4
      FHR5=FLR5
C
C  21 FORMAT( / 5X, 1I5, 1P2E20.13 )
C     IF(IPA.EQ.1) WRITE(6,21) IPA,FHR1
C     IF(IPA.EQ.2) WRITE(6,21) IPA,GHR1
C
   22 CONTINUE
C
      RETURN
      END

      DOUBLE COMPLEX FUNCTION FERMI(MB,MT,QB,QT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 MH,MH2,MH4,MH6,MH8,MH10,MH12,MH14
      REAL*8 MZ,MZ2,MZ4,MZ6,MZ8
      REAL*8 MW,MW2,MW4,MW6,MW8
      REAL*8 ME,ME2,ME4,ME6,ME8
      REAL*8 MN,MP,MP2
      REAL*8 MB,MT,MZW2I
      DOUBLE COMPLEX  SREN1,S1ZWF,S2ZWF,S3ZWF,S4ZWF,S5ZWF,
     1                GREN1,G1ZWF,G2ZWF,G3ZWF,G4ZWF,G5ZWF,
     1                S1GWF,S2GWF,S3GWF,S4GWF,S5GWF
      DOUBLE COMPLEX  FHR1,FHR2,FH3N,FHR4,FHR5
      DOUBLE COMPLEX  GHR1,GHR2,GH3N,GHR4,GHR5
      DOUBLE COMPLEX  DMZ2,ZVZ,ZZPU1,DMZG,OMZG,ZGPU1,ZVG,GGPU1,DMW2,ZVW,
     1                DE1
      DOUBLE COMPLEX FS01 ,FS02 ,FS03 ,FS04 ,FT01,FF5,
     X               FS01P,FS02P,FS03P,FS04P,     FF5P
      COMMON /OVR/ ME,MP,MW,MZ,MN,
     1             ME2,ME4,ME6,ME8,MP2,MW2,MW4,MW6,MW8,MZ2,MZ4,MZ6,MZ8,
     1             MH2,MH4,MH6,MH8,MH10,MH12,MH14,
     1             RE2,RE4,RE6,RE8,RP2,RW2,RW4,RW6,RW8,RMZ2,RZ4,RZ6,RZ8,
     1             RH2,SI2,SI2I,AC,AW2,AW3,A20,A40,QE2,EE,XI,
     1             E,PP,QQ,EW,T,U,S5R,S6R,S7R,R11,R21,R31,R41,R51,R61
     1            ,R12,R22,R32,R42,R52,R62,AME5,AME6,AME7,AMZ5,AMZ6,AMP6
     1            ,AMZ7,P1DP2,P1DP3,P1DP4,P2DP3,P2DP4,P3DP4,
     1             XMH2,XMZ2,XMW2,XME1,XE1,XVI1
      COMMON /KIN/ S1,S2,S3,S4,S5,S6,S7
      COMMON /AMF/ SREN1,S1ZWF,S2ZWF,S3ZWF,S4ZWF,S5ZWF,
     1             GREN1,G1ZWF,G2ZWF,G3ZWF,G4ZWF,G5ZWF,
     1                   S1GWF,S2GWF,S3GWF,S4GWF,S5GWF
      COMMON /RNS/ DMZ2,ZVZ,ZZPU1,DMZG,OMZG,ZGPU1,ZVG,GGPU1,DMW2,ZVW,DE1
     1            ,DQI1
      COMMON /FHL/ FHR1,FHR2,FH3N,FHR4,FHR5
      COMMON /GHL/ GHR1,GHR2,GH3N,GHR4,GHR5
      COMMON /FER/ BC,MZW2I
      COMMON /ANO/ AXY,CFD,CFC,CFR,CTB,CTF,CFF,CSF
Cte
C      COMMON /ANO/ AXY,CFD,CFC1,CFR,CTB,CTF,CFF,CSF
C      CFC=0.D0
C      ifer=0
Cte
C
      FERMI=(0.D0,0.D0)
C
      ENTRY FS01(MB,MT,QB,QT)
       SREN1=-S6**(-2)*QE2**2*GGPU1
     1 +AMZ6*(-2.D0*QE2*ZGPU1*AC+2.D0*QE2*ZGPU1*RMZ2*MW2
     1 -4.D0*DMW2*AC*MZW2I*MW4+4.D0*DMW2*RMZ2*MW4+4.D0*DMZ2*AC*MZW2I*MW4
     1 -4.D0*DMZ2*RMZ2*MW4+8.D0*AC*DE1*MW2+4.D0*AC*ZVW*MW4)
     1 +AMZ6**2*(-4.D0*DMZ2*AC*MZ2*MW2+4.D0*AC*ZZPU1*MZ2*MW2)
     1 +AMP6*(2.D0*QE2*ZGPU1*AC-2.D0*QE2*ZGPU1*RMZ2*MW2-2.D0*QE2*DE1
     1 -QE2*ZVW*MW2+4.D0*QE2*DMZG*RMZ2*MW2)
       S1ZWF=+AMZ6*(-2.D0*AC*FHR1*MZ2*MW2)
       S1GWF=+AMP6*(1.D0/2.D0*QE2*GHR1*MW2)
       GREN1=
     1 +AMZ6*(2.D0*QE2*ZGPU1*BC+4.D0*DMW2*BC*MZW2I*MW4-4.D0*DM
     1 Z2*BC*MZW2I*MW4-8.D0*DE1*BC*MW2-4.D0*ZVW*BC*MW4)
     1 +AMZ6**2*(4.D0*DMZ2*BC*MZ2*MW2-4.D0*ZZPU1*BC*MZ2*MW2)
     1 +AMP6*(-2.D0*QE2*ZGPU1*BC)
       G1ZWF=+AMZ6*(2.D0*BC*FHR1*MZ2*MW2)
Cte
C      ifer=ifer+1
C      ifer=mod(ifer,3)
C      IF (ifer.eq.0) THEN
C       CFC=CFC1
C      ELSE 
C       CFC=0.D0
C      ENDIF
C      write(9,*) ' (mb,mt): ',mb,mt
C      write(9,*) ' '
Cte
      S1ZWF=CFC*S1ZWF
      S1GWF=CFC*S1GWF
      G1ZWF=CFC*G1ZWF
      SREN1=CFR*SREN1
      GREN1=CFR*GREN1
      FERMI=SREN1+S1ZWF+S1GWF+GREN1+G1ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      FERMU=SREN1            +GREN1
C      FERMU=FERMU*A40
C      FERMU=-FERMU
C      write(9,*) ' FS01R=',FERMU
C      FERMT=      S2ZWF+S2GWF      +G2ZWF
C      FERMT=FERMT*A40
C      FERMT=-FERMT
C      write(9,*) ' FS01 =',FERMT
Cte
      RETURN
C
      ENTRY FS02(MB,MT,QB,QT)
       S2ZWF=+AMZ6*(2.D0*AC*FHR2*MZ2)
       S2GWF=+AMP6*(-1.D0/2.D0*QE2*GHR2)
       G2ZWF=+AMZ6*(-2.D0*BC*FHR2*MZ2)
      S2ZWF=CFC*S2ZWF
      S2GWF=CFC*S2GWF
      G2ZWF=CFC*G2ZWF
      FERMI=      S2ZWF+S2GWF      +G2ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS02 =',FERMI
Cte
      RETURN
C
      ENTRY FS03(MB,MT,QB,QT)
       S3ZWF=+AMZ6*(-2.D0*AC*FH3N*MZ2*MW2)
       S3GWF=+AMP6*(1.D0/2.D0*QE2*GH3N*MW2)
       G3ZWF=+AMZ6*(2.D0*BC*FH3N*MZ2*MW2)
      S3ZWF=CFC*S3ZWF
      S3GWF=CFC*S3GWF
      G3ZWF=CFC*G3ZWF
      FERMI=      S3ZWF+S3GWF      +G3ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS03 =',FERMI
Cte
      RETURN
C
      ENTRY FS04(MB,MT,QB,QT)
       S4ZWF=+AMZ6*(-2.D0*AC*FHR4*MZ2*MW2)
       S4GWF=+AMP6*(1.D0/2.D0*QE2*GHR4*MW2)
       G4ZWF=+AMZ6*(2.D0*BC*FHR4*MZ2*MW2)
      S4ZWF=CFC*S4ZWF
      S4GWF=CFC*S4GWF
      G4ZWF=CFC*G4ZWF
      FERMI=      S4ZWF+S4GWF      +G4ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS04 =',FERMI
Cte
      RETURN
C
      ENTRY FS01P(MB,MT,QB,QT)
      FERMI=SREN1+S1ZWF+S1GWF-GREN1-G1ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS01P=',FERMI
Cte
      RETURN
C
      ENTRY FS02P(MB,MT,QB,QT)
      FERMI=      S2ZWF+S2GWF      -G2ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS02P=',FERMI
Cte
      RETURN
C
      ENTRY FS03P(MB,MT,QB,QT)
      FERMI=      S3ZWF+S3GWF      -G3ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS03P=',FERMI
Cte
      RETURN
C
      ENTRY FS04P(MB,MT,QB,QT)
      FERMI=      S4ZWF+S4GWF      -G4ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FS04P=',FERMI
Cte
      RETURN
C
      ENTRY FT01(MB,MT,QB,QT)
      FERMI=-2.D0*MW2/S5*(-DMW2+2.D0*DQI1+MW2*ZVW)
      FERMI=CFR*FERMI*A40
Cte
C      write(9,*) ' FT01 =',FERMI
Cte
C
      RETURN
C
      ENTRY FF5(MB,MT,QB,QT)
       S5ZWF=+AMZ6*(-2.D0*AC*FHR5*MZ2*MW2)
       S5GWF=+AMP6*(1.D0/2.D0*QE2*GHR5*MW2)+0.
       G5ZWF=+AMZ6*(2.D0*BC*FHR5*MZ2*MW2)+0.
      S5ZWF=CFC*S5ZWF
      S5GWF=CFC*S5GWF
      G5ZWF=CFC*G5ZWF
      FERMI=      S5ZWF+S5GWF      +G5ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FF5  =',FERMI
Cte
      RETURN
C
      ENTRY FF5P(MB,MT,QB,QT)
      FERMI=      S5ZWF+S5GWF      -G5ZWF
      FERMI=FERMI*A40
      FERMI=-FERMI
Cte
C      write(9,*) ' FF5P =',FERMI
Cte
      RETURN
C
      END
*###[ getpol:
	subroutine getpol
***#[*comment:***********************************************************
*									*
*	determine the polarizations to sum over from the string giving	*
*	the polarization of electron, W- and W+.			*
*									*
*	Input:								*
*									*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	common blocks
*
	CHARACTER*11 POLE
	COMMON/POLINI/POLE
	CHARACTER*12 POLWM,POLWP,polwmi,polwpi
	COMMON/POLFIN/POLWM,POLWP,polwmi,polwpi
	integer LS1,LS2,IAVER
	COMMON/POLELE/LS1,LS2,IAVER
	integer LM1,LM2,LMSTEP
	COMMON/POLWMI/LM1,LM2,LMSTEP
	integer LP1,LP2,LPSTEP
	COMMON/POLWPL/LP1,LP2,LPSTEP
*
*  #] declarations:
*  #[ sort out e:
*
	IF(POLE.EQ.'UNPOLARIZED' .or. pole.eq.'POLARIZED')THEN
	    LS1=-1
	    LS2=1
	    IAVER=4
	ELSE IF(POLE.EQ.'LEFTHANDED')THEN
	    LS1=-1
	    LS2=-1
	    IAVER=2
	ELSE if ( pole.eq.'RIGHTHANDED' ) then
	    LS1=1
	    LS2=1
	    IAVER=2
	else
	    print *,'getpol: error: unknown pol. for e-: ',pole
	    stop
	END IF
*
*  #] sort out e:
*  #[ sort out W-:
*
	IF(POLWM.EQ.'UNPOLARIZED')THEN
	    LM1=1
	    LM2=3
	    LMSTEP=1
	ELSE IF(POLWM.EQ.'LONGITUDINAL')THEN
	    LM1=3
	    LM2=3
	    LMSTEP=1
	ELSE IF(POLWM.EQ.'TRANSVERSE' .or. POLWM.eq.'+ TRANSVERSE' .or. 
     +		POLWM.eq.'- TRANSVERSE' )THEN
	    LM1=1
	    LM2=2
	    LMSTEP=1
	ELSE IF(POLWM.EQ.'X TRANSVERSE')THEN
	    LM1=1
	    LM2=1
	    LMSTEP=1
	ELSE IF(POLWM.EQ.'Y TRANSVERSE')THEN
	    LM1=2
	    LM2=2
	    LMSTEP=1
	else
	    print *,'getpol: error: unknown pol. for W-:',polwm
	    stop
	END IF
*
*  #] sort out W-:
*  #[ sort out W+:
*
	IF(POLWP.EQ.'UNPOLARIZED')THEN
	    LP1=1
	    LP2=3
	    LPSTEP=1
	ELSE IF(POLWP.EQ.'LONGITUDINAL')THEN
	    LP1=3
	    LP2=3
	    LPSTEP=1
	ELSE IF(POLWP.EQ.'TRANSVERSE' .or. POLWP.eq.'+ TRANSVERSE' .or. 
     +		POLWP.eq.'- TRANSVERSE' )THEN
	    LP1=1
	    LP2=2
	    LPSTEP=1
	ELSE IF(POLWP.EQ.'X TRANSVERSE')THEN
	    LP1=1
	    LP2=1
	    LPSTEP=1
	ELSE IF(POLWP.EQ.'Y TRANSVERSE')THEN
	    LP1=2
	    LP2=2
	    LPSTEP=1
	else
	    print *,'getpol: error: unknown pol. for W+:',polwp
	    stop
	END IF
*
*  #] sort out W+:
*###] getpol:
	end
      SUBROUTINE OffIni
!     *****************
! Initialization of ff package.
! Written by: Wieslaw Placzek,   Sept. 19, 1996
!-----------------------------------------------
      include 'aa.h'
      include 'ff.h'
!
      CALL ffinit
      atest = .FALSE.
      ltest = .FALSE.
      lwarn = .FALSE.
      lmem  = .TRUE.
      END

* file aaxbx.for  16-jul-1990

*###[ aaxbx :
	subroutine aaxbx(caxi,cbxi,acbxi,d0,xmu,xp,xma,xmb,level,ier)
*###[ comment:***********************************************************
*									*
*	Calculation of formfactors resulting  from decself.sub		*
*	or decself.frm (at the moment up to second rank tensor)		*
*	11-jun-1993: changed to use my ffxb1, ffxdb0 routines  GJ	*
*									*
*	Input:	xp,xma,xmb	the same as in Geert Jan's routines	*
*		level		rank of tensor(integral)		*
*	Output:								*
*		caxi(2)		ca0i					*
*		cbxi(4)		cb0,cb11,cb21,cb22			*
*		acbxi(2)	acbxi(1),acb11 (derivatives)		*
*									*
*###] comment:***********************************************************
*###[ declarations :
	implicit none
*
*	arguments
*
	integer ier,level
	DOUBLE PRECISION xp,xma,xmb,d0,xmu
	DOUBLE COMPLEX caxi(2),cbxi(4),acbxi(2)
*
*	local variables
*
	integer i,ier0,ier1
	DOUBLE COMPLEX cb2i(2),acb0p
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*	initialization
*
	do 10 i=1,2
	    caxi(i)=0
   10	continue
	do 11 i=1,4
	    cbxi(i)=0
   11	continue
	do 12 i=1,2
	    acbxi(i)=0
   12	continue
*###] declarations :
*###[ level 0 : B0
*	B0-function
	ldot = .TRUE.
	ier1 = ier
	call ffxb0(cbxi(1),d0,xmu,xp,xma,xmb,ier1)
	if ( awrite ) then
	    print *,'   '
	    print *,'aaxbx : level 0'
	    print *,'B0 =',cbxi(1)
	endif
	if (level .eq. 0  .and. .NOT. aderiv ) goto 990
*###] level 0 :
*###[ level 1 : B11,A0(I) and derivatives AB0,AB11
*		need 2 diff A0(I)-functions
	ier0 = ier
	call ffxa0( caxi(1),d0,xmu,xma,ier0)
	ier1 = max(ier1,ier0)
	ier0 = ier
	call ffxa0( caxi(2),d0,xmu,xmb,ier0)
	ier1 = max(ier1,ier0)
	if (aderiv) then
	    ier0 = ier
	    call ffxdb0(acbxi(1),acb0p,xp,xma,xmb,ier0)
	    ier1 = max(ier1,ier0)
	    if ( atest ) then
		if ( abs(xp*acbxi(1)-acb0p) .gt. precc*abs(acb0p) )
     +		    print *,'aaxbx: error: B0'' not consistent: ',
     +		    xp*acbxi(1),acb0p,xp*acbxi(1)-acb0p,ier0
	    endif
	    if ( awrite ) then
		print *,'AB0 =',acbxi(1)
	    endif
	endif

	if ( level .eq. 0 ) return
*###[ calculation of B11:
	ier = ier1
	call ffxb1(cbxi(2),cbxi(1),caxi,xp,xma,xmb,fpij2,ier1)
*###] calculation of B11:
	if ( awrite ) then
	    print *,'	   '
	    print *,'aaxbx : level 1 '
	    print *,'B11 = ',cbxi(2)
	    print *,'  A0(1) =',caxi(1)
	    print *,'  A0(2) =',caxi(2)
	    print *,'AB0 = ',acbxi(1)
	    print *,'AB11= not yet implemented'
	endif

	if (level .eq. 1  ) goto 990

*###] level 1 :
*###[ level 2 : B21,B22
*		calculate B21 either on the basis of B11 or make
*		first the  complete analytical reduction to B0,A0
	call ffxb2p(cb2i,cbxi(2),cbxi(1),caxi,xp,xma,xmb,fpij2,ier1)

	cbxi(3)=cb2i(1)
	cbxi(4)=cb2i(2)
	if ( awrite ) then
	    print *,' '
	    print *,'aaxbx : level 2 '
	    print *,'B21 = ',cb2i(1)
	    print *,'B22 = ',cb2i(2)
	endif

	if (level .eq. 2) goto 990

*###] level 2 :
	print *,'aaxbx: error: level ',level,' not supported'
	stop

  990	continue
	ier = max(ier1,ier)
*###] aaxbx :
	end

* file aaxcx.for  18-jun-1990, 8-nov-1993 GJ

*###[ aaxcx :
	subroutine aaxcx(caxi,cbxi,ccxi,d0,xmm,xpi,level,ier)
***#[*comment:***********************************************************
*									*
*	Calculation of formfactors resulting from decvert.sub		*
*	or decvert.frm							*
*	(up to third rank)						*
*									*
*	Input:								*
*		xpi	  the same as in Geert Jan's routines		*
*		level	  rank of tensor(integral)			*
*	Output: 							*
*		caxi(3)  : ca0i 		     i=1,2,3		*
*		cbxi(12) : cb0i,cb11i,cb21i,cb22i    i=1,2,3		*
*		ccxi(13) : cc0,cc1(2),cc2(4),cc3(6)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations :
	implicit none
*
*	arguments
*
	integer ier,level
	DOUBLE PRECISION xpi(6),d0,xmm
	DOUBLE COMPLEX caxi(3),cbxi(12),ccxi(13)
*
*	local variables
*
	integer i,bl,ier0,ier1
	DOUBLE COMPLEX cb0i(3),acbxi(2),ca0i(6)
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*  #] declarations :
*  #[ initialisations:
*
*	initialization
*
	do 9 i=1,3
	    caxi(i)=0
    9	continue
	do 10 i=1,12
	    cbxi(i)=0
   10	continue
	do 11 i=1,13
	    ccxi(i)=0
   11	continue
*
*  #] initialisations:
*  #[ get C0:
*	C0-function
*	   futhermore dotpr and determinants are delivered by ff
	ldot=.TRUE.
	ier1 = ier
	call ffxc0(ccxi(1),xpi,ier1)
	if ( ier1.gt.10 ) then
	    if ( ltest ) then
		print *,'aaxcx: id = ',id,', nevent = ',nevent
		print *,'aaxcx: lost ',ier1,' digits in C0 with isgnal '
     +			,isgnal,', trying other roots, isgnal ',-isgnal
		print *,'       if OK (no further messages) adding this'
     +			,' to your code will improve speed'
	    endif
	    isgnal = -isgnal
	    ier1 = ier
	    call ffxc0(ccxi(1),xpi,ier1)
	    isgnal = -isgnal
	endif
	if ( ier1 .gt. 10 ) then
	    print *,'aaxcx: id = ',id,', nevent = ',nevent
	    print *,'aaxcx: error: C0 not stable, lost ',ier1,' digits'
	    print *,'       please contact author (t19@nikhef.nl)'
	    print *,'xpi = ',xpi
	endif
	if ( awrite ) then
*	 #[ for debugging: imported stuff from ff
	    print *,' '
	    print *,'aaxcx : level 0 '
	    print *,'C0 =',ccxi(1)
	    print *,'used:',( xpi(i),i=1,3 )
	    print *,'     ',( xpi(i),i=4,6 )
	    print *,'imported stuff via ff.h:'
	    print *,'kin det = ',fdel2
	    print *,'dotpr1,1= ',fpij3(4,4)
	    print *,'dotpr2,2= ',fpij3(5,5)
	    print *,'dotpr1,2= ',fpij3(4,5)
*	 #] for debugging:
	endif

	if (level .eq. 0) goto 990
*
*  #] get C0:
*  #[ need B-functions till b-level=(level-1):
	bl=level-1
	if ( awrite ) then
	    print *,'  '
	    print *,'----->underlying A,B-functions up to level:',bl
	endif
	aderiv = .FALSE.
	ier0 = ier
	call aaxbx( ca0i(1),cbxi(1),acbxi,d0,xmm,xpi(5),xpi(2),xpi(3),
     +								bl,ier0)
	ier1 = max(ier1,ier0)
	ier0 = ier
	call aaxbx( ca0i(3),cbxi(5),acbxi,d0,xmm,xpi(6),xpi(1),xpi(3),
     +								bl,ier0)
	ier1 = max(ier1,ier0)
	ier0 = ier
	call aaxbx( ca0i(5),cbxi(9),acbxi,d0,xmm,xpi(4),xpi(1),xpi(2),
     +								bl,ier0)
	ier1 = max(ier1,ier0)
	if ( awrite ) then
	    print *,'  '
	    print *,'----->end of A,B-function output-------------'
	endif
*		symmetry in A0(i,j)
	caxi(1)=ca0i(1)
	caxi(2)=ca0i(2)
	caxi(3)=ca0i(3)
	if ( atest ) then
	    if ((ca0i(4)-ca0i(2)) .ne. 0. .or.
     +		(ca0i(5)-ca0i(3)) .ne. 0. .or.
     +		(ca0i(6)-ca0i(1)) .ne. 0. ) then
		print *,'error in A0-calculations in aaxbi.for'
		goto 990
	    endif
	endif
*  #] need B-functions till b-level=(level-1):
*  #[ call aaxcxp:
	call aaxcxp(cbxi,ccxi,xpi,level,ier1)
  990	continue
	ier = ier1
*  #] call aaxcxp:
*###] aaxcx :
	end
*###[ aaxcxp:
	subroutine aaxcxp(cbxi,ccxi,xpi,level,ier)
***#[*comment:***********************************************************
*									*
*	The part of aaxcx that can also be used by aazcz		*
*									*
*									*
***#]*comment:***********************************************************
*  #[ declarations :
	implicit none
*
*	arguments
*
	integer ier,level
	DOUBLE PRECISION xpi(6),d0,xmm
	DOUBLE COMPLEX cbxi(12),ccxi(13)
*
*	local variables
*
	integer i,j,ier1,ier2
	DOUBLE PRECISION xi3(3),f1,f2,absc
	DOUBLE COMPLEX R1,R2,R3,R4,R5,R6,R11,R12,R13,R14,R15,R16,R17,
     +		R18,cb0i(3),cb11i(3),cb21i(3),cb22i(3),cc,cxy(2)
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations :
*  #[ kinematical quatities for 3pv-red :
	ier1 = ier
***	if (abs(fdel2)	.lt. .1d-5 ) then
***	      print *,'kinematical det = 0, PV-scheme breaks down'
***	      print *,'det=',fdel2
***	      goto 990
***	endif
*	       inverse kinematical matrix xi3  (2X2)
	ier2 = ier
	call aaxi3(xi3,ier2)
*
*	       f-functions:
***	f1=xpi(2)-xpi(1)-fpij3(4,4)
***	print *,'f1 was ',f1
	f1 = 2*fpij3(1,4)
***	print *,'f1 is  ',f1
***	f2=xpi(3)-xpi(2)-2.d0*fpij3(4,5)-fpij3(5,5)
***	print *,'f2 was ',f2
	f2 = 2*fpij3(1,5)
***	print *,'f2 is  ',f2
*  #] kinematical quatities for 3pv-red :
*  #[ level 1 : C11,C12,B0(I)
*		need 3 diff B0(I)-functions,I=1,2,3
	cb0i(1)=cbxi(1)
	cb0i(2)=cbxi(5)
	cb0i(3)=cbxi(9)
*		PV-reduction
	R1=( f1*ccxi(1)+cb0i(2)-cb0i(1) )/2
	R2=( f2*ccxi(1)+cb0i(3)-cb0i(2) )/2
	ccxi(2)=xi3(1)*R1+xi3(3)*R2
	ccxi(3)=xi3(3)*R1+xi3(2)*R2
	if (awrite) then
	    print *,'	   '
	    print *,'aaxcx : level 1 :'
	    print *,'C11=',ccxi(2)
	    print *,'C12=',ccxi(3)
	endif
*	       check with ffroutine
	if ( atest ) then
*	    call ffxc1(ccxi(2),ccxi(1),cb0i,xpi,fpij3(1,1),fdel2,ier)
	    if ( awrite ) then
		print *,'GEERT JANs-scheme:'
		print *,'C11=',ccxi(2)
		print *,'C12=',ccxi(3)
		print *,'     '
	    endif
	endif
*
	if (level .eq. 1) goto 990
*
*  #] level 1 :
*  #[ level 2 : C21,C22,C23,C24,B11(I),A0(I,J)
*		need 3 diff B1-functions and 3 diff A0-fuctions
	do 12 i=1,3
	j=(i+1)+(i-1)*3
 12	cb11i(i)=cbxi(j)
*		PV-reduction
	ccxi(7)=1/4.d0 + 1/2.d0*xpi(1)*ccxi(1) -
     +		  1/4.d0*( f1*ccxi(2)+f2*ccxi(3)-cb0i(1)  )
	R3=( f1*ccxi(2) + cb11i(2) + cb0i(1)  )/2 - ccxi(7)
	R4=( f2*ccxi(2) + cb11i(3) - cb11i(2) )/2
	R5=( f1*ccxi(3) + cb11i(2) - cb11i(1) )/2
	R6=( f2*ccxi(3)            - cb11i(2) )/2 - ccxi(7)
	ccxi(4)=xi3(1)*R3 + xi3(3)*R4
	ccxi(5)=xi3(3)*R5 + xi3(2)*R6
	ccxi(6)=xi3(3)*R3 + xi3(2)*R4
	if ( atest ) then
	    cxy(1)=xi3(1)*R5 + xi3(3)*R6
	    if ( absc(cxy(1)-ccxi(6)) .gt. .1d-4 ) then
		print *,'redundancy check at level 2 failed'
		goto 990
	    endif
	endif
	if ( awrite ) then
	    print *,'	   '
	    print *,'aaxcx : level 2 '
	    print *,'C21=',ccxi(4)
	    print *,'C22=',ccxi(5)
	    print *,'C23=',ccxi(6)
	    print *,'C24=',ccxi(7)
	endif

	if (level .eq. 2) goto 990

*  #] level 2 :
*  #[ level 3 : C31,C32,C33,C34,C35,C36,B21(I),B22(I)
	do 13 i=1,3
	j=(i+1)+(i-1)*3
	cb21i(i)=cbxi(j+1)
 13	cb22i(i)=cbxi(j+2)
*		PV-reduction
	R17=( f1*ccxi(7)+cb22i(2)-cb22i(1) )/2
	R18=( f2*ccxi(7)+cb22i(3)-cb22i(2) )/2
	ccxi(12)=xi3(1)*R17+xi3(3)*R18
	ccxi(13)=xi3(3)*R17+xi3(2)*R18
	R11=( f1*ccxi(4)+cb21i(2)-cb0i(1)  )/2 - 2*ccxi(12)
	R12=( f2*ccxi(4)+cb21i(3)-cb21i(2) )/2
	R13=( f1*ccxi(5)+cb21i(2)-cb21i(1) )/2
	R14=( f2*ccxi(5)         -cb21i(2) )/2 - 2*ccxi(13)
	R15=( f1*ccxi(6)+cb21i(2)+cb11i(1) )/2 - ccxi(13)
	R16=( f2*ccxi(6)         -cb21i(2) )/2 - ccxi(12)
	ccxi(8) =xi3(1)*R11 + xi3(3)*R12
	ccxi(9) =xi3(3)*R13 + xi3(2)*R14
	ccxi(10)=xi3(3)*R11 + xi3(2)*R12
	ccxi(11)=xi3(1)*R13 + xi3(3)*R14
*	redundancy check
	if ( atest ) then
	    cxy(1)=xi3(1)*R15 + xi3(3)*R16
	    cxy(2)=xi3(3)*R15 + xi3(2)*R16
	    if ( absc(cxy(1)-ccxi(10)) .gt. .1d-3   .or.
     +		 absc(cxy(2)-ccxi(11)) .gt. .1d-3	   ) then
		print *,'redundancy check at level 3 failed'
		goto 990
	    endif
	endif
	if ( awrite ) then
	    print *,'	   '
	    print *,'aaxcx : level 3 '
	    print *,'C31=',ccxi(8)
	    print *,'C32=',ccxi(9)
	    print *,'C33=',ccxi(10)
	    print *,'C34=',ccxi(11)
	    print *,'C35=',ccxi(12)
	    print *,'C36=',ccxi(13)
	endif

	if (level .eq. 3) goto 990

*  #] level 3 :
*  #[ end:
	print *,'aaxcx: level ',level,' not supported.'
	stop
  990	continue
	ier = ier1 + (ier2-ier)
*  #] end:
*###] aaxcxp:
	end

* file aaxdx.for  25-jun-1990, 8-nov-1993 GJ

*###[ aaxdx :
	subroutine aaxdx(cbxi,ccxi,cdxi,d0,xmm,xpi,level,ier)
***#[*comment:***********************************************************
*									*
*	Calculation of formfactors resulting from  decbox.sub		*
*	or decbox.frm							*
*	( up to 3.rank tensor )						*
*									*
*	Input:								*
*		xpi	  the same as in Geert Jan's routines		*
*		level	  rank of tensor(integral)			*
*	Output: 							*
*		cbxi(12)  cb0(1),cb1(1),[cb2(2)]	 x 6		*
*		ccxi(28)  cc0(1),cc1(2),cc2(4),[cc3(6)]  x 4		*
*		cdxi(24)  cd0(1),cd1(3),cd2(7),cd3(13)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations :
	implicit none
*
*	arguments
*
	integer ier,level
	DOUBLE PRECISION xpi(13),d0,xmm
	DOUBLE COMPLEX cbxi(12),ccxi(28),cdxi(24)
*
*	local variables
*
	integer i,j,cl,ier0,ier1,iinx(6,4)
	DOUBLE PRECISION xpi3(6),fdel2i(4)
	DOUBLE COMPLEX caxj(12),cbxj(48),ccxj(52)
	save iinx
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*	data
*
	data iinx /2,3,4,6,7,10,
     +		   1,3,4,9,7,8,
     +		   1,2,4,5,10,8,
     +		   1,2,3,5,6,9/
*
*  #] declarations :
*  #[ initialisations:
*
*	initialization
*
	do 9 i=1,12
	    cbxi(i)=0
    9	continue
	do 10 i=1,28
	    ccxi(i)=0
   10	continue
	do 11 i=1,24
	    cdxi(i)=0
   11	continue
*
*  #] initialisations:
*  #[ get D0:
*	D0-function (ff)
*	   futhermore dotpr and determinants are delivered by ff
	ldot = .TRUE.
	ier1 = ier
	call ffxd0(cdxi(1),xpi,ier1)
	if ( ier1.gt.10 ) then
	    if ( ltest ) then
		print *,'aaxdx: id = ',id,', nevent = ',nevent
		print *,'aaxdx: lost ',ier1,' digits in D0 with isgnal '
     +			,isgnal,', trying other roots, isgnal ',-isgnal
		print *,'       if OK (no further messages) adding this'
     +			,' to your code will improve speed'
	    endif
	    isgnal = -isgnal
	    ier1 = ier
	    call ffxd0(cdxi(1),xpi,ier1)
	    isgnal = -isgnal
	endif
	if ( awrite ) then
	    print *,'    '
	    print *,'aaxdx : level 0 '
	    print *,'D0 =',cdxi(1)
	endif
	if ( ier1 .gt. 10 ) then
	    print *,'aaxdx: id = ',id,', nevent = ',nevent
	    print *,'aaxdx: error: D0 not stable, lost ',ier1,' digits'
	    print *,'       please try another permutation or contact ',
     +	    	'author (t19@nikhef.nl)'
	    print *,'xpi = ',xpi
	endif
*
	if (level .eq. 0) goto 990
*
*  #] get D0:
*  #[ need C-functions till c-level=(level-1):
	if (level .gt. 3) then
	    print *,'higher than third rank not yet implemented'
	    goto 990
	endif
	cl=level-1
*	go trough the 4 different cancellation patterns
	if ( awrite ) then
	   print *,'	 '
	   print *,'------>underlying C-functions up to level:',cl
	endif
	do 100 i=1,4
	    do 60 j=1,6
		xpi3(j) = xpi(iinx(j,i))
   60	    continue
	    ier0 = ier
	    call aaxcx( caxj(3*i-2),cbxj(12*i-11),ccxj(13*i-12),
     +		d0,xmm,xpi3,cl,ier0)
	    ier1 = max(ier1,ier0)
*		only used for comparision with Geert Jans routines
	    fdel2i(i)=fdel2
  100	continue
*  #[ old code:
***	go trough the 4 different cancellation patterns
*	if ( awrite ) then
*	   print *,'	 '
*	   print *,'------>underlying C-functions up to level:',cl
*	endif
***	C(1)=C(p2,p3,m2,m3,m4)
*	xpj(1)=xpi(2)
*	xpj(2)=xpi(3)
*	xpj(3)=xpi(4)
*	xpj(4)=xpi(6)
*	xpj(5)=xpi(7)
*	xpj(6)=xpi(10)
*	ier0 = ier
*	call aaxcx( caxj(1),cbxj(1),ccxj(1),d0,xmm,xpj,cl,ier0)
*	ier1 = max(ier1,ier0)
***	    only used for comparision with Geert Jans routines
*	fdel2i(1)=fdel2
***	C(2)=C(p1+p2,p3,m1,m3,m4)
*	xpj(1)=xpi(1)
*	xpj(2)=xpi(3)
*	xpj(3)=xpi(4)
*	xpj(4)=xpi(9)
*	xpj(5)=xpi(7)
*	xpj(6)=xpi(8)
*	ier0 = ier
*	call aaxcx( caxj(4),cbxj(13),ccxj(14),d0,xmm,xpj,cl,ier)
*	ier1 = max(ier1,ier0)
***	    only used for comparision with Geert Jans routines
*	fdel2i(2)=fdel2
***	C(3)=C(p1,p2+p3,m1,m2,m4)
*	xpj(1)=xpi(1)
*	xpj(2)=xpi(2)
*	xpj(3)=xpi(4)
*	xpj(4)=xpi(5)
*	xpj(5)=xpi(10)
*	xpj(6)=xpi(8)
*	ier0 = ier
*	call aaxcx( caxj(7),cbxj(25),ccxj(27),d0,xmm,xpj,cl,ier)
*	ier1 = max(ier1,ier0)
***	    only used for comparision with Geert Jans routines
*	fdel2i(3)=fdel2
***	C(4)=C(p1,p2,m1,m2,m3)
*	xpj(1)=xpi(1)
*	xpj(2)=xpi(2)
*	xpj(3)=xpi(3)
*	xpj(4)=xpi(5)
*	xpj(5)=xpi(6)
*	xpj(6)=xpi(9)
*	ier0 = ier
*	call aaxcx( caxj(10),cbxj(37),ccxj(40),d0,xmm,xpj,cl,ier)
*	ier1 = max(ier1,ier0)
***	    only used for comparision with Geert Jans routines
*	fdel2i(4)=fdel2
*  #] old code:
	if ( awrite ) then
	    print *,'	 '
	    print *,'---->end of C-function output--------------------'
	endif
*  #] need C-functions till c-level=(level-1):
*  #[ call aaxdxp:
	call aaxdxp(cbxi,ccxi,cdxi,caxj,cbxj,ccxj,xpi,fdel2i,level,
     +		ier1)
  990	continue
	ier = ier1
*  #] call aaxdxp:
*###] aaxdx :
	end
*###[ aaxdxp :
	subroutine aaxdxp(cbxi,ccxi,cdxi,caxj,cbxj,ccxj,xpi,fdel2i,
     +		level,ier)
***#[*comment:***********************************************************
*									*
*	the part that is common to aaxdx and aazdz.			*
*									*
*									*
***#]*comment:***********************************************************
*  #[ declarations :
	implicit none
*
*	arguments
*
	integer ier,level
	DOUBLE PRECISION xpi(13),fdel2i(4)
	DOUBLE COMPLEX cbxi(12),ccxi(28),cdxi(24),caxj(12),cbxj(48),
     +		ccxj(52)
*
*	local variables
*
	integer i,j,k,ier0,ier1,ier2
	DOUBLE PRECISION xi4(6),f1,f2,f3,absc
	DOUBLE COMPLEX R20,R21,R22,R30,R31,R32,R33,R34,R35,R36,R37,R38,
     +		R41,R42,R43,R44,R45,R46,R47,R48,R49,R50,R51,R52,R53,R54,
     +		R55,cd1i(3),cc0i(4),cc11i(4),cc12i(4),
     +		cc21i(4),cc22i(4),cc23i(4),cc24i(4),cc,cxy(3)
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*	statement functions
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations :
*  #[ kinematical quatities for 4pv-red :
	ier1 = ier
*	if ( abs(fdel3)  .lt. 1.d-6 ) then
*	    print *,'kinematical det = 0, PV-scheme breaks down'
*	    print *,fdel3
*	    goto 990
*	endif
*	    inverse kinematical matrix xi4  (3X3)

	ier2 = ier
	call aaxi4(xi4,ier2)
*
*	    f-functions:
***	f1=(xpi(2)-xpi(1))-fpij4(5,5)
***	print *,'f1 was : ',f1
	f1 = 2*fpij4(1,5)
***	print *,'f1 is  : ',f1
***	f2=(xpi(3)-xpi(2))-2*fpij4(5,6)-fpij4(6,6)
***	print *,'f2 was : ',f2
	f2 = 2*fpij4(1,6)
***	print *,'f2 is  : ',f2
***	f3=(xpi(4)-xpi(3))-2*fpij4(5,7)-2*fpij4(6,7)-fpij4(7,7)
***	print *,'f3 was : ',f3
	f3 = 2*fpij4(1,7)
***	print *,'f3 is  : ',f3
*
*  #] kinematical quatities for 4pv-red :
*  #[ level 0 :
*	output preparation
*	   1)C-output: reduce the array ccxj(4*13) to ccxi(4*7)
*		       c's are calculated only to (level-1)
	do 130 j=1,4
	    do 131 i=1,7
		ccxi(i+(j-1)*7)=ccxj(i+(j-1)*13)
 131	    continue
 130	continue
*	   2)B-output: reduce the array cbxj(12*4) to cbxi(6*2)
*		       b's are calculated only to (level-2)
	cbxi(1) = cbxj(1)
	cbxi(2) = cbxj(2)
	cbxi(3) = cbxj(5)
	cbxi(4) = cbxj(6)
	cbxi(5) = cbxj(9)
	cbxi(6) = cbxj(10)
	cbxi(7) = cbxj(17)
	cbxi(8) = cbxj(18)
	cbxi(9) = cbxj(21)
	cbxi(10)= cbxj(22)
	cbxi(11)= cbxj(33)
	cbxi(12)= cbxj(34)
*	check the symmetry in B0(i,j)
	if ( atest ) then
	    do 13 i=1,4
		j=4+i
		k=8+i
		if (( cbxj(i)     - cbxj(i+1*12) ) .ne. 0. .or.
     +		    ( cbxj(j)     - cbxj(i+2*12) ) .ne. 0. .or.
     +		    ( cbxj(k)     - cbxj(i+3*12) ) .ne. 0. .or.
     +		    ( cbxj(j+1*12)- cbxj(j+2*12) ) .ne. 0. .or.
     +		    ( cbxj(k+1*12)- cbxj(j+3*12) ) .ne. 0. .or.
     +		    ( cbxj(k+2*12)- cbxj(k+3*12) ) .ne. 0. ) then
		    print *,'error in B0-calculations in aaxcx.for'
		    goto 990
		endif
 13	    continue
	endif

*  #] level 0 :
*  #[ level 1 : D11,D12,D13,C0(I)
*		need 4 diff C0(I)-functions,I=1,2,3
	cc0i(1)=ccxj(1)
	cc0i(2)=ccxj(14)
	cc0i(3)=ccxj(27)
	cc0i(4)=ccxj(40)
*	    PV-reduction
	R20 = ( f1*cdxi(1)+cc0i(2)-cc0i(1) )/2
	R21 = ( f2*cdxi(1)+cc0i(3)-cc0i(2) )/2
	R22 = ( f3*cdxi(1)+cc0i(4)-cc0i(3) )/2
	cdxi(2)=xi4(1)*R20+xi4(4)*R21+xi4(5)*R22
	cdxi(3)=xi4(4)*R20+xi4(2)*R21+xi4(6)*R22
	cdxi(4)=xi4(5)*R20+xi4(6)*R21+xi4(3)*R22
	if (awrite) then
	    print *,'	   '
	    print *,'aaxdx : level 1 :'
	    print *,'D11=',cdxi(2)
	    print *,'D12=',cdxi(3)
	    print *,'D13=',cdxi(4)
	endif
*
*	check with ffroutine
	if ( atest ) then
	    ier0 = ier
	    call ffxd1(cd1i,cdxi(1),cc0i,xpi,fpij4,fdel3,fdel2i,ier0)
	    if ( awrite ) then
		print *,'GEERT JANs-scheme:',ier0
		print *,'D11=',cd1i(1)
		print *,'D12=',cd1i(2)
		print *,'D13=',cd1i(3)
	    endif
	endif
*
	if (level .eq. 1) goto 990
*
*  #] level 1 :
*  #[ level 2 : D21,D22,D23,D24,D25,D26,D27,C11(I),C12(I)
*	    need 4 diff C1-functions
	do 14 i=1,4
	    j = 2 +(i-1)*13
	    cc11i(i)=ccxj(j)
 14	    cc12i(i)=ccxj(j+1)
*		PV-reduction
	cdxi(11)=-( f1*cdxi(2)+f2*cdxi(3)+f3*cdxi(4)-cc0i(1) )/2
     +		 +xpi(1)*cdxi(1)
	R30=( f1*cdxi(2) + cc11i(2) + cc0i(1)  )/2 - cdxi(11)
	R31=( f2*cdxi(2) + cc11i(3) - cc11i(2) )/2
	R32=( f3*cdxi(2) + cc11i(4) - cc11i(3) )/2
	R33=( f1*cdxi(3) + cc11i(2) - cc11i(1) )/2
	R34=( f2*cdxi(3) + cc12i(3) - cc11i(2) )/2 - cdxi(11)
	R35=( f3*cdxi(3) + cc12i(4) - cc12i(3) )/2
	R36=( f1*cdxi(4) + cc12i(2) - cc12i(1) )/2
	R37=( f2*cdxi(4) + cc12i(3) - cc12i(2) )/2
	R38=( f3*cdxi(4)            - cc12i(3) )/2 - cdxi(11)
	cdxi(5) = xi4(1)*R30+xi4(4)*R31+xi4(5)*R32
	cdxi(6) = xi4(4)*R33+xi4(2)*R34+xi4(6)*R35
	cdxi(7) = xi4(5)*R36+xi4(6)*R37+xi4(3)*R38
	cdxi(8) = xi4(4)*R30+xi4(2)*R31+xi4(6)*R32
	cdxi(9) = xi4(5)*R30+xi4(6)*R31+xi4(3)*R32
	cdxi(10)= xi4(5)*R33+xi4(6)*R34+xi4(3)*R35
*	redundancy check
	if ( atest ) then
	    cxy(1) = xi4(1)*R33+xi4(4)*R34+xi4(5)*R35
	    cxy(2) = xi4(1)*R36+xi4(4)*R37+xi4(5)*R38
	    cxy(3) = xi4(4)*R36+xi4(2)*R37+xi4(6)*R38
	    if ( absc(cxy(1)-cdxi(8))	.gt. .1d-3   .or.
     +		 absc(cxy(2)-cdxi(9))	.gt. .1d-3   .or.
     +		 absc(cxy(3)-cdxi(10)) .gt. .1d-5	   ) then
		print *,'redundancy check at level 2 failed'
		goto 990
	    endif
	endif
	if ( awrite ) then
	    print *,'	   '
	    print *,'aaxdx : level 2 '
	    print *,'D21=',cdxi(5)
	    print *,'D22=',cdxi(6)
	    print *,'D23=',cdxi(7)
	    print *,'D24=',cdxi(8)
	    print *,'D25=',cdxi(9)
	    print *,'D26=',cdxi(10)
	    print *,'D27=',cdxi(11)
	endif
*
	if (level .eq. 2) goto 990
*
*  #] level 2 :
*  #[ level 3 : D31,D32,D33,D34,D35,D36,D37,D38,D39,D310,D311,D312,D313
*		C21(I),C22(I),C23(I),C11(I),C12(I)
*		need 4 diff C2-functions
	do 15 i=1,4
	    j = 4 +(i-1)*13
	    cc21i(i)=ccxj(j)
	    cc22i(i)=ccxj(j+1)
	    cc23i(i)=ccxj(j+2)
 15	    cc24i(i)=ccxj(j+3)
*		PV-reduction
	R53=( f1*cdxi(11) + cc24i(2) - cc24i(1) )/2
	R54=( f2*cdxi(11) + cc24i(3) - cc24i(2) )/2
	R55=( f3*cdxi(11) + cc24i(4) - cc24i(3) )/2
	cdxi(22) = xi4(1)*R53+xi4(4)*R54+xi4(5)*R55
	cdxi(23) = xi4(4)*R53+xi4(2)*R54+xi4(6)*R55
	cdxi(24) = xi4(5)*R53+xi4(6)*R54+xi4(3)*R55
*
	R41=( f1*cdxi(5) + cc21i(2) - cc0i(1)  )/2-2*cdxi(22)
	R42=( f2*cdxi(5) + cc21i(3) - cc21i(2) )/2
	R43=( f3*cdxi(5) + cc21i(4) - cc21i(3) )/2
	R44=( f1*cdxi(6) + cc21i(2) - cc21i(1) )/2
	R45=( f2*cdxi(6) + cc22i(3) - cc21i(2) )/2-2*cdxi(23)
	R46=( f3*cdxi(6) + cc22i(4) - cc22i(3) )/2
	R47=( f1*cdxi(7) + cc22i(2) - cc22i(1) )/2
	R48=( f2*cdxi(7) + cc22i(3) - cc22i(2) )/2
	R49=( f3*cdxi(7)            - cc22i(3) )/2-2*cdxi(24)
	R50=( f1*cdxi(8) + cc21i(2) + cc11i(1) )/2-cdxi(23)
	R51=( f2*cdxi(8) + cc23i(3) - cc21i(2) )/2-cdxi(22)
	R52=( f3*cdxi(8) + cc23i(4) - cc23i(3) )/2
	cdxi(12) = xi4(1)*R41+xi4(4)*R42+xi4(5)*R43
	cdxi(13) = xi4(4)*R44+xi4(2)*R45+xi4(6)*R46
	cdxi(14) = xi4(5)*R47+xi4(6)*R48+xi4(3)*R49
	cdxi(15) = xi4(4)*R41+xi4(2)*R42+xi4(6)*R43
	cdxi(16) = xi4(5)*R41+xi4(6)*R42+xi4(3)*R43
	cdxi(17) = xi4(1)*R44+xi4(4)*R45+xi4(5)*R46
	cdxi(18) = xi4(1)*R47+xi4(4)*R48+xi4(5)*R49
	cdxi(19) = xi4(5)*R44+xi4(6)*R45+xi4(3)*R46
	cdxi(20) = xi4(4)*R47+xi4(2)*R48+xi4(6)*R49
	cdxi(21) = xi4(5)*R50+xi4(6)*R51+xi4(3)*R52
*	redundancy check
	if ( atest ) then
	    cxy(1) = xi4(1)*R50+xi4(4)*R51+xi4(5)*R52
	    cxy(2) = xi4(4)*R50+xi4(2)*R51+xi4(6)*R52
	    if ( absc(cxy(1)-cdxi(15)) .gt. .1d-3   .or.
     +		 absc(cxy(2)-cdxi(17)) .gt. .1d-3	   ) then
		print *,'redundancy check at level 3 failed'
		goto 990
	    endif
	endif
	if ( awrite ) then
	    print *,'	   '
	    print *,'aaxdx : level 3 '
	    print *,'D31 =',cdxi(12)
	    print *,'D32 =',cdxi(13)
	    print *,'D33 =',cdxi(14)
	    print *,'D34 =',cdxi(15)
	    print *,'D35 =',cdxi(16)
	    print *,'D36 =',cdxi(17)
	    print *,'D37 =',cdxi(18)
	    print *,'D38 =',cdxi(19)
	    print *,'D39 =',cdxi(20)
	    print *,'D310=',cdxi(21)
	    print *,'D311=',cdxi(22)
	    print *,'D312=',cdxi(23)
	    print *,'D313=',cdxi(24)
	endif
*
	if (level .eq. 3) goto 990
*
*  #] level 3 :
*  #[ end:
  990	continue
	ier = ier1 + (ier2-ier)
*  #] end:
*###] aaxdxp :
	end

* file aaxinv	4-oct-1990

*###[ : aaxi3 :
	subroutine aaxi3(xi3,ier)
*###[ : comment:*******************************************************
*###] : comment:**********************************************************
*###[ : declarations :
	implicit none
* arguments
	DOUBLE PRECISION xi3(3)
	integer ier
* local variables
	DOUBLE PRECISION e3(3),s1,s2,s3
	integer i,j
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*###] : declarations :
*###[ : kinematical matrix x3 and inverse xi3:
*	the dotproducts are imported via ff.h
*	definition see ffxc0.ffdot3:comment
	s1=fpij3(4,4)
	s2=fpij3(5,5)
	s3=fpij3(4,5)
*	       inverse kinematical matrix xi3
*	       the determinant is also provided by ff
	xi3(1)= s2/fdel2
	xi3(3)=-s3/fdel2
	xi3(2)= s1/fdel2
*###] : kinematical matrix x3 and inverse xi3:
*###[ : check: on accuracy
	if ( atest ) then
	    e3(1)= s1*xi3(1)+s3*xi3(3)
	    e3(2)= s3*xi3(3)+s2*xi3(2)
	    e3(3)= s1*xi3(3)+s3*xi3(2)
	    if (  abs(e3(1)-1.d0) .gt. .1d-4  .or.
     +		  abs(e3(2)-1.d0) .gt. .1d-4  .or.
     +		  abs(e3(3))	   .gt. .1d-4 ) then
		print *,'error in xi3'
		return
	    endif
	endif
	if ( awrite ) then
	    print *,' '
	    print *,'aaxi3:imported dots and inv:'
	    print *,'s..xi3 ',s1,xi3(1)
	    print *,'       ',s2,xi3(2)
	    print *,'       ',s3,xi3(3)
	    print *,' '
	endif
*###] : check:
*###] : aaxi3 :
	end

*###[ : aaxi4 :
	subroutine aaxi4(xi4,ier)
*###[ : comment:*******************************************************
*###] : comment:**********************************************************
*###[ : declarations :
	implicit none
* arguments
	DOUBLE PRECISION xi4(6)
	integer ier
* local variables
	DOUBLE PRECISION e4(6),
     +			 s1,s2,s3,s4,s5,s6
	integer i,j
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*###] : declarations :
*###[ : kinematical matrix x4 and inverse xi4:
*	the dotproducts are imported via ff.h
*	definition see ffxd0.ffdot4:comment
	s1=fpij4(5,5)
	s2=fpij4(6,6)
	s3=fpij4(7,7)
	s4=fpij4(5,6)
	s5=fpij4(5,7)
	s6=fpij4(6,7)
*	       inverse kinematical matrix xi4
*	       the determinant is also provided by ff
	xi4(1)=( +2*s2*s3-2*s6**2 )/fdel3/2
	xi4(4)=( -2*s3*s4+2*s5*s6 )/fdel3/2
	xi4(5)=( -2*s2*s5+2*s4*s6 )/fdel3/2
	xi4(2)=( +2*s1*s3-2*s5**2 )/fdel3/2
	xi4(6)=( -2*s1*s6+2*s4*s5 )/fdel3/2
	xi4(3)=( +2*s1*s2-2*s4**2 )/fdel3/2
*###] : kinematical matrix x4 and inverse xi4:
*###[ : check:
	if ( atest ) then
	    e4(1) = ( s1*xi4(1)+s4*xi4(4)+s5*xi4(5) )
	    e4(2) = ( s4*xi4(4)+s2*xi4(2)+s6*xi4(6) )
	    e4(3) = ( s5*xi4(5)+s6*xi4(6)+s3*xi4(3) )
	    e4(4) = ( s1*xi4(4)+s4*xi4(2)+s5*xi4(6) )
	    e4(5) = ( s1*xi4(5)+s4*xi4(6)+s5*xi4(3) )
	    e4(6) = ( s4*xi4(5)+s2*xi4(6)+s6*xi4(3) )
	    do 12 i=1,3
		if (  abs(e4(i)-1.d0) .gt. .1d-5  .or.
     +		      abs(e4(i+3) ) .gt. .1d-5 ) then
		    print *,'error in xi4'
		    return
		endif
 12	    continue
	endif
*###] : check:
*###] : aaxi4 :
	end

*###[ : aaxi5 :
	subroutine aaxi5(xi5,ier)
*###[ : comment:*******************************************************
*###] : comment:**********************************************************
*###[ : declarations :
	implicit none
* arguments
	DOUBLE PRECISION xi5(10)
	integer ier
* local variables
	DOUBLE PRECISION e5(10),s1,s2,s3,s4,s5,s6,s7,s8,s9,s10
	integer i,j
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*###] : declarations :
*###[ : kinematical matrix x5 and inverse xi5:
*	the dotproducts are imported via ff.h
*	definition see ffex0.ffdot5:comment
	s1  = fpij5(6,6)
	s2  = fpij5(7,7)
	s3  = fpij5(8,8)
	s4  = fpij5(9,9)
	s5  = fpij5(6,7)
	s6  = fpij5(6,8)
	s7  = fpij5(6,9)
	s8  = fpij5(7,8)
	s9  = fpij5(7,9)
	s10 = fpij5(8,9)
*
* inverse kinematical matrix xi5
	xi5(1)=
     +	  s2*s3*s4-s2*s10**2-s3*s9**2-s4*s8**2+2*s8*s9*s10
	xi5(5)=
     +	  -s3*s4*s5+s3*s7*s9+s4*s6*s8+s5*s10**2-s6*s9*s10-s7*s8*s10
	xi5(6)=
     +	  -s2*s4*s6+s2*s7*s10+s4*s5*s8-s5*s9*s10+s6*s9**2-s7*s8*s9
	xi5(7)=
     +	  -s2*s3*s7+s2*s6*s10+s3*s5*s9-s5*s8*s10-s6*s8*s9+s7*s8**2
	xi5(2)=
     +	  +s1*s3*s4-s1*s10**2-s3*s7**2-s4*s6**2+2*s6*s7*s10
	xi5(8)=
     +	  -s1*s4*s8+s1*s9*s10+s4*s5*s6-s5*s7*s10-s6*s7*s9+s7**2*s8
	xi5(9)=
     +	  -s1*s3*s9+s1*s8*s10+s3*s5*s7-s5*s6*s10-s6*s7*s8+s6**2*s9
	xi5(3)=
     +	  +s1*s2*s4-s1*s9**2-s2*s7**2-s4*s5**2+2*s5*s7*s9
	xi5(10)=
     +	  -s1*s2*s10+s1*s8*s9+s2*s6*s7-s5*s6*s9-s5*s7*s8+s5**2*s10
	xi5(4)=
     +	  +s1*s2*s3-s1*s8**2-s2*s6**2-s3*s5**2+2*s5*s6*s8

* the determinant is also provided by ff
	do 20 i=1,10
 20	xi5(i) = xi5(i) / fdel4
*###] : kinematical matrix x5 and inverse xi5:
*###[ : check:
	if ( atest ) then
	  e5(1)=( s1*xi5(1)+s5*xi5(5)+s6*xi5(6)+s7*xi5(7) )
	  e5(2)=( s5*xi5(5)+s2*xi5(2)+s8*xi5(8)+s9*xi5(9) )
	  e5(3)=( s6*xi5(6)+s8*xi5(8)+s3*xi5(3)+s10*xi5(10) )
	  e5(4)=( s7*xi5(7)+s9*xi5(9)+s10*xi5(10)+s4*xi5(4) )
	  e5(5)=( s1*xi5(5)+s5*xi5(2)+s6*xi5(8)+s7*xi5(9) )
	  e5(6)=( s1*xi5(6)+s5*xi5(8)+s6*xi5(3)+s7*xi5(10) )
	  e5(7)=( s1*xi5(7)+s5*xi5(9)+s6*xi5(10)+s7*xi5(4) )
	  e5(8)=( s5*xi5(6)+s2*xi5(8)+s8*xi5(3)+s9*xi5(10) )
	  e5(9)=( s5*xi5(7)+s2*xi5(9)+s8*xi5(10)+s9*xi5(4) )
	  e5(10)=( s6*xi5(7)+s8*xi5(9)+s3*xi5(10)+s10*xi5(4) )
	     do 12 i=1,4
	     if (  abs(e5(i)-1.d0) .gt. .1d-5  .or.
     +		   abs(e5(i+6)	 ) .gt. .1d-5 ) then
	       print *,'error in xi5'
	       return
	     endif
 12	     continue
	endif
*###] : check:
*###] : aaxi5 :
	end




*###[ ff2dl2:
	subroutine ff2dl2(del2d2,del2n,xpi,dpipj,piDpj, i,
     +			j,k,kj,iskj,l, m,n,nm,isnm, ns, ier)
***#[*comment:***********************************************************
*									*
*	Calculate							*
*									*
*	 si mu	 mu sl							*
*	d	d	= si.sj*sk.sm*sl.sn - si.sk*sj.sm*sl.sn		*
*	 sj sk	 sm sn		- si.sj*sk.sn*sl.sm + si.sk*sj.sn*sl.sm	*
*									*
*	with p(kj) = iskj*(sk-sj)					*
*	with p(nm) = isnm*(sn-sm)					*
*									*
*	Input:	xpi(ns)			as usual			*
*		dpipj(ns,ns)		  -"-				*
*		piDpj(ns,ns)		  -"-				*
*		i,j,k,kj,iskj		see above			*
*		l,m,n,nm,isnm		  -"-				*
*									*
*	Output:	del2d2			see above			*
*		del2n			it is needed in fftran anyway	*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer i,j,k,kj,iskj,l,m,n,nm,isnm,ns,ier
	DOUBLE PRECISION del2d2,del2n,xpi(10),dpipj(10,10),piDpj(10,10)
*
*	local variables:
*
	integer isii,ii,ik,ij,im,in
	DOUBLE PRECISION s(5),del2m,del2nm,som,xmax,smax
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations: 
*  #[ check input:
	if ( ltest ) then
	    if ( abs(iskj) .ne. 1 ) print *,'ff2dl2: error: abs(iskj) ',
     +		'<> 1 but ',iskj
	    if ( abs(isnm) .ne. 1 ) print *,'ff2dl2: error: abs(isnm) ',
     +		'<> 1 but ',isnm
	    if ( ns .ne. 10 ) print *,'ff2dl2: error: ns <> 10 !!'
	    if ( kj.eq.0 ) then
		print *,'ff2dl2: error: kj=0:j,k,id,idsub=',j,k,id,idsub
	    endif
	    if ( nm.eq.0 ) then
		print *,'ff2dl2: error: nm=0:m,n,id,idsub=',m,n,id,idsub
	    endif
	endif
*  #] check input: 
*  #[ special case:
*	we need this in any case !
	if ( i .eq. n ) then
	    del2n = 0
	elseif ( i .le. 4 ) then
	    ii = inx(n,i)
	    isii = isgn(n,i)
	    call ffdl2s(del2n,xpi,piDpj,i,n,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(del2n,piDpj,i,n,j,k,kj,iskj,+1,10,ier)
	endif
	if ( i .eq. l .and. j .eq. m .and. k .eq. n ) then
	    call ffdl3m(s,.FALSE.,x0,x0,xpi,dpipj,piDpj,ns,j,k,kj,
     +		i,1,ier)
	    del2d2 = -s(1)
*	    if ( lwrite ) print *,'del2d2 = ',del2d2
	    return
	endif
	if ( k .eq. l .and. j .le. 4 ) then
	    call ffdl2s(del2m,xpi,piDpj, j,l,inx(l,j),isgn(l,j),
     +		m,n,nm,isnm, 10,ier)
	    del2d2 = -piDpj(i,k)*del2m
*	    if ( lwrite ) print *,'del2d2 = ',del2d2
	    return
	endif
*	not yet tested:
*	if ( j .eq. l .and. k .le. 4 ) then
*	    call ffdl2s(del2m,xpi,piDpj, k,l,inx(k,j),isgn(k,j),
*     +		m,n,nm,isnm, 10,ier)
*	    del2d2 = piDpj(i,j)*del2m
*	    return
*	endif
*  #] special case: 
*  #[ calculations:
	if ( i .eq. m ) then
	    del2m = 0
	elseif ( i .le. 4 ) then
	    ii = inx(m,i)
	    isii = isgn(m,i)
	    call ffdl2s(del2m,xpi,piDpj,i,m,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(del2m,piDpj,i,m,j,k,kj,iskj,+1,10,ier)
	endif
	s(1) = del2m*piDpj(n,l)
	s(2) = del2n*piDpj(m,l)
	del2d2 = s(1) - s(2)
	if ( abs(del2d2) .ge. xloss*abs(s(1)) ) goto 60

	som = del2d2
	xmax = abs(s(1))
	if ( lwrite ) print *,'  del2d2  = ',del2d2,s(1),-s(2)

	call ffdl2t(del2nm,piDpj,i,nm,j,k,kj,iskj,+1,10,ier)
	s(1) = del2n*piDpj(nm,l)
	s(2) = del2nm*piDpj(n,l)
	del2d2 = isnm*(s(1) - s(2))
	if ( lwrite ) print *,'  del2d2+ = ',del2d2,s(1),-s(2)
	if ( abs(del2d2) .ge. xloss*abs(s(1)) ) goto 60

	if ( abs(s(1)) .lt. xmax ) then
	    som = del2d2
	    xmax = abs(s(1))
	endif

	s(1) = del2m*piDpj(nm,l)
	s(2) = del2nm*piDpj(m,l)
	del2d2 = isnm*(s(1) - s(2))
	if ( lwrite ) print *,'  del2d2+ = ',del2d2,s(1),-s(2)
	if ( abs(del2d2) .ge. xloss*abs(s(1)) ) goto 60

	if ( abs(s(1)) .lt. xmax ) then
	    som = del2d2
	    xmax = abs(s(1))
	endif

*	One more special case:
	if ( k .eq. m ) then
	    isii = -1
	    ik = j
	    ij = k
	    im = m
	    in = n
	elseif ( j .eq. m ) then
	    isii = +1
	    ik = k
	    ij = j
	    im = m
	    in = n
	elseif ( j .eq. n ) then
	    isii = -1
	    ik = k
	    ij = j
	    im = n
	    in = m
	elseif ( k .eq. n ) then
	    isii = +1
	    ik = j
	    ij = k
	    im = n
	    in = m
	else
	    goto 50
	endif
	if ( ij .eq. im .and. i .le. 4 .and. ij .le. 4 .and. in .le. 4 )
     +								then
	    if ( inx(ij,i) .gt. 0 .and. inx(im,l) .gt. 0 ) then
		if (  abs(dpipj(i,inx(ij,i))) .lt. xloss*abs(xpi(ij))
     +		.and. abs(dpipj(l,inx(im,l))) .lt. xloss*abs(xpi(im)) )
     +								then
		    s(1) = piDpj(l,in)*piDpj(ik,ij)*dpipj(i,inx(ij,i))/2
		    s(2) = isgn(ij,i)*piDpj(l,in)*xpi(ij)*piDpj(ik,
     +			inx(ij,i))/2
		    s(3) = -piDpj(i,ij)*piDpj(ik,in)*piDpj(l,im)
		    s(4) = piDpj(i,ik)*piDpj(im,in)*dpipj(l,inx(im,l))/2
		    s(5) = isgn(im,l)*piDpj(i,ik)*xpi(im)*piDpj(in,
     +			inx(im,l))/2
		    del2d2 = s(1) + s(2) + s(3) + s(4) + s(5)
		    if ( isii .lt. 0 ) del2d2 = -del2d2
		    smax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +			abs(s(5)))
		    if ( lwrite ) print *,'  del2d2* = ',del2d2,s
		    if ( abs(del2d2) .ge. xloss**2*abs(smax) ) goto 60
		    if ( smax .lt. xmax ) then
			som = del2d2
			xmax = smax
		    endif
		endif
	    endif
	endif
   50	continue
*
*	give up
*
	del2d2 = som
	if ( lwarn ) call ffwarn(123,ier,del2d2,xmax)
	if ( lwrite ) then
	    print *,'ff2dl2: giving up on this case'
	    print *,'        indices: i=n:',i,j,k,l,m,n
	    print *,'        xpi: ',xpi
	endif

   60	continue
*  #] calculations:
*  #[ check:
	if ( ltest ) then
	    s(1) = + piDpj(i,j)*piDpj(k,m)*piDpj(l,n)
	    s(2) = - piDpj(i,k)*piDpj(j,m)*piDpj(l,n)
	    s(3) = - piDpj(i,j)*piDpj(k,n)*piDpj(l,m)
	    s(4) = + piDpj(i,k)*piDpj(j,n)*piDpj(l,m)
	    som = s(1) + s(2) + s(3) + s(4)
	    xmax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)))
	    if ( xloss*abs(som-del2d2) .gt. precx*xmax ) then
		print *,'ff2dl2: error: del2d2 not correct: ',del2d2,
     +		som,xmax,del2d2-som
	    endif
	endif
*  #] check: 
*###] ff2dl2:
	end
*###[ ff2d22:
	subroutine ff2d22(dl2d22,xpi,dpipj,piDpj, i, j,k,kj,iskj,
     +			m,n,nm,isnm, ns, ier)
***#[*comment:***********************************************************
*									*
*	Calculate							*
*									*
*	/ si mu	 mu nu \2						*
*	|d	d      |						*
*	\ sj sk	 sm sn /						*
*									*
*	=   si.sj^2*sk.sm^2*sn.sn					*
*	- 2*si.sj^2*sk.sm*sk.sn*sm.sn					*
*	+   si.sj^2*sk.sn^2*sm.sm					*
*	- 2*si.sj*si.sk*sj.sm*sk.sm*sn.sn				*
*	+ 2*si.sj*si.sk*sj.sm*sk.sn*sm.sn				*
*	+ 2*si.sj*si.sk*sj.sn*sk.sm*sm.sn				*
*	- 2*si.sj*si.sk*sj.sn*sk.sn*sm.sm				*
*	+   si.sk^2*sj.sm^2*sn.sn					*
*	- 2*si.sk^2*sj.sm*sj.sn*sm.sn					*
*	+   si.sk^2*sj.sn^2*sm.sm					*
*									*
*	Input:	xpi(ns)			as usual			*
*		dpipj(ns,ns)		  -"-				*
*		piDpj(ns,ns)		  -"-				*
*		i,j,k,kj,iskj		see above			*
*		m,n,nm,isnm		 -"-				*
*									*
*	Output:	dl2d22			see above			*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer i,j,k,kj,iskj,m,n,nm,isnm,ns,ier
	DOUBLE PRECISION dl2d22,xpi(10),dpipj(10,10),piDpj(10,10)
*
*	local variables:
*
	integer ii,isii
	DOUBLE PRECISION s(10),del2s,del23,del24,del27,som,smax,xmax
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations: 
*  #[ check input:
	if ( ltest ) then
	    if ( abs(iskj) .ne. 1 ) print *,'ff2d22: error: abs(iskj) ',
     +		'<> 1 but ',iskj
	    if ( abs(isnm) .ne. 1 ) print *,'ff2d22: error: abs(isnm) ',
     +		'<> 1 but ',isnm
	    if ( ns .ne. 10 ) print *,'ff2d22: error: ns <> 10 !!'
	    if ( m .ne. 3 .or. n .ne. 4 ) print *,'ff2d22: error ',
     +		'only for m=3,n=4 !!'
	endif
*  #] check input: 
*  #[ special cases:
	if ( i .eq. n .or. i .eq. m ) then
	    call ffdl2s(del2s,xpi,piDpj, j,k,kj,iskj, m,n,nm,isnm,
     +							 10,ier)
	    dl2d22 = xpi(i)*del2s**2
*	    if ( lwrite ) print *,'  dl2d22  = ',dl2d22
	    return
	endif
*  #] special cases: 
*  #[ calculations:
*	We use the product form
	if ( i .eq. 3 ) then
	    del23 = 0
	elseif ( i .le. 4 ) then
	    ii = inx(3,i)
	    isii = isgn(3,i)
	    call ffdl2s(del23,xpi,piDpj,i,3,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(del23,piDpj,i,3,j,k,kj,iskj,+1,10,ier)
	endif
	if ( i .eq. 4 ) then
	    del24 = 0
	elseif ( i .le. 4 ) then
	    ii = inx(n,i)
	    isii = isgn(n,i)
	    call ffdl2s(del24,xpi,piDpj,i,4,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(del24,piDpj,i,4,j,k,kj,iskj,+1,10,ier)
	endif

	s(1) = xpi(4)*del23**2
	s(2) = -2*piDpj(3,4)*del23*del24
	s(3) = xpi(3)*del24**2
	dl2d22 = s(1) + s(2) + s(3)
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( abs(dl2d22) .ge. xloss*smax ) goto 110

	som = dl2d22
	xmax = smax
	if ( lwrite ) print *,'  dl2d22  = ',dl2d22,s(1),s(2),s(3)

*	try the special case k=4 (for use in ee->mumu among others)
	if ( i .lt. 4 .and. k .eq. 4 .and. abs(s(3)) .lt. xloss*smax
     +		.and. ( abs(dpipj(i,inx(4,i))) .lt. xloss*xpi(i) .or.
     +		abs(piDpj(j,inx(4,i))) .lt. xloss*abs(piDpj(j,4)) ) )
     +								then
	    s(1) = -del23*piDpj(i,4)*piDpj(j,3)*xpi(4)
	    s(2) =  del23*dpipj(i,inx(4,i))*piDpj(j,4)*piDpj(3,4)
	    s(4) =  del23*piDpj(3,4)*xpi(4)*piDpj(j,inx(4,i))*isgn(4,i)
	    dl2d22 = s(1) + s(2) + s(3) + s(4)
	    smax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)))
	    if ( lwrite ) print *,'  dl2d22* = ',dl2d22,s(1),s(2),s(3),
     +		s(4)
	    if ( abs(dl2d22) .ge. xloss*smax ) goto 110

	    if ( smax .lt. xmax ) then
		som = dl2d22
		xmax = smax
	    endif
	endif

	call ffdl2t(del27,piDpj,i,7,j,k,kj,iskj,+1,10,ier)
	s(1) = xpi(7)*del24**2
	s(2) = -2*piDpj(4,7)*del24*del27
	s(3) = xpi(4)*del27**2
	dl2d22 = s(1) + s(2) + s(3)
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( lwrite ) print *,'  dl2d22+ = ',dl2d22,s(1),s(2),s(3)
	if ( abs(dl2d22) .ge. xloss*smax ) goto 110

	if ( smax .lt. xmax ) then
	    som = dl2d22
	    xmax = smax
	endif

	s(1) = xpi(7)*del23**2
	s(2) = -2*piDpj(3,7)*del23*del27
	s(3) = xpi(3)*del27**2
	dl2d22 = s(1) + s(2) + s(3)
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( lwrite ) print *,'  dl2d22+ = ',dl2d22,s(1),s(2),s(3)
	if ( abs(dl2d22) .ge. xloss*smax ) goto 110
*
*	We'll have to think of something more intelligent ...
*
	if ( smax .lt. xmax ) then
	    som = dl2d22
	    xmax = smax
	endif

	dl2d22 = som
	if ( lwarn ) call ffwarn(122,ier,dl2d22,xmax)
	if ( lwrite ) then
	    print *,'ff2d22: give up on this case ...'
	    print *,'        indices: ijkmn:',i,j,k,m,n
	    print *,'        xpi:',xpi
	endif

  110	continue
*  #] calculations: 
*  #[ check:
	if ( ltest ) then
	    s(1) = +   piDpj(i,j)**2*piDpj(k,m)**2*piDpj(n,n)
	    s(2) = - 2*piDpj(i,j)**2*piDpj(k,m)*piDpj(k,n)*piDpj(m,n)
	    s(3) = +   piDpj(i,j)**2*piDpj(k,n)**2*piDpj(m,m)
	    s(4) = - 2*piDpj(i,j)*piDpj(i,k)*piDpj(j,m)*piDpj(k,m)*
     +		piDpj(n,n)
	    s(5) = + 2*piDpj(i,j)*piDpj(i,k)*piDpj(j,m)*piDpj(k,n)*
     +		piDpj(m,n)
	    s(6) = + 2*piDpj(i,j)*piDpj(i,k)*piDpj(j,n)*piDpj(k,m)*
     +		piDpj(m,n)
	    s(7) = - 2*piDpj(i,j)*piDpj(i,k)*piDpj(j,n)*piDpj(k,n)*
     +		piDpj(m,m)
	    s(8) = +   piDpj(i,k)**2*piDpj(j,m)**2*piDpj(n,n)
	    s(9) = - 2*piDpj(i,k)**2*piDpj(j,m)*piDpj(j,n)*piDpj(m,n)
	    s(10)= +   piDpj(i,k)**2*piDpj(j,n)**2*piDpj(m,m)
	    som = 0
	    xmax = 0
	    do 900 ii=1,10
		som = som + s(ii)
		xmax = max(xmax,abs(s(ii)))
  900	    continue
	    if ( xloss*abs(som-dl2d22) .gt. precx*xmax ) then
		print *,'ff2c22: error: dl2d22 not correct: ',dl2d22,
     +		som,xmax
	    endif
	endif
*  #] check: 
*###] ff2d22: 
	end
*###[ ff3dl2:
	subroutine ff3dl2(del3d2,xpi,dpipj,piDpj, i,
     +		j,k,kj,iskj, l,m,ml,isml, n, o,p,po,ispo, ns, ier)
***#[*comment:***********************************************************
*									*
*	Calculate							*
*									*
*	 si mu	 mu nu	 mu sn						*
*	d	d	d	= ...					*
*	 sj sk	 sl sm	 so sp						*
*									*
*	with p(kj) = iskj*(sk-sj)					*
*	     p(ml) = isml*(sm-sl)					*
*	     p(po) = ispo*(sp-so)					*
*									*
*	Input:	xpi(ns)			as usual			*
*		dpipj(ns,ns)		  -"-				*
*		piDpj(ns,ns)		  -"-				*
*		i,j,k,kj,iskj		see above			*
*		l,m,ml,isml		  -"-				*
*		n,o,p,po,ispo		  -"-				*
*									*
*	Output:	del3d2			see above			*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer i,j,k,kj,iskj,l,m,ml,isml,n,o,p,po,ispo,ns,ier
	DOUBLE PRECISION del3d2,xpi(10),dpipj(10,10),piDpj(10,10)
*
*	local variables:
*
	integer isii,ii
	DOUBLE PRECISION s(2),dl2il,dl2im,dl2ln,dl2mn,dl2iml,dl2mln
	DOUBLE PRECISION d2d2j,d2d2k,d2d2kj,dum,d2d2o,d2d2p,d2d2po
	DOUBLE PRECISION som,xmax
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations: 
*  #[ check input:
	if ( ltest ) then
	    if ( abs(iskj) .ne. 1 ) print *,'ff3dl2: error: abs(iskj) ',
     +		'<> 1 but ',iskj
	    if ( abs(isml) .ne. 1 ) print *,'ff3dl2: error: abs(isml) ',
     +		'<> 1 but ',isml
	    if ( abs(ispo) .ne. 1 ) print *,'ff3dl2: error: abs(ispo) ',
     +		'<> 1 but ',ispo
	    if ( ns .ne. 10 ) print *,'ff3dl2: error: ns <> 10 !!'
	endif
*  #] check input: 
*  #[ split up l,m:
	if ( i .eq. l ) then
	    dl2il = 0
	elseif ( i .le. 4 ) then
	    ii = inx(l,i)
	    isii = isgn(l,i)
	    call ffdl2s(dl2il,xpi,piDpj,i,l,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(dl2il,piDpj,i,l,j,k,kj,iskj,+1,10,ier)
	endif
	if ( m .eq. n ) then
	    dl2mn = 0
	elseif ( i .le. 4 ) then
	    ii = inx(n,m)
	    isii = isgn(n,m)
	    call ffdl2s(dl2mn,xpi,piDpj,m,n,ii,isii,o,p,po,ispo,10,ier)
	else
	    call ffdl2t(dl2mn,piDpj,m,n,o,p,po,ispo,+1,10,ier)
	endif
	s(1) = dl2il*dl2mn
	if ( i .eq. m ) then
	    dl2im = 0
	elseif ( i .le. 4 ) then
	    ii = inx(m,i)
	    isii = isgn(m,i)
	    call ffdl2s(dl2im,xpi,piDpj,i,m,ii,isii,j,k,kj,iskj,10,ier)
	else
	    call ffdl2t(dl2im,piDpj,i,m,j,k,kj,iskj,+1,10,ier)
	endif
	if ( l .eq. n ) then
	    dl2ln = 0
	elseif ( i .le. 4 ) then
	    ii = inx(n,l)
	    isii = isgn(n,l)
	    call ffdl2s(dl2ln,xpi,piDpj,l,n,ii,isii,o,p,po,ispo,10,ier)
	else
	    call ffdl2t(dl2ln,piDpj,l,n,o,p,po,ispo,+1,10,ier)
	endif
	s(2) = dl2im*dl2ln
	del3d2 = s(1) - s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( lwrite ) print *,'  del3d2  = ',del3d2,s(1),-s(2)
	som = del3d2
	xmax = abs(s(1))
*
*	rotate l,m
*
	call ffdl2t(dl2mln,piDpj,ml,n,o,p,po,ispo,+1,10,ier)
	call ffdl2t(dl2iml,piDpj,i,ml,j,k,kj,iskj,+1,10,ier)
	s(1) = dl2im*dl2mln
	s(2) = dl2iml*dl2mn
	del3d2 = isml*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

	s(1) = dl2il*dl2mln
	s(2) = dl2iml*dl2ln
	del3d2 = isml*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

*  #] split up l,m: 
*  #[ split up j,k:
	call ff2dl2(d2d2k,dum,xpi,dpipj,piDpj, k, l,m,ml,isml, n,
     +						o,p,po,ispo, 10, ier)
	call ff2dl2(d2d2j,dum,xpi,dpipj,piDpj, j, l,m,ml,isml, n,
     +						o,p,po,ispo, 10, ier)
	s(1) = piDpj(i,j)*d2d2k
	s(2) = piDpj(i,k)*d2d2j
	del3d2 = s(1) - s(2)
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

	call ff2dl2(d2d2kj,dum,xpi,dpipj,piDpj, kj, l,m,ml,isml, n,
     +						o,p,po,ispo, 10, ier)
	s(1) = piDpj(i,k)*d2d2kj
	s(2) = piDpj(i,kj)*d2d2k
	del3d2 = iskj*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

	s(1) = piDpj(i,j)*d2d2kj
	s(2) = piDpj(i,kj)*d2d2j
	del3d2 = iskj*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

*  #] split up j,k: 
*  #[ split up o,p:
	call ff2dl2(d2d2o,dum,xpi,dpipj,piDpj, i, j,k,kj,iskj, o,
     +						l,m,ml,isml, 10, ier)
	call ff2dl2(d2d2p,dum,xpi,dpipj,piDpj, i, j,k,kj,iskj, p,
     +						l,m,ml,isml, 10, ier)
	s(1) = piDpj(p,n)*d2d2o
	s(2) = piDpj(o,n)*d2d2p
	del3d2 = s(1) - s(2)
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

	call ff2dl2(d2d2po,dum,xpi,dpipj,piDpj, i, j,k,kj,iskj, po,
     +						l,m,ml,isml, 10, ier)
	s(1) = piDpj(po,n)*d2d2p
	s(2) = piDpj(p,n)*d2d2po
	del3d2 = ispo*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

	s(1) = piDpj(po,n)*d2d2o
	s(2) = piDpj(o,n)*d2d2po
	del3d2 = ispo*(s(1) - s(2))
	if ( lwrite ) print *,'  del3d2+ = ',del3d2,s(1),-s(2)
	if ( abs(del3d2) .ge. xloss*abs(s(1)) ) return

	if ( abs(s(1)) .lt. xmax ) then
	    som = del3d2
	    xmax = abs(s(1))
	endif

*  #] split up o,p: 
*  #[ give up:
	del3d2 = som
	if ( lwarn ) call ffwarn(124,ier,del3d2,xmax)
*  #] give up: 
*###] ff3dl2: 
	end
*###[ ffabcd:
	subroutine ffabcd(aijkl,xpi,dpipj,piDpj,del2s,sdel2s,
     +		in,jn,jin,isji, kn,ln,lkn,islk, ns, ifirst, ier)
***#[*comment:***********************************************************
*									*
*	Calculate the a,b,c,d of the equation for qij.qkl		*
*									*
*	a      = s4.s4^2						*
*									*
*		  si sj  sk sl	/ sm sn	 sm sn	  sm sn	  mu   ro\	*
*	-b/2   = d	d	|d	d      - d	s4   s4	 |	*
*		  mu nu  nu ro	\ mu s4	 ro s4	  sm sn		 /	*
*									*
*	 _	  si sj	 sk sl	/ mu s4	  ro	  mu s4	  ro\		*
*	vD/2   = d	d	|d	s4   +	 d	s4  |		*
*		  mu nu	 nu ro	\ s3 s4		  s3 s4	    /		*
*									*
*	with	sm = s3, sn = s4					*
*		p(jin) = isji*(sj-si)					*
*		p(lkn) = islk*(sl-sk)					*
*									*
*	Input:	xpi(ns)			as usual			*
*		dpipj(ns,ns)		  -"-				*
*		piDpj(ns,ns)		  -"-				*
*		in,jn,jin,isjn		see above			*
*		kn,ln,lkn,islk		see above			*
*									*
*	Output:	del4d2			see above			*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer in,jn,jin,isji,kn,ln,lkn,islk,ns,ifirst,
     +		ier
	DOUBLE PRECISION aijkl,xpi(10),dpipj(10,10),piDpj(10,10),del2s
	DOUBLE PRECISION sdel2s
*
*	local variables:
*
	integer i,j,ji,k,l,lk,isii
	integer ii,ll
	integer iii(6,2)
	save iii
	logical ldet(4)
	DOUBLE PRECISION xa,xb,xc,xd,s(24),del3(4),som,somb,somd,xbp,
     +		xdp,smaxp,smax,save,xmax,rloss,del2d2,dum,del2i,del2j,
     +		del2ji,del2k,del2l,del2lk,d2d2i,d2d2j,d2d2ji,d2d2k,
     +		d2d2l,d2d2lk,d3d2m,d3d2n,d3d2nm
	save del3,ldet
*
*	common blocks:
*
	include 'ff.h'
*
*	data
*
	data iii / 0,3,4,0,7,0,
     +		   0,3,4,0,7,0/
*	data isign/1,1,1,0,1,0,
*     +		   1,1,1,0,1,0/
*  #] declarations: 
*  #[ initialisaties:
	if ( ifirst .eq. 0 ) then
	    ifirst = ifirst + 1
	    ldet(2) = .FALSE.
	    ldet(3) = .FALSE.
	    ldet(4) = .FALSE.
	endif
	xa = xpi(4)**2
*  #] initialisaties: 
*  #[ check input:
	if ( ltest ) then
	    if ( abs(isji) .ne. 1 ) print *,'ff2d22: error: abs(isji)',
     +		' /= 1',isji
	    if ( abs(islk) .ne. 1 ) print *,'ff2d22: error: abs(islk)',
     +		' /= 1',islk
	    if ( ns .ne. 10 ) print *,'ffabcd: only valid for ns=10!!'
	endif
*  #] check input: 
*  #[ prepare input:
	i = in
	j = jn
	ji = jin
	k = kn
	l = ln
	lk = lkn
*	sort it so that i<j, k<l, i<=k, and if i=k, j<=l
*	(I  think this is superfluous as the indices are sorted when
*	called)
*	if ( i .gt. j ) then
*	    ii = i
*	    i = j
*	    j = ii
*	    isji = -isji
*	endif
*	if ( k .gt. l ) then
*	    ii = k
*	    k = l
*	    l = ii
*	    islk = -islk
*	endif
*	if ( 16*i + j .gt. 16*k + l ) then
*	    ii = i
*	    i = k
*	    k = ii
*	    ii = j
*	    j = l
*	    l = ii
*	    ii = ji
*	    ji = lk
*	    lk = ii
*	    ii = isji
*	    isji = islk
*	    islk = ii
*	endif
*  #] prepare input: 
*  #[ special cases:
	if ( k .eq. 3 ) then
	    xb = 0
	    xc = 0
	    xd = 0
*	    print *,'  b,c,d = 0 (kl=34)'
	    goto 990
	elseif ( j .ge. 3 .and. l .ge. 3 ) then
*	    the whole thing collapses to factor*det3
*	    we have a good memory of things already calculated ...
	    if ( .not.ldet(i+k) ) then
		ldet(i+k) = .TRUE.
		iii(1,1) = i
		iii(4,1) = isgn(3,i)*inx(3,i)
		iii(6,1) = isgn(i,4)*inx(i,4)
		iii(1,2) = k
		iii(4,2) = isgn(3,k)*inx(3,k)
		iii(6,2) = isgn(k,4)*inx(k,4)
		call ffdl3s(del3(i+k),xpi,piDpj,iii,10,ier)
	    endif
	    if ( l .eq. 4 .and. j .eq. 4 ) then
		xb = xpi(4)**2*del3(i+k)/del2s
		xd = 0
		xc = xb**2/xa
	    elseif ( l .eq. 4 .or. j .eq. 4 ) then
		xb = piDpj(3,4)*xpi(4)*del3(i+k)/del2s
		xd = -xpi(4)*del3(i+k)/sdel2s
		xc = xpi(4)*xpi(3)*del3(i+k)**2/del2s**2
	    else
*		l .eq. 3 .and. j .eq. 3
		xd = -2*piDpj(3,4)*del3(i+k)/sdel2s
		s(1) = xpi(3)*xpi(4)
		s(2) = 2*piDpj(3,4)**2
		som = s(2) - s(1)
		if ( abs(som) .ge. xloss*abs(s(1)) ) goto 20
		call ffwarn(88,ier,som,s(1))
   20		continue
		xb = som*del3(i+k)/del2s
		xc = xpi(3)**2*del3(i+k)**2/del2s**2
	    endif
	    goto 900
	endif
	if ( j .eq. 2 .and. l .eq. 4 ) then
	    call ff3dl2(s(1),xpi,dpipj,piDpj, 4, 1,2,5,+1,
     +			k,3,inx(3,k),isgn(3,k), 4, 3,4,7,+1, 10,ier)
	    xb = -xpi(4)*s(1)/del2s
	    iii(1,1) = 1
	    iii(2,1) = 2
	    iii(4,1) = 5
	    iii(5,1) = 10
	    iii(6,1) = 8
	    iii(1,2) = k
	    iii(4,2) = isgn(3,k)*inx(3,k)
	    iii(6,2) = isgn(k,4)*inx(k,4)
	    call ffdl3s(s(1),xpi,piDpj,iii,10,ier)
*	    restore values for other users
	    iii(2,1) = 3
	    iii(5,1) = 7
	    xd = -xpi(4)*s(1)/sdel2s
	    goto 800
	endif
*  #] special cases: 
*  #[ normal case b:
*
*	First term:
*
	call ff2dl2(del2d2,dum,xpi,dpipj,piDpj, 4,
     +			i,j,ji,isji, 4, k,l,lk,islk, 10, ier)
	s(1) = -del2d2*del2s
*
*	Second and third term, split i,j
*
	if ( i .eq. 4 ) then
	    del2i = 0
	else
	    ii = inx(4,i)
	    isii = isgn(4,i)
	    call ffdl2s(del2i,xpi,piDpj,i,4,ii,isii,3,4,7,+1,10,ier)
	endif
	if ( j .eq. 4 ) then
	    del2j = 0
	else
	    ii = inx(4,j)
	    isii = isgn(4,j)
	    call ffdl2s(del2j,xpi,piDpj,j,4,ii,isii,3,4,7,+1,10,ier)
	endif
	call ff2dl2(d2d2i,dum,xpi,dpipj,piDpj, i, k,l,lk,islk, 4,
     +						3,4,7,+1, 10, ier)
	call ff2dl2(d2d2j,dum,xpi,dpipj,piDpj, j, k,l,lk,islk, 4,
     +						3,4,7,+1, 10, ier)
	s(2) = +del2i*d2d2j
	s(3) = -del2j*d2d2i
	somb = s(1) + s(2) + s(3)
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( abs(somb) .ge. xloss*smax ) goto 90
	xmax = smax
	save = somb

*	if the first term is wrong ... forget about it
	if ( abs(somb) .lt. xloss*abs(s(1)) ) then
	    if ( lwrite ) print *,'somb: s = ',s(1),s(2),s(3)
	    goto 80
	endif
	if ( lwrite ) print *,'  somb  = ',somb,s(1),s(2),s(3)

	call ffdl2t(del2ji,piDpj, ji,4, 3,4,7,+1,+1, 10,ier)
	call ff2dl2(d2d2ji,dum,xpi,dpipj,piDpj, ji, k,l,lk,islk, 4,
     +						3,4,7,+1, 10, ier)
	s(2) = +del2j*d2d2ji
	s(3) = -del2ji*d2d2j
	somb = s(1) + isji*(s(2) + s(3))
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( lwrite ) print *,'  somb+1= ',somb,s(1),s(2),s(3),isji
	if ( abs(somb) .ge. xloss*smax ) goto 90
	if ( smax .lt. xmax ) then
	    save = somb
	    xmax = smax
	endif

	s(2) = +del2i*d2d2ji
	s(3) = -del2ji*d2d2i
	somb = s(1) + isji*(s(2) + s(3))
	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
	if ( lwrite ) print *,'  somb+2= ',somb,s(1),s(2),s(3),isji
	if ( abs(somb) .ge. xloss*max(abs(s(1)),abs(s(2)),abs(s(3))) )
     +		goto 90
	if ( smax .lt. xmax ) then
	    save = somb
	    xmax = smax
	endif
*
*	Second and third term, split k,l
*
*	more of the same ...
*	if ( k .eq. 4 ) then
*	    del2k = 0
*	else
*	    ii = inx(4,k)
*	    isii = isgn(4,k)
*	    call ffdl2s(del2k,xpi,piDpj,k,4,ii,isii,3,4,7,+1,10,ier)
*	endif
*	if ( l .eq. 4 ) then
*	    del2l = 0
*	else
*	    ii = inx(4,l)
*	    isii = isgn(4,l)
*	    call ffdl2s(del2l,xpi,piDpj,l,4,ii,isii,3,4,7,+1,10,ier)
*	endif
*	call ff2dl2(d2d2k,dum,xpi,dpipj,piDpj, k, i,j,ji,isji, 4,
*     +						3,4,7,+1, 10, ier)
*	call ff2dl2(d2d2l,dum,xpi,dpipj,piDpj, l, i,j,ji,isji, 4,
*     +						3,4,7,+1, 10, ier)
*	s(2) = +del2k*d2d2l
*	s(3) = -del2l*d2d2k
*	somb = s(1) + s(2) + s(3)
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( lwrite ) print *,'  somb+3= ',somb,s(1),s(2),s(3)
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
*
*	call ffdl2t(del2lk,piDpj, lk,4, 3,4,7,+1,+1, 10,ier)
*	call ff2dl2(d2d2lk,dum,xpi,dpipj,piDpj, lk, i,j,ji,isji, 4,
*     +						3,4,7,+1, 10, ier)
*	s(2) = +del2l*d2d2lk
*	s(3) = -del2lk*d2d2l
*	somb = s(1) + islk*(s(2) + s(3))
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( lwrite ) print *,'  somb+4= ',somb,s(1),s(2),s(3),islk
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
*
*	s(2) = +del2k*d2d2lk
*	s(3) = -del2lk*d2d2k
*	somb = s(1) + islk*(s(2) + s(3))
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( lwrite ) print *,'  somb+5= ',somb,s(1),s(2),s(3),isji
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
**
*	Second and third term, split m,n
**
*	call ff3dl2(d3d2m,xpi,dpipj,piDpj, 3, i,j,ji,isji,
*     +				k,l,lk,islk, 4, 3,4,7,+1, 10,ier)
*	call ff3dl2(d3d2n,xpi,dpipj,piDpj, 4, i,j,ji,isji,
*     +				k,l,lk,islk, 4, 3,4,7,+1, 10,ier)
*	s(2) = +d3d2m*piDpj(4,4)
*	s(3) = -d3d2n*piDpj(3,4)
*	somb = s(1) + s(2) + s(3)
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( lwrite ) print *,'  somb+6= ',somb,s(1),s(2),s(3)
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
*
*	call ff3dl2(d3d2nm,xpi,dpipj,piDpj, 7, i,j,ji,isji,
*     +				k,l,lk,islk, 4, 3,4,7,+1, 10,ier)
*	s(2) = +d3d2n*piDpj(7,4)
*	s(3) = -d3d2nm*piDpj(4,4)
*	somb = s(1) + s(2) + s(3)
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( lwrite ) print *,'  somb+7= ',somb,s(1),s(2),s(3)
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
*
*	s(2) = +d3d2m*piDpj(7,4)
*	s(3) = -d3d2nm*piDpj(3,4)
*	somb = s(1) + s(2) + s(3)
*	smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	if ( lwrite ) print *,'  somb+8= ',somb,s(1),s(2),s(3)
*	if ( abs(somb) .ge. xloss*smax ) goto 90
*	if ( smax .lt. xmax ) then
*	    save = somb
*	    xmax = smax
*	endif
*
   80	continue
*
*	give up:
*
	somb = save
	call ffwarn(89,ier,somb,xmax)
	if ( lwrite ) then
	    print *,'ffabcd: giving up on somb'
	    print *,'    i,j,k,l = ',i,j,k,l
	    print *,'    xpi     = ',xpi
	endif
   90	continue
	xb = somb/del2s
*  #] normal case b: 
*  #[ normal case d:
	call ff3dl2(s(1),xpi,dpipj,piDpj, 4, i,j,ji,isji, k,l,lk,islk,
     +						4, 3,4,7,+1, 10, ier)
	if ( i .eq. k .and. j .eq. l ) then
	    somd = -2*s(1)
	    if ( lwrite ) s(2) = s(1)
	else
	    call ff3dl2(s(2),xpi,dpipj,piDpj, 4, k,l,lk,islk,
     +				i,j,ji,isji, 4, 3,4,7,+1, 10, ier)
	    somd = - s(1) - s(2)
	    if ( abs(somd) .lt. xloss*abs(s(1)) ) then
		call ffwarn(90,ier,somd,s(1))
	    endif
	endif
*	if ( lwrite ) print *,'  somd = ',somd,s(1),s(2)
	xd = -somd/sdel2s
*  #] normal case d: 
*  #[ normal case c:
  800	continue
	s(1) = xb - xd
	s(2) = xb + xd
	som = s(1)*s(2)
	if ( min(abs(s(1)),abs(s(2))) .ge. xloss*abs(xb) ) goto 220
*	take into account that we know that we only need x+
	if ( xb*xd .ge. 0 ) goto 220
	call ffwarn(91,ier,min(abs(s(1)),abs(s(2))),xb)
	if ( lwrite ) print *,'b-d,b+d,b,d: ',s(1),s(2),xb,xd
  220	continue
	xc = som/xa
*  #] normal case c: 
*  #[ check output:
  900	continue
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    s(1)  = -piDpj(in,kn)*piDpj(jn,3)*piDpj(ln,3)*piDpj(4,4)
     +							**2
	    s(2)  = +piDpj(in,kn)*piDpj(jn,3)*piDpj(ln,4)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(3)  = +piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,3)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(4)  = -piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,4)*piDpj(3,4)
     +							**2
	    s(5)  = +piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,4)*piDpj(3,3)
     +							*piDpj(4,4)
	    s(6)  = -piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,4)*piDpj(3,4)
     +							**2
	    s(7)  = +piDpj(in,ln)*piDpj(jn,3)*piDpj(kn,3)*piDpj(4,4)
     +							**2
	    s(8)  = -piDpj(in,ln)*piDpj(jn,3)*piDpj(kn,4)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(9)  = -piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,3)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(10) = +piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,4)*piDpj(3,4)
     +							**2
	    s(11) = -piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,4)*piDpj(3,3)
     +							*piDpj(4,4)
	    s(12) = +piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,4)*piDpj(3,4)
     +							**2
	    s(13) = +piDpj(in,3)*piDpj(jn,kn)*piDpj(ln,3)*piDpj(4,4)
     +							**2
	    s(14) = -piDpj(in,3)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(15) = -piDpj(in,3)*piDpj(jn,ln)*piDpj(kn,3)*piDpj(4,4)
     +							**2
	    s(16) = +piDpj(in,3)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(17) = -piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,3)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(18) = +piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,4)
     +							**2
	    s(19) = +piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,3)*piDpj(3,4)
     +							*piDpj(4,4)
	    s(20) = -piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,4)
     +							**2
	    s(21) = -piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,3)
     +							*piDpj(4,4)
	    s(22) = +piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,4)
     +							**2
	    s(23) = +piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,3)
     +							*piDpj(4,4)
	    s(24) = -piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,4)
     +							**2
	    xbp = s(1)
	    smaxp = abs(s(1))
	    do 910 ll = 2,24
		xbp = xbp + s(ll)
		smaxp = max(smaxp,abs(xbp))
  910	    continue
	    xbp = xbp/del2s
	    smaxp = abs(smaxp/del2s)
	    if ( rloss*abs(xb-xbp) .gt. precx*smaxp ) then
		print *,'ffabcd: error: xb does not agree with ',
     +			'normal case:'
		print *,'  xb:  ',xb
		print *,'  xbp: ',xbp,smaxp
		print *,'  diff:',xb-xbp
		xb = xbp
	    endif
	    s(1)  = + piDpj(in,kn)*piDpj(jn,3)*piDpj(ln,4)*piDpj(4,4)
	    s(2)  = - piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,4)*piDpj(3,4)
	    s(3)  = + piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,3)*piDpj(4,4)
	    s(4)  = - piDpj(in,kn)*piDpj(jn,4)*piDpj(ln,4)*piDpj(3,4)
	    s(5)  = - piDpj(in,ln)*piDpj(jn,3)*piDpj(kn,4)*piDpj(4,4)
	    s(6)  = + piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,4)*piDpj(3,4)
	    s(7)  = - piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,3)*piDpj(4,4)
	    s(8)  = + piDpj(in,ln)*piDpj(jn,4)*piDpj(kn,4)*piDpj(3,4)
	    s(9)  = - piDpj(in,3)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(4,4)
	    s(10) = + piDpj(in,3)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(4,4)
	    s(11) = + piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,4)
	    s(12) = - piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,4)
	    s(13) = - piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,3)*piDpj(4,4)
	    s(14) = + piDpj(in,4)*piDpj(jn,kn)*piDpj(ln,4)*piDpj(3,4)
	    s(15) = + piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,3)*piDpj(4,4)
	    s(16) = - piDpj(in,4)*piDpj(jn,ln)*piDpj(kn,4)*piDpj(3,4)
	    xdp = s(1)
	    smaxp = abs(s(1))
	    do 920 ll = 2,16
		xdp = xdp + s(ll)
		smaxp = max(smaxp,abs(xdp))
  920	    continue
	    xdp = -xdp/sdel2s
	    smaxp = abs(smaxp/sdel2s)
	    if ( rloss*abs(xd-xdp) .gt. precx*smaxp ) then
		print *,'ffabcd: error: xd does not agree with ',
     +			'normal case:'
		print *,'  xd:  ',xd
		print *,'  xdp: ',xdp,smaxp
		print *,'  diff:',xd-xdp
		xd = xdp
	    endif
	endif
*  #] check output: 
*  #[ and tne final answer:
  990	continue
	call ffroot(dum,aijkl,xa,xb,xc,xd,ier)
*  #] and tne final answer: 
*###] ffabcd: 
	end

*###[ ffca0:
	subroutine ffca0(ca0,d0,xmm,cm,ier)
***#[*comment:***********************************************************
*									*
*	calculates the one-point function (see 't Hooft and		*
*	Veltman) for complex mass					*
*									*
*	Input:	d0	(real) infinity, result of the			*
*			renormalization procedure, the final		*
*			answer should not depend on it.			*
*		xmm	(real) arbitrary mass2, the final answer	*
*			should not depend on this either.		*
*		cm	(complex) mass2, re>0, im<0.			*
*									*
*	Output:	ca0	(complex) A0, the one-point function,		*
*		ier	0 (OK)						*
*									*
*	Calls:	log.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX ca0,cm
	DOUBLE PRECISION d0,xmm
*
*	local variables
*
	DOUBLE COMPLEX cmu,clogm,c
	DOUBLE PRECISION absc,xm
*
*	common blocks etc
*
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*  #] declarations:
*  #[ the real case:
*	
*	adapted to log-and-pole scheme 25-mar-1992
*	
	if ( DIMAG(cm) .eq. 0 .or. nschem .lt. 7 ) then
	    xm = DBLE(cm)
	    call ffxa0(ca0,d0,xmm,xm,ier)
	    return
	endif
*  #] the real case:
*  #[ "calculations":
	if ( xmm .ne. 0 ) then
	    cmu = cm/DBLE(xmm)
	else
	    cmu = cm
	endif
	if ( absc(cmu) .gt. xclogm ) then
	    clogm = log(cmu)
	else
	    clogm = 0
	    if ( cmu .ne. c0 ) call fferr(1,ier)
	endif
	ca0 = - cm * ( clogm - 1 - DBLE(d0) )
*  #] "calculations":
*  #[ debug:
	if (lwrite) then
	    print *,'d0  = ',d0
	    print *,'xmm = ',xmm
	    print *,'cm  = ',cm
	    print *,'ca0 = ',ca0
	endif
*  #] debug:
*###] ffca0:
	end
*###[ ffxa0:
	subroutine ffxa0(ca0,d0,xmm,xm,ier)
***#[*comment:***********************************************************
*									*
*	calculates the one-point function (see 't Hooft and		*
*	Veltman) for real mass						*
*									*
*	Input:	d0	(real) infinity, result of the			*
*			renormalization procedure, the final		*
*			answer should not depend on it.			*
*		xmm	(real) arbitrary mass2, the final answer	*
*			should not depend on this either.		*
*		xm	(real) mass2,					*
*									*
*	Output:	ca0	(complex) A0, the one-point function,		*
*		ier	0 (ok)						*
*									*
*	Calls:	log.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX ca0
	DOUBLE PRECISION d0,xmm,xm
*
*	local variables
*
	DOUBLE PRECISION xmu,xlogm
*
*	common blocks etc
*
	
	include 'ff.h'
*  #] declarations:
*  #[ "calculations":
	if ( xmm .ne. 0 ) then
	    xmu = xm/xmm
	else
	    xmu = xm
	endif
	if ( xmu .gt. xalogm ) then
	    xlogm = log(xmu)
	else
	    xlogm = 0
	    if ( xmu .ne. 0 ) call fferr(2,ier)
	endif
	ca0 = -(xm*(xlogm - 1 - d0))
*  #] "calculations":
*  #[ debug:
	if (lwrite) then
	    print *,'d0  = ',d0
	    print *,'xmm = ',xmm
	    print *,'xm  = ',xm
	    print *,'ca0 = ',ca0
	endif
*  #] debug:
*###] ffxa0:
	end
*###[ ffza0:
	subroutine ffza0(za0,d0,xmm,cm,xm,ndiv,ier)
***#[*comment:***********************************************************
*									*
*	calculates the one-point function (see 't Hooft and		*
*	Veltman) for complex mass in some on-shell scheme		*
*									*
*	Input:	d0	(real) infinity, result of the			*
*			renormalization procedure, the final		*
*			answer should not depend on it.			*
*		xmm	(real) arbitrary mass2, the final answer	*
*			should not depend on this either.		*
*		cm	(complex) mass2, re>0, im<0.			*
*		xm	(real) mass2, used instead of cm if onshel=true	*
*		ndiv	(integer) if >0 return 0 (the number of 	*
*			divergences the A0 should contain)		*
*									*
*	Output:	za0	(complex) A0, the one-point function,		*
*		ier	0 (OK)						*
*									*
*	Calls:	log.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ndiv,ier
	DOUBLE COMPLEX za0,cm
	DOUBLE PRECISION d0,xmm,xm
*
*	common blocks etc
*
	include 'ff.h'
*
*  #] declarations:
*  #[ preliminaries:
*
*	as the A0 cannot contain any on-shell singularities, return 
*	zero when one asks for one.
*
	if ( onshel .and. ndiv .gt. 0 ) then
	    za0 = 0
	    return
	endif
*
*  #] preliminaries:
*  #[ "work":
	if ( nschem.lt.7 ) then
	    call ffxa0(za0,d0,xmm,xm,ier)
	else
	    call ffca0(za0,d0,xmm,cm,ier)
	endif
*  #] "work":
*###] ffza0:
	end

*###[ ffcc0p:
	subroutine ffcc0p(cs3,ipi12,isoort,clogi,ilogi,cpi,cpipj,
     +		cpiDpj,sdel2,cel2si,etalam,etami,delpsi,alpha,npoin,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the threepoint function closely following		*
*	recipe in 't Hooft & Veltman, NP B(183) 1979.			*
*	Bjorken and Drell metric is used nowadays!			*
*									*
*	    p2	^ |							*
*		| |							*
*		 / \							*
*	      m2/   \m3 						*
*	p1     /     \	p3						*
*	<-    /  m1   \ ->						*
*	------------------------					*
*									*
*	Input:	cpi(1-3)   (complex)	pi squared (,2=untransformed	*
*					when npoin=4)			*
*		cpi(4-6)   (complex)	internal mass squared		*
*		cpipj(6,6)   (complex)	cpi(i)-cpi(j)			*
*		cpiDpj(6,6)   (complex)	pi(i).pi(j)			*
*									*
*	Output: cs3	 (complex)(48)	C0, not yet summed.		*
*		ipi12	 (integer)(3)	factors pi^2/12, not yet summed	*
*		cslam	 (complex)	lambda(p1,p2,p3).		*
*		isoort	 (integer)(3)	indication of he method used	*
*		ier	 (integer)	0=ok, 1=inaccurate, 2=error	*
*									*
*	Calls:	ffcel2,ffcoot,ffccyz,ffcdwz,ffcs3,ffcs4			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(8),isoort(8),ilogi(3),npoin,ier
	DOUBLE COMPLEX cs3(80),clogi(3),cpi(6),cpipj(6,6),
     +		cpiDpj(6,6),sdel2,cel2si(3),etalam,etami(6),
     +		delpsi(3),alpha(3)
*
*	local variables:
*
	integer i,j,k,ip,ierw,jsoort(8),iw,ismall(3),ier0
	logical l4,l4pos
	DOUBLE COMPLEX c,cs,zfflog,cs1,cs2,cs4,ci
	DOUBLE COMPLEX cy(4,3),cz(4,3),cw(4,3),cdyz(2,2,3),
     +		cdwy(2,2,3),cdwz(2,2,3),cd2yzz(3),cd2yww(3)
	DOUBLE COMPLEX csdl2i(3)
*	DOUBLE COMPLEX cyp,cym,ca,cb,cc,cd
	DOUBLE COMPLEX zfflo1
	DOUBLE PRECISION absc
*FOR ABSOFT ONLY
*	DOUBLE COMPLEX csqrt
*	external csqrt
*
*	common blocks:
*
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    ier0 = 0
	    call ffchck(cpi,cpipj,6,ier0)
	    if ( ier0 .ne. 0 ) print *,'ffcc0p: error: ',
     +		'transformed momenta wrong'
	endif
*  #] check input:
*  #[ get roots etc:
*  #[   get z-roots:
	if ( npoin .ne. 3 ) then
	    l4pos = .FALSE.
	else
	    l4pos = l4also
	endif
	if ( lwrite ) print '(a)','  ##[ get roots: (ffcc0p)'
	do 10 i=1,3
*
*	    get roots (y,z)
*
	    ip = i+3
*	    first get the roots
	    j = i+1
	    if ( j .eq. 4 ) j = 1
	    csdl2i(i) = sqrt(-cel2si(i))
	    if ( cpi(ip) .eq. 0 ) then
		if ( i .eq. 1 .and. alpha(3) .eq. 0 .or.
     +		     i .eq. 3 .and. alpha(1) .eq. 0 ) then
		    isoort(2*i-1) = 0
		    isoort(2*i) = 0
		    l4pos = .FALSE.
		    goto 10
		endif
	    endif
	    call ffccyz(cy(1,i),cz(1,i),cdyz(1,1,i),cd2yzz(i),i,
     +		sdel2,csdl2i(i),etalam,etami,delpsi(i),
     +		cpi,cpiDpj,isoort(2*i-1),6,ier)
   10	continue
*	if ( lwrite ) then
*	    print *,'cy(1)  = ',cy(2,1)
*	    print *,'vgl    = ',cy(4,2)/alpha(3)
*	    print *,'cy(3)1 = ',cy(4,3)
*	    print *,'vgl    = ',cy(2,2)/alpha(1)
*	endif
*  #]   get z-roots:
*  #[   get w-roots:
*
*	get w's:
*
	ierw = 0
	l4 = .FALSE.
	if ( isoort(4) .eq. 0 ) then
	    call fferr(10,ierw)
	    goto 90
	endif
	do 70 iw = 1,3,2
	if ( .not. l4pos .or. alpha(4-iw) .eq. 0 ) then
	    jsoort(2*iw-1) = 0
	    jsoort(2*iw) = 0
	    l4pos = .FALSE.
	else
	jsoort(2*iw-1) = -1
	jsoort(2*iw) = -1
	cd2yww(iw) = -cd2yzz(2)/alpha(4-iw)
	do 20 j=1,2
	    cw(j+iw-1,iw) = cz(j+3-iw,2)/alpha(4-iw)
	    cw(j+3-iw,iw) = 1 - cw(j+iw-1,iw)
	    if ( absc(cw(j+3-iw,iw)) .lt. xloss ) then
		if (lwrite) print *,'   cw(',j+3-iw,iw,')  = ',
     +			cw(j+3-iw,iw),x1
		cs = cz(j+iw-1,2) - alpha(iw)
		if ( absc(cs) .lt. xloss*absc(alpha(iw)) ) then
		    ierw = 1
		    goto 70
		endif
		cw(j+3-iw,iw) = cs/alpha(4-iw)
		if (lwrite) print *,'   cw(',j+3-iw,iw,')+ = ',
     +			cw(j+3-iw,iw),absc(alpha(iw))/absc(alpha(4-iw))
	    endif
	    cdwy(j,2,iw) = cdyz(2,j,2)/alpha(4-iw)
	    do 15 i=1,2
		cdwz(j,i,iw) = cw(j,iw) - cz(i,iw)
		if ( absc(cdwz(j,i,iw)) .ge. xloss*absc(cw(j,iw)) )
     +								goto 14
		if ( lwrite ) print *,'  cdwz(',j,i,iw,')  = ',
     +			cdwz(j,i,iw),absc(cw(j,iw))
		cdwz(j,i,iw) = cz(i+2,iw) - cw(j+2,iw)
		if ( lwrite ) print *,'  cdwz(',j,i,iw,')+ = ',
     +			cdwz(j,i,iw),absc(cw(j+2,iw))
		if ( absc(cdwz(j,i,iw)) .ge. xloss*absc(cw(j+2,iw)) )
     +								goto 14
		cdwz(j,i,iw) = cdwy(j,2,iw) + cdyz(2,i,iw)
		if ( lwrite ) print *,'  cdwz(',j,i,iw,')++= ',
     +			cdwz(j,i,iw),absc(cdwy(j,2,iw))
		if ( absc(cdwz(j,i,iw)) .ge. xloss*absc(cdwy(j,2,iw)) )
     +								goto 14
		l4 = .TRUE.
		call ffcdwz(cdwz(1,1,iw),cw(1,iw),cz(1,iw),j,i,iw,
     +			alpha(1),alpha(3),cpi,cpipj,cpiDpj,csdl2i,
     +			sdel2,6,ierw)
   14		continue
   15	    continue
   20	continue
	endif
   70	continue
*  #]   get w-roots:
*  #[   write output:
	if ( lwrite ) then
	    print *,'ffcc0p: found roots:'
	    do 85 i=1,3
		print *,'  k = ',i
		if ( isoort(2*i) .ne. 0 ) then
		    print *,'  cym,cym1 = ',cy(1,i),cy(3,i),
     +			'(not used)'
		    print *,'  cyp,cyp1 = ',cy(2,i),cy(4,i)
		    print *,'  czm,czm1 = ',cz(1,i),cz(3,i)
		    print *,'  czp,czp1 = ',cz(2,i),cz(4,i)
		    if ( i .ne. 2 .and. l4pos ) then
			print *,'  cwm,cwm1 = ',cw(1,i),cw(3,i)
			print *,'  cwp,cwp1 = ',cw(2,i),cw(4,i)
		    endif
		else
		    if ( isoort(2*i-1) .eq. 0 ) then
			print *,'  no roots, all is zero'
		    else
			print *,'  cyp,cyp1 = ',cy(2,i),
     +				cy(4,i)
			print *,'  czp,czp1 = ',cz(2,i),
     +				cz(4,i)
			if ( i .ne. 2 .and. jsoort(2*i-1) .ne. 0 ) then
			    print *,'  cwm,cwm1 = ',cw(1,i),cw(3,i)
			    print *,'  cwp,cwp1 = ',cw(2,i),cw(4,i)
			endif
		    endif
		endif
   85	    continue
   86	    continue
	    print '(a)','  ##] get roots:'
	endif
*  #]   write output:
*  #[   which case:
   90	if ( l4 ) then
	    if ( DIMAG(alpha(1)) .ne. 0 ) then
		if ( lwrite ) print *,'ffcc0p: cannot handle unphysical'
     +			,' momenta in 16 dilogs (yet)'
		l4pos = .FALSE.
	    elseif ( ierw .ge. 1 ) then
		l4pos = .FALSE.
	    else
		ier = max(ier,ierw)
	    endif
	endif
*  #]   which case:
*  #] get roots etc:
*  #[ logarithms for 4point function:
	if ( npoin .eq. 4 ) then
	if ( lwrite ) print '(a)','  ##[ logarithms for Ai<0:'
	do 95 i = 1,3
	    ismall(i) = 0
	    if ( ilogi(i) .ne. -999 ) goto 95
	    if ( isoort(2*i) .ne. 0 ) then
*		maybe add sophisticated factors i*pi later
		c = -cdyz(2,1,i)/cdyz(2,2,i)
		if ( lwrite ) then
*		    fantasize imag part, but suppress error message
		    print *,'c = ',c
		    clogi(i) = zfflog(c,1,c1,ier0)
		    print *,'clogi  = ',clogi(i)
		endif
		if ( absc(c-1) .lt. xloss ) then
		    cs = cd2yzz(i)/cdyz(2,2,i)
		    clogi(i) = zfflo1(cs,ier)
		    ilogi(i) = 0
		    ismall(i) = 1
		    if ( lwrite ) then
			print *,'c = ',c
			print *,'c+= ',1-cs
		    endif
		elseif ( DBLE(c) .gt. 0 ) then
		    clogi(i) = zfflog(c,0,c0,ier)
		    ilogi(i) = 0
		else
		    if ( absc(c+1) .lt. xloss ) then
			cs = -2*csdl2i(i)/cdyz(2,2,i)/
     +				DBLE(cpi(i+3))
			clogi(i) = zfflo1(cs,ier)
			ismall(i) = -1
			if ( lwrite ) then
			    print *,'c = ',c
			    print *,'c+= ',-1+cs
			endif
		    else
			cs = 0
			clogi(i) = zfflog(-c,0,c0,ier)
		    endif
		    if ( DIMAG(c).lt.0 .or. DIMAG(cs).lt.0 ) then
			ilogi(i) = -1
		    elseif ( DIMAG(c).gt.0 .or. DIMAG(cs).gt.0 ) then
			ilogi(i) = +1
		    elseif ( DBLE(cdyz(2,2,i)) .eq. 0 ) then
			ilogi(i)=-nint(sign(DBLE(x1),DBLE(cpi(i+3))))
			ier = ier + 50
			print *,'doubtful imaginary part ',ilogi(i)
		    endif
		    if ( abs(DIMAG(c)).lt.precc*absc(c) .and.
     +			abs(DIMAG(cs)).lt.precc*absc(cs) ) then
			print *,'ffcc0p: error: imaginary part doubtful'
			ier = ier + 50
		    endif
		endif
		if ( lwrite ) print *,'clogi+ = ',clogi(i)+
     +			DCMPLX(x0,pi)*ilogi(i)
	    endif
   95	continue
	do 96 i=1,3
	    j = i + 1
	    if ( j .eq. 4 ) j = 1
	    if ( abs(ismall(i)+ismall(j)) .eq. 2 .and. absc(clogi(i)+
     +			clogi(j)) .lt. xloss*absc(clogi(i)) ) then
		print *,'eerst: ',clogi(i)+clogi(j)
*		assume that we got here because of complex sqrt(-delta)
		ci = DCMPLX(DBLE(0),DBLE(1))
		cs1=-2*ci*DIMAG(cy(2,i))*csdl2i(j)/DBLE(cpi(j+3))/
     +			(cdyz(2,2,i)*cdyz(2,2,j))
		cs2=-2*ci*DIMAG(cy(2,j))*csdl2i(i)/DBLE(cpi(i+3))/
     +			(cdyz(2,2,i)*cdyz(2,2,j))
		cs = cs1 + cs2
		if ( absc(cs) .lt. xloss*absc(cs1) ) then
		    if ( lwrite ) print *,'Eerste poging:',cs,cs1,cs2
		    k = j+1
		    if ( k .eq. 4 ) k = 1
		    cs1 = cpipj(j+3,i+3)*cpi(j)
		    cs2 = cpiDpj(k+3,j)*cpiDpj(j+3,j)
		    cs4 = -cpiDpj(k+3,j)*cpiDpj(i+3,j)
		    cs = cs1 + cs2 + cs4
		    if ( lwrite ) then
			print *,'csdl2i(i)-csdl2i(j) = ',
     +			    csdl2i(i)-csdl2i(j),absc(csdl2i(i))
			print *,'csdl2i(i)-csdl2i(j)+= ',cs/
     +				(csdl2i(i)+csdl2i(j))
		    endif
		    if ( absc(cs) .lt. xloss*max(absc(cs1),absc(cs2),
     +		    		absc(cs4)) ) then
			print *,'ffcc0p: cancellations in delj-deli'
			goto 96
		    endif
		    cs1=ci*DIMAG(cy(2,j))*cs/(csdl2i(i)+csdl2i(j))
		    call ffcl2t(cs2,cpiDpj,k+3,j,4,5,6,+1,-1,6,ier)
		    cs2 = -cs2*csdl2i(j)/sdel2/DBLE(cpi(j+3))
		    cs = cs1 + cs2
		    if ( lwrite ) print *,'Tweede poging:',cs,cs1,cs2
		    if ( absc(cs) .lt. xloss*absc(cs1) ) then
			print *,'ffcc0p: cancellations in extra terms'
			goto 96
		    endif
		    cs = -2*cs/DBLE(cpi(i+3))/(cdyz(2,2,i)*
     +			cdyz(2,2,j))
		endif
		clogi(i) = zfflo1(cs,ier)
		clogi(j) = 0
		print *,'nu:    ',clogi(i)+clogi(j)
	    endif
   96	continue
	if ( lwrite ) print '(a)','  ##] logarithms for Ai<0:'
	endif
*  #] logarithms for 4point function:
*  #[ integrals:
	if ( .not. l4 .or. .not. l4pos ) then
*	    normal case
	    do 200 i=1,3
		if ( lwrite ) print '(a,i1,a)','  ##[ s3 nr ',i,':'
		j = 2*i-1
		if ( isoort(2*i-1) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffcc0p: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j),isoort(j+1)
		    endif
		else
		    call ffcs3(cs3(20*i-19),ipi12(2*i-1),cy(1,i),
     +			cz(1,i),cdyz(1,1,i),cd2yzz(i),cpi,cpiDpj,
     +			i,6,isoort(j),ier)
		endif
		if ( lwrite ) print '(a,i1,a)','  ##] s3 nr ',i,':'
  200	    continue
	    isoort(7) = 0
	    isoort(8) = 0
	else
	    if ( lwrite ) print '(a)','  ##[ s4 nr 1:'
	    isoort(3) = jsoort(1)
	    isoort(4) = jsoort(2)
	    call ffcs4(cs3(1),ipi12(1),cw(1,1),cy(1,1),
     +			cz(1,1),cdwy(1,1,1),cdwz(1,1,1),cdyz(1,1,1),
     +			cd2yww(1),cd2yzz(1),cpi,cpiDpj,
     +			cpi(5)*alpha(3)**2,etami,1,6,isoort(1),ier)
	    if ( lwrite ) print '(a)','  ##] s4 nr 1:'
	    if ( lwrite ) print '(a)','  ##[ s4 nr 2:'
	    isoort(7) = jsoort(5)
	    isoort(8) = jsoort(6)
	    call ffcs4(cs3(41),ipi12(1),cw(1,3),cy(1,3),
     +			cz(1,3),cdwy(1,1,3),cdwz(1,1,3),cdyz(1,1,3),
     +			cd2yww(3),cd2yzz(3),cpi,cpiDpj,
     +			cpi(5)*alpha(1)**2,etami,3,6,isoort(5),ier)
	    if ( lwrite ) print '(a)','  ##] s4 nr 2:'
	endif
*  #] integrals:
*###] ffcc0p:
	end
*###[ ffccyz:
	subroutine ffccyz(cy,cz,cdyz,cd2yzz,ivert,csdelp,csdels,etalam,
     +				etami,delps,xpi,piDpj,isoort,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*	cz(1,2) = (-p(ip1).p(is2) +/- csdelp)/xpi(ip1)			*
*	cy(1,2) = (-p(ip1).p(is2) +/- sdisc)/xpi(ip1)			*
*			cdisc = csdels + etaslam*xpi(ip1)		*
*									*
*	cy(3,4) = 1-cy(1,2)						*
*	cz(3,4) = 1-cz(1,2)						*
*	cdyz(i,j) = cy(i) - cz(j)					*
*									*
*	Input:	ivert		(integer)	defines the vertex	*
*		csdelp		(complex)	sqrt(lam(p1,p2,p3))/2	*
*		csdels		(complex)	sqrt(lam(p,ma,mb))/2	*
*		etalam		(complex)	det(si.sj)/det(pi.pj)	*
*		etami(6)	(complex)	si.si - etalam		*
*		xpi(ns)		(complex)	standard		*
*		piDpj(ns,ns)	(complex)	standard		*
*		ns		(integer)	dim of xpi,piDpj	*
*									*
*	Output:	cy(4),cz(4),cdyz(4,4)	(complex)	see above	*
*		ier		(integer)	usual error flag	*
*									*
*	Calls:	fferr,ffroot						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ivert,ns,ier,isoort(2)
	DOUBLE COMPLEX cy(4),cz(4),cdyz(2,2),cd2yzz,csdelp,csdels
	DOUBLE COMPLEX etalam,etami(6),delps,xpi(6),piDpj(6,6)
*
*	local variables:
*
	integer i,j,ip1,ip2,ip3,is1,is2,is3,ier0
	DOUBLE COMPLEX cverg,cdisc,c,check,dpipj(6,6)
	DOUBLE PRECISION absc,rloss
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ set up pointers:
	if ( lwrite ) print *,'ffccyz: ivert = ',ivert
	if ( ltest .and. ns .ne. 6 ) then
	    print *,'ffccyz: error: ns != 6 !!',ns
	    stop
	endif
	is1 = ivert
	is2 = ivert+1
	if ( is2 .eq. 4 ) is2 = 1
	is3 = ivert-1
	if ( is3 .eq. 0 ) is3 = 3
	ip1 = is1 + 3
	ip2 = is2 + 3
	ip3 = is3 + 3
*  #] set up pointers:
*  #[ check input:
	if ( ltest ) then
	    ier0 = ier
	    dpipj(1,1) = 1
	    call ffcl2p(cverg,xpi,dpipj,piDpj,ip1,ip2,ip3,is1,is2,is3,6,
     +	    	ier0)
	    rloss = xloss*DBLE(10)**(-mod(ier0,50))
	    if ( rloss*absc(cverg-delps).gt.precc*absc(cverg) ) print *,
     +	    	'ffccyz: error: delps <> cverg',delps,cverg,delps-cverg
	    ier0 = ier
	    call ffcel2(cverg,piDpj,6,ip1,ip2,ip3,1,ier0)
	    rloss = xloss*DBLE(10)**(-mod(ier0,50))
	    if ( rloss*absc(cverg+csdelp**2) .gt. precc*absc(cverg) ) 
     +	    	print *,'ffccyz: error: csdelp**2 incorrect ',
     +	    	csdelp**2,-cverg,csdelp**2+cverg
	    ier0 = ier
	    call ffcel3(cverg,xpi,piDpj,6,ier0)
	    check = etami(is2)-xpi(is2)-cverg/csdelp**2
	    rloss = xloss**2*DBLE(10)**(-mod(ier0,50))
	    if ( rloss*absc(check) .gt. precc*max(absc(etami(is2)),
     +	    	absc(xpi(is2)),absc(cverg/csdelp**2)) ) print *,
     +	    	'ffccyz: error: etami(',is2,') incorrect ',
     +	    	etami(is2),xpi(is2)+cverg/csdelp**2,check,ier0
	endif
*  #] check input:
*  #[ xk = 0:
	if ( xpi(ip1) .eq. 0 ) then
	    isoort(2) = 0
	    if ( piDpj(is1,ip1) .eq. 0 ) then
		isoort(1) = 0
		if (lwrite) print *,'  ck = 0, cm1 = cm2, so cs3 = 0'
		return
	    endif
	    if ( DIMAG(etalam).ne.0 ) then
	    	isoort(1) = -1
	    else
	    	isoort(1) = -3
	    endif
	    cy(1) = etami(is2) / piDpj(is1,ip1) /2
	    cy(2) = cy(1)
	    cy(3) = - etami(is1) / piDpj(is1,ip1) /2
	    cy(4) = cy(3)
	    cz(1) = xpi(is2) / piDpj(is1,ip1) /2
	    cz(2) = cz(1)
	    cz(3) = - xpi(is1) / piDpj(is1,ip1) /2
	    cz(4) = cz(3)
	    cdyz(1,1) = - etalam / piDpj(is1,ip1) /2
	    cdyz(1,2) = cdyz(1,1)
	    cdyz(2,1) = cdyz(1,1)
	    cdyz(2,2) = cdyz(1,1)
	    if ( ltest ) then
*		check whether we have the correct root ...
		call ffcl2p(cverg,xpi,dpipj,piDpj,ip1,ip2,ip3,
     +					is1,is2,is3,6,ier)
		cdisc = cverg/csdelp
		check = piDpj(ip1,is2) + cdisc
		if ( xloss*absc(check) .gt. precc*max(absc(piDpj(
     +			ip1,is2)),absc(cdisc)) ) then
		    call fferr(36,ier)
		    if ( lwrite ) then
			print *,'piDpj(',ip1,is2,') = ',piDpj(ip1,is2)
			print *,'cdisc = ',cdisc
			print *,'diff  = ',check
		    endif
		endif
	    endif
	    return
	endif
*  #] xk = 0:
*  #[ get cy(1,2),cz(1,2):
	if ( DIMAG(etalam).ne.0 ) then
	    isoort(1) = -1
	    isoort(2) = -1
	else
	    isoort(1) = -3
	    isoort(2) = -3
	endif
	call ffcoot(cz(1),cz(2),xpi(ip1),piDpj(ip1,is2),xpi(is2),
     +							csdels,ier)
	cdisc = delps/csdelp
	call ffcoot(cy(1),cy(2),xpi(ip1),piDpj(ip1,is2),etami(is2),
     +							cdisc,ier)
*  #] get cy(1,2),cz(1,2):
*  #[ get cy(3,4),cz(3,4):
	cz(4) = 1-cz(2)
	cz(3) = 1-cz(1)
	if ( absc(cz(3)) .lt. xloss .or. absc(cz(4)) .lt. xloss ) then
	    call ffcoot(cz(4),cz(3),xpi(ip1),-piDpj(ip1,is1),
     +						xpi(is1),csdels,ier)
	endif
*	the imaginary part may not be accurate in these cases, take
*	some precautions:
	if ( cz(3) .eq. 0 ) cz(1) = 1
	if ( cz(4) .eq. 0 ) cz(2) = 1
	if ( DIMAG(cz(1)).eq.0 )
     +		cz(1) = DCMPLX(DBLE(cz(1)),-DIMAG(cz(3)))
	if ( DIMAG(cz(2)).eq.0 )
     +		cz(2) = DCMPLX(DBLE(cz(2)),-DIMAG(cz(4)))
	if ( DIMAG(cz(1)) .gt. 0 .neqv. DIMAG(cz(3)) .lt. 0 ) then
	    if ( abs(DBLE(cz(1))) .ge. abs(DBLE(cz(3))) ) then
		cz(1) = DCMPLX(DBLE(cz(1)),-DIMAG(cz(3)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part z1 changed to -z3'
	    else
		cz(3) = DCMPLX(DBLE(cz(3)),-DIMAG(cz(1)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part z3 changed to -z1'
	    endif
	endif
	if ( DIMAG(cz(2)) .gt. 0 .neqv. DIMAG(cz(4)) .lt. 0 ) then
	    if ( abs(DBLE(cz(2))) .ge. abs(DBLE(cz(4))) ) then
		cz(2) = DCMPLX(DBLE(cz(2)),-DIMAG(cz(4)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part z2 changed to -z4'
	    else
		cz(4) = DCMPLX(DBLE(cz(4)),-DIMAG(cz(2)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part z4 changed to -z2'
	    endif
	endif
	cy(4) = 1-cy(2)
	cy(3) = 1-cy(1)
	if ( absc(cy(3)) .lt. xloss .or. absc(cy(4)) .lt. xloss ) then
	    call ffcoot(cy(4),cy(3),xpi(ip1),-piDpj(ip1,is1),
     +						etami(is1),cdisc,ier)
	endif
	if ( cy(3) .eq. 0 ) cy(1) = 1
	if ( cy(4) .eq. 0 ) cy(2) = 1
	if ( DIMAG(cy(1)).eq.0 )
     +		cy(1) = DCMPLX(DBLE(cy(1)),-DIMAG(cy(3)))
	if ( DIMAG(cy(2)).eq.0 )
     +		cy(2) = DCMPLX(DBLE(cy(2)),-DIMAG(cy(4)))
	if ( DIMAG(cy(1)) .gt. 0 .neqv. DIMAG(cy(3)) .lt. 0 ) then
	    if ( abs(DBLE(cy(1))) .ge. abs(DBLE(cy(3))) ) then
		cy(1) = DCMPLX(DBLE(cy(1)),-DIMAG(cy(3)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part y1 changed to -y3'
	    else
		cy(3) = DCMPLX(DBLE(cy(3)),-DIMAG(cy(1)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part y3 changed to -y1'
	    endif
	endif
	if ( DIMAG(cy(2)) .gt. 0 .neqv. DIMAG(cy(4)) .lt. 0 ) then
	    if ( abs(DBLE(cy(2))) .ge. abs(DBLE(cy(4))) ) then
		cy(2) = DCMPLX(DBLE(cy(2)),-DIMAG(cy(4)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part y2 changed to -y4'
	    else
		cy(4) = DCMPLX(DBLE(cy(4)),-DIMAG(cy(2)))
		if ( lwrite ) print *,'ffccyz: comment: imaginary ',
     +			'part y4 changed to -y2'
	    endif
	endif
*  #] get cy(3,4),cz(3,4):
*  #[ get cdyz:
*	Note that cdyz(i,j) only exists for i,j=1,2!
	if ( absc(cdisc+csdels) .gt. xloss*absc(cdisc) ) then
	    cdyz(2,1) = ( cdisc + csdels )/xpi(ip1)
	    cdyz(2,2) = etalam/(xpi(ip1)*cdyz(2,1))
	else
	    cdyz(2,2) = ( cdisc - csdels )/xpi(ip1)
	    cdyz(2,1) = etalam/(xpi(ip1)*cdyz(2,2))
	endif
	cdyz(1,1) = -cdyz(2,2)
	cdyz(1,2) = -cdyz(2,1)
	cd2yzz = 2*cdisc/xpi(ip1)
*  #] get cdyz:
*  #[ test output:
	if ( ltest ) then
	    rloss = xloss*DBLE(10)**(-1-mod(ier,50))
	    do 99 i=1,2
		if ( rloss*absc(cy(i)+cy(i+2)-1) .gt. precc*max(absc(
     +		    cy(i)),absc(cy(i+2)),x1)) print *,'ffccyz: error: ',
     +		    'cy(',i+2,')<>1-cy(',i,'):',cy(i+2),cy(i),cy(i+2)+
     +		    cy(i)-1
		if ( rloss*absc(cz(i)+cz(i+2)-1) .gt. precc*max(absc(
     +		    cz(i)),absc(cz(i+2)),x1)) print *,'ffccyz: error: ',
     +		    'cz(',i+2,')<>1-cz(',i,'):',cz(i+2),cz(i),cz(i+2)+
     +		    cz(i)-1
		do 98 j=1,2
		    if ( rloss*absc(cdyz(i,j)-cy(i)+cz(j)) .gt. precc*
     +			max(absc(cdyz(i,j)),absc(cy(i)),absc(cz(j))) )
     +			print *,'ffccyz: error: cdyz(',i,j,') <> cy(',
     +			i,')-','cz(',j,'):',cdyz(i,j),cy(i),cz(j),
     +			cdyz(i,j)-cy(i)+cz(j)
   98		continue
   99	    continue
	    if ( rloss*absc(cd2yzz-2*cy(2)+cz(1)+cz(2)) .gt. precc*max(
     +		absc(cd2yzz),x2*absc(cy(2)),absc(cz(1)),absc(cz(2))) )
     +		print *,'ffccyz: error: cd2yzz <> 2*cy(2)+cz(1)+cz(2):',
     +		cd2yzz,2*cy(2),cz(1),cz(2),cd2yzz-2*cy(2)+cz(1)+cz(2)
	endif
*  #] test output:
*###] ffccyz:
	end
*###[ ffcel2:
	subroutine ffcel2(del2,piDpj,ns,i1,i2,i3,lerr,ier)
*************************************************************************
*	calculate in a numerically stable way				*
*	del2(piDpj(i1,i1),piDpj(i2,i2),piDpj(i3,i3)) =			*
*		= piDpj(i1,i1)*piDpj(i2,i2) - piDpj(i1,i2)^2		*
*		= piDpj(i1,i1)*piDpj(i3,i3) - piDpj(i1,i3)^2		*
*		= piDpj(i2,i2)*piDpj(i3,i3) - piDpj(i2,i3)^2		*
*	ier is the usual error flag.					*
*************************************************************************
	implicit none
*
*	arguments:
*
	integer ns,i1,i2,i3,lerr,ier
	DOUBLE COMPLEX del2,piDpj(ns,ns)
*
*	local variables
*
	DOUBLE COMPLEX s1,s2,cc
	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*	calculations
*
	if ( absc(piDpj(i1,i2)) .lt. absc(piDpj(i1,i3)) .and.
     +	     absc(piDpj(i1,i2)) .lt. absc(piDpj(i2,i3)) ) then
	    s1 = piDpj(i1,i1)*piDpj(i2,i2)
	    s2 = piDpj(i1,i2)**2
	elseif ( absc(piDpj(i1,i3)) .lt. absc(piDpj(i2,i3)) ) then
	    s1 = piDpj(i1,i1)*piDpj(i3,i3)
	    s2 = piDpj(i1,i3)**2
	else
	    s1 = piDpj(i2,i2)*piDpj(i3,i3)
	    s2 = piDpj(i2,i3)**2
	endif
	del2 = s1 - s2
	if ( absc(del2) .lt. xloss*absc(s2) ) then
	    if ( lerr .eq. 0 ) then
*		we know we have another chance
		if ( del2.ne.0 ) then
		    ier = ier + int(log10(xloss*absc(s2)/absc(del2)))
		else
		    ier = ier + int(log10(xloss*absc(s2)/xclogm))
		endif
	    else
		if ( lwarn ) call ffwarn(71,ier,absc(del2),absc(s2))
	    endif
	endif
*###] ffcel2:
	end
*###[ ffcl2p:
	subroutine ffcl2p(delps1,xpi,dpipj,piDpj,
     +		ip1,ip2,ip3,is1,is2,is3,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*	delta_{ip1,is2}^{ip1,ip2}					*
*	ier is the usual error flag.					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ip1,ip2,ip3,is1,is2,is3,ier
	DOUBLE COMPLEX delps1,xpi(ns),dpipj(ns,ns),piDpj(ns,ns)
*
*	local variables
*
	DOUBLE COMPLEX s1,s2,s3,som,c
	DOUBLE PRECISION xmax,absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ stupid tree:
*	1
	s1 = xpi(ip1)*piDpj(ip2,is2)
	s2 = piDpj(ip1,ip2)*piDpj(ip1,is2)
	delps1 = s1 - s2
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( lwrite ) print *,'  delps1   = ',delps1,absc(s1)
	som = delps1
	xmax = absc(s1)
*	2
	s1 = piDpj(ip1,ip2)*piDpj(ip3,is2)
	s2 = piDpj(ip1,ip3)*piDpj(ip2,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+1 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	3
	s1 = piDpj(ip1,ip3)*piDpj(ip1,is2)
	s2 = xpi(ip1)*piDpj(ip3,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+2 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	4
	s1 = xpi(ip1)*piDpj(ip2,is1)
	s2 = piDpj(ip1,is1)*piDpj(ip1,ip2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+3 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	5
	s1 = piDpj(ip1,is2)*piDpj(ip2,is1)
	s2 = piDpj(ip1,is1)*piDpj(ip2,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+4 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	6
	s1 = piDpj(ip1,ip2)*piDpj(ip3,is1)
	s2 = piDpj(ip1,ip3)*piDpj(ip2,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+5 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	7
	s1 = piDpj(ip2,is2)*piDpj(ip3,is1)
	s2 = piDpj(ip2,is1)*piDpj(ip3,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+6 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	8
	s1 = piDpj(ip1,ip3)*piDpj(ip1,is1)
	s2 = xpi(ip1)*piDpj(ip3,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+7 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*	9
	s1 = piDpj(ip1,is1)*piDpj(ip3,is2)
	s2 = piDpj(ip1,is2)*piDpj(ip3,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+8 = ',delps1,absc(s1)
	if ( absc(delps1) .ge. xloss*absc(s1) ) goto 100
	if ( absc(s1) .lt. xmax ) then
	    som = delps1
	    xmax = absc(s1)
	endif
*10	22-nov-1993 yet another one
	if ( dpipj(1,1).eq.0 ) then
	    s1 = +xpi(ip1)*dpipj(is3,is2)/2
	    s2 = -piDpj(ip1,ip2)*dpipj(is2,is1)/2
	    s3 = +xpi(ip1)*piDpj(ip2,ip3)/2
	    delps1 = s1+s2+s3
	    if ( lwrite ) print *,'  delps1+9 = ',delps1,s1,s2,s3
	    if ( absc(delps1) .ge. xloss*max(absc(s1),absc(s2)) ) 
     +	    	goto 100
	    if ( max(absc(s1),absc(s2)) .lt. xmax ) then
		som = delps1
		xmax = absc(s1)
	    endif
	endif
*	NO possibility
	delps1 = som
	if ( lwarn ) call ffwarn(92,ier,absc(delps1),xmax)
  100	continue
*  #] stupid tree:
*###] ffcl2p:
	end
*###[ ffcl2s:
	subroutine ffcl2s(delps1,xpi,piDpj,in,jn,jin,isji,
     +					kn,ln,lkn,islk,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*		\delta_{si,sj}^{sk,sl}					*
*									*
*	with p(ji) = isji*(sj-si)					*
*	     p(lk) = islk*(sl-sk)					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer in,jn,jin,isji,kn,ln,lkn,islk,ns,ier
	DOUBLE COMPLEX delps1,xpi(ns),piDpj(ns,ns)
*
*	local variables
*
	integer ii,jj,i,j,ji,k,l,lk,ihlp
	DOUBLE COMPLEX s1,s2,som,c
	DOUBLE PRECISION smax,absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    if ( abs(isji) .ne. 1 ) print *,'ffcl2s: error: abs(isji) ',
     +		' <> 1 but ',isji
	    if ( abs(islk) .ne. 1 ) print *,'ffcl2s: error: abs(islk) ',
     +		' <> 1 but ',islk
	endif
*  #] check input:
*  #[ stupid tree:
	som = 0
	smax = 0
	i = in
	j = jn
	ji = jin
	k = kn
	l = ln
	lk = lkn
	do 20 ii=1,3
	    do 10 jj=1,3
		s1 = piDpj(i,k)*piDpj(j,l)
		s2 = piDpj(i,l)*piDpj(j,k)
		delps1 = s1 - s2
		if ( ii .gt. 1 ) delps1 = isji*delps1
		if ( jj .gt. 1 ) delps1 = islk*delps1
		if ( ii .eq. 3 .neqv. jj .eq. 3 ) delps1 = -delps1
		if ( absc(delps1) .ge. xloss*absc(s1) ) goto 30

		if ( lwrite ) print *,'  delps1+',3*ii+jj-3,'=',delps1,
     +			absc(s1)
*
*		Save the most accurate estimate so far:
		if ( ii .eq. 1 .and. jj .eq. 1 .or. absc(s1) .lt. smax
     +			) then
		    som = delps1
		    smax = absc(s1)
		endif
*
*		rotate the jj's
		ihlp = k
		k = l
		l = lk
		lk = ihlp
   10	    continue
*
*	    and the ii's
	    ihlp = i
	    i = j
	    j = ji
	    ji = ihlp
   20	continue
	delps1 = som
	if ( lwarn ) call ffwarn(83,ier,absc(delps1),smax)
   30	continue
	if ( lwrite .and. 3*ii+jj.ne.4 ) print *,'  delps1+',3*ii+jj-3,
     +		'=', delps1,s1,s2
*  #] stupid tree:
*###] ffcl2s:
	end
*###[ ffcl2t:
	subroutine ffcl2t(delps,piDpj,in,jn,kn,ln,lkn,islk,iss,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*		\delta_{si,sj}^{sk,sl}					*
*									*
*	with p(lk) = islk*(iss*sl - sk)	(islk,iss = +/-1)		*
*	and NO relationship between s1,s2 assumed (so 1/2 the		*
*	possibilities of ffdl2s).					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer in,jn,ip1,kn,ln,lkn,islk,iss,ns,ier
	DOUBLE COMPLEX delps,piDpj(ns,ns)
*
*	local variables
*
	DOUBLE COMPLEX s1,s2,c
	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest .and. abs(islk) .ne. 1 )
     +		print *,'ffcl2t: error: abs(islk) <> 1'
*  #] check input:
*  #[ calculations:
	if ( in .eq. jn ) then
	    delps = 0.
	    return
	endif
	s1 = piDpj(kn,in)*piDpj(ln,jn)
	s2 = piDpj(ln,in)*piDpj(kn,jn)
	delps = s1 - s2
	if ( absc(delps) .ge. xloss*absc(s1) ) goto 10
	if ( lwrite ) print *,'  delps  = ',delps,s1,-s2
	s1 = piDpj(kn,in)*piDpj(lkn,jn)
	s2 = piDpj(lkn,in)*piDpj(kn,jn)
	delps = iss*islk*(s1 - s2)
	if ( lwrite ) print *,'  delps+ = ',delps,islk,s1,-s2
	if ( absc(delps) .ge. xloss*absc(s1) ) goto 10
	s1 = piDpj(lkn,in)*piDpj(ln,jn)
	s2 = piDpj(ln,in)*piDpj(lkn,jn)
	delps = islk*(- s1 + s2)
	if ( lwrite ) print *,'  delps++= ',delps,islk,-s1,s2
	if ( absc(delps) .ge. xloss*absc(s1) ) goto 10
	if ( lwarn ) call ffwarn(93,ier,absc(delps),absc(s1))
   10	continue
*  #] calculations:
*###] ffcl2t:
	end
*###[ ffcl3m:
	subroutine ffcl3m(del3mi,ldel,del3,del2,xpi,dpipj,piDpj,ns,ip1n,
     +		ip2n,ip3n,is,itime,ier)
***#[*comment:***********************************************************
*									*
*	Calculate xpi(i)*del2 - del3(piDpj)				*
*									*
*	  /  si	mu \2		(This appears to be one of the harder	*
*	= | d	   |		 determinants to calculate accurately.	*
*	  \  p1	p2 /		 Note that we allow a loss of xloss^2)	*
*									*
*	Input:	ldel		iff .true. del2 and del3 exist		*
*		del3		\delta^{s(1),p1,p2}_{s(1),p1,p2}	*
*		del2		\delta^{p1,p2}_{p1,p2}			*
*		xpi(ns)		standard				*
*		dpipj(ns,ns)	standard				*
*		piDpj(ns,ns)	standard				*
*		ipi		pi = xpi(abs(ipi)) [p3=-p1 +/-p2]	*
*		is		si = xpi(is,is+1,..,is+itime-1)		*
*		itime		number of functions to calculate	*
*									*
*	Output:	del3mi(3)	(\delta^{s_i \mu}_{p_1 p_2})^2		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ip1n,ip2n,ip3n,is,itime,ier
	logical ldel
	DOUBLE COMPLEX del3mi(itime),del3,del2,xpi(ns),dpipj(ns,ns),
     +		piDpj(ns,ns)
*
*	local variables:
*
	DOUBLE PRECISION smax,xmax,absc
	DOUBLE COMPLEX s(7),som,xsom,del2s,delps,c
	integer i,j,k,ip1,ip2,ip3,ipn,is1,is2,isi,is3,ihlp,iqn,jsgnq,
     +		jsgn1,jsgn2,jsgn3,jsgnn,iadj(10,10,3:4),init,nm
	save iadj,init
	logical lsign,lmax,ltwist
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data iadj /200*0/
	data init /0/
*  #] declarations:
*  #[ initialisations:
	if ( init .eq. 0 ) then
	    init = 1
*
*	    Fill the array with adjacent values: if
*		x = iadj(i,j)
*		k = abs(mod(k,100))
*		jsgnk = sign(x)
*		jsgnj = 1-2*theta(x-100)  (ie -1 iff |x|>100)
*	    then
*		pi(k) = jsgnk*( p(i) - jsgnj*pi(j) )
*
	    do 5 nm=3,4
		do 4 i=1,nm
		    is1 = i
		    is2 = i+1
		    if ( is2 .gt. nm ) is2 = 1
		    is3 = i-1
		    if ( is3 .eq. 0 ) is3 = nm
		    ip1 = is1 + nm
		    iadj(is1,is2,nm) = -ip1
		    iadj(is2,is1,nm) = ip1
		    iadj(ip1,is2,nm) = -is1
		    iadj(is2,ip1,nm) = is1
		    iadj(is1,ip1,nm) = 100+is2
		    iadj(ip1,is1,nm) = 100+is2
		    if ( nm .eq. 3 ) then
			iadj(ip1,is2+3,3) = -100-is3-3
			iadj(is2+3,ip1,3) = -100-is3-3
		    endif
    4		continue
    5	    continue

	    iadj(3,1,4) = -9
	    iadj(1,3,4) = 9
	    iadj(9,1,4) = -3
	    iadj(1,9,4) = 3
	    iadj(3,9,4) = 100+1
	    iadj(9,3,4) = 100+1

	    iadj(2,4,4) = -10
	    iadj(4,2,4) = 10
	    iadj(10,4,4) = -2
	    iadj(4,10,4) = 2
	    iadj(2,10,4) = 100+4
	    iadj(10,2,4) = 100+4

	endif
	if ( ns .eq. 6 ) then
	    nm = 3
	else
	    nm = 4
	endif
*  #] initialisations:
*  #[ superfluous code:
*	if ( ns .ne. 6 ) print *,'ffcl3m: called with ns <> 6 !!'
*	if ( ip1n .lt. 4 ) then
*	    lsign = .TRUE.
*	else
*	    lsign = .FALSE.
*	endif
*	if ( ltest .and. lsign ) then
*	    if ( ip3n .eq. 4 ) then
*		if ( ip1n .ne. 1 .or. ip2n .ne. 2 ) goto 2
*	    elseif ( ip3n .eq. 5 ) then
*		if ( ip1n .ne. 2 .or. ip2n .ne. 3 ) goto 2
*	    elseif ( ip3n .eq. 6 ) then
*		if ( ip1n .ne. 3 .or. ip2n .ne. 1 ) goto 2
*	    else
*		goto 2
*	    endif
*	    goto 3
*    2	    continue
*	    print *,'ffcl3m: unexpected combination of indices',ip1,ip2,
*     +					ip3
*    3	    continue
*	endif
*	this went at he end:
*  #[ special case 4,5,6:
*	    Next try - I don't give up easily
*	    if ( nm .eq. 6 .and. ip1n .eq. 4 .and. ip2n .eq. 5 .and.
*     +			ip3n .eq. 6 .and. is .eq. 1 ) then
*		is3 = isi + 1
*		if ( is3 .eq. 4 ) is3 = 1
*		is1 = is3 + 1
*		if ( is1 .eq. 4 ) is1 = 1
*		ip1 = is1 + 3
*		ip2 = isi + 3
*		ip3 = is3 + 3
*		This is an algorithm of last resort.  Add special
*		cases at will.
*		s(1) = xpi(ip1)*xpi(ip2)*xpi(ip3)
*		s(2) = dpipj(is1,isi)*dpipj(ip1,ip2)**2
*		s(3) = -dpipj(is1,isi)*xpi(ip3)*(xpi(ip1)+xpi(ip2))
*		s(4) = 2*dpipj(is1,isi)*dpipj(is1,is3)*
*     +			piDpj(ip1,ip3)
*		s(5) = -2*dpipj(is1,is3)*xpi(ip1)*piDpj(ip2,ip3)
*		s(6) = dpipj(is1,isi)**2*xpi(ip3)
*		s(7) = dpipj(is1,is3)**2*xpi(ip1)
*		som = s(1)
*		smax = abs(s(1))
*		do 31 j=2,7
*		    som = som + s(j)
*		    smax = max(smax,abs(som))
*   31		continue
*		som = som/4
*		smax = smax/4
*		if (lwrite) print *,'  del3mi(',isi,')++= ',som,smax
*		if ( abs(som) .ge. xloss*smax ) goto 35
*		if ( smax .lt. xmax ) then
*		    xsom = som
*		    xmax = smax
*		endif
*	    endif
*  #] special case 4,5,6:
*  #] superfluous code:
*  #[ easy tries:
	do 40 i=1,itime
	    isi = i+is-1
	    lmax = .FALSE.
*
*	    get xpi(isi)*del2 - del3 ... if del3 and del2 are defined
*
	    if ( ldel ) then
		s(1) = xpi(isi)*del2
		som = s(1) - del3
		smax = absc(s(1))
		if ( absc(som) .ge. xloss**2*smax ) goto 35
		if ( lwrite ) print *,'  del3mi(',isi,')  =',som,s(1),
     +			del3
		xsom = som
		xmax = smax
		lmax = .TRUE.
	    endif
	    ip1 = ip1n
	    ip2 = ip2n
	    ip3 = ip3n
	    do 20 j=1,3
*
*		otherwise use the simple threeterm formula
*
		s(1) = xpi(ip2)*piDpj(ip1,isi)**2
		s(2) = xpi(ip1)*piDpj(ip2,isi)*piDpj(ip2,isi)
		s(3) = -2*piDpj(ip2,isi)*piDpj(ip2,ip1)*piDpj(ip1,isi)
		som = s(1) + s(2) + s(3)
		smax = max(absc(s(1)),absc(s(2)),absc(s(3)))
		if ( lwrite .and. (ldel.or.j.ne.1) ) print *,
     +			'  del3mi(',isi,')+ =',som,(s(k),k=1,3)
		if ( absc(som) .ge. xloss**2*smax ) goto 35
		if ( lwrite .and. .not.(ldel.or.j.ne.1) ) print *,
     +			'  del3mi(',isi,')  =',som,(s(k),k=1,3)
		if ( .not. lmax .or. smax .lt. xmax ) then
		    xsom = som
		    xmax = smax
		    lmax = .TRUE.
		endif
*
*		if there are cancellations between two of the terms:
*		we try mixing with isi.
*
*		First map cancellation to s(2)+s(3) (do not mess up
*		rotations...)
*
		if ( absc(s(1)+s(3)) .lt. absc(s(3))/2 ) then
		    ihlp = ip1
		    ip1 = ip2
		    ip2 = ihlp
		    som = s(1)
		    s(1) = s(2)
		    s(2) = som
		    ltwist = .TRUE.
		else
		    ltwist = .FALSE.
		endif
		if ( absc(s(2)+s(3)) .lt. absc(s(3))/2 ) then
*
*		switch to the vector pn so that si = jsgn1*p1 + jsgnn*pn
*
		k = iadj(isi,ip1,nm)
		if ( k .ne. 0 ) then
		    ipn = abs(k)
		    jsgnn = isign(1,k)
		    if ( ipn .gt. 100 ) then
			ipn = ipn - 100
			jsgn1 = -1
		    else
			jsgn1 = +1
		    endif
		    if ( absc(dpipj(ipn,isi)) .lt. 
     +		    	xloss*absc(piDpj(ip1,isi)) .and.
     +			 absc(piDpj(ipn,ip2)) .lt. 
     +			xloss*absc(piDpj(ip2,isi)) ) then
*		same:	s(1) = xpi(ip2)*piDpj(ip1,isi)**2
			s(2) = jsgnn*piDpj(isi,ip2)*piDpj(ipn,ip2)*
     +								xpi(ip1)
			s(3) = jsgn1*piDpj(isi,ip2)*piDpj(ip1,ip2)*
     +							dpipj(ipn,isi)
			som = s(1) + s(2) + s(3)
			smax = max(absc(s(1)),absc(s(2)),absc(s(3)))
			if ( lwrite ) print *,
     +			    '  del3mi(',isi,')++=',som,(s(k),k=1,3)
*			print *,'    (isi+ip1) with isi,ip1,ip2,ipn: ',
*     +				isi,ip1,ip2,ipn
*			print *,'xpi(ip2),piDpj(ip1,isi)',xpi(ip2),
*     +				piDpj(ip1,isi)
*			print *,'piDpj(isi,ip2),piDpj(ipn,ip2),xpi(ip1)'
*     +				,piDpj(isi,ip2),piDpj(ipn,ip2),xpi(ip1)
			if ( absc(som) .ge. xloss**2*smax ) goto 35
			if ( smax .lt. xmax ) then
			    xsom = som
			    xmax = smax
			endif
*
*			there may be a cancellation between s(1) and
*			s(2) left.  Introduce a vector q such that
*			pn = jsgnq*q + jsgn2*p2.  We also need the sign
*			jsgn3 in p3 = -p1 - jsgn3*p2
*
			k = iadj(ipn,ip2,nm)
			if ( k .ne. 0 ) then
			    iqn = abs(k)
*not used		    jsgnq = isign(1,k)
			    if ( iqn .gt. 100 ) then
				iqn = iqn - 100
				jsgn2 = -1
			    else
				jsgn2 = +1
			    endif
			    k = iadj(ip1,ip2,nm)
			    if ( k .eq. 0 .or. k .lt. 100 ) then
*				we have p1,p2,p3 all p's
				jsgn3 = +1
			    elseif ( k .lt. 0 ) then
*				ip1,ip2 are 2*s,1*p such that p2-p1=ip3
				jsgn3 = -1
			    else
				jsgn3 = 0
			    endif
*			    we need one condition on the signs for this
*			    to work
			    if ( ip3.ne.0 .and. jsgn1*jsgn2.eq.jsgnn*
     +			    jsgn3 .and. absc(s(3)).lt.xloss*smax ) then
				s(1) = piDpj(ip1,isi)**2*dpipj(iqn,ipn)
				s(2) = -jsgn2*jsgn1*piDpj(ipn,ip2)*
     +					piDpj(ip1,isi)*dpipj(ipn,isi)
*				s(3) stays the same
				s(4) = -jsgn2*jsgn1*piDpj(ipn,ip2)*
     +					xpi(ip1)*piDpj(isi,ip3)
				som = s(1) + s(2) + s(3) + s(4)
				smax = max(absc(s(1)),absc(s(2)),
     +					absc(s(3)),absc(s(4)))
				if ( lwrite ) print *,
     +				'  del3mi(',isi,')+2=',som,(s(k),k=1,4)
				if (absc(som).ge.xloss**2*smax) goto 35
				if ( smax .lt. xmax ) then
				    xsom = som
				    xmax = smax
				endif
			    endif
			endif
		    endif
		endif
		k = iadj(isi,ip2,nm)
		if ( k .ne. 0 ) then
		    ipn = abs(k)
		    jsgnn = isign(1,k)
		    if ( ipn .gt. 100 ) then
			jsgn1 = -1
			ipn = ipn - 100
		    else
			jsgn1 = +1
		    endif
		    if ( absc(dpipj(ipn,isi)) .lt. 
     +		    	xloss*absc(piDpj(ip2,isi)) .and.
     +			 absc(piDpj(ipn,ip1)) .lt. 
     +			xloss*absc(piDpj(ip1,isi)) ) then
			s(1) = jsgnn*piDpj(isi,ip1)*piDpj(ipn,ip1)*
     +								xpi(ip2)
			s(2) = xpi(ip1)*piDpj(ip2,isi)**2
			s(3) = jsgn1*piDpj(isi,ip1)*piDpj(ip2,ip1)*
     +							dpipj(ipn,isi)
			som = s(1) + s(2) + s(3)
			smax = max(absc(s(1)),absc(s(2)),absc(s(3)))
			if ( lwrite ) print *,
     +			    '  del3mi(',isi,')++=',som,(s(k),k=1,3)
			print *,'    (isi+ip2) with isi,ip1,ip2,ipn: ',
     +				isi,ip1,ip2,ipn
			if ( absc(som) .ge. xloss**2*smax ) goto 35
			if ( smax .lt. xmax ) then
			    xsom = som
			    xmax = smax
			endif
		    endif
		endif
		endif
*this does not suffice
*		if ( lsign ) then
*		    if ( absc(s(1)) .lt. absc(s(2)) ) then
*			s(2) = piDpj(isi,ip2)*piDpj(isi,ip3)*xpi(ip1)
*			if ( j .eq. 2 ) s(2) = -s(2)
*			s(3) = piDpj(isi,ip1)*piDpj(isi,ip2)*
*     +				dpipj(ip3,ip2)
*		    else
*			s(1) = piDpj(isi,ip1)*piDpj(isi,ip3)*xpi(ip2)
*			if ( j .eq. 1 ) s(1) = -s(1)
*			s(3) = piDpj(isi,ip1)*piDpj(isi,ip2)*
*     +				dpipj(ip3,ip1)
*		    endif
*		    if ( j .eq. 3 ) s(3) = -s(3)
**
*		    som = s(1) + s(2) + s(3)
*		    smax = max(absc(s(1)),absc(s(2)),absc(s(3)))
*		    if ( lwrite ) print *,
*     +			'  del3mi(',isi,')++=',som,(s(k),k=1,3)
*		    if ( absc(som) .ge. xloss**2*smax ) goto 35
*		    if ( smax .lt. xmax ) then
*			xmax = smax
*			xsom = som
*		    endif
*		endif
*nor does this
*		if ( j .eq. 1 )
*     +			call ffcel2(del2s,piDpj,6,ip1,ip2,ip3,1,ier)
*		call ffcl2t(delps,piDpj,isi,ip2,ip1,ip2,ip3,+1,+1,6,ier)
*		s(1) = piDpj(isi,ip2)**2*del2s/xpi(ip2)
*		s(2) = delps**2/xpi(ip2)
*		som = s(1) + s(2)
*		smax = absc(s(1))
*		if ( lwrite ) print *,
*     +			'  del3mi(',isi,')++=',del3mi(i),(s(k),k=1,2)
*		if ( absc(som) .ge. xloss*smax ) goto 35
*		if ( smax .lt. xmax ) then
*		    xmax = smax
*		    xsom = som
*		endif
*
*		rotate the ipi
*
		if ( ip3 .eq. 0 ) goto 30
		if ( j .ne. 3 ) then
		    if ( .not. ltwist ) then
			ihlp = ip1
			ip1 = ip2
			ip2 = ip3
			ip3 = ihlp
		    else
			ihlp = ip2
			ip2 = ip3
			ip3 = ihlp
		    endif
		endif
   20	    continue
   30	    continue
*  #] easy tries:
*  #[ choose the best value:
*
*	    These values are the best found:
*
	    som = xsom
	    smax = xmax
	    if ( lwarn ) call ffwarn(75,ier,absc(som),smax)
	    if ( lwrite ) then
		print *,'ffcl3m: giving up:'
		print *,'ip1,ip2,ip3,is,itime =',ip1,ip2,ip3,is,itime
		print *,'xpi = ',xpi
	    endif

   35	    continue
	    del3mi(i) = som
   40	continue
*  #] choose the best value:
*###] ffcl3m:
	end
*###[ ffcel3:
	subroutine ffcel3(del3,xpi,piDpj,ns,ier)
***#[*comment:***********************************************************
*									*
*	Calculate del3(piDpj) = det(si.sj)	with			*
*	the momenta as follows:						*
*	p(1-3) = s(i)							*
*	p(4-6) = p(i)							*
*									*
*	Input:	xpi(ns)		(real)	m^2(i),i=1,3; p^2(i-3),i=4,10	*
*		piDpj(ns,ns)	(real)					*
*		ns		(integer)				*
*		ier		(integer)				*
*									*
*	Output:	del3		(real)	det(si.sj)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ier
	DOUBLE COMPLEX del3,xpi(6),piDpj(6,6)
*
*	local variables:
*
	integer mem,nperm
	parameter(mem=10,nperm=16)
	integer i,jj(6),iperm(3,nperm),imem,memarr(mem,3),memind,inow
	DOUBLE COMPLEX s(6),del3p,cc
	DOUBLE PRECISION xmax,xmaxp,absc,rloss
	save iperm,memind,memarr,inow
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations:
*  #[ data:
	data memind /0/
	data memarr /mem*0,mem*0,mem*1/
	data inow /1/
*
*	these are all permutations that give a non-zero result with the
*	correct sign.  This list was generated with getperm3.
*
	data iperm/
     +		1,2,3,  1,2,5,  1,6,2,  1,4,3,
     +		1,3,5,  1,4,5,  1,6,4,  1,5,6,
     +		2,4,3,  2,3,6,  2,4,5,  2,6,4,
     +		2,5,6,  3,4,5,  3,6,4,  3,5,6/
*  #] data:
*  #[ check input:
	if ( ltest .and. ns .ne. 6 ) then
	    print *,'ffcel3: error: only for ns = 6, not ',ns
	    stop
	endif
*  #] check input:
*  #[ starting point in memory?:
*
*	see if we know were to start, if not: go on as last time
*
	do 5 i=1,mem
	    if ( id .eq. memarr(i,1) .and. idsub .eq. memarr(i,2) ) then
		inow = memarr(i,3)
		goto 6
	    endif
    5	continue
    6	continue
*  #] starting point in memory?:
*  #[ calculations:
	imem = inow
	del3 = 0
	xmax = 0

   10	continue

	jj(1) = iperm(1,inow)
	jj(3) = iperm(2,inow)
	jj(5) = iperm(3,inow)

	jj(2) = iperm(1,inow)
	jj(4) = iperm(2,inow)
	jj(6) = iperm(3,inow)

	s(1) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(6))
	s(2) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(2))
	s(3) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(4))
	s(4) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(4))
	s(5) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(2))
	s(6) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(6))

	del3p = 0
	xmaxp = 0
	do 20 i=1,6
	    del3p = del3p + s(i)
	    xmaxp = max(xmaxp,absc(s(i)))
   20	continue
	if ( absc(del3p) .lt. xloss*xmaxp ) then
	    if ( lwrite ) print *,'del3+',inow,' = ',del3p,xmaxp
	    if ( inow .eq. imem .or. xmaxp .lt. xmax ) then
		del3 = del3p
		xmax = xmaxp
	    endif
	    inow = inow + 1
	    if ( inow .gt. nperm ) inow = 1
	    if ( inow .eq. imem ) then
		if ( lwarn ) call ffwarn(72,ier,absc(del3),xmax)
		goto 800
	    endif
	    goto 10
	endif
	if ( inow .ne. imem ) then
	    if ( lwrite ) print *,'del3+',inow,' = ',del3p,xmaxp
	endif
	del3 = del3p
	xmax = xmaxp
*  #] calculations:
*  #[ into memory:
  800	continue
	memind = memind + 1
	if ( memind .gt. mem ) memind = 1
	memarr(memind,1) = id
	memarr(memind,2) = idsub
	memarr(memind,3) = inow
*  #] into memory:
*  #[ check output:
	if ( ltest ) then

	    s(1) = +piDpj(1,1)*piDpj(2,2)*piDpj(3,3)
	    s(2) = +piDpj(1,2)*piDpj(2,3)*piDpj(3,1)
	    s(3) = +piDpj(1,3)*piDpj(2,1)*piDpj(3,2)
	    s(4) = -piDpj(1,1)*piDpj(2,3)*piDpj(3,2)
	    s(5) = -piDpj(1,3)*piDpj(2,2)*piDpj(3,1)
	    s(6) = -piDpj(1,2)*piDpj(2,1)*piDpj(3,3)

	    del3p = 0
	    xmaxp = 0
	    do 820 i=1,6
		del3p = del3p + s(i)
		xmaxp = max(xmaxp,absc(s(i)))
  820	    continue
	    cc = del3p-del3
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    if ( rloss*absc(cc) .gt. precc*xmaxp ) then
		print *,'ffcel3: error: result does not agree with',
     +			' normal case'
		print *,'result: ',del3,xmax
		print *,'normal: ',del3p,xmaxp
		print *,'diff.:  ',del3-del3p
	    endif
	endif
*  #] check output:
*###] ffcel3:
	end
*(##[ ffcl3s:
	subroutine ffcl3s(dl3s,xpi,piDpj,ii,ns,ier)
***#[*comment:***********************************************************
*									*
*	Calculate dl3s(piDpj) = det(si.sj)	with			*
*	the momenta indicated by the indices ii(1-6,1), ii(1-6,2)	*
*	as follows:							*
*	p(|ii(1,)|-|ii(3,)|) = s(i)					*
*	p(|ii(4,)|-|ii(6,)|) = p(i) = sgn(ii())*(s(i+1) - s(i))		*
*									*
*	At this moment (26-apr-1990) only the diagonal is tried		*
*									*
*	Input:	xpi(ns)		(real)	m^2(i),i=1,3; p^2(i-3),i=4,10	*
*		piDpj(ns,ns)	(real)					*
*		ii(6,2)		(integer)	see above		*
*		ns		(integer)				*
*		ier		(integer)				*
*									*
*	Output:	dl3s		(real)	det(si.sj)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ii(6,2),ns,ier
	DOUBLE COMPLEX dl3s,xpi(ns),piDpj(ns,ns)
*
*	local variables:
*
	integer mem,nperm
	parameter(mem=10,nperm=16)
	integer i,j,jj(6),jsgn,iperm(3,nperm),imem,memarr(mem,3),
     +		memind,inow
	DOUBLE PRECISION xmax,xmaxp,xlosn,absc,rloss
	DOUBLE COMPLEX s(6),dl3sp,xhck,cc
	save iperm,memind,memarr,inow
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations:
*  #[ data:
*
	data memind /0/
	data memarr /mem*0,mem*0,mem*1/
	data inow /1/
*
*	these are all permutations that give a non-zero result with the
*	correct sign.  This list was generated with getperm3.
*
	data iperm/
     +		1,2,3,  1,2,5,  1,6,2,  1,4,3,
     +		1,3,5,  1,4,5,  1,6,4,  1,5,6,
     +		2,4,3,  2,3,6,  2,4,5,  2,6,4,
     +		2,5,6,  3,4,5,  3,6,4,  3,5,6/
*  #] data:
*  #[ test input:
	if ( ltest ) then
	    if ( lwrite ) then
		print *,'ffcl3s: input: ii(,1) = ',(ii(i,1),i=1,6)
		print *,'               ii(,2) = ',(ii(i,2),i=1,6)
	    endif
	    xlosn = xloss*DBLE(10)**(-mod(ier,50)-1)
	    do 3 j=1,2
	    do 1 i=1,6
		if ( abs(ii(i,j)) .gt. ns ) print *,'ffcl3s: error: ',
     +			'|ii(i,j)| > ns: ',ii(i,j),ns
		if ( abs(ii(i,j)) .eq. 0 ) print *,'ffcl3s: error: ',
     +			'|ii(i,j)| = 0: ',ii(i,j)
    1	    continue
	    do 2 i=1,6

		xhck = piDpj(abs(ii(i,j)),ii(1,j))
     +		     - piDpj(abs(ii(i,j)),ii(2,j))
     +		     + sign(1,ii(4,j))*piDpj(abs(ii(i,j)),abs(ii(4,j)))
		xmax = max(absc(piDpj(abs(ii(i,j)),ii(1,j))),
     +			   absc(piDpj(abs(ii(i,j)),ii(2,j))))
		if ( xlosn*absc(xhck).gt.precc*xmax ) print *,'ffcl3s:'
     +		  ,' error: dotproducts 124 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(1,j)),
     +		  piDpj(abs(ii(i,j)),ii(2,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(4,j))),xhck

		xhck = piDpj(abs(ii(i,j)),ii(2,j))
     +		     - piDpj(abs(ii(i,j)),ii(3,j))
     +		     +sign(1,ii(5,j))*piDpj(abs(ii(i,j)),abs(ii(5,j)))
		xmax = max(absc(piDpj(abs(ii(i,j)),ii(2,j))),
     +			absc(piDpj(abs(ii(i,j)),ii(3,j))))
		if ( xlosn*absc(xhck).gt.precc*xmax ) print *,'ffcl3s:'
     +		  ,' error: dotproducts 235 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(2,j)),
     +		  piDpj(abs(ii(i,j)),ii(3,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(5,j))),xhck

		xhck = piDpj(abs(ii(i,j)),ii(3,j))
     +		     - piDpj(abs(ii(i,j)),ii(1,j))
     +		     + sign(1,ii(6,j))*piDpj(abs(ii(i,j)),abs(ii(6,j)))
		xmax = max(absc(piDpj(abs(ii(i,j)),ii(3,j))),
     +			absc(piDpj(abs(ii(i,j)),ii(1,j))))
		if ( xlosn*absc(xhck).gt.precc*xmax ) print *,'ffcl3s:'
     +		  ,' error: dotproducts 316 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(3,j)),
     +		  piDpj(abs(ii(i,j)),ii(1,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(6,j))),xhck

		xhck = sign(1,ii(4,j))*piDpj(abs(ii(i,j)),abs(ii(4,j)))
     +		     + sign(1,ii(5,j))*piDpj(abs(ii(i,j)),abs(ii(5,j)))
     +		     + sign(1,ii(6,j))*piDpj(abs(ii(i,j)),abs(ii(6,j)))
		xmax = max(absc(piDpj(abs(ii(i,j)),abs(ii(4,j)))),
     +			   absc(piDpj(abs(ii(i,j)),abs(ii(5,j)))))
		if ( xlosn*absc(xhck).gt.precc*xmax ) print *,'ffcl3s:'
     +		  ,' error: dotproducts 456 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),abs(ii(4,j))),
     +		  piDpj(abs(ii(i,j)),abs(ii(5,j))),
     +		  piDpj(abs(ii(i,j)),abs(ii(6,j))),xhck

    2	    continue
    3	    continue
	    do 4 i=1,ns
	    	xhck = piDpj(i,i) - xpi(i)
	    	xmax = abs(xpi(i))
		if ( xlosn*absc(xhck).gt.precc*xmax ) print *,'ffcl3s:'
     +		  ,' error: xpi(',i,') != piDpj(',i,i,') :',xpi(i),
     +		  piDpj(i,i),xhck
    4	    continue
	endif
*  #] test input:
*  #[ starting point in memory?:
*
*	see if we know were to start, if not: go on as last time
*
	do 5 i=1,mem
	    if ( id .eq. memarr(i,1) .and. idsub .eq. memarr(i,2) ) then
		inow = memarr(i,3)
		goto 6
	    endif
    5	continue
    6	continue
*  #] starting point in memory?:
*  #[ calculations:
	imem = inow
	dl3s = 0
	xmax = 0

   10	continue

	jj(1) = abs(ii(iperm(1,inow),1))
	jj(3) = abs(ii(iperm(2,inow),1))
	jj(5) = abs(ii(iperm(3,inow),1))

	jj(2) = abs(ii(iperm(1,inow),2))
	jj(4) = abs(ii(iperm(2,inow),2))
	jj(6) = abs(ii(iperm(3,inow),2))

	jsgn =  sign(1,ii(iperm(1,inow),1))
     +		*sign(1,ii(iperm(2,inow),1))
     +		*sign(1,ii(iperm(3,inow),1))
     +		*sign(1,ii(iperm(1,inow),2))
     +		*sign(1,ii(iperm(2,inow),2))
     +		*sign(1,ii(iperm(3,inow),2))

	s(1) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(6))
	s(2) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(2))
	s(3) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(4))
	s(4) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(4))
	s(5) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(2))
	s(6) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(6))

	dl3sp = 0
	xmaxp = 0
	do 20 i=1,6
	    dl3sp = dl3sp + s(i)
	    xmaxp = max(xmaxp,absc(s(i)))
   20	continue
	if ( absc(dl3sp) .lt. xloss*xmaxp ) then
	    if ( lwrite ) print *,'dl3s+',inow,' = ',dl3sp,xmaxp
	    if ( inow .eq. imem .or. xmaxp .lt. xmax ) then
		dl3s = jsgn*dl3sp
		xmax = xmaxp
	    endif
	    inow = inow + 1
	    if ( inow .gt. nperm ) inow = 1
	    if ( inow .eq. imem ) then
		if ( lwarn ) call ffwarn(85,ier,absc(dl3s),xmax)
		goto 800
	    endif
	    goto 10
	endif
	if ( inow .ne. imem ) then
	    if ( lwrite ) print *,'dl3s+',inow,' = ',dl3sp,xmaxp
	endif
	dl3s = jsgn*dl3sp
	xmax = xmaxp
*  #] calculations:
*  #[ into memory:
  800	continue
	memind = memind + 1
	if ( memind .gt. mem ) memind = 1
	memarr(memind,1) = id
	memarr(memind,2) = idsub
	memarr(memind,3) = inow
*  #] into memory:
*  #[ check output:
	if ( ltest ) then

	    s(1) = +piDpj(ii(1,1),ii(1,2))*piDpj(ii(2,1),ii(2,2))*
     +						piDpj(ii(3,1),ii(3,2))
	    s(2) = +piDpj(ii(1,1),ii(2,2))*piDpj(ii(2,1),ii(3,2))*
     +						piDpj(ii(3,1),ii(1,2))
	    s(3) = +piDpj(ii(1,1),ii(3,2))*piDpj(ii(3,1),ii(2,2))*
     +						piDpj(ii(2,1),ii(1,2))
	    s(4) = -piDpj(ii(1,1),ii(1,2))*piDpj(ii(2,1),ii(3,2))*
     +						piDpj(ii(3,1),ii(2,2))
	    s(5) = -piDpj(ii(1,1),ii(3,2))*piDpj(ii(2,1),ii(2,2))*
     +						piDpj(ii(3,1),ii(1,2))
	    s(6) = -piDpj(ii(1,1),ii(2,2))*piDpj(ii(2,1),ii(1,2))*
     +						piDpj(ii(3,1),ii(3,2))

	    dl3sp = 0
	    xmaxp = 0
	    do 820 i=1,6
		dl3sp = dl3sp + s(i)
		xmaxp = max(xmaxp,absc(s(i)))
  820	    continue
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    if ( rloss*absc(dl3sp-dl3s) .gt. precc*xmaxp ) then
		print *,'ffcl3s: error: result does not agree with',
     +			' normal case'
		print *,'result: ',dl3s,xmax
		print *,'normal: ',dl3sp,xmaxp
		print *,'diff.:  ',dl3s-dl3sp
	    endif
	endif
*  #] check output:
*)##] ffcl3s:
	end
*###[ ffzli2:
	subroutine ffzli2(zdilog,zlog,cx,lreal,ier)
***#[*comment:***********************************************************
*									*
*	Computes the dilogarithm (Li2, Sp) for any (complex) cx 	*
*	to a precision precc.  It assumes that cx is already in the	*
*	area |cx|<=1, Re(cx)<=1/2.  As it is available it also returns	*
*	log(1-cx) = zlog.						*
*									*
*	Input:	cx	(complex)					*
*		lreal	(logical) indicates whether only the real part  *
*				  is needed				*
*									*
*	Output:	zdilog	(complex) Li2(cx)				*
*		zlog	(complex) log(1-cx) = -Li1(cx)			*
*		ier	(integer) 0=OK,1=num,2=err			*
*									*
*	Calls:	log,zfflo1,(d/a)imag,real/dble				*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	logical lreal
	DOUBLE COMPLEX cx,zlog,zdilog
*
*	local variables
*
	DOUBLE PRECISION xprec,bdn02,bdn05,bdn10,bdn15,bdn20,
     +		xi,xr,xdilog,xlog,x,absc,xa,a,ffbnd
	DOUBLE COMPLEX cc,cz,cz2,zfflo1
	save xprec,bdn02,bdn05,bdn10,bdn15,bdn20
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations: 
*  #[ initialisations:
	data xprec /-1./
	if ( xprec .ne. precc ) then
	    xprec = precc
	    bdn02 = ffbnd(1,2,bf)
	    bdn05 = ffbnd(1,5,bf)
	    bdn10 = ffbnd(1,10,bf)
	    bdn15 = ffbnd(1,15,bf)
	    bdn20 = ffbnd(1,19,bf)
*		we don't have bf(21) ...
	endif
*  #] initialisations: 
*  #[ check input:
*	(throw out later)
	if ( ltest .and. absc(cx).gt.1.5 .or. DBLE(cx).gt..75 )
     +		call fferr(30,ier)
*  #] check input: 
*  #[ exceptional cases:
	xi  = DIMAG(cx)
	xr  = DBLE(cx)
	if ( xi .eq. 0) then
	    call ffxli2(xdilog,xlog,xr,ier)
	    zdilog = xdilog
	    zlog = xlog
	    return
	endif
	xa = abs(xi) + abs(xr)
	if ( xa .lt. precc ) then
	    zdilog = cx
	    zlog = -cx
	    return
	endif
*  #] exceptional cases: 
*  #[ get log,dilog:
	if ( xa .lt. xloss**2 ) then
	    zlog = zfflo1(cx,ier)
	else
	    zlog = log(1-cx)
	endif
	cz = -zlog
	if ( absc(cz) .lt. xclog2 ) then
	    zdilog = cz
	else
	cz2 = cz*cz
	a = xa**2
	if ( lwarn .and. a .gt. bdn20 ) then
	    call ffwarn(61,ier,precc,abs(bf(20))*a**20)
	endif
	if ( a .gt. bdn15 ) then
	    zdilog = cz2*(DBLE(bf(16)) + cz2*(DBLE(bf(17))
     +		   + cz2*(DBLE(bf(18)) + cz2*(DBLE(bf(19))
     +		   + cz2*(DBLE(bf(20)))))))
	else
	    zdilog = 0
	endif
	if ( a .gt. bdn10 ) then
	    zdilog = cz2*(DBLE(bf(11)) + cz2*(DBLE(bf(12))
     +		   + cz2*(DBLE(bf(13)) + cz2*(DBLE(bf(14))
     +		   + cz2*(DBLE(bf(15)) + zdilog)))))
	endif
	if ( a .gt. bdn05 ) then
	    zdilog = cz2*(DBLE(bf(6)) + cz2*(DBLE(bf(7))
     +		   + cz2*(DBLE(bf(8)) + cz2*(DBLE(bf(9))
     +		   + cz2*(DBLE(bf(10)) + zdilog)))))
	endif
	if ( a .gt. bdn02 ) then
	    zdilog = cz2*(DBLE(bf(3)) + cz2*(DBLE(bf(4))
     +		   + cz2*(DBLE(bf(5)) + zdilog)))
	endif
*	watch the powers of z.
	zdilog = cz + cz2*(DBLE(bf(1)) + cz*(DBLE(bf(2)) + zdilog))
	endif
*  #] get log,dilog: 
*  #[ check for numerical problems:
*
*	if we just need the real part the dominant term is xi^2/4
*
	if ( lreal .and. abs(DBLE(zdilog)) .lt. xloss*xi**2/4 ) then
*	    think of something more intelligent later ...
	    x = DBLE(zdilog)
	    if ( lwarn ) call ffwarn(151,ier,x,xi**2/4)
	endif
*  #] check for numerical problems: 
*###] ffzli2: 
	end
*###[ ffzzdl:
	subroutine ffzzdl(zdilog,ipi12,zlog,cx,ier)
***#[*comment:***************************************************
*								*
*	Computes the dilogarithm (Li2, Sp) for any (complex) cx *
*	to about 15 significant figures. This can be improved	*
*	by adding more of the bf's. For real cx > 1 an error is	*
*	generated as the imaginary part is undefined then.	*
*	For use in ffcdbd zlog = log(1-cx) is also calculated	*
*								*
*	Input:	cx	(complex)				*
*								*
*	Output:	zdilog	(complex) Li2(cx) mod factors pi^2/12	*
*		ipi12	(integer) these factors			*
*		zlog	(complex) log(1-cx)			*
*								*
*	Calls:	log,zfflo1,(d/a)imag,real/dble			*
*								*
***#]*comment:*************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12,ier
	DOUBLE COMPLEX zdilog,zlog,cx
*
*	local variables
*
	integer jsgn
	DOUBLE PRECISION xprec,bdn02,bdn05,bdn10,bdn15,bdn20,
     +		xi,xr,s1,s2,xa,a,absc,ffbnd
	DOUBLE COMPLEX cfact,cx1,cy,cz,cz2,zfflo1,c
	save xprec,bdn02,bdn05,bdn10,bdn15,bdn20
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ initialisations:
	data xprec /-1./
	if ( xprec .ne. precc ) then
	    xprec = precc
	    bdn02 = ffbnd(1,2,bf)
	    bdn05 = ffbnd(1,5,bf)
	    bdn10 = ffbnd(1,10,bf)
	    bdn15 = ffbnd(1,15,bf)
	    bdn20 = ffbnd(1,19,bf)
	endif
*  #] initialisations: 
*  #[ debug:
*	if ( lwrite ) print *,'ffzzdl(',cx,')'
*  #] debug: 
*  #[ exceptional cases:
	xi  = DIMAG(cx)
	xr  = DBLE(cx)
	if ( xi .eq. 0 ) then
	    if ( xr .gt. 1 ) call fferr(31,ier)
	    call ffzxdl(zdilog,ipi12,zlog,xr,1,ier)
	    return
	endif
	if ( abs(xi) .lt. xalog2 ) then
	    s1 = 0
	else
	    s1 = xi**2
	endif
	if ( abs(xr) .lt. xalog2 ) then
	    s2 = 0
	else
	    s2 = xr**2
	endif
	xa = sqrt(s1 + s2)
	if ( xa .lt. precc ) then
	    zdilog = cx
	    zlog = -cx
	    ipi12 = 0
	    return
	endif
*  #] exceptional cases: 
*  #[ transform to |x|<1, Re(x) < 0.5:
	if ( xr .le. x05) then
	    if (xa .gt. 1) then
		if ( 1/xa .lt. xalogm ) then
		    cfact = 0
		elseif ( 1/xa .lt. xclogm ) then
		    cx1 = cx*DBLE(1/xa)
		    cfact = log(-cx1) + log(DBLE(xa))
		else
		    cfact = log(-cx)
		endif
		cy = - cfact**2/2
		ipi12 = -2
		if ( xa*xloss**2 .gt. 1) then
		    if ( 1/xa .lt. xclogm ) then
			cx1 = cx*DBLE(1/xa)
			cx1 = 1/cx1
			cx1 = cx1*DBLE(1/xa)
		    else
			cx1 = 1/cx
		    endif
		    cz = -zfflo1(cx1,ier)
		else
		    cz = -log(1-1/cx)
		endif
		zlog = log(1-cx)
		jsgn = -1
	    else
		cy = 0
		ipi12 = 0
		if ( xa .lt. xloss**2 ) then
		    zlog = zfflo1(cx,ier)
		else
		    zlog = log(1-cx)
		endif
		cz = -zlog
		jsgn = 1
	    endif
	else
	    if (xa .le. sqrt(2*xr)) then
		cz = -log(cx)
		if ( abs(xr-1) + abs(xi) .lt. xclogm ) then
		    if ( lwarn )
     +			call ffwarn(65,ier,abs(1-xr)+abs(xi),xclogm)
		    cy = 0
		else
		    zlog = log(1-cx)
		    cy = cz*zlog
		endif
		ipi12 = 2
		jsgn = -1
	    else
		if ( 1/xa .lt. xalogm ) then
		    cfact = 0
		elseif ( 1/xa .lt. xclogm ) then
		    cx1 = cx*DBLE(1/xa)
		    cfact = log(-cx1) + log(DBLE(xa))
		else
		    cfact = log(-cx)
		endif
		cy = - cfact**2/2
		ipi12 = -2
		if ( xa*xloss .gt. 1) then
		    if ( 1/xa .lt. xclogm ) then
			cx1 = cx*DBLE(1/xa)
			cx1 = 1/cx1
			cx1 = cx1*DBLE(1/xa)
		    else
			cx1 = 1/cx
		    endif
		    cz = -zfflo1(cx1,ier)
		else
		    cz = -log(1-1/cx)
		endif
		zlog = log(1-cx)
		jsgn = -1
	    endif
	endif
*  #] transform to |x|<1, Re(x) < 0.5: 
*  #[ get dilog:
	if ( absc(cz) .lt. xclogm ) then
	    zdilog = cz
	else
	cz2 = cz*cz
	a = DBLE(cz)**2 + DIMAG(cz)**2
	if ( lwarn .and. a .gt. bdn20 ) then
	    call ffwarn(67,ier,precc,abs(bf(20))*a**20)
	endif
	if ( a .gt. bdn15 ) then
	    zdilog = cz2*(DBLE(bf(16)) + cz2*(DBLE(bf(17))
     +		   + cz2*(DBLE(bf(18)) + cz2*(DBLE(bf(19))
     +		   + cz2*(DBLE(bf(20)))))))
	else
	    zdilog = 0
	endif
	if ( a .gt. bdn10 ) then
	    zdilog = cz2*(DBLE(bf(11)) + cz2*(DBLE(bf(12))
     +		   + cz2*(DBLE(bf(13)) + cz2*(DBLE(bf(14))
     +		   + cz2*(DBLE(bf(15)) + zdilog)))))
	endif
	if ( a .gt. bdn05 ) then
	    zdilog = cz2*(DBLE(bf(6)) + cz2*(DBLE(bf(7))
     +		   + cz2*(DBLE(bf(8)) + cz2*(DBLE(bf(9))
     +		   + cz2*(DBLE(bf(10)) + zdilog)))))
	endif
	if ( a .gt. bdn02 ) then
	    zdilog = cz2*(DBLE(bf(3)) + cz2*(DBLE(bf(4))
     +		   + cz2*(DBLE(bf(5)) + zdilog)))
	endif
*	watch the powers of z.
	zdilog = cz + cz2*(DBLE(bf(1)) + cz*(DBLE(bf(2)) + zdilog))
	endif
	if(jsgn.eq.1)then
	    zdilog =  zdilog + cy
	else
	    zdilog = -zdilog + cy
	endif
*  #] get dilog: 
*###] ffzzdl: 
	end
*###[ zfflog:
	DOUBLE COMPLEX function zfflog(cx,ieps,cy,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the complex logarithm of cx.  The following cases	*
*	are treted separately:						*
*		|cx| too small:		give warning and return 0	*
*					(for Absoft, Apollo DN300)	*
*		Im(cx) = 0, Re(cx) < 0:	take sign according to ieps	*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
*
*	arguments
*
	implicit none
	integer ieps,ier
	DOUBLE COMPLEX cx,cy
*
*	local variables
*
	DOUBLE COMPLEX c,ctroep
	DOUBLE PRECISION absc,xa,xlog1p
*
*	common blocks, statement function
*
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ check input:
	if ( lwarn .and. absc(cx-1) .lt. xloss ) then
	    call ffwarn(128,ier,absc(cx-1),x1)
	endif
*  #] check input: 
*  #[ calculations:
	xa = absc(cx)
	if ( xa .lt. xalogm ) then
	    if ( cx .ne. 0 ) call fferr(23,ier)
	    zfflog = 0
	elseif ( DBLE(cx) .lt. 0 .and. DIMAG(cx) .eq. 0 ) then
*     +		 abs(DIMAG(cx)) .lt. precc*abs(DBLE(cx)) ) then
	    xlog1p = log(-DBLE(cx))
*	    checked imaginary parts 19-May-1988
	    if ( abs(ieps) .eq. 1 ) then
		if ( ieps*DBLE(cy) .lt. 0 ) then
		    zfflog = DCMPLX(xlog1p,-pi)
		elseif ( ieps*DBLE(cy) .gt. 0 ) then
		    zfflog = DCMPLX(xlog1p,pi)
		else
		    call fferr(51,ier)
		    zfflog = DCMPLX(xlog1p,pi)
		endif
	    elseif ( ieps .ge. 2 .and. ieps .le. 3 ) then
		zfflog = DCMPLX(xlog1p,-pi)
	    elseif ( ieps .le. -2 .and. ieps .ge. -3 ) then
		zfflog = DCMPLX(xlog1p,pi)
	    else
		call fferr(51,ier)
		zfflog = DCMPLX(xlog1p,pi)
	    endif
	    if ( ltest .and. DIMAG(cx) .ne. 0 ) then
		if ( DIMAG(zfflog) .gt. 0 .neqv. DIMAG(cx) .gt. 0 )
     +		    call fferr(56,ier)
	    endif
	elseif ( xa .lt. xclogm .or. 1/xa .lt. xclogm ) then
	    ctroep = cx*DBLE(1/xa)
	    zfflog = log(ctroep) + DBLE(log(xa))
	else
*	    print *,'zfflog: neem log van ',cx
	    zfflog = log(cx)
	endif
*  #] calculations:
*###] zfflog:
	end
*###[ zfflo1:
	DOUBLE COMPLEX function zfflo1(cx,ier)
***#[*comment:***************************************************
*	calculates log(1-x) for |x|<.14 in a faster way to ~15	*
*	significant figures.					*
***#]*comment:*************************************************** 
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE COMPLEX cx,c,zfflog
	DOUBLE PRECISION xprec,bdn01,bdn05,bdn10,bdn15,bdn19,
     +		absc,xa,ffbnd
	save xprec,bdn01,bdn05,bdn10,bdn15,bdn19
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ initialisations:
	data xprec /-1./
	if ( precc .ne. xprec ) then
	    xprec = precc
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv)
	    bdn05 = ffbnd(1,5,xninv)
	    bdn10 = ffbnd(1,10,xninv)
	    bdn15 = ffbnd(1,15,xninv)
	    bdn19 = ffbnd(1,19,xninv)
	endif
*  #] initialisations: 
*  #[ calculations:
	xa = absc(cx)
	if ( xa .gt. bdn19 ) then
	    if ( lwarn .and. xa .lt. xloss ) call ffwarn(63,ier,xa,x1)
	    c = cx-1
	    xa = absc(c)
	    if ( lwarn .and. xa .lt. xloss ) call ffwarn(133,ier,xa,x1)
	    zfflo1 = zfflog(1-cx,0,c0,ier)
	    return
	endif
	if ( xa .gt. bdn15 ) then
	    zfflo1 = cx*( DBLE(xninv(16)) + cx*( DBLE(xninv(17))
     +		   + cx*( DBLE(xninv(18)) + cx*( DBLE(xninv(19))
     +		   + cx*( DBLE(xninv(20)) )))))
	else
	    zfflo1 = 0
	endif
	if ( xa .gt. bdn10 ) then
	    zfflo1 = cx*( DBLE(xninv(11)) + cx*( DBLE(xninv(12))
     +		   + cx*( DBLE(xninv(13)) + cx*( DBLE(xninv(14))
     +		   + cx*( DBLE(xninv(15)) + zfflo1 )))))
	endif
	if ( xa .gt. bdn05 ) then
	    zfflo1 = cx*( DBLE(xninv(6)) + cx*( DBLE(xninv(7))
     +		   + cx*( DBLE(xninv(8)) + cx*( DBLE(xninv(9))
     +		   + cx*( DBLE(xninv(10)) + zfflo1 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    zfflo1 = cx*( DBLE(xninv(2)) + cx*( DBLE(xninv(3))
     +		   + cx*( DBLE(xninv(4)) + cx*( DBLE(xninv(5))
     +		   + zfflo1 ))))
	endif
	zfflo1 = - cx*( DBLE(xninv(1)) + zfflo1 )
*  #] calculations: 
*###] zfflo1: 
	end
*###[ zfflo2:
	DOUBLE COMPLEX function zfflo2(x,ier)
***#[*comment:***************************************************
*	calculates log(1-x)+x for |x|<.14 in a faster way to	*
*	~15 significant figures.				*
***#]*comment:*************************************************** 
*  #[ declarations:
	implicit none
	integer ier,ier0
	DOUBLE COMPLEX x,d1,zfflo1,cc
	DOUBLE PRECISION bdn01,bdn05,bdn10,bdn15,bdn18,xprec,xa,xheck,
     +		ffbnd,absc
	save xprec,bdn01,bdn05,bdn10,bdn15,bdn18
	include 'ff.h'
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations: 
*  #[ initialisation:
	data xprec /-1./
	if ( xprec .ne. precc ) then
	    xprec = precx
	    precx = precc
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv(2))
	    bdn05 = ffbnd(1,5,xninv(2))
	    bdn10 = ffbnd(1,10,xninv(2))
	    bdn15 = ffbnd(1,15,xninv(2))
	    bdn18 = ffbnd(1,18,xninv(2))
	    precx = xprec
	    xprec = precc
	endif
*  #] initialisation: 
*  #[ calculations:
	xa = absc(x)
	if ( xa .gt. bdn18 ) then
	    zfflo2 = zfflo1(x,ier) + x
	    if ( lwarn .and. absc(zfflo2).lt.xloss*abs(x) )
     +		call ffwarn(234,ier,absc(zfflo2),absc(x))
	    return
	endif
	if ( xa .gt. bdn15 ) then
	    zfflo2 = x*( DBLE(xninv(17)) + x*( DBLE(xninv(18)) +
     +		x*( DBLE(xninv(19)) + x*( DBLE(xninv(20)) ))))
	else
	    zfflo2 = 0
	endif
	if ( xa .gt. bdn10 ) then
	    zfflo2 = x*( DBLE(xninv(12)) + x*( DBLE(xninv(13)) +
     +		x*( DBLE(xninv(14)) + x*( DBLE(xninv(15)) +
     +		x*( DBLE(xninv(16)) + zfflo2 )))))
	endif
	if ( xa .gt. bdn05 ) then
	    zfflo2 = x*( DBLE(xninv(7)) + x*( DBLE(xninv(8)) +
     +		x*( DBLE(xninv(9)) +x*( DBLE(xninv(10)) +
     +		x*( DBLE(xninv(11)) + zfflo2 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    zfflo2 = x*( DBLE(xninv(3)) + x*( DBLE(xninv(4)) +
     +		x*( DBLE(xninv(5)) + x*( DBLE(xninv(6)) + zfflo2 ))))
	endif
	zfflo2 = - x**2*( DBLE(xninv(2)) + zfflo2 )
*  #] calculations: 
*  #[ check output:
	if ( ltest ) then
	    ier0 = ier
	    d1 = zfflo1(x,ier0) + x
	    xheck = absc(d1-zfflo2)
	    if ( xloss*abs(xheck) .gt. precc ) print *,'zfflo2: error:',
     +		' answer is not OK',d1,zfflo2,xheck
	endif
*  #] check output: 
*###] zfflo2: 
	end
*###[ zfflo3:
	DOUBLE COMPLEX function zfflo3(x,ier)
***#[*comment:***************************************************
*	calculates log(1-x)+x+x^2/2 for |x|<.14 in a faster 	*
*	way to ~15 significant figures.				*
***#]*comment:*************************************************** 
*  #[ declarations:
	implicit none
	integer ier,ier0
	DOUBLE COMPLEX x,d1,zfflo2,cc
	DOUBLE PRECISION bdn01,bdn05,bdn10,bdn15,xprec,xa,xheck,ffbnd,
     +		absc
	save xprec,bdn01,bdn05,bdn10,bdn15
	include 'ff.h'
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations: 
*  #[ initialisation:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
	    precx = precc
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv(3))
	    bdn05 = ffbnd(1,5,xninv(3))
	    bdn10 = ffbnd(1,10,xninv(3))
	    bdn15 = ffbnd(1,15,xninv(3))
	    precx = xprec
	    xprec = precc
	endif
*  #] initialisation: 
*  #[ calculations:
	xa = absc(x)
	if ( xa .gt. bdn15 ) then
	    zfflo3 = zfflo2(x,ier) + x**2/2
	    if ( lwarn .and. absc(zfflo3).lt.xloss*absc(x**2)/2 )
     +		call ffwarn(235,ier,absc(zfflo3),absc(x**2/2))
	    return
	endif
	if ( xa .gt. bdn10 ) then
	    zfflo3 = x*( DBLE(xninv(13)) + x*( DBLE(xninv(14)) +
     +		x*( DBLE(xninv(15)) + x*( DBLE(xninv(16)) +
     +		x*( DBLE(xninv(17)) )))))
	else
	    zfflo3 = 0
	endif
	if ( xa .gt. bdn05 ) then
	    zfflo3 = x*( DBLE(xninv(8)) + x*( DBLE(xninv(9)) +
     +		x*( DBLE(xninv(10)) + x*( DBLE(xninv(11)) +
     +		x*( DBLE(xninv(12)) + zfflo3 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    zfflo3 = x*( DBLE(xninv(4)) + x*( DBLE(xninv(5)) +
     +		x*( DBLE(xninv(6)) + x*( DBLE(xninv(7)) + zfflo3 ))))
	endif
	zfflo3 = - x**3*( DBLE(xninv(3)) + zfflo3 )
*  #] calculations: 
*  #[ check output:
	if ( ltest ) then
	    ier0 = ier
	    d1 = zfflo2(x,ier0) + x**2/2
	    xheck = absc(d1-zfflo3)
	    if ( xloss*abs(xheck) .gt. precc ) print *,'zfflo3: error:',
     +		' answer is not OK',d1,zfflo3,xheck
	endif
*  #] check output: 
*###] zfflo3: 
	end

*###[ ffcrr:
	subroutine ffcrr(crr,ipi12,cy,cy1,cz,cz1,cdyz,ld2yzz,cd2yzz,czz,
     +					czz1,isoort,ieps,ier)
***#[*comment:***********************************************************
*									*
*	calculates R as defined in appendix b:				*
*									*
*			/1   log(y-y1+ieps) - log(y0-y1+ieps)		*
*	r(y0,y1,iesp) = \ dy --------------------------------		*
*			/0		y-y0				*
*									*
*	    = li2(c1) - li2(c2) 					*
*		+ eta(-y1,1/(y0-y1))*log(c1)				*
*		- eta(1-y1,1/(y0-y1))*log(c2)				*
*	with								*
*	    c1 = y0 / (y0-y1), c2 = (y0-1) / (y0-y1)			*
*									*
*	the factors pi^2/12 are passed separately in the integer ipi12	*
*	ier is a status flag: 0=ok, 1=numerical problems, 2=error	*
*									*
*	Input:	cy	(complex)					*
*		cy1	(complex)	1-y				*
*		cz	(complex)					*
*		cz1	(complex)	1-z				*
*		cdyz	(complex)	y-z				*
*		ieps	(integer)	denotes sign imaginary part of	*
*					argument logs (0: don't care;	*
*					+/-1: add -ieps to z; +/-2:	*
*					direct in dilogs, no eta's)	*
*									*
*	Output	crr	(complex)	R modulo factors pi^2/12	*
*		ipi12	(integer)	these factors			*
*		ier	(integer)	lost ier digits, >100: error	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12,isoort,ieps,ier
	logical ld2yzz,lreal
	DOUBLE COMPLEX crr(7),cy,cy1,cz,cz1,cdyz,cd2yzz,czz,czz1
*
*	local variables
*
	DOUBLE COMPLEX check,cfact,cc1,cc2,cc1p,cc2p,carg1,carg2,carg3,
     +		cli1,cli2,cli3,clo1,clo2,clo3,clog1p,clog2p,chill,
     +		cd2,cd21,cd2n,cd21n1,cc1n,cterm,ctot,zfflo1,clog1,clog2,
     +		cr,cr1,cc,cli4,clo4
	DOUBLE COMPLEX clia,clib,ctroep,zfflog
	DOUBLE PRECISION xa,xr,absc,rloss,xprec,bndtay,ffbnd
	integer i,nffeta,nffet1,iclas1,iclas2,ier0,n1,n2,n3,ntot,ipi121,
     +		ipi122,isign,i2pi,n3p
	save xprec,bndtay
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations:
*  #[ initialisations:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
	    bndtay = ffbnd(2,18,xn2inv)
*	    print *,'bndtay = ',bndtay
	endif
*  #] initialisations:
*  #[ check input:
	if ( ltest ) then
	    if ( (isoort.eq.-1 .or. isoort.eq.-3) .and. abs(ieps).eq.1 
     +	    	    .and. abs(DIMAG(cz)).gt.precc*abs(DBLE(cz)) ) then
		if ( DIMAG(cz).gt.0 .eqv. ieps.gt.0 ) then
		    print *,'ffcrr: error: imaginary signs cz and ',
     +			'ieps do not agree: ',cz,ieps
		endif
	    endif
	    rloss = xloss*DBLE(10)**(-mod(ier,50)-2)
	    check = cy + cy1 - 1
	    if ( rloss*absc(check) .gt. precc*max(absc(cy),
     +		absc(cy1),x1)) then
		print *,'ffcrr: error: cy <> 1-cy1',cy,cy1,check
	    endif
	    check = cz + cz1 - 1
	    if( rloss*absc(check) .gt. precc*max(absc(cz),
     +		absc(cz1),x1)) then
		print *,'ffcrr: error: cz <> 1-cz1',cz,cz1,check
	    endif
	    check = cdyz - cy + cz
	    if ( rloss*absc(check) .gt. precc*max(absc(cy),
     +		absc(cz),absc(cdyz)) ) then
		print *,'ffcrr: error: cdyz <> cy-cz',cdyz,cy,cz,check
	    endif
	    if ( ld2yzz ) then
		check = cd2yzz-2*cy+cz+czz
		if( rloss*absc(check).gt.precc*max(absc(cd2yzz),
     +			2*absc(cy),absc(cz),absc(czz)))then
		    print *,'ffcrr: error: cd2yzz<>2cy-cz-czz',cd2yzz,
     +			2*cy,cz,czz,check
		endif
		check = czz + czz1 - 1
		if ( rloss*absc(check) .gt. precc*max(absc(czz),
     +			absc(czz1),x1) ) then
		    print *,'ffcrr: error: 1-czz <> czz1',czz,czz1,check
		endif
	    endif
	endif
	if ( lwrite ) then
	    print *,'ffcrr: input:'
	    print *,'  cy    = ',cy,cy1
	    print *,'  cz    = ',cz,cz1
	    print *,'  cdyz  = ',cdyz
	    if ( ld2yzz ) then
		print *,'  cd2yzz= ',cd2yzz
		print *,'  czz   = ',czz,czz1
	    endif
	    print *,'  cz->cz-eps*',ieps
	    print *,'  isoort= ',isoort
	endif
*  #] check input:
*  #[ arguments:
*
*	get the arguments
*
	xa = absc(cdyz)
	if ( xa .eq. 0 ) then
	    if ( lwarn ) call ffwarn(48,ier,absc(cdyz),x1)
	    return
*	This line is for 68000 compilers that have a limited range for
*	complex division (Absoft, Apollo, Gould NP1):
	elseif ( DBLE(cdyz) .lt. xclogm .or. DIMAG(cdyz) .lt. xclogm
     +		.or. 1/xa .lt. xclogm ) then
	    ctroep = cdyz*DBLE(1/xa)
	    cfact = 1/ctroep
	    cfact = DBLE(1/xa)*cfact
	else
	    cfact = 1/cdyz
	endif
	cc1 = cy * cfact
	cc2 = - cy1 * cfact
*
*	see if we just need the real part
*
	lreal = mod(isoort,5) .eq. 0
*  #] arguments:
*  #[ which area?:
*
*	determine the area:	1={|x|<=1,Re(x)<=1/2},
*				2={|1-x|<=1,Re(x)>1/2}
*				3={|x|>1,|1-x|>1}
*
	xr = DBLE(cc1)
	xa = absc(cc1)
	if ( xa .gt. 1 .and. xa .lt. 1+sqrt(2.) ) then
*	    we need a more accurate estimate
	    xa = xr**2 + DIMAG(cc1)**2
	endif
	if ( ld2yzz .and. absc(cc1+1) .lt. xloss/2 ) then
	    iclas1 = 4
	    cc1p = cc1
	elseif ( xa .le. 1 .and. xr .le. 0.5 ) then
	    iclas1 = 1
	    cc1p = cc1
	elseif ( xa .lt. 1+sqrt(2.) .and. xa .lt. 2*xr ) then
	    iclas1 = 2
	    cc1p = -cz * cfact
	    if ( abs(DIMAG(cc1p)) .lt. precc*abs(DBLE(cc1p)) )
     +		cc1p = DBLE(cc1p)
	else
	    iclas1 = 3
	    if ( 1/xa .lt. xclogm ) then
		ctroep = cc1*DBLE(1/xa)
		ctroep = 1/ctroep
		cc1p = ctroep*DBLE(1/xa)
	    else
		cc1p = 1/cc1
	    endif
	endif
	xr = DBLE(cc2)
	xa = absc(cc2)
	if ( xa .gt. 1 .and. xa .lt. 1+sqrt(2.) ) then
	    xa = xr**2 + DIMAG(cc2)**2
	endif
	if ( ld2yzz .and. absc(cc2+1) .lt. xloss ) then
	    iclas2 = 4
	    cc2p = cc2
	elseif ( xa .le. 1 .and. xr .le. 0.5 ) then
	    iclas2 = 1
	    cc2p = cc2
	elseif ( xa .lt. 1+sqrt(2.) .and. xa .lt. 2*xr ) then
	    iclas2 = 2
	    cc2p = cz1 * cfact
	    if ( abs(DIMAG(cc2p)) .lt. precc*abs(DBLE(cc2p)) )
     +		cc2p = DBLE(cc2p)
	else
	    iclas2 = 3
	    if ( 1/xa .lt. xclogm ) then
		ctroep = cc2*DBLE(1/xa)
		ctroep = 1/ctroep
		cc2p = ctroep*DBLE(1/xa)
	    else
		cc2p = 1/cc2
	    endif
	endif
*
*	throw together if they are close
*
	if ( iclas1 .ne. iclas2 .and. absc(cc1-cc2) .lt. 2*xloss )
     +		then
*	    we don't want trouble with iclasn = 4
	    if ( iclas1 .eq. 4 ) iclas1 = 1
	    if ( iclas2 .eq. 4 ) iclas2 = 1
	    if ( iclas1 .eq. iclas2 ) goto 5
*	    go on
	    if ( iclas1 .le. iclas2 ) then
		iclas2 = iclas1
		if ( iclas1 .eq. 1 ) then
		    cc2p = cc2
		else
		    cc2p = cz1*cfact
		endif
	    else
		iclas1 = iclas2
		if ( iclas1 .eq. 1 ) then
		    cc1p = cc1
		else
		    cc1p = -cz*cfact
		endif
	    endif
	endif
    5	continue
*  #] which area?:
*  #[ eta's:
*
*	get eta1 and eta2
*
	if ( abs(ieps) .ge. 2 .or. isoort .eq. -2 ) then
	    n1 = 0
	    n2 = 0
	else
	if ( DIMAG(cz) .eq. 0 .or. DIMAG(cz1) .eq. 0 ) then
	    if ( DIMAG(cz1) .eq. 0 ) then
		if ( DIMAG(cz) .eq. 0 ) then
*		    cz is really real, the hard case:
		    if ( cz .eq. 0 ) then
*			multiplied with log(1), so don't care:
			n1 = 0
*			look at ieps for guidance
*			n2 = nffet1(DCMPLX(DBLE(0),DBLE(ieps)),cfact,cfact,ier) = 0
			n2 = 0
		    elseif ( cz1 .eq. 0 ) then
			n1 = nffet1(DCMPLX(DBLE(0),DBLE(ieps)),cfact,
     +				-cfact,ier)
			n2 = 0
		    else
			n1 = nffet1(DCMPLX(DBLE(0),DBLE(ieps)),cfact,
     +				-cz*cfact,ier)
			n2 = nffet1(DCMPLX(DBLE(0),DBLE(ieps)),cfact,
     +				cz1*cfact,ier)
		    endif
		else
		    n1 = nffet1(-cz,cfact,-cz*cfact,ier)
		    n2 = nffet1(-cz,cfact,cz1*cfact,ier)
		endif
	    else
		n1 = nffet1(cz1,cfact,-cz*cfact,ier)
		n2 = nffet1(cz1,cfact,cz1*cfact,ier)
	    endif
	else
*	    the imaginary part of cc1, cc1p is often very unstable.
*	    make sure it agrees with the actual sign used.
	    if ( iclas1 .eq. 2 ) then
		if ( DIMAG(cc1p) .eq. 0 ) then
*		    if y (or y1 further on) is purely imaginary
*		    give a random shift, this will also be used in 
*		    the transformation terms.  Checked 7-mar-94 that it 
*		    is independent of the sign used.
		    if ( DBLE(cy).eq.0 ) cy = cy + 
     +		    	isgnal*DBLE(precc)*DIMAG(cy)
		    n1 = nffet1(-cz,cfact,DCMPLX(DBLE(0),ieps*DBLE(cy)),
     +			ier)
		else
		    n1 = nffet1(-cz,cfact,cc1p,ier)
		endif
	    else
		if ( DIMAG(cc1) .eq. 0 ) then
		    if ( DBLE(cy1).eq.0 ) cy1 = cy1 + 
     +		    	isgnal*DBLE(precc)*DIMAG(cy)
		    n1 = nffet1(-cz,cfact,DCMPLX(DBLE(0),
     +					-ieps*DBLE(cy1)),ier)
		else
		    n1 = nffet1(-cz,cfact,-cc1,ier)
		endif
	    endif
	    if ( iclas2 .eq. 2 ) then
		if ( DIMAG(cc2p) .eq. 0 ) then
		    if ( DBLE(cy).eq.0 ) cy = cy +
     +		    	isgnal*DBLE(precc)*DIMAG(cy)
		    n2 = nffet1(cz1,cfact,DCMPLX(DBLE(0),ieps*DBLE(cy)),
     +			ier)
		else
		    n2 = nffet1(cz1,cfact,cc2p,ier)
		endif
	    else
		if ( DIMAG(cc2) .eq. 0 ) then
		    if ( DBLE(cy1).eq.0 ) cy1 = cy1 +
     +		    	isgnal*DBLE(precc)*DIMAG(cy)
		    n2 = nffet1(cz1,cfact,DCMPLX(DBLE(0),
     +					-ieps*DBLE(cy1)),ier)
		else
		    n2 = nffet1(cz1,cfact,-cc2,ier)
		endif
	    endif
	endif
	endif
	if ( lwrite ) then
	    print *,'n1, n2 = ',n1,n2
	endif
*  #] eta's:
*  #[ calculations:
	if ( iclas1 .eq. iclas2 .and. isoort .ne. -2 .and.
     +		( absc(cc1p-cc2p) .lt. 2*xloss*absc(cc1p)
     +		.or. lreal .and. abs(DBLE(cc1p-cc2p)) .lt. 2*xloss*
     +			abs(DBLE(cc1p)) ) ) then
*	    Close together:
* -#[	    handle dilog's:
	    if ( .not.lreal .and. absc(cc2p) .gt. xloss
     +		 .or. lreal .and. ( (abs(DBLE(cc2p)) + DIMAG(cc2p)**2/4)
     +			.gt. xloss .or. abs(DIMAG(cc2p)) .gt. bndtay ) )
     +		then
*--#[		Hill identity:
*
*		Use the Hill identity to get rid of the cancellations.
*
*
*	    first get the arguments:
*
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    carg1 = 1/cy
		    carg2 = 1/cz1
		    carg3 = carg2/cc1p
		elseif ( iclas1 .eq. 2 ) then
		    carg1 = 1/cz
		    carg2 = 1/cy1
		    carg3 = carg2/cc1p
		elseif ( iclas1 .eq. 3 ) then
		    carg1 = 1/cy1
		    carg3 = 1/cz1
		    carg2 = carg3*cc1p
		endif
		call ffzli2(cli1,clo1,carg1,lreal,ier)
		call ffzli2(cli2,clo2,carg2,lreal,ier)
		call ffzli2(cli3,clo3,carg3,lreal,ier)
		if ( absc(cc2p) .lt. xloss ) then
		    clog2p = zfflo1(cc2p,ier)
		else
		    clog2p = zfflog(1-cc2p,0,c0,ier)
		endif
		chill = clo1*clog2p
*debug		the sum of these terms should be Li2(cc1p)-Li2(cc2p)
*		if ( lwrite ) then
*		    csum  = cli1 + cli2 - cli3 + chill
*		    call ffzli2(clia,ctroep,cc1p,lreal,ier0)
*		    call ffzli2(clib,ctroep,cc2p,lreal,ier0)
*		    print *,'      check Hill'
*		    print *,'      oorspr:',clia - clib
*		    print *,'      nu    :',csum
*		endif
*--#]		Hill identity:
	    else
*--#[		Taylor expansion:
*
*		if the points are close to zero do a Taylor
*		expansion of the first and last dilogarithm
*
*			Li2(cc1p) - Li2(cc2p)
*			  = sum cc1p^i ( 1-(1-cd2)^i ) /i^2
*
*		with cd2 = 1-cc2p/cc1p = ...
*
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    cd2 = 1/cy
		elseif ( iclas1 .eq. 2 ) then
		    cd2 = 1/cz
		elseif ( iclas1 .eq. 3 ) then
		    cd2 = 1/cy1
		endif
		cd21 = 1-cd2
		cd21n1 = 1
		cc1n = cc1p
		cd2n = cd2
		ctot = cc1p*cd2
		do 50 i=2,20
		    cc1n = cc1n*cc1p
		    cd21n1 = cd21n1*cd21
		    cd2n = cd2n + cd2*cd21n1
		    cterm = cc1n*cd2n*DBLE(xn2inv(i))
		    ctot = ctot + cterm
		    if ( absc(cterm) .le. precc*absc(ctot) .or.
     +			 lreal .and. abs(DBLE(cterm)) .le. precc*
     +				abs(DBLE(ctot)) ) goto 51
   50		continue
		if ( lwarn ) call ffwarn(54,ier,absc(ctot),absc(cterm))
   51		continue
		cli1 = ctot
		cli2 = 0
		cli3 = 0
		chill = 0
*		for the eta+transformation section we also need
		if ( iclas1 .ne. 1 ) clo1 = zfflo1(cd2,ier)
		if ( iclas1 .eq. 2 ) clo2 = zfflo1(1/cy1,ier)
*		check of Taylor expansion
*		if (lwrite) then
*		    call ffzli2(clia,ctroep,cc1p,lreal,ier0)
*		    call ffzli2(clib,ctroep,cc2p,lreal,ier0)
*		    print *,'      check Taylor'
*		    print *,'      oorspr:',clia-clib
*		    print *,'      nu    :',cli1
*		endif
*--#]		Taylor expansion:
	    endif
*
* -#]	    handle dilog's:
* -#[	    handle eta + transformation terms:
	    if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
*--#[		no transformation:
*
*		no transformation was made.
*
*		crr(5) = 0
		if ( n1 .ne. n2 ) then
		    if ( lwarn ) call ffwarn(49,ier,x1,x0)
		    if ( absc(cc1) .lt. xclogm ) then
			call fferr(23,ier)
		    else
*			imaginary part not checked
			ier = ier + 50
			crr(5) = (n1-n2)*c2ipi*zfflog(cc1,ieps,-cy,ier)
		    endif
		endif
*		crr(6) = 0
*		crr(7) = 0
		if ( n2 .ne. 0 ) then
		    crr(6) = - n2*c2ipi*clo1
		    n3 = nffeta(cc2,1/cc1,ier)
		    if ( n3 .ne. 0 ) then
			if ( lwarn ) call ffwarn(49,ier,x1,x0)
			crr(7) = n2*n3*c2ipi**2
*		    else
*			crr(7) = 0
		    endif
		endif
		if (lwrite) then
		    clog1 = zfflog(cc1,ieps,-cy,ier)
		    clog2 = zfflog(cc2,ieps,cy1,ier)
*		    print *,'      check geen trans'
*		    print *,'      oorspr:',c2ipi*(n1*clog1-n2*clog2)
*		    print *,'      nu    :',crr(5)+crr(6)+crr(7)
		endif
*--#]		no transformation:
	    elseif ( iclas1 .eq. 2 ) then
*--#[		transform 1-x:
*
*		we tranformed to 1-x for both dilogs
*
		if ( absc(cc1p) .lt. xloss ) then
		    clog1 = zfflo1(cc1p,ier)
		else
		    clog1 = zfflog(cc1,ieps,-cy,ier)
		endif
		if ( DIMAG(cc2p).eq.0 ) then
		    if ( DIMAG(cc1p).eq.0 ) then
*			use the ieps instead
			n3 = 0
		    else
			n3 = nffet1(DCMPLX(DBLE(0),ieps*DBLE(cy)),
     +				1/cc1p,cc2p/cc1p,ier)
		    endif
		else
		    if ( DIMAG(cc1p).eq.0 ) then
			n3 =nffet1(cc2p,DCMPLX(DBLE(0),-ieps*DBLE(cy1)),
     +				cc2p/cc1p,ier) 
		    else
			n3 = nffet1(cc2p,1/cc1p,cz,ier)
		    endif
		endif
		ntot = n1-n2-n3
		crr(5) = (ntot*c2ipi + clo1)*clog1
		clog2p = zfflog(cc2p,ieps,cy,ier)
		crr(6) = clo2*(n2*c2ipi - clog2p)
*		crr(7) = 0
*		if (lwrite) then
*		    clog1p = zfflog(cc1p,ieps,cy,ier)
*		    clog2 = zfflog(cc2,ieps,cy1,ier)
*		    print *,'      check trans 1-x'
*		    print *,'      oorspr:',c2ipi*(n1*clog1-n2*clog2)-
*     +				clog1*clog1p+clog2*clog2p
*		    print *,'      nu    :',crr(5)+crr(6)+crr(7)
*		endif
*--#]		transform 1-x:
	    elseif ( iclas1 .eq. 3 ) then
*--#[		transform 1/x:
*
*		we transformed to 1/x for both dilogs
*
*should be in clas=4:if ( ld2yzz .and. absc(cc2p+1) .lt. xloss ) then
*		    ctroep = czz1 - cd2yzz
*		    if ( lwarn .and. absc(ctroep) .lt. xloss*absc(czz1) )
*     +			call ffwarn(57,ier,absc(ctroep),absc(czz1))
*		    clog2p = zfflo1(ctroep/cy1,ier)
*		else
		    clog2p = zfflog(-cc2p,ieps,cy1,ier)
*		endif
		if ( DIMAG(cc2p).eq.0 .or. DIMAG(cc1).eq.0 ) then
*		    we chose the eta's already equal, no worry.
		    n3 = 0
		    n3p = 0
		else
		    n3 = nffet1(-cc2p,-cc1,-cy/cy1,ier)
		    n3p = nffet1(cc2p,cc1,-cy/cy1,ier)
		endif
		if ( n3.ne.0 .or. n3p.ne.0 .or. n1.ne.n2 ) then
		    if ( lwarn ) call ffwarn(49,ier,x1,x0)
*		    for the time being the normal terms, I'll have to think of
*		    something smarter one day
		    clog1p = zfflog(-cc1p,ieps,-cy,ier)
		    crr(5) = -clog1p**2/2
		    crr(6) = +clog2p**2/2
		    crr(7) = (n1*zfflog(cc1,ieps,cy,ier) -
     +				n2*zfflog(cc2,ieps,-cy1,ier))*c2ipi
		else
		    crr(5) = clo1*(n2*c2ipi + clog2p - clo1/2)
		endif
*--#]		transform 1/x:
	    endif
* -#]	    handle eta + transformation terms:
* -#[	    add up and print out:
	    if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		crr(1) = cli1
		crr(2) = cli2
		crr(3) = - cli3
		crr(4) = chill
	    else
		crr(1) = - cli1
		crr(2) = - cli2
		crr(3) = cli3
		crr(4) = - chill
	    endif
	    if ( lwrite ) then
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    isign = 1
		else
		    isign = -1
		endif
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    cr = cli1+cli2-cli3+chill+crr(5)+crr(6)+crr(7)
		else
		    cr = -cli1-cli2+cli3-chill+crr(5)+crr(6)+crr(7)
		endif
		print *,'ffcrr: Close together'
		print *,'       oorspronkeijk:',cc1
		print *,'                    :',cc2
		print *,'       iclas = ',iclas1
		print *,'       Li2''s:',cli1*isign
		print *,'            :',cli2*isign
		print *,'            :',-cli3*isign
		print *,'       logs :',chill*isign
		print *,'       eta''s:',crr(5)
		print *,'            :',crr(6)
		print *,'            :',crr(7)
		print '(a,2g24.15,2i6)','    cr is dus:',cr,ipi12,ier
	    endif
* -#]	    add up and print out:
	else
*	    Normal case:
* -#[	    handle dilogs:
*
*	    the dilogs will not come close together so just go on
*	    only the special case cc1p ~ (-1,0) needs special attention
*
	    if ( iclas1 .ne. 4 .or. .not. ld2yzz ) then
		call ffzli2(cli1,clo1,cc1p,lreal,ier)
	    else
		cd2 = cd2yzz + czz
		if ( absc(cd2) .lt. xloss*absc(cd2yzz) ) then
		    if ( lwrite ) print *,'cd2  = ',cd2
		    cd2 = cy + cdyz
		    if ( lwrite ) print *,'cd2+ = ',cd2
		    if ( lwarn .and. abs(cd2) .lt. xloss*absc(cdyz) )
     +			call ffwarn(56,ier,absc(cd2),absc(cdyz))
		endif
		cd2 = cd2/cdyz
		cfact = 1/(2-cd2)
		call ffzli2(cli1,clo1,cd2*cfact,lreal,ier)
		call ffzli2(cli3,clo3,-cd2*cfact,lreal,ier)
		call ffzli2(cli4,clo4,cd2,lreal,ier)
	    endif
	    if ( iclas2 .ne. 4 .or. .not. ld2yzz ) then
		call ffzli2(cli2,clo2,cc2p,lreal,ier)
	    else
		if ( iclas1 .eq. 4 ) call fferr(26,ier)
		cd2 = cd2yzz - czz1
		if ( absc(cd2) .lt. xloss*absc(cd2yzz) ) then
		    if ( lwrite ) print *,'cd2  = ',cd2
		    cd2 = cdyz - cy1
		    if ( lwrite ) print *,'cd2+ = ',cd2
		    if ( lwarn .and. absc(cd2) .lt. xloss*absc(cdyz) )
     +			call ffwarn(57,ier,absc(cd2),absc(cdyz))
		endif
		cd2 = cd2/cdyz
		cfact = 1/(2-cd2)
		call ffzli2(cli2,clo2,cd2*cfact,lreal,ier)
		call ffzli2(cli3,clo3,-cd2*cfact,lreal,ier)
		call ffzli2(cli4,clo4,cd2,lreal,ier)
	    endif
* -#]	    handle dilogs:
* -#[	    handle eta terms:
*
*	    the eta's
*
	    if ( n1 .ne. 0 ) then
		if ( iclas1 .ne. 2 .or. absc(cc1p) .gt. xloss ) then
		    if ( DBLE(cc1) .gt. -abs(DIMAG(cc1)) ) then
			clog1 = zfflog(cc1,ieps,cy,ier)
		    else
*			take apart the factor i*pi^2
			if ( iclas1 .eq. 4 ) then
			    clog1 = zfflo1(cd2,ier)
			else
			    clog1 = zfflog(-cc1,0,cy,ier)
			endif
			if ( DIMAG(cc1) .lt. 0 ) then
			    i2pi = -1
			elseif ( DIMAG(cc1) .gt. 0 ) then
			    i2pi = +1
			elseif ( DBLE(cy)*ieps .lt. 0 ) then
			    i2pi = -1
			elseif ( DBLE(cy)*ieps .gt. 0 ) then
			    i2pi = +1
			else
			    call fferr(51,ier)
			    i2pi = 0
			endif
			ipi12 = ipi12 - n1*24*i2pi
		    endif
		else
		    clog1 = zfflo1(cc1p,ier)
		endif
		crr(5) = n1*c2ipi*clog1
*	    else
*		crr(5) = 0
	    endif
	    if ( n2 .ne. 0 ) then
		if ( iclas2 .ne. 2 .or. absc(cc2p) .gt. xloss ) then
		    if ( DBLE(cc2) .gt. -abs(DIMAG(cc2)) ) then
			clog2 = zfflog(cc2,ieps,cy,ier)
		    else
*			take apart the factor i*pi^2
			if ( iclas2 .eq. 4 ) then
			    clog2 = zfflo1(cd2,ier)
			else
			    clog2 = zfflog(-cc2,0,c0,ier)
			endif
			if ( DIMAG(cc2) .lt. 0 ) then
			    i2pi = -1
			elseif ( DIMAG(cc2) .gt. 0 ) then
			    i2pi = +1
			elseif ( DBLE(cy)*ieps .lt. 0 ) then
			    i2pi = -1
			elseif ( DBLE(cy)*ieps .gt. 0 ) then
			    i2pi = +1
			else
			    call fferr(51,ier)
			    i2pi = 0
			endif
			ipi12 = ipi12 + n2*24*i2pi
		    endif
		else
		    clog2 = zfflo1(cc2p,ier)
		endif
		crr(6) = n2*c2ipi*clog2
*	    else
*		crr(6) = 0
	    endif
* -#]	    handle eta terms:
* -#[	    handle transformation terms:
*
*	    transformation of cc1
*
	    if ( iclas1 .eq. 1 ) then
*		crr(3) = 0
	    elseif( iclas1 .eq. 2 ) then
		cli1 = -cli1
		ipi12 = ipi12 + 2
		crr(3) = - clo1*zfflog(cc1p,ieps,cy,ier)
	    elseif ( iclas1 .eq. 3 ) then
		cli1 = -cli1
		ipi12 = ipi12 - 2
		clog1p = zfflog(-cc1p,ieps,cy1,ier)
		crr(3) = - clog1p**2/2
		if ( lwrite ) print *,'clog1p = ',clog1p
	    elseif ( iclas1 .eq. 4 ) then
*		Note that this sum does not cause problems as d2<<1
		crr(3) = -cli3 - cli4 + clo4*zfflog(cfact,0,c0,ier)
		ipi12 = ipi12 - 1
		if ( lwrite ) then
		    print *,'Check iclas1 = 4'
		    print '(a,2g14.8)','Nu:   ',cli1+crr(3)
		    call ffzli2(clia,ctroep,cc1p,lreal,ier)
		    print '(a,2g14.8)','Eerst:',clia+DBLE(pi12)
		endif
	    else
		call fferr(25,ier)
	    endif
*
*	    transformation of cc2
*
	    if ( iclas2 .eq. 1 ) then
*		crr(4) = 0
	    elseif( iclas2 .eq. 2 ) then
		cli2 = -cli2
		ipi12 = ipi12 - 2
		crr(4) = clo2*zfflog(cc2p,ieps,cy,ier)
	    elseif ( iclas2 .eq. 3 ) then
		cli2 = -cli2
		ipi12 = ipi12 + 2
		clog2p = zfflog(-cc2p,ieps,cy1,ier)
		crr(4) = clog2p**2/2
		if ( lwrite ) print *,'clog2p = ',clog2p
	    elseif ( iclas2 .eq. 4 ) then
*		Note that this sum does not cause problems as d2<<1
		crr(4) = cli3 + cli4 - clo4*zfflog(cfact,0,c0,ier)
		ipi12 = ipi12 + 1
		if ( lwrite ) then
		    print *,'Check iclas2 = 4'
		    print '(a,2g14.8)','Nu:   ',-cli2+crr(4)
		    call ffzli2(clia,ctroep,cc2p,lreal,ier)
		    print '(a,2g14.8)','Eerst:',-clia-DBLE(pi12)
		endif
	    else
		call fferr(27,ier)
	    endif
* -#]	    handle transformation terms:
* -#[	    sum and print:
	    crr(1) = cli1
	    crr(2) = - cli2
	    crr(6) = - crr(6)
*	    crr(7) = 0
	    if(lwrite)then
		cr = cli1 - cli2 + crr(5) + crr(6) + crr(3) + crr(4)
		print *,'ffcrr: Normal case'
		print *,'       oorspronkelijk:',cc1
		print *,'       iclas1 = ',iclas1
		if(iclas1.ne.1)print *,'                   nu:',cc1p
		print *,'       Li21 :',cli1
		if(n1.ne.0)print *,'       eta1 :',crr(5)
		if(iclas1.ne.1)print *,'       tran1:',crr(3)
		print *,'       oorspronkelijk:',cc2
		print *,'       iclas2 = ',iclas2
		if(iclas2.ne.1)print *,'                   nu:',cc2p
		print *,'       Li22 :',cli2
		if(n2.ne.0)print *,'       eta2 :',-crr(6)
		if(iclas2.ne.1)print *,'       tran2:',-crr(4)
		print '(a,2g24.15,2i6)','    cr is dus:',cr,ipi12,ier
		if(ipi12.ne.0)print '(a,2g24.15)','             =',
     +			cr+ipi12*DBLE(pi12)
	    endif
* -#]	    sum and print:
	endif
*  #] calculations:
*  #[ debug:
	if(lwrite)then
	    ier0 = 0
	    call ffzzdl(cli1,ipi121,ctroep,cc1,ier0)
	    call ffzzdl(cli2,ipi122,ctroep,cc2,ier0)
	    if ( n1 .ne. 0 .and. absc(cc1) .gt. xclogm ) then
		clo1 = log(cc1)
	    else
		clo1 = 0
	    endif
	    if ( n2 .ne. 0 .and. absc(cc2) .gt. xclogm ) then
		clo2 = log(cc2)
	    else
		clo2 = 0
	    endif
	    cr1 = cli1-cli2+c2ipi*(n1*clo1-n2*clo2)+(ipi121-ipi122)*
     +		DBLE(pi12)
	    print '(a,2g24.15,i3)','    verg. cr1:',cr1
	    if(n1.ne.0)print *,'    met n1*clo1 = ',n1*clo1*c2ipi
	    if(n2.ne.0)print *,'    met n2*clo2 = ',n2*clo2*c2ipi
	endif
*  #] debug:
*###] ffcrr:
	end
*###[ ffcxr:
	subroutine ffcxr(crr,ipi12,y,y1,z,z1,dyz,ld2yzz,d2yzz,zz,zz1,
     +		ldy2z,dy2z,ieps,ier)
***#[*comment:***********************************************************
*									*
*	calculates R as defined in appendix b:				*
*									*
*		   /1    log(x-z+i*eps) - log(y-z+i*eps)		*
*	r(y,z)  =  \ dx  -----------------------------------		*
*		   /0		      x-y				*
*									*
*	    = li2(y/(y-z)+i*eps') - li2((y-1)/(y-z)+i*eps')		*
*									*
*	y,z are real, ieps integer denoting the sign of i*eps.		*
*	factors pi^2/12 are passed in the integer ipi12.		*
*									*
*	Input:	y	(real)						*
*		y1	(real)		1-y				*
*		z	(real)						*
*		z1	(real)		1-z				*
*		dyz	(real)		y-z				*
*									*
*		ld2yzz	(logical)	if .TRUE. also defined are:	*
*		d2yzz	(real)		2*y - z^+ - z^-			*
*		zz	(real)		the other z-root		*
*		zz1	(real)		1 - zz				*
*									*
*		ieps	(integer)	if +/-1 denotes sign imaginary	*
*					part of	argument logs		*
*		ieps	(integer)	if +/-2 denotes sign imaginary	*
*					part of	argument dilogs		*
*									*
*	Output	crr	(complex)	R modulo factors pi^2/12	*
*		ipi12	(integer)	these factors			*
*		ier	(intger)	0=ok, 1=num prob, 2=error	*
*									*
*	Calls:	ffxli2,(test: ffzxdl),dfflo1,zxfflg			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12,ieps,ier
	logical ld2yzz,ldy2z
	DOUBLE PRECISION y,y1,z,z1,dyz,d2yzz,zz,zz1,dy2z(3)
	DOUBLE COMPLEX crr(7)
*
*	local variables
*
        integer i,iclas1,iclas2,iteken,ieps1,ieps2,ipi121,ipi122,ierdum
	logical taylor
	DOUBLE PRECISION xheck,fact,xx1,xx2,xx1p,xx2p,arg2,arg3,
     +		xli1,xli2,xli3,xlo1,xlo2,xlo3,xhill,xlog1,
     +		xlog2p,xx1n,d2,d21,d2n,d21n1,term,tot,xlia,xtroep,xli4,
     +		xlo4,rloss,som,xmax
	DOUBLE COMPLEX cr,cr1,clog1p,clog2p,ctroep,cli1,cli2
	DOUBLE PRECISION dfflo1
	DOUBLE COMPLEX zxfflg
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffcxr: input:'
	    print *,'  y    = ',y,y1
	    print *,'  z    = ',z,z1
	    print *,'  dyz  = ',dyz
	    if ( ld2yzz ) then
		print *,'  d2yzz= ',d2yzz
		print *,'  zz   = ',zz,zz1
	    endif
	    if ( ldy2z ) then
		print *,'  dy2z = ',dy2z(1),dy2z(3)
	    endif
	    print *,'  z->z - eps*',ieps
	endif
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    xheck = y + y1 - 1
	    if ( rloss*abs(xheck).gt.precx*max(abs(y),abs(y1),x1) ) then
		print *,'ffcxr: error: 1-y <> y1',y,y1,xheck,ier
	    endif
	    xheck = z + z1 - 1
	    if ( rloss*abs(xheck).gt.precx*max(abs(z),abs(z1),x1) ) then
		print *,'ffcxr: error: 1-z <> z1',z,z1,xheck,ier
	    endif
	    xheck = dyz - y + z
	    if ( rloss*abs(xheck).gt.precx*max(abs(z),abs(y),abs(dyz)) )
     +			then
		print *,'ffcxr: error: dyz<>y-z',dyz,y,z,xheck,ier
	    endif
	    if ( ld2yzz ) then
		xheck = d2yzz-2*y+z+zz
		if ( rloss*abs(xheck).gt.precx*max(abs(d2yzz),abs(2*y),
     +			abs(z),abs(zz)) ) then
		    print *,'ffcxr: error: d2yzz<>2y-z-zz',d2yzz,2*y,z,
     +			zz,xheck,ier
		endif
		xheck = zz + zz1 - 1
		if ( rloss*abs(xheck) .gt. precx*max(abs(zz),abs(zz1),
     +			x1)) then
		    print *,'ffcxr: error: 1-zz <> zz1',zz,zz1,xheck
		endif
	    endif
	    if ( ldy2z ) then
		xheck = dy2z(1)-y+2*z
		if ( rloss*abs(xheck).gt.precx*max(abs(dy2z(1)),abs(y),
     +			abs(2*z)) ) then
		    print *,'ffcxr: error: dy2z<>y-2z',dy2z(1),y,2*z,
     +			xheck,ier
		endif
		xheck = dy2z(3)-y1+2*z1
		if ( rloss*abs(xheck).gt.precx*max(abs(dy2z(2)),abs(y1),
     +			abs(2*z1)) ) then
		    print *,'ffcxr: error: dy2z1<>y1-2z1',dy2z(3),y1,
     +			2*z1,xheck,ier
		endif
	    endif
	    if ( abs(ieps).gt.2 ) then
		print*,'ffcxr: ieps is not -2,..2 ',ieps
	    endif
	endif
*  #] check input:
*  #[ groundwork:
	taylor = .FALSE.
*
*	get the arguments
*
	if ( dyz .eq. 0 ) then
	    if ( lwarn ) call ffwarn(51,ier,dyz,x1)
	    return
	endif
	fact = 1/dyz
	xx1 = y * fact
	xx2 = - y1 * fact
*
*  #] groundwork:
*  #[ which area?:
*
*	determine the area:	1 = [-1+xloss,1/2]
*				2 = (1/2,2-xloss]
*				3 = [2+xloss,->) U (<-,-1-xloss]
*				4 = [-1-xloss,-1+xloss]
*				5 = [2-xloss,2+xloss]
*
	if ( xx1 .lt. -1-xloss/2 ) then
	    iclas1 = 3
	    xx1p = 1/xx1
	elseif( xx1 .lt. -1+xloss/2 ) then
	    if ( ld2yzz ) then
		iclas1 = 4
	    else
		iclas1 = 1
	    endif
	    xx1p = xx1
	elseif( xx1 .le. x05 ) then
	    iclas1 = 1
	    xx1p = xx1
	elseif ( xx1 .lt. 2-xloss ) then
	    iclas1 = 2
	    xx1p = -z*fact
	elseif ( ldy2z .and. xx1 .lt. 2+xloss ) then
	    iclas1 = 5
	    xx1p = dy2z(1)*fact
	else
	    iclas1 = 3
	    xx1p = 1/xx1
	endif
	if ( xx2 .lt. -1-xloss/2 ) then
	    iclas2 = 3
	    xx2p = 1/xx2
	elseif( xx2 .lt. -1+xloss/2 ) then
	    if ( ld2yzz ) then
		iclas2 = 4
	    else
		iclas2 = 1
	    endif
	    xx2p = xx2
	elseif ( xx2 .le. x05 ) then
	    iclas2 = 1
	    xx2p = xx2
	elseif ( xx2 .lt. 2-xloss ) then
	    iclas2 = 2
	    xx2p = z1*fact
	elseif ( ldy2z .and. xx2 .lt. 2+xloss ) then
	    iclas2 = 5
	    xx2p = -dy2z(3)*fact
	else
	    iclas2 = 3
	    xx2p = 1/xx2
	endif
*
*	throw together if they are close
*
	if ( iclas1 .ne. iclas2 .and. abs(xx1-xx2) .lt. 2*xloss )
     +		then
*	    we don't want trouble with iclasn = 4,5
	    if ( iclas1 .eq. 4 ) then
		iclas1 = 1
	    elseif ( iclas1 .eq. 5 ) then
		iclas1 = 3
		xx1p = 1/xx1
	    endif
	    if ( iclas2 .eq. 4 ) then
		iclas2 = 1
	    elseif ( iclas2 .eq. 5 ) then
		iclas2 = 3
		xx2p = 1/xx2
	    endif
	    if ( iclas1 .eq. iclas2 ) goto 5
*	    go on
	    if ( iclas1 .le. iclas2 ) then
		iclas2 = iclas1
		if ( iclas1 .eq. 1 ) then
		    xx2p = xx2
		else
		    xx2p = z1*fact
		endif
	    else
		iclas1 = iclas2
		if ( iclas1 .eq. 1 ) then
		    xx1p = xx1
		else
		    xx1p = -z*fact
		endif
	    endif
	endif
*  #] which area?:
*  #[ calculations:
    5	if ( iclas1 .eq. iclas2 .and.
     +		abs(xx1p-xx2p) .lt. 2*xloss*max(abs(xx1p),abs(xx2p))
     +		.and. iclas1 .ne. 5 ) then
*		      |----->temporary!
*	    Close together:
* -#[	    handle dilog's:
	    if ( abs(xx2p) .gt. xloss ) then
*--#[		Hill identity:
*
*		Use the Hill identity to get rid of the cancellations.
*
*
*	    first get the arguments:
*
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    d2 = 1/y
		    arg2 = 1/z1
		    arg3 = arg2/xx1p
		elseif ( iclas1 .eq. 2 ) then
		    d2 = 1/z
		    arg2 = 1/y1
		    arg3 = arg2/xx1p
		elseif ( iclas1 .eq. 3 ) then
		    d2 = 1/y1
		    arg3 = 1/z1
		    arg2 = arg3*xx1p
		endif
		call ffxli2(xli1,xlo1,d2,ier)
		call ffxli2(xli2,xlo2,arg2,ier)
		call ffxli2(xli3,xlo3,arg3,ier)
		if ( abs(xx2p) .lt. xloss ) then
		    xlog2p = dfflo1(xx2p,ier)
		else
		    xlog2p = zxfflg(1-xx2p,0,x1,ier)
		endif
		xhill = xlo1*xlog2p
*--#]		Hill identity:
	    else
*--#[		Taylor expansion:
*
*		if the points are close to zero do a Taylor
*		expansion of the first and last dilogarithm
*
*			Li2(xx1p) - Li2(xx2p)
*			  = sum xx1p^i ( 1-(1-d2)^i ) /i^2
*
*		with d2 = 1-xx2p/xx1p = ...
*
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    d2 = 1/y
		elseif ( iclas1 .eq. 2 ) then
		    d2 = 1/z
		elseif ( iclas1 .eq. 3 ) then
		    d2 = 1/y1
		endif
*		flag to the print section that we did a Taylor expansion
		if ( lwrite ) taylor = .TRUE.
		d21 = 1-d2
		d21n1 = 1
		xx1n = xx1p
		d2n = d2
		tot = xx1p*d2
*		check for possible underflow on the next line
		if ( abs(xx1p) .lt. xalog2 ) goto 51
		do 50 i=2,20
		    xx1n = xx1n*xx1p
		    d21n1 = d21n1*d21
		    d2n = d2n + d2*d21n1
		    term = xx1n*d2n*xn2inv(i)
		    tot = tot + term
		    if ( abs(term) .le. precx*abs(tot) ) goto 51
   50		continue
		if ( lwarn ) call ffwarn(55,ier,abs(tot),abs(term))
   51		continue
		xli1 = tot
		xli2 = 0
		xli3 = 0
		xhill = 0
*		for the eta+transformation section we also need
		if ( iclas1 .ne. 1 ) then
		    if ( abs(d2) .lt. xloss ) then
			xlo1 = dfflo1(d2,ier)
		    else
			xlo1 = zxfflg(d21,0,x1,ier)
		    endif
		endif
		if ( iclas1 .eq. 2 ) xlo2 = dfflo1(1/y1,ier)
*--#]		Taylor expansion:
	    endif
*
* -#]	    handle dilog's:
* -#[	    handle transformation terms:
	    if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
*
*		no transformation was made.
*
*		crr(5) = 0
*		crr(6) = 0
	    elseif ( iclas1 .eq. 2 ) then
*
*		we tranformed to 1-x for both dilogs
*
		if ( abs(xx1p) .lt. xloss ) then
		    xlog1 = dfflo1(xx1p,ier)
		else
		    xlog1 = zxfflg(xx1,0,x1,ier)
		endif
		crr(5) = xlo1*xlog1
		clog2p = zxfflg(xx2p,ieps,-y1,ier)
*		if ( abs(xx2p) .lt. xalogm ) then
*		    if ( lwarn .and. xx2p .ne. 0 ) call ffwarn(53,ier,xx2p,xalogm)
*		    clog2p = 0
*		elseif ( xx2p .gt. 0 ) then
*		    clog2p = log(xx2p)
*		else
*		    xlog2p = log(-xx2p)
*		    checked imaginary parts 19-May-1988
*		    if ( abs(ieps) .eq. 1 ) then
*			if ( y1*ieps .gt. 0 ) then
*			    clog2p = DCMPLX(xlog2p,-pi)
*			else
*			    clog2p = DCMPLX(xlog2p,pi)
*			endif
*		    elseif ( ieps .eq. 2 ) then
*			clog2p = DCMPLX(xlog2p,-pi)
*		    else
*			clog2p = DCMPLX(xlog2p,pi)
*		    endif
*		endif
		crr(6) = -DBLE(xlo2)*clog2p
		if (lwrite) then
		    clog1p = zxfflg(xx1p,ieps,y,ier)
		endif
	    elseif ( iclas1 .eq. 3 ) then
*
*		we transformed to 1/x for both dilogs
*
		clog2p = zxfflg(-xx2p,-ieps,-y1,ier)
*		if ( abs(xx2p) .lt. xalogm ) then
*		    if ( lwarn ) call ffwarn(53,ier,xx2p,xalogm)
*		    clog2p = 0
*		elseif ( xx2p .lt. 0 ) then
*		    clog2p = log(-xx2p)
*		else
*		    xlog2p = log(xx2p)
*		    checked imaginary parts 19-May-1988
*		    if ( abs(ieps) .eq. 1 ) then
*			if ( ieps*y1 .gt. 0 ) then
*			    clog2p = DCMPLX(xlog2p,pi)
*			else
*			    clog2p = DCMPLX(xlog2p,-pi)
*			endif
*		    elseif ( ieps .eq. 2 ) then
*			clog2p = DCMPLX(xlog2p,-pi)
*		    else
*			clog2p = DCMPLX(xlog2p,pi)
*		    endif
*		endif
		crr(5) = DBLE(xlo1)*(clog2p - DBLE(xlo1)/2)
*		crr(6) = 0
		if (lwrite) then
		    clog1p = zxfflg(xx1p,ieps,y,ier)
		endif
	    endif
* -#]	    handle transformation terms:
* -#[	    add up and print out:
	    if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		crr(1) = xli1
		crr(2) = xli2
		crr(3) = - xli3
		crr(4) = xhill
	    else
		crr(1) = - xli1
		crr(2) = - xli2
		crr(3) = xli3
		crr(4) = - xhill
	    endif
*	    crr(7) = 0
*	    ipi12 = 0
	    if ( lwrite ) then
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    iteken = 1
		else
		    iteken = -1
		endif
		if ( iclas1 .eq. 1 .or. iclas1 .eq. 4 ) then
		    cr = DBLE(xli1+xli2-xli3+xhill) + crr(5) + crr(6)
		else
		    cr = DBLE(-xli1-xli2+xli3-xhill) + crr(5) + crr(6)
		endif
		print *,'ffcxr: Close together'
		print *,'       oorspronkeijk:',xx1
		print *,'                    :',xx2
		print *,'       iclas = ',iclas1
		print *,'       Li2''s:',xli1*iteken
		if ( .not.taylor ) then
		print *,'            :',xli2*iteken
		print *,'            :',-xli3*iteken
		endif
		print *,'       log''s:',xhill*iteken
		print *,'       eta''s:',crr(5)
		print *,'            :',crr(6)
		print '(a,2g24.15,2i3)','    cr is dus:',cr,ipi12,ier
	    endif
* -#]	    add up and print out:
	else
*	    Normal case:
* -#[	    handle dilogs:
*
*	    the dilogs will not come close together so just go on
*	    only the special case xx1p ~ -1 needs special attention
*	    - and the special case xx1 ~ 2 also needs special attention
*
	    if ( iclas1 .eq. 4 ) then
		d2 = d2yzz + zz
		xmax = abs(d2yzz)
		if ( abs(d2) .lt. xloss*xmax ) then
		    if ( lwrite ) print *,'d2  = ',d2,xmax
		    som = y + dyz
		    if ( lwrite ) print *,'d2+ = ',som,abs(y)
		    if ( abs(y).lt.xmax ) then
			d2 = som
			xmax = abs(y)
		    endif
		    if ( lwarn .and. abs(d2) .lt. xloss*xmax ) then
			call ffwarn(58,ier,d2,xmax)
		    endif
		endif
		d2 = d2/dyz
		fact = 1/(2-d2)
		call ffxli2(xli1,xlo1,d2*fact,ier)
		call ffxli2(xli3,xlo3,-d2*fact,ier)
		call ffxli2(xli4,xlo4,d2,ier)
	    elseif ( iclas1 .eq. 5 ) then
		call ffxl22(xli1,xx1p,ier)
		ipi12 = ipi12 + 3
	    else
		call ffxli2(xli1,xlo1,xx1p,ier)
	    endif
	    if ( iclas2 .eq. 4 ) then
		if ( iclas1 .eq. 4 ) call fferr(26,ier)
		d2 = d2yzz - zz1
		xmax = abs(d2yzz)
		if ( abs(d2) .lt. xloss*xmax ) then
		    if ( lwrite ) print *,'d2  = ',d2,xmax
		    som = dyz - y1
		    if ( lwrite ) print *,'d2+ = ',som,abs(y1)
		    if ( abs(y1).lt.xmax ) then
			d2 = som
			xmax = abs(y1)
		    endif
		    if ( lwarn .and. abs(d2) .lt. xloss*xmax ) then
			call ffwarn(59,ier,d2,xmax)
		    endif
		endif
		d2 = d2/dyz
		fact = 1/(2-d2)
		call ffxli2(xli2,xlo2,d2*fact,ier)
		call ffxli2(xli3,xlo3,-d2*fact,ier)
		call ffxli2(xli4,xlo4,d2,ier)
	    elseif ( iclas2 .eq. 5 ) then
		call ffxl22(xli2,xx2p,ier)
		ipi12 = ipi12 - 3
	    else
		call ffxli2(xli2,xlo2,xx2p,ier)
	    endif
* -#]	    handle dilogs:
* -#[	    handle transformation terms xx1:
*
*	    transformation of c1
*
	    if ( iclas1 .eq. 1 ) then
		crr(1) = xli1
	    elseif( iclas1 .eq. 2 ) then
		crr(1) = -xli1
		ipi12 = ipi12 + 2
		clog1p = zxfflg(xx1p,ieps,y,ier)
		crr(3) = - DBLE(xlo1)*clog1p
	    elseif ( iclas1 .eq. 3 ) then
		crr(1) = -xli1
		ipi12 = ipi12 - 2
		clog1p = zxfflg(-xx1p,-ieps,y,ier)
		crr(3) = - clog1p**2/2
	    elseif ( iclas1 .eq. 4 ) then
		crr(1) = xli1
*		Note that this sum does not cause problems as d2<<1
		crr(3) = DBLE(-xli3-xli4) + DBLE(xlo4)*
     +			zxfflg(fact,0,x0,ier)
		ipi12 = ipi12 - 1
		if ( lwrite ) then
		    print *,'Check iclas1 = 4'
		    print '(a,2g14.8)','Nu:   ',crr(1)+crr(3)
		    call ffxli2(xlia,xtroep,xx1p,ier)
		    print '(a,2g14.8)','Eerst:',xlia+pi12,x0
		endif
	    elseif ( iclas1 .eq. 5 ) then
		crr(1) = xli1
*		supply an imaginary part
		clog1p = zxfflg(-1/xx1,-ieps,y,ier)
		xtroep = -DIMAG(clog1p)*DBLE(clog1p)
		crr(3) = DCMPLX(x0,xtroep)
	    else
		call fferr(26,ier)
	    endif
* -#]	    handle transformation terms xx1:
* -#[	    handle transformation terms xx2:
*
*	    transformation of c2
*
	    if ( iclas2 .eq. 1 ) then
		crr(2) = -xli2
	    elseif( iclas2 .eq. 2 ) then
		crr(2) = +xli2
		ipi12 = ipi12 - 2
		clog2p = zxfflg(xx2p,ieps,-y1,ier)
		crr(4) = + DBLE(xlo2)*clog2p
	    elseif ( iclas2 .eq. 3 ) then
		crr(2) = +xli2
		ipi12 = ipi12 + 2
		clog2p = zxfflg(-xx2p,-ieps,-y1,ier)
		crr(4) = clog2p**2/2
	    elseif ( iclas2 .eq. 4 ) then
		crr(2) = -xli2
*		Note that this sum does not cause problems as d2<<1
		crr(4) = DBLE(xli3+xli4) - DBLE(xlo4)*
     +			zxfflg(fact,0,x0,ier)
		ipi12 = ipi12 + 1
		if ( lwrite ) then
		    print *,'Check iclas2 = 4'
		    print '(a,2g14.8)','Nu:   ',-DBLE(xli2)+crr(4)
		    call ffxli2(xlia,xtroep,xx2p,ier)
		    print '(a,2g14.8)','Eerst:',-xlia-pi12,x0
		endif
	    elseif ( iclas2 .eq. 5 ) then
		crr(2) = -xli2
*		supply an imaginary part
		clog2p = zxfflg(-1/xx2,-ieps,-y1,ier)
		xtroep = DIMAG(clog2p)*DBLE(clog2p)
		crr(4) = DCMPLX(x0,xtroep)
	    else
		call fferr(28,ier)
	    endif
* -#]	    handle transformation terms xx2:
* -#[	    sum and print:
	    if ( lwrite ) then
		cr = crr(1) + crr(2) + crr(3) + crr(4) + crr(5) + crr(6)
		print *,'ffcxr: Normal case'
		print *,'	oorspronkelijk:',xx1
		print *,'	iclas1 = ',iclas1
		if(iclas1.ne.1)print *,'                   nu:',xx1p
		print *,'	Li21 :',crr(1)
		if(iclas1.ne.1)print *,'       tran1:',crr(3)
		if(crr(5).ne.0)print *,'             :',crr(5)
		if(crr(6).ne.0)print *,'             :',crr(6)
		print *,'	oorspronkelijk:',xx2
		print *,'	iclas2 = ',iclas2
		if(iclas2.ne.1)print *,'                   nu:',xx2p
		print *,'	Li22 :',-crr(2)
		if(iclas2.ne.1)print *,'        tran2:',-crr(4)
		if(crr(5).ne.0)print *,'             :',-crr(5)
		if(crr(6).ne.0)print *,'             :',-crr(6)
		print '(a,2g24.15,2i6)','    cr is dus:',cr,ipi12,ier
		if(ipi12.ne.0)print '(a,2g24.15)','             =',
     +			cr+ipi12*DBLE(pi12)
	    endif
* -#]	    sum and print:
	endif
*  #] calculations:
*  #[ debug:
	if ( lwrite ) then
	    if ( abs(ieps) .eq. 1 ) then
		if ( y .lt. 0 ) then
		    ieps1 = ieps
		else
		    ieps1 = -ieps
		endif
		if ( y1 .lt. 0 ) then
		    ieps2 = -ieps
		else
		    ieps2 = ieps
		endif
	    else
		ieps1 = ieps
		ieps2 = ieps
	    endif
	    ierdum = 0
	    call ffzxdl(cli1,ipi121,ctroep,xx1,ieps1,ierdum)
	    call ffzxdl(cli2,ipi122,ctroep,xx2,ieps2,ierdum)
	    cr1 = cli1 - cli2 + (ipi121-ipi122)*DBLE(pi12)
	    print '(a,2g24.15,i6)','    verg. cr1:',cr1,ierdum
	endif
*  #] debug:
*###] ffcxr:
	end
*###[ ffcxs3:
	subroutine ffcxs3(cs3,ipi12,y,z,dyz,d2yzz,dy2z,xpi,piDpj,ii,ns,
     +					isoort,ier)
***#[*comment:***********************************************************
*									*
*	calculates the s3 as defined in appendix b.			*
*		(ip = ii+3, is1 = ii, is2 = ii+1)			*
*									*
*		  log( xk*y^2 + (-xk+xm1-xm2)*y + xm2 - i*eps ) 	*
*	     /1 				  - log( ... ) |y=yi	*
*	s3 = \ dy --------------------------------------------------	*
*	     /0 			y - yi				*
*									*
*	    = r(yi,y-,+) + r(yi,y+,-)					*
*									*
*	with y+- the roots of the argument of the logarithm.		*
*	the sign of the argument to the logarithms in r is passed	*
*	in ieps 							*
*									*
*	input:	y(4),z(4)	(real)	roots in form (z-,z+,1-z-,1-z+)	*
*		dyz(2,2),d2yzz,	(real)	y() - z(), y+ - z- - z+		*
*		dy2z(4)		(real)	y() - 2z()			*
*		xpi	(real(ns))	p(i).p(i) (B&D metric)	i=1,3	*
*					m(i)^2 = si.si		i=4,6	*
*		ii	(integer)	xk = xpi(ii+3) etc		*
*		ns	(integer)	size of arrays			*
*		isoort	(integer)	returns kind of action taken	*
*		cs3	(complex)(20)	assumed zero.			*
*		ccy	(complex)(3)	if i0 != 0: complex y		*
*									*
*	output: cs3	(complex)	mod factors pi^2/12, in array	*
*		ipi12	(integer)	these factors			*
*		ier	(integer)	0=ok 1=inaccurate 2=error	*
*									*
*	calls:	ffcrr,ffcxr,real/dble,DCMPLX,log,ffadd1,ffadd2,ffadd3	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(2),ii,ns,isoort(2),ier
	DOUBLE COMPLEX cs3(20)
	DOUBLE PRECISION y(4),z(4),dyz(2,2),d2yzz,dy2z(4),
     +		xpi(ns),piDpj(ns,ns)
*
*	local variables:
*
	integer i,ip,ieps(2),ipi12p(2),ier0,i2,i3
	DOUBLE COMPLEX c,csum,cs3p(14)
	DOUBLE PRECISION yy,yy1,zz,zz1,dyyzz,xdilog,xlog,x00(3)
	DOUBLE PRECISION absc,xmax
	logical ld2yzz
*
*	common blocks
*
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*  #] declarations:
*  #[ get counters:
	if ( ltest .and. ns .ne. 6 )
     +	    print *,'ffcxs3: error: only for ns=6, not ',ns
	ip = ii+3
	if ( isoort(2) .ne. 0 ) then
	    if ( (z(2).gt.z(1) .or.  z(1).eq.z(2) .and. z(4).lt.z(3) )
     +			.eqv. xpi(ip) .gt. 0 ) then
		ieps(1) = +1
		ieps(2) = -1
	    else
		ieps(1) = -1
		ieps(2) = +1
	    endif
	else
	    if ( piDpj(ip,ii) .gt. 0 ) then
		ieps(1) = +1
	    else
		ieps(1) = -1
	    endif
	endif
	i2 = mod(ii,3) + 1
	i3 = mod(i2,3) + 1
*  #] get counters:
*  #[ special case |z| >> |y|:
	if ( xpi(ip).lt.0 .and. max(abs(y(2)),abs(y(4))) .lt. 
     +		xloss*min(abs(z(1)), abs(z(2)))/2 ) then
*
*	    we will obtain cancellations of the type Li_2(x) + Li_2(-x)
*	    with x small.
*
	    if ( lwrite ) then
		print *,'ffcxs3: special case |z| >> |y|'
		print *,'  y,y1  = ',y(2),y(4)
		print *,'  z,z1- = ',z(1),z(3)
		print *,'  z,z1+ = ',z(2),z(4)
	    endif
	    yy = dyz(2,1)/d2yzz
	    yy1 = dyz(2,2)/d2yzz
	    if ( y(2) .eq. 0 ) goto 10
	    zz = z(2)*yy/y(2)
	    zz1 = 1-zz
	    if ( lwarn .and. abs(zz) .lt. xloss )
     +		call ffwarn(44,ier,abs(zz),x1)
	    dyyzz = dyz(2,2)*yy/y(2)
	    call ffcxr(cs3(1),ipi12(1),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,0,ier)
   10	    continue
	    if ( y(4) .eq. 0 ) goto 30
	    zz = yy*z(4)/y(4)
	    zz1 = 1-zz
	    if ( lwarn .and. abs(zz) .lt. xloss )
     +		call ffwarn(44,ier,abs(zz),x1)
	    dyyzz = -yy*dyz(2,2)/y(4)
	    call ffcxr(cs3(8),ipi12(2),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,0,ier)
	    do 20 i=8,14
   20		cs3(i) = -cs3(i)
   30	    continue
*	    And now the remaining Li_2(x^2) terms
	    call ffxli2(xdilog,xlog,(y(2)/dyz(2,1))**2,ier)
	    cs3(15) = +xdilog/2
	    call ffxli2(xdilog,xlog,(y(4)/dyz(2,1))**2,ier)
	    cs3(16) = -xdilog/2
	    if ( lwrite ) then
		lwrite = .FALSE.
		ipi12p(1) = 0
		ipi12p(2) = 0
		ier0 = 0
		do 40 i=1,14
   40		    cs3p(i) = 0
		call ffcxr(cs3p(1),ipi12p(1),y(2),y(4),z(1),z(3),
     +		    dyz(2,1),.FALSE.,x0,x0,x0,.FALSE.,x00,ieps(1),ier0)
		call ffcxr(cs3p(8),ipi12p(2),y(2),y(4),z(2),z(4),
     +		    dyz(2,2),.FALSE.,x0,x0,x0,.FALSE.,x00,ieps(2),ier0)
		csum = 0
		xmax = 0
		do 50 i=1,14
		    csum = csum + cs3p(i)
		    xmax = max(xmax,absc(csum))
   50		continue
		csum = csum + (ipi12p(1)+ipi12(2))*DBLE(pi12)
		print '(a,3g20.10,3i3)','cmp',csum,xmax,ipi12p,ier0
		lwrite = .TRUE.
	    endif
	    goto 900
	endif
*  #] special case |z| >> |y|:
*  #[ normal:
	if ( xpi(ip) .eq. 0 ) then
	    ld2yzz = .FALSE.
	else
	    ld2yzz = .TRUE.
	endif
	if ( lwrite ) print *,  'ieps = ',ieps
	if ( isoort(1) .ne. 0 ) call ffcxr(cs3(1),ipi12(1),y(2),y(4),
     +	    z(1),z(3),dyz(2,1),ld2yzz,d2yzz,z(2),z(4),.TRUE.,dy2z(1),
     +	    ieps(1),ier)
	if ( isoort(2) .ne. 0 ) then
	    if ( mod(isoort(2),10) .eq. 2 ) then
*		both roots are equal: multiply by 2
		if ( lwrite ) print *,'ffcxs3: skipped next R as it ',
     +			'is the conjugate'
		do 60 i=1,7
		    cs3(i) = 2*DBLE(cs3(i))
   60		continue
		ipi12(1) = 2*ipi12(1)
	    else
		call ffcxr(cs3(8),ipi12(2),y(2),y(4),z(2),z(4),dyz(2,2),
     +		    ld2yzz,d2yzz,z(1),z(3),.TRUE.,dy2z(2),ieps(2),ier)
	    endif
	endif
*
*  #] normal:
*  #[ print output:
  900	if (lwrite) then
	    print *,'  cs3 ='
	    print '(i3,2g20.10,1x)',(i,cs3(i),i=1,20)
	    print '(a3,2g20.10,1x)','pi ',(ipi12(1)+ipi12(2))*pi12
	    print *,'+-----------'
	    csum = 0
	    do 910 i=1,20
  910	    csum = csum + cs3(i)
	    csum = csum+(ipi12(1)+ipi12(2))*DBLE(pi12)
	    print '(a,2g20.10)','Si ',csum
	    print *,'  ipi12,ier=',ipi12,ier
	    print *,' '
	endif
*  #] print output:
*###] ffcxs3:
	end
*###[ ffcs3:
	subroutine ffcs3(cs3,ipi12,cy,cz,cdyz,cd2yzz,cpi,cpiDpj,ii,ns,
     +		isoort,ier)
***#[*comment:***********************************************************
*									*
*	calculates the s3 as defined in appendix b.			*
*									*
*		  log( cpi(ii+3)*y^2 + (cpi(ii+3)+cpi(ii)-cpi(ii+1))*y	*
*	     /1 		     +	cpi(ii+1))  - log( ... ) |y=cyi	*
*	s3 = \ dy ----------------------------------------------------	*
*	     /0 			y - cyi				*
*									*
*	   = r(cyi,cy+) + r(cyi,cy-) +  ( eta(-cy-,-cy+) -		*
*		eta(1-cy-,1-cy+) - eta(...) )*log(1-1/cyi)		*
*									*
*	with y+- the roots of the argument of the logarithm.		*
*									*
*	input:	cy(4)	 (complex)  cy(1)=y^-,cy(2)=y^+,cy(i+2)=1-cy(1)	*
*		cz(4)	 (complex)  cz(1)=z^-,cz(2)=z^+,cz(i+2)=1-cz(1)	*
*		cpi(6)   (complex)  masses & momenta (B&D)		*
*		ii	 (integer)  position of cp,cma,cmb in cpi	*
*		ns	 (integer)  size of arrays			*
*		isoort(2)(integer)  returns the kind of action taken	*
*		cs3	 (complex)(14)	assumed zero.			*
*									*
*	output: cs3	 (complex)  mod factors ipi12			*
*		ipi12(2) (integer)  these factors			*
*		ier	 (integer)  0=ok, 1=numerical problems, 2=error	*
*									*
*	calls:	ffcrr,DIMAG,DBLE,zfflog					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(2),ii,ns,isoort(2),ier
	DOUBLE COMPLEX cs3(20),cpi(ns),cpiDpj(ns,ns)
	DOUBLE COMPLEX cy(4),cz(4),cdyz(2,2),cd2yzz
*
*	local variables:
*
	integer i,ip,ieps(2),ieps0,ni(4),ipi12p(2),ier0,ntot,i2,i3
	logical ld2yzz
	DOUBLE COMPLEX c,csum,zdilog,zlog,cyy,cyy1,czz,czz1,cdyyzz
     +		,cs3p(14)
	DOUBLE PRECISION absc,xmax,y,y1,z,z1,dyz,d2yzz,zz,zz1,
     +		x00(3),sprec
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ get ieps:
	if ( ltest ) then
	    if ( ns .ne. 6 ) then
		print *,'ffcs3: error: only for ns=6, not ',ns
		stop
	    endif
	endif
	ip = ii+3
	call ffieps(ieps,cz(1),cpi(ip),cpiDpj(ip,ii),isoort)
	i2 = mod(ii,3) + 1
	i3 = mod(i2,3) + 1
*  #] get ieps:
*  #[ special case |cz| >> |cy|:
	if ( isoort(2) .ne. 0 .and. max(absc(cy(2)),absc(cy(4))) .lt. 
     +		xloss*min(absc(cz(1)),absc(cz(2)))/2 ) then
*
*	    we will obtain cancellations of the type Li_2(x) + Li_2(-x)
*	    with x small.
*
	    if ( lwrite ) print *,'Special case |cz| >> |cy|'
	    cyy = cdyz(2,1)/cd2yzz
	    cyy1 = cdyz(2,2)/cd2yzz
	    if ( absc(cy(2)) .lt. xclogm ) then
		if ( DIMAG(cy(2)) .eq. 0 .and. abs(DBLE(cy(2))) .gt.
     +			xalogm ) then
		    czz = cz(2)*cyy*DCMPLX(1/DBLE(cy(2)))
		    cdyyzz = cyy*cdyz(2,2)*DCMPLX(1/DBLE(cy(2)))
		elseif ( cy(2) .eq. 0 .and. cz(2) .ne. 0 .and. cyy
     +			.ne. 0 ) then
*		    the answer IS zero
		    goto 30
		else
*		    the answer is rounded off to zero
		    if (lwarn) call ffwarn(42,ier,absc(cy(2)),xclogm)
		endif
	    else
		czz = cz(2)*cyy/cy(2)
		cdyyzz = cyy*cdyz(2,2)/cy(2)
	    endif
	    czz1 = 1-czz
	    if ( lwarn .and. absc(czz) .lt. xloss )
     +		call ffwarn(43,ier,absc(czz),x1)
	    if ( isoort(1) .eq. -10 ) then
*		no eta terms.
		ieps0 = 99
	    else
*		do not know the im part
		ieps0 = 0
	    endif
	    call ffcrr(cs3(1),ipi12(1),cyy,cyy1,czz,czz1,cdyyzz,.FALSE.,
     +		c0,c0,c0,-1,ieps0,ier)
   30	    continue
	    if ( absc(cy(4)) .lt. xclogm ) then
		if ( DIMAG(cy(4)) .eq. 0 .and. abs(DBLE(cy(4))) .gt.
     +			xalogm ) then
		    czz = cz(4)*cyy*DCMPLX(1/DBLE(cy(4)))
		    cdyyzz = -cyy*cdyz(2,2)*DCMPLX(1/DBLE(cy(4)))
		elseif ( cy(4) .eq. 0 .and. cz(4) .ne. 0 .and. cyy
     +			.ne. 0 ) then
*		    the answer IS zero
		    goto 50
		else
*		    the answer is rounded off to zero
		    if (lwarn) call ffwarn(42,ier,absc(cy(4)),xclogm)
		endif
	    else
		czz = cz(4)*cyy/cy(4)
		cdyyzz = -cyy*cdyz(2,2)/cy(4)
	    endif
	    czz1 = 1-czz
	    if ( lwarn .and. absc(czz) .lt. xloss )
     +		call ffwarn(43,ier,absc(czz),x1)
	    call ffcrr(cs3(8),ipi12(2),cyy,cyy1,czz,czz1,cdyyzz,.FALSE.,
     +		c0,c0,c0,-1,ieps0,ier)
	    do 40 i=8,14
		cs3(i) = -cs3(i)
   40	    continue
   50	    continue
*
*	    And now the remaining Li_2(x^2) terms
*	    stupid Gould NP1
*
	    c = cy(2)*cy(2)/(cdyz(2,1)*cdyz(2,1))
	    call ffzli2(zdilog,zlog,c,.FALSE.,ier)
	    cs3(15) = +zdilog/2
*	    stupid Gould NP1
	    c = cy(4)*cy(4)/(cdyz(2,1)*cdyz(2,1))
	    call ffzli2(zdilog,zlog,c,.FALSE.,ier)
	    cs3(16) = -zdilog/2
	    if ( lwrite ) then
		lwrite = .FALSE.
		ipi12p(1) = 0
		ipi12p(2) = 0
		ier0 = 0
		do 60 i=1,14
		    cs3p(i) = 0
   60		continue
		call ffcrr(cs3p(1),ipi12p(1),cy(2),cy(4),cz(1),
     +			cz(3),cdyz(2,1),.TRUE.,cd2yzz,cz(2),
     +			cz(4),isoort(1),ieps(1),ier0)
		call ffcrr(cs3p(8),ipi12p(2),cy(2),cy(4),cz(2),
     +			cz(4),cdyz(2,2),.TRUE.,cd2yzz,cz(1),
     +			cz(3),isoort(2),ieps(2),ier0)
		csum = 0
		xmax = 0
		do 70 i=1,14
		    csum = csum + cs3p(i)
		    xmax = max(xmax,absc(csum))
   70		continue
		csum = csum + (ipi12p(1)+ipi12(2))*DBLE(pi12)
		print '(a,3g20.10,3i3)','cmp',csum,xmax,ipi12p,ier0
		lwrite = .TRUE.
	    endif
	    goto 900
	endif
*  #] special case |cz| >> |cy|:
*  #[ normal:
	if ( isoort(2) .eq. 0 ) then
	    ld2yzz = .FALSE.
	else
	    ld2yzz = .TRUE.
	endif
	if ( isoort(1) .eq. 0 ) then
*	    do nothing
	elseif ( mod(isoort(1),10).eq.0 .or. mod(isoort(1),10).eq.-1 
     +		.or. mod(isoort(1),10).eq.-3 ) then
	    call ffcrr(cs3(1),ipi12(1),cy(2),cy(4),cz(1),cz(3),
     +		cdyz(2,1),ld2yzz,cd2yzz,cz(2),cz(4),isoort(1),
     +		ieps(1),ier)
	elseif ( mod(isoort(1),10) .eq. -5 .or. mod(isoort(1),10) .eq.
     +		-6 ) then
	    y = DBLE(cy(2))
	    y1 = DBLE(cy(4))
	    z = DBLE(cz(1))
	    z1 = DBLE(cz(3))
	    dyz = DBLE(cdyz(2,1))
	    d2yzz = DBLE(cd2yzz)
	    zz = DBLE(cz(2))
	    zz1 = DBLE(cz(4))
	    sprec = precx
	    precx = precc
	    call ffcxr(cs3(1),ipi12(1),y,y1,z,z1,dyz,ld2yzz,d2yzz,zz,zz1
     +				,.FALSE.,x00,ieps(1),ier)
	    precx = sprec
	else
	    call fferr(12,ier)
	endif
	if ( isoort(2) .eq. 0 ) then
*	    do nothing
	elseif ( mod(isoort(2),5) .eq. 0 ) then
	    if ( lwrite ) print *,'ffcs3: skipped next R as it is the ',
     +		'conjugate'
	    do 100 i=1,7
  100		cs3(i) = 2*DBLE(cs3(i))
	    ipi12(1) = 2*ipi12(1)
	elseif ( mod(isoort(2),10).eq.-1 .or. mod(isoort(1),10).eq.-3 )
     +		then
	    call ffcrr(cs3(8),ipi12(2),cy(2),cy(4),cz(2),cz(4),
     +		cdyz(2,2),ld2yzz,cd2yzz,cz(1),cz(3),isoort(2),
     +		ieps(2),ier)
	elseif ( mod(isoort(2),10) .eq. -6 ) then
	    y = DBLE(cy(2))
	    y1 = DBLE(cy(4))
	    z = DBLE(cz(2))
	    z1 = DBLE(cz(4))
	    dyz = DBLE(cdyz(2,2))
	    d2yzz = DBLE(cd2yzz)
	    zz = DBLE(cz(1))
	    zz1 = DBLE(cz(3))
	    sprec = precx
	    precx = precc
	    call ffcxr(cs3(8),ipi12(2),y,y1,z,z1,dyz,ld2yzz,d2yzz,zz,zz1
     +				,.FALSE.,x00,ieps(2),ier)
	    precx = sprec
	else
	    call fferr(13,ier)
	endif
*  #] normal:
*  #[ eta's:
	if ( DIMAG(cpi(ip)) .eq. 0 ) then
	    call ffgeta(ni,cz(1),cdyz(1,1),cd2yzz,
     +		cpi(ip),cpiDpj(ii,ip),ieps,isoort,ier)
	    if ( lwrite ) print *,'ffcs3: eta''s are ',ni
	    ntot = ni(1) + ni(2) + ni(3) + ni(4)
	    if ( ntot .ne. 0 ) call ffclgy(cs3(15),ipi12(2),ntot,
     +		cy(1),cz(1),cd2yzz,ier)
	else
*
*	    cpi(ip) is really complex (occurs in transformed
*	    4pointfunction)
*
	    print *,'THIS PART IS NOT READY ',
     +			'and should not be reached'
	    stop
	endif
*  #] eta's:
*  #[ print output:
  900	if (lwrite) then
	    print *,'  cs3 ='
	    print '(i3,2g20.10,1x)',(i,cs3(i),i=1,20)
	    print '(a3,2g20.10,1x)','pi ',(ipi12(1)+ipi12(2))*pi12
	    print *,'+-----------'
	    csum = 0
	    do 910 i=1,20
  910	    csum = csum + cs3(i)
	    csum = csum+(ipi12(1)+ipi12(2))*DBLE(pi12)
	    print '(a,2g20.10)','Si ',csum
	    print *,'  ipi12,ier=',ipi12,ier
	endif
*  #] print output:
*###] ffcs3:
	end
*###[ ffclgy:
	subroutine ffclgy(cs3,ipi12,ntot,cy,cz,cd2yzz,ier)
***#[*comment:***********************************************************
*									*
*	calculates the the difference of two S's with cy(3,4),cz(3,4),	*
*	cy(4)cz(3)-cy(3)cz(4) given.  Note the difference with ffdcs4,	*
*	in which the cy's are the same and only the cz's different.	*
*	Here both can be different.	Also we skip an intermediat	*
*	level.								*
*									*
*	input:	cy(4)	     (complex)	cy,1-cy in S with s3,s4		*
*		cz(4)	     (complex)	cz,1-cz in S with s3,s4		*
*		cdyz(2,2)    (complex)	cy - cz				*
*		cd2yzz	     (complex)	2*cy - cz+ - cz-		*
*		cdyzzy(4)    (complex)	cy(i,4)*cz(i,4)-cy(i,3)*cz(i,4)	*
*		cpiDpj(6,6)  (complex)	usual				*
*		cs3	     (complex)	assumed zero.			*
*									*
*	output: cs3	     (complex)	mod factors pi^2/12, in array	*
*		ipi12	     (integer)	these factors			*
*		isoort	     (integer)	returns kind of action taken	*
*		ier	     (integer)	number of digits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cs3
	DOUBLE COMPLEX cy(4),cz(4),cd2yzz
	integer ipi12,ntot,ier
*
*	local variables
*
	integer ipi
	DOUBLE COMPLEX c,cc,clogy,c2y1,zfflog,zfflo1,csum
	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ calculations:
	ipi = 0
	if ( 1 .lt. xloss*absc(cy(2)) ) then
	    clogy = zfflo1(1/cy(2),ier)
	else
	    if ( absc(cy(2)) .lt. xclogm .or. absc(cy(4)) .lt. xclogm )
     +			then
		if ( ntot .ne. 0 ) call fferr(15,ier)
		clogy = 0
	    else
		c = -cy(4)/cy(2)
		if ( DBLE(c) .gt. -abs(DIMAG(c)) ) then
		    clogy = zfflog(c,0,c0,ier)
		else
*		    take out the factor 2*pi^2
		    cc = c+1
		    if ( absc(cc) .lt. xloss ) then
			c2y1 = -cd2yzz - cz(1) + cz(4)
			if ( absc(c2y1) .lt. xloss*max(absc(cz(1)),
     +				absc(cz(4))) ) then
			    c2y1 = -cd2yzz - cz(2) + cz(3)
			    if ( lwarn .and. absc(c2y1) .lt. xloss*max(
     +				absc(cz(2)),absc(cz(3))) ) call ffwarn(
     +				56,ier,absc(c2y1),absc(cy(2)))
			endif
			csum = -c2y1/cy(2)
			clogy = zfflo1(csum,ier)
			if ( lwrite ) then
			    print *,'c  = ',c
			    print *,'c+ = ',-1+csum
			endif
		    else
			csum = 0
			clogy = zfflog(-c,0,c0,ier)
		    endif
		    if ( DIMAG(c) .lt. -precc*absc(c) .or.
     +			 DIMAG(csum) .lt. -precc*absc(csum) ) then
			ipi = -1
		    elseif ( DIMAG(c) .gt. precc*absc(c) .or.
     +			     DIMAG(csum) .gt. precc*absc(csum) ) then
			ipi = +1
		    else
			call fferr(51,ier)
			ipi = 0
		    endif
		endif
	    endif
	endif
	if ( ltest .and. cs3 .ne. 0 ) then
	    print *,'ffclgy: error: cs3 al bezet! ',cs3
	endif
	cs3 = cs3 + ntot*c2ipi*clogy
	if ( ipi .ne. 0 ) then
	    ipi12 = ipi12 - 24*ntot*ipi
	endif
*  #] calculations:
*###] ffclgy:
	end
*###[ ffieps:
	subroutine ffieps(ieps,cz,cp,cpDs,isoort)
***#[*comment:***********************************************************
*									*
*	Get the ieps prescription in such a way that it is compatible	*
*	with the imaginary part of cz if non-zero, compatible with the	*
*	real case if zero.						*
*									*
*	Input:	cz	complex(4)	the roots z-,z+,1-z-,1-z+	*
*		cp	complex		p^2				*
*		cpDs	complex		p.s				*
*		isoort	integer(2)	which type of Ri		*
*									*
*	Output:	ieps	integer(2)	z -> z-ieps*i*epsilon		*
*					will give correct im part	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ieps(2),isoort(2)
	DOUBLE COMPLEX cp,cpDs,cz(4)
*
*  #] declarations:
*  #[ work:
	if ( DIMAG(cp) .ne. 0 ) then
*	    do not calculate ANY eta terms, we'll do them ourselves.
	    ieps(1) = 99
	    ieps(2) = 99
	elseif ( isoort(2) .ne. 0 ) then
	    if ( DIMAG(cz(1)) .lt. 0 ) then
		ieps(1) = +1
		if ( DIMAG(cz(2)) .lt. 0 ) then
		    ieps(2) = +1
		else
		    ieps(2) = -1
		endif
	    elseif ( DIMAG(cz(1)) .gt. 0 ) then
		ieps(1) = -1
		if ( DIMAG(cz(2)) .le. 0 ) then
		    ieps(2) = +1
		else
		    ieps(2) = -1
		endif
	    else
		if ( DIMAG(cz(2)) .lt. 0 ) then
		    ieps(1) = -1
		    ieps(2) = +1
		elseif ( DIMAG(cz(2)) .gt. 0 ) then
		    ieps(1) = +1
		    ieps(2) = -1
		else
		    if ( (DBLE(cz(2)).gt.DBLE(cz(1))
     +			.or.  (DBLE(cz(1)).eq.DBLE(cz(2))
     +				.and. DBLE(cz(4)).lt.DBLE(cz(3)))
     +			) .eqv. DBLE(cp).gt.0 ) then
			ieps(1) = +1
			ieps(2) = -1
		    else
			ieps(1) = -1
			ieps(2) = +1
		    endif
		endif
	    endif
	else
	    if ( DIMAG(cz(1)) .lt. 0 ) then
		ieps(1) = +1
	    elseif ( DIMAG(cz(1)) .gt. 0 ) then
		ieps(1) = -1
	    elseif ( DBLE(cpDs) .gt. 0 ) then
		ieps(1) = +1
	    else
		ieps(1) = -1
	    endif
	    ieps(2) = -9999
	endif
*  #] work:
*###] ffieps:
	end
*###[ ffgeta:
	subroutine ffgeta(ni,cz,cdyz,cd2yzz,cp,cpDs,ieps,isoort,ier)
***#[*comment:***********************************************************
*									*
*	Get the eta terms which arise from splitting up			*
*	log(p2(x-z-)(x-z+)) - log(p2(y-z-)(y-z+))			*
*									*
*	Input:	cz	complex(4)	the roots z-,z+,1-z-,1-z+	*
*		cdyz	complex(2,2)	y-z				*
*		cd2yzz	complex(2)	2y-(z-)-(z+)			*
*		cp	complex		p^2				*
*		cpDs	complex		p.s				*
*		ieps	integer(2)	the assumed im part if Im(z)=0	*
*		isoort	integer(2)	which type of Ri		*
*									*
*	Output:	ni	integer(4)	eta()/(2*pi*i)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ni(4),ieps(2),isoort(2),ier
	DOUBLE COMPLEX cp,cpDs,cz(4),cdyz(2,2),cd2yzz
*
*	local variables
*
	integer i,nffeta,nffet1
	DOUBLE COMPLEX cmip
*
*	common
*
	include 'ff.h'
*
*  #] declarations:
*  #[ complex  masses or imaginary roots:
*
*	only complex because of complex roots in y or z
*	[checked and in agreement with ieps definition 23-sep-1991]
*
	if ( lwrite ) print *,'ffgeta: isoort = ',isoort
*
*	isoort = +1:        y is real, z is real
*	isoort = -1-n*10:   y is complex, possibly z as well
*	isoort = -3-n*10:   y,z complex, (y-z-)*(y-z+) real
*	isoort = 0:         y is complex, one z root only
*	isoort = -10-n*10:  y is real, z is complex
*	isoort = -5,6-n*10: y,z real
*
	if ( isoort(1) .gt. 0 ) then
*
*	    really a real case
*
	    ni(1) = 0
	    ni(2) = 0
	    ni(3) = 0
	    ni(4) = 0
	elseif ( mod(isoort(1),10) .ne. 0 .and. isoort(2) .ne. 0 ) then
	    cmip = DCMPLX(DBLE(x0),-DBLE(cp))
*
*	    ni(1) = eta(p2,(x-z-)(x-z+)) = 0 by definition (see ni(3))
*	    ni(2) = eta(x-z-,x-z+)
*
	    ni(1) = 0
	    if ( ieps(1) .gt. 0 .neqv. ieps(2) .gt. 0 ) then
		ni(2) = 0
	    else
		ni(2) = nffet1(-cz(1),-cz(2),cmip,ier)
		if ( cz(3).ne.0 .and. cz(4).ne.0 ) then
		    i = nffet1(cz(3),cz(4),cmip,ier)
		    if ( i .ne. ni(2) ) call fferr(53,ier)
		endif
	    endif
*
*	    ni(3) compensates for whatever convention we chose in ni(1)
*	    ni(4) = -eta(y-z-,y-z+)
*
***	    if ( DBLE(cd2yzz).eq.0 .and. ( DIMAG(cz(1)).eq.0 .and.
***     +		 DIMAG(cz(2)).eq.0 .or. DBLE(cdyz(2,1)).eq.0 .and.
***     +		 DBLE(cdyz(2,2)) .eq. 0 ) ) then
	    if ( mod(isoort(1),10).eq.-3 ) then
*		follow the i*epsilon prescription as (y-z-)(y-z+) real
		ni(3) = 0
		if ( ltest ) then
		    if ( DIMAG(cdyz(2,1)).eq.0 .or. DIMAG(cdyz(2,2))
     +		    .eq.0 ) print *,'ffgeta: error: calling nffet1',
     +		    ' with im(y-z-)=im(y-z+)=0: ',cdyz(2,1),cdyz(2,2)
		endif
		ni(4) = -nffet1(cdyz(2,1),cdyz(2,2),cmip,ier)
	    else
		if ( DBLE(cp) .lt. 0 .and. DIMAG(cdyz(2,1)*
     +			cdyz(2,2)) .lt. 0 ) then
		    ni(3) = -1
		else
		    ni(3) = 0
		endif
		ni(4) = -nffeta(cdyz(2,1),cdyz(2,2),ier)
	    endif
	elseif ( (mod(isoort(1),10).eq.-1 .or. mod(isoort(1),10).eq.-3) 
     +		.and. isoort(2) .eq. 0 ) then
	    ni(1) = 0
	    if ( DIMAG(cz(1)) .ne. 0 ) then
		ni(2) = nffet1(-cpDs,-cz(1),DCMPLX(DBLE(0),
     +			DBLE(-1)),ier)
	    else
		ni(2) = nffet1(-cpDs,DCMPLX(DBLE(0),DBLE(1)),
     +			DCMPLX(DBLE(0),DBLE(-1)),ier)
	    endif
	    ni(3) = 0
	    ni(4) = -nffeta(-cpDs,cdyz(2,1),ier)
	else
	    ni(1) = 0
	    ni(2) = 0
	    ni(3) = 0
	    ni(4) = 0
	endif
*  #] complex  masses or imaginary roots:
*###] ffgeta:
	end
*###[ ffcxs4:
	subroutine ffcxs4(cs3,ipi12,w,y,z,dwy,dwz,dyz,d2yww,d2yzz,
     +					xpi,piDpj,ii,ns,isoort,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the 8 Spence functions = 4 R's = 2 dR's		*
*									*
*									*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(4),ii,ns,isoort(4),ier
	DOUBLE COMPLEX cs3(40)
	DOUBLE PRECISION w(4),y(4),z(4),dwy(2,2),dwz(2,2),dyz(2,2),
     +		d2yww,d2yzz,xpi(ns),piDpj(ns,ns),x00(3)
*
*	local variables:
*
	integer iepz(2),iepw(2)
	logical ld2yzz,ld2yww
*	DOUBLE COMPLEX c
*	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ groundwork:
	if ( ltest .and. ns .ne. 6 )
     +	    print *,'ffcxs4: error: only for ns=6, not ',ns
	if ( isoort(2) .eq. 0 ) then
	    ld2yzz = .FALSE.
	else
	    ld2yzz = .TRUE.
	endif
	if ( isoort(4) .eq. 0 ) then
	    ld2yww = .FALSE.
	else
	    ld2yww = .TRUE.
	endif
	if ( isoort(2) .ne. 0 ) then
	    if ( z(2) .gt. z(1) .eqv. xpi(ii+3) .gt. 0 ) then
		iepz(1) = +1
		iepz(2) = -1
	    else
		iepz(1) = -1
		iepz(2) = +1
	    endif
	else
	    print *,'ffcxs4: error: untested algorithm'
	    if ( piDpj(ii,ii+3) .gt. 0 ) then
		iepz(1) = +1
	    else
		iepz(1) = -1
	    endif
	endif
	if ( isoort(4) .ne. 0 ) then
	    if ( w(2) .gt. w(1) .eqv. xpi(5) .gt. 0 ) then
		iepw(1) = 1
		iepw(2) = -1
	    else
		iepw(1) = -1
		iepw(2) = 1
	    endif
	else
	    print *,'ffcxs4: error: untested algorithm'
	    if ( piDpj(2,5) .gt. 0 ) then
		iepw(1) = +1
	    else
		iepw(1) = -1
	    endif
	endif
*  #] groundwork:
*  #[ zm and wp:
	if ( isoort(4) .eq. 0 ) then
	    if (lwrite) print *,'ffcxs4: to ffcxr(zm)'
	    call ffcxr(cs3(1),ipi12(1),y(2),y(4),z(1),z(3),dyz(2,1),
     +		ld2yzz,d2yzz,z(2),z(4),.FALSE.,x00,iepz(1),ier)
	else
	    if (lwrite) print *,'ffcxs4: to ffdcxr(zm,wp)'
	    if ( .not. ( dwz(2,1).eq.0 .and. iepz(1).eq.iepw(2) ) )
     +	    	call ffdcxr(cs3( 1),ipi12(1),y(2),y(4),z(1),z(3),
     +			z(2),z(4),d2yzz,w(2),w(4),w(1),w(3),d2yww,
     +			dyz(2,1),dwy(2,2),dwz(2,1),iepz(1),iepw(2),ier)
	endif
*  #] zm and wp:
*  #[ zp and wm:
	if ( isoort(2) .eq. 0 ) then
	    if (lwrite) print *,'ffcxs4: to ffcxr(wm)'
	    call ffcxr(cs3(1),ipi12(1),y(2),y(4),w(1),w(3),-dwy(1,2),
     +		ld2yww,d2yww,w(2),w(4),.FALSE.,x00,iepw(1),ier)
	else
	    if (lwrite) print *,'ffcxs4: to ffdcxr(zp,wm)'
	    if ( .not. ( dwz(1,2).eq.0 .and. iepz(2).eq.iepw(1) ) )
     +	    	call ffdcxr(cs3(21),ipi12(3),y(2),y(4),z(2),z(4),
     +			z(1),z(3),d2yzz,w(1),w(3),w(2),w(4),d2yww,
     +			dyz(2,2),dwy(1,2),dwz(1,2),iepz(2),iepw(1),ier)
	endif
*  #] zp and wm:
*###] ffcxs4:
	end
*###[ ffcs4:
	subroutine ffcs4(cs3,ipi12,cw,cy,cz,cdwy,cdwz,cdyz,cd2yww,cd2yzz
     +			,cpi,cpiDpj,cp2p,cetami,ii,ns,isoort,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the 8 Spence functions = 4 R's = 2 dR's		*
*									*
*									*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(4),ii,ns,isoort(4),ier
	DOUBLE COMPLEX cs3(40)
	DOUBLE COMPLEX cw(4),cy(4),cz(4),cdwy(2,2),cdwz(2,2),cdyz(2,2)
	DOUBLE COMPLEX cd2yww,cd2yzz,cpi(ns),cp2p,cpiDpj(ns,ns),
     +		cetami(6)
*
*	local variables:
*
	logical ld2yzz,ld2yww
	integer i,j,ip,iepz(2),iepw(2),nz(4),nw(4),ntot,i2pi
	DOUBLE COMPLEX c,cc,clogy,c2y1,cdyw(2,2)
	DOUBLE COMPLEX zfflo1,zfflog
	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ get counters:
	if ( ltest .and. ns .ne. 6 ) then
	    print *,'ffcs4: error: only for ns=6, not ',ns
	    stop
	endif
	ip = ii+3
	if ( isoort(2) .eq. 0 ) then
	    ld2yzz = .FALSE.
	else
	    ld2yzz = .TRUE.
	endif
	if ( isoort(4) .eq. 0 ) then
	    ld2yww = .FALSE.
	else
	    ld2yww = .TRUE.
	endif
	call ffieps(iepz,cz,cpi(ip),cpiDpj(ip,ii),isoort)
	call ffieps(iepw,cw,cp2p,cpiDpj(ip,ii),isoort(3))
	if ( isoort(4) .eq. 0 ) then
	    print *,'ffcs4: error: case not implemented'
	    ier = ier + 50
	endif
*  #] get counters:
*  #[ R's:
	if ( isoort(4) .eq. 0 ) then
	    call ffcrr(cs3(1),ipi12(1),cy(2),cy(4),cz(1),cz(3),cdyz(2,1)
     +		,ld2yzz,cd2yzz,cz(2),cz(4),isoort(4),iepz(1),ier)
	else
	    if (lwrite) print *,'ffcs4: to ffdcrr(zm,wp)'
	    if ( .not. ( cdwz(2,1).eq.0 .and. iepz(1).eq.iepw(2) ) )
     +	    call ffdcrr(cs3( 1),ipi12(1),cy(2),cy(4),cz(1),cz(3),cz(2),
     +		cz(4),cd2yzz,cw(2),cw(4),cw(1),cw(3),cd2yww,cdyz(2,1),
     +		cdwy(2,2),cdwz(2,1),isoort(4),iepz(1),iepw(2),ier)
	endif
	if ( isoort(2) .eq. 0 ) then
	    call ffcrr(cs3(1),ipi12(1),cy(2),cy(4),cw(1),cw(3),-cdwy(1,2
     +	    	),ld2yww,cd2yww,cw(2),cw(4),isoort(2),iepw(1),ier)
	else
	    if (lwrite) print *,'ffcs4: to ffdcrr(zp,wm)'
	    if ( .not. ( cdwz(1,2).eq.0 .and. iepz(2).eq.iepw(1) ) )
     +	    call ffdcrr(cs3(21),ipi12(3),cy(2),cy(4),cz(2),cz(4),cz(1),
     +		cz(3),cd2yzz,cw(1),cw(3),cw(2),cw(4),cd2yww,cdyz(2,2),
     +		cdwy(1,2),cdwz(1,2),iepz(2),isoort(2),iepw(1),ier)
	endif
*  #] R's:
*  #[ eta's:
	if ( DIMAG(cpi(ip)) .eq. 0 ) then
	    call ffgeta(nz,cz,cdyz,cd2yzz,
     +		cpi(ip),cpiDpj(ii,ip),iepz,isoort,ier)
	    do 120 i=1,2
		do 110 j=1,2
		    cdyw(i,j) = cdwy(j,i)
  110		continue
  120	    continue
	    call ffgeta(nw,cw,cdyw,cd2yww,
     +		cp2p,cpiDpj(ii,ip),iepw,isoort(3),ier)
	else
	    print *,'ffcs4: error: not ready for complex D0 yet'
	endif
	ntot = nz(1)+nz(2)+nz(3)+nz(4)-nw(1)-nw(2)-nw(3)-nw(4)
	if ( ntot .ne. 0 ) then
	    i2pi = 0
	    if ( 1/absc(cy(2)) .lt. xloss ) then
		clogy = zfflo1(1/cy(2),ier)
	    else
		c = -cy(4)/cy(2)
		if ( DBLE(c) .gt. -abs(DIMAG(c)) ) then
		    clogy = zfflog(c,0,c0,ier)
		else
*		    take out the factor 2*pi^2
		    cc = c+1
		    if ( absc(cc) .lt. xloss ) then
			c2y1 = -cd2yzz - cz(1) + cz(4)
			if ( absc(c2y1) .lt. xloss*max(absc(cz(1)),
     +			     absc(cz(4))) ) then
			    c2y1 = -cd2yzz - cz(2) + cz(3)
			    if ( lwarn .and. absc(c2y1) .lt. xloss*max(
     +				absc(cz(2)),absc(cz(3))) ) then
				call ffwarn(134,ier,absc(c2y1),
     +					absc(cy(2)))
			    endif
			endif
			if ( lwrite ) then
			    print *,'1+c         = ',1+c
			    print *,'-c2y1/cy(2) = ',-c2y1/cy(2)
			endif
			clogy = zfflo1(-c2y1/cy(2),ier)
		    else
			clogy = zfflog(-c,0,c0,ier)
		    endif
		    if ( DIMAG(c) .lt. 0 ) then
			i2pi = -1
		    elseif ( DIMAG(c) .gt. 0 ) then
			i2pi = +1
		    else
			call fferr(51,ier)
			i2pi = 0
		    endif
		    ipi12(2) = ipi12(2) - ntot*24*i2pi
		endif
	    endif
	    if ( cs3(40) .ne. 0 ) print *,'ffcs4: error: cs3(40) != 0'
	    cs3(40) = ntot*c2ipi*clogy
	endif
	if ( lwrite ) then
	    print *,'eta''s:'
	    print *,'nzi  :',nz
	    print *,'nwi  :',nw
	    print *,'total:',ntot*c2ipi*clogy
	    if ( i2pi .ne. 0 ) print *,'     +',-ntot*24*i2pi*pi12
	    print *,'     =',ntot,' *( ',c2ipi*clogy,' + ',24*i2pi*pi12,
     +		')'
	endif
*  #] eta's:
*###] ffcs4:
	end
*###[ ffdcxr:
	subroutine ffdcxr(cs3,ipi12,y,y1,z,z1,zp,zp1,d2yzz,
     +			w,w1,wp,wp1,d2yww,dyz,dwy,dwz,iepsz,iepsw,ier)
***#[*comment:***********************************************************
*									*
*	Calculate							*
*									*
*		R(y,z,iepsz) - R(y,w,iepsw)				*
*									*
*	Input:								*
*		a = [yzw]	(real)		see definition		*
*		a1 = 1 - a	(real)					*
*		dab = a - b	(real)					*
*		ieps[zw]	(integer)	sign of imaginary part	*
*						of argument logarithm	*
*		cs3(20)		(complex)	assumed zero		*
*									*
*	Output:								*
*		cs3(20)		(complex)	the results, not added	*
*		ipi12(2)	(integer)	factors pi^2/12		*
*									*
*	Calls:	ffcxr							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(2),iepsz,iepsw,ier
	DOUBLE COMPLEX cs3(20)
	DOUBLE PRECISION y,z,w,y1,z1,w1,dyz,dwy,dwz,zp,zp1,d2yzz,wp,wp1,
     +		d2yww
*
*	local variables:
*
	integer i,ieps,ipi12p(2),ier1,ier2,isign,inorm
	logical again
	DOUBLE PRECISION yy,yy1,zz,zz1,dyyzz,xx1,xx1n,term,tot,d2,d3,
     +		d21,d31,d2n,d3n,d21n1,d31n1,dw,xlogy,x00(3)
	DOUBLE COMPLEX csum,csum1,csum2,cs3p(20),chulp
	DOUBLE PRECISION dfflo1
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
*	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
	inorm = 0
*  #] declarations:
*  #[ groundwork:
	if ( dwz .eq. 0 .and. iepsz .eq. iepsw ) return
	if ( dyz .eq. 0 ) then
	    call fferr(75,ier)
	    return
	endif
	xx1 = y/dyz
	dw = dwz/dyz
	if ( xx1 .le. x05 .or. xx1 .gt. 2 ) then
	    d2 = 1/y
	    dw = dw*y/w
	else
	    d2 = 1/z1
	endif
	again = .FALSE.
  123	continue
*  #] groundwork:
*  #[ trivial case:
	if ( dw .eq. 0 ) then
	    if ( lwrite ) print *,'  Trivial case'
*  #] trivial case:
*  #[ normal case:
	elseif ( abs(dw) .gt. xloss .or. again ) then
*	    nothing's the matter
	    if ( lwrite ) print *,'  Normal case'
	    inorm = 1
	    call ffcxr(cs3( 1),ipi12(1),y,y1,z,z1,dyz,
     +		.TRUE.,d2yzz,zp,zp1,.FALSE.,x00,iepsz,ier)
	    call ffcxr(cs3(11),ipi12(2),y,y1,w,w1,-dwy,
     +		.TRUE.,d2yww,wp,wp1,.FALSE.,x00,iepsw,ier)
	    do 10 i=11,20
   10		cs3(i) = -cs3(i)
	    ipi12(2) = -ipi12(2)
*  #] normal case:
*  #[ only cancellations in w, not in y:
	elseif ( abs(d2) .gt. xloss ) then
*	    there are no cancellations the other way:
	    if ( lwrite ) print *,'  Cancellations one way, turned Rs'
	    if ( iepsz .ne. iepsw .and. ( y/dyz .gt. 1 .or.-y/dwy .gt.
     +		1 ) ) then
		again = .TRUE.
		if ( lwrite ) then
		    print *,'ffdcxr: problems with ieps, solvable,'
		    print *,'        but for the moment just call the ',
     +		    	'normal case'
		endif
		again = .TRUE.
		goto 123
*		call fferr(21,ier)
	    endif
	    yy = dwy/dwz
	    zz = yy*z/y
	    yy1 = dyz/dwz
	    zz1 = yy1*w/y
	    dyyzz = yy*dyz/y
	    if ( y .lt. 0 ) then
		ieps = iepsz
	    else
		ieps = -iepsz
	    endif
	    call ffcxr(cs3( 1),ipi12(1),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,2*ieps,ier)
	    zz = yy*z1/y1
	    zz1 = yy1*w1/y1
	    dyyzz = -yy*dyz/y1
	    if ( y1 .gt. 0 ) then
		ieps = iepsz
	    else
		ieps = -iepsz
	    endif
	    call ffcxr(cs3(11),ipi12(2),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,2*ieps,ier)
	    do 20 i=11,20
		cs3(i) = -cs3(i)
   20	    continue
	    ipi12(2) = -ipi12(2)
*  #] only cancellations in w, not in y:
*  #[ Hill identity:
	elseif (  ( 1 .gt. xloss*abs(y) .or. abs(xx1) .gt. xloss )
     +	    .and. ( 1 .gt. xloss*abs(z) .or. abs(z/dyz) .gt. xloss )
     +	    .and. ( 1 .gt. xloss*abs(y) .or. abs(dyz/y) .gt. xloss )
     +		) then
*	    do a Hill identity on the y,y-1 direction
	    if ( lwrite ) print *,'  Hill identity to split z,w'
	    yy = -y*w1/dwy
	    yy1 = w*y1/dwy
	    zz = -z*w1/dwz
	    zz1 = w*z1/dwz
	    dyyzz = -w*w1*(dyz/(dwy*dwz))
	    if ( y*dwz .gt. 0 .eqv. (y+dwz) .gt. 0 ) then
		ieps = 2*iepsw
	    else
		ieps = -2*iepsw
	    endif
	    call ffcxr(cs3( 1),ipi12(1),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,ieps,ier)
	    yy = w1
	    yy1 = w
	    zz = -w1*z/dwz
	    zz1 = w*z1/dwz
	    dyyzz = w*w1/dwz
	    call ffcxr(cs3( 9),ipi12(2),yy,yy1,zz,zz1,dyyzz,.FALSE.,x0,
     +			x0,x0,.FALSE.,x00,ieps,ier)
	    do 30 i=9,16
   30		cs3(i) = -cs3(i)
	    ipi12(2) = -ipi12(2)
*	    the extra logarithms ...
	    if ( 1 .lt. xloss*abs(w) ) then
		chulp = dfflo1(1/w,ier)
	    elseif ( w1 .lt. 0 .or. w .lt. 0 ) then
		chulp = log(-w1/w)
	    else
		chulp = DCMPLX(DBLE(log(w1/w)),DBLE(-iepsw*pi))
	    endif
	    cs3(20) = -DBLE(dfflo1(dwz/dwy,ier))*chulp
*  #] Hill identity:
*  #[ Taylor expansion:
	elseif ( (w.lt.0..or.w1.lt.0) .and. (z.lt.0..or.z1.lt.0) ) then
*	    do a Taylor expansion
	    if ( abs(xx1) .lt. xloss ) then
		if ( lwrite ) print *,'ffdcxr: Taylor expansion, normal'
		d3 = dwz/dwy
*		isign = 1
		xx1n = xx1
		d2n = d2
		d3n = d3
		d21 = 1-d2
		d21n1 = 1
		d31 = 1-d3
		d31n1 = 1
		tot = xx1*d2*d3
		do 50 i=2,20
		    xx1n = xx1n*xx1
		    d21n1 = d21n1*d21
		    d31n1 = d31n1*d31
		    d2n = d2n + d2*d21n1
		    d3n = d3n + d3*d31n1
		    term = xx1n*d2n*d3n*xn2inv(i)
		    tot = tot + term
		    if ( abs(term) .le. precx*abs(tot) ) goto 51
   50		continue
		if ( lwarn ) call ffwarn(46,ier,tot,term)
   51		continue
*		if ( isign .eq. 1 ) then
		    cs3(1) = tot
*		else
*		    cs3(1) = -tot
*		endif
	    elseif ( abs(z/dyz) .lt. xloss ) then
		if ( lwrite ) print *,'  Normal case'
		inorm = 1
		call ffcxr(cs3( 1),ipi12(1),y,y1,z,z1,dyz,
     +		     .TRUE.,d2yzz,zp,zp1,.FALSE.,x00,iepsz,ier)
		call ffcxr(cs3(11),ipi12(2),y,y1,w,w1,-dwy,
     +		     .TRUE.,d2yww,wp,wp1,.FALSE.,x00,iepsw,ier)
		do 110 i=11,20
  110		    cs3(i) = -cs3(i)
*		if ( lwrite ) print *,'ffdcxr: Taylor expansion, 1-x'
*		print *,'NOT YET READY !!!'
*		ier = ier + 100
*		yy = y1*dwz/(z1*dwy)
*		if ( abs(yy) .lt. xloss ) then
*		    cs3(10) = -dfflo1(1/y,ier)*dfflo1(yy,ier)
*		else
*		    yy1 = -w1*dyz/(z1*dwy)
*		    if ( yy1 .gt. xalogm ) then
*			cs3(10) = -dfflo1(1/y,ier)*log(yy1)
*		    elseif ( yy1 .gt. -xalogm ) then
*			if ( lwarn ) call ffwarn(80,ier,yy1,xalogm)
*		    else
*			xlogy = log(-yy1)
*			if ( lwarn .and. iepsz.ne.iepsw )
*     +				call ffwarn(81,ier,x1,x1)
*			if ( (w1+dyz)*dwz*y1*iepsz .lt. 0 ) then
*			    cs3(10) = -dfflo1(1/y,ier)*DCMPLX(DBLE(xlogy),DBLE(pi))
*			else
*			    cs3(10) = -dfflo1(1/y,ier)*DCMPLX(DBLE(xlogy),DBLE(-pi))
*			endif
*		    endif
*		endif
*		cs3(11) = -dfflo1(1/z,ier)*dfflo1(dwz/dwy,ier)
*		yy = dwz/(w*z1)
*		if ( abs(yy) .lt. xloss ) then
*		    cs3(12) = -dfflo1(w/dwy,ier)*dfflo1(yy,ier)
*		else
*		    yy1 = z*w1/(w*z1)
*		    if ( yy1 .gt. xalogm ) then
*			cs3(12) = -dfflo1(w/dwy,ier)*log(yy1)
*		    elseif (  yy .gt. -xalogm ) then
*			if ( lwarn ) call ffwarn(80,ier,yy,xalogm)
*		    else
*			xlogy = log(-yy1)
*			if ( lwarn .and. iepsz.ne.iepsw )
*     +				call ffwarn(81,ier,x1,x1)
*			if ( dwz*(dwz+1)*ieps .gt. 0 ) then
*			    cs3(12) = -dfflo1(w/dwy,ier)*DCMPLX(DBLE(xlogy),DBLE(pi))
*			else
*			    cs3(12) =-dfflo1(w/dwy,ier)*DCMPLX(DBLE(xlogy),DBLE(-pi))
*			endif
*		    endif
*		endif
*		isign = -1
*		xx1 = -z/dyz
*		d2 = 1/z
*		d3 = dwz/dwy
	    else
		if ( lwrite ) print *,'ffdcxr: Taylor expansion, 1/x'
		call fferr(22,ier)
		return
	    endif
	else
	    if ( lwrite ) print *,'Not clear, take normal route'
	    inorm = 1
	    call ffcxr(cs3( 1),ipi12(1),y,y1,z,z1,dyz,.FALSE.,x0,x0,x0,
     +				.FALSE.,x00,iepsz,ier)
	    call ffcxr(cs3(11),ipi12(2),y,y1,w,w1,-dwy,.FALSE.,x0,x0,x0,
     +				.FALSE.,x00,iepsw,ier)
	    do 40 i=11,20
   40		cs3(i) = -cs3(i)
	    ipi12(2) = -ipi12(2)
	endif
*  #] Taylor expansion:
*  #[ debug output:
        if ( lwrite ) then
	    csum = 0
	    do 900 i=1,20
		csum = csum + cs3(i)
		print '(i2,2g16.8)',i,cs3(i)
  900	    continue
	    print '(a)','---------------------------------'
	    print '(2x,2g16.8,2i3)',csum,ipi12
	    print '(a,i3)','ier = ',ier
	    if ( inorm .eq. 0 ) then
	    lwrite = .FALSE.
	    ier1 = 0
	    ier2 = 0
	    do 905 i=1,20
  905		cs3p(i) = 0
	    ipi12p(1) = 0
	    ipi12p(2) = 0
	    call ffcxr(cs3p( 1),ipi12p(1),y,y1,z,z1,dyz,.FALSE.,x0,x0,
     +				x0,.FALSE.,x00,iepsz,ier1)
	    call ffcxr(cs3p(11),ipi12p(2),y,y1,w,w1,-dwy,.FALSE.,x0,x0,
     +				x0,.FALSE.,x00,iepsw,ier2)
	    csum1 = 0
	    do 910 i=1,10
  910		csum1 = csum1 + cs3p(i)
	    csum2 = 0
	    do 920 i=11,20
  920		csum2 = csum2 - cs3p(i)
	    csum = csum1 + csum2 + (ipi12p(1)-ipi12p(2))*DBLE(pi12)
	    print *,'cmp with:'
	    print '(i2,2g16.8,i3)',1,csum1,ier1
	    print '(i2,2g16.8,i3)',2,csum2,ier2
	    print *,'------------------+'
	    print '(2x,2g16.8,3i3)',csum1+csum2,ipi12p,max(ier1,ier2)
	    print '(2x,2g16.8,3i3)',csum
	    lwrite = .TRUE.
	    endif
	endif
*  #] debug output:
*###] ffdcxr:
	end
*###[ ffdcrr:
	subroutine ffdcrr(cs3,ipi12,cy,cy1,cz,cz1,czp,czp1,cd2yzz,cw,cw1
     +		,cwp,cwp1,cd2yww,cdyz,cdwy,cdwz,isoort,iepsz,iepsw,ier)
***#[*comment:***********************************************************
*									*
*	Calculate							*
*									*
*		R(cy,cz,iepsz) - R(cy,cw,iepsw)				*
*									*
*	Input:								*
*		a = [yzw]	(real)		see definition		*
*		a1 = 1 - a	(real)					*
*		dab = a - b	(real)					*
*		ieps[zw]	(integer)	sign of imaginary part	*
*						of argument logarithm	*
*		cs3(20)		(complex)	assumed zero		*
*									*
*	Output:								*
*		cs3(20)		(complex)	the results, not added	*
*		ipi12(2)	(integer)	factors pi^2/12		*
*									*
*	Calls:	ffcrr							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(2),isoort,iepsz,iepsw,ier
	DOUBLE COMPLEX cs3(20)
	DOUBLE COMPLEX cy,cz,czp,cw,cwp,cy1,cz1,czp1,cw1,cwp1,
     +		cdyz,cdwy,cdwz,cd2yzz,cd2yww
*
*	local variables:
*
	integer i,ieps,ieps1,ieps2,ipi12p(2),ier1,ier2,isign,inorm,i2pi,
     +		nffeta,nffet1,n1,n2,n3,n4,n5,n6
	logical ld2yyz
	DOUBLE COMPLEX cyy,cyy1,czz,czz1,cdyyzz,chulp,zfflo1,zfflog,
     +		cc1,cdw,cc1n,cterm,ctot,cd2,cd3,
     +		cd21,cd31,cd2n,cd3n,cd21n1,cd31n1,
     +		cc2,cfactz,cfactw,czzp,czzp1,cd2yyz
	DOUBLE COMPLEX csum,csum1,csum2,cs3p(20),c,check
	DOUBLE PRECISION absc,xlosn
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
	inorm = 0
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-1-mod(ier,50))
	    check = cd2yzz - 2*cy + cz + czp
	    if ( xlosn*absc(check) .gt. precc*max(2*absc(cy),absc(cz),
     +			absc(czp)) ) then
		print *,'ffdcrr: error:  cd2yzz != 2*cy - cz - czp:',
     +			cd2yzz,cy,cz,czp,check
	    endif
	    check = cd2yww - 2*cy + cw + cwp
	    if ( xlosn*absc(check) .gt. precc*max(2*absc(cy),absc(cw),
     +			absc(cwp)) ) then
		print *,'ffdcrr: error:  cd2yww != 2*cy - cw - cwp:',
     +			cd2yww,cy,cw,cwp,check
	    endif
	endif
*  #] check input:
*  #[ groundwork:
	if ( cdwz .eq. 0 ) then
	    if ( abs(DIMAG(cz)) .gt. precc*abs(DBLE(cz)) .or.
     +		iepsz .eq. iepsw ) return
	    if ( DBLE(cz) .ge. 0 .and. DBLE(cz1) .ge. 0 ) return
	    call fferr(76,ier)
	    return
	endif
	if ( cdyz .eq. 0 ) then
	    call fferr(77,ier)
	    return
	endif
	cc1 = cy/cdyz
	cdw = cdwz/cdyz
	if ( DBLE(cc1) .le. x05 .or. abs(cc1-1) .gt. 1 ) then
	    cd2 = 1/cy
	    cdw = cdw*cy/cw
	else
	    cd2 = 1/cz1
	endif
*  #] groundwork:
*  #[ trivial case:
	if ( absc(cdw) .eq. 0 ) then
	    if ( lwrite ) print *,'  Trivial case'
*  #] trivial case:
*  #[ normal case:
*
*	if no cancellations are expected OR the imaginary signs differ
*	and are significant
*
	elseif ( absc(cdw) .gt. xloss .or. (iepsz.ne.iepsw .and.
     +		(DBLE(cy/cdyz).gt.1 .or. DBLE(-cy1/cdyz).gt.1) ) ) then
*	    nothing's the matter
	    if ( lwrite ) print *,'ffdcrr: Normal case'
	    inorm = 1
	    call ffcrr(cs3(1),ipi12(1),cy,cy1,cz,cz1,cdyz,.TRUE.,
     +		cd2yzz,czp,czp1,isoort,iepsz,ier)
	    call ffcrr(cs3(8),ipi12(2),cy,cy1,cw,cw1,-cdwy,.TRUE.,
     +		cd2yww,cwp,cwp1,isoort,iepsw,ier)
	    do 10 i=8,14
   10		cs3(i) = -cs3(i)
	    ipi12(2) = -ipi12(2)
*  #] normal case:
*  #[ only cancellations in cw, not in cy:
	elseif ( absc(cd2) .gt. xloss ) then
*	    there are no cancellations the other way:
	    if ( lwrite ) print *,'ffdcrr: Cancellations one way, ',
     +		'turned Rs'
	    cyy = cdwy/cdwz
	    czz = cz*cyy/cy
	    cyy1 = cdyz/cdwz
	    czz1 = cyy1*cw/cy
	    cdyyzz = cdyz*cyy/cy
	    if ( DBLE(cy) .gt. 0 ) then
		ieps1 = -3*iepsz
	    else
		ieps1 = +3*iepsz
	    endif
*	    Often 2y-z-z is relevant, but 2*yy-zz-zz is not, solve by
*	    introducing zzp.
	    czzp = czp*cyy/cy
	    cd2yyz = cd2yzz*cyy/cy
	    czzp1 = 1 - czzp
	    if ( absc(czzp1) .lt. xloss ) then
*		later try more possibilities
		ld2yyz = .FALSE.
	    else
		ld2yyz = .TRUE.
	    endif
	    call ffcrr(cs3(1),ipi12(1),cyy,cyy1,czz,czz1,cdyyzz,
     +		ld2yyz,cd2yyz,czzp,czzp1,isoort,ieps1,ier)
	    czz = cyy*cz1/cy1
	    czz1 = cyy1*cw1/cy1
	    if ( DBLE(-cy1) .gt. 0 ) then
		ieps2 = -3*iepsz
	    else
		ieps2 = +3*iepsz
	    endif
	    cdyyzz = -cyy*cdyz/cy1
	    czzp = czp1*cyy/cy1
	    cd2yyz = -cd2yzz*cyy/cy1
	    czzp1 = 1 - czzp
	    if ( absc(czzp1) .lt. xloss ) then
*		later try more possibilities
		ld2yyz = .FALSE.
	    else
		ld2yyz = .TRUE.
	    endif
	    call ffcrr(cs3(8),ipi12(2),cyy,cyy1,czz,czz1,cdyyzz,
     +		.TRUE.,cd2yyz,czzp,czzp1,isoort,ieps2,ier)
	    do 20 i=8,14
		cs3(i) = -cs3(i)
   20	    continue
	    ipi12(2) = -ipi12(2)
*	    eta terms (are not calculated in ffcrr as ieps = 3)
	    cfactz = 1/cdyz
	    if ( DIMAG(cz) .eq. 0 ) then
		if ( DIMAG(cy) .eq. 0 ) then
		    n1 = 0
		    n2 = 0
		else
		    n1 = nffet1(DCMPLX(DBLE(0),DBLE(iepsz)),cfactz,
     +			-cz*cfactz,ier)
		    n2 = nffet1(DCMPLX(DBLE(0),DBLE(iepsz)),cfactz,
     +			cz1*cfactz,ier)
		endif
	    else
		n1 = nffeta(-cz,cfactz,ier)
		n2 = nffeta(cz1,cfactz,ier)
	    endif
	    cfactw = -1/cdwy
	    if ( DIMAG(cw) .eq. 0 ) then
		if ( DIMAG(cy) .eq. 0 ) then
		    n4 = 0
		    n5 = 0
		else
		    n4 = nffet1(DCMPLX(DBLE(0),DBLE(iepsw)),cfactw,
     +			-cw*cfactw,ier)
		    n5 = nffet1(DCMPLX(DBLE(0),DBLE(iepsw)),cfactw,
     +			cw1*cfactw,ier)
		endif
	    else
		n4 = nffeta(-cw,cfactw,ier)
		n5 = nffeta(cw1,cfactw,ier)
	    endif
*
*	    we assume that cs3(15-17) are not used, this is always true
*
	    n3 = 0
	    n6 = 0
	    if ( n1.eq.n4 ) then
		if ( n1.eq.0 ) then
*		    nothing to do
		else
		    cc1 = cdwz/cdyz
		    if ( absc(cc1) .lt. xloss ) then
			cs3(15) = n1*c2ipi*zfflo1(cc1,ier)
		    else
			cc1 = -cdwy/cdyz
			cs3(15) = n1*c2ipi*zfflog(cc1,0,c0,ier)
		    endif
		    cc1 = cy*cfactz
		    cc2 = cy*cfactw
		    if ( DIMAG(cc1).eq.0 .or. DIMAG(cc2).eq.0 ) then
			n3 = 0
		    else
			n3 = nffeta(cc1,1/cc2,ier)
		    endif
		    if ( n3.ne.0 ) then
			print *,'ffdcrr: error: untested algorithm'
			ier = ier + 50
			ipi12(1) = ipi12(1) + 4*12*n1*n3
		    endif
		endif
	    else
		cc1 = cy*cfactz
		cc2 = cy*cfactw
		cs3(15) = (n1*zfflog(cc1,ieps1,c0,ier) + 
     +			   n4*zfflog(cc2,ieps1,c0,ier))*c2ipi
	    endif
	    if ( n2.eq.n5 ) then
		if ( n2.eq.0 ) then
*		    nothing to do
		else
		    cc1 = cdwz/cdyz
		    if ( absc(cc1) .lt. xloss ) then
			cs3(16) = n2*c2ipi*zfflo1(cc1,ier)
		    else
			cc1 = -cdwy/cdyz
			cs3(16) = n2*c2ipi*zfflog(cc1,0,c0,ier)
		    endif
		    cc1 = -cy1*cfactz
		    cc2 = -cy1*cfactw
		    if ( DIMAG(cc1).eq.0 .or. DIMAG(cc2).eq.0 ) then
			n6 = 0
		    else
			n6 = nffeta(cc1,1/cc2,ier)
		    endif
		    if ( n6.ne.0 ) then
			print *,'ffdcrr: error: untested algorithm'
			ier = ier + 50
			ipi12(2) = ipi12(2) + 4*12*n2*n6
		    endif
		endif
	    else
		cc1 = -cy1*cfactz
		cc2 = -cy1*cfactw
		cs3(15) = (n2*zfflog(cc1,ieps2,c0,ier) + 
     +			   n5*zfflog(cc2,ieps2,c0,ier))*c2ipi
	    endif
	    if ( lwrite ) then
		print *,'  eta''s z are :',n1,n2,n3
		print *,'  eta''s w are :',n4,n5,n6
	    endif
*  #] only cancellations in cw, not in cy:
*  #[ Hill identity:
	elseif (  ( 1.gt.xloss*absc(cy) .or. absc(cc1).gt.xloss )
     +	    .and. ( 1.gt.xloss*absc(cz) .or. absc(cz/cdyz).gt.xloss )
     +	    .and. ( 1.gt.xloss*absc(cy) .or. absc(cdyz/cy).gt.xloss )
     +		) then
*	    do a Hill identity on the cy,cy-1 direction
	    if ( lwrite ) print *,'ffdcrr: Hill identity to split cz,cw'
	    cyy = -cy*cw1/cdwy
	    cyy1 = cw*cy1/cdwy
	    czz = -cz*cw1/cdwz
	    czz1 = cw*cz1/cdwz
	    cdyyzz = -cw*cw1*(cdyz/(cdwy*cdwz))
	    ieps = -2*iepsz
	    call ffcrr(cs3(1),ipi12(1),cyy,cyy1,czz,czz1,cdyyzz,
     +		.FALSE.,c0,c0,c0,isoort,ieps,ier)
	    cyy = cw1
	    cyy1 = cw
	    czz = -cw1*cz/cdwz
	    czz1 = cw*cz1/cdwz
	    cdyyzz = cw*cw1/cdwz
	    call ffcrr(cs3(8),ipi12(2),cyy,cyy1,czz,czz1,cdyyzz,
     +		.FALSE.,c0,c0,c0,isoort,0,ier)
	    do 30 i=8,14
   30		cs3(i) = -cs3(i)
	    ipi12(2) = -ipi12(2)
*	    the extra logarithms ...
	    if ( 1 .lt. xloss*absc(cw) ) then
		chulp = zfflo1(1/cw,ier)
	    else
		chulp = zfflog(-cw1/cw,0,c0,ier)
	    endif
	    cs3(15) = -zfflo1(cdwz/cdwy,ier)*chulp
*  #] Hill identity:
*  #[ Taylor expansion:
	else
*	    Do a Taylor expansion
	    if ( absc(cc1) .lt. xloss ) then
		if ( lwrite ) print *,'ffdcrr: Taylor expansion, normal'
		cd3 = cdwz/cdwy
*		isign = 1
		cc1n = cc1
		cd2n = cd2
		cd3n = cd3
		cd21 = 1-cd2
		cd21n1 = 1
		cd31 = 1-cd3
		cd31n1 = 1
		ctot = cc1*cd2*cd3
		do 50 i=2,20
		    cc1n = cc1n*cc1
		    cd21n1 = cd21n1*cd21
		    cd31n1 = cd31n1*cd31
		    cd2n = cd2n + cd2*cd21n1
		    cd3n = cd3n + cd3*cd31n1
		    cterm = cc1n*cd2n*cd3n*DBLE(xn2inv(i))
		    ctot = ctot + cterm
		    if ( absc(cterm) .lt. precc*absc(ctot) ) goto 51
   50		continue
		if ( lwarn ) call ffwarn(45,ier,absc(ctot),absc(cterm))
   51		continue
*		if ( isign .eq. 1 ) then
		    cs3(1) = ctot
*		else
*		    cs3(1) = -ctot
*		endif
	    elseif ( absc(cz/cdyz) .lt. xloss ) then
		if ( lwrite ) print *,'ffdcrr: Normal case'
		inorm = 1
		call ffcrr(cs3(1),ipi12(1),cy,cy1,cz,cz1,cdyz,.TRUE.,
     +			cd2yzz,czp,czp1,isoort,iepsz,ier)
		call ffcrr(cs3(8),ipi12(2),cy,cy1,cw,cw1,-cdwy,.TRUE.,
     +			cd2yww,cwp,cwp1,isoort,iepsw,ier)
		do 110 i=8,14
  110			cs3(i) = -cs3(i)
		ipi12(2) = -ipi12(2)
*		if ( lwrite ) print *,'ffdcrr: Taylor expansion, 1-x'
*		print *,'NOT YET READY !!'
*		ier = ier + 100
*		cyy = cy1*cdwz/(cz1*cdwy)
*		if ( absc(cyy) .lt. xloss ) then
*		    cs3(10) = -zfflo1(1/cy,ier)*zfflo1(cyy,ier)
*		else
*		    cyy1 = -cw1*cdyz/(cz1*cdwy)
*		    cs3(10) = -zfflo1(1/cy,ier)*zfflog(cyy1,0,cy,ier)
*		endif
*		cs3(11) = -zfflo1(1/cz,ier)*zfflo1(cdwz/cdwy,ier)
*		cyy = cdwz/(cw*cz1)
*		if ( absc(cyy) .lt. xloss ) then
*		    cs3(12) = -zfflo1(cw/cdwy,ier)*zfflo1(cyy,ier)
*		else
*		    cyy1 = cz*cw1/(cw*cz1)
*		    cs3(12) = -zfflo1(cw/cdwy,ier)*zfflog(cyy1,0,c0,ier)
*		endif
*		isign = -1
*		cc1 = -cz/cdyz
*		cd2 = 1/cz
*		cd3 = cdwz/cdwy
	    else
		if ( lwrite ) print *,'ffdcrr: Taylor expansion, 1/x'
		call fferr(20,ier)
		return
	    endif
	endif
*  #] Taylor expansion:
*  #[ debug output:
        if ( lwrite ) then
	    csum = 0
	    do 900 i=1,20
		csum = csum + cs3(i)
		print '(i2,2g16.8)',i,cs3(i)
  900	    continue
	    print '(a)','---------------------------------'
	    print '(2x,2g16.8,2i3)',csum,ipi12
	    print '(a,2g16.8)','= ',csum+(ipi12(1)+ipi12(2))*DBLE(pi12)
	    print '(a,i3)','ier = ',ier
	    if ( inorm .eq. 0 ) then
		lwrite = .FALSE.
		ier1 = 0
		ier2 = 0
		do 905 i=1,14
  905			cs3p(i) = 0
		ipi12p(1) = 0
		ipi12p(2) = 0
		call ffcrr(cs3p(1),ipi12p(1),cy,cy1,cz,cz1,cdyz,
     +			.TRUE.,cd2yzz,czp,czp1,isoort,iepsz,ier1)
		call ffcrr(cs3p(8),ipi12p(2),cy,cy1,cw,cw1,-cdwy,
     +			.TRUE.,cd2yww,cwp,cwp1,isoort,iepsw,ier2)
		csum1 = 0
		do 910 i=1,7
  910			csum1 = csum1 + cs3p(i)
		csum2 = 0
		do 920 i=8,14
  920			csum2 = csum2 - cs3p(i)
		print *,'cmp with:'
		print '(i2,2g16.8,i2)',1,csum1,ier1
		print '(i2,2g16.8,i2)',2,csum2,ier2
		print *,'------------------+'
		print '(2x,2g16.8,3i3)',csum1+csum2,ipi12p,
     +			max(ier1,ier2)
		print '(a,2g16.8,3i3)','= ',csum1+csum2+
     +			(ipi12p(1)-ipi12p(2))*DBLE(pi12)
		lwrite = .TRUE.
	    endif
	endif
*  #] debug output:
*###] ffdcrr:
	end
*###[ ffcxyz:
	subroutine ffcxyz(cy,cz,cdyz,cd2yzz,ivert,sdelpp,sdelps,etalam,
     +			etami,delps,xpi,piDpj,isoort,ldel2s,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*	cz(1,2) = (-p(ip1).p(is2) +/- sdelpp)/xpi(ip1)			*
*	cy(1,2) = (-p(ip1).p(is2) +/- sdisc)/xpi(ip1)			*
*			disc = slam1 + 4*eta*xpi(ip)/slam		*
*									*
*	cy(3,4) = 1-cy(1,2)						*
*	cz(3.4) = 1-cz(1,2)						*
*	cdyz(i,j) = cy(i) - cz(j)					*
*									*
*	Input:	ivert		(integer)	1,2 of 3		*
*		sdelpp		(real)		sqrt(lam(p1,p2,p3))/2	*
*		sdelps		(real)		sqrt(-lam(p,ma,mb))/2	*
*		etalam		(real)		det(si.sj)/det(pi.pj)	*
*		etami(6)	(real)		si.si - etalam		*
*		xpi(ns)		(real)		standard		*
*		piDpj(ns,ns)	(real)		standard		*
*		ns		(integer)	dim of xpi,piDpj	*
*									*
*	Output:	cy(4),cz(4),cdyz(4,4)	(complex)	see above	*
*									*
*	Calls:	??							*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ivert,isoort(2),ns,ier
	logical ldel2s
	DOUBLE COMPLEX cy(4),cz(4),cdyz(2,2),cd2yzz
	DOUBLE PRECISION sdelpp,sdelps,etalam,etami(6),delps,xpi(ns),
     +		piDpj(ns,ns)
*
*	local variables:
*
	integer i,j,ip1,ip2,ip3,is1,is2,is3
	DOUBLE COMPLEX c
	DOUBLE PRECISION absc,y(4)
	DOUBLE PRECISION delps1,disc,hulp,xlosn
*
*	common blocks:
*
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ set up pointers:
	if ( ldel2s .and. ivert .ne. 1 ) goto 100
	is1 = ivert
	is2 = ivert+1
	if ( is2 .eq. 4 ) is2 = 1
	is3 = ivert-1
	if ( is3 .eq. 0 ) is3 = 3
	ip1 = is1 + 3
*	ip2 = is2 + 3
*	ip3 = is3 + 3
	isoort(1) = -10
	isoort(2) = -10
*  #] set up pointers: 
*  #[ test input:
	if ( ltest .and. xpi(ip1) .eq. 0 ) then
	    call fferr(47,ier)
	    return
	endif
*  #] test input: 
*  #[ get cypm,czpm:
	hulp = sdelps/xpi(ip1)
	cz(1) = DCMPLX(piDpj(ip1,is2)/xpi(ip1),-hulp)
	cz(2) = DCMPLX(piDpj(ip1,is2)/xpi(ip1),+hulp)
	disc = delps/sdelpp
	call ffroot(y(1),y(2),xpi(ip1),piDpj(ip1,is2),etami(is2),disc,
     +								ier)
	cy(1) = y(1)
	cy(2) = y(2)
*  #] get cypm,czpm: 
*  #[ get cypm1,czpm1:
	if ( xpi(is1) .eq. xpi(is2) ) then
	    cy(4) = cy(1)
	    cy(3) = cy(2)
	    cz(4) = cz(1)
	    cz(3) = cz(2)
	else
	    cz(3) = 1 - cz(1)
	    cz(4) = 1 - cz(2)
	    if ( absc(cz(3)).lt.xloss .or. absc(cz(4)).lt.xloss ) then
		cz(3) =DCMPLX(-piDpj(ip1,is1)/xpi(ip1),+hulp)
		cz(4) =DCMPLX(-piDpj(ip1,is1)/xpi(ip1),-hulp)
	    endif
	    y(3) = 1 - y(1)
	    y(4) = 1 - y(2)
	    if ( abs(y(3)) .lt. xloss .or. abs(y(4)) .lt. xloss ) then
		call ffroot(y(4),y(3),xpi(ip1),-piDpj(ip1,is1),
     +						etami(is1),disc,ier)
	    endif
	    cy(3) = y(3)
	    cy(4) = y(4)
	endif
*  #] get cypm1,czpm1: 
*  #[ get cdypzp, cdypzm:
	cdyz(2,1) = DCMPLX(disc/xpi(ip1),+hulp)
	cdyz(2,2) = DCMPLX(disc/xpi(ip1),-hulp)
	cdyz(1,1) = -cdyz(2,2)
	cdyz(1,2) = -cdyz(2,1)
	cd2yzz = 2*disc/xpi(ip1)
	goto 200
*  #] get cdypzp, cdypzm: 
*  #[ special case, get indices:
  100	continue
	if ( ivert.eq.2 ) then
	    is1 = 2
	    ip1 = 5
	else
	    is1 = 1
	    ip1 = 6
	endif
	isoort(1) = -100
	isoort(2) = -100
*  #] special case, get indices: 
*  #[ get cypm,czpm:
*
*	special case del2s = 0, hence the roots are not the real roots
*	but z_2'' = (z_2'-1)/delta, z''_3 = -z'_3/delta
*
	hulp = sdelps/xpi(3)
	disc = delps/sdelpp
	if ( ivert .eq. 3 ) then
	    hulp = -hulp
	    disc = -disc
	endif
	cz(1) = DCMPLX(piDpj(is1,3)/xpi(3),-hulp)
	cz(2) = DCMPLX(piDpj(is1,3)/xpi(3),+hulp)
	call ffroot(y(1),y(2),xpi(3),piDpj(is1,3),etami(is1),disc,ier)
	cy(1) = y(1)
	cy(2) = y(2)
*  #] get cypm,czpm: 
*  #[ get cypm1,czpm1:
	cz(3) = 1 - cz(1)
	cz(4) = 1 - cz(2)
	if ( absc(cz(3)).lt.xloss .or. absc(cz(4)).lt.xloss ) then
	    if ( lwrite ) print *,'cz(3,4) = ',cz(3),cz(4)
	    if ( ivert.eq.2 ) then
		cz(3) =DCMPLX(piDpj(ip1,3)/xpi(3),+hulp)
		cz(4) =DCMPLX(piDpj(ip1,3)/xpi(3),-hulp)
	    else
		cz(3) =DCMPLX(-piDpj(ip1,3)/xpi(3),+hulp)
		cz(4) =DCMPLX(-piDpj(ip1,3)/xpi(3),-hulp)
	    endif
	    if ( lwrite ) print *,'cz(3,4)+= ',cz(3),cz(4)
	endif
	y(3) = 1 - y(1)
	y(4) = 1 - y(2)
	if ( abs(y(3)) .lt. xloss .or. abs(y(4)) .lt. xloss ) then
	    if ( lwrite ) print *,'y(3,4) = ',y(3),y(4)
	    if ( ivert .eq. 2 ) then
		call ffroot(y(4),y(3),xpi(3),piDpj(ip1,3),etami(ip1),
     +							disc,ier)
	    else
		call ffroot(y(4),y(3),xpi(3),-piDpj(ip1,3),etami(ip1),
     +							disc,ier)
	    endif
	    if ( lwrite ) print *,'y(3,4)+= ',y(3),y(4)
	endif
	cy(3) = y(3)
	cy(4) = y(4)
*  #] get cypm1,czpm1: 
*  #[ get cdypzp, cdypzm:
	cdyz(2,1) = DCMPLX(disc/xpi(3),+hulp)
	cdyz(2,2) = DCMPLX(disc/xpi(3),-hulp)
	cdyz(1,1) = -cdyz(2,2)
	cdyz(1,2) = -cdyz(2,1)
	cd2yzz = 2*disc/xpi(3)
*  #] get cdypzp, cdypzm: 
*  #[ test output:
  200	continue
	if ( ltest ) then
	    xlosn = xloss**2*DBLE(10)**(-mod(ier,50))
	    do 99 i=1,2
		if ( xlosn*absc(cy(i)+cy(i+2)-1) .gt. precc*max(absc(
     +		    cy(i)),absc(cy(i+2)),x1)) print *,'ffcxyz: error: ',
     +		    'cy(',i+2,')<>1-cy(',i,'):',cy(i+2),cy(i),cy(i+2)+
     +		    cy(i)-1
		if ( xlosn*absc(cz(i)+cz(i+2)-1) .gt. precc*max(absc(
     +		    cz(i)),absc(cz(i+2)),x1)) print *,'ffcxzz: error: ',
     +		    'cz(',i+2,')<>1-cz(',i,'):',cz(i+2),cz(i),cz(i+2)+
     +		    cz(i)-1
		do 98 j=1,2
		    if ( xlosn*absc(cdyz(i,j)-cy(i)+cz(j)) .gt. precc*
     +			max(absc(cdyz(i,j)),absc(cy(i)),absc(cz(j))) )
     +			print *,'ffcxyz: error: cdyz(',i,j,') <> cy(',i,
     +			')-cz(',j,'):',cdyz(i,j),cy(i),cz(j),cdyz(i,j)-
     +			cy(i)+cz(j)
   98		continue
   99	    continue
	endif
*  #] test output: 
*###] ffcxyz: 
	end
*###[ ffcdwz:
	subroutine ffcdwz(cdwz,cw,cz,i1,j1,l,calpha,calph1,cpi,cdpipj,
     +					cpiDpj,csdeli,csdel2,ns,ier)
***#[*comment:***********************************************************
*									*
*	Recalculate cdwz(i1,j1) = cw(i1) - cz(j1)			*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer i1,j1,l,ns,ier
	DOUBLE COMPLEX cdwz(2,2),cw(4),cz(4),calpha,calph1,cpi(ns)
	DOUBLE COMPLEX cdpipj(ns,ns),cpiDpj(ns,ns),csdeli(3),csdel2
*
*	local variables:
*
	integer i,n
	DOUBLE COMPLEX cs(8),csum,cfac,c,cddel
	DOUBLE PRECISION xmax,absc,afac
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ calculations:
	if ( l .eq. 1 ) then
	    if ( j1 .eq. 1 ) then
		if ( absc(csdeli(1)+csdel2) .lt. xloss*absc(csdel2) )
     +								then
*		    for example in e-> e g* with eeg loop
*		    first get the difference of csdeli(1) and csdel2:
		    cs(1) = cpi(4)*cdpipj(2,5)
		    cs(2) = -cpiDpj(4,3)*cpiDpj(4,2)
		    cs(3) = cpiDpj(4,3)*cpiDpj(4,5)
		    csum = cs(1)+cs(2)+cs(3)
		    xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)))
		    if ( absc(csum) .lt. xloss*xmax ) then
			if ( lwrite ) print *,'ffcdwz: canc in cddel'
			ier = 1
			goto 5
		    endif
		    cddel = csum/(csdel2-csdeli(1))
		    if ( i1 .eq. 1 ) then
			cs(1) = cpi(4)*csdeli(2)
		    else
			cs(1) = -cpi(4)*csdeli(2)
		    endif
		    cs(2) = cddel*cpiDpj(4,2)
		    cs(3) = -cpiDpj(4,3)*csdeli(1)
		    cs(4) = cpiDpj(4,3)*cpiDpj(4,5)
		    cs(5) = -cpi(4)*cpiDpj(5,3)
		    cs(6) = -cddel*csdel2
		    n = 6
		else
		    if ( lwrite ) print *,'ffcdwz: ',
     +			'cannot handle this case yet'
		    ier = 1
		    goto 5
		endif
		csum = 0
		xmax = 0
		do 1 i=1,n
		    csum = csum + cs(i)
		    xmax = max(xmax,absc(cs(i)))
    1		continue
		if ( absc(csum) .lt. xloss*xmax ) then
		    if ( lwrite ) print *,'ffcdwz: still cancellations',
     +			' in cdwz(',i1,j1,l,'): ',csum,xmax
		    ier = 1
		endif
		if (lwrite) print *,'  cdwz(',i1,j1,l,')  =',cdwz(i1,j1)
     +				,min(absc(cw(i1)),absc(cw(i1+2)))
		cdwz(i1,j1) = csum/calph1/cpi(4)/cpi(5)
		if ( cdwz(i1,j1) .eq. 0 .and. csum .ne. 0 ) then
		    print *,'?#$&!! cdwz = 0 but csum != 0, try again'
		    afac = 1/absc(csum)
		    csum = csum*DBLE(afac)
		    cdwz(i1,j1) = csum/calph1/cpi(4)/cpi(5)
		    afac = 1/afac
		    cdwz(i1,j1) = cdwz(i1,j1)*DBLE(afac)
		endif
		if (lwrite) print *,'  cdwz(',i1,j1,l,')+ =',cdwz(i1,j1)
     +				,xmax/absc(calph1*cpi(4)*cpi(5))
	    else
		if ( lwrite ) print *,'ffcdwz:  warning: cannot handle',
     +			' this case cdwz(',i1,j1,l,') yet'
		ier = 1
	    endif
    5	    continue
	elseif ( l .eq. 3 ) then
	    if ( (i1.eq.2 .and. j1.eq.1) .or. (i1.eq.1 .and. j1.eq.2 ) )
     +			then
		cfac = 1/(csdeli(2) + csdeli(3))
		cs(1) = cdpipj(6,5)*cz(j1)
		cs(2) = -calph1*cpi(5)*cz(j1+2)
		if ( max(absc(cdpipj(2,1)),absc(cdpipj(5,6))) .lt.
     +		     max(absc(cdpipj(2,6)),absc(cdpipj(5,1))) ) then
		    cs(3) = cdpipj(2,1)/2
		    cs(4) = cdpipj(5,6)/2
		else
		    cs(3) = cdpipj(2,6)/2
		    cs(4) = cdpipj(5,1)/2
		endif
		cs(5) = cpiDpj(4,3)*cpiDpj(5,3)*cfac
		cs(6) = -cpiDpj(4,3)*cpiDpj(6,3)*cfac
		cs(7) = cpi(3)*cdpipj(5,6)*cfac
		if ( i1 .eq. 1 ) then
		    csum = cs(1)+cs(2)+cs(3)+cs(4) - (cs(5)+cs(6)+cs(7))
		else
		    csum = cs(1)+cs(2)+cs(3)+cs(4) + cs(5)+cs(6)+cs(7)
		endif
		xmax = absc(cs(1))
		do 10 i=2,7
		    xmax = max(xmax,absc(cs(i)))
   10		continue
		if ( absc(csum) .lt. xloss*xmax ) then
*		    this result is not used if it is not accurate (see
*		    ffxc0p)
		    if ( lwrite ) then
			call ffwarn(78,ier,absc(csum),xmax)
		    else
			ier = max(ier,1)
		    endif
		    xmax = xmax/absc(calpha*cpi(5))
		    if ( xmax .lt. min(absc(cz(j1)),absc(cz(j1+2))) )
     +								then
			if (lwrite) print *,'  cdwz(',i1,j1,l,')  = ',
     +			    cdwz(i1,j1),min(absc(cw(i1)),absc(cw(i1+2)))
			cdwz(i1,j1) = csum/(calpha*cpi(5))
			if (lwrite) print *,'  cdwz(',i1,j1,l,')+ = ',
     +						cdwz(i1,j1),xmax
		    endif
		else
		    if (lwrite) print *,'  cdwz(',i1,j1,l,')  = ',
     +			    cdwz(i1,j1),min(absc(cw(i1)),absc(cw(i1+2)))
		    cdwz(i1,j1) = csum/(calpha*cpi(5))
		    if (lwrite) print *,'  cdwz(',i1,j1,l,')+ = ',
     +				cdwz(i1,j1),xmax/absc(calpha*cpi(5))
		endif
	    else
		if ( lwrite ) print *,'ffcdwz:  warning: cannot handle',
     +			' this case cdwz(',i1,j1,l,') yet'
		ier = 1
	    endif
	else
	    if ( lwrite ) print *,'ffcdwz:  error: l <> 1 or 3 but ',l
	    ier = 99
	endif
*  #] calculations: 
*  #[ test output:
	if ( ltest .and. ier .eq. 0 ) then
	    if ( xloss**2*absc(cdwz(i1,j1)-cw(i1)+cz(j1)) .gt. precc*
     +		max(absc(cdwz(i1,j1)),absc(cw(i1)),absc(cz(j1))) )
     +		print *,'ffcdwz:  error: cdwz(',i1,j1,l,') <> cw - cz :'
     +		,cdwz(i1,j1),cw(i1),cz(j1),cw(i1)-cz(j1),
     +		cdwz(i1,j1)-cw(i1)+cz(j1)
	    if ( xloss**2*absc(cdwz(i1,j1)+cw(i1+2)-cz(j1+2)) .gt.
     +		precc*max(absc(cdwz(i1,j1)),absc(cw(i1+2)),
     +		absc(cz(j1+2))) ) print *,'ffcdwz:  error: cdwz(',i1,j1,
     +		l,') <> cz1- cw1:',cdwz(i1,j1),cz(i1+2),cw(j1+2),
     +		cz(i1+2)-cw(j1+2),cdwz(i1,j1)+cw(i1+2)-cz(j1+2)
	    endif
*  #] test output: 
*###] ffcdwz: 
	end
*###[ ffdcc0:
	subroutine ffdcc0(cs3,ipi12,isoort,clogi,ilogi,xpi,dpipj,piDpj,
     +		xqi,dqiqj,qiDqj,sdel2,del2s,etalam,etami,delpsi,alph,
     +		ddel2s,ldel2s,npoin,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the difference of two threepoint functions		*
*	C(3,...a) - C(4,...b)						*
*									*
*	Input:	xpi(6,3:4)    (complex)	transformed mi,pi squared in Ci	*
*		dpipj(6,6,3:4)(complex)	xpi(i)-xpi(j)			*
*		piDpj(6,6,3:4)(complex)	pi(i).pi(j)			*
*		xqi(10,10)    (complex)	transformed mi,pi squared in D	*
*		dqiqj(10,10)  (complex)	xqi(i)-xqi(j)			*
*		qiDqj(10,10)  (complex)	qi(i).qi(j)			*
*		sdel2	      (complex)	sqrt(delta_{p_1 p_2}^{p_1 p_2})	*
*		del2s(3,3:4)  (complex)	delta_{p_i s_i}^{p_i s_i}	*
*		etalam(3:4)   (complex)	delta_{s_1 s_2 s_3}^{s_1 s_2 s_3}
*					  /delta_{p_1 p_2}^{p_1 p_2}	*
*		etami(6,3:4)  (complex)	m_i^2 - etalam			*
*		ddel2s(2:3)   (complex)	del2s(i,3) - del2s(i,4)		*
*		alph(3)	      (complex)	alph(1)=alpha, alph(3)=1-alpha	*
*									*
*	Output: cs3	 (complex)(160)	C0(3)-C0(4), not yet summed.	*
*		ipi12	 (integer)(6)	factors pi^2/12, not yet summed	*
*		slam	 (complex)	lambda(p1,p2,p3).		*
*		isoort	 (integer)(16)	indication of he method used	*
*		clogi	 (complex)(6)	log(-dyz(2,1,i)/dyz(2,2,i))	*
*		ilogi	 (integer)(6)	factors i*pi in this		*
*		ier	 (integer)	0=ok, 1=inaccurate, 2=error	*
*									*
*	Calls:	...							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(16),isoort(16),ilogi(6),npoin,ier
	logical ldel2s
	DOUBLE COMPLEX cs3(160),clogi(6)
	DOUBLE COMPLEX xqi(10),dqiqj(10,10),qiDqj(10,10),
     +		xpi(6,3:4),dpipj(6,6,3:4),piDpj(6,6,3:4),
     +		sdel2,del2s(3,3:4),etalam(3:4),etami(6,3:4),alph(3),
     +		ddel2s(2:3),delpsi(3,3:4)
*
*	local variables:
*
	integer i,j,k,ip,ii,ifirst,ieri(8)
	DOUBLE COMPLEX c,cc
	DOUBLE COMPLEX sdel2i(3,3:4),s(5),som,zfflo1,xhck,
     +		y(4,3:4,3),z(4,3:4,3),dyz(2,2,3:4,3),d2yzz(3:4,3),
     +		dyzzy(4,3),dsdel2,dyyzz(2,3)
	DOUBLE PRECISION smax,absc,xmax,rloss
	DOUBLE COMPLEX zfflog
*for Absoft
**	DOUBLE COMPLEX csqrt
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    call ffchck(xpi(1,3),dpipj(1,1,3),6,ier)
	    call ffchck(xpi(1,4),dpipj(1,1,4),6,ier)
	    call ffchck(xqi,dqiqj,10,ier)
	    if ( ldel2s ) print *,'ffdcc0: error: cannot handle this ',
     +		'case yet!!'
	endif
*  #] check input:
*  #[   get y,z-roots:
	if ( lwrite ) print '(a)','  ##[ get roots: (ffdcc0)'
	do 20 k=3,4
	do 10 i=1,3
*
*	get roots (y,z)
*
	    ip = i+3
	    sdel2i(i,k) = sqrt(-del2s(i,k))
*	    then handle the special case Si = 0
	    if ( xpi(ip,k) .eq. 0 ) then
		if ( i .eq. 1 .and. alph(3) .eq. 0 .or.
     +		     i .eq. 3 .and. alph(1) .eq. 0 ) then
		    isoort(2*i-1+8*(k-3)) = 0
		    isoort(2*i+8*(k-3)) = 0
		    goto 10
		endif
	    endif
	    call ffccyz(y(1,k,i),z(1,k,i),dyz(1,1,k,i),d2yzz(k,i),i,
     +		sdel2,sdel2i(i,k),etalam(k),etami(1,k),delpsi(i,k),
     +		xpi(1,k),piDpj(1,1,k),isoort(2*i-1+8*(k-3)),6,ier)
   10	continue
   20	continue
*  #]   get y,z-roots:
*  #[   get differences:
*
*	the only important differences are y4z3-z3y4 and (1-y4)(1-z3)-
*	(1-y3)(1-z4).  Note that the errors work in parallel.
*
	do 199 i=1,8
	    ieri(i) = 0
  199	continue
	if ( isoort(1) .eq. isoort(9) ) then
*  #[	    vertices (1):
	    som = qiDqj(7,2)/sdel2
*
*	    flag if we have a cancellation
*
	    if ( absc(som) .lt. xloss ) then
		    isoort(1) = isoort(1) - 10
		    isoort(9) = isoort(9) - 10
	    endif
	    do 201 k=1,4
		dyzzy(k,1) = som*z(k,3,1)
		if ( k .gt. 2 ) dyzzy(k,1) = -dyzzy(k,1)
		if ( lwrite ) then
		    ii = 2*((k+1)/2)
		    print *,'dyzzy(',k,'1)  = ',y(ii,4,1)*z(k,3,1) -
     +			y(ii,3,1)*z(k,4,1),absc(y(ii,4,1)*z(k,3,1))
		    print *,'dyzzy(',k,'1)+ = ',dyzzy(k,1)
		endif
  201	    continue
	    dyyzz(1,1) = som
	    dyyzz(2,1) = som
	    if ( lwrite ) then
		print *,'dyyzz(1,1) =',y(2,4,1)-y(2,3,1)
		print *,'dyyzz(1,1)+=',dyyzz(1,1)
	    endif
*  #]	    vertices (1):
	endif
	if ( isoort(3) .eq. isoort(11) ) then
*  #[       vertices (2):
	    ifirst = 0
	    do 22 j=1,2
	    do 21 k=1,2
		ii = 2*(j-1) + k
		dyzzy(ii,2) = y(2*j,4,2)*z(ii,3,2)-y(2*j,3,2)*z(ii,4,2)
		xmax = absc(y(2*j,4,2)*z(ii,3,2))
		if ( absc(dyzzy(ii,2)) .ge. xmax ) goto 21
		isoort(3) = isoort(3) - 10
		isoort(11) = isoort(11) - 10
		if ( lwrite ) print *,'dyzzy(',ii,'2)  = ',dyzzy(ii,2),
     +								xmax
		if ( ifirst .eq. 0 ) then
		    if ( ddel2s(2) .eq. 0 ) then
			dsdel2 = 0
		    else
			dsdel2 = ddel2s(2)/(sdel2i(2,3)+sdel2i(2,4))
		    endif
		endif
		if ( ifirst .le. 1 ) then
		    if ( j .eq. 1 ) then
			s(1) = xqi(6)*qiDqj(7,4)*qiDqj(5,4)/sdel2
			s(2) = -qiDqj(7,4)*sdel2i(2,3)
			s(3) = +qiDqj(6,4)*dsdel2
		    else
			s(1) = xqi(6)*qiDqj(7,2)*qiDqj(5,2)/sdel2
			s(2) = -qiDqj(7,2)*sdel2i(2,3)
			s(3) = +qiDqj(6,2)*dsdel2
		    endif
		endif
		if ( ifirst .le. 0 ) then
		    ifirst = 2
		    s(4) = -qiDqj(5,10)*qiDqj(7,4)*sdel2i(2,3)/sdel2
		    s(5) = delpsi(2,3)*dsdel2/sdel2
		endif
		if ( k .eq. 1 ) then
		    som = s(1) + s(2) + s(3) + s(4) + s(5)
		else
		    som = s(1) - s(2) - s(3) - s(4) - s(5)
		endif
		smax = max(absc(s(1)),absc(s(2)),absc(s(3)),absc(s(4)),
     +			absc(s(5)))/DBLE(xqi(6))**2
		if ( lwrite ) then
		    print *,'dyzzy(',ii,'2)+ = ',som/xqi(6)**2,smax
		    print *,(s(i)/xqi(6)**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    dyzzy(ii,2) = som*(1/DBLE(xqi(6))**2)
		    xmax = smax
		endif
		if ( lwarn .and. absc(dyzzy(ii,2)).lt.xloss*xmax ) then
		   call ffwarn(142,ieri(2*k+j-2),absc(dyzzy(ii,2)),xmax)
		endif
   21	    continue
*
*	    get dyyzz
*
	    if ( ldel2s ) then
		dyyzz(j,2) = dyz(2,j,4,2) - dyz(2,j,3,2)
		xmax = absc(dyz(2,j,4,2))
		if ( absc(dyyzz(j,2)) .ge. xloss*xmax ) goto 22
 1002		format(a,i1,a,2g22.14,g12.4)
		if ( lwrite ) print 1002,'dyyzz(',j,'2) =',dyyzz(j,2),
     +			xmax
		print *,'ffdcc0: under construction!'
*
*		(could be copied from real case)
*
		if ( lwarn .and. absc(dyyzz(j,2)).lt.xloss*xmax ) then
		    call ffwarn(147,ieri(7+j),absc(dyyzz(j,2)),xmax)
		endif
	    endif
*
*	    bookkeeping
*
	    ifirst = ifirst - 1
   22	    continue
*  #]       vertices (2):
	endif
	if ( isoort(5) .eq. isoort(13) ) then
*  #[       vertices (3):
	    ifirst = 0
	    do 26 j=1,2
	    do 25 k=1,2
		ii = 2*(j-1) + k
		dyzzy(ii,3) = y(2*j,4,3)*z(ii,3,3)-y(2*j,3,3)*z(ii,4,3)
		xmax = absc(y(2*j,4,3)*z(ii,3,3))
		if ( absc(dyzzy(ii,3)) .ge. xmax ) goto 25
		isoort(5) = isoort(5) - 10
		isoort(13) = isoort(13) - 10
		if ( lwrite ) print *,'dyzzy(',ii,'3)  = ',dyzzy(ii,3),
     +								xmax
		if ( ifirst .eq. 0 ) then
		    if ( ddel2s(2) .eq. 0 ) then
			dsdel2 = 0
		    else
			dsdel2 = ddel2s(3)/(sdel2i(3,3)+sdel2i(3,4))
		    endif
		endif
		if ( ifirst .le. 1 ) then
		    if ( j .eq. 1 ) then
			s(1) = xqi(8)*qiDqj(7,1)*qiDqj(5,1)/sdel2
			s(2) = +qiDqj(7,1)*sdel2i(3,3)
			s(3) = +qiDqj(9,1)*dsdel2
		    else
			s(1) = xqi(8)*qiDqj(7,4)*qiDqj(5,4)/sdel2
			s(2) = +qiDqj(7,4)*sdel2i(3,3)
			s(3) = +qiDqj(9,4)*dsdel2
		    endif
		endif
		if ( ifirst .le. 0 ) then
		    ifirst = 2
		    s(4) = -qiDqj(5,9)*qiDqj(7,1)*sdel2i(3,3)/sdel2
		    s(5) = delpsi(3,3)*dsdel2/sdel2
		endif
		if ( k .eq. 1 ) then
		    som = s(1) + s(2) + s(3) + s(4) + s(5)
		else
		    som = s(1) - s(2) - s(3) - s(4) - s(5)
		endif
		smax = max(absc(s(1)),absc(s(2)),absc(s(3)),absc(s(4)),
     +			absc(s(5)))/DBLE(xqi(8))**2
		if ( lwrite ) then
		    print *,'dyzzy(',ii,'3)+ = ',som/xqi(8)**2,smax
		    print *,(s(i)/xqi(8)**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    dyzzy(ii,3) = som*(1/DBLE(xqi(8))**2)
		    xmax = smax
		endif
		if ( lwarn .and. absc(dyzzy(ii,3)).lt.xloss*xmax ) then
		   call ffwarn(142,ieri(2*k+j+2),absc(dyzzy(ii,3)),xmax)
		endif
   25	    continue
*
*	    get dyyzz
*
	    if ( ldel2s ) then
		dyyzz(j,3) = dyz(2,j,4,3) - dyz(2,j,3,3)
		xmax = absc(dyz(2,j,4,3))
		if ( absc(dyyzz(j,3)) .ge. xloss*xmax ) goto 24
		print *,'ffdcc0: under construction!'
*
*		(could be copied from real case)
*
		if ( lwrite ) print 1002,'dyyzz(',j,'3) =',dyyzz(j,3),
     +			xmax
		if ( lwarn .and. absc(dyyzz(j,3)).lt.xloss*xmax ) then
		    call ffwarn(147,ieri(9+j),absc(dyyzz(j,3)),xmax)
		endif
	    endif
*
*	    bookkeeping
*
   24	    continue
	    ifirst = ifirst - 1
   26	    continue
*  #]       vertices (3):
	endif
	ier = ier + max(ieri(1),ieri(2),ieri(3),ieri(4),ieri(5),ieri(6),
     +							ieri(7),ieri(8))
*  #]   get differences:
*  #[   check differences:
	if ( ltest ) then
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    do 30 i=1,3
		if ( isoort(2*i-1) .ne. isoort(2*i+7) ) goto 30
		do 29 j=1,2
		    xhck = dyzzy(j,i) - y(2,4,i)*z(j,3,i)
     +				      + z(j,4,i)*y(2,3,i)
		    if ( rloss*absc(xhck) .gt. precc*max(abs(y(2,4,i)*
     +			z(j,3,i)),abs(z(j,4,i)*y(2,3,i))) ) print *,
     +			'ffdcc0: error: ','dyzzy(',j,i,') <> terms, ',
     +			dyzzy(j,i),y(2,4,i)*z(j,3,i),z(j,4,i)*y(2,3,i),
     +			xhck
		    xhck = dyzzy(j+2,i) - y(4,4,i)*z(j+2,3,i)
     +				       + z(j+2,4,i)*y(4,3,i)
		    if ( rloss*absc(xhck) .gt. precc*max(abs(y(4,4,i)*
     +			z(j+2,3,i)),abs(z(j+2,4,i)*y(4,3,i))) ) print*,
     +			'ffdcc0: error: ','dyzzy(',j+2,i,') <> terms, ',
     +			dyzzy(j+2,i),y(4,4,i)*z(j+2,3,i),z(j+2,4,i)*
     +			y(4,3,i),xhck
   29		continue
   30	    continue
	endif
*  #]   check differences:
*  #[   write output:
	if ( lwrite ) then
	    print *,'ffdcc0: found roots:'
	    do 86 k=3,4
	    do 85 i=1,3
		print *,'  k = ',i
		if ( isoort(2*i+8*(k-3)) .ne. 0 ) then
		    print *,'  ym,ym1 = ',y(1,k,i),y(3,k,i),
     +			' (not used)'
		    print *,'  yp,yp1 = ',y(2,k,i),y(4,k,i)
		    print *,'  zm,zm1 = ',z(1,k,i),z(3,k,i)
		    print *,'  zp,zp1 = ',z(2,k,i),z(4,k,i)
		elseif ( isoort(2*i+8*(k-3)) .eq. 0 ) then
		    if ( isoort(2*i-1+8*(k-3)) .eq. 0 ) then
			print *,'  no roots, all is zero'
		    else
			print *,'  yp,yp1 = ',y(2,k,i),y(4,k,i)
			print *,'  zp,zp1 = ',z(2,k,i),z(4,k,i)
		    endif
		endif
   85	    continue
   86	    continue
	endif
	if ( lwrite ) print '(a)','  ##] get roots:'
*  #]   write output:
*  #[ logarithms for 4point function:
	if ( npoin .eq. 4 ) then
	if ( lwrite ) print '(a)','  ##[ logarithms for Ai<0:'
	do 96 k = 3,4
	do 95 i = 1,3
	    ii = i+3*(k-3)
	    if ( ilogi(ii) .ne. -999 ) goto 95
	    if ( isoort(2*i+8*(k-3)) .ne. 0 ) then
*		maybe add sophisticated factors i*pi later
		c = -dyz(2,1,i,k)/dyz(2,2,i,k)
		cc = c-1
		if ( absc(cc) .lt. xloss ) then
		    s(1) = d2yzz(i,k)/dyz(2,2,i,k)
		    clogi(ii) = zfflo1(s(1),ier)
		    ilogi(ii) = 0
		    if ( lwrite ) then
			print *,'c = ',c
			print *,'c+= ',1-s(1)
		    endif
		elseif ( DBLE(c) .gt. 0 ) then
		    clogi(ii) = zfflog(c,0,c0,ier)
		    ilogi(ii) = 0
		else
		    cc = c+1
		    if ( absc(cc) .lt. xloss ) then
			s(1) = -2*sdel2i(i,k)/dyz(2,2,i,k)/
     +				DBLE(xpi(i+3,k))
			clogi(ii) = zfflo1(s(1),ier)
			if ( lwrite ) then
			    print *,'c = ',c
			    print *,'c+= ',-1+s(1)
			endif
		    else
			s(1) = 0
			clogi(ii) = zfflog(-c,0,c0,ier)
		    endif
		    if ( DIMAG(c) .lt. -precc*absc(c) .or. DIMAG(s(1))
     +				.lt. -precc*absc(s(1)) ) then
			ilogi(ii) = -1
		    elseif ( DIMAG(c) .gt. precc*absc(c) .or.
     +				DIMAG(s(1)) .gt. precc*absc(s(1)) ) then
			ilogi(ii) = +1
		    elseif ( DBLE(dyz(2,2,i,k)) .eq. 0 ) then
			ilogi(ii) = -nint(sign(DBLE(x1),
     +						DBLE(xpi(i+3,k))))
			ier = ier + 50
			print *,'doubtful imaginary part ',ilogi(ii)
		    else
			call fferr(78,ier)
			print *,'c = ',c
		    endif
		endif
	    endif
   95	continue
   96	continue
	if ( lwrite ) print '(a)','  ##] logarithms for Ai<0:'
	endif
*  #] logarithms for 4point function:
*  #[ integrals:
	do 100 i=1,3
	    if ( lwrite ) print '(a,i1,a)','  ##[ dcs nr ',i,':'
	    j = 2*i-1
	    if ( isoort(j) .eq. 0 ) then
		if ( lwrite ) then
		    print *,'ffdcc0: xk=0, ma=mb/Si-0 -> S3 = 0'
		    print *,'isoort:',isoort(j),isoort(j+1)
		endif
		if ( isoort(j+8) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffdcc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j+8),isoort(j+9)
		    endif
		else
		    call ffcs3(cs3(20*i+61),ipi12(j+8),y(1,4,i),
     +			z(1,4,i),dyz(1,1,4,i),d2yzz(4,i),
     +			xpi(1,4),piDpj(1,1,4),i,6,isoort(j+8),ier)
		endif
	    elseif ( isoort(j+8) .eq. 0 ) then
		if ( lwrite ) then
		    print *,'ffdcc0: xk=0, ma=mb/Si-0 -> S3 = 0'
		    print *,'isoort:',isoort(j),isoort(j+1)
		endif
		call ffcs3(cs3(20*i-19),ipi12(j),y(1,3,i),
     +		    z(1,3,i),dyz(1,1,3,i),d2yzz(3,i),
     +		    xpi(1,3),piDpj(1,1,3),i,6,isoort(j),ier)
	    else
		call ffdcs(cs3(20*i-19),ipi12(j),y(1,3,i),z(1,3,i),
     +		    dyz(1,1,3,i),d2yzz(3,i),dyzzy(1,i),dyyzz(1,i),
     +		    xpi,piDpj,i,6,isoort(j),ier)
	    endif
	    if ( lwrite ) print '(a,i1,a)','  ##] dcs nr ',i,':'
  100	    continue
*  #] integrals:
*###] ffdcc0:
	end
*###[ ffdcxs:
	subroutine ffdcxs(cs3,ipi12,y,z,dyz,d2yzz,dy2z,dyzzy,xpi,piDpj,
     +						ii,ns,isoort,ier)
***#[*comment:***********************************************************
*									*
*	calculates the the difference of two S's with y(3,4),z(3,4) and *
*	y(4)z(3)-y(3)z(4) given.  Note the difference with ffdcxs4, in	*
*	which the y's are the same and only the z's different.  Here	*
*	both can be different.	Also we skip an intermediate level.	*
*	Note also that this routine is much less conservative than 	*
*	ffcxs3 in its expectations of the order of the roots: it knows	*
*	that it is (z-,z+,1-z-,1-z+)!					*
*									*
*	input:	y(4,3:4)	(real)	y,1-y in S with s3,s4		*
*		z(4,3:4)	(real)	z,1-z in S with s3,s4		*
*		dyz(2,2,3:4)	(real)	y - z				*
*		d2yzz(3:4)	(real)	2*y - z+ - z-			*
*		dy2z(4,3:4)	(real)	y - 2*z				*
*		dyzzy(4)	(real)	y(i,4)*z(i,4)-y(i,3)*z(i,4)	*
*		xpi(6,3:4)	(real)	usual				*
*		piDpj(6,3:4)	(real)	usual				*
*		cs3(40)	(complex)	assumed zero.			*
*									*
*	output: cs3(40)	(complex)	mod factors pi^2/12, in array	*
*		ipi12(6)(integer)	these factors			*
*		isoort(6)(integer)	returns kind of action taken	*
*		ier	(integer)	0=ok 1=inaccurate 2=error	*
*									*
*	calls:	ffcrr,ffcxr,real/dble,DCMPLX,log,ffadd1,ffadd2,ffadd3	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cs3(100)
	DOUBLE PRECISION y(4,3:4),z(4,3:4),dyz(2,2,3:4),d2yzz(3:4),
     +		dy2z(4,3:4),dyzzy(4),xpi(6,3:4),piDpj(6,6,3:4)
	integer ipi12(10),ii,ns,isoort(10),ier
*
*	local variables
*
	integer i,j,k,l,m,ier0,iepsi(4),ieps,ipi12p(4),ipitot,ipitop
	DOUBLE COMPLEX cs1,cs2,cs1p,cs2p,cs3p(40),c
	DOUBLE PRECISION yy,zz,yy1,zz1,dyyzz,hulp3,hulp4,absc,xhck,xmax,
     +		rloss,xm1,xm2,xm1p,xm2p,x00(3)
	save iepsi
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data iepsi /-2,+2,+2,-2/
*
*	statement function
*
	absc(c) = abs(DBLE(c)) +abs(DIMAG(c))
*
*	check constants
	if ( ltest .and. ns .ne. 6 ) print *,'ffdcxs: error: ns <> 6'
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    if ( lwrite ) print *,'rloss = ',rloss
	    do 2 k=3,4
	    	do 1 i=1,2
	    	    xhck = y(i,k) + y(i+2,k) - 1
	    	    xmax = max(abs(y(i,k)),x1)
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: 1 - y(',i,k,') <> 1-y(',i,k,'): ', 
     +	    	    	y(i,k),y(i+2,k),xhck
	    	    xhck = z(i,k) + z(i+2,k) - 1
	    	    xmax = max(abs(z(i,k)),x1)
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: 1 - z(',i,k,') <> 1-z(',i,k,'): ', 
     +	    	    	z(i,k),z(i+2,k),xhck
	    	    xhck = dyz(2,i,k) - y(2,k) + z(i,k)
	    	    xmax = max(abs(y(2,k)),abs(z(i,k)))
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: dyz(2',i,k,')<>y(2',k,')-z(',i,k,'): ',
     +	    	    	dyz(2,i,k),y(2,k),z(i,k),xhck
	    	    xhck = dy2z(i,k) - y(2,k) + 2*z(i,k)
	    	    xmax = max(abs(y(2,k)),2*abs(z(i,k)))
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: dy2z(',i,k,')<>y(2',k,')-2*z(',i,k,
     +	    	    	'): ',dy2z(i,k),y(2,k),2*z(i,k),xhck
	    	    xhck = dy2z(i+2,k) - y(4,k) + 2*z(i+2,k)
	    	    xmax = max(abs(y(4,k)),2*abs(z(i+2,k)))
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: dy2z(',i+2,k,')<>y(4',k,')-2z(',i+2,k,
     +	    	    	'): ',dy2z(i+2,k),y(4,k),2*z(i+2,k),xhck
	    	    l = 2*k+i - 6
	    	    m = 2*(k/2)
	    	    xhck = dyzzy(l) - y(m,4)*z(m+i-2,3) + 
     +	    	    	y(m,3)*z(m+i-2,4)
	    	    xmax = max(abs(dyzzy(l)),abs(y(m,4)*z(m+i-2,3)))
	    	    if ( rloss*xhck .gt. precx*xmax ) print *,'ffdcxs:',
     +	    	    	' error: dyzzy(',l,') <> ...',dyzzy(l),
     +	    	    	y(m,4)*z(m+i-2,3),y(m,3)*z(m+i-2,4),xhck
    1	    	continue
    2	    continue
	endif
*  #] check input:
*  #[ normal case:
	if ( isoort(1) .ne. isoort(9) .or. isoort(1) .lt. 10 ) then
	    if ( lwrite ) print *,'ffdcxs: normal case'
	    call ffcxs3(cs3( 1),ipi12(1),y(1,3),z(1,3),dyz(1,1,3),
     +		d2yzz(3),dy2z(1,3),xpi(1,3),piDpj(1,1,3),ii,6,
     +		isoort(1),ier)
	    call ffcxs3(cs3(81),ipi12(9),y(1,4),z(1,4),dyz(1,1,4),
     +		d2yzz(4),dy2z(1,4),xpi(1,4),piDpj(1,1,4),ii,6,
     +		isoort(9),ier)
	    return
	endif
*  #] normal case:
*  #[ rotate R's:
	if ( abs(y(2,3)) .lt. 1/xloss ) then
	    if ( lwrite ) print *,'ffdcxs: rotated R''s'
*	    loop over y,z , 1-y,1-z
	    do 20 i=1,2
*	    loop over z+ , z-
	    do 10 j=1,2
		if ( j .eq. 2 ) then
*		    do not calculate if not there (isoort=0, one root)
*			(this is probably not needed as this case should
*			have been dealt with in ffdxc0)
		    if ( isoort(9) .eq. 0 ) goto 10
*		    or if not needed (isoort=2, two equal roots)
		    if ( mod(isoort(9),10) .eq. 2 ) then
			if ( lwrite ) print *,'ffdcxs: skipped next ',
     +				'R as it is equal'
*			we use that l still contains the correct value
			do 5 m=1,7
			    cs3(10*(l-1)+m) = 2*DBLE(cs3(10*(l-1)+m))
    5			continue
			ipi12(l) = 2*ipi12(l)
			goto 10
		    endif
		endif
		k = 2*(i-1)+j
		l = 8*(i-1)+j
		if ( dyzzy(k) .ne. 0 ) then
		    hulp3 = -dyz(2,j,3)/dyzzy(k)
		    hulp4 = dyz(2,j,4)/dyzzy(k)
		    yy = y(2*i,3)*hulp4
		    yy1 = y(2*i,4)*hulp3
		    zz = z(k,3)*hulp4
		    zz1 = z(k,4)*hulp3
		    dyyzz = dyz(2,j,3)*hulp4
		    if ( i .eq. 2 ) then
			yy = -yy
			yy1 = -yy1
			zz = -zz
			zz1 = -zz1
		    endif
*		    iepsi() = /-2,+2,+2,-2/
*		    BUT I AM NOT YET SURE OF THE SIGNS (29/6/89)
		    if ( y(2*i,3) .gt. 0 ) then
			ieps = iepsi(k)
		    else
			ieps = -iepsi(k)
		    endif
		    if ( y(2*i,3) .gt. 0 .neqv. y(2*i,4) .gt. 0 ) then
			ieps = 0
		    endif
*		    if ( ltest ) then
*			if ( rloss*abs(yy+yy1-1) .gt. precx*max(abs(yy),
*     +				x1) ) print *,'ffdcxs: error: 1 - yy ',
*     +				'<> yy1',yy,yy1,yy+yy1-1
*			if ( rloss*abs(zz+zz1-1) .gt. precx*max(abs(zz),
*     +				x1) ) print *,'ffdcxs: error: 1 - zz ',
*     +				'<>zz1',zz,zz1,zz+zz1-1
*			if ( rloss*abs(dyyzz-yy+zz) .gt. precx*max(abs(
*     +				yy),abs(zz)) ) print *,'ffdcxs: error:',
*				' dyyzz<>yy-zz',dyyzz,yy,zz,dyyzz-yy+zz
*		    endif
		    call ffcxr(cs3(10*l-9),ipi12(l),yy,yy1,zz,zz1,dyyzz,
     +			.FALSE.,x0,x0,x0,.FALSE.,x00,ieps,ier)
		else
		    if ( lwrite ) print *,'  y(4)z(3)-y(3)z(4)=0 -> S=0'
		endif
   10	    continue
   20	    continue
	    goto 800
	endif
*  #] rotate R's:
*  #[ other cases (not ready):
	if ( lwrite ) print *,'ffdcxs: warning: special case not',
     +		' yet implemented, trying normal route'
	call ffcxs3(cs3( 1),ipi12(1),y(1,3),z(1,3),dyz(1,1,3),
     +		d2yzz(3),dy2z(1,3),xpi(1,3),piDpj(1,1,3),ii,ns,
     +		isoort(1),ier)
	call ffcxs3(cs3(81),ipi12(9),y(1,4),z(1,4),dyz(1,1,4),
     +		d2yzz(4),dy2z(1,4),xpi(1,4),piDpj(1,1,4),ii,ns,
     +		isoort(9),ier)
	return
*  #] other cases (not ready):
*  #[ debug:
  800	if ( lwrite ) then
	    ier0 = 0
	    do 805 i=1,40
		cs3p(i) = 0
  805	    continue
	    print '(a)','   #[ compare: '
	    call ffcxs3(cs3p( 1),ipi12p(1),y(1,3),z(1,3),dyz(1,1,3),
     +		d2yzz(3),dy2z(1,3),xpi(1,3),piDpj(1,1,3),ii,ns,
     +		isoort(1),ier0)
	    call ffcxs3(cs3p(21),ipi12p(3),y(1,4),z(1,4),dyz(1,1,4),
     +		d2yzz(4),dy2z(1,4),xpi(1,4),piDpj(1,1,4),ii,ns,
     +		isoort(9),ier0)
	    print '(a)','   #] compare: '
	    cs1 = 0
	    cs2 = 0
	    cs1p = 0
	    cs2p = 0
	    xm1 = 0
	    xm2 = 0
	    xm1p = 0
	    xm2p = 0
	    do 810 i=1,20
		cs1 = cs1 + cs3(i)
		xm1 = max(xm1,absc(cs1))
		cs2 = cs2 + cs3(i+80)
		xm2 = max(xm2,absc(cs2))
		cs1p = cs1p + cs3p(i)
		xm1p = max(xm1p,absc(cs1p))
		cs2p = cs2p + cs3p(i+20)
		xm2p = max(xm2p,absc(cs2p))
  810	    continue
	    ipitot = ipi12(1) + ipi12(2) - ipi12(9) - ipi12(10)
	    ipitop = ipi12p(1) + ipi12p(2) - ipi12p(3) - ipi12p(4)
 1000	    format(2g24.16,g12.4)
	    print *,'ffdcxs: compare:'
	    print *,'    Originally:'
	    print 1000,cs1p,xm1p
	    print 1000,-cs2p,xm2p
	    if ( ipitot .ne. 0 ) print 1000,ipitot*pi12,0.
	    print *,'+ ------------'
	    print 1000,cs1p-cs2p+ipitot*DBLE(pi12),max(xm1p,xm2p)
	    print *,'    Now:'
	    print 1000,cs1,xm1
	    print 1000,-cs2,xm2
	    if ( ipitop .ne. 0 ) print 1000,ipitop*pi12,0.
	    print *,'+ ------------'
	    print 1000,cs1-cs2+ipitop*DBLE(pi12),max(xm1,xm2)
	endif
*  #] debug:
*###] ffdcxs:
	end
*###[ ffdcs:
	subroutine ffdcs(cs3,ipi12,cy,cz,cdyz,cd2yzz,cdyzzy,cdyyzz,
     +		cpi,cpiDpj,ii,ns,isoort,ier)
***#[*comment:***********************************************************
*									*
*	calculates the the difference of two S's with cy(3,4),cz(3,4),	*
*	cy(4)cz(3)-cy(3)cz(4) given.  Note the difference with ffdcs4,	*
*	in which the cy's are the same and only the cz's different.	*
*	Here both can be different.	Also we skip an intermediat	*
*	level.								*
*									*
*	input:	cy(4,3:4)    (complex)	cy,1-cy in S with s3,s4		*
*		cz(4,3:4)    (complex)	cz,1-cz in S with s3,s4		*
*		cdyz(2,2,3:4)(complex)	cy - cz				*
*		cd2yzz(3:4)  (complex)	2*cy - cz+ - cz-		*
*		cdyzzy(4)    (complex)	cy(i,4)*cz(i,4)-cy(i,3)*cz(i,4)	*
*		cdyyzz(2)    (complex)	cy(i,4)-cz(i,4)-cy(i,3)+cz(i,4)	*
*		cpi(6,3:4)   (complex)	usual				*
*		cpiDpj(6,3:4)(complex)	usual				*
*		cs3(40)	     (complex)	assumed zero.			*
*									*
*	output: cs3(40)	     (complex)	mod factors pi^2/12, in array	*
*		ipi12(6)     (integer)	these factors			*
*		isoort(6)    (integer)	returns kind of action taken	*
*		ier	     (integer)	number of digits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cs3(100)
	DOUBLE COMPLEX cy(4,3:4),cz(4,3:4),cdyz(2,2,3:4),cd2yzz(3:4),
     +		cdyzzy(4),cdyyzz(2),cpi(6,3:4),cpiDpj(6,6,3:4)
	integer ipi12(10),ii,ns,isoort(10),ier
*
*	local variables
*
	integer i,j,k,l,m,n,ier0,ieps,ni(4,3:4),ntot(3:4),
     +		n1a,n1b,ii1,nffeta,nffet1,i2pi,n2a,ip,ipi12p(4),ipitot,
     +		ipitop
	DOUBLE COMPLEX cs1,cs2,cs1p,cs2p,cs3p(40),c,cc,clogy,zfflog,
     +		zfflo1,cmip,yy,zz,yy1,zz1,dyyzz,hulp3,hulp4,xhck
	DOUBLE PRECISION rloss,xm1,xm2,xm1p,xm2p,absc,xmax,s1,s2,s3,s4,
     +		y1m,y1m1,y1p,y1p1
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) +abs(DIMAG(c))
*
*	check constants
	if ( ltest .and. ns .ne. 6 ) print *,'ffdcs: error: ns <> 6'
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    rloss = xloss*DBLE(10)**(-mod(ier,50)-2)
	    if ( lwrite ) print *,'rloss = ',rloss
	    do 20 k=3,4
		do 10 i=1,2
		    xhck = cy(i,k) + cy(i+2,k) - 1
		    xmax = max(absc(cy(i,k)),x1)
		    if ( rloss*absc(xhck) .gt. precc*xmax )
     +			print *,'ffdcs: error: 1 - cy(',i,k,') <> 1-cy('
     +			,i,k,'): ',cy(i,k),cy(i+2,k),xhck
		    xhck = cz(i,k) + cz(i+2,k) - 1
		    xmax = max(absc(cz(i,k)),x1)
		    if ( rloss*absc(xhck) .gt. precc*xmax )
     +			print *,'ffdcs: error: 1 - cz(',i,k,') <> 1-cz('
     +			,i,k,'): ',cz(i,k),cz(i+2,k),xhck
		    xhck = cdyz(2,i,k) - cy(2,k) + cz(i,k)
		    xmax = max(absc(cy(2,k)),absc(cz(i,k)))
		    if ( rloss*absc(xhck) .gt. precc*xmax )
     +			print *,'ffdcs: error: cdyz(2',i,k,')<>cy(2',k,
     +			')-cz(',i,k,'): ',cdyz(2,i,k),cy(2,k),cz(i,k),
     +			xhck
		    l = 2*k+i - 6
		    m = 2*(k/2)
		    xhck = cdyzzy(l) - cy(m,4)*cz(m+i-2,3) +
     +			cy(m,3)*cz(m+i-2,4)
		    xmax =max(absc(cdyzzy(l)),absc(cy(m,4)*cz(m+i-2,3)))
		    if ( rloss*absc(xhck) .gt. precc*xmax )
     +			print *,'ffdcs: error: cdyzzy(',l,') <> ...',
     +			cdyzzy(l),cy(m,4)*cz(m+i-2,3),cy(m,3)*cz(m+i-2,4
     +			),xhck
   10		continue
   20	    continue
	endif
*  #] check input:
*  #[ normal case:
	if ( mod(isoort(1),5).ne.mod(isoort(9),5) .or. isoort(1).gt.-5
     +								) then
	    if ( lwrite ) print *,'ffdcs: normal case'
	    if ( ltest .and. isoort(1) .le. -100 ) then
	    	print *,'ffdcs: error: wrong value for isoort'
	    endif
	    call ffcs3(cs3( 1),ipi12(1),cy(1,3),cz(1,3),cdyz(1,1,3),
     +		cd2yzz(3),cpi(1,3),cpiDpj(1,1,3),ii,6,isoort(1),ier)
	    call ffcs3(cs3(81),ipi12(9),cy(1,4),cz(1,4),cdyz(1,1,4),
     +		cd2yzz(4),cpi(1,4),cpiDpj(1,1,4),ii,6,isoort(9),ier)
	    return
	endif
*  #] normal case:
*  #[ rotate R's:
	if ( absc(cy(2,3)) .lt. 1/xloss .or. isoort(1) .le. -100 ) then
	    if ( lwrite ) print *,'ffdcs: rotated R''s'
*
*	    loop over cy,cz , 1-cy,1-cz
	    do 190 i=1,2

	    if ( isoort(1).le.-100 .and. i.eq.2 ) then
*
*		special case del2s=0, a limit has been taken
*
		if ( ii .eq. 2  ) then
*
*		    we took the wrong sign for the dilogs...
*
		    do 110 j=1,20
			cs3(j) = -cs3(j)
  110		    continue
		    ipi12(1) = -ipi12(1)
		    ipi12(2) = -ipi12(2)
		endif
*
*		now the remaining logs.  take care to get the ieps 
*		correct!
*
		if ( i.eq.1 .eqv. DBLE(cy(2*i,3)).gt.0 ) then
		    ieps = -3
		else
		    ieps = +3
		endif
		call ffclg2(cs3(81),ipi12(9),cy(2,3),cz(1,3),
     +			cdyz(2,1,3),cy(2,4),cz(1,4),cdyz(2,1,4),
     +			cdyyzz(1),isoort(1),isoort(9),ii,ieps,ier)
		if ( ii .eq. 2 ) then
*		    we have the wrong sign
		    do 120 j=81,83
		    	cs3(j) = -cs3(j)
  120		    continue
		    ipi12(9) = -ipi12(9)
		endif
		if ( mod(isoort(1),5).eq.0 .and. mod(isoort(9),5).eq.0
     +								) then 
		    if ( lwrite ) print *,'ffdcs: skipped other logs ',
     +			'as they are the complex conjugate'
		    do 130 j=81,83
			cs3(j) = 2*DBLE(cs3(j))
  130		    continue
		    ipi12(9) = 2*ipi12(9)
		else
		    print *,'ffdcs: error: not yet tested'
		    call ffclg2(cs3(91),ipi12(10),cy(2,3),cz(2,3),
     +		    	cdyz(2,2,3),cy(2,4),cz(2,4),cdyz(2,2,4),
     +		    	cdyyzz(2),isoort(1),isoort(9),ii,-ieps,ier)
		    if ( ii .eq. 2 ) then
*		    	we have the wrong sign
		    	do 140 j=91,93
		    	    cs3(j) = -cs3(j)
  140		    	continue
		    	ipi12(10) = -ipi12(10)
		    endif
		endif
		goto 190
	    endif
*
*	    loop over cz- , cz+
	    do 180 j=1,2
		if ( j .eq. 2 ) then
		    if ( isoort(9) .eq. 0 .or. isoort(1) .eq. 0 ) then
*
*			(this is not correct as this case should
*			have been dealt with in ffdxc0,ffdcc0)
*
			call fferr(79,ier)
			goto 180
		    elseif ( mod(isoort(9),5) .eq. 0 .and. 
     +		    	     mod(isoort(1),5) .eq. 0 ) then
*
*			or if not needed (isoort=-10, two conjugate roots)
*
			if ( lwrite ) print *,'ffdcs: skipped next ',
     +				'R as it is the conjugate'
*			we use that l still contains the correct value
			do 150 m=1,9
			    cs3(10*(l-1)+m) = 2*DBLE(cs3(10*(l-1)+m))
  150			continue
			ipi12(l) = 2*ipi12(l)
			goto 180
		    elseif ( mod(isoort(9),10) .eq. 2 ) then
			if ( lwrite ) print *,'ffdcs: skipped next ',
     +				'R as it is equal'
*			we use that l still contains the correct value
			do 160 m=1,9
			    cs3(10*(l-1)+m) = 2*cs3(10*(l-1)+m)
  160			continue
			ipi12(l) = 2*ipi12(l)
			goto 180
		    endif
		endif
		k = 2*(i-1)+j
		l = 8*(i-1)+j
		if ( cdyzzy(k) .ne. 0 ) then
		    hulp3 = -cdyz(2,j,3)/cdyzzy(k)
		    hulp4 = cdyz(2,j,4)/cdyzzy(k)
		    yy = cy(2*i,3)*hulp4
		    yy1 = cy(2*i,4)*hulp3
		    zz = cz(k,3)*hulp4
		    zz1 = cz(k,4)*hulp3
		    dyyzz = cdyz(2,j,3)*hulp4
		    if ( i .eq. 2 ) then
			yy = -yy
			yy1 = -yy1
			zz = -zz
			zz1 = -zz1
		    endif
*
*		    ieps = 3 means: dear ffcrr, do not use eta terms,
*		    they are calculated here.  The sign gives the sign
*		    of the imag. part of the argument of the dilog, not 
*		    y-z.
*
		    if ( i.eq.1 .eqv. j.eq.1 .eqv. DBLE(cy(2*i,3)).gt.0 
     +		    						) then
		    	ieps = -3
		    else
		    	ieps = +3
		    endif
		    call ffcrr(cs3(10*l-9),ipi12(l),yy,yy1,zz,zz1,dyyzz,
     +			.FALSE.,c0,c0,c0,isoort(j),ieps,ier)
*
*		    eta terms of the R's (eta(.)*log(c1)-eta(.)*log(c2))
*
		    do 170 m=3,4
*		    	no eta terms in the real case
		    	if ( DIMAG(cz(k,m)) .eq. 0 .and. 
     +		    	     DIMAG(cdyz(2,j,m)) .eq. 0 ) goto 170
		    	if ( i .eq. 1 ) then
			    ni(k,m) = nffeta(-cz(k,m),1/cdyz(2,j,m),ier)
		    	else
			    ni(k,m) = nffeta(cz(k,m),1/cdyz(2,j,m),ier)
		    	endif
  170		    continue
		    if ( ni(k,3) .ne. 0 .or. ni(k,4) .ne. 0 ) then
			if ( lwrite ) print *,'n3,n4: ',ni(k,3),ni(k,4)
			if ( ni(k,3) .ne. ni(k,4) ) then
			    do 175 m=3,4
				c = cy(2*i,m)/cdyz(2,j,m)
				if ( i .eq. 2 ) c = -c
				cc = c-1
				if ( absc(cc) .lt. xloss ) then
				    if ( lwrite ) print *,'c = ',c
				    c = cz(k,m)/cdyz(2,j,m)
				    if ( lwrite ) print *,'c+= ',1-c
				    clogy = zfflo1(c,ier)
				else
				    clogy = zfflog(c,0,c0,ier)
				endif
				n = 10*l + (m-3) - 2
				if ( ltest .and. cs3(n) .ne. 0 ) then
				    print *,'ffdcs: error: cs3(',n,
     +				    	') != 0'
				endif
				if ( m .eq. 3 ) then
				   cs3(n) = + ni(k,m)*c2ipi*clogy
				else
				   cs3(n) = - ni(k,m)*c2ipi*clogy
				endif
				if ( lwrite ) then
				print *,'eta',n,'= ',ni(k,m)*c2ipi*clogy
				if ( m .eq. 4 ) print *,'som = ',cs3(n)
     +							+ cs3(n-1)
				endif
 175			    continue
			else
			    if ( i .eq. 1 ) then
				n1a = nffeta(cy(k,3)/cdyz(2,j,3),
     +					cdyz(2,j,4)/cy(k,4),ier)
			    else
				n1a = nffeta(-cy(k,3)/cdyz(2,j,3),
     +					-cdyz(2,j,4)/cy(k,4),ier)
			    endif
			    if ( n1a .ne. 0 ) then
			    	call fferr(80,ier)
			    endif
			    c =cy(k,3)*cdyz(2,j,4)/(cdyz(2,j,3)*cy(k,4))
			    cc = c-1
			    if ( absc(cc) .lt. xloss ) then
				if ( lwrite ) print *,'1-c = ',1-c
				c = -cdyzzy(k)/(cdyz(2,j,3)*cy(k,4))
				if ( lwrite ) print *,'1-c+= ',c
				clogy = zfflo1(c,ier)
			    else
				clogy = zfflog(c,0,c0,ier)
			    endif
			    n = 10*l - 2
			    if ( ltest .and. cs3(n) .ne. 0 ) then
				print *,'ffdcs: error: cs3(',n,') not 0'
			    endif
			    if ( i .eq. 1 ) then
				cs3(n) = +ni(k,3)*c2ipi*clogy
			    else
				cs3(n) = -ni(k,3)*c2ipi*clogy
			    endif
			    if ( lwrite ) print *,'both etas ',cs3(n)
			endif
		    endif
		else
		    if ( lwrite ) print *,'  cy(4)cz(3)-cy(3)cz(4)=0',
     +			' -> S=0'
		endif
  180	    continue
  190	    continue
	    goto 700
	endif
*  #] rotate R's:
*  #[ other cases (not ready):
	if ( lwrite ) print *,'ffdcs: warning: special case not',
     +		' yet implemented, trying normal route'
	call ffcs3(cs3( 1),ipi12(1),cy(1,3),cz(1,3),cdyz(1,1,3),
     +		cd2yzz(3),cpi(1,3),cpiDpj(1,1,3),ii,ns,isoort(1),ier)
	call ffcs3(cs3(81),ipi12(9),cy(1,4),cz(1,4),cdyz(1,1,4),
     +		cd2yzz(4),cpi(1,4),cpiDpj(1,1,4),ii,ns,isoort(9),ier)
	return
*  #] other cases (not ready):
*  #[ get eta's:
  700	continue
	ip = ii+3
	do 740 k=3,4
	l = 8*(k-3) + 1
	if ( DIMAG(cpi(ip,k)) .eq. 0 ) then
*
*	complex because of a complex root in y or z
*
	if ( (mod(isoort(l),10).eq.-1 .or. mod(isoort(l),10).eq.-3) 
     +		.and. isoort(l+1) .ne. 0 ) then
*
*	    isoort = -1:    y is complex, possibly z as well
*	    isoort = -3:    y,z complex, but (y-z-)(y-z+) real
*	    isoort = 0:     y is complex, one z root only
*	    isoort = -10:   y is real, z is complex
*	    isoort = -5,-6: y,z both real
*
	    cmip = DCMPLX(DBLE(x0),-DBLE(cpi(ip,k)))
	    if ( DIMAG(cz(1,k)) .eq. 0 ) then
		ni(1,k) = 0
	    else
		ni(1,k) = nffet1(-cz(1,k),-cz(2,k),cmip,ier)
		i = nffet1(cz(3,k),cz(4,k),cmip,ier)
		if ( i .ne. ni(1,k) ) call fferr(53,ier)
	    endif
	    ni(2,k) = 0
	    if ( DBLE(cd2yzz(k)).eq.0 .and. ( DIMAG(cz(1,k)).eq.0 .and.
     +		 DIMAG(cz(2,k)).eq.0 .or. DBLE(cdyz(2,1,k)).eq.0 .and.
     +		 DBLE(cdyz(2,2,k)) .eq. 0 ) ) then
*		follow the i*epsilon prescription as (y-z-)(y-z+) real
		if ( DBLE(cpi(ip,k)) .lt. 0 ) then
		    ni(3,k) = -1
		else
		    ni(3,k) = 0
		endif
		ni(4,k) = -nffet1(cdyz(2,1,k),cdyz(2,2,k),cmip,ier)
	    else
		if ( DBLE(cpi(ip,k)) .lt. 0 .and. DIMAG(cdyz(2,1,k)*
     +			cdyz(2,2,k)) .lt. 0 ) then
		    ni(3,k) = -1
		else
		    ni(3,k) = 0
		endif
		ni(4,k) = -nffeta(cdyz(2,1,k),cdyz(2,2,k),ier)
	    endif
	elseif ( (mod(isoort(l),10).eq.-1 .or. mod(isoort(l),10).eq.-3) 
     +		.and. isoort(l+1).eq.0 ) then
	    ni(1,k) = 0
	    if ( DIMAG(cz(1,k)) .ne. 0 ) then
		ni(2,k) = nffet1(-cpiDpj(ii,ip,k),-cz(1,k),DCMPLX(DBLE(0
     +			),DBLE(-1)),ier)
	    else
		ni(2,k) = nffet1(-cpiDpj(ii,ip,k),DCMPLX(DBLE(0),
     +			DBLE(1)),DCMPLX(DBLE(0),DBLE(-1)),ier)
	    endif
	    ni(3,k) = 0
	    ni(4,k) = -nffeta(-cpiDpj(ii,ip,k),cdyz(2,1,k),ier)
	else
	    if ( mod(isoort(l),5).ne.0 .and. mod(isoort(l),5).ne.-1 
     +	    		.and. mod(isoort(l),5).ne.-3 ) then
	    	call fferr(81,ier)
		print *,'isoort(',l,') = ',isoort(l)
	    endif
	    ni(1,k) = 0
	    ni(2,k) = 0
	    ni(3,k) = 0
	    ni(4,k) = 0
	endif
	else
	    print *,'ffdcs: error: cpi complex should not occur'
	    stop
	endif
  740	continue
	if ( lwrite ) then
	    print *,'ffdcs: eta''s are: '
	    print *,'s3: ',(ni(i,3),i=1,4)
	    print *,'s4: ',(ni(i,4),i=1,4)
	endif
*  #] get eta's:
*  #[ add eta's:
	do 750 k=3,4
	    ntot(k) = ni(1,k)+ni(2,k)+ni(3,k)+ni(4,k)
  750	continue
	if ( ntot(3) .ne. 0 .and. ntot(3) .eq. ntot(4) ) then
	    if ( lwrite ) print *,'ffdcs: warning: could be smarter...'
	endif
	do 760 k=3,4
	    if ( ntot(k) .ne. 0 ) call ffclgy(cs3(20+80*(k-3)),
     +	    	ipi12(2+8*(k-3)),ni(1,k),cy(1,k),cz(1,k),cd2yzz(k),ier)
  760	continue
*  #] add eta's:
*  #[ debug:
  800	if ( lwrite ) then
	    ier0 = 0
	    do 805 i=1,40
		cs3p(i) = 0
  805	    continue
	    do 806 i=1,4
		ipi12p(i) = 0
  806		continue
	    if ( isoort(1) .gt. -100 ) then
		print '(a)','   #[ compare: '
		call ffcs3(cs3p( 1),ipi12p(1),cy(1,3),cz(1,3),cdyz(1,1,3
     +			),cd2yzz(3),cpi(1,3),cpiDpj(1,1,3),ii,ns,
     +			isoort(1),ier0)
		call ffcs3(cs3p(21),ipi12p(3),cy(1,4),cz(1,4),cdyz(1,1,4
     +			),cd2yzz(4),cpi(1,4),cpiDpj(1,1,4),ii,ns,
     +			isoort(9),ier0)
		print '(a)','   #] compare: '
	    endif
	    cs1 = 0
	    cs2 = 0
	    cs1p = 0
	    cs2p = 0
	    xm1 = 0
	    xm2 = 0
	    xm1p = 0
	    xm2p = 0
	    do 810 i=1,20
		cs1 = cs1 + cs3(i)
		xm1 = max(xm1,absc(cs1))
		cs2 = cs2 + cs3(i+80)
		xm2 = max(xm2,absc(cs2))
		cs1p = cs1p + cs3p(i)
		xm1p = max(xm1p,absc(cs1p))
		cs2p = cs2p + cs3p(i+20)
		xm2p = max(xm2p,absc(cs2p))
  810	    continue
	    ipitot = ipi12(1) + ipi12(2) - ipi12(9) - ipi12(10)
	    ipitop = ipi12p(1) + ipi12p(2) - ipi12p(3) - ipi12p(4)
 1000	    format(2g24.16,g12.4)
	    print *,'ffdcs: compare:'
	    print *,'    Originally:'
	    print 1000,cs1p,xm1p
	    print 1000,-cs2p,xm2p
	    if ( ipitop .ne. 0 ) print 1000,ipitop*DBLE(pi12),0.
	    print *,'+ ------------'
	    print 1000,cs1p-cs2p+ipitop*DBLE(pi12),max(xm1p,xm2p)
	    print *,'    Now:'
	    print 1000,cs1,xm1
	    print 1000,-cs2,xm2
	    if ( ipitot .ne. 0 ) print 1000,ipitot*pi12,0.
	    print *,'+ ------------'
	    print 1000,cs1-cs2+ipitot*DBLE(pi12),max(xm1,xm2)
	endif
*  #] debug:
*###] ffdcs:
	end
*###[ ffclg2:
	subroutine ffclg2(cs3,ipi12,cy3,cz3,cdyz3,cy4,cz4,cdyz4,cdyyzz,
     +		isort3,isort4,ii,ieps,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the finite part of the divergent dilogs in case	*
*	del2s=0.  These are given by					*
*									*
*		log^2(-cdyz3)/2 - log^2(-cdyz4)/2			*
*									*
*	Note that often we only need the imaginary part, which may be	*
*	very unstable even if the total is not.				*
*									*
*									*
*	Input:	cy3,cz3,cdyz3	(complex)	y,z,diff in C with s3	*
*		cy4,cz4,cdyz4	(complex)	y,z,diff in C with s4	*
*		cdyyzz		(complex)	y4 - z4 - y3 + z3	*
*		isort3,4	(integer)				*
*									*
*	Output	cs3(4)		(complex)	output			*
*		ipi12		(integer)	terms pi^2/12		*
*		ier		(integer)	error flag		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cs3(3),cy3(3),cz3(3),cdyz3,cy4(3),cz4(3),cdyz4,
     +		cdyyzz
	integer ipi12,ieps,ier,isort3,isort4,ii
*
*	local variables
*
	integer n1,nffeta,nffet1,ipi3,ipi4
	DOUBLE COMPLEX c,cc,chck,clog3,clog4,clog1,zfflo1,cipi
	DOUBLE PRECISION absc,rloss
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    if ( abs(ieps) .ne. 3 ) print *,'ffclg2: error: |ieps| <> 3'
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    if ( cs3(1) .ne. c0 .or. cs3(2) .ne. c0 .or. cs3(3) .ne. c0)
     +	    	print *,'ffclg2: error: cs3 <> 0',cs3
	    chck = cz3(1) + cz3(3) - 1
	    if ( rloss*absc(chck) .gt. precc*max(x1,absc(cz3(1))) ) 
     +	    	print *,'ffclg2: error: 1 - cz3 <> (1-cz3)',cz3(1),cz3(3
     +	    	),chck
	    chck = cz4(1) + cz4(3) - 1
	    if ( rloss*absc(chck) .gt. precc*max(x1,absc(cz4(1))) ) 
     +	    	print *,'ffclg2: error: 1 - cz4 <> (1-cz4)',cz4(1),cz4(3
     +	    	),chck
	    chck = cdyz3 - cy3(1) + cz3(1)
	    if ( rloss*absc(chck) .gt. precc*max(absc(cdyz3),absc(cz3(1)
     +	    	)) ) print *,'ffclg2: error: cdyz3 <> cy3-cz3',
     +	    	cdyz3,cy3(1),cz3(1),chck
	    chck = cdyz4 - cy4(1) + cz4(1)
	    if ( rloss*absc(chck) .gt. precc*max(absc(cdyz4),absc(cz4(1)
     +	    	)) ) print *,'ffclg2: error: cdyz4 <> cy4-cz4',
     +	    	cdyz4,cy4(1),cz4(1),chck
	    chck = cdyyzz - cy4(1) + cz4(1) + cy3(1) - cz3(1)
	    if ( rloss*absc(chck) .gt. precc*max(absc(cy4(1)),absc(cz4(1
     +	    	)),absc(cy3(1))) ) print *,'ffclg2: error: cdyyzz <> ',
     +	    	'terms',cdyyzz,cy4(1),cz4(1),cy3(1),cz3(1),chck
	endif
*  #] check input:
*  #[ calculations:
	cipi = DCMPLX(DBLE(x0),DBLE(pi))
	if ( DBLE(cdyz3) .lt. 0 ) then
	    clog3 = log(-cdyz3)
	    ipi3 = 0
	else
	    clog3 = log(cdyz3)
	    if ( DIMAG(cdyz3) .gt. 0 ) then
	    	ipi3 = -1
	    elseif ( DIMAG(cdyz3) .lt. 0 ) then
	    	ipi3 = +1
	    else
	    	ipi3 = sign(1,-ieps)
	    endif
	endif
	if ( DBLE(cdyz4) .lt. 0 ) then
	    clog4 = log(-cdyz4)
	    ipi4 = 0
	else
	    clog4 = log(cdyz4)
	    if ( DIMAG(cdyz4) .gt. 0 ) then
	    	ipi4 = -1
	    elseif ( DIMAG(cdyz4) .lt. 0 ) then
	    	ipi4 = +1
	    else
	    	ipi4 = sign(1,-ieps)
	    endif
	endif
	cc = clog3-clog4
	if ( absc(cc) .ge. xloss*absc(clog3) ) then
	    cs3(1) = -(clog3+ipi3*cipi)**2/2
	    cs3(2) = +(clog4+ipi4*cipi)**2/2
	    if ( lwrite ) clog1 = -123
	else
	    c = cdyyzz/cdyz4
	    clog1 = zfflo1(c,ier)
*
*	    notice that zfflog return log(a-ieps) (for compatibility
*	    with the dilog)		   ^
*
	    if ( DIMAG(cdyz3) .eq. 0 ) then
		n1 = nffet1(DCMPLX(DBLE(0),DBLE(-ieps)),-1/cdyz4,-c,
     +			ier)
	    elseif ( DIMAG(cdyz3) .eq. 0 ) then
		n1 = nffet1(-cdyz3,DCMPLX(DBLE(0),DBLE(ieps)),-c,ier)
	    else
		n1 = nffeta(-cdyz3,-1/cdyz4,ier)
	    endif
	    if ( n1 .ne. 0 ) then
		clog1 = clog1 - n1*c2ipi
	    endif
	    cs3(1) = -clog3*clog1/2
	    cs3(2) = -clog4*clog1/2
	    cs3(3) = -(ipi3+ipi4)*cipi*clog1/2
*	    we could split off a factor 2*pi^2 if needed
	endif
*	ATTENTION: now (23-jul-1989) ffdcs assumes that only *3* cs are
*	set. Change ffdcs as well if this is no longer true!
*  #] calculations:
*  #[ debug:
	if ( lwrite ) then
	    if ( clog1 .ne. -123 ) then
		print *,'ffclg2: originally:'
		print '(a,2g24.15)','S3: ',+(clog3+ipi3*cipi)**2/2
		print '(a,2g24.15)','S4: ',-(clog4+ipi4*cipi)**2/2
		print '(a,2g24.15,2i6)','sum:',+(clog3+ipi3*cipi)**2/2
     +			-(clog4+ipi4*cipi)**2/2
	    endif
	    print *,'ffclg2: now:'
	    print '(a,2g24.15)','S3: ',-cs3(1)
	    print '(a,2g24.15)','S4: ',-cs3(2)
	    print '(a,2g24.15)','Spi:',-cs3(3)
	    print '(a,2g24.15,2i6)','sum:',-cs3(1)-cs3(2)-cs3(3),-ipi12,
     +	    	ier
	endif
*  #] debug:
*###] ffclg2:
	end
*###[ ffdel2:
	subroutine ffdel2(del2,piDpj,ns,i1,i2,i3,lerr,ier)
*************************************************************************
*	calculate in a numerically stable way				*
*	del2(piDpj(i1,i1),piDpj(i2,i2),piDpj(i3,i3)) =			*
*		= piDpj(i1,i1)*piDpj(i2,i2) - piDpj(i1,i2)^2		*
*		= piDpj(i1,i1)*piDpj(i3,i3) - piDpj(i1,i3)^2		*
*		= piDpj(i2,i2)*piDpj(i3,i3) - piDpj(i2,i3)^2		*
*	ier is the usual error flag.					*
*************************************************************************
	implicit none
*
*	arguments:
*
	integer ns,i1,i2,i3,lerr,ier
	DOUBLE PRECISION del2,piDpj(ns,ns)
*
*	local variables
*
	DOUBLE PRECISION s1,s2
*
*	common blocks
*
	include 'ff.h'
*
*	calculations
*
	idsub = idsub + 1
	if ( abs(piDpj(i1,i2)) .lt. abs(piDpj(i1,i3)) .and.
     +	     abs(piDpj(i1,i2)) .lt. abs(piDpj(i2,i3)) ) then
	    s1 = piDpj(i1,i1)*piDpj(i2,i2)
	    s2 = piDpj(i1,i2)**2
	elseif ( abs(piDpj(i1,i3)) .lt. abs(piDpj(i2,i3)) ) then
	    s1 = piDpj(i1,i1)*piDpj(i3,i3)
	    s2 = piDpj(i1,i3)**2
	else
	    s1 = piDpj(i2,i2)*piDpj(i3,i3)
	    s2 = piDpj(i2,i3)**2
	endif
	del2 = s1 - s2
	if ( abs(del2) .lt. xloss*s2 ) then
	    if ( lerr .eq. 0 ) then
*		we know we have another chance
		if ( del2.ne.0 ) then
		    ier = ier + int(log10(xloss*abs(s2/del2)))
		else
		    ier = ier + int(log10(xloss*abs(s2)/xclogm))
		endif
	    else
		if ( lwarn ) call ffwarn(71,ier,del2,s1)
	    endif
	endif
*###] ffdel2:
	end
*###[ ffdl2p:
	subroutine ffdl2p(delps1,xpi,dpipj,piDpj,
     +		ip1,ip2,ip3,is1,is2,is3,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*	delta_{ip1,is2}^{ip1,ip2}					*
*	ier is the usual error flag.					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ip1,ip2,ip3,is1,is2,is3,ier
	DOUBLE PRECISION delps1,xpi(ns),dpipj(ns,ns),piDpj(ns,ns)
*
*	local variables
*
	DOUBLE PRECISION s1,s2,s3,xmax,som
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ stupid tree:
*	1
	s1 = xpi(ip1)*piDpj(ip2,is2)
	s2 = piDpj(ip1,ip2)*piDpj(ip1,is2)
	delps1 = s1 - s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( lwrite ) print *,'  delps1   = ',delps1,s1,s2
	som = delps1
	xmax = abs(s1)
*	2
	s1 = piDpj(ip1,ip2)*piDpj(ip3,is2)
	s2 = piDpj(ip1,ip3)*piDpj(ip2,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+1 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	3
	s1 = piDpj(ip1,ip3)*piDpj(ip1,is2)
	s2 = xpi(ip1)*piDpj(ip3,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+2 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	4
	s1 = xpi(ip1)*piDpj(ip2,is1)
	s2 = piDpj(ip1,is1)*piDpj(ip1,ip2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+3 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	5
	s1 = piDpj(ip1,is2)*piDpj(ip2,is1)
	s2 = piDpj(ip1,is1)*piDpj(ip2,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+4 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	6
	s1 = piDpj(ip1,ip2)*piDpj(ip3,is1)
	s2 = piDpj(ip1,ip3)*piDpj(ip2,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+5 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	7
	s1 = piDpj(ip2,is2)*piDpj(ip3,is1)
	s2 = piDpj(ip2,is1)*piDpj(ip3,is2)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+6 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	8
	s1 = piDpj(ip1,ip3)*piDpj(ip1,is1)
	s2 = xpi(ip1)*piDpj(ip3,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+7 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*	9
	s1 = piDpj(ip1,is1)*piDpj(ip3,is2)
	s2 = piDpj(ip1,is2)*piDpj(ip3,is1)
	delps1 = s1 - s2
	if ( lwrite ) print *,'  delps1+8 = ',delps1,s1,s2
	if ( abs(delps1) .ge. xloss*abs(s1) ) goto 100
	if ( abs(s1) .lt. xmax ) then
	    som = delps1
	    xmax = abs(s1)
	endif
*10	22-nov-1993 yet another one
	if ( dpipj(1,1).eq.0 ) then
	    s1 = +xpi(ip1)*dpipj(is3,is2)/2
	    s2 = -piDpj(ip1,ip2)*dpipj(is2,is1)/2
	    s3 = +xpi(ip1)*piDpj(ip2,ip3)/2
	    delps1 = s1+s2+s3
	    if ( lwrite ) print *,'  delps1+9 = ',delps1,s1,s2,s3
	    if ( abs(delps1) .ge. xloss*max(abs(s1),abs(s2)) ) goto 100
	    if ( max(abs(s1),abs(s2)) .lt. xmax ) then
		som = delps1
		xmax = abs(s1)
	    endif
	endif
*	NO possibility
	delps1 = som
	if ( lwarn ) call ffwarn(92,ier,delps1,xmax)
	if ( lwrite ) then
	    print *,'xpi = ',xpi
	    print *,'ip1,ip2,ip3,is1,is2,is3 = ',ip1,ip2,ip3,is1,is2,is3
	endif
  100	continue
*  #] stupid tree:
*###] ffdl2p:
	end
*###[ ffdl2s:
	subroutine ffdl2s(delps1,xpi,piDpj,in,jn,jin,isji,
     +					kn,ln,lkn,islk,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*		\delta_{si,sj}^{sk,sl}					*
*									*
*	with p(ji) = isji*(sj-si)					*
*	     p(lk) = islk*(sl-sk)					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer in,jn,jin,isji,kn,ln,lkn,islk,ns,ier
	DOUBLE PRECISION delps1,xpi(ns),piDpj(ns,ns)
*
*	local variables
*
	integer ii,jj,i,j,ji,k,l,lk,ihlp
	DOUBLE PRECISION s1,s2,som,smax
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    if ( abs(isji) .ne. 1 ) print *,'ffdl2s: error: abs(isji) ',
     +		' <> 1 but ',isji
	    if ( abs(islk) .ne. 1 ) print *,'ffdl2s: error: abs(islk) ',
     +		' <> 1 but ',islk
	endif
*  #] check input:
*  #[ stupid tree:
	idsub = idsub + 1
	som = 0
	smax = 0
	i = in
	j = jn
	ji = jin
	k = kn
	l = ln
	lk = lkn
	do 20 ii=1,3
	    do 10 jj=1,3
		s1 = piDpj(i,k)*piDpj(j,l)
		s2 = piDpj(i,l)*piDpj(j,k)
		delps1 = s1 - s2
		if ( ii .gt. 1 ) delps1 = isji*delps1
		if ( jj .gt. 1 ) delps1 = islk*delps1
		if ( ii .eq. 3 .neqv. jj .eq. 3 ) delps1 = -delps1
		if ( abs(delps1) .ge. xloss*abs(s1) ) goto 30

		if ( lwrite ) print *,'  delps1+',3*ii+jj-3,'=',delps1,
     +			abs(s1)
*
*		Save the most accurate estimate so far:
		if ( ii .eq. 1 .and. jj .eq. 1 .or. abs(s1) .lt. smax
     +			) then
		    som = delps1
		    smax = abs(s1)
		endif
*
*		rotate the jj's
		if ( lk .eq. 0 ) goto 20
		ihlp = k
		k = l
		l = lk
		lk = ihlp
   10	    continue
*
*	    and the ii's
	    if ( ji .eq. 0 ) goto 25
	    ihlp = i
	    i = j
	    j = ji
	    ji = ihlp
   20	continue
   25	continue
	delps1 = som
	if ( lwarn ) call ffwarn(83,ier,delps1,smax)
   30	continue
	if ( lwrite .and. 3*ii+jj.ne.4 ) print *,'  delps1+',3*ii+jj-3,
     +		'=', delps1,s1,s2
*  #] stupid tree:
*###] ffdl2s:
	end
*###[ ffdl2t:
	subroutine ffdl2t(delps,piDpj,in,jn,kn,ln,lkn,islk,iss,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*		\delta_{si,sj}^{sk,sl}					*
*									*
*	with p(lk) = islk*(iss*sl - sk)	(islk,iss = +/-1)		*
*	and NO relationship between s1,s2 assumed (so 1/2 the		*
*	possibilities of ffdl2s).					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer in,jn,ip1,kn,ln,lkn,islk,iss,ns,ier
	DOUBLE PRECISION delps,piDpj(ns,ns)
*
*	local variables
*
	integer i
	DOUBLE PRECISION s1,s2,som,smax,xnul,xlosn
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    if ( abs(islk) .ne. 1 )
     +		print *,'ffdl2i: error: |islk| != 1 ',islk
	    if ( abs(iss) .ne. 1 )
     +		print *,'ffdl2i: error: |iss| != 1 ',iss
	    xlosn = xloss*DBLE(10)**(-1-mod(ier,50))
	    do 10 i=1,ns
		xnul = islk*iss*piDpj(ln,i) - islk*piDpj(kn,i) -
     +			piDpj(lkn,i)
		smax = max(abs(piDpj(ln,i)),abs(piDpj(kn,i)))
		if ( xlosn*abs(xnul) .gt. precx*smax ) then
		    print *,'ffdl2t: error: dotproducts ',islk*iss*ln,
     +		    -islk*kn,-lkn,' with ',i,' do not add to 0:',
     +		    islk*iss*piDpj(ln,i),-iss*piDpj(kn,i),-piDpj(lkn,i),
     +		    xnul,ier
		endif
   10	    continue
	endif
*  #] check input:
*  #[ calculations:
	if ( in .eq. jn ) then
	    delps = 0
	    return
	endif
	s1 = piDpj(kn,in)*piDpj(ln,jn)
	s2 = piDpj(ln,in)*piDpj(kn,jn)
	delps = s1 - s2
	if ( abs(delps) .ge. xloss*abs(s1) ) goto 20
	if ( lwrite ) print *,'  delps  = ',delps,s1,-s2
	som = delps
	smax = abs(s1)

	s1 = piDpj(kn,in)*piDpj(lkn,jn)
	s2 = piDpj(lkn,in)*piDpj(kn,jn)
	delps = iss*islk*(s1 - s2)
	if ( lwrite ) print *,'  delps+ = ',delps,islk,s1,-s2
	if ( abs(delps) .ge. xloss*abs(s1) ) goto 20
	if ( abs(s1) .lt. smax ) then
	    som = delps
	    smax = abs(s1)
	endif

	s1 = piDpj(lkn,in)*piDpj(ln,jn)
	s2 = piDpj(ln,in)*piDpj(lkn,jn)
	delps = islk*(- s1 + s2)
	if ( lwrite ) print *,'  delps++= ',delps,islk,-s1,s2
	if ( abs(delps) .ge. xloss*abs(s1) ) goto 20
	if ( abs(s1) .lt. smax ) then
	    som = delps
	    smax = abs(s1)
	endif
*
*	give up
*
	delps = som
	if ( lwarn ) call ffwarn(93,ier,delps,smax)

   20	continue
*  #] calculations:
*###] ffdl2t:
	end
*###[ ffdl3m:
	subroutine ffdl3m(del3mi,ldel,del3,del2,xpi,dpipj,piDpj,ns,ip1n,
     +		ip2n,ip3n,is,itime,ier)
***#[*comment:***********************************************************
*									*
*	Calculate xpi(i)*del2 - del3(piDpj)				*
*									*
*	  /  si	mu \2		(This appears to be one of the harder	*
*	= | d	   |		 determinants to calculate accurately.	*
*	  \  p1	p2 /		 Note that we allow a loss of xloss^2)	*
*									*
*	Input:	ldel		iff .true. del2 and del3 exist		*
*		del3		\delta^{s(1),p1,p2}_{s(1),p1,p2}	*
*		del2		\delta^{p1,p2}_{p1,p2}			*
*		xpi(ns)		standard				*
*		dpipj(ns,ns)	standard				*
*		piDpj(ns,ns)	standard				*
*		ipi		pi = xpi(abs(ipi)) [p3=-p1 +/-p2]	*
*		is		si = xpi(is,is+1,..,is+itime-1)		*
*		itime		number of functions to calculate	*
*									*
*	Output:	del3mi(3)	(\delta^{s_i \mu}_{p_1 p_2})^2		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ip1n,ip2n,ip3n,is,itime,ier
	logical ldel
	DOUBLE PRECISION del3mi(itime),del3,del2,xpi(ns),dpipj(ns,ns),
     +		piDpj(ns,ns)
*
*	local variables:
*
	DOUBLE PRECISION s(7),som,smax,del2s,delps,xsom,xmax
	integer i,j,k,ip1,ip2,ip3,ipn,is1,is2,isi,is3,ihlp,iqn,jsgnq,
     +		jsgn1,jsgn2,jsgn3,jsgnn,iadj(10,10,3:4),init,nm
	save iadj,init
	logical lsign,lmax,ltwist
*
*	common blocks:
*
	include 'ff.h'
*
*	data
*
	data iadj /200*0/
	data init /0/
*  #] declarations:
*  #[ initialisations:
	if ( init .eq. 0 ) then
	    init = 1
*
*	    Fill the array with adjacent values: if
*		x = iadj(i,j)
*		k = abs(mod(k,100))
*		jsgnk = sign(x)
*		jsgnj = 1-2*theta(x-100)  (ie -1 iff |x|>100)
*	    then
*		pi(k) = jsgnk*( p(i) - jsgnj*pi(j) )
*
	    do 5 nm=3,4
		do 4 i=1,nm
		    is1 = i
		    is2 = i+1
		    if ( is2 .gt. nm ) is2 = 1
		    is3 = i-1
		    if ( is3 .eq. 0 ) is3 = nm
		    ip1 = is1 + nm
		    iadj(is1,is2,nm) = -ip1
		    iadj(is2,is1,nm) = ip1
		    iadj(ip1,is2,nm) = -is1
		    iadj(is2,ip1,nm) = is1
		    iadj(is1,ip1,nm) = 100+is2
		    iadj(ip1,is1,nm) = 100+is2
		    if ( nm .eq. 3 ) then
			iadj(ip1,is2+3,3) = -100-is3-3
			iadj(is2+3,ip1,3) = -100-is3-3
		    endif
    4		continue
    5	    continue

	    iadj(3,1,4) = -9
	    iadj(1,3,4) = 9
	    iadj(9,1,4) = -3
	    iadj(1,9,4) = 3
	    iadj(3,9,4) = 100+1
	    iadj(9,3,4) = 100+1

	    iadj(2,4,4) = -10
	    iadj(4,2,4) = 10
	    iadj(10,4,4) = -2
	    iadj(4,10,4) = 2
	    iadj(2,10,4) = 100+4
	    iadj(10,2,4) = 100+4

	endif
	if ( ns .eq. 6 ) then
	    nm = 3
	else
	    nm = 4
	endif
*  #] initialisations:
*  #[ superfluous code:
*	if ( ns .ne. 6 ) print *,'ffdl3m: called with ns <> 6 !!'
*	if ( ip1n .lt. 4 ) then
*	    lsign = .TRUE.
*	else
*	    lsign = .FALSE.
*	endif
*	if ( ltest .and. lsign ) then
*	    if ( ip3n .eq. 4 ) then
*		if ( ip1n .ne. 1 .or. ip2n .ne. 2 ) goto 2
*	    elseif ( ip3n .eq. 5 ) then
*		if ( ip1n .ne. 2 .or. ip2n .ne. 3 ) goto 2
*	    elseif ( ip3n .eq. 6 ) then
*		if ( ip1n .ne. 3 .or. ip2n .ne. 1 ) goto 2
*	    else
*		goto 2
*	    endif
*	    goto 3
*    2	    continue
*	    print *,'ffdl3m: unexpected combination of indices',ip1,ip2,
*     +					ip3
*    3	    continue
*	endif
*	this went at he end:
*  #[ special case 4,5,6:
*	    Next try - I don't give up easily
*	    if ( nm .eq. 6 .and. ip1n .eq. 4 .and. ip2n .eq. 5 .and.
*     +			ip3n .eq. 6 .and. is .eq. 1 ) then
*		is3 = isi + 1
*		if ( is3 .eq. 4 ) is3 = 1
*		is1 = is3 + 1
*		if ( is1 .eq. 4 ) is1 = 1
*		ip1 = is1 + 3
*		ip2 = isi + 3
*		ip3 = is3 + 3
*		This is an algorithm of last resort.  Add special
*		cases at will.
*		s(1) = xpi(ip1)*xpi(ip2)*xpi(ip3)
*		s(2) = dpipj(is1,isi)*dpipj(ip1,ip2)**2
*		s(3) = -dpipj(is1,isi)*xpi(ip3)*(xpi(ip1)+xpi(ip2))
*		s(4) = 2*dpipj(is1,isi)*dpipj(is1,is3)*
*     +			piDpj(ip1,ip3)
*		s(5) = -2*dpipj(is1,is3)*xpi(ip1)*piDpj(ip2,ip3)
*		s(6) = dpipj(is1,isi)**2*xpi(ip3)
*		s(7) = dpipj(is1,is3)**2*xpi(ip1)
*		som = s(1)
*		smax = abs(s(1))
*		do 31 j=2,7
*		    som = som + s(j)
*		    smax = max(smax,abs(som))
*   31		continue
*		som = som/4
*		smax = smax/4
*		if (lwrite) print *,'  del3mi(',isi,')++= ',som,smax
*		if ( abs(som) .ge. xloss*smax ) goto 35
*		if ( smax .lt. xmax ) then
*		    xsom = som
*		    xmax = smax
*		endif
*	    endif
*  #] special case 4,5,6:
*  #] superfluous code:
*  #[ easy tries:
	do 40 i=1,itime
	    isi = i+is-1
	    lmax = .FALSE.
*
*	    get xpi(isi)*del2 - del3 ... if del3 and del2 are defined
*
	    if ( ldel ) then
		s(1) = xpi(isi)*del2
		som = s(1) - del3
		smax = abs(s(1))
		if ( abs(som) .ge. xloss**2*smax ) goto 35
		if ( lwrite ) print *,'  del3mi(',isi,')  =',som,s(1),
     +			del3
		xsom = som
		xmax = smax
		lmax = .TRUE.
	    endif
	    ip1 = ip1n
	    ip2 = ip2n
	    ip3 = ip3n
	    do 20 j=1,3
*
*		otherwise use the simple threeterm formula
*
		s(1) = xpi(ip2)*piDpj(ip1,isi)**2
		s(2) = xpi(ip1)*piDpj(ip2,isi)*piDpj(ip2,isi)
		s(3) = -2*piDpj(ip2,isi)*piDpj(ip2,ip1)*piDpj(ip1,isi)
		som = s(1) + s(2) + s(3)
		smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
		if ( lwrite .and. (ldel.or.j.ne.1) ) print *,
     +			'  del3mi(',isi,')+ =',som,(s(k),k=1,3)
		if ( abs(som) .ge. xloss**2*smax ) goto 35
		if ( lwrite .and. .not.(ldel.or.j.ne.1) ) print *,
     +			'  del3mi(',isi,')  =',som,(s(k),k=1,3)
		if ( .not. lmax .or. smax .lt. xmax ) then
		    xsom = som
		    xmax = smax
		    lmax = .TRUE.
		endif
*
*		if there are cancellations between two of the terms:
*		we try mixing with isi.
*
*		First map cancellation to s(2)+s(3) (do not mess up
*		rotations...)
*
		if ( abs(s(1)+s(3)) .lt. abs(s(3))/2 ) then
		    ihlp = ip1
		    ip1 = ip2
		    ip2 = ihlp
		    som = s(1)
		    s(1) = s(2)
		    s(2) = som
		    ltwist = .TRUE.
		else
		    ltwist = .FALSE.
		endif
		if ( abs(s(2)+s(3)) .lt. abs(s(3))/2 ) then
*
*		switch to the vector pn so that si = jsgn1*p1 + jsgnn*pn
*
		k = iadj(isi,ip1,nm)
		if ( k .ne. 0 ) then
		    ipn = abs(k)
		    jsgnn = isign(1,k)
		    if ( ipn .gt. 100 ) then
			ipn = ipn - 100
			jsgn1 = -1
		    else
			jsgn1 = +1
		    endif
		    if (abs(dpipj(ipn,isi)).lt.xloss*abs(piDpj(ip1,isi))
     +		     .and.
     +			abs(piDpj(ipn,ip2)).lt.xloss*abs(piDpj(ip2,isi))
     +			   ) then
*		same:	s(1) = xpi(ip2)*piDpj(ip1,isi)**2
			s(2) = jsgnn*piDpj(isi,ip2)*piDpj(ipn,ip2)*
     +								xpi(ip1)
			s(3) = jsgn1*piDpj(isi,ip2)*piDpj(ip1,ip2)*
     +							dpipj(ipn,isi)
			som = s(1) + s(2) + s(3)
			smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
			if ( lwrite ) print *,
     +			    '  del3mi(',isi,')++=',som,(s(k),k=1,3)
*			print *,'    (isi+ip1) with isi,ip1,ip2,ipn: ',
*     +				isi,ip1,ip2,ipn
*			print *,'xpi(ip2),piDpj(ip1,isi)',xpi(ip2),
*     +				piDpj(ip1,isi)
*			print *,'piDpj(isi,ip2),piDpj(ipn,ip2),xpi(ip1)'
*     +				,piDpj(isi,ip2),piDpj(ipn,ip2),xpi(ip1)
			if ( abs(som) .ge. xloss**2*smax ) goto 35
			if ( smax .lt. xmax ) then
			    xsom = som
			    xmax = smax
			endif
*
*			there may be a cancellation between s(1) and
*			s(2) left.  Introduce a vector q such that
*			pn = jsgnq*q + jsgn2*p2.  We also need the sign
*			jsgn3 in p3 = -p1 - jsgn3*p2
*
			k = iadj(ipn,ip2,nm)
			if ( k .ne. 0 ) then
			    iqn = abs(k)
*not used		    jsgnq = isign(1,k)
			    if ( iqn .gt. 100 ) then
				iqn = iqn - 100
				jsgn2 = -1
			    else
				jsgn2 = +1
			    endif
			    k = iadj(ip1,ip2,nm)
			    if ( k .eq. 0 .or. k .lt. 100 ) then
*				we have p1,p2,p3 all p's
				jsgn3 = +1
			    elseif ( k .lt. 0 ) then
*				ip1,ip2 are 2*s,1*p such that p2-p1=ip3
				jsgn3 = -1
			    else
				jsgn3 = 0
			    endif
*			    we need one condition on the signs for this
*			    to work
			    if ( ip3.ne.0 .and. jsgn1*jsgn2.eq.jsgnn*
     +			      jsgn3 .and. abs(s(3)).lt.xloss*smax ) then
				s(1) = piDpj(ip1,isi)**2*dpipj(iqn,ipn)
				s(2) = -jsgn2*jsgn1*piDpj(ipn,ip2)*
     +					piDpj(ip1,isi)*dpipj(ipn,isi)
*				s(3) stays the same
				s(4) = -jsgn2*jsgn1*piDpj(ipn,ip2)*
     +					xpi(ip1)*piDpj(isi,ip3)
				som = s(1) + s(2) + s(3) + s(4)
				smax =max(abs(s(1)),abs(s(2)),abs(s(3)),
     +					abs(s(4)))
				if ( lwrite ) print *,
     +				'  del3mi(',isi,')+2=',som,(s(k),k=1,4)
				if ( abs(som).ge.xloss**2*smax ) goto 35
				if ( smax .lt. xmax ) then
				    xsom = som
				    xmax = smax
				endif
			    endif
			endif
		    endif
		endif
		k = iadj(isi,ip2,nm)
		if ( k .ne. 0 ) then
		    ipn = abs(k)
		    jsgnn = isign(1,k)
		    if ( ipn .gt. 100 ) then
			jsgn1 = -1
			ipn = ipn - 100
		    else
			jsgn1 = +1
		    endif
		    if (abs(dpipj(ipn,isi)).lt.xloss*abs(piDpj(ip2,isi))
     +		     .and.
     +			abs(piDpj(ipn,ip1)).lt.xloss*abs(piDpj(ip1,isi))
     +			   ) then
			s(1) = jsgnn*piDpj(isi,ip1)*piDpj(ipn,ip1)*
     +								xpi(ip2)
			s(2) = xpi(ip1)*piDpj(ip2,isi)**2
			s(3) = jsgn1*piDpj(isi,ip1)*piDpj(ip2,ip1)*
     +							dpipj(ipn,isi)
			som = s(1) + s(2) + s(3)
			smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
			if ( lwrite ) print *,
     +			    '  del3mi(',isi,')++=',som,(s(k),k=1,3)
			print *,'    (isi+ip2) with isi,ip1,ip2,ipn: ',
     +				isi,ip1,ip2,ipn
			if ( abs(som) .ge. xloss**2*smax ) goto 35
			if ( smax .lt. xmax ) then
			    xsom = som
			    xmax = smax
			endif
		    endif
		endif
		endif
*this does not suffice
*		if ( lsign ) then
*		    if ( abs(s(1)) .lt. abs(s(2)) ) then
*			s(2) = piDpj(isi,ip2)*piDpj(isi,ip3)*xpi(ip1)
*			if ( j .eq. 2 ) s(2) = -s(2)
*			s(3) = piDpj(isi,ip1)*piDpj(isi,ip2)*
*     +				dpipj(ip3,ip2)
*		    else
*			s(1) = piDpj(isi,ip1)*piDpj(isi,ip3)*xpi(ip2)
*			if ( j .eq. 1 ) s(1) = -s(1)
*			s(3) = piDpj(isi,ip1)*piDpj(isi,ip2)*
*     +				dpipj(ip3,ip1)
*		    endif
*		    if ( j .eq. 3 ) s(3) = -s(3)
**
*		    som = s(1) + s(2) + s(3)
*		    smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*		    if ( lwrite ) print *,
*     +			'  del3mi(',isi,')++=',som,(s(k),k=1,3)
*		    if ( abs(som) .ge. xloss**2*smax ) goto 35
*		    if ( smax .lt. xmax ) then
*			xmax = smax
*			xsom = som
*		    endif
*		endif
*nor does this
*		if ( j .eq. 1 )
*     +			call ffdel2(del2s,piDpj,6,ip1,ip2,ip3,1,ier)
*		call ffdl2t(delps,piDpj,isi,ip2,ip1,ip2,ip3,+1,+1,6,ier)
*		s(1) = piDpj(isi,ip2)**2*del2s/xpi(ip2)
*		s(2) = delps**2/xpi(ip2)
*		som = s(1) + s(2)
*		smax = abs(s(1))
*		if ( lwrite ) print *,
*     +			'  del3mi(',isi,')++=',del3mi(i),(s(k),k=1,2)
*		if ( abs(som) .ge. xloss*smax ) goto 35
*		if ( smax .lt. xmax ) then
*		    xmax = smax
*		    xsom = som
*		endif
*
*		rotate the ipi
*
		if ( ip3 .eq. 0 ) goto 30
		if ( j .ne. 3 ) then
		    if ( .not. ltwist ) then
			ihlp = ip1
			ip1 = ip2
			ip2 = ip3
			ip3 = ihlp
		    else
			ihlp = ip2
			ip2 = ip3
			ip3 = ihlp
		    endif
		endif
   20	    continue
   30	    continue
*  #] easy tries:
*  #[ choose the best value:
*
*	    These values are the best found:
*
	    som = xsom
	    smax = xmax
	    if ( lwarn ) call ffwarn(75,ier,som,smax)
	    if ( lwrite ) then
		print *,'ffdl3m: giving up:'
		print *,'ip1,ip2,ip3,is,itime =',ip1,ip2,ip3,is,itime
		print *,'xpi = ',xpi
	    endif

   35	    continue
	    del3mi(i) = som
   40	continue
*  #] choose the best value:
*###] ffdl3m:
	end
*###[ ffdel3:
	subroutine ffdel3(del3,xpi,piDpj,ns,ier)
***#[*comment:***********************************************************
*									*
*	Calculate del3(piDpj) = det(si.sj)	with			*
*	the momenta as follows:						*
*	p(1-3) = s(i)							*
*	p(4-6) = p(i)							*
*									*
*	Input:	xpi(ns)		(real)	m^2(i),i=1,3; p^2(i-3),i=4,10	*
*		piDpj(ns,ns)	(real)					*
*		ns		(integer)				*
*		ier		(integer)				*
*									*
*	Output:	del3		(real)	det(si.sj)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ier
	DOUBLE PRECISION del3,xpi(6),piDpj(6,6)
*
*	local variables:
*
	integer mem,nperm
	parameter(mem=10,nperm=16)
	integer i,jj(6),iperm(3,nperm),imem,memarr(mem,3),memind,inow
	DOUBLE PRECISION s(6),xmax,del3p,xmaxp,rloss
	save iperm,memind,memarr,inow
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ data:
	data memind /0/
	data memarr /mem*0,mem*0,mem*1/
	data inow /1/
*
*	these are all permutations that give a non-zero result with the
*	correct sign.  This list was generated with getperm3.
*
	data iperm/
     +		1,2,3,  1,2,5,  1,6,2,  1,4,3,
     +		1,3,5,  1,4,5,  1,6,4,  1,5,6,
     +		2,4,3,  2,3,6,  2,4,5,  2,6,4,
     +		2,5,6,  3,4,5,  3,6,4,  3,5,6/
*  #] data:
*  #[ starting point in memory?:
*
*	see if we know were to start, if not: go on as last time
*
	do 5 i=1,mem
	    if ( id .eq. memarr(i,1) .and. idsub .eq. memarr(i,2) ) then
		inow = memarr(i,3)
		goto 6
	    endif
    5	continue
    6	continue
*  #] starting point in memory?:
*  #[ calculations:
	imem = inow
	del3 = 0
	xmax = 0

   10	continue

	jj(1) = iperm(1,inow)
	jj(3) = iperm(2,inow)
	jj(5) = iperm(3,inow)

	jj(2) = iperm(1,inow)
	jj(4) = iperm(2,inow)
	jj(6) = iperm(3,inow)

	s(1) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(6))
	s(2) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(2))
	s(3) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(4))
	s(4) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(4))
	s(5) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(2))
	s(6) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(6))

	del3p = 0
	xmaxp = 0
	do 20 i=1,6
	    del3p = del3p + s(i)
	    xmaxp = max(xmaxp,abs(s(i)))
   20	continue
	if ( abs(del3p) .lt. xloss*xmaxp ) then
	    if ( lwrite ) print *,'del3+',inow,' = ',del3p,xmaxp
	    if ( inow .eq. imem .or. xmaxp .lt. xmax ) then
		del3 = del3p
		xmax = xmaxp
	    endif
	    inow = inow + 1
	    if ( inow .gt. nperm ) inow = 1
	    if ( inow .eq. imem ) then
		if ( lwarn ) call ffwarn(73,ier,del3,xmax)
		goto 800
	    endif
	    goto 10
	endif
	if ( inow .ne. imem ) then
	    if ( lwrite ) print *,'del3+',inow,' = ',del3p,xmaxp
	endif
	del3 = del3p
	xmax = xmaxp
*  #] calculations:
*  #[ into memory:
  800	continue
	memind = memind + 1
	if ( memind .gt. mem ) memind = 1
	memarr(memind,1) = id
	memarr(memind,2) = idsub
	memarr(memind,3) = inow
*  #] into memory:
*  #[ check output:
	if ( ltest ) then

	    s(1) = +piDpj(1,1)*piDpj(2,2)*piDpj(3,3)
	    s(2) = +piDpj(1,2)*piDpj(2,3)*piDpj(3,1)
	    s(3) = +piDpj(1,3)*piDpj(2,1)*piDpj(3,2)
	    s(4) = -piDpj(1,1)*piDpj(2,3)*piDpj(3,2)
	    s(5) = -piDpj(1,3)*piDpj(2,2)*piDpj(3,1)
	    s(6) = -piDpj(1,2)*piDpj(2,1)*piDpj(3,3)

	    del3p = 0
	    xmaxp = 0
	    do 820 i=1,6
		del3p = del3p + s(i)
		xmaxp = max(xmaxp,abs(s(i)))
  820	    continue
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    if ( rloss*abs(del3p-del3) .gt. precx*xmaxp ) then
		print *,'ffdel3: error: result does not agree with',
     +			' normal case'
		print *,'result: ',del3,xmax
		print *,'normal: ',del3p,xmaxp
		print *,'diff.:  ',del3-del3p
	    endif
	endif
*  #] check output:
*###] ffdel3:
	end
*(##[ ffdl3s:
	subroutine ffdl3s(dl3s,xpi,piDpj,ii,ns,ier)
***#[*comment:***********************************************************
*									*
*	Calculate dl3s(piDpj) = det(si.sj)	with			*
*	the momenta indicated by the indices ii(1-6,1), ii(1-6,2)	*
*	as follows:							*
*	p(|ii(1,)|-|ii(3,)|) = s(i)					*
*	p(|ii(4,)|-|ii(6,)|) = p(i) = sgn(ii())*(s(i+1) - s(i))		*
*									*
*	At this moment (26-apr-1990) only the diagonal is tried		*									
*									*									
*	Input:	xpi(ns)		(real)	m^2(i),i=1,3; p^2(i-3),i=4,10	*
*		piDpj(ns,ns)	(real)					*
*		ii(6,2)		(integer)	see above		*
*		ns		(integer)				*
*		ier		(integer)				*
*									*
*	Output:	dl3s		(real)	det(si.sj)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ii(6,2),isgn6(2),ns,ier
	DOUBLE PRECISION dl3s,xpi(ns),piDpj(ns,ns)
*
*	local variables:
*
	integer mem,nperm
	parameter(mem=10,nperm=16)
	integer i,j,jj(6),jsgn,iperm(3,nperm),imem,memarr(mem,3),
     +		memind,inow
	DOUBLE PRECISION s(6),xmax,dl3sp,xmaxp,xlosn,xhck,rloss
	save iperm,memind,memarr,inow
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ data:
	data memind /0/
	data memarr /mem*0,mem*0,mem*1/
	data inow /1/
*
*	these are all permutations that give a non-zero result with the
*	correct sign.  This list was generated with getperm3.
*
	data iperm/
     +		1,2,3,  1,2,5,  1,6,2,  1,4,3,
     +		1,3,5,  1,4,5,  1,6,4,  1,5,6,
     +		2,4,3,  2,3,6,  2,4,5,  2,6,4,
     +		2,5,6,  3,4,5,  3,6,4,  3,5,6/
*  #] data:
*  #[ test input:
	if ( ltest ) then
*	    print *,'ffdl3s: input: ii(,1) = ',(ii(i,1),i=1,6)
*	    print *,'               ii(,2) = ',(ii(i,2),i=1,6)
	    xlosn = xloss*DBLE(10)**(-mod(ier,50))
	    do 3 j=1,2
	    do 1 i=1,6
		if ( abs(ii(i,j)) .gt. ns ) print *,'ffdl3s: error: ',
     +			'|ii(i,j)| > ns: ',ii(i,j),ns
		if ( abs(ii(i,j)) .eq. 0 ) print *,'ffdl3s: error: ',
     +			'|ii(i,j)| = 0: ',ii(i,j)
    1	    continue
	    do 2 i=1,6

		xhck = piDpj(abs(ii(i,j)),ii(1,j))
     +		     - piDpj(abs(ii(i,j)),ii(2,j))
     +		     + sign(1,ii(4,j))*piDpj(abs(ii(i,j)),abs(ii(4,j)))
		xmax = max(abs(piDpj(abs(ii(i,j)),ii(1,j))),
     +			   abs(piDpj(abs(ii(i,j)),ii(2,j))))
		if ( xlosn*abs(xhck) .gt. precx*xmax ) print *,'ffdl3s:'
     +		  ,' error: dotproducts 124 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(1,j)),
     +		  piDpj(abs(ii(i,j)),ii(2,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(4,j))),xhck

		xhck = piDpj(abs(ii(i,j)),ii(2,j))
     +		     - piDpj(abs(ii(i,j)),ii(3,j))
     +		     + sign(1,ii(5,j))*piDpj(abs(ii(i,j)),abs(ii(5,j))) 
		xmax = max(abs(piDpj(abs(ii(i,j)),ii(2,j))),
     +			abs(piDpj(abs(ii(i,j)),ii(3,j))))
		if ( xlosn*abs(xhck) .gt. precx*xmax ) print *,'ffdl3s:'
     +		  ,' error: dotproducts 235 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(2,j)),
     +		  piDpj(abs(ii(i,j)),ii(3,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(5,j))),xhck

		xhck = piDpj(abs(ii(i,j)),ii(3,j)) 
     +		     - piDpj(abs(ii(i,j)),ii(1,j))
     +		     + sign(1,ii(6,j))*piDpj(abs(ii(i,j)),abs(ii(6,j))) 
		xmax = max(abs(piDpj(abs(ii(i,j)),ii(3,j))),
     +			abs(piDpj(abs(ii(i,j)),ii(1,j))))
		if ( xlosn*abs(xhck) .gt. precx*xmax ) print *,'ffdl3s:'
     +		  ,' error: dotproducts 316 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),ii(3,j)),
     +		  piDpj(abs(ii(i,j)),ii(1,j)),
     +		  piDpj(abs(ii(i,j)),abs(ii(6,j))),xhck

		xhck = sign(1,ii(4,j))*piDpj(abs(ii(i,j)),abs(ii(4,j))) 
     +		     + sign(1,ii(5,j))*piDpj(abs(ii(i,j)),abs(ii(5,j)))
     +		     + sign(1,ii(6,j))*piDpj(abs(ii(i,j)),abs(ii(6,j)))
		xmax = max(abs(piDpj(abs(ii(i,j)),abs(ii(4,j)))),
     +			   abs(piDpj(abs(ii(i,j)),abs(ii(5,j)))))
		if ( xlosn*abs(xhck) .gt. precx*xmax ) print *,'ffdl3s:'
     +		  ,' error: dotproducts 456 with ',i,' do not add to 0:'
     +		  ,piDpj(abs(ii(i,j)),abs(ii(4,j))),
     +		  piDpj(abs(ii(i,j)),abs(ii(5,j))),
     +		  piDpj(abs(ii(i,j)),abs(ii(6,j))),xhck

    2	    continue
    3	    continue
	endif
*  #] test input:
*  #[ starting point in memory?:
*
*	see if we know were to start, if not: go on as last time
*
	do 5 i=1,mem
	    if ( id .eq. memarr(i,1) .and. idsub .eq. memarr(i,2) ) then
		inow = memarr(i,3)
		goto 6
	    endif
    5	continue
    6	continue
*  #] starting point in memory?:
*  #[ calculations:
	imem = inow
	dl3s = 0
	xmax = 0

   10	continue

	jj(1) = abs(ii(iperm(1,inow),1))
	jj(3) = abs(ii(iperm(2,inow),1))
	jj(5) = abs(ii(iperm(3,inow),1))

	jj(2) = abs(ii(iperm(1,inow),2))
	jj(4) = abs(ii(iperm(2,inow),2))
	jj(6) = abs(ii(iperm(3,inow),2))

	jsgn =  sign(1,ii(iperm(1,inow),1))
     +		*sign(1,ii(iperm(2,inow),1))
     +		*sign(1,ii(iperm(3,inow),1))
     +		*sign(1,ii(iperm(1,inow),2))
     +		*sign(1,ii(iperm(2,inow),2))
     +		*sign(1,ii(iperm(3,inow),2))

	s(1) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(6))
	s(2) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(2))
	s(3) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(4))
	s(4) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*piDpj(jj(5),jj(4))
	s(5) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*piDpj(jj(5),jj(2))
	s(6) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*piDpj(jj(5),jj(6))

	dl3sp = 0
	xmaxp = 0
	do 20 i=1,6
	    dl3sp = dl3sp + s(i)
	    xmaxp = max(xmaxp,abs(s(i)))
   20	continue
	if ( abs(dl3sp) .lt. xloss*xmaxp ) then
	    if ( lwrite ) print *,'dl3s+',inow,' = ',dl3sp,xmaxp
	    if ( inow .eq. imem .or. xmaxp .lt. xmax ) then
		dl3s = jsgn*dl3sp
		xmax = xmaxp
	    endif
	    inow = inow + 1
	    if ( inow .gt. nperm ) inow = 1
	    if ( inow .eq. imem ) then
		if ( lwarn ) call ffwarn(85,ier,dl3s,xmax)
		goto 800
	    endif
	    goto 10
	endif
	if ( inow .ne. imem ) then
	    if ( lwrite ) print *,'dl3s+',inow,' = ',dl3sp,xmaxp
	endif
	dl3s = jsgn*dl3sp
	xmax = xmaxp
*  #] calculations:
*  #[ into memory:
  800	continue
	memind = memind + 1
	if ( memind .gt. mem ) memind = 1
	memarr(memind,1) = id
	memarr(memind,2) = idsub
	memarr(memind,3) = inow
*  #] into memory:
*  #[ check output:
	if ( ltest ) then

	    s(1) = +piDpj(ii(1,1),ii(1,2))*piDpj(ii(2,1),ii(2,2))*
     +						piDpj(ii(3,1),ii(3,2))
	    s(2) = +piDpj(ii(1,1),ii(2,2))*piDpj(ii(2,1),ii(3,2))*
     +						piDpj(ii(3,1),ii(1,2))
	    s(3) = +piDpj(ii(1,1),ii(3,2))*piDpj(ii(3,1),ii(2,2))*
     +						piDpj(ii(2,1),ii(1,2))
	    s(4) = -piDpj(ii(1,1),ii(1,2))*piDpj(ii(2,1),ii(3,2))*
     +						piDpj(ii(3,1),ii(2,2))
	    s(5) = -piDpj(ii(1,1),ii(3,2))*piDpj(ii(2,1),ii(2,2))*
     +						piDpj(ii(3,1),ii(1,2))
	    s(6) = -piDpj(ii(1,1),ii(2,2))*piDpj(ii(2,1),ii(1,2))*
     +						piDpj(ii(3,1),ii(3,2))

	    dl3sp = 0
	    xmaxp = 0
	    do 820 i=1,6
		dl3sp = dl3sp + s(i)
		xmaxp = max(xmaxp,abs(s(i)))
  820	    continue
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    if ( rloss*abs(dl3sp-dl3s) .gt. precx*xmaxp ) then
		print *,'ffdl3s: error: result does not agree with',
     +			' normal case'
		print *,'result: ',dl3s,xmax
		print *,'normal: ',dl3sp,xmaxp
		print *,'diff.:  ',dl3s-dl3sp
	    endif
	endif
*  #] check output:
*)##] ffdl3s:
	end
*###[ ffdel4:
	subroutine ffdel4(del4,xpi,piDpj,ns,ier)
***#[*comment:***********************************************************
*									*
*	Calculate del4(piDpj) = det(si.sj)	with			*
*	the momenta as follows:						*
*	p(1-4) = s(i)							*
*	p(4-10) = p(i)							*
*									*
*	Input:	xpi(ns)		(real)	m^2(i),i=1,3; p^2(i-3),i=4,10	*
*		piDpj(ns,ns)	(real)					*
*		ns		(integer)				*
*		ier		(integer)				*
*									*
*	Output:	del4		(real)	det(si.sj)			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ier
	DOUBLE PRECISION del4,xpi(10),piDpj(10,10)
*
*	local variables:
*
	integer mem,nperm
	parameter(mem=10,nperm=125)
	integer i,jj(8),iperm(4,nperm),imem,jmem,memarr(mem,4),memind,
     +		inow,jnow,icount
	DOUBLE PRECISION s(24),xmax,del4p,xmaxp,rloss
	save iperm,memind,memarr,inow,jnow
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ data:
	data memind /0/
	data memarr /mem*0,mem*0,mem*1,mem*1/
	data inow /1/
	data jnow /1/
*
*	these are all permutations that give a non-zero result with the
*	correct sign.  This list was generated with getperm4.
*	(note: this used to be well-ordened, but then it had more than
*	19 continuation lines)
*
	data iperm/
     +	1,2,3,4,1,2,3,7,1,2,8,3,1,2,3,10,1,2,6,4,1,2,4,7,1,2,4,9,1,2,6,7
     +	,1,2,8,6,1,2,6,10,1,2,7,8,1,2,7,9,1,2,10,7,1,2,9,8,1,2,10,9,1,3,
     +	4,5,1,3,6,4,1,3,10,4,1,3,7,5,1,3,5,8,1,3,10,5,1,3,6,7,1,3,8,6,1,
     +	3,6,10,1,3,10,7,1,3,8,10,1,4,5,6,1,4,7,5,1,4,9,5,1,4,6,7,1,4,6,9
     +	,1,4,6,10,1,4,10,7,1,4,10,9,1,5,6,7,1,5,8,6,1,5,6,10,1,5,7,8,1,5
     +	,7,9,1,5,10,7,1,5,9,8,1,5,10,9,1,6,8,7,1,6,9,7,1,6,8,9,1,6,8,10,
     +	1,6,9,10,1,7,10,8,1,7,10,9,1,8,9,10,2,3,4,5,2,3,8,4,2,3,9,4,2,3,
     +	7,5,2,3,5,8,2,3,10,5,2,3,8,7,2,3,9,7,2,3,8,9,2,3,8,10,2,3,9,10,2
     +	,4,5,6,2,4,7,5,2,4,9,5,2,4,6,8,2,4,6,9,2,4,8,7,2,4,9,7,2,4,8,9,2
     +	,5,6,7,2,5,8,6,2,5,6,10,2,5,7,8,2,5,7,9,2,5,10,7,2,5,9,8,2,5,10,
     +	9,2,6,8,7,2,6,9,7,2,6,8,9,2,6,8,10,2,6,9,10,2,7,10,8,2,7,10,9,2,
     +	8,9,10,3,4,5,6,3,4,8,5,3,4,9,5,3,4,5,10,3,4,6,8,3,4,6,9,3,4,10,8
     +	,3,4,10,9,3,5,6,7,3,5,8,6,3,5,6,10,3,5,7,8,3,5,7,9,3,5,10,7,3,5,
     +	9,8,3,5,10,9,3,6,8,7,3,6,9,7,3,6,8,9,3,6,8,10,3,6,9,10,3,7,10,8,
     +	3,7,10,9,3,8,9,10,4,5,6,7,4,5,8,6,4,5,6,10,4,5,7,8,4,5,7,9,4,5,1
     +	0,7,4,5,9,8,4,5,10,9,4,6,8,7,4,6,9,7,4,6,8,9,4,6,8,10,4,6,9,10,4
     +	,7,10,8,4,7,10,9,4,8,9,10/
*  #] data:
*  #[ check input:
	if ( ltest .and. ns .ne. 10 ) then
	    print *,'ffdel4: error: only for ns = 10, not ',ns
	    stop
	endif
*  #] check input:
*  #[ get starting point from memory:
*
*	see if we know were to start, if not: go on as last time
*
	do 5 i=1,mem
	    if ( id .eq. memarr(i,1) .and. idsub .eq. memarr(i,2) ) then
		inow = memarr(i,3)
		jnow = memarr(i,4)
		if ( lwrite ) print *,'ffcel4: from memory: ',id,idsub,
     +			inow,jnow
		goto 6
	    endif
    5	continue
    6	continue
*  #] get starting point from memory:
*  #[ calculations:
	imem = inow
	jmem = jnow
	del4 = 0
	xmax = 0
	icount = 0

   10	continue

	jj(1) = iperm(1,inow)
	jj(3) = iperm(2,inow)
	jj(5) = iperm(3,inow)
	jj(7) = iperm(4,inow)

	jj(2) = iperm(1,jnow)
	jj(4) = iperm(2,jnow)
	jj(6) = iperm(3,jnow)
	jj(8) = iperm(4,jnow)

	s( 1) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(7),jj(8))
	s( 2) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(7),jj(8))
	s( 3) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(7),jj(8))
	s( 4) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(7),jj(8))
	s( 5) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(7),jj(8))
	s( 6) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(7),jj(8))

	s( 7) = -piDpj(jj(1),jj(2))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(7),jj(6))*piDpj(jj(5),jj(8))
	s( 8) = -piDpj(jj(1),jj(4))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(7),jj(2))*piDpj(jj(5),jj(8))
	s( 9) = -piDpj(jj(1),jj(6))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(7),jj(4))*piDpj(jj(5),jj(8))
	s(10) = +piDpj(jj(1),jj(2))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(7),jj(4))*piDpj(jj(5),jj(8))
	s(11) = +piDpj(jj(1),jj(6))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(7),jj(2))*piDpj(jj(5),jj(8))
	s(12) = +piDpj(jj(1),jj(4))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(7),jj(6))*piDpj(jj(5),jj(8))

	s(13) = -piDpj(jj(1),jj(2))*piDpj(jj(7),jj(4))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(3),jj(8))
	s(14) = -piDpj(jj(1),jj(4))*piDpj(jj(7),jj(6))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(3),jj(8))
	s(15) = -piDpj(jj(1),jj(6))*piDpj(jj(7),jj(2))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(3),jj(8))
	s(16) = +piDpj(jj(1),jj(2))*piDpj(jj(7),jj(6))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(3),jj(8))
	s(17) = +piDpj(jj(1),jj(6))*piDpj(jj(7),jj(4))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(3),jj(8))
	s(18) = +piDpj(jj(1),jj(4))*piDpj(jj(7),jj(2))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(3),jj(8))

	s(19) = -piDpj(jj(7),jj(2))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(1),jj(8))
	s(20) = -piDpj(jj(7),jj(4))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(1),jj(8))
	s(21) = -piDpj(jj(7),jj(6))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(1),jj(8))
	s(22) = +piDpj(jj(7),jj(2))*piDpj(jj(3),jj(6))*
     +		piDpj(jj(5),jj(4))*piDpj(jj(1),jj(8))
	s(23) = +piDpj(jj(7),jj(6))*piDpj(jj(3),jj(4))*
     +		piDpj(jj(5),jj(2))*piDpj(jj(1),jj(8))
	s(24) = +piDpj(jj(7),jj(4))*piDpj(jj(3),jj(2))*
     +		piDpj(jj(5),jj(6))*piDpj(jj(1),jj(8))

	del4p = 0
	xmaxp = 0
	do 20 i=1,24
	    del4p = del4p + s(i)
	    xmaxp = max(xmaxp,abs(s(i)))
   20	continue
	if ( abs(del4p) .lt. xloss*xmaxp ) then
	    if ( lwrite ) print *,'del4+',icount,' = ',del4p,xmaxp,inow,
     +		jnow
	    if ( inow .eq. imem .or. xmaxp .lt. xmax ) then
		del4 = del4p
		xmax = xmaxp
	    endif
*	    as the list is ordered we may have more luck stepping
*	    through with large steps
	    inow = inow + 43
	    jnow = jnow + 49
	    if ( inow .gt. nperm ) inow = inow - nperm
	    if ( jnow .gt. nperm ) jnow = jnow - nperm
	    icount = icount + 1
	    if ( icount.gt.15 .or. inow.eq.imem .or. jnow.eq.jmem
     +			) then
		if ( lwarn ) call ffwarn(143,ier,del4,xmax)
		goto 800
	    endif
	    goto 10
	endif
	if ( inow.ne.imem) then
	    if ( lwrite ) print *,'del4+',icount,' = ',del4p,xmaxp,inow,
     +		jnow
	endif
	del4 = del4p
	xmax = xmaxp
*  #] calculations:
*  #[ into memory:
	if ( lwrite ) print *,'ffcel4: into memory: ',id,idsub,inow,jnow
	memind = memind + 1
	if ( memind .gt. mem ) memind = 1
	memarr(memind,1) = id
	memarr(memind,2) = idsub
	memarr(memind,3) = inow
	memarr(memind,4) = jnow
  800	continue
*  #] into memory:
*  #[ check output:
	if ( ltest ) then
*
	    s( 1) = +piDpj(1,1)*piDpj(2,2)*piDpj(3,3)*piDpj(4,4)
	    s( 2) = +piDpj(1,2)*piDpj(2,3)*piDpj(3,1)*piDpj(4,4)
	    s( 3) = +piDpj(1,3)*piDpj(2,1)*piDpj(3,2)*piDpj(4,4)
	    s( 4) = -piDpj(1,1)*piDpj(2,3)*piDpj(3,2)*piDpj(4,4)
	    s( 5) = -piDpj(1,3)*piDpj(2,2)*piDpj(3,1)*piDpj(4,4)
	    s( 6) = -piDpj(1,2)*piDpj(2,1)*piDpj(3,3)*piDpj(4,4)
	    s( 7) = -piDpj(1,1)*piDpj(2,2)*piDpj(4,3)*piDpj(3,4)
	    s( 8) = -piDpj(1,2)*piDpj(2,3)*piDpj(4,1)*piDpj(3,4)
	    s( 9) = -piDpj(1,3)*piDpj(2,1)*piDpj(4,2)*piDpj(3,4)
	    s(10) = +piDpj(1,1)*piDpj(2,3)*piDpj(4,2)*piDpj(3,4)
	    s(11) = +piDpj(1,3)*piDpj(2,2)*piDpj(4,1)*piDpj(3,4)
	    s(12) = +piDpj(1,2)*piDpj(2,1)*piDpj(4,3)*piDpj(3,4)
	    s(13) = -piDpj(1,1)*piDpj(4,2)*piDpj(3,3)*piDpj(2,4)
	    s(14) = -piDpj(1,2)*piDpj(4,3)*piDpj(3,1)*piDpj(2,4)
	    s(15) = -piDpj(1,3)*piDpj(4,1)*piDpj(3,2)*piDpj(2,4)
	    s(16) = +piDpj(1,1)*piDpj(4,3)*piDpj(3,2)*piDpj(2,4)
	    s(17) = +piDpj(1,3)*piDpj(4,2)*piDpj(3,1)*piDpj(2,4)
	    s(18) = +piDpj(1,2)*piDpj(4,1)*piDpj(3,3)*piDpj(2,4)
	    s(19) = -piDpj(4,1)*piDpj(2,2)*piDpj(3,3)*piDpj(1,4)
	    s(20) = -piDpj(4,2)*piDpj(2,3)*piDpj(3,1)*piDpj(1,4)
	    s(21) = -piDpj(4,3)*piDpj(2,1)*piDpj(3,2)*piDpj(1,4)
	    s(22) = +piDpj(4,1)*piDpj(2,3)*piDpj(3,2)*piDpj(1,4)
	    s(23) = +piDpj(4,3)*piDpj(2,2)*piDpj(3,1)*piDpj(1,4)
	    s(24) = +piDpj(4,2)*piDpj(2,1)*piDpj(3,3)*piDpj(1,4)
*
	    del4p = 0
	    xmaxp = 0
	    do 820 i=1,24
		del4p = del4p + s(i)
		xmaxp = max(xmaxp,abs(s(i)))
  820	    continue
	    rloss = xloss*DBLE(10)**(-mod(ier,50))
	    if ( rloss*abs(del4p-del4) .gt. precx*xmaxp ) then
		print *,'ffdel4: error: result does not agree with',
     +			' normal case'
		print *,'result: ',del4,xmax
		print *,'normal: ',del4p,xmaxp
		print *,'diff.:  ',del4-del4p,ier
	    endif
	endif
*  #] check output:
*###] ffdel4:
	end
*###[ ffdl3p:
	subroutine ffdl3p(dl3p,piDpj,ns,ii,jj,ier)
***#[*comment:***********************************************************
*	calculate in a numerically stable way				*
*									*
*	     p1  p2  p3							*
*	delta								*
*	     p1' p2' p3'						*
*									*
*	with pn = xpi(ii(n)), p4 = -p1-p2-p3, p5 = -p1-p2, p6 = p2+p3	*
*	with pn'= xpi(jj(n)), p4'= etc.       (when ns=15 p5=p1+p2)	*
*									*
*	Input:	piDpj	real(ns,ns)	dotpruducts			*
*		ns	integer		either 10 or 15			*
*		ii,jj	integer(6)	location of pi in piDpj		*
*		ier	integer		number of digits lost so far	*
*	Output:	dl3p	real		see above			*
*		ier	integer		number of digits lost so far	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,ii(6),jj(6),ier
	DOUBLE PRECISION dl3p,piDpj(ns,ns)
*
*	local variables
*
	integer i,j,k,l,iperm(3,16),ii1,ii2,ii3,jj1,jj2,jj3,i0
	logical lsymm
	DOUBLE PRECISION s(6),som,xmax,smax,xheck,xlosn
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data iperm /1,2,3, 2,4,3, 3,4,1, 4,2,1,
     +		    1,2,6, 6,4,3, 3,1,6, 2,4,6,
     +		    2,5,3, 5,4,1, 1,3,5, 2,4,5,
     +		    1,6,5, 2,5,6, 3,6,5, 4,5,6/
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffdl3p: indices are'
	    print *,ii
	    print *,jj
	endif
	if ( ltest ) then
	    if ( ns .ne. 10 .and. ns .ne. 15 ) print *,'ffdl3p: error:',
     +		' only tested for ns=10,15'
	    xlosn = xloss*10.d0**(-mod(ier,50))
	    do 10 i=1,ns
		xheck = +piDpj(i,ii(1))+piDpj(i,ii(2))
     +			+piDpj(i,ii(3))+piDpj(i,ii(4))
		xmax = max(abs(piDpj(i,ii(1))),abs(piDpj(i,ii(2))),
     +			   abs(piDpj(i,ii(3))),abs(piDpj(i,ii(4))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta i1234 do not add to 0:',
     +			i,piDpj(i,ii(1)),piDpj(i,ii(2)),piDpj(i,ii(3)),
     +			piDpj(i,ii(4)),xheck,ier
		xheck = piDpj(i,ii(6))-piDpj(i,ii(2))-piDpj(i,ii(3))
		xmax = max(abs(piDpj(i,ii(6))),abs(piDpj(i,ii(2))),
     +			   abs(piDpj(i,ii(3))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta i623 do not add to 0:',
     +			i,piDpj(i,ii(6)),piDpj(i,ii(2)),piDpj(i,ii(3)),
     +			xheck,ier
		if ( ns .eq. 10 ) then
		    xheck = piDpj(i,ii(5))+piDpj(i,ii(1))+piDpj(i,ii(2))
		else
		    xheck = piDpj(i,ii(5))-piDpj(i,ii(1))-piDpj(i,ii(2))
		endif
		xmax = max(abs(piDpj(i,ii(5))),abs(piDpj(i,ii(1))),
     +			   abs(piDpj(i,ii(2))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta i512 do not add to 0:',
     +			i,piDpj(i,ii(5)),piDpj(i,ii(1)),piDpj(i,ii(2)),
     +			xheck,ier
		xheck = +piDpj(i,jj(1))+piDpj(i,jj(2))
     +			+piDpj(i,jj(3))+piDpj(i,jj(4))
		xmax = max(abs(piDpj(i,jj(1))),abs(piDpj(i,jj(2))),
     +			   abs(piDpj(i,jj(3))),abs(piDpj(i,jj(4))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta j1234 do not add to 0:',
     +			i,piDpj(i,jj(1)),piDpj(i,jj(2)),piDpj(i,jj(3)),
     +			piDpj(i,jj(4)),xheck,ier
		xheck = piDpj(i,jj(6))-piDpj(i,jj(2))-piDpj(i,jj(3))
		xmax = max(abs(piDpj(i,jj(6))),abs(piDpj(i,jj(2))),
     +			   abs(piDpj(i,jj(3))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta j623 do not add to 0:',
     +			i,piDpj(i,jj(6)),piDpj(i,jj(2)),piDpj(i,jj(3)),
     +			xheck,ier
		if ( ns .eq. 10 ) then
		    xheck = piDpj(i,jj(5))+piDpj(i,jj(1))+piDpj(i,jj(2))
		else
		    xheck = piDpj(i,jj(5))-piDpj(i,jj(1))-piDpj(i,jj(2))
		endif
		xmax = max(abs(piDpj(i,jj(5))),abs(piDpj(i,jj(1))),
     +			   abs(piDpj(i,jj(2))))
		if ( xlosn*xheck .gt. precx*xmax ) print *,
     +			'ffdl3p: error: momenta j512 do not add to 0:',
     +			i,piDpj(i,jj(5)),piDpj(i,jj(1)),piDpj(i,jj(2)),
     +			xheck,ier
   10	    continue
	endif
*  #] check input:
*  #[ calculations:
	if ( ii(1).eq.jj(1) .and. ii(2).eq.jj(2) .and. ii(3).eq.jj(3) )
     +		then
*
*	    symmetric - fewer possibilities
*
	    lsymm = .TRUE.
	else
	    lsymm = .FALSE.
	endif
*
*	try all (8.5,16)*16 permutations
*
	xmax = 0
	do 101 l=1,16
	    if ( lsymm ) then
		i0 = l
	    else
		i0 = 1
	    endif
	    do 100 i=i0,16
		ii1 = ii(iperm(1,i))
		ii2 = ii(iperm(2,i))
		ii3 = ii(iperm(3,i))
		j = i+l-1
		if ( j .gt. 16 ) j=j-16
		jj1 = jj(iperm(1,j))
		jj2 = jj(iperm(2,j))
		jj3 = jj(iperm(3,j))
		s(1) = +piDpj(ii1,jj1)*piDpj(ii2,jj2)*piDpj(ii3,jj3)
		s(2) = +piDpj(ii2,jj1)*piDpj(ii3,jj2)*piDpj(ii1,jj3)
		s(3) = +piDpj(ii3,jj1)*piDpj(ii1,jj2)*piDpj(ii2,jj3)
		s(4) = -piDpj(ii1,jj1)*piDpj(ii3,jj2)*piDpj(ii2,jj3)
		s(5) = -piDpj(ii3,jj1)*piDpj(ii2,jj2)*piDpj(ii1,jj3)
		s(6) = -piDpj(ii2,jj1)*piDpj(ii1,jj2)*piDpj(ii3,jj3)
		som = 0
		smax = 0
		do 80 k=1,6
		    som = som + s(k)
		    smax = max(smax,abs(som))
   80		continue
		if ( ns .eq. 15 .and. (i.gt.8 .neqv. j.gt.8) )
     +		    som = -som
		if ( i .eq. 1 .or. smax .lt. xmax ) then
		    dl3p = som
		    xmax = smax
		endif
		if ( lwrite ) then
		    print *,'dl3p = +',i-1+16*(l-1),' = ',som,smax
		endif
		if ( abs(dl3p) .ge. xloss*smax ) goto 110
  100	    continue
  101	continue
	if ( lwarn ) call ffwarn(138,ier,dl3p,xmax)
  110	continue
*  #] calculations:
*###] ffdl3p:
	end
*###[ ffdl2i:
	subroutine ffdl2i(dl2i,piDpj,ns,i1,i2,i3,isn,j1,j2,j3,jsn,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*	   p(i1) p(i2)		with	p(i3) = isn*(p(i1)+p(i2)	*
*	del				p(j3) = jsn*(p(j1)+p(j2)	*
*	   p(j1) p(j2)							*
*									*
*	ier is the usual error flag.					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ns,i1,i2,i3,isn,j1,j2,j3,jsn,ier
	DOUBLE PRECISION dl2i,piDpj(ns,ns)
*
*	local variables
*
	integer i
	DOUBLE PRECISION s1,s2,del2,xmax,xnul,xlosn
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffdl2i: arbitrary 2x2 p-like determinant'
	    print *,'in: '
	    print *,'i1,i2,i3,isn = ',i1,i2,i3,isn
	    print *,'j1,j2,j3,jsn = ',j1,j2,j3,jsn
	endif
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-2-mod(ier,50))
	    if ( abs(isn) .ne. 1 )
     +		print *,'ffdl2i: error: |isn| != 1 ',isn
	    if ( abs(jsn) .ne. 1 )
     +		print *,'ffdl2i: error: |jsn| != 1 ',jsn
	    do 10 i=1,ns
		xnul = piDpj(i1,i) + piDpj(i2,i) - isn*piDpj(i3,i)
		xmax = max(abs(piDpj(i1,i)),abs(piDpj(i2,i)))
		if ( xlosn*abs(xnul) .gt. precx*xmax ) print *,
     +		    'ffdl2i: dotproducts ',i1,i2,i3,' with ',i,
     +		    ' do not add to 0',piDpj(i1,i),piDpj(i2,i),
     +		    isn*piDpj(i3,i),xnul,ier
		xnul = piDpj(j1,i) + piDpj(j2,i) - jsn*piDpj(j3,i)
		xmax = max(abs(piDpj(j1,i)),abs(piDpj(j2,i)))
		if ( xlosn*abs(xnul) .gt. precx*xmax ) print *,
     +		    'ffdl2i: dotproducts ',j1,j2,j3,' with ',i,
     +		    ' do not add to 0',piDpj(j1,i),piDpj(j2,i),
     +		    jsn*piDpj(j3,i),xnul,ier
   10	    continue
	endif
*  #] check input:
*  #[ stupid tree:
*
*	calculations
*
	idsub = idsub + 1
*
*	stupid tree
*
	s1 = +piDpj(i1,j1)*piDpj(i2,j2)
	s2 = -piDpj(i1,j2)*piDpj(i2,j1)
	dl2i = s1 + s2
	xmax = abs(s1)
	if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	if ( lwrite ) print *,'dl2i+1= ',dl2i,xmax
*
	s1 = +piDpj(i1,j1)*piDpj(i3,j2)
	s2 = -piDpj(i1,j2)*piDpj(i3,j1)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+2= ',del2*isn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i3,j1)*piDpj(i2,j2)
	s2 = -piDpj(i3,j2)*piDpj(i2,j1)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+3= ',del2*isn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i1,j1)*piDpj(i2,j3)
	s2 = -piDpj(i1,j3)*piDpj(i2,j1)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+4= ',del2*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i1,j1)*piDpj(i3,j3)
	s2 = -piDpj(i1,j3)*piDpj(i3,j1)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+5= ',del2*isn*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i3,j1)*piDpj(i2,j3)
	s2 = -piDpj(i3,j3)*piDpj(i2,j1)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+6= ',del2*isn*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i1,j3)*piDpj(i2,j2)
	s2 = -piDpj(i1,j2)*piDpj(i2,j3)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+7= ',del2*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i1,j3)*piDpj(i3,j2)
	s2 = -piDpj(i1,j2)*piDpj(i3,j3)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+8= ',del2*isn*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	s1 = +piDpj(i3,j3)*piDpj(i2,j2)
	s2 = -piDpj(i3,j2)*piDpj(i2,j3)
	del2 = s1 + s2
	if ( lwrite ) print *,'dl2i+9= ',del2*isn*jsn,abs(s1)
	if ( abs(s1) .lt. xmax ) then
	    dl2i = del2*isn*jsn
	    xmax = abs(s1)
	    if ( abs(dl2i) .ge. xloss*xmax ) goto 100
	endif
*
	if ( lwarn ) call ffwarn(165,ier,dl2i,xmax)
*
  100	continue
*  #] stupid tree:
*###] ffdl2i:
	end
*###[ ffdl3q:
	subroutine ffdl3q(dl3q,piDpj,i1,i2,i3,j1,j2,j3,
     +		isn1,isn2,isn3,jsn1,jsn2,jsn3,ier)
***#[*comment:***********************************************************
*									*
*	calculate the 3x3 determinant					*
*									*
*	      p(i1) p(i2) p(i3)	      /	p(j1) = jsn1*(p(i1)-isn1*p(i2))	*
*	delta			 with |	p(j2) = jsn2*(p(i2)-isn2*p(i3))	*
*	      p5    p6    p7	      \	p(j3) = jsn3*(p(i3)-isn3*p(i1))	*
*									*
*	and piDpj(10,10) in standard four-point notation.		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer i1,i2,i3,j1,j2,j3,isn1,isn2,isn3,jsn1,jsn2,jsn3,ier
	DOUBLE PRECISION dl3q,piDpj(10,10)
*
*	local variables
*
	logical lset
	integer ier0,ier1
	DOUBLE PRECISION del2i(3),s(6),xmax,xmaxp,som
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ debug input:
	if ( lwrite ) then
	    print *,'ffdl3q: determinant delta(',i1,i2,i3,';5,6,7)'
	    print *,'input: i1,i2,i3 = ',i1,i2,i3
	    print *,'input: j1,j2,j3 = ',j1,j2,j3
	    print *,'input: isigns   = ',isn1,isn2,isn3
	    print *,'input: jsigns   = ',jsn1,jsn2,jsn3
	    print *,'(p(j1) = jsn1*(p(i1)-isn1*p(i2) etc.)'
	endif
*  #] debug input:
*  #[ first try:
*
	lset = .FALSE.
	if ( isn1 .eq. -1 ) then
	    ier1 = ier
	    if ( lwrite ) print *,'ffdl2i #1'
	    call ffdl2i(del2i(1),piDpj,10, i1,i2,j1,jsn1,6,7,10,+1,ier1)
	    if ( lwrite ) print *,'ffdl2t #2'
	    ier0 = ier
	    call ffdl2t(del2i(2),piDpj,7,5, i1,i2,j1,-jsn1,-1, 10,ier0)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'ffdl2i #3'
	    ier0 = ier
	    call ffdl2i(del2i(3),piDpj,10, i1,i2,j1,jsn1,5,6,9,-1,ier0)
	    ier1 = max(ier1,ier0)
	    s(1) = piDpj(i3,5)*del2i(1)
	    s(2) = piDpj(i3,6)*del2i(2)
	    s(3) = piDpj(i3,7)*del2i(3)
	    som = s(1) + s(2) + s(3)
	    xmax = DBLE(10)**(ier1-ier)*max(abs(s(1)),abs(s(2)),
     +	    	abs(s(3)))
	    dl3q = som
	    xmaxp = xmax
	    lset = .TRUE.
	    if ( lwrite ) then
		print *,'dl3q 1 = ',dl3q,xmax
		print *,'(s     = ',s(1),s(2),s(3),')'
	    endif
	    if ( abs(dl3q) .ge. xloss*xmax ) goto 900
	endif
	if ( isn2 .eq. -1 ) then
	    ier1 = ier
	    if ( lwrite ) print *,'ffdl2i #1'
	    call ffdl2i(del2i(1),piDpj,10, i2,i3,j2,jsn2,6,7,10,+1,ier1)
	    if ( lwrite ) print *,'ffdl2t #2'
	    ier0 = ier
	    call ffdl2t(del2i(2),piDpj,7,5, i2,i3,j2,-jsn2,-1, 10,ier0)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'ffdl2i #3'
	    ier0 = ier
	    call ffdl2i(del2i(3),piDpj,10, i2,i3,j2,jsn2,5,6,9,-1,ier0)
	    ier1 = max(ier1,ier0)
	    s(1) = piDpj(i1,5)*del2i(1)
	    s(2) = piDpj(i1,6)*del2i(2)
	    s(3) = piDpj(i1,7)*del2i(3)
	    som = s(1) + s(2) + s(3)
	    xmax = DBLE(10)**(ier1-ier)*max(abs(s(1)),abs(s(2)),
     +	    	abs(s(3)))
	    if ( .not.lset ) then
		dl3q = som
		xmaxp = xmax
		lset = .TRUE.
	    elseif ( xmax .lt. xmaxp ) then
		dl3q = som
		xmaxp = xmax
	    endif
	    if ( lwrite ) then
		print *,'dl3q 2 = ',som,xmax
		print *,'(s     = ',s(1),s(2),s(3),')'
	    endif
	    if ( abs(dl3q) .ge. xloss*xmax ) goto 900
	endif
	if ( isn3 .eq. -1 ) then
	    if ( lwrite ) print *,'ffdl2i #1'
	    ier1 = ier
	    call ffdl2i(del2i(1),piDpj,10, i3,i1,j3,jsn3,6,7,10,+1,ier1)
	    if ( lwrite ) print *,'ffdl2t #2'
	    ier0 = ier
	    call ffdl2t(del2i(2),piDpj,7,5, i3,i1,j3,-jsn3,-1, 10,ier0)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'ffdl2i #3'
	    ier0 = ier
	    call ffdl2i(del2i(3),piDpj,10, i3,i1,j3,jsn3,5,6,9,-1,ier0)
	    ier1 = max(ier1,ier0)
	    s(1) = piDpj(i2,5)*del2i(1)
	    s(2) = piDpj(i2,6)*del2i(2)
	    s(3) = piDpj(i2,7)*del2i(3)
	    som = s(1) + s(2) + s(3)
	    xmax = DBLE(10)**(ier1-ier)*max(abs(s(1)),abs(s(2)),
     +	    	abs(s(3)))
	    if ( .not.lset ) then
		dl3q = som
		xmaxp = xmax
		lset = .TRUE.
	    elseif ( xmax .lt. xmaxp ) then
		dl3q = som
		xmaxp = xmax
	    endif
	    if ( lwrite ) then
		print *,'dl3q 3 = ',som,xmax
		print *,'(s     = ',s(1),s(2),s(3),')'
	    endif
	    if ( abs(dl3q) .ge. xloss*xmax ) goto 900
	endif
*  #] first try:
*  #[ last try:
	if ( .not. lset ) then
	    s(1) = + piDpj(i1,5)*piDpj(i2,6)*piDpj(i3,7)
	    s(2) = - piDpj(i1,5)*piDpj(i2,7)*piDpj(i3,6)
	    s(3) = - piDpj(i1,6)*piDpj(i2,5)*piDpj(i3,7)
	    s(4) = + piDpj(i1,6)*piDpj(i2,7)*piDpj(i3,5)
	    s(5) = + piDpj(i1,7)*piDpj(i2,5)*piDpj(i3,6)
	    s(6) = - piDpj(i1,7)*piDpj(i2,6)*piDpj(i3,5)
	    dl3q = s(1) + s(2) + s(3) + s(4) + s(5) + s(6)
	    xmax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +		abs(s(5)),abs(s(6)))
	    if ( lwrite ) then
		print *,'dl3q 0 = ',dl3q,xmax
		print *,'(s     = ',s(1),s(2),s(3),s(4),s(5),s(6),')'
	    endif
	    if ( abs(dl3q) .ge. xloss*xmax ) goto 900
	endif
*  #] last try:
*  #[ final:
	if ( lwarn ) call ffwarn(166,ier,dl3q,xmax)
  900	continue
*  #] final:
*  #[ check output:
	if ( ltest ) then
	    s(1) = + piDpj(i1,5)*piDpj(i2,6)*piDpj(i3,7)
	    s(2) = - piDpj(i1,5)*piDpj(i2,7)*piDpj(i3,6)
	    s(3) = - piDpj(i1,6)*piDpj(i2,5)*piDpj(i3,7)
	    s(4) = + piDpj(i1,6)*piDpj(i2,7)*piDpj(i3,5)
	    s(5) = + piDpj(i1,7)*piDpj(i2,5)*piDpj(i3,6)
	    s(6) = - piDpj(i1,7)*piDpj(i2,6)*piDpj(i3,5)
	    som = s(1) + s(2) + s(3) + s(4) + s(5) + s(6)
	    xmaxp = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +		abs(s(5)),abs(s(6)))
	    if ( lwrite ) then
		print *,'dl3q = ',som,xmaxp
	    endif
	    if ( xloss*abs(som-dl3q) .gt. precx*max(xmax,xmaxp) ) then
		print *,'ffdl3q: error: answer does not agree with ',
     +		    'normal case: ',dl3q,som,max(xmax,xmaxp),dl3q-som
	    endif
	endif
*  #] check output:
*###] ffdl3q:
	end

*###[ ffdxc0:
	subroutine ffdxc0(cs3,ipi12,isoort,clogi,ilogi,xpi,dpipj,piDpj,
     +		xqi,dqiqj,qiDqj,sdel2,del2s,etalam,etami,delpsi,alph,
     +		ddel2s,ldel2s,npoin,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the difference of two threepoint functions		*
*	C(3,...a) - C(4,...b)						*
*	For this we not only calculate the roots of the three-point	*
*	function y,z(1-4,3-4,1-3) but also the combinations		*
*									*
*		yzzy = y(,4,)*z(,3,) - z(,4,)*y(,3,)			*
*	and								*
*		yyzz = y(,4,) - z(,4,) - y(,3,) + z(,3,)		*
*									*
*	This is done explicitly for most special cases, so a lot of	*
*	lines of code result.  This may be shortened with a smart use	*
*	of indices, however, it is readable now.			*
*									*
*	Input:	xpi(6,3:4)	(real)	transformed mi,pi squared in Ci	*
*		dpipj(6,6,3:4)	(real)	xpi(i)-xpi(j)			*
*		piDpj(6,6,3:4)	(real)	pi(i).pi(j)			*
*		xqi(10,10)	(real)	transformed mi,pi squared in D	*
*		dqiqj(10,10)	(real)	xqi(i)-xqi(j)			*
*		qiDqj(10,10)	(real)	qi(i).qi(j)			*
*		sdel2		(real)	sqrt(delta_{p_1 p_2}^{p_1 p_2})	*
*		del2s(3,3:4)	(real)	delta_{p_i s_i}^{p_i s_i}	*
*		etalam(3:4)	(real)	delta_{s_1 s_2 s_3}^{s_1 s_2 s_3}
*					  /delta_{p_1 p_2}^{p_1 p_2}	*
*		etami(6,3:4)	(real)	m_i^2 - etalam			*
*		ddel2s(2:3)	(real)	del2s(i,3) - del2s(i,4)		*
*		alph(3)		(real)	alph(1)=alpha, alph(3)=1-alpha	*
*		ldel2s	 (logical)	indicates yes/no limit del2s->0	*
*									*
*	Output: cs3	 (complex)(160)	C0(3)-C0(4), not yet summed.	*
*		ipi12	 (integer)(6)	factors pi^2/12, not yet summed	*
*		slam	 (complex)	lambda(p1,p2,p3).		*
*		isoort	 (integer)(16)	indication of he method used	*
*		clogi	 (complex)(6)	log(-dyz(2,1,i)/dyz(2,2,i))	*
*		ilogi	 (integer)(6)	factors i*pi in this		*
*		ier	 (integer)	0=ok, 1=inaccurate, 2=error	*
*									*
*	Calls:	...							*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(16),isoort(16),ilogi(6),npoin,ier
	logical ldel2s
	DOUBLE COMPLEX cs3(160),clogi(6)
	DOUBLE PRECISION xqi(10),dqiqj(10,10),qiDqj(10,10),
     +		xpi(6,3:4),dpipj(6,6,3:4),piDpj(6,6,3:4),
     +		sdel2,del2s(3,3:4),etalam(3:4),etami(6,3:4),alph(3),
     +		ddel2s(2:3),delpsi(3,3:4)
*
*	local variables:
*
	integer i,j,k,l,ip,ier0,ii,ifirst,ieri(12),idone(6)
	logical lcompl
	DOUBLE COMPLEX c,csom,chck,cs(5),csdeli(3,3:4),csdel2,
     +		cy(4,3:4,3),cz(4,3:4,3),cdyz(2,2,3:4,3),cd2yzz(3:4,3),
     +		cpi(6,3:4),cpiDpj(6,6,3:4),cdyzzy(4,3),cdyyzz(2,3)
	DOUBLE PRECISION sdel2i(3,3:4),s(5),som,smax,absc,dfflo1,xhck,
     +		rloss,y(4,3:4,3),z(4,3:4,3),dyz(2,2,3:4,3),d2yzz(3:4,3),
     +		dy2z(4,3:4,3),dyzzy(4,3),dsdel2,xmax
	DOUBLE COMPLEX zxfflg,zfflog,zfflo1
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations: 
*  #[ check input:
	if ( ltest ) then
*	    call ffxhck(xpi(1,3),dpipj(1,1,3),6,ier)
*	    call ffxhck(xpi(1,4),dpipj(1,1,4),6,ier)
	    call ffxhck(xqi,dqiqj,10,ier)
	endif
*  #] check input: 
*  #[ get y,z-roots:
	lcompl = .FALSE.
	if ( lwrite ) print '(a)','  ##[ get roots:'
	do 20 k=3,4
	do 10 i=1,3
*
*	get roots (y,z) and flag what to do: 0=nothing, 1=normal,
*	-1=complex
*
	ip = i+3
*	first get the roots
	if ( del2s(i,k) .le. 0 ) then
*	    real case
	    sdel2i(i,k) = sqrt(-del2s(i,k))
*	    then handle the special case Si = 0
	    if ( xpi(ip,k) .eq. 0 ) then
		if ( i .eq. 1 .and. alph(3) .eq. 0 .or.
     +		     i .eq. 3 .and. alph(1) .eq. 0 ) then
		    isoort(2*i-1+8*(k-3)) = 0
		    isoort(2*i+8*(k-3)) = 0
		    goto 10
		endif
	    endif
	    call ffxxyz(y(1,k,i),z(1,k,i),dyz(1,1,k,i),d2yzz(k,i),
     +		dy2z(1,k,i),i,sdel2,sdel2i(i,k),etalam(k),etami(1,k),
     +		delpsi(i,k),xpi(1,k),dpipj(1,1,k),piDpj(1,1,k),
     +		isoort(2*i-1+8*(k-3)),ldel2s,6,ier)
	else
*	    complex case
	    sdel2i(i,k) = sqrt(del2s(i,k))
	    csdeli(i,k) = DCMPLX(x0,sdel2i(i,k))
	    lcompl = .TRUE.
	    call ffcxyz(cy(1,k,i),cz(1,k,i),cdyz(1,1,k,i),cd2yzz(k,i),i,
     +		sdel2,sdel2i(i,k),etalam(k),etami(1,k),delpsi(i,k),xpi(
     +		1,k),piDpj(1,1,k),isoort(2*i-1+8*(k-3)),ldel2s,6,ier)
	endif
   10	continue
   20	continue
*  #] get y,z-roots: 
*  #[ convert to complex if necessary:
	do 60 i=2,3
	    l = 2*i-1
	    if ( isoort(l).gt.0 .and. isoort(l+8).lt.0 ) then
		k = 3
*		we get  -5, -105 if they have equal roots, isoort=+2
*			-6, -106 if they have unequal roots, isoort=+1
		if ( .not.ldel2s ) then
		    isoort(l) = isoort(l)-7
		    isoort(l+1) = isoort(l+1)-7
		else
		    isoort(l) = isoort(l)-207
		    isoort(l+1) = isoort(l+1)-207
		endif
	    elseif ( isoort(l).lt.0 .and. isoort(l+8).gt.0 ) then
		k = 4
		if ( .not.ldel2s ) then
		    isoort(l+8) = isoort(l+8)-7
		    isoort(l+9) = isoort(l+9)-7
		else
		    isoort(l+8) = isoort(l+8)-207
		    isoort(l+9) = isoort(l+9)-207
		endif
	    else
		k = 0
	    endif
	    if ( k .ne. 0 ) then
		if ( lwrite ) print *,'ffdxc0: converting i,k=',i,k,
     +			' to complex'
		do 30 j=1,4
		    cy(j,k,i) = y(j,k,i)
		    cz(j,k,i) = z(j,k,i)
   30		continue
		do 50 j=1,2
		    do 40 l=1,2
			cdyz(l,j,k,i) = dyz(l,j,k,i)
   40		    continue
   50		continue
		cd2yzz(k,i) = d2yzz(k,i)
		csdeli(i,k) = sdel2i(i,k)
	    endif
   60	continue
*  #] convert to complex if necessary: 
*  #[ get differences:
*
*	the only important differences are y4z3-z3y4 and (1-y4)(1-z3)-
*	(1-y3)(1-z4)
*
	do 100 i=1,12
	    ieri(i) = 0
  100	continue
*  #[	vertices (1):
	som = qiDqj(7,2)/sdel2
	if ( isoort(1) .ge. 0 ) then
*	    Note that the isoorts are equal as the vertex is equal.
*
*	    flag if we have a cancellation
*
	    if ( abs(som) .lt. xloss ) then
		isoort(1) = isoort(1) + 10
		isoort(9) = isoort(9) + 10
	    endif
	    do 110 k=1,4
		dyzzy(k,1) = som*z(k,3,1)
		if ( k .gt. 2 ) dyzzy(k,1) = -dyzzy(k,1)
  110	    continue
	else
	    if ( abs(som) .lt. xloss ) then
		isoort(1) = isoort(1) - 10
		isoort(9) = isoort(9) - 10
	    endif
	    do 120 k=1,4
		cdyzzy(k,1) = DBLE(som)*cz(k,3,1)
		if ( k .gt. 2 ) cdyzzy(k,1) = -cdyzzy(k,1)
  120	    continue
	    cdyyzz(1,1) = som
	    cdyyzz(2,1) = som
	    if ( lwrite ) then
		print *,'cdyyzz(1,1) =',cy(2,4,1)-cy(2,3,1)
		print *,'cdyyzz(1,1)+=',cdyyzz(1,1)
	    endif
	endif
*  #]	vertices (1): 
*  #[	vertices (2):
	if ( isoort(3) .ge. 0 ) then
*  #[	    real case: (note that this implies isoort(11)>0)
	    ifirst = 0
	    do 150 j=1,2
	    do 140 k=1,2
		ii = 2*(j-1) + k
		dyzzy(ii,2) = y(2*j,4,2)*z(ii,3,2)-y(2*j,3,2)*z(ii,4,2)
		xmax = abs(y(2*j,4,2)*z(ii,3,2))
		if ( abs(dyzzy(ii,2)) .ge. xmax ) goto 140
		isoort(3) = isoort(3) + 10
		isoort(11) = isoort(11) + 10
 1000		format(a,i1,a,g22.14,g12.4)
		if ( lwrite ) print 1000,'dyzzy(',ii,'2)  = ',
     +			dyzzy(ii,2),xmax
		if ( ldel2s ) then
		    print *,'ffdxc0: not ready for del2s=0, real case'
		    goto 130
		endif
		if ( ifirst .le. 0 ) then
		    if ( ddel2s(2) .eq. 0 ) then
			dsdel2 = 0
		    else
			dsdel2 = ddel2s(2)/(sdel2i(2,3)+sdel2i(2,4))
		    endif
		endif
		if ( ifirst .le. 1 ) then
		    if ( j .eq. 1 ) then
			s(1) = xqi(6)*qiDqj(7,4)*qiDqj(5,4)/sdel2
			s(2) = -qiDqj(7,4)*sdel2i(2,3)
			s(3) = +qiDqj(6,4)*dsdel2
		    else
			s(1) = xqi(6)*qiDqj(7,2)*qiDqj(5,2)/sdel2
			s(2) = -qiDqj(7,2)*sdel2i(2,3)
			s(3) = +qiDqj(6,2)*dsdel2
		    endif
		endif
		if ( ifirst .le. 0 ) then
		    ifirst = 2
		    s(4) = -qiDqj(5,10)*qiDqj(7,4)*sdel2i(2,3)/sdel2
		    s(5) = delpsi(2,3)*dsdel2/sdel2
		endif
		if ( k .eq. 1 ) then
		    som = s(1) + s(2) + s(3) + s(4) + s(5)
		else
		    som = s(1) - s(2) - s(3) - s(4) - s(5)
		endif
		smax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +			abs(s(5)))/xqi(6)**2
		if ( lwrite ) then
		    print 1000,'dyzzy(',ii,'2)+ = ',som/xqi(6)**2,smax
*		    print *,(s(i)/xqi(6)**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    dyzzy(ii,2) = som/xqi(6)**2
		    xmax = smax
		endif
  130		continue
		if ( lwarn .and. abs(dyzzy(ii,2)) .lt. xloss*xmax ) then
		    call ffwarn(140,ieri(2*k+j-2),dyzzy(ii,2),xmax)
		endif
  140	    continue
	    ifirst = ifirst - 1
  150	    continue
*  #]	    real case: 
	else
*  #[	    complex case:
	    ifirst = 0
	    do 180 j=1,2
	    do 170 k=1,2
		ii = 2*(j-1) + k
		cdyzzy(ii,2) = cy(2*j,4,2)*cz(ii,3,2)-cy(2*j,3,2)*
     +			cz(ii,4,2)
		xmax = absc(cy(2*j,4,2)*cz(ii,3,2))
		if ( absc(cdyzzy(ii,2)) .ge. xmax ) goto 170
		isoort(3) = isoort(3) - 10
		isoort(11) = isoort(11) - 10
 1002		format(a,i1,a,2g22.14,g12.4)
		if ( lwrite ) print 1002,'cdyzzy(',ii,'2)  =',
     +						cdyzzy(ii,2),xmax
		if ( ldel2s ) then
		    ip = 3
		else
		    ip = 6
		endif
		if ( mod(isoort(3),10).ne.0 .or. mod(isoort(11),10).ne.0
     +								) then
*
*		    one of the roots is really real
*
		    if ( ifirst .le. 0 ) then
			csdel2=DBLE(ddel2s(2))/(csdeli(2,3)+csdeli(2,4))
		    endif
		    if ( ifirst .le. 1 ) then
			if ( j .eq. 1 .neqv. ldel2s ) then
			    if ( .not.ldel2s ) then
				cs(1)=xqi(6)*qiDqj(7,4)*qiDqj(5,4)/sdel2
				cs(2) = -DBLE(qiDqj(7,4))*csdeli(2,3)
				cs(3) = +DBLE(qiDqj(6,4))*csdel2
			    else
				cs(1)=-xqi(3)*qiDqj(5,10)*qiDqj(7,2)/
     +								sdel2
				cs(2) = -DBLE(qiDqj(7,2))*csdeli(2,3)
				cs(3) = -DBLE(qiDqj(6,3))*csdel2
			    endif
			else
			    cs(1) = xqi(ip)*qiDqj(7,2)*qiDqj(5,2)/sdel2
			    cs(2) = -DBLE(qiDqj(7,2))*csdeli(2,3)
			    cs(3) = +DBLE(qiDqj(ip,2))*csdel2
			endif
		    endif
		    if ( ifirst .le. 0 ) then
			ifirst = 2
			if ( .not.ldel2s ) then
			    cs(4) = -DBLE(qiDqj(5,10)*qiDqj(7,4)/sdel2)*
     +				csdeli(2,3)
			else
			    cs(4) = -DBLE(qiDqj(5,3)*qiDqj(7,2)/sdel2)*
     +				csdeli(2,3)
			endif
			cs(5) = DBLE(delpsi(2,3)/sdel2)*csdel2
		    endif
		else
*
*		    both roots are complex
*
		    if ( ifirst .eq. 0 ) then
			dsdel2 = -ddel2s(2)/(sdel2i(2,3)+sdel2i(2,4))
			csdel2 = dsdel2
		    endif
		    if ( ifirst .le. 1 ) then
			if ( j .eq. 1 .neqv. ldel2s ) then
			    if ( .not.ldel2s ) then
				cs(1)=xqi(6)*qiDqj(7,4)*qiDqj(5,4)/sdel2
				cs(2)=-DCMPLX(x0,qiDqj(7,4)*sdel2i(2,3))
				cs(3)=+DCMPLX(x0,qiDqj(6,3)*dsdel2)
			    else
				cs(1)=-xqi(3)*qiDqj(5,10)*qiDqj(7,2)/
     +								sdel2
				cs(2)=-DCMPLX(x0,qiDqj(7,2)*sdel2i(2,3))
				cs(3)=-DCMPLX(x0,qiDqj(6,3)*dsdel2)
			    endif
			else
			    cs(1) = xqi(ip)*qiDqj(7,2)*qiDqj(5,2)/sdel2
			    cs(2) = -DCMPLX(x0,qiDqj(7,2)*sdel2i(2,3))
			    cs(3) = +DCMPLX(x0,qiDqj(ip,2)*dsdel2)
			endif
		    endif
		    if ( ifirst .eq. 0 ) then
			ifirst = 2
			if ( .not.ldel2s ) then
			    cs(4) = -DCMPLX(x0,qiDqj(5,10)*qiDqj(7,4)*
     +						sdel2i(2,3)/sdel2)
			else
			    cs(4) = -DCMPLX(x0,qiDqj(5,3)*qiDqj(7,2)*
     +						sdel2i(2,3)/sdel2)
			endif
			cs(5) = DCMPLX(x0,delpsi(2,3)*dsdel2/sdel2)
		    endif
		endif
		if ( k .eq. 1 ) then
		    csom = cs(1) + cs(2) + cs(3) + cs(4) + cs(5)
		else
		    csom = cs(1) - cs(2) - cs(3) - cs(4) - cs(5)
		endif
		smax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)),
     +			absc(cs(4)),absc(cs(5)))/xqi(ip)**2
		if ( lwrite ) then
		    print 1002,'cdyzzy(',ii,'2)+ =',csom/DBLE(xqi(ip))**
     +			2,smax
*		    print *,(cs(i)/DBLE(xqi(ip))**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    cdyzzy(ii,2) = csom/DBLE(xqi(ip))**2
		    xmax = smax
		endif
		if ( lwarn .and. absc(cdyzzy(ii,2)).lt.xloss*xmax ) then
		  call ffwarn(140,ieri(2*k+j-2),absc(cdyzzy(ii,2)),xmax)
		endif
  170	    continue
*
*	    get cdyyzz
*
	    if ( ldel2s ) then
		cdyyzz(j,2) = cdyz(2,j,4,2) - cdyz(2,j,3,2)
		xmax = absc(cdyz(2,j,4,2))
*		if ( absc(cdyyzz(j,2)) .ge. xloss*xmax ) goto 175
		if ( lwrite ) print 1002,'cdyyzz(',j,'2) =',cdyyzz(j,2),
     +			xmax
		if ( ifirst .le. 0 ) then
		    if ( mod(isoort( 3),10).ne.0 .or.
     +			 mod(isoort(11),10).ne.0 ) then
			csdel2=DBLE(ddel2s(2))/(csdeli(2,3)+csdeli(2,4))
		    else
			dsdel2 = -ddel2s(2)/(sdel2i(2,3)+sdel2i(2,4))
			csdel2 = dsdel2
		    endif
		endif
		cs(2) = csdel2/DBLE(xqi(3))
		cs(1) = qiDqj(5,3)*qiDqj(7,2)/(sdel2*xqi(3))
		if ( j .eq. 1 ) then
		    csom = cs(1) + cs(2)
		else
		    csom = cs(1) - cs(2)
		endif
		smax = absc(cs(1))
		if ( lwrite ) print 1002,'cdyyzz(',j,'2)+=',csom,smax
		if ( smax .lt. xmax ) then
		    cdyyzz(j,2) = csom
		    xmax = smax
		endif
		if ( lwarn .and. absc(cdyyzz(j,2)).lt.xloss*xmax ) then
		    call ffwarn(147,ieri(7+j),absc(cdyyzz(j,2)),xmax)
		endif
	    endif
*
*	    bookkeeping
*
  175	    continue
	    ifirst = ifirst - 1
  180	    continue
*  #]	    complex case: 
	endif
*  #]	vertices (2): 
*  #[	vertices (3):
	if ( isoort(5) .ge. 0 ) then
*  #[	    real case: (note that this implies isoort(15)>0)
	    ifirst = 0
	    do 210 j=1,2
	    do 200 k=1,2
		ii = 2*(j-1) + k
		dyzzy(ii,3) = y(2*j,4,3)*z(ii,3,3)-y(2*j,3,3)*z(ii,4,3)
		xmax = abs(y(2*j,4,3)*z(ii,3,3))
		if ( abs(dyzzy(ii,3)) .ge. xmax ) goto 200
		isoort(5) = isoort(5) + 10
		isoort(13) = isoort(13) + 10
		if ( lwrite ) print 1000,'dyzzy(',ii,'3)  = ',
     +			dyzzy(ii,3),xmax
		if ( ldel2s ) then
		    print *,'ffdxc0: not ready for del2s=0, real case'
		    goto 190
		endif
		if ( ifirst .le. 0 ) then
		    if ( ddel2s(2) .eq. 0 ) then
			dsdel2 = 0
		    else
			dsdel2 = ddel2s(3)/(sdel2i(3,3)+sdel2i(3,4))
		    endif
		endif
		if ( ifirst .le. 1 ) then
		    if ( j .eq. 1 ) then
			s(1) = xqi(8)*qiDqj(7,1)*qiDqj(5,1)/sdel2
			s(2) = +qiDqj(7,1)*sdel2i(3,3)
			s(3) = +qiDqj(9,1)*dsdel2
		    else
			s(1) = xqi(8)*qiDqj(7,4)*qiDqj(5,4)/sdel2
			s(2) = +qiDqj(7,4)*sdel2i(3,3)
			s(3) = +qiDqj(9,4)*dsdel2
		    endif
		endif
		if ( ifirst .le. 0 ) then
		    ifirst = 2
		    s(4) = -qiDqj(5,9)*qiDqj(7,1)*sdel2i(3,3)/sdel2
		    s(5) = delpsi(3,3)*dsdel2/sdel2
		endif
		if ( k .eq. 1 ) then
		    som = s(1) + s(2) + s(3) + s(4) + s(5)
		else
		    som = s(1) - s(2) - s(3) - s(4) - s(5)
		endif
		smax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +			abs(s(5)))/xqi(8)**2
		if ( lwrite ) then
		    print 1000,'dyzzy(',ii,'3)+ = ',som/xqi(8)**2,smax
*		    print *,(s(i)/xqi(8)**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    dyzzy(ii,3) = som/xqi(8)**2
		    xmax = smax
		endif
  190		continue
		if ( lwarn .and. abs(dyzzy(ii,3)) .lt. xloss*xmax ) then
		    call ffwarn(140,ieri(2*k+j+2),dyzzy(ii,3),xmax)
		endif
  200	    continue
	    ifirst = ifirst - 1
  210	    continue
*  #]	    real case: 
	else
*  #[	    complex case:
	    ifirst = 0
	    do 240 j=1,2
	    do 230 k=1,2
		ii = 2*(j-1) + k
		cdyzzy(ii,3) = cy(2*j,4,3)*cz(ii,3,3)-cy(2*j,3,3)*
     +			cz(ii,4,3)
		xmax = absc(cy(2*j,4,3)*cz(ii,3,3))
		if ( absc(cdyzzy(ii,3)) .ge. xmax ) goto 230
		isoort(5) = isoort(5) - 10
		isoort(13) = isoort(13) - 10
		if ( lwrite ) print 1002,'cdyzzy(',ii,'3)  =',
     +						cdyzzy(ii,3),xmax
		if ( ldel2s ) then
		    ip = 3
		else
		    ip = 8
		endif
		if ( mod(isoort(3),10).ne.0 .or. mod(isoort(11),10).ne.0
     +								) then
*
*		    one of the roots is really real
*
		    if ( ifirst .le. 0 ) then
			csdel2=DBLE(ddel2s(3))/(csdeli(3,3)+csdeli(3,4))
		    endif
		    if ( ifirst .le. 1 ) then
			if ( j .eq. 1 ) then
			    cs(1) = xqi(ip)*qiDqj(7,1)*qiDqj(5,1)/sdel2
			    cs(2) = +DBLE(qiDqj(7,1))*csdeli(3,3)
			    if ( .not.ldel2s ) then
				cs(3) = +DBLE(qiDqj(9,1))*csdel2
			    else
				cs(3) = +DBLE(qiDqj(3,1))*csdel2
			    endif
			else
			    if ( .not.ldel2s ) then
				cs(1) = xqi(ip)*qiDqj(7,4)*qiDqj(5,4)/
     +								sdel2
				cs(2) = DBLE(qiDqj(7,4))*csdeli(3,3)
			    else
				cs(1) = xqi(ip)*qiDqj(7,1)*qiDqj(5,9)/
     +								sdel2
				cs(2) = DBLE(qiDqj(7,1))*csdeli(3,3)
			    endif
			    cs(3) = +DBLE(qiDqj(9,3))*csdel2
			endif
			if ( ldel2s ) cs(3) = -cs(3)
		    endif
		    if ( ifirst .le. 0 ) then
			ifirst = 2
			if ( .not.ldel2s ) then
			    cs(4) = -DBLE(qiDqj(5,9)*qiDqj(7,1)/sdel2)*
     +				csdeli(3,3)
			else
			    cs(4) = DBLE(qiDqj(5,4)*qiDqj(7,1)/sdel2)*
     +				csdeli(3,3)
			endif
			cs(5) = DBLE(delpsi(3,3)/sdel2)*csdel2
		    endif
		else
*
*		    both roots are complex
*
		    if ( ifirst .eq. 0 ) then
			dsdel2 = -ddel2s(3)/(sdel2i(3,3)+sdel2i(3,4))
			csdel2 = dsdel2
		    endif
		    if ( ifirst .le. 1 ) then
			if ( j .eq. 1 ) then
			    cs(1) = xqi(ip)*qiDqj(7,1)*qiDqj(5,1)/sdel2
			    cs(2) = +DCMPLX(x0,qiDqj(7,1)*sdel2i(3,3))
			    if ( .not.ldel2s ) then
				cs(3) = +DCMPLX(x0,qiDqj(9,1)*dsdel2)
			    else
				cs(3) = +DCMPLX(x0,qiDqj(3,1)*dsdel2)
			    endif
			else
			    if ( .not.ldel2s ) then
				cs(1) = xqi(ip)*qiDqj(7,4)*qiDqj(5,4)/
     +								sdel2
				cs(2) =DCMPLX(x0,qiDqj(7,4)*sdel2i(3,3))
			    else
				cs(1) = xqi(ip)*qiDqj(7,1)*qiDqj(5,9)/
     +								sdel2
				cs(2) =DCMPLX(x0,qiDqj(7,1)*sdel2i(3,3))
			    endif
			    cs(3) = +DCMPLX(x0,qiDqj(9,3)*dsdel2)
			endif
			if ( ldel2s ) cs(3) = -cs(3)
		    endif
		    if ( ifirst .le. 0 ) then
			ifirst = 2
			if ( .not.ldel2s ) then
			    cs(4) = -DCMPLX(x0,qiDqj(5,9)*qiDqj(7,1)*
     +						sdel2i(3,3)/sdel2)
			else
			    cs(4) = DCMPLX(x0,qiDqj(5,4)*qiDqj(7,1)*
     +						sdel2i(3,3)/sdel2)
			endif
			cs(5) = DCMPLX(x0,delpsi(3,3)*dsdel2/sdel2)
		    endif
		endif
		if ( k .eq. 1 ) then
		    csom = cs(1) + cs(2) + cs(3) + cs(4) + cs(5)
		else
		    csom = cs(1) - cs(2) - cs(3) - cs(4) - cs(5)
		endif
		smax =max(absc(cs(1)),absc(cs(2)),absc(cs(3)),
     +			absc(cs(4)),absc(cs(5)))/xqi(ip)**2
		if ( lwrite ) then
		    print 1002,'cdyzzy(',ii,'3)+ =',csom/DBLE(xqi(ip))**
     +			2,smax
*		    print *,(cs(i)/DBLE(xqi(ip))**2,i=1,5)
		endif
		if ( smax .lt. xmax ) then
		    cdyzzy(ii,3) = csom/DBLE(xqi(ip))**2
		    xmax = smax
		endif
		if ( lwarn .and. absc(cdyzzy(ii,3)).lt.xloss*xmax ) then
		  call ffwarn(140,ieri(2*k+j+2),absc(cdyzzy(ii,3)),xmax)
		endif
  230	    continue
*
*	    get cdyyzz
*
	    if ( ldel2s ) then
		cdyyzz(j,3) = cdyz(2,j,4,3) - cdyz(2,j,3,3)
		xmax = absc(cdyz(2,j,4,3))
*		if ( absc(cdyyzz(j,3)) .ge. xloss*xmax ) goto 235
		if ( lwrite ) print 1002,'cdyyzz(',j,'3) =',cdyyzz(j,3),
     +			xmax
		if ( ifirst .le. 0 ) then
		    if ( mod(isoort( 5),10).ne.0 .or.
     +			 mod(isoort(13),10).ne.0 ) then
			csdel2=DBLE(ddel2s(3))/(csdeli(3,3)+csdeli(3,4))
		    else
			dsdel2 = -ddel2s(3)/(sdel2i(3,3)+sdel2i(3,4))
			csdel2 = dsdel2
		    endif
		endif
		cs(2) = -csdel2/DBLE(xqi(3))
		cs(1) = qiDqj(5,3)*qiDqj(7,1)/(sdel2*xqi(3))
		if ( j .eq. 1 ) then
		    csom = cs(1) + cs(2)
		else
		    csom = cs(1) - cs(2)
		endif
		smax = absc(cs(1))
		if ( lwrite ) print 1002,'cdyyzz(',j,'3)+=',csom,smax
		if ( smax .lt. xmax ) then
		    cdyyzz(j,3) = csom
		    xmax = smax
		endif
		if ( lwarn .and. absc(cdyyzz(j,3)).lt.xloss*xmax ) then
		    call ffwarn(147,ieri(9+j),absc(cdyyzz(j,3)),xmax)
		endif
	    endif
*
*	    bookkeeping
*
  235	    continue
	    ifirst = ifirst - 1
  240	    continue
*  #]	    complex case: 
	endif
*  #]	vertices (3): 
	ier0 = 0
	do 250 i = 1,12
	   ier0 = max(ier0,ieri(i))
  250	continue
	ier = ier + ier0
*  #] get differences: 
*  #[ check differences:
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    do 300 i=1,3
		if ( isoort(2*i-1) .ne. isoort(2*i+7) ) goto 300
		do 290 j=1,2
		    if ( isoort(2*i-1) .ge. 0 ) then
			xhck = dyzzy(j,i) - y(2,4,i)*z(j,3,i)
     +				      + z(j,4,i)*y(2,3,i)
			if ( rloss*abs(xhck) .gt. precx*max(
     +				abs(y(2,4,i)*z(j,3,i)),
     +				abs(z(j,4,i)*y(2,3,i))) ) print *,
     +			'ffdxc0: error: ','dyzzy(',j,i,') <> terms, ',
     +				dyzzy(j,i),y(2,4,i)*z(j,3,i),
     +				z(j,4,i)*y(2,3,i),xhck
			xhck = dyzzy(j+2,i) - y(4,4,i)*z(j+2,3,i)
     +				       + z(j+2,4,i)*y(4,3,i)
			if ( rloss*abs(xhck) .gt. precx*max(
     +				abs(y(4,4,i)*z(j+2,3,i)),
     +				abs(z(j+2,4,i)*y(4,3,i))) ) print *,
     +			'ffdxc0: error: ','dyzzy(',j+2,i,') <> terms, ',
     +				dyzzy(j+2,i),y(4,4,i)*z(j+2,3,i),
     +				z(j+2,4,i)*y(4,3,i),xhck
		    else
			chck = cdyzzy(j,i) - cy(2,4,i)*cz(j,3,i)
     +				      + cz(j,4,i)*cy(2,3,i)
			if ( rloss*absc(chck) .gt. precc*max(
     +				abs(cy(2,4,i)*cz(j,3,i)),
     +				abs(cz(j,4,i)*cy(2,3,i))) ) print *,
     +			'ffdxc0: error: ','cdyzzy(',j,i,') <> terms, ',
     +				cdyzzy(j,i),cy(2,4,i)*cz(j,3,i),
     +				cz(j,4,i)*cy(2,3,i),chck
			chck = cdyzzy(j+2,i) - cy(4,4,i)*cz(j+2,3,i)
     +				       + cz(j+2,4,i)*cy(4,3,i)
			if ( rloss*absc(chck) .gt. precc*max(
     +				abs(cy(4,4,i)*cz(j+2,3,i)),
     +				abs(cz(j+2,4,i)*cy(4,3,i))) ) print *,
     +			'ffdxc0: error: ','cdyzzy(',j+2,i,') <> terms,',
     +				cdyzzy(j+2,i),cy(4,4,i)*cz(j+2,3,i),
     +				cz(j+2,4,i)*cy(4,3,i),chck
		    endif
  290		continue
  300	    continue
	endif
*  #] check differences: 
*  #[ write output:
	if ( lwrite ) then
	    print *,'ffdxc0: found roots:'
	    do 320 k=3,4
	    do 310 i=1,3
		print *,'  k = ',i
		if ( isoort(2*i+8*(k-3)) .gt. 0 ) then
		    print *,'  ym,ym1 = ',y(1,k,i),y(3,k,i),
     +			' (not used)'
		    print *,'  yp,yp1 = ',y(2,k,i),y(4,k,i)
		    print *,'  zm,zm1 = ',z(1,k,i),z(3,k,i)
		    print *,'  zp,zp1 = ',z(2,k,i),z(4,k,i)
		elseif ( isoort(2*i+8*(k-3)) .eq. 0 ) then
		    if ( isoort(2*i-1+8*(k-3)) .eq. 0 ) then
			print *,'  no roots, all is zero'
		    else
			print *,'  yp,yp1 = ',y(2,k,i),y(4,k,i)
			print *,'  zp,zp1 = ',z(2,k,i),z(4,k,i)
		    endif
		else
		    print *,'  cym,cym1 = ',cy(1,k,i),cy(3,k,i),
     +			'(not used)'
		    print *,'  cyp,cyp1 = ',cy(2,k,i),cy(4,k,i)
		    print *,'  czm,czm1 = ',cz(1,k,i),cz(3,k,i)
		    print *,'  czp,czp1 = ',cz(2,k,i),cz(4,k,i)
		endif
  310	    continue
  320	    continue
	endif
	if ( lwrite ) print '(a)','  ##] get roots:'
*  #] write output: 
*  #[ logarithms for 4point function:
*
*	Not yet made stable ...
*
	if ( npoin .eq. 4 ) then
	if ( lwrite ) print '(a)','  ##[ logarithms for Ai<0:'
	do 420 i = 1,3
	do 410 k = 3,4
	    ii = i+3*(k-3)
	    if ( ilogi(ii) .ne. -999 ) then
		idone(ii) = 0
		goto 410
	    endif
	    l = 2*i+8*(k-3)-1
	    if ((isoort(l).gt.0 .or. mod(isoort(l),10).le.-5) .and.
     +		(isoort(l+1).ge.0 .or. mod(isoort(l+1),10).le.-5)) then
*  #[		real case:
*
*		the real case (isoort=-5,-6: really real but complex for ffdcs)
*
		s(1) = -dyz(2,1,k,i)/dyz(2,2,k,i)
		if ( lwrite ) then
*		    fantasize imag part, but suppress error message
		    clogi(ii) = zxfflg(s(1),1,x1,ier0)
		    print *,'clogi  = ',clogi(ii)
		endif
		if ( abs(s(1)-1) .lt. xloss ) then
		    clogi(ii) = dfflo1(d2yzz(k,i)/dyz(2,2,k,i),ier)
		    ilogi(ii) = 0
		else
		    if ( abs(s(1)+1) .lt. xloss ) then
			clogi(ii) = dfflo1(-2*sdel2i(i,k)/(xpi(i+3,k)*
     +				dyz(2,2,k,i)),ier)
		    else
			clogi(ii) = zxfflg(abs(s(1)),0,x0,ier)
		    endif
		    if ( dyz(2,2,k,i).gt.0 .and. dyz(2,1,k,i).gt.0 )
     +								then
			ilogi(ii) = -1
		    elseif ( dyz(2,1,k,i).lt.0 .and. dyz(2,2,k,i).lt.0)
     +								then
			ilogi(ii) = +1
		    else
			ilogi(ii) = 0
		    endif
*		    in case del2s=0 and i=3 we pick up a minus sign, I think
		    if ( ldel2s .and. i .eq. 3 ) ilogi(ii) = -ilogi(ii)
		endif
		if ( lwrite ) print *,'clogi+ = ',clogi(ii)+
     +			DCMPLX(x0,pi)*ilogi(ii)
		idone(ii) = 1
*  #]		real case: 
	    elseif ( isoort(l) .lt. 0 ) then
*  #[		complex case:
*		for stability split the unit circle up in 4*pi/2
*		(this may have to be improved to 8*pi/4...)
*
		ier0 = 0
		if ( lwrite ) then
		    if ( abs(DBLE(cdyz(2,1,k,i))) .lt. xalog2 .or.
     +			abs(DIMAG(cdyz(2,2,k,i))) .lt. xalog2 ) then
			csom = -DCMPLX(DBLE(cdyz(2,1,k,i))/xalog2,DIMAG(
     +				cdyz(2,1,k,i))/xalog2) /DCMPLX(DBLE(cdyz
     +				(2,2,k,i))/xalog2,DIMAG(cdyz(2,2,k,i))/
     +				xalog2)
		    else
			csom = -cdyz(2,1,k,i)/cdyz(2,2,k,i)
		    endif
		    clogi(ii)=zfflog(csom,0,c0,ier0)
		    print *,'clogi = ',clogi(ii)
		endif
		if ( DBLE(cdyz(2,1,k,i)) .gt. abs(DIMAG(cdyz(2,1,k,i))))
     +								then
		    som =2*atan2(DIMAG(cdyz(2,1,k,i)),DBLE(
     +							cdyz(2,1,k,i)))
		    clogi(ii) = DCMPLX(x0,som)
		    if ( DIMAG(cdyz(2,1,k,i)) .gt. 0 ) then
			ilogi(ii) = -1
		    else
			ilogi(ii) = +1
		    endif

		elseif ( DBLE(cdyz(2,1,k,i)) .lt. -DIMAG(cdyz(2,1,k,i)))
     +								then
		    if ( DIMAG(cdyz(2,1,k,i)) .eq. 0 ) then
		    	call fferr(82,ier)
			print *,'isoort = ',isoort(l),isoort(l+1)
		    endif
		    som = 2*atan2(-DIMAG(cdyz(2,1,k,i)),-DBLE(
     +							cdyz(2,1,k,i)))
		    clogi(ii) = DCMPLX(x0,som)
		    ilogi(ii) = 1
		else
		    s(1) = -DBLE(cdyz(2,1,k,i))
		    s(2) = DIMAG(cdyz(2,1,k,i))
		    som = 2*atan2(s(1),s(2))
		    clogi(ii) = DCMPLX(x0,som)
		    ilogi(ii) = 0
		endif
		if ( lwrite ) print *,'clogi+= ',clogi(ii)+
     +			DCMPLX(x0,pi)*ilogi(ii)
		idone(ii) = 1
*  #]		complex case: 
	    endif
*	    Note that we generate an error if isoort(l)=0
	    if ( lwrite ) print *,ii,': ',clogi(ii),' + ',ilogi(ii),
     +		'*i*pi'
  410	continue
	if ( idone(ii) .ne. 0 .and. idone(ii-3) .ne. 0 .and.
     +	     absc(clogi(ii)-clogi(ii-3)) .lt. absc(clogi(ii)) ) then
*  #[	    subtract more smartly:
	    if ( isoort(l).gt.0 .and. isoort(l+1).ge.0 ) then
		if ( lwrite ) print *,'ffdxc0: extra logs not ready ',
     +			'in the real case'
		goto 420
	    else
		cs(1) = cdyzzy(1,i)
		cs(2) = cdyzzy(2,i)
		if ( i .eq. 1 ) then
		    cs(3) = 0
		else
		    if ( lwrite ) print *,'ffdxc0: extra logs not ',
     +			'ready for i <>1'
		    goto 420
		endif
		csom = cs(1) - cs(2) + cs(3)
		xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)))
*		change this to "no warning and quit" later
		if ( lwarn .and. absc(csom) .lt. xmax ) then
		     call ffwarn(148,ier,absc(csom),xmax)
		endif
		if ( lwrite ) print *,'som was : ',clogi(ii-3)-clogi(ii)
		c = csom/(cdyz(2,2,3,i)*cdyz(2,1,4,i))
		clogi(ii-3) = zfflo1(c,ier)
		clogi(ii) = 0
		if ( lwrite ) print *,'som is  : ',clogi(ii-3)-clogi(ii)
	    endif
*  #]	    subtract more smartly: 
	endif
  420	continue
*	An algorithm to obtain the sum of two small logarithms more
*	accurately has been put in ffcc0p, not yet here
	if ( lwrite ) print '(a)','  ##] logarithms for Ai<0:'
	endif
*  #] logarithms for 4point function: 
*  #[ real case integrals:
	if ( .not. lcompl ) then
*	    normal case
	    do 510 i=1,3
		if ( lwrite ) print '(a,i1,a)','  ##[ dxs nr ',i,':'
		j = 2*i-1
		if ( isoort(j) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j),isoort(j+1)
		    endif
		    if ( isoort(j+8) .eq. 0 ) then
			if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j+8),isoort(j+9)
			endif
		    else
			call ffcxs3(cs3(20*i+61),ipi12(j+8),y(1,4,i),
     +			   z(1,4,i),dyz(1,1,4,i),d2yzz(4,i),dy2z(1,4,i),
     +			   xpi(1,4),piDpj(1,1,4),i,6,isoort(j+8),ier)
		    endif
		elseif ( isoort(j+8) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j),isoort(j+1)
		    endif
		    call ffcxs3(cs3(20*i-19),ipi12(j),y(1,3,i),
     +			   z(1,3,i),dyz(1,1,3,i),d2yzz(3,i),dy2z(1,3,i),
     +			   xpi(1,3),piDpj(1,1,3),i,6,isoort(j),ier)
		else
		    call ffdcxs(cs3(20*i-19),ipi12(j),y(1,3,i),z(1,3,i),
     +			dyz(1,1,3,i),d2yzz(3,i),dy2z(1,3,i),dyzzy(1,i),
     +			xpi,piDpj,i,6,isoort(j),ier)
		endif
		if ( lwrite ) print '(a,i1,a)','  ##] dxs nr ',i,':'
  510	    continue
	    isoort(7) = 0
	    isoort(8) = 0
*  #] real case integrals: 
*  #[ complex case integrals:
	else
*	    convert xpi
	    do 540 k=3,4
*not	    cetami(1,k) = etami(1,k)
*used	    cetami(3,k) = etami(3,k)
	    do 530 i=1,6
		cpi(i,k) = xpi(i,k)
		do 520 j=1,6
		    cpiDpj(j,i,k) = piDpj(j,i,k)
  520		continue
  530	    continue
  540	    continue
	    do 550 i=1,3
		if ( lwrite ) print '(a,i1,a)','  ##[ dcs nr ',i,':'
		j = 2*i-1
		if ( isoort(j) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j),isoort(j+1)
		    endif
		    if ( isoort(j+8) .eq. 0 ) then
			if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j+8),isoort(j+9)
			endif
		    else
			call ffcxs3(cs3(20*i+61),ipi12(j+8),y(1,4,i),
     +			   z(1,4,i),dyz(1,1,4,i),d2yzz(4,i),dy2z(1,4,i),
     +			   xpi(1,4),piDpj(1,1,4),i,6,isoort(j+8),ier)
		    endif
		elseif ( isoort(j+8) .eq. 0 ) then
		    if ( lwrite ) then
			print *,'ffdxc0: xk=0, ma=mb/Si-0 -> S3 = 0'
			print *,'isoort:',isoort(j),isoort(j+1)
		    endif
		    call ffcxs3(cs3(20*i-19),ipi12(j),y(1,3,i),
     +			   z(1,3,i),dyz(1,1,3,i),d2yzz(3,i),dy2z(1,3,i),
     +			   xpi(1,3),piDpj(1,1,3),i,6,isoort(j),ier)
		elseif ( isoort(j) .gt. 0 ) then
		    if ( isoort(j+8) .gt. 0 ) then
			call ffdcxs(cs3(20*i-19),ipi12(j),y(1,3,i),
     +			   z(1,3,i),dyz(1,1,3,i),d2yzz(3,i),dy2z(1,3,i),
     +			   dyzzy(1,i),xpi,piDpj,i,6,isoort(j),ier)
		    else
			print *,'ffdxc0: error: should not occur!'
			call ffcxs3(cs3(20*i-19),ipi12(j),y(1,3,i),
     +			   z(1,3,i),dyz(1,1,3,i),d2yzz(3,i),dy2z(1,3,i),
     +			   xpi(1,3),piDpj(1,1,3),i,6,isoort(j),ier)
			call ffcs3(cs3(20*i+61),ipi12(j+8),cy(1,4,i),
     +			    cz(1,4,i),cdyz(1,1,4,i),cd2yzz(4,i),
     +			    cpi(1,4),cpiDpj(1,1,4),i,6,isoort(j+8),ier)
		    endif
		else
		    if ( isoort(j+8) .lt. 0 ) then
			call ffdcs(cs3(20*i-19),ipi12(j),cy(1,3,i),
     +			    cz(1,3,i),cdyz(1,1,3,i),cd2yzz(3,i),
     +			    cdyzzy(1,i),cdyyzz(1,i),cpi,cpiDpj,
     +			    i,6,isoort(j),ier)
		    else
			print *,'ffdxc0: error: should not occur!'
			call ffcs3(cs3(20*i-19),ipi12(j),cy(1,3,i),
     +			    cz(1,3,i),cdyz(1,1,3,i),cd2yzz(3,i),
     +			    cpi(1,3),cpiDpj(1,1,3),i,6,isoort(j),ier)
			call ffcxs3(cs3(20*i+61),ipi12(j+8),y(1,4,i),
     +			   z(1,4,i),dyz(1,1,4,i),d2yzz(4,i),dy2z(1,4,i),
     +			   xpi(1,4),piDpj(1,1,4),i,6,isoort(j+8),ier)
		    endif
		endif
		if ( lwrite ) print '(a,i1,a)','  ##] dcs nr ',i,':'
  550	    continue
	    isoort(7) = 0
	    isoort(8) = 0
	endif
	return
*  #] complex case integrals: 
*###] ffdxc0: 
	end
*###[ ffinit:
	subroutine ffinit
***#[*comment:***********************************************************
*	calculate a lot of commonly-used constants in the common block	*
*	/ffcnst/. also set the precision, maximum loss of digits and	*
*	the minimum value the logarithm accepts in /prec/.		*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer i,j,init,ioldp(13,12),isgrop(10,12)
	save init
	DOUBLE PRECISION s,sold
	DOUBLE COMPLEX cs
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
	data init /0/
	data ioldp/1,2,3,4, 5,6,7,8,9,10, 11,12,13,
     +		   4,1,2,3, 8,5,6,7,10,9, 11,13,12,
     +		   3,4,1,2, 7,8,5,6,9,10, 11,12,13,
     +		   2,3,4,1, 6,7,8,5,10,9, 11,13,12,
     +		   4,2,3,1, 10,6,9,8,7,5, 12,11,13,
     +		   1,3,2,4, 9,6,10,8,5,7, 12,11,13,
     +		   1,2,4,3, 5,10,7,9,8,6, 13,12,11,
     +		   1,4,3,2, 8,7,6,5,9,10, 11,13,12,
     +		   3,4,2,1, 7,10,5,9,6,8, 13,12,11,
     +		   2,3,1,4, 6,9,8,10,5,7, 12,13,11,
     +		   4,2,1,3, 10,5,9,7,8,6, 13,11,12,
     +		   1,3,4,2, 9,7,10,5,8,6, 13,11,12/
	data isgrop/
     +		+1,+1,+1,+1, +1,+1,+1,+1, +1,+1,
     +		+1,+1,+1,+1, +1,+1,+1,+1, -1,+1,
     +		+1,+1,+1,+1, +1,+1,+1,+1, -1,-1,
     +		+1,+1,+1,+1, +1,+1,+1,+1, +1,-1,
     +		+1,+1,+1,+1, -1,+1,+1,-1, +1,-1,
     +		+1,+1,+1,+1, -1,-1,+1,+1, -1,+1,
     +		+1,+1,+1,+1, +1,+1,-1,+1, +1,+1,
     +		+1,+1,+1,+1, -1,-1,-1,-1, +1,-1,
     +		+1,+1,+1,+1, -1,+1,+1,+1, -1,-1,
     +		+1,+1,+1,+1, +1,+1,+1,-1, +1,-1,
     +		+1,+1,+1,+1, -1,+1,+1,-1, -1,-1,
     +		+1,+1,+1,+1, -1,-1,+1,+1, -1,-1/
*  #] declarations:
*  #[ check:
*	check whether tehre is anything to do
	if ( init .ne. 0 ) return
	init = 1
	print *,'===================================================='
	print *,'    FF, a package to evaluate one-loop integrals'
	print *,'written by G. J. van Oldenborgh, NIKHEF-H, Amsterdam'
	print *,'===================================================='
	print *,'for the algorithms used see preprint NIKHEF-H 89/17,'
	print *,'''New Algorithms for One-loop Integrals'', by G.J. van'
	print *,'Oldenborgh and J.A.M. Vermaseren, published in '
	print *,'Zeitschrift fuer Physik C46(1990)425.'
	print *,'===================================================='
*  #] check:
*  #[ precision etc:
	lwrite = .TRUE.
	nevent = -1
*
*	the loss of accuracy in any single subtraction at which
*	(timeconsuming) corrective action is to be taken is
*
	xloss = 0.125
*
*	the precision to which real calculations are done is
*
	precx = 1
	sold = 0
	do 1 i=1,1000
	    precx = precx/2
	    s = exp(log(1+precx))
	    if ( s .eq. sold ) goto 2
	    sold = s
    1	continue
    2	continue
	precx = precx*8
*	(take three bits for safety)
	if ( lwrite ) print *,'ffinit: precx = ',precx
*
*	the precision to which complex calculations are done is
*
	precc = 1
	sold = 0
	do 3 i=1,1000
	    precc = precc/2
	    cs = exp(log(DCMPLX(1+precc,x0)))
	    if ( DBLE(cs) .eq. sold ) goto 4
	    sold = DBLE(cs)
    3	continue
    4	continue
	precc = precc*8
*	(take three bits for safety)
	if ( lwrite ) print *,'ffinit: precc = ',precc
*
*	for efficiency tke them equal if they are not too different
*
	if ( precx/precc .lt. 4 .and. precx/precc .gt. .25 ) then
	    precx = max(precc,precx)
	    precx = max(precc,precx)
	endif
*
*	and the minimum value the logarithm accepts without complaining
*	about arguments zero is (DOUBLE PRECISION cq DOUBLE COMPLEX)
*
	s = 1
	xalogm = 1
	do 5 i=1,10000
	    s = s/2
	    if ( 2*abs(s) .ne. xalogm ) goto 6
	    xalogm = abs(s)
    5	continue
    6	continue
*	stupid dbx...
*	xalogm = 1.e-75
	if ( lwrite ) print *,'ffinit: xalogm = ',xalogm
	s = 1
	xclogm = abs(DCMPLX(s))
	do 7 i=1,10000
	    s = s/2
	    if ( 2*abs(DCMPLX(s)) .ne. xclogm ) goto 8
	    xclogm = abs(DCMPLX(s))
    7	continue
    8	continue
*	stupid dbx...
*	xclogm = 1.e-37
	if ( lwrite ) print *,'ffinit: xclogm = ',xclogm
*
*	These values are for Absoft, Apollo fortran (68000):
*	xalogm = 1.D-308
*	xclogm = 1.D-18
*	These values are for VAX g_float
*	xalogm = 1.D-308
*	xclogm = 1.D-308
*	These values are for Gould fort (because of div_zz)
*	xalogm = 1.D-75
*	xclogm = 1.D-36
	xalog2 = sqrt(xalogm)
	xclog2 = sqrt(xclogm)
*  #] precision etc:
*  #[ constants:
*
*	calculate the coefficients of the series expansion
*	li2(x) = sum bn*z^n/(n+1)!, z = -log(1-x), bn are the
*	bernouilli numbers (zero for odd n>1).
*
	bf(1) = - 1.D+0/4.D+0
	bf(2) = + 1.D+0/36.D+0
	bf(3) = - 1.D+0/36.D+2
	bf(4) = + 1.D+0/21168.D+1
	bf(5) = - 1.D+0/108864.D+2
	bf(6) = + 1.D+0/52690176.D+1
	bf(7) = - 691.D+0/16999766784.D+3
	bf(8) = + 1.D+0/1120863744.D+3
	bf(9) = - 3617.D+0/18140058832896.D+4
	bf(10) = + 43867.D+0/97072790126247936.D+3
	bf(11) = - 174611.D+0/168600109166641152.D+5
	bf(12) = + 77683.D+0/32432530090601152512.D+4
	bf(13) = - 236364091.D+0/4234560341829359173632.D+7
	bf(14) = + 657931.D+0/5025632054039239458816.D+6
	bf(15) = - 3392780147.D+0/109890470493622010006470656.D+7
	bf(16)=+172.3168255201D+0/2355349904102724211909.3102313472D+6
	bf(17)=-770.9321041217D+0/4428491985594062112714.2791446528D+8
	bf(18)=( 0.4157635644614046176D-28)
	bf(19)=(-0.9962148488284986022D-30)
	bf(20)=( 0.2394034424896265390D-31)
*
*	inverses of integers:
*
	do 10 i=1,30
	    xninv(i) = x1/i
	    xn2inv(i) = x1/(i*i)
   10	continue
*
*	inverses of faculties of integers:
*
	xinfac(1) = x1
	do 20 i=2,30
	    xinfac(i) = xinfac(i-1)/i
   20	continue
*
*	inx: p(inx(i,j)) = isgn(i,j)*(s(i)-s(j))
*
	inx(1,1) = -9999
	inx(2,1) = 5
	inx(3,1) = 9
	inx(4,1) = 8
	inx(1,2) = 5
	inx(2,2) = -9999
	inx(3,2) = 6
	inx(4,2) = 10
	inx(1,3) = 9
	inx(2,3) = 6
	inx(3,3) = -9999
	inx(4,3) = 7
	inx(1,4) = 8
	inx(2,4) = 10
	inx(3,4) = 7
	inx(4,4) = -9999
	isgn(1,1) = -9999
	isgn(2,1) = +1
	isgn(3,1) = -1
	isgn(4,1) = -1
	isgn(1,2) = -1
	isgn(2,2) = -9999
	isgn(3,2) = +1
	isgn(4,2) = +1
	isgn(1,3) = +1
	isgn(2,3) = -1
	isgn(3,3) = -9999
	isgn(4,3) = +1
	isgn(1,4) = +1
	isgn(2,4) = -1
	isgn(3,4) = -1
	isgn(4,4) = -9999
	do 40 i=1,12
	    do 30 j=1,13
	    	iold(j,i) = ioldp(j,i)
   30	    continue
	    do 35 j=1,10
	    	isgrot(j,i) = isgrop(j,i)
   35	    continue
   40	continue
*  #] constants:
*  #[ defaults for flags:
	nevent = 0
*
*	the debugging flags.
*
	lwrite = .FALSE.
	ltest = .TRUE.
	lwarn = .TRUE.
	ldc3c4 = .TRUE.
	l4also = .TRUE.
	lmem = .FALSE.
	ldot = .FALSE.
	idot = 0
*
*	Specify which root to take in cases were two are possible
*	it may be advantageous to change this to -1 (debugging hook)
*
	isgn34 = 1
	isgnal = 1
*
*	the cutoff has to be initialized because of the memory mechansim
*
	delta = 0
*
*	the scheme used for the complex scalar functions:
*
*	nschem = 1: do not use the complex mass at all
*		 2: only use the complex mass in linearly divergent terms
*		 3: also use the complex mass in divergent logs UNDEFINED
*		 4: use the complex mass in the C0 if there are 
*		    divergent logs
*		 5: include the almost-divergent threshold terms from
*		    (m,m,0) vertices
*		 6: include the (s-m^2)*log(s-m^2) threshold terms from
*		    (m1+m2),m1,m2) vertices
*		 7: full complex computation
*	(only in the ffz... functions):
*	onshel = .FALSE.: use the offshell p^2 everywhere
*		 .TRUE.:  use the onshell p^2 except in complex parts
*
	nschem = 4
	onshel = .TRUE.
*
*	the precision wanted in the complex D0 (and hence E0) when
*	nschem=7, these are calculated via Taylor exoansion in the real
*	one and hence expensive.
*
	reqprc = 1.e-8
*
*	in some schemes, for onshel=.FALSE.,
*	when |p^2-Re(m^2)| < nwidth*|Im(m^2)| special action is taken
*
	nwidth = 5
*
*	a flag to indicate the validity of differences smuggled to the
*	IR routines in the C0 (ff internal only)
*
	lsmug = .FALSE.
*
*  #] defaults for flags:
*###] ffinit:
	end
*###[ ffexit:
	subroutine ffexit
***#[*comment:***********************************************************
*	check a lot of commonly-used constants in the common block	*
*	/ffcnst/.							*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer i,ier
	include 'ff.h'
*  #] declarations:
*  #[ checks:
*
*	calculate the coefficients of the series expansion
*	li2(x) = sum bn*z^n/(n+1)!, z = -log(1-x), bn are the
*	bernouilli numbers (zero for odd n>1).
*
	if ( bf(1) .ne. - 1.D+0/4.D+0 )
     +	print *,'ffexit: error: bf(1) is corrupted'
	if ( bf(2) .ne. + 1.D+0/36.D+0 )
     +	print *,'ffexit: error: bf(2) is corrupted'
	if ( bf(3) .ne. - 1.D+0/36.D+2 )
     +	print *,'ffexit: error: bf(3) is corrupted'
	if ( bf(4) .ne. + 1.D+0/21168.D+1 )
     +	print *,'ffexit: error: bf(4) is corrupted'
	if ( bf(5) .ne. - 1.D+0/108864.D+2 )
     +	print *,'ffexit: error: bf(5) is corrupted'
	if ( bf(6) .ne. + 1.D+0/52690176.D+1 )
     +	print *,'ffexit: error: bf(6) is corrupted'
	if ( bf(7) .ne. - 691.D+0/16999766784.D+3 )
     +	print *,'ffexit: error: bf(7) is corrupted'
	if ( bf(8) .ne. + 1.D+0/1120863744.D+3 )
     +	print *,'ffexit: error: bf(8) is corrupted'
	if ( bf(9) .ne. - 3617.D+0/18140058832896.D+4 )
     +	print *,'ffexit: error: bf(9) is corrupted'
	if ( bf(10) .ne. + 43867.D+0/97072790126247936.D+3 )
     +	print *,'ffexit: error: bf(10) is corrupted'
	if ( bf(11) .ne. - 174611.D+0/168600109166641152.D+5 )
     +	print *,'ffexit: error: bf(11) is corrupted'
	if ( bf(12) .ne. + 77683.D+0/32432530090601152512.D+4 )
     +	print *,'ffexit: error: bf(12) is corrupted'
	if ( bf(13) .ne. - 236364091.D+0/4234560341829359173632.D+7 )
     +	print *,'ffexit: error: bf(13) is corrupted'
	if ( bf(14) .ne. + 657931.D+0/5025632054039239458816.D+6 )
     +	print *,'ffexit: error: bf(14) is corrupted'
	if ( bf(15) .ne. -3392780147.D+0/109890470493622010006470656.D+7
     +	) print *,'ffexit: error: bf(15) is corrupted'
	if ( bf(16).ne.+172.3168255201D+0/2355349904102724211909.3102313
     +	472D+6 )
     +	print *,'ffexit: error: bf(16) is corrupted'
	if ( bf(17).ne.-770.9321041217D+0/4428491985594062112714.2791446
     +	528D+8 )
     +	print *,'ffexit: error: bf(17) is corrupted'
	if ( bf(18).ne.( 0.4157635644614046176D-28) )
     +	print *,'ffexit: error: bf(18) is corrupted'
	if ( bf(19).ne.(-0.9962148488284986022D-30) )
     +	print *,'ffexit: error: bf(19) is corrupted'
	if ( bf(20).ne.( 0.2394034424896265390D-31) )
     +	print *,'ffexit: error: bf(20) is corrupted'
*
*	inverses of integers:
*
	do 10 i=1,20
	    if ( abs(xninv(i)-x1/i) .gt. precx*xninv(i) ) print *,
     +		'ffexit: error: xninv(',i,') is not 1/',i,': ',
     +		xninv(i),xninv(i)-x1/i
   10	continue
*
*  #] checks:
	ier = 0
	call fferr(999,ier)
*###] ffexit:
	end
*###[ fferr:
	subroutine fferr(nerr,ierr)
***#[*comment:***********************************************************
*									*
*	generates an errormessage #nerr	with severity 2			*
*	nerr=999 gives a frequency listing of all errors		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer nmax
	parameter (nmax=100)
	integer nerr,ierr,ifile
	character*80 error(nmax),error1
	logical locwrt
	integer noccur(nmax),init,i,ier,inone,nnerr,nomore
	save error,noccur,init,locwrt,nomore
	include 'ff.h'
*  #] declarations:
*  #[ data:
	data locwrt /.TRUE./
	data nomore /-1/
	data noccur /nmax*0/
	data init /0/
	if ( init.eq.0 ) then
	    init = 1
	    do 1 i=1,nmax
		error(i) =
     +  	'fferr:  error:   illegal value for ierr'
    1	    continue
            call ffopen(ifile,'fferr.dat',ier)
	    if ( ier .ne. 0 ) goto 100
	    rewind(ifile)
	    read(ifile,'(a)')error1
	    read(ifile,'(a)')error1
	    do 90 i=1,10000
		read(ifile,'(i4,a80)',end=110,err=110)ier,error1
		if ( ier .lt. 1 .or. ier .gt. nmax ) then
		    print '(a,i3)','fferr:  error: wild error number ',
     +								ier
		    print '(a,a)','>>> ',error1
		    goto 90
		endif
		error(ier) = error1
   90	    continue
	    goto 110
  100	    continue
	    print '(a)',
     +		'fferr:  warning cannot open fferr.dat with error texts'
  110	    continue
	    close(ifile)
	endif
*  #] data:
*  #[ nerr=999:
	if ( nerr .eq. 999 ) then
*	    print out total numbers...
	    print '(a)',' '
	    print '(a)','total number of errors and warnings'
	    print '(a)','==================================='
	    inone = 1
	    do 10 i=1,nmax
		if ( noccur(i) .gt. 0 ) then
		    print '(a,i8,a,i3,a,a)','fferr: ',noccur(i),
     +			' times ',i,': ',error(i)
		    noccur(i) = 0
		    inone = 0
		endif
   10	    continue
	    if ( inone .eq. 1 ) print '(a)','fferr: no errors'
	    if ( lwarn ) call ffwarn(999,ierr,x1,x1)
	    print '(a)',' '
	    return
	endif
*  #] nerr=999:
*  #[ print error:
	if ( nerr .lt. 1 .or. nerr .gt. nmax ) then
	    nnerr = nmax
	else
	    nnerr = nerr
	endif
	noccur(nnerr) = noccur(nnerr) + 1
	ierr = ierr + 100

	if ( nevent .eq. nomore ) return

	if ( locwrt ) then
	    print '(a,i6,a,i6,a,i8)','fferr: id nr ',id,'/',idsub,
     +		', event nr ',nevent
	    print '(a,i6,a,a)','error nr',nerr,': ',error(nnerr)
	endif

	if ( nerr .eq. 100 ) then
*	    we found a matherror - discard all errors from now till next
*	    event
	    nomore = nevent
	endif

*  #] print error:
*###] fferr:
	end
*###[ ffwarn:
	subroutine ffwarn(nerr,ierr,som,xmax)
***#[*comment:***********************************************************
*									*
*	The warning routine.  A warning is aloss of precision greater	*
*	than xloss (which is default set in ffinit), whenever in a	*
*	subtraction the result is smaller than xloss*max(operands) this	*
*	routine is called.  Now the strategy is to remember these	*
*	warnings until a 998 message is obtained; then all warnings of	*
*	the previous event are printed.  The rationale is that one	*
*	makes this call if too much preciasion is lost only.		*
*	nerr=999 gives a frequency listing of all warnings		*
*									*
*	Input:	nerr	integer	the id of the warning message, see the	*
*				file ffwarn.dat or 998 or 999		*
*		ierr	integer	the usual error flag: number of digits	*
*				lost so far				*
*		som	real	the result of the addition		*
*		xmax	real	the largest operand			*
*									*
*	Output:	ierr	integer	is raised by the number of digits lost	*
*				the tolerated loss of xloss		*
*									*
*	NOTE: This routine needs a file ffwarn.dat with the warning	*
*	texts, it is very system dependent where to pick it up		*
*	set the PATH variable to your own taste.			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer nmax
	parameter (nmax=300)
*
*	arguments
*
	integer nerr,ierr
	DOUBLE PRECISION som,xmax
*
*	local variables
*
	integer memmax
	parameter (memmax = 1000)
	character*80 warn(nmax),warn1
	integer noccur(nmax),init,i,ier,inone,nnerr,ilost,
     +		nermem(memmax),losmem(memmax),idmem(memmax),
     +		idsmem(memmax),laseve,imem,ifile
	DOUBLE PRECISION xlosti(nmax),xlost
	save warn,noccur,init,xlosti,nermem,losmem,idmem,idsmem,
     +		laseve,imem
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*  #] declarations:
*  #[ data:
	data noccur /nmax*0/
	data init /0/
	if (init.eq.0) then
	    init = 1
	    do 1 i=1,nmax
		warn(i) =
     +  	'ffwarn:  warning:   illegal value for ierr'
		xlosti(i) = 0
    1	    continue
            call ffopen(ifile,'ffwarn.dat',ier)
	    if ( ier .ne. 0 ) goto 100
	    rewind(ifile)
	    read(ifile,'(a)')warn1
	    read(ifile,'(a)')warn1
	    do 90 i=1,10000
		read(ifile,'(i4,a80)',end=110,err=110)ier,warn1
		if ( warn1 .eq. ' ' ) goto 90
		if ( ier .lt. 1 .or. ier .gt. nmax ) then
		    print '(a,i3)','ffwarn: error: wild warning number '
     +								,ier
		    print '(a,a)','>>> ',warn1
		    goto 90
		endif
		warn(ier) = warn1
   90	    continue
	    goto 110
  100	    continue
	    print '(a)',
     +	    'ffwarn: warning cannot open ffwarn.dat with warning texts'
  110	    continue
	    close(ifile)
	    laseve = -1
	    imem = 1
	endif
*  #] data:
*  #[ nerr=999:
	if ( nerr .eq. 999 ) then
*	    print out total numbers...
	    inone = 1
	    do 10 i=1,nmax
		if ( noccur(i) .gt. 0 ) then
		    print '(a,i8,a,i3,a,a)','ffwarn: ',noccur(i),
     +			' times ',i,': ',warn(i)
		    print '(a,g12.3,a)',
     +			'     (lost at most a factor ',xlosti(i),')'
		    noccur(i) = 0
		    xlosti(i) = 0
		    inone = 0
		endif
   10	    continue
	    if ( inone .eq. 1 ) print '(a)','ffwarn: no warnings'
	    return
	endif
*  #] nerr=999:
*  #[ print warning:
	if ( nerr .eq. 998 ) then
	    if ( nevent .ne. laseve ) return
	    do 20 i=1,imem-1
		if ( nermem(i).ne.0 ) then
		    print '(a,i6,a,i6,a,i8)','ffwarn: id nr ',idmem(i),
     +			'/',idsmem(i),', event nr ',nevent
		    print '(a,i6,a,a)','warning nr ',nermem(i),': ',
     +			warn(nermem(i))
		    print '(a,i3,a)','     (lost ',losmem(i),' digits)'
		endif
   20	    continue
	    imem = 1
	    return
	endif
*  #] print warning:
*  #[ collect warnings:
*
*	bring in range
*
	if ( nerr .lt. 1 .or. nerr .gt. nmax ) then
	    nnerr = nmax
	else
	    nnerr = nerr
	endif
*
*	bookkeeping
*
	noccur(nnerr) = noccur(nnerr) + 1
	if ( som .ne. 0 ) then
	    xlost = abs(xmax/som)
	elseif ( xmax .ne. 0 ) then
	    xlost = 1/precx
	else
	    xlost = 1
	endif
	xlosti(nnerr) = max(xlosti(nnerr),xlost)
	if ( xlost*xloss .gt. xalogm ) then
	    ilost = 1 + int(abs(log10(xlost*xloss)))
	else
	    ilost = 0
	endif
	ierr = ierr + ilost
*	
*	nice place to stop when debugging
*	
	if ( ilost.ge.10 ) then
	    ilost = ilost + 1 - init
	endif
*
*	add to memory
*
	if ( laseve .ne. nevent ) then
	    imem = 1
	    laseve = nevent
	endif
	if ( imem .le. memmax ) then
	    idmem(imem) = id
	    idsmem(imem) = idsub
	    nermem(imem) = nnerr
	    losmem(imem) = ilost
	    imem = imem + 1
	endif
*
*	print directly if lwrite TRUE
*
	if ( awrite .or. lwrite ) then
	    imem = imem - 1
	    print '(a,i6,a,i6,a,i8)','ffwarn: id nr ',idmem(imem),'/',
     +			idsmem(imem),', event nr ',nevent
	    print '(a,i6,a,a)','warning nr ',nermem(imem),': ',
     +			warn(nnerr)
	    print '(a,i3,a)','     (lost ',losmem(imem),' digits)'
	endif
*  #] collect warnings:
*###] ffwarn:
	end
*###[ ffopen:
	subroutine ffopen(ifile,name,ier)
*
*	opens a data file and returns the unit number.
*
	implicit none
*
*	arguments
*
	integer ifile,ier
	character*(*) name
*
	logical lopen
	character*128 fullname
*
	include 'ff.h'
*
	ier = 0
	do 10 ifile = 1,100
	    inquire(ifile,opened=lopen)
	    if ( .not.lopen ) goto 20
   10	continue
   20	continue
!WP	fullname = 'ff/'//name
	fullname = '../ff/'//name
	open(ifile,file=fullname,status='OLD',err=100)
*
*	VMS users: use the following lines instead
*	fullname = 'USR$LOCAL[GEERT]'//name
*	open(ifile,file=fullname,status='OLD',READONLY,err=100)
*
	return
  100	continue
	if ( lwrite ) print *,'ffopen: error: could not open ',fullname
	ier = -1
*###] ffopen:
	end
*###[ ffbnd:
	DOUBLE PRECISION function ffbnd(n1,n2,array)
*************************************************************************
*									*
*	calculate bound = (precx*|a(n1)/a(n1+n2)|^(1/n2) which is the	*
*	maximum value of x in a series expansion sum_(i=n1)^(n1+n2)	*
*	a(i)*x(i) to give a result of accuracy precx (actually of |next	*
*	term| < prec							*
*									*
*************************************************************************
	implicit none
	integer n1,n2
	DOUBLE PRECISION array(n1+n2)
	include 'ff.h'
	if ( array(n1+n2) .eq. 0 ) then
	   print *,'ffbnd: fatal: array not intialized; did you call ',
     +		'ffinit?'
	   stop
	endif
	ffbnd = (precx*abs(array(n1)/array(n1+n2)))**(1/DBLE(n2))
*###] ffbnd:
	end
*###[ ffbndc:
	DOUBLE PRECISION function ffbndc(n1,n2,carray)
*************************************************************************
*									*
*	calculate bound = (precc*|a(n1)/a(n1+n2)|^(1/n2) which is the	*
*	maximum value of x in a series expansion sum_(i=n1)^(n1+n2)	*
*	a(i)*x(i) to give a result of accuracy precc (actually of |next	*
*	term| < prec							*
*									*
*************************************************************************
	implicit none
	integer n1,n2
	DOUBLE COMPLEX carray(n1+n2)
	include 'ff.h'
	if ( carray(n1+n2) .eq. 0 ) then
	   print *,'ffbnd: fatal: array not intialized; did you call ',
     +		'ffinit?'
	   stop
	endif
	ffbndc = (precc*abs(carray(n1)/carray(n1+n2)))**(1/DBLE(n2))
*###] ffbndc:
	end
*###[ ffroot:
	subroutine ffroot(xm,xp,a,b,c,d,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the rrots of the equation				*
*		a*x^2 - 2*b*x + c = 0					*
*	given by							*
*		x = (b +/- d )/a	xp*xm = c/a			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ier
	DOUBLE PRECISION xm,xp,a,b,c,d
*
*	local variables:
*
	DOUBLE PRECISION s1,s2,s3,rloss
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( a .eq. 0 ) then
	    call fferr(39,ier)
	    if ( b.gt.0 .eqv. d.gt.0 ) then
		xp = 1/xalogm
		xm = c/(b+d)
	    else
		xp = c/(b-d)
		xm = 1/xalogm
	    endif
	    return
	endif
*	if ( lwrite ) print *,'ffroot: a,b,c,d = ',a,b,c,d
*  #] check input:
*  #[ calculations:
	if ( d .eq. 0 ) then
	    xm = b / a
	    xp = xm
	elseif ( b .gt. 0 .eqv.  d .gt. 0 ) then
	    xp = ( b + d ) / a
	    xm = c / (a*xp)
	else
	    xm = ( b - d ) / a
	    xp = c / (a*xm)
	endif
*  #] calculations:
*  #[ test output:
	if ( ltest ) then
	    rloss = xloss*DBLE(10)**(-2-mod(ier,50))
	    if ( xm .ne. 0 ) then
		s1 = a*xm
		s2 = 2*b
		s3 = c/xm
		if ( rloss*abs(s1-s2+s3) .gt. precx*max(abs(s1),abs(s2),
     +			abs(s3)) ) then
		    print *,'ffroot: error: xm not root! ',s1,s2,s3,
     +			s1-s2+s3,ier
		endif
	    endif
	    if ( xp .ne. 0 ) then
		s1 = a*xp
		s2 = 2*b
		s3 = c/xp
		if ( rloss*abs(s1-s2+s3) .gt. precx*max(abs(s1),abs(s2),
     +			abs(s3)) ) then
		    print *,'ffroot: error: xp not root! ',s1,s2,s3,
     +			s1-s2+s3,ier
		endif
	    endif
	endif
*  #] test output:
*###] ffroot:
	end
*###[ ffcoot:
	subroutine ffcoot(xm,xp,a,b,c,d,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the rrots of the equation				*
*		a*x^2 - 2*b*x + c = 0					*
*	given by							*
*		x = (b +/- d )/a	xp*xm = c/a			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ier
	DOUBLE COMPLEX xm,xp,a,b,c,d
*
*	local variables:
*
	DOUBLE COMPLEX s1,s2,s3,cc
	DOUBLE PRECISION absc,rloss
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations:
*  #[ check input:
	if ( a .eq. 0 ) then
	    call fferr(38,ier)
	    return
	endif
*	if ( lwrite ) print *,'ffroot: a,b,c,d = ',a,b,c,d
*  #] check input:
*  #[ calculations:
	cc = b+d
	if ( d .eq. 0 ) then
	    xm = b / a
	    xp = xm
	elseif ( absc(cc) .gt. xloss*absc(d) ) then
	    xp = ( b + d ) / a
	    xm = c / (a*xp)
	else
	    xm = ( b - d ) / a
	    xp = c / (a*xm)
	endif
*  #] calculations:
*  #[ test output:
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    if ( absc(xm) .gt. xclogm ) then
		s1 = a*xm
		s2 = 2*b
		s3 = c/xm
		cc = s1-s2+s3
		if ( rloss*absc(cc).gt.precc*max(absc(s1),absc(
     +			s2),absc(s3)) ) print *,
     +			'ffcoot: error: xm not root! ',s1,s2,s3,s1-s2+s3
	    endif
	    if ( absc(xp) .gt. xclogm ) then
		s1 = a*xp
		s2 = 2*b
		s3 = c/xp
		cc = s1-s2+s3
		if ( rloss*absc(cc).gt.precc*max(absc(s1),absc(
     +			s2),absc(s3)) ) print *,
     +			'ffcoot: error: xp not root! ',s1,s2,s3,s1-s2+s3
	    endif
	endif
*  #] test output:
*###] ffcoot:
	end
*###[ ffxhck:
	subroutine ffxhck(xpi,dpipj,ns,ier)
***#[*comment:***********************************************************
*									*
*	check whether the differences dpipj are compatible with xpi	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ns,ier
	DOUBLE PRECISION xpi(ns),dpipj(ns,ns)
	integer i,j
	DOUBLE PRECISION xheck,rloss
	include 'ff.h'
*  #] declarations:
*  #[ calculations:
	rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	do 20 i=1,ns
	    do 10 j=1,ns
		xheck = dpipj(j,i) - xpi(j) + xpi(i)
		if ( rloss*abs(xheck) .gt. precx*max(abs(dpipj(j,i)),
     +			abs(xpi(j)),abs(xpi(i))) ) then
		    print *,'ffxhck: error: dpipj(',j,i,') <> xpi(',j,
     +			') - xpi(',i,'):',dpipj(j,i),xpi(j),xpi(i),xheck
		    if ( lwrite ) ier = ier + 100
		endif
   10	    continue
   20	continue
*  #] calculations:
*###] ffxhck:
	end
*###[ ffchck:
	subroutine ffchck(cpi,cdpipj,ns,ier)
***#[*comment:***********************************************************
*									*
*	check whether the differences cdpipj are compatible with cpi	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ns,ier
	DOUBLE COMPLEX cpi(ns),cdpipj(ns,ns),c
	integer i,j
	DOUBLE COMPLEX check
	DOUBLE PRECISION absc,rloss
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ calculations:
	rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	do 20 i=1,ns
	    do 10 j=1,ns
		check = cdpipj(j,i) - cpi(j) + cpi(i)
		if ( rloss*absc(check) .gt. precc*max(absc(
     +			cdpipj(j,i)),absc(cpi(j)),absc(cpi(i))) ) then
		    print *,'ffchck: error: cdpipj(',j,i,') <> cpi(',j,
     +		       ') - cpi(',i,'):',cdpipj(j,i),cpi(j),cpi(i),check
		    if ( lwrite ) ier = ier + 100
		endif
   10	    continue
   20	continue
*  #] calculations:
*###] ffchck:
	end
*###[ nffeta:
	integer function nffeta(ca,cb,ier)
***#[*comment:***********************************************************
*	calculates							*
*									*
*	eta(a,b)/(2*i*pi) = ( thIm(-a)*thIm(-b)*thIm(a*b)		*
*				- thIm(a)*thIm(b)*thIm(-a*b) )		*
*									*
*	with thIm(a) = theta(Im(a))					*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE COMPLEX ca,cb
	DOUBLE PRECISION a,b,ab,rab
	include 'ff.h'
*  #] declarations:
*  #[ calculations:
	a = DIMAG(ca)
	b = DIMAG(cb)
	if ( a*b .lt. 0 ) then
	    nffeta = 0
	    return
	endif
	rab = DBLE(ca)*DBLE(cb) - a*b
	ab = DBLE(ca)*b + a*DBLE(cb)
	if ( abs(ab) .lt. precc*abs(DBLE(ca)*b) ) then
	    call fferr(32,ier)
	    if ( lwrite ) print *,'a,b = ',ca,cb,
     +		' (no precision left in DIMAG(ab)=',ab,')'
	endif
	if ( a .lt. 0 .and. b .lt. 0 .and. ab .gt. 0 ) then
	    nffeta = 1
	elseif ( a .gt. 0 .and. b .gt. 0 .and. ab .lt. 0 ) then
	    nffeta = -1
	elseif ( a .eq. 0 .and. DBLE(ca) .le. 0 .or.
     +		 b .eq. 0 .and. DBLE(cb) .le. 0 .or.
     +		 ab .eq. 0 .and. rab .le. 0 ) then
	    call fferr(32,ier)
	    if ( ltest .or. lwrite ) print *,'a,b = ',ca,cb
	    nffeta = 0
	else
	    nffeta = 0
	endif
*  #] calculations:
*###] nffeta:
	end
*###[ nffet1:
	integer function nffet1(ca,cb,cc,ier)
***#[*comment:***********************************************************
*	calculates the same eta with three input variables		*
*									*
*	et1(a,b)/(2*i*pi) = ( thIm(-a)*thIm(-b)*thIm(c)			*
*				- thIm(a)*thIm(b)*thIm(-c) )		*
*									*
*	with thIm(a) = theta(Im(a))					*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE COMPLEX ca,cb,cc,c
	DOUBLE PRECISION a,b,ab,abp,absc
	include 'ff.h'
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest .and. DIMAG(ca)*DIMAG(cb) .gt. 0 .and. DBLE(ca)*DBLE(
     +		cb) .ne. 0 ) then
	    ab = DIMAG(cc)
	    abp = DIMAG(ca*cb)
	    if ( xloss*abs(abp) .lt. precc*absc(ca)*absc(cb) )
     +		abp = 0
	    if ( ab .gt. 0 .and. abp .lt. 0 .or. ab .lt. 0 .and. abp
     +		.gt. 0  ) then
		print *,'nffet1: error:  sgn im(ca*cb) != sgn im(cc): ',
     +			ab,abp
	    endif
	endif
*  #] check input:
*  #[ calculations:
	a = DIMAG(ca)
	b = DIMAG(cb)
	if ( a .gt. 0 .neqv. b .gt. 0 ) then
	    nffet1 = 0
	    return
	endif
	ab = DIMAG(cc)
	if ( a .lt. 0 .and. b .lt. 0 .and. ab .gt. 0 ) then
	    nffet1 = 1
	elseif ( a .gt. 0 .and. b .gt. 0 .and. ab .lt. 0 ) then
	    nffet1 = -1
	elseif ( a .eq. 0 .and. DBLE(ca) .le. 0 .or.
     +		 b .eq. 0 .and. DBLE(cb) .le. 0 .or.
     +		 ab .eq. 0 .and. DBLE(cc) .le. 0 ) then
	    call fferr(33,ier)
	    if ( ltest.or.lwrite ) print *,'a,b,ab = ',ca,cb,cc
	    nffet1 = 1
	else
	    nffet1 = 0
	endif
*  #] calculations:
*###] nffet1:
	end
*###[ ffcayl:
	subroutine ffcayl(cs,z,coeff,n,ier)
***#[*comment:***********************************************************
*									*
*	Do a Taylor expansion in z with real coefficients coeff(i)	*
*									*
*	Input:	z		complex					*
*		coeff(n)	real					*
*		n		integer					*
*									*
*	Output	cs		complex		\sum_{i=1} z^i coeff(i)	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer n,ier
	DOUBLE PRECISION coeff(n)
	DOUBLE COMPLEX z,cs
*
*	local variables
*
	integer i
	DOUBLE PRECISION absc
	DOUBLE COMPLEX c,zi,csi
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*  #] declarations:
*  #[ work:
	cs = z*DBLE(coeff(1))
	if ( absc(z) .lt. precc ) return
	zi = z
	do 10 i=2,n
	    zi = zi*z
	    csi = zi*DBLE(coeff(i))
	    cs = cs + csi
	    if ( absc(csi) .lt. precc*absc(cs) ) goto 20
   10	continue
	call ffwarn(9,ier,precc,absc(csi))
   20	continue
*  #] work:
*###] ffcayl:
	end
*###[ fftayl:
	subroutine fftayl(s,z,coeff,n,ier)
***#[*comment:***********************************************************
*									*
*	Do a Taylor expansion in z with real coefficients coeff(i)	*
*									*
*	Input:	z		real					*
*		coeff(n)	real					*
*		n		integer					*
*									*
*	Output	cs		real		\sum_{i=1} z^i coeff(i)	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer n,ier
	DOUBLE PRECISION coeff(n),z,s
*
*	local variables
*
	integer i
	DOUBLE PRECISION zi,si
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ work:
	s = coeff(1)*z
	if ( abs(z) .lt. precx ) return
	zi = z
	do 10 i=2,n
	    zi = zi*z
	    si = coeff(i)*zi
	    s = s + si
	    if ( abs(si) .lt. precx*abs(s) ) goto 20
   10	continue
	call ffwarn(9,ier,precx,si)
   20	continue
*  #] work:
*###] fftayl:
	end

*###[ ffai:
	subroutine ffai(ai,daiaj,aai,laai,del2s,sdel2s,xpi,dpipj,piDpj,
     +		ier)
***#[*comment:***********************************************************
*									*
*	calculates the coefficients of the projective transformation	*
*									*
*	    xi = ai*ui / (som aj*uj )					*
*									*
*	such that the coefficients of z^2, z*x and z*y vanish:		*
*									*
*	    a2/a1 = ( lij +/- lam1/2(xp1,xm1,xm2) ) / (2*xm2)		*
*	    a3 = ( xm2*a2 - xm1*a1 ) / ( xl23*a2 - xl13*a1 )		*
*	    a4 = ( xm2*a2 - xm1*a1 ) / ( xl24*a2 - xl14*a1 )		*
*									*
*	the differences ai-aj = daiaj(i,j) are also evaluated.		*
*									*
*	Input:	del2s		real	delta(s3,s4,s3,s4)		*
*		sdel2s		real	sqrt(-del2s)			*
*		xpi(10)		real	masses, momenta^2		*
*		dpipj(10,10	real	xpi(i) - xpi(j)			*
*		piDpj(10,10)	real	dotproducts			*
*									*
*	Output:	ai(4)		real	Ai of the transformation	*
*		daiaj(4,4)	real	Ai-Aj				*
*		aai(4)		real	the other roots			*
*		laai		logical	if .TRUE. aai are defined	*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	logical laai
	DOUBLE PRECISION ai(4),daiaj(4,4),aai(4),del2s,sdel2s,xpi(10),
     +		dpipj(10,10),piDpj(10,10)
*
*	local variables
*
	integer i,j,ier0,ier1,ier2
	DOUBLE PRECISION del2sa,del2sb,del3mi(2),aim(4),aaim(4),delps,
     +		del3m(1),dum,da2a1m,da1a3m,da1a4m,da2a3m,da2a4m,da3a4m
*	for debugging purposes
	DOUBLE COMPLEX ca1m
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations: 
*  #[ get ai:
	if ( lwrite ) print *,'ffai: xpi = ',(xpi(i),i=1,10),ier
*
*	A4: some arbitrary normalisation ...
*
	ai(4) = 1
	aai(4) = 1
	ier2 = ier
	if ( del2s .ne. 0 ) then
*
*	    A3: simple solution of quadratic equation
*
	    ier0 = ier
	    call ffroot(aaim(3),aim(3),xpi(4),piDpj(4,3),xpi(3),
     +							sdel2s,ier0)
	    ier2 = max(ier2,ier0)
	    if ( aim(3) .eq. 0 ) then
*		choose the other root
		if ( lwrite ) print *,'ffai: 1/A_3 = 0'
		ier = ier + 100
		return
	    endif
	    ai(3) = ai(4)/aim(3)
	    if ( aaim(3) .ne. 0 ) then
		laai = .TRUE.
		aai(3) = aai(4)/aaim(3)
	    else
		laai = .FALSE.
	    endif
*
*	    A2: a bit more complicated quadratic equation
*
	    ier1 = ier
	    ier0 = ier
	    call ffdl2s(del2sa,xpi,piDpj, 2,4,10,1, 3,4,7,1, 10,ier0)
	    ier1 = max(ier1,ier0)
	    ier0 = ier
	    call ffdl3m(del3mi(2),.FALSE.,x0,x0,xpi,dpipj,piDpj,10,
     +						3,4,7, 2,1,ier0)
	    ier1 = max(ier1,ier0)
	    call ffroot(aim(2),aaim(2),xpi(4),piDpj(4,2),del3mi(2)/del2s
     +		,del2sa/sdel2s,ier1)
	    ier2 = max(ier2,ier1)
	    if ( aim(2) .eq. 0 ) then
		if ( lwrite ) print *,'ffai: 1/A_2 = 0'
		ier = ier + 100
		return
	    endif
	    ai(2) = ai(4)/aim(2)
	    if ( laai ) then
		if ( aaim(2) .eq. 0 ) then
		    laai = .FALSE.
		else
		    aai(2) = aai(4)/aaim(2)
		endif
	    endif
*
*	    A1: same as A2, except for the special nasty case.
*
	    if ( .not.lnasty ) then
	    ier0 = ier
	    ier1 = ier
	    call ffdl2s(del2sb,xpi,piDpj, 1,4,8,-1, 3,4,7,1, 10,ier0)
	    ier1 = max(ier1,ier0)
	    ier0 = ier
	    call ffdl3m(del3mi(1),.FALSE.,x0,x0,xpi,dpipj,piDpj,10,
     +						3,4,7, 1,1,ier0)
	    ier1 = max(ier1,ier0)
	    call ffroot(aim(1),aaim(1),xpi(4),piDpj(4,1),del3mi(1)/del2s
     +		,del2sb/sdel2s,ier1)
	    ier2 = max(ier2,ier1)
	    if ( aim(1) .eq. 0 ) then
		if ( lwrite ) print *,'ffai: 1/A_1 = 0'
		ier = ier + 100
		return
	    endif
	    ai(1) = ai(4)/aim(1)
	    if ( laai ) then
		if ( aaim(1) .eq. 0 ) then
		    laai = .FALSE.
		else
		    aai(1) = aai(4)/aaim(1)
		endif
	    endif
	    else
		laai = .FALSE.
		ca1m = (c2sisj(1,4) - (c2sisj(1,3)*DBLE(xpi(4)) -
     +			c2sisj(1,4)*DBLE(piDpj(3,4)))/DBLE(sdel2s))/
     +			DBLE(2*xpi(4))
		ca1 = DBLE(ai(4))/ca1m
		if ( lwrite ) print *,'ffai: A1 = ',ca1
		ai(1) = ai(4)/DBLE(ca1m)
	    endif
	else
*
*	    the special case del2s=0 with xpi(3)=xpi(4),xpi(7)=0
*
	    laai = .FALSE.
	    ai(3) = ai(4)
	    if ( piDpj(7,2) .eq. 0 .or. piDpj(7,1) .eq. 0 ) then
		call fferr(55,ier)
		return
	    endif
	    ai(2) = ai(4)*xpi(3)/piDpj(7,2)
	    ai(1) = ai(4)*xpi(3)/piDpj(7,1)
	endif
	ier = ier2
*  #] get ai: 
*  #[ get daiaj:
	ier2 = ier
	do 120 i=1,4
	    daiaj(i,i) = 0
	    do 110 j=i+1,4
		daiaj(j,i) = ai(j) - ai(i)
		if ( abs(daiaj(j,i)) .ge. xloss*abs(ai(i)) ) goto 105
		if ( lwrite ) print *,'daiaj(',j,i,') = ',daiaj(j,i),
     +			ai(j),-ai(i),ier
		if ( del2s .eq. 0 ) then
*  #[		    del2s=0:
		    if ( i .eq. 1 .and. j .eq. 2 ) then
			daiaj(2,1) = -ai(1)*ai(2)*piDpj(5,7)/xpi(3)
			goto 104
		    elseif ( i .eq. 3 .and. j .eq. 4 ) then
			daiaj(4,3) = 0
			goto 104
		    endif
		    ier1 = ier
		    call ffwarn(146,ier1,daiaj(j,i),ai(i))
		    goto 105
*  #]		    del2s=0: 
		elseif ( lnasty .and. i.eq.1 ) then
		    ier1 = ier
		    call ffwarn(146,ier1,daiaj(j,i),ai(i))
		    goto 105
		endif
		ier0 = ier
		if ( i .eq. 1 .and. j .eq. 2 ) then
*  #[		    daiaj(2,1):
*
*		    some determinants (as usual)
*
*		    as the vertex p1,s4,? does not exist we use ffdl2t
*
		    call ffdl2t(delps,piDpj, 5,4, 3,4,7,1,+1, 10,ier0)
		    ier1 = max(ier1,ier0)
		    ier0 = ier
		    call ffdl3m(del3m,.FALSE.,x0,x0,xpi,dpipj,piDpj,
     +			10, 3,4,7, 5,1, ier0)
		    ier1 = max(ier1,ier0)
		    call ffroot(dum,da2a1m,xpi(4),piDpj(4,5),
     +			del3m(1)/del2s,-delps/sdel2s,ier1)
		    daiaj(2,1) = -ai(1)*ai(2)*da2a1m
		    goto 104
*  #]		    daiaj(2,1): 
		elseif ( i .eq. 1 .and. j .eq. 3 ) then
*  #[		    daiaj(3,1):
*
*		    Again, the solution of a simple quadratic equation
*
		    call ffdl2t(delps,piDpj, 9,4, 3,4,7,1,+1, 10,ier0)
		    ier1 = ier0
		    ier0 = ier
		    call ffdl3m(del3m,.FALSE.,x0,x0,xpi,dpipj,piDpj,
     +			10, 3,4,7, 9,1, ier0)
		    ier1 = max(ier1,ier0)
		    call ffroot(dum,da1a3m,xpi(4),-piDpj(4,9),
     +			del3m(1)/del2s,delps/sdel2s,ier1)
		    daiaj(3,1) = -ai(1)*ai(3)*da1a3m
		    goto 104
*  #]		    daiaj(3,1): 
		elseif ( i .eq. 1 .and. j .eq. 4 ) then
*  #[		    daiaj(4,1):
*
*		    Again, the solution of a simple quadratic equation
*
		    call ffdl2s(delps,xpi,piDpj,4,1,8,1,3,4,7,1,10,ier0)
		    ier1 = ier0
		    ier0 = ier
		    call ffdl3m(del3m,.FALSE.,x0,x0,xpi,dpipj,piDpj,
     +			10, 3,4,7, 8,1, ier0)
		    ier1 = max(ier0,ier1)
		    call ffroot(dum,da1a4m,xpi(4),piDpj(4,8),del3m(1)/
     +			del2s,delps/sdel2s,ier1)
		    daiaj(4,1) = ai(1)*ai(4)*da1a4m
		    goto 104
*  #]		    daiaj(4,1): 
		elseif ( i .eq. 2 .and. j .eq. 3 ) then
*  #[		    daiaj(3,2):
*
*		    Again, the solution of a simple quadratic equation
*
		    call ffdl2t(delps,piDpj, 6,4, 3,4,7,1,+1, 10,ier0)
		    ier1 = ier0
		    ier0 = ier
		    call ffdl3m(del3m,.FALSE.,x0,x0,xpi,dpipj,piDpj,
     +			10, 3,4,7, 6,1, ier0)
		    ier1 = max(ier1,ier0)
		    call ffroot(dum,da2a3m,xpi(4),-piDpj(4,6),
     +			del3m(1)/del2s,delps/sdel2s,ier1)
		    daiaj(3,2) = ai(2)*ai(3)*da2a3m
		    goto 104
*  #]		    daiaj(3,2): 
		elseif ( i .eq. 2 .and. j .eq. 4 ) then
*  #[		    daiaj(4,2):
*
*		    Again, the solution of a simple quadratic equation
*
		    call ffdl2s(delps,xpi,piDpj,2,4,10,1,3,4,7,1,10,
     +								ier0)
		    ier1 = ier0
		    ier0 = ier
		    call ffdl3m(del3m,.FALSE.,x0,x0,xpi,dpipj,piDpj,
     +			10, 3,4,7, 10,1, ier0)
		    ier1 = max(ier0,ier1)
		    call ffroot(dum,da2a4m,xpi(4),piDpj(4,10),del3m(1)/
     +			del2s,delps/sdel2s,ier1)
		    daiaj(4,2) = -ai(2)*ai(4)*da2a4m
		    goto 104
*  #]		    daiaj(4,2): 
		elseif ( i .eq. 3 .and. j .eq. 4 ) then
*  #[		    daiaj(4,3):
*
*		    Again, the solution of a very simple quadratic equation
*
		    ier1 = ier
		    call ffroot(dum,da3a4m,xpi(4),-piDpj(4,7),
     +			xpi(7),sdel2s,ier1)
		    daiaj(4,3) = ai(3)*ai(4)*da3a4m
		    goto 104
*  #]		    daiaj(4,3): 
		endif
  104		continue
		if ( lwrite ) print *,'daiaj(',j,i,')+= ',daiaj(j,i),ier
  105		continue
		daiaj(i,j) = -daiaj(j,i)
		ier2 = max(ier2,ier1)
  110	    continue
  120	continue
	ier = ier2
*  #] get daiaj: 
*  #[ debug output:
	if ( lwrite ) then
	    print *,'ffai: Found Ai: ',ai
	    print *,'      Ai-Aj:    ',daiaj
	    print *,'      ier       ',ier
	endif
*  #] debug output: 
*###] ffai: 
	end
*###[ fftran:
	subroutine fftran(ai,daiaj,aai,laai,xqi,dqiqj,qiDqj,
     +		del2s,sdel2s,xpi,dpipj,piDpj,ier)
***#[*comment:***********************************************************
*									*
*	Transform the impulses according to				*
*									*
*	    ti  = Ai*si							*
*	    qij = (Ai*si - Aj*sj)					*
*									*
*	In case del2s=0 it calculates the same coefficients but for	*
*	for A1,A2 leave out the delta with 2*delta = 1-xpi(4)/xpi(3)	*
*	infinitesimal.							*
*									*
*	Input:	ai(4)		ai					*
*		daiaj(4,4)	ai-aj					*
*		del2s		\delta^{s(3) s4}_{s(3) s4}		*
*		sdel2s		sqrt(del2s)				*
*		xpi(10)		masses = s1-s2-s(3)-s4			*
*		dpipj(10,10)	differences				*
*		piDpj(10,10)	dotproducts				*
*									*
*	Output:	xqi(10)		transformed momenta			*
*		dqiqj(10,10)	differences				*
*		qiDqj(10,10)	dotproducts				*
*		ier		(integer) 0=ok,1=inaccurate,2=error	*
*									*
*	Calls:	ffxlmb,...						*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	logical laai
	DOUBLE PRECISION ai(4),daiaj(4,4),aai(4),xqi(10),dqiqj(10,10),
     +		qiDqj(10,10),del2s,sdel2s,xpi(10),dpipj(10,10),
     +		piDpj(10,10)
*
*	local variables
*
	integer i,j,ji,k,kj,l,lk,is,isgnji,isgnlk,
     +		ifirst,i1,j1,k1,j2,kk,kkj,ier0,ier1,ier2
	logical lgo
	DOUBLE PRECISION xmax,dum,delps,del2d2,dl2d22,aijk,aijkl,
     +		xheck,smax,s(3),rloss,som
*
*	common blocks
*
	include 'ff.h'
*
	ifirst = 0
*  #] declarations: 
*  #[ si.sj -> ti.tj:
*
*	calculate the dotproducts of ti(i) = ai*si(i): no problems.
*
	do 20 i=1,4
	    xqi(i) = ai(i)**2 * xpi(i)
	    qiDqj(i,i) = xqi(i)
	    do 10 j=i+1,4
		qiDqj(j,i) = ai(j)*ai(i)*piDpj(j,i)
		qiDqj(i,j) = qiDqj(j,i)
   10	    continue
   20	continue
*
*	and the smuggled ones for the onshell complex D0
*
	if ( lsmug ) then
	    do 40 j=1,3
		do 30 i=i+1,4
		    c2sisj(i,j) = DBLE(ai(j)*ai(i))*c2sisj(i,j)
		    c2sisj(j,i) = c2sisj(i,j)
   30		continue
   40	    continue
	endif
	if ( lnasty ) then
	    do 60 j=3,4
*
*		we also hide in this array the corresponding real value
*		in (j,2) and (2,j), and the untransformed in (j,j).
*		Not beuatiful, but we need these to get the correct
*		Riemann sheets.
*
		c2sisj(j,j) = c2sisj(j,1)
		c2sisj(j,2) = ai(j)*ai(1)*DBLE(c2sisj(j,1))
		c2sisj(2,j) = c2sisj(j,2)
		c2sisj(j,1) = DBLE(ai(j))*ca1*c2sisj(j,1)
		c2sisj(1,j) = c2sisj(j,1)
*
   60	    continue
	    if ( lwrite ) then
		print *,'c2sisj(1,3-4) = ',c2sisj(1,3),c2sisj(1,4)
		print *,'c2sisj(2,3-4) = ',c2sisj(2,3),c2sisj(2,4)
	    endif
	endif
*
*  #] si.sj -> ti.tj: 
*  #[ si.pj -> ti.qj:
*
*	The dotproducts ti.qjk are still not too bad
*	Notice that t3.p = t4.p, so qiDqj(3,5-10) = qiDqj(4,5-10)
*
	ier2 = ier
	do 90 i=1,4
	    do 80 j=1,3
		do 70 k=j+1,4
		    ier1 = ier
		    kj = inx(k,j)
		    is = isgn(k,j)
		    if ( .not. ltest .and. i.eq.4 .and.
     +			(del2s.ne.0 .or. kj.eq.5 .or. kj.eq.7 )) then
			qiDqj(kj,4) = qiDqj(kj,3)
			goto 65
		    endif
		    s(1) = qiDqj(k,i)
		    s(2) = qiDqj(j,i)
		    qiDqj(kj,i) = is*(s(1) - s(2))
		    if ( abs(qiDqj(kj,i)).ge.xloss*abs(s(1)) ) goto 65
		    if ( lwrite ) print *,'qiDqj(',kj,i,')  =',
     +			qiDqj(kj,i),is,s(1),s(2),ier
		    ier0 = ier
		    if ( del2s .eq. 0 ) then
*
*			the special cases for del2s-0
*
			if ( kj .eq. 5 ) then
			    call ffdl2t(delps,piDpj, 7,i, 1,2,5,
     +							1,1,10,ier0)
			    qiDqj(5,i) = ai(1)*ai(2)*ai(i)*delps/xpi(3)
			elseif ( kj .eq. 7 ) then
			    qiDqj(kj,i) = ai(i)*ai(4)**2*piDpj(kj,i)
			else
*
*			    the pi has a mixed delta/no delta behaviour
*
			    call ffwarn(144,ier1,qiDqj(kj,i),s(1))
			    if ( lwrite ) print *,'in qiDqj(',kj,i,')'
			    goto 65
			endif
			if ( lwrite ) print *,'qiDqj(',kj,i,')+ =',
     +				qiDqj(kj,i),max(ier2,ier1)
			goto 65
		    endif
*
*		    Normal case, from the quadratic equation ...
*
		    ier1 = ier0
		    ier0 = ier
		    call ff2dl2(del2d2,delps,xpi,dpipj,piDpj, i,
     +			j,k,kj,is, 4, 3,4,7,+1, 10, ier0)
		    ier1 = max(ier1,ier0)
		    ier0 = ier
		    call ff2d22(dl2d22,xpi,dpipj,piDpj, i, j,k,kj,is,
     +			3,4,7,+1, 10,ier0)
		    ier1 = max(ier1,ier0)
		    call ffroot(dum,aijk,xpi(4),delps,dl2d22/del2s,
     +			-del2d2/sdel2s,ier1)
*		    the minus sign is because we have aijk, not aikj.
		    qiDqj(kj,i) = -is*aijk*ai(i)*ai(j)*ai(k)
		    if ( lwrite ) print *,'qiDqj(',kj,i,')+ =',
     +			qiDqj(kj,i),max(ier2,ier1)
   65		    continue
		    qiDqj(i,kj) = qiDqj(kj,i)
		    ier2 = max(ier2,ier1)
   70		continue
   80	    continue
   90	continue
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    do 100 i=5,10
		if ( del2s.eq.0 .and. (i.ne.5 .and. i.ne.7) ) goto 100
		if ( lnasty .and. (i.eq.5.or.i.eq.8.or.i.eq.9)) goto 100
		if ( rloss*abs(qiDqj(i,3)-qiDqj(i,4)) .gt. precx*
     +		    abs(qiDqj(i,3)))print *,'fftran: error: t3.q',i,
     +		    ' /= t4.q',i,': ',qiDqj(i,3),qiDqj(i,4),
     +		    qiDqj(i,3)-qiDqj(i,4),ier
  100	    continue
	endif
*  #] si.pj -> ti.qj: 
*  #[ pi.pj -> qi.qj:
	do 180 i=1,3
	    do 170 j=i+1,4
		ji = inx(j,i)
		isgnji = isgn(j,i)
		do 160 k=i,3
		    do 150 l=k+1,4
			if ( k .eq. i .and. l .lt. j ) goto 150
			ier1 = ier
			lk = inx(l,k)
			isgnlk = isgn(l,k)
*
*			Some are zero by definition, or equal to others
*
			if ( del2s .ne. 0 .and. (ji.eq.7 .or. lk.eq.7)
     +				.or.
     +			     del2s .eq. 0 .and. (ji.eq.7 .and. (lk.eq.7
     +				.or. lk.eq.5) .or. ji.eq.5 .and. lk.eq.7
     +			    ) ) then
			    qiDqj(lk,ji) = 0
			    goto 145
			endif
			if ( j.eq.4 .and. (del2s.ne.0 .or. lk.eq.5) )
     +								then
			    qiDqj(lk,ji) = isgnji*isgn(3,i)*
     +				qiDqj(lk,inx(3,i))
			    goto 145
			endif
			if ( l.eq.4 .and. (del2s.ne.0 .or. ji.eq.5) )
     +								then
			    qiDqj(lk,ji) = isgnlk*isgn(3,k)*
     +				qiDqj(inx(3,k),ji)
			    goto 145
			endif
*
*			First normal try
*
			if ( abs(qiDqj(k,ji)).le.abs(qiDqj(i,lk)) ) then
			    s(1) = qiDqj(k,ji)
			    s(2) = qiDqj(l,ji)
			    is = isgnlk
			else
			    s(1) = qiDqj(i,lk)
			    s(2) = qiDqj(j,lk)
			    is = isgnji
			endif
			qiDqj(lk,ji) = is*(s(2) - s(1))
			if ( abs(qiDqj(lk,ji)) .ge. xloss**2*abs(s(1)) )
     +				goto 145
			if ( lwrite ) print *,'qiDqj(',lk,ji,')  = ',
     +			    qiDqj(lk,ji),isgnji,isgnlk,s(1),s(2),ier2
*
*			First the special case del2s=0
*
			if ( del2s .eq. 0 ) then
			    if ( ji .eq. 5 .and. lk .eq. 5 ) then
				call ffdl3m(s(1),.FALSE.,x0,x0,xpi,dpipj
     +					,piDpj, 10, 1,2,5, 7, 1,ier1)
				qiDqj(5,5) =ai(1)**2*ai(2)**2*s(1)/xpi(3
     +					)**2
				if ( lwrite ) print *,'qiDqj(',lk,ji,
     +				  ')+ =',qiDqj(lk,ji),max(ier2,ier1)
			    else
				call ffwarn(145,ier1,qiDqj(lk,ji),s(1))
			    endif
			    goto 145
			endif
*
*			Otherwise use determinants
*
			call ffabcd(aijkl,xpi,dpipj,piDpj,del2s,
     +			    sdel2s, i,j,ji,isgnji, k,l,lk,isgnlk, 10,
     +			    ifirst, ier1)
			qiDqj(lk,ji) = (isgnji*isgnlk)*
     +				aijkl*ai(i)*ai(j)*ai(k)*ai(l)
			if ( lwrite ) print *,'qiDqj(',lk,ji,')+ = ',
     +				qiDqj(lk,ji),max(ier2,ier1)
			goto 145
*			print *,'fftran: warning: numerical problems ',
*     +				'in qiDqj(',lk,ji,')'
  145			continue
			if ( lk .ne. ji ) then
			    qiDqj(ji,lk) = qiDqj(lk,ji)
			else
			    xqi(ji) = qiDqj(lk,ji)
			endif
			ier2 = max(ier2,ier1)
  150		    continue
  160		continue
  170	    continue
  180	continue
	ier = ier2
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    if ( del2s .ne. 0 ) then
	    do 810 i=1,2
		do 800 j=i,2
		   s(1) = isgn(i,3)*isgn(j,3)*qiDqj(inx(i,3),inx(j,3))
		   s(2) = isgn(i,4)*isgn(j,4)*qiDqj(inx(i,4),inx(j,4))
		   if ( rloss*abs(s(1)-s(2)).gt.precx*max(abs(
     +			s(1)),abs(s(2))) ) print *,'fftran: error: q',i,
     +			'3.q',j,'3 /= q',i,'4.q',j,'4 : ',s(1),s(2),
     +			s(1)-s(2),ier
  800		continue
  810	    continue
	    endif
	    do 830 i=1,10
		do 820 j=i+1,10
		    if ( qiDqj(i,j) .ne. qiDqj(j,i) ) print *,
     +			'fftran: error: qiDqj(',i,j,')/= qiDqj(',j,i,')'
  820		continue
  830	    continue
	    do 840 i=1,10
		xheck = qiDqj(i,5)+qiDqj(i,6)+qiDqj(i,7)+qiDqj(i,8)
		smax = max(abs(qiDqj(i,5)),abs(qiDqj(i,6)),
     +			abs(qiDqj(i,7)),abs(qiDqj(i,8)))
		if ( rloss*abs(xheck) .gt. precx*smax ) print *,
     +			'fftran: error: No momentum conservation in ',
     +			'qiDqj, i=',i,' j=5678 ',xheck,smax,ier
		xheck = qiDqj(i,5)+qiDqj(i,6)+qiDqj(i,9)
		smax = max(abs(qiDqj(i,5)),abs(qiDqj(i,6)),
     +			abs(qiDqj(i,9)))
		if ( rloss*abs(xheck) .gt. precx*smax ) print *,
     +			'fftran: error: No momentum conservation in ',
     +			'qiDqj, i=',i,' j=569 ',xheck,smax,ier
		xheck = qiDqj(i,5)+qiDqj(i,10)+qiDqj(i,8)
		smax = max(abs(qiDqj(i,5)),abs(qiDqj(i,10)),
     +			abs(qiDqj(i,8)))
		if ( rloss*abs(xheck) .gt. precx*smax ) print *,
     +			'fftran: error: No momentum conservation in ',
     +			'qiDqj, i=',i,' j=5810 ',xheck,smax,ier
  840	    continue
	endif
*  #] pi.pj -> qi.qj: 
*  #[ si^2 - sj^2:
*
*	the differences may be awkward
*
	ier2 = ier
	do 140 i=1,4
	    dqiqj(i,i) = 0
	    do 130 j=i+1,4
		ier0 = ier
		dqiqj(j,i) = xqi(j) - xqi(i)
		smax = abs(xqi(i))
		if ( abs(dqiqj(j,i)) .ge. xloss*smax ) goto 125
		if ( lwrite ) print *,'dqiqj(',j,i,')  = ',
     +			dqiqj(j,i),xqi(j),-xqi(i),ier2
		if ( abs(daiaj(j,i)) .le. xloss*abs(ai(i)) )
     +								then
		    s(1) = daiaj(j,i)*(ai(i)+ai(j))*xpi(j)
		    s(2) = ai(i)**2*dpipj(j,i)
		    som = s(1) + s(2)
		    xmax = abs(s(1))
		    if ( lwrite ) print *,'dqiqj(',j,i,')+ = ',
     +				som,s(1),s(2),ier2
		    if ( xmax.lt.smax ) then
			dqiqj(j,i) = som
			smax = xmax
		    endif
		    if ( abs(dqiqj(j,i)) .ge. xloss*smax ) goto 125
		endif
*
*		give up
*
		call ffwarn(125,ier0,dqiqj(j,i),smax)
		if ( lwrite ) print *,' (between qi(',i,') and qi(',j,
     +			'))'
  125		continue
		dqiqj(i,j) = -dqiqj(j,i)
		ier2 = max(ier2,ier0)
  130	    continue
  140	continue
*  #] si^2 - sj^2: 
*  #[ si^2 - pj^2:
	do 210 i=1,4
	    do 200 j=1,4
		do 190 kk=j+1,4
		    ier0 = ier
		    k = kk
		    kj = inx(k,j)
		    kkj = kj
*
*		    Use that q_(i4)^2 = q_(i3)^2
*
		    if ( del2s.ne.0 .and. k.eq.4 ) then
			if ( j .eq. 3 ) then
			    dqiqj(7,i) = -xqi(i)
			else
			    dqiqj(kj,i) = dqiqj(inx(j,3),i)
			endif
			goto 185
		    elseif ( kj .eq. 7 ) then
			dqiqj(7,i) = -xqi(i)
			goto 185
		    endif
		    xmax = 0
  181		    continue
		    som = xqi(kj) - xqi(i)
		    if ( lwrite .and. kk .ne. k ) print *,'dqiqj(',kj,i,
     +			')4+= ',som,xqi(kj),xqi(i),ier2
		    if ( k.eq.kk .or. abs(xqi(i)).lt.xmax ) then
			dqiqj(kj,i) = som
			xmax = abs(xqi(i))
			if ( abs(dqiqj(kj,i)) .ge. xloss*xmax ) goto 185
		    endif
		    if ( lwrite .and. kk .eq. k ) print *,'dqiqj(',kj,i,
     +			')  = ',dqiqj(kj,i),xqi(kj),xqi(i),ier2
*
*		    second try
*		    we assume that qi.qj, i,j<=3 are known
*
		    if ( abs(dqiqj(k,i)) .lt. abs(dqiqj(j,i)) ) then
			j1 = k
			j2 = j
		    else
			j2 = k
			j1 = j
		    endif
		    s(1) = dqiqj(j1,i)
		    s(2) = xqi(j2)
		    s(3) = -2*qiDqj(j1,j2)
		    som = s(1) + s(2) + s(3)
		    smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
		    if ( lwrite ) print *,'dqiqj(',kj,i,')+ = ',
     +			som,s(1),s(2),s(3),ier2
		    if ( smax.lt.xmax ) then
			dqiqj(kj,i) = som
			xmax = smax
			if ( abs(dqiqj(kj,i)) .ge. xloss*xmax ) goto 185
		    endif
*
*		    third try: rearrange s(2),s(3)
*		    this works if ai(j1)~ai(j2)
*
		    if ( abs(daiaj(j2,j1)) .lt. xloss*abs(ai(j1)) ) then
			s(2) = ai(j2)*daiaj(j2,j1)*xpi(j2)
			s(3) = ai(j2)*ai(j1)*dpipj(kj,j1)
			som = s(1) + s(2) + s(3)
			smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
			if ( lwrite ) print *,'dqiqj(',kj,i,')++= ',
     +				som,s(1),s(2),s(3),ier2
			if ( smax.lt.xmax ) then
			    dqiqj(kj,i) = som
			    xmax = smax
			    if ( abs(dqiqj(kj,i)) .ge. xloss*xmax )
     +				goto 185
			endif
		    endif
*
*		    There is a trick involving the other root for j2=4
*		    Of course it also works for j2=3.
*
		    if ( laai .and. j2 .ge. 3 ) then
			s(2) = -ai(4)**2*(ai(j1)/aai(j1))*xpi(4)
			som = s(1) + s(2)
			smax = abs(s(1))
			if ( lwrite ) print *,'dqiqj(',kj,i,')3+= ',
     +				som,s(1),s(2),ier2
			if ( smax.lt.xmax ) then
			    dqiqj(kj,i) = som
			    xmax = smax
			    if ( abs(dqiqj(kj,i)) .ge. xloss*xmax )
     +				goto 185
			endif
		    endif
*
*		    If k = 3 we can also try with k = 4 -- should give
*		    the same
*
		    if ( del2s.ne.0 .and. kk.eq.3 .and. k.eq.3 ) then
			k = 4
			kj = inx(k,j)
			dqiqj(kj,i) = dqiqj(kkj,i)
			if ( lwrite ) print *,'trying with ',kj,
     +				' instead of ',kkj
			goto 181
		    endif
		    if ( del2s.ne.0 .and. kk.eq.4 .and. k.eq.4 ) then
			k = 3
			kj = inx(k,j)
			dqiqj(kj,i) = dqiqj(kkj,i)
			if ( lwrite ) print *,'trying with ',kj,
     +				' instead of ',kkj
			goto 181
		    endif
*
*		    give up
*
		    call ffwarn(126,ier0,dqiqj(kj,i),xmax)
		    if ( lwrite ) print *,' (between qi(',kj,') and qi('
     +			,i,'))'

  185		    continue
		    if ( k .ne. kk ) then
			dqiqj(kkj,i) = dqiqj(kj,i)
			dqiqj(i,kkj) = -dqiqj(kj,i)
		    else
			dqiqj(i,kj) = -dqiqj(kj,i)
		    endif
		    ier2 = max(ier2,ier0)
  190		continue
  200	    continue
  210	continue
*  #] si^2 - pj^2:
*  #[ pi^2 - pj^2:
	do 280 i=1,4
	    do 270 j=i+1,4
		ji = inx(j,i)
		dqiqj(ji,ji) = 0
		do 260 k=i,4
		    do 250 l=k+1,4
			ier0 = ier
			if ( k .eq. i .and. l .le. j ) goto 250
			lk = inx(l,k)
			if ( del2s .eq. 0 ) then
*
*			    special case:
*
			    if ( j.eq.4 .and. i.eq.3 ) then
				dqiqj(lk,7) = xqi(lk)
				goto 245
			    endif
			    if ( l.eq.4 .and. k.eq.3 ) then
				dqiqj(7,ji) = -xqi(ji)
				goto 245
			    endif
			else
*
*			Use that t_3.p_i = t_4.p_i
*
			    if ( k.eq.i .and. j.eq.3 .and. l.eq.4 ) then
				dqiqj(lk,ji) = 0
				goto 245
			    endif
			    if ( j.eq.4 ) then
				if ( i .eq. 3 ) then
				    dqiqj(lk,7) = xqi(lk)
				else
				    dqiqj(lk,ji) = dqiqj(lk,inx(i,3))
				endif
				goto 245
			    endif
			    if ( l.eq.4 ) then
				if ( k .eq. 3 ) then
				    dqiqj(7,ji) = -xqi(ji)
				else
				    dqiqj(lk,ji) = dqiqj(inx(k,3),ji)
				endif
				goto 245
			    endif
			endif
*
*			We really have to calculate something
*
			dqiqj(lk,ji) = xqi(lk) - xqi(ji)
			smax = abs(xqi(lk))
			if ( abs(dqiqj(lk,ji)).ge.xloss*smax ) goto 245
			if ( lwrite ) print *,'dqiqj(',lk,ji,')  =',
     +				dqiqj(lk,ji),xqi(lk),xqi(ji),ier2
*
*			First the special case j=k,l
*
			i1 = i
			j1 = j
			k1 = k
			lgo = .FALSE.
			if ( j .eq. k ) then
			    k1 = l
			    lgo = .TRUE.
			elseif ( j .eq. l ) then
			    lgo = .TRUE.
			elseif ( i .eq. k ) then
			    i1 = j
			    j1 = i
			    k1 = l
			    lgo = .TRUE.
			endif
			if ( lgo ) then
			    s(1) = dqiqj(k1,i1)
			    s(2) = 2*isgn(i1,k1)*qiDqj(j1,inx(i1,k1))
			    xmax = abs(s(1))
			    if ( xmax .lt. smax ) then
				smax = xmax
				dqiqj(lk,ji) = s(1) + s(2)
				if ( lwrite ) print *,'dqiqj(',lk,ji,
     +				  ')+ =',dqiqj(lk,ji),s(1),s(2),ier2
				if ( abs(dqiqj(lk,ji)).ge.xloss*smax )
     +						goto 245
			    endif
			endif
*
*			Just some recombinations
*
			if ( abs(dqiqj(l,ji)).lt.abs(dqiqj(k,ji)) ) then
			    j1 = l
			    j2 = k
			else
			    j2 = l
			    j1 = k
			endif
			s(1) = dqiqj(j1,ji)
			s(2) = xqi(j2)
			s(3) = -2*qiDqj(j1,j2)
*			only if this is an improvement
			xmax = max(abs(s(1)),abs(s(2)),abs(s(3)))
			if (  xmax .lt. smax ) then
			    smax = xmax
			    dqiqj(lk,ji) = s(1) + s(2) + s(3)
			    if ( lwrite ) print *,'dqiqj(',lk,ji,')+1=',
     +				dqiqj(lk,ji),s(1),s(2),s(3),ier2
			    if ( abs(dqiqj(lk,ji)) .ge. xloss*smax )
     +				goto 245
			endif
			if ( abs(dqiqj(j,lk)).lt.abs(dqiqj(i,lk)) ) then
			    j1 = j
			    j2 = i
			else
			    j2 = j
			    j1 = i
			endif
			s(1) = -dqiqj(j1,lk)
			s(2) = -xqi(j2)
			s(3) = 2*qiDqj(j1,j2)
*			only if this is an improvement
			xmax = max(abs(s(1)),abs(s(2)),abs(s(3)))
			if (  xmax .lt. smax ) then
			    dqiqj(lk,ji) = s(1) + s(2) + s(3)
			    smax = xmax
			    if ( lwrite ) print *,'dqiqj(',lk,ji,')+2=',
     +				dqiqj(lk,ji),s(1),s(2),s(3),ier2
			    if ( abs(dqiqj(lk,ji)) .ge. xloss*smax )
     +				goto 245
			endif
*
*			give up
*
			call ffwarn(127,ier0,dqiqj(lk,ji),smax)
			if ( lwrite ) print *,' (between qi(',lk,
     +				') and qi(',ji,'))'

  245			continue
			dqiqj(ji,lk) = -dqiqj(lk,ji)
			ier2 = max(ier2,ier0)
  250		    continue
  260		continue
  270	    continue
  280	continue
	ier = ier2
*  #] pi^2 - pj^2: 
*  #[ debug:
	if ( lwrite ) then
	    print *,'fftran: transformed momenta'
	    print *,xqi
	    print '(10e16.8)',qiDqj
	    print *,'ier = ',ier
	endif
*  #] debug: 
*###] fftran:
	end
*###[ ffxb0:
	subroutine ffxb0(cb0,d0,xmu,xp,xma,xmb,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the the two-point function (cf 't Hooft and Veltman)	*
*	we include an overall factor 1/(i*pi^2)	relative to FormF	*
*									*
*	Input:	d0	(real)	  infinity arising from renormalization	*
*		xmu	(real)	  renormalization mass			*
*		xp	(real)	  k2, in B&D metric			*
*		xma	(real)	  mass2					*
*		xmb	(real)	  mass2					*
*									*
*	Output:	cb0	(complex) B0, the two-point function,		*
*		ier	(integer) # of digits lost, if >=100: error	*
*									*
*	Calls:	ffxb0p							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cb0
	DOUBLE PRECISION d0,xmu,xp,xma,xmb
*
*	local variables
*
	integer ier0
	DOUBLE COMPLEX cb0p,c
	DOUBLE PRECISION dmamb,dmap,dmbp,xm,absc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffxb0: nevent,id = ',nevent,id,' input:'
	    print *,'xma,xmb,xp,ier = ',xma,xmb,xp,ier
	endif
	if ( ltest ) then
	    if ( xma .lt. 0 .or. xmb .lt. 0 ) then
		print *,'ffxb0: error: xma,b < 0: ',xma,xmb
		stop
	    endif
	endif
*  #] check input:
*  #[ get differences:
	ier0 = 0
	dmamb = xma - xmb
	dmap = xma - xp
	dmbp = xmb - xp
	if ( lwarn ) then
	    if ( abs(dmamb) .lt. xloss*abs(xma) .and. xma .ne. xmb )
     +		call ffwarn(97,ier0,dmamb,xma)
	    if ( abs(dmap) .lt. xloss*abs(xp) .and. xp .ne. xma )
     +		call ffwarn(98,ier0,dmap,xp)
	    if ( abs(dmbp) .lt. xloss*abs(xp) .and. xp .ne. xmb )
     +		call ffwarn(99,ier0,dmbp,xp)
	endif
*  #] get differences:
*  #[ calculations:
	call ffxb0p(cb0p,xp,xma,xmb,dmap,dmbp,dmamb,ier)
	if ( xma .eq. 0 ) then
	    if ( xmb .eq. 0 ) then
		xm = x1
	    else
		xm = xmb**2
	    endif
	elseif ( xmb .eq. 0 ) then
	    xm = xma**2
	else
	    xm = xma*xmb
	endif
	if ( xmu .ne. 0 ) xm = xm/xmu**2
	if ( abs(xm) .gt. xalogm ) then
	    cb0 = DBLE(d0 - log(xm)/2) - cb0p
	    if ( lwarn .and. absc(cb0).lt.xloss*max(abs(d0),absc(cb0p)))
     +		call ffwarn(150,ier,absc(cb0),max(abs(d0),absc(cb0p)))
	else
	    call fferr(4,ier)
	    cb0 = DBLE(d0) - cb0p
	endif
	if ( lwrite ) print *,'B0 = ',cb0,ier
*  #] calculations:
*###] ffxb0:
	end
*###[ ffxb0p:
	subroutine ffxb0p(cb0p,xp,xma,xmb,dmap,dmbp,dmamb,ier)
***#[*comment:***********************************************************
*									*
*	calculates the two-point function (see 't Hooft and		*
*	Veltman) for all possible cases: masses equal, unequal,		*
*	equal to zero.							*
*									*
*	Input:	xp	(real) p.p, in B&D metric			*
*		xma	(real) mass2,					*
*		xmb	(real) mass2,					*
*		dm[ab]p	(real) xm[ab] - xp				*
*		dmamb	(real) xma - xmb				*
*									*
*	Output:	cb0p	(complex) B0, the two-point function, minus	*
*				  log(xm1*xm2)/2, delta and ipi^2	*
*		ier	(integer) 0=ok, 1=numerical problems, 2=error	*
*									*
*	Calls:	ffxb0q.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cb0p
	DOUBLE PRECISION xp,xma,xmb,dmap,dmbp,dmamb
*
*	local variables
*
	integer i,initeq,initn1,iflag,jsign,init
	DOUBLE PRECISION ax,ay,ffbnd,
     +		xprceq,bdeq01,bdeq05,bdeq11,bdeq17,bdeq25,
     +		xprcn1,bdn101,bdn105,bdn110,bdn115,bdn120,
     +		xprnn2,bdn201,bdn205,bdn210,bdn215,bdn220,
     +		xprcn3,bdn301,bdn305,bdn310,bdn315,
     +		xprcn5,bdn501,bdn505,bdn510,bdn515,
     +		absc
	DOUBLE PRECISION xcheck,xm,dmp,xm1,xm2,dm1m2,dm1p,
     +		dm2p,s,s1,s1a,s1b,s1p,s2,s2a,s2b,s2p,x,y,som,
     +		xlam,slam,xlogmm,alpha,alph1,xnoe,xpneq(30),
     +		xpnn1(30),xx,xtel,dfflo1
	DOUBLE COMPLEX cs2a,cs2b,cs2p,c,cx
	save initeq,initn1,init,xpneq,xpnn1,
     +		xprceq,bdeq01,bdeq05,bdeq11,bdeq17,bdeq25,
     +		xprcn1,bdn101,bdn105,bdn110,bdn115,bdn120,
     +		xprnn2,bdn201,bdn205,bdn210,bdn215,bdn220,
     +		xprcn3,bdn301,bdn305,bdn310,bdn315,
     +		xprcn5,bdn501,bdn505,bdn510,bdn515
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data xprceq /-1./
	data xprcn1 /-1./
	data xprnn2 /-1./
	data xprcn3 /-1./
	data xprcn5 /-1./
	data initeq /0/
	data initn1 /0/
	data init /0/
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if (ltest) then
	    xcheck = xma - xmb - dmamb
	    if ( abs(xcheck) .gt. precx*max(abs(xma),abs(xmb),abs(
     +			dmamb))/xloss ) then
		print *,'ffxb0q: input not OK, dmamb <> xma-xmb',xcheck
	    endif
	    xcheck = -xp + xma - dmap
	    if ( abs(xcheck) .gt. precx*max(abs(xp),abs(xma),abs(
     +			dmap))/xloss ) then
		print *,'ffxb0q: input not OK, dmap <> xma - xp',xcheck
	    endif
	    xcheck = -xp + xmb - dmbp
	    if ( abs(xcheck) .gt. precx*max(abs(xp),abs(xmb),abs(
     +			dmbp))/xloss ) then
		print *,'ffxb0q: input not OK, dmbp <> xmb - xp',xcheck
	    endif
	endif
*  #] check input:
*  #[ fill some dotproducts:
	if ( ldot ) then
	    call ffdot2(fpij2,xp,xma,xmb,dmap,dmbp,dmamb,ier)
	endif
*  #] fill some dotproducts:
*  #[ which case:
*
*	sort according to the type of masscombination encountered:
*	100: both masses zero, 200: one equal to zero, 300: both equal
*	400: rest.
*
	if ( xma .eq. 0 ) then
		if ( xmb .eq. 0 ) then
			goto 100
		endif
		xm = xmb
		dmp = dmbp
		goto 200
	endif
	if ( xmb .eq. 0 ) then
		xm = xma
		dmp = dmap
		goto 200
	elseif ( dmamb .eq. 0 ) then
		xm = xma
		dmp = dmap
		goto 300
	elseif ( xma .gt. xmb ) then
		xm2 = xma
		xm1 = xmb
		dm1m2 = -dmamb
		dm1p = dmbp
		dm2p = dmap
	else
		xm1 = xma
		xm2 = xmb
		dm1m2 = dmamb
		dm1p = dmap
		dm2p = dmbp
	endif
	goto 400
*  #] which case:
*  #[ both masses equal to zero:
  100	continue
	if ( xp .lt. -xalogm ) then
	    cb0p = log(-xp) - 2
	elseif ( xp .gt. xalogm ) then
	    cb0p = DCMPLX( DBLE(log(xp) - 2), DBLE(-pi) )
	else
	    cb0p = 0
	    call fferr(7,ier)
	endif
	return
*  #] both masses equal to zero:
*  #[ one mass equal to zero:
  200	continue
*
*	special case xp = 0
*
	if ( xp .eq. 0 ) then
	    cb0p = -1
	    goto 990
*
*	special case xp = xm
*
	elseif ( dmp.eq.0 ) then
	    cb0p = -2
	    goto 990
	endif
*
*	Normal case:
*
	s1 = xp/xm
	if ( abs(s1) .lt. xloss ) then
	    s = dfflo1(s1,ier)
	else
	    s = log(abs(dmp/xm))
	endif
	s = -s*dmp/xp
	cb0p = s - 2
	if ( xp .gt. xm )
     +		cb0p = cb0p - DCMPLX(DBLE(x0),DBLE(-(dmp/xp)*pi))
	if ( lwarn .and. absc(cb0p) .lt. xloss*x2 )
     +		call ffwarn(14,ier,absc(cb0p),x2)
	goto 990
*  #] one mass equal to zero:
*  #[ both masses equal:
  300	continue
*
*	Both masses are equal.	Not only this speeds up things, some
*	cancellations have to be avoided as well.
*
*	first a special case
*
	if ( abs(xp) .lt. 8*xloss*xm ) then
* -#[	    taylor expansion:
*
*	    a Taylor expansion seems appropriate as the result will go
*	    as k^2 but seems to go as 1/k !!
*
*--#[	    data and bounds:
	    if ( initeq .eq. 0 ) then
		initeq = 1
		xpneq(1) = x1/6
		do 1 i=2,30
		    xpneq(i) = - xpneq(i-1)*DBLE(i-1)/DBLE(2*(2*i+1))
    1		continue
	    endif
	    if (xprceq .ne. precx ) then
*
*		calculate the boundaries for the number of terms to be
*		included in the taylorexpansion
*
		xprceq = precx
		bdeq01 = ffbnd(1,1,xpneq)
		bdeq05 = ffbnd(1,5,xpneq)
		bdeq11 = ffbnd(1,11,xpneq)
		bdeq17 = ffbnd(1,17,xpneq)
		bdeq25 = ffbnd(1,25,xpneq)
	    endif
*--#]	    data and bounds:
	    x = -xp/xm
	    ax = abs(x)
	    if ( lwarn .and. ax .gt. bdeq25 ) then
		call ffwarn(15,ier,precx,abs(xpneq(25))*ax**25)
	    endif
	    if ( ax .gt. bdeq17 ) then
		som = x*(xpneq(18) + x*(xpneq(19) + x*(xpneq(20) +
     +		x*(xpneq(21) + x*(xpneq(22) + x*(xpneq(23) +
     +		x*(xpneq(24) + x*(xpneq(25) ))))))))
	    else
		som = 0
	    endif
	    if ( ax .gt. bdeq11 ) then
		som = x*(xpneq(12) + x*(xpneq(13) + x*(xpneq(14) +
     +		x*(xpneq(15) + x*(xpneq(16) + x*(xpneq(17) + som ))))
     +		))
	    endif
	    if ( ax .gt. bdeq05 ) then
		som = x*(xpneq(6) + x*(xpneq(7) + x*(xpneq(8) + x*(
     +		xpneq(9) + x*(xpneq(10) + x*(xpneq(11) + som ))))))
	    endif
	    if ( ax .gt. bdeq01 ) then
		som = x*(xpneq(2) + x*(xpneq(3) + x*(xpneq(4) + x*(
     +		xpneq(5) + som ))))
	    endif
	    cb0p = x*(xpneq(1)+som)
	    if (lwrite) then
		print *,'ffxb0q: m1 = m2, Taylor expansion in ',x
	    endif
	    goto 990
* -#]	    taylor expansion:
	endif
* -#[	normal case:
*
*	normal case
*
	call ffxlmb(xlam,-xp,-xm,-xm,dmp,dmp,x0,ier)
	if ( xlam .ge. 0 ) then
*	    cases 1,2 and 4
	    slam = sqrt(xlam)
	    s2a = dmp + xm
	    s2 = s2a + slam
	    if ( abs(s2) .gt. xloss*slam ) then
*		looks fine
		jsign = 1
	    else
		s2 = s2a - slam
		jsign = -1
	    endif
	    ax = abs(s2/(2*xm))
	    if ( ax .lt. xalogm ) then
		if ( lwarn ) call ffwarn(16,ier,ax,xalogm)
		s = 0
	    elseif( ax-1 .lt. .1 .and. s2 .gt. 0 ) then
*		In this case a quicker and more accurate way is to
*		calculate log(1-x).
		s2 = (xp - slam)
*		the following line is superfluous.
		if ( lwarn .and. abs(s2) .lt. xloss*slam )
     +			call ffwarn(17,ier,s2,slam)
		s = -slam/xp*dfflo1(s2/(2*xm),ier)
	    else
*		finally the normal case
		s = -slam/xp*log(ax)
		if ( jsign .eq. -1 ) s = -s
	    endif
	    if ( xp .gt. 2*xm ) then
*		in this case ( xlam>0, so xp>(2*m)^2) ) there also
*		is an imaginary part
		y = -pi*slam/xp
	    else
		y = 0
	    endif
	else
*	    the root is complex (k^2 between 0 and (2*m1)^2)
	    slam = sqrt(-xlam)
	    s = 2*slam/xp*atan2(xp,slam)
	    y = 0
	endif
	if (lwrite) print *,'s =   ',s
	xx = s - 2
	if ( lwarn .and. abs(xx).lt.xloss*2 ) call ffwarn(18,ier,xx,x2)
	cb0p = DCMPLX(DBLE(xx),DBLE(y))
	goto 990
* -#]	normal case:
*
*  #] both masses equal:
*  #[ unequal nonzero masses:
* -#[	get log(xm2/xm1):
  400	continue
	x = xm2/xm1
	if ( 1 .lt. xalogm*x ) then
	    call fferr(8,ier)
	    xlogmm = 0
	elseif ( abs(x-1) .lt. xloss ) then
	    xlogmm = dfflo1(dm1m2/xm1,ier)
	else
	    xlogmm = log(x)
	endif
* -#]	get log(xm2/xm1):
* -#[	xp = 0:
*
*	first a special case
*
	if ( xp .eq. 0 ) then
	    s2 = ((xm2+xm1) / dm1m2)*xlogmm
	    s = - s2 - 2
*	    save the factor 1/2 for the end
	    if (lwrite) print *,'s = ',s/2
*	    save the factor 1/2 for the end
	    if ( abs(s) .lt. xloss*2 ) then
*		Taylor expansions: choose which one
		x = dm1m2/xm1
		ax = abs(x)
		if ( ax .lt. .15 .or. precx .gt. 1.E-8 .and. ax
     +			.lt. .3 ) then
*
*		    This is the simple Taylor expansion 'n1'
*
*--#[		    data and bounds:
*		    get the coefficients of the taylor expansion
		    if ( initn1 .eq. 0 ) then
			initn1 = 1
			do 410 i = 1,30
  410			    xpnn1(i) = DBLE(i)/DBLE((i+1)*(i+2))
		    endif
*		    determine the boundaries for 1,5,10,15 terms
		    if ( xprcn1 .ne. precx ) then
			xprcn1 = precx
			bdn101 = ffbnd(1,1,xpnn1)
			bdn105 = ffbnd(1,5,xpnn1)
			bdn110 = ffbnd(1,10,xpnn1)
			bdn115 = ffbnd(1,15,xpnn1)
			bdn120 = ffbnd(1,20,xpnn1)
		    endif
*--#]		    data and bounds:
*		    calculate:
		    if ( lwarn .and. ax .gt. bdn120 )
     +			call ffwarn(19,ier,precx,abs(xpnn1(20))*ax**19)
		    if ( ax .gt. bdn115 ) then
			s = x*(xpnn1(16) + x*(xpnn1(17) + x*(xpnn1(18) +
     +			    x*(xpnn1(19) + x*(xpnn1(20)) ))))
		    else
			s = 0
		    endif
		    if ( ax .gt. bdn110 ) then
			s = x*(xpnn1(11) + x*(xpnn1(12) + x*(xpnn1(13) +
     +			    x*(xpnn1(14) + x*(xpnn1(15)) + s))))
		    endif
		    if ( ax .gt. bdn105 ) then
			s = x*(xpnn1(6) + x*(xpnn1(7) + x*(xpnn1(8) + x*
     +			      (xpnn1(9) + x*(xpnn1(10) + s)))))
		    endif
		    if ( ax .gt. bdn101 ) then
			s = x*(xpnn1(2) + x*(xpnn1(3) + x*(xpnn1(4) + x*
     +			(xpnn1(5) +s))))
		    endif
		    s = x*x*(xpnn1(1) + s)
		    if (lwrite) then
			print *,'ffxb0q: xp = 0, simple Taylor exp'
			print *,'	 in ',x
			print *,'	 gives s ',s/2
		    endif
		else
*
*		    This is the more complicated Taylor expansion 'fc'
*
*  #[		    bounds:
*		    determine the boundaries for 1,5,10,15 terms for
*		    the exponential taylor expansion, assuming it
*		    starts at n=2.
*
		    if ( xprnn2 .ne. precx ) then
			xprnn2 = precx
			bdn201 = ffbnd(4,1,xinfac)
			bdn205 = ffbnd(4,5,xinfac)
			bdn210 = ffbnd(4,10,xinfac)
			bdn215 = ffbnd(4,15,xinfac)
			bdn220 = ffbnd(4,20,xinfac)
		    endif
*  #]		    bounds:
*		    calculate:
		    y = 2*x/(2-x)
		    ay = abs(y)
		    if ( lwarn .and. ay .gt. bdn220 )
     +			call ffwarn(20,ier,precx,xinfac(23)*ay**23)
		    if ( ay .gt. bdn220 ) then
			s = y*(xinfac(19) + y*(xinfac(20) + y*(xinfac(
     +				      21) + y*(xinfac(22) + y*(xinfac(
     +				      23) )))))
		    else
			s = 0
		    endif
		    if ( ay .gt. bdn215 ) then
			s = y*(xinfac(14) + y*(xinfac(15) + y*(xinfac(
     +				      16) + y*(xinfac(17) + y*(xinfac(
     +				      18) + s)))))
		    endif
		    if ( ay .gt. bdn210 ) then
			s = y*(xinfac(9) + y*(xinfac(10) + y*(xinfac(11)
     +			  + y*(xinfac(12) + y*(xinfac(13) + s)))))
		    endif
		    if ( ay .gt. bdn205 ) then
			s = y*(xinfac(5) + y*(xinfac(6) + y*(xinfac(7) +
     +			    y*(xinfac(8) + s))))
		    endif
		    s = (1-x)*y**4*(xinfac(4)+s)
		    s = x*y**2*(1+y)/12 - s
		    s = - 2*dfflo1(s,ier)/y
		    if (lwrite) then
			print *,'ffxb0q: xp = 0, other Taylor expansion'
			print *,'	 in ',y
			print *,'	 s = ',s/2
		    endif
		endif
	    endif
	    cb0p = s/2
	    goto 990
	endif
* -#]	xp = 0:
* -#[	normal case:
*
*	proceeding with the normal case
*
	call ffxlmb(xlam,-xp,-xm2,-xm1,dm2p,dm1p,dm1m2,ier)
	if ( xlam .gt. 0 ) then
*	    cases k^2 < -(m2+m1)^2 or k^2 > -(m2-m1)^2:
*--#[	    first try:
*	    first try the normal way
	    iflag = 0
	    slam = sqrt(xlam)
	    s2a = dm2p + xm1
	    s2 = s2a + slam
	    if ( abs(s2) .gt. xloss*slam ) then
*		looks fine
		jsign = 1
	    else
		s2 = s2a - slam
		jsign = -1
	    endif
	    s2 = s2**2/(4*xm1*xm2)
	    if ( abs(s2) .lt. xalogm ) then
		call fferr(9,ier)
		s2 = 0
	    elseif ( abs(s2-1) .lt. xloss ) then
		if ( jsign.eq.1 ) then
		    if ( lwrite ) print *,'s2 was ',-slam/(2*xp)*log(s2)
		    s2 = -slam*(s2a+slam)/(2*xm1*xm2)
		    s2 = -slam/(2*xp)*dfflo1(s2,ier)
		else
		    if ( lwrite ) print *,'s2 was ',+slam/(2*xp)*log(s2)
		    s2 = +slam*(s2a-slam)/(2*xm1*xm2)
		    s2 = +slam/(2*xp)*dfflo1(s2,ier)
		endif
		if ( lwrite ) print *,'s2 is  ',s2,jsign
	    else
		s2 = -slam/(2*xp)*log(s2)
		if ( jsign .eq. -1 ) s2 = -s2
	    endif
	    s1 = -dm1m2*xlogmm/(2*xp)
	    xx = s1+s2-2
	    if (lwrite) then
		print *,'ffxb0q: lam>0, first try, xx  = ',xx,s1,s2,-2
	    endif
*--#]	    first try:
	    if ( abs(xx) .lt. xloss*max(abs(s1),abs(s2)) ) then
*--#[		second try:
*		this is unacceptable, try a better solution
		s1a = dm1m2 + slam
		if (lwrite) print *,'s1 = ',-s1a/(2*xp),slam/(2*xp)
		if ( abs(s1a) .gt. xloss*slam ) then
*		    (strangely) this works
		    s1 = -s1a/(2*xp)
		else
*		    by division a more accurate form can be found
		    s1 = ( -xp/2 + xm1 + xm2 ) / ( slam - dm1m2 )
		    if (lwrite) print *,'s1+= ',s1
		endif
		s1 = s1*xlogmm
		if ( abs(xp) .lt. xm2 ) then
		    s2a = xp - dm1m2
		else
		    s2a = xm2 - dm1p
		endif
		s2 = s2a - slam
		if (lwrite) print *,'s2 = ',s2/(2*xm2),slam/(2*xm2)
		if ( abs(s2) .gt. xloss*slam ) then
*		    at least reasonable
		    s2 = s2 / (2*xm2)
		else
*		    division again
		    s2 = (2*xp) / (s2a+slam)
		    if (lwrite) print *,'s2+= ',s2
		endif
		if ( abs(s2) .lt. .1 ) then
*		    choose a quick way to get the logarithm
		    s2 = dfflo1(s2,ier)
		else
		    s2a = abs(1-s2)
		    s2 = log(s2a)
		endif
		s2 = -(slam/xp)*s2
		xx = s1 + s2 - 2
		if (lwrite) then
		    print *,'ffxb0q: lam>0, second try, xx  = ',xx
		    alpha = slam/(slam-dm1m2)
		    alph1 = -dm1m2/(slam-dm1m2)
		    print *,'	     alpha = ',alpha
		    print *,'	     s1 = ',s1,',- 2alph1 = ',s1-2*alph1
		    print *,'	     s2 = ',s2,',- 2alpha = ',s2-2*alpha
		endif
*--#]		second try:
		if ( abs(xx) .lt. xloss**2*max(abs(s1),abs(s2)) ) then
*--#[		    third try:
*		    (we accept two times xloss because that's the same
*		    as in this try)
*		    A Taylor expansion might work.  We expand
*		    inside the logs. Only do the necessary work.
*
		    alpha = slam/(slam-dm1m2)
		    alph1 = -dm1m2/(slam-dm1m2)
*
*		    First s1:
*
		    s1p = s1 - 2*alph1
		    if ( abs(s1p) .lt. xloss*abs(s1) ) then
* -#[			bounds:
*			determine the boundaries for 1,5,10,15 terms
			if ( xprcn3 .ne. precx ) then
			    xprcn3 = precx
			    bdn301 = ffbnd(3,1,xinfac)
			    bdn305 = ffbnd(3,5,xinfac)
			    bdn310 = ffbnd(3,10,xinfac)
			    bdn315 = ffbnd(3,15,xinfac)
			endif
* -#]			bounds:
			xnoe = -xp + 2*xm1 + 2*xm2
			x = 4*dm1m2/xnoe
			ax = abs(x)
			if ( lwarn .and. ax .gt. bdn315 ) then
			    call ffwarn(21,ier,precx,xinfac(17)*ax**14)
			endif
			if ( ax .gt. bdn310 ) then
			    s1a = x*(xinfac(13) + x*(xinfac(14) + x*(
     +				     xinfac(15) + x*(xinfac(16) + x*(
     +				     xinfac(17))))))
			else
			    s1a = 0
			endif
			if ( ax .gt. bdn305 ) then
			    s1a = x*(xinfac(8) + x*(xinfac(9) + x*(
     +				   xinfac(10) + x*(xinfac(11) + x*(
     +				   xinfac(12) + s1a)))))
			endif
			if ( ax .gt. bdn301 ) then
			    s1a = x*(xinfac(4) + x*(xinfac(5) + x*(
     +				     xinfac(6) + x*(xinfac(7) + s1a))))
			endif
			s1a = x**3 *(xinfac(3) + s1a) *xm2/xm1
			s1b = dm1m2*(4*dm1m2**2 - xp*(4*xm1-xp))/
     +				(xm1*xnoe**2)
			s1p = s1b - s1a
			if ( lwarn .and. abs(s1p).lt.xloss*abs(s1a) )
     +			    call ffwarn(22,ier,s1p,s1a)
			s1p = xnoe*dfflo1(s1p,ier)/(slam - dm1m2)/2
			if (lwrite) then
			    print *,'ffxb0q: Taylor exp. of s1-2(1-a)'
			    print *,'	     in x = ',x
			    print *,'	     gives s1p = ',s1p
			endif
		    endif
*
*		    next s2:
*
  490		    s2p = s2 - 2*alpha
		    if ( abs(s2p) .lt. xloss*abs(s2) ) then
* -#[			bounds:
*			determine the boundaries for 1,5,10,15 terms
			if ( xprcn5 .ne. precx ) then
			    xprcn5 = precx
			    bdn501 = ffbnd(4,1,xinfac)
			    bdn505 = ffbnd(4,5,xinfac)
			    bdn510 = ffbnd(4,10,xinfac)
			    bdn515 = ffbnd(4,15,xinfac)
			endif
* -#]			bounds:
			xnoe = slam - dm1m2
			x = 2*xp/xnoe
			ax = abs(x)
			if ( ax .gt. bdn515 ) then
*			    do not do the Taylor expansion
			    if ( lwarn ) call ffwarn(23,ier,s2p,s2) 
			    goto 495
			endif
			if ( ax .gt. bdn510 ) then
			    s2a = x*(xinfac(14) + x*(xinfac(15) + x*(
     +				     xinfac(16) + x*(xinfac(17) + x*(
     +				     xinfac(18))))))
			else
			    s2a = 0
			endif
			if ( ax .gt. bdn505 ) then
			    s2a = x*(xinfac(9) + x*(xinfac(10) + x*(
     +				    xinfac(11) + x*(xinfac(12) + x*(
     +				    xinfac(13) + s2a)))))
			endif
			if ( ax .gt. bdn501 ) then
			    s2a = x*(xinfac(5) + x*(xinfac(6) + x*(
     +				     xinfac(7) + x*(xinfac(8) + s2a))))
			endif
			s2a = x**4*(xinfac(4)+s2a)*(1-2*xp/(xnoe+xp))
			s2b = -2*xp**3 *(-2*xp - xnoe)/(3*(xnoe+xp)*
     +			    xnoe**3)
			s2p = s2b - s2a
			if ( lwarn .and. abs(s2p).lt.xloss*abs(s2a) )
     +				call ffwarn(24,ier,s2p,s2a)
			s2p = -slam/xp*dfflo1(s2p,ier)
			if (lwrite) then
			    print *,'ffxb0q: Taylor expansion of s2-2a'
			    print *,'	     in x = ',x
			    print *,'	     gives s2p = ',s2p
			endif
		    endif
*
*		    finally ...
*
  495		    xx = s1p + s2p
		    if ( lwarn .and. abs(xx) .lt. xloss*abs(s1p) ) then
			call ffwarn(25,ier,xx,s1p)
		    endif
*--#]		    third try:
		endif
	    endif
	    if ( xp .gt. xm1+xm2 ) then
*--#[		imaginary part:
*		in this case ( xlam>0, so xp>(m1+m2)^2) ) there also
*		is an imaginary part
		y = -pi*slam/xp
	    else
		y = 0
*--#]		imaginary part:
	    endif
	 else
*	    the root is complex (k^2 between -(m1+m2)^2 and -(m2-m1)^2)
*--#[	    first try:
	    slam = sqrt(-xlam)
	    xnoe = dm2p + xm1
	    s1 = -(dm1m2/(2*xp))*xlogmm
	    s2 = (slam/xp)*atan2(slam,xnoe)
	    xx = s1 + s2 - 2
	    if (lwrite) then
		print *,'ffxb0q: lam<0, first try, xx  = ',xx
		alpha = -xlam/(2*xp*xnoe)
		alph1 = -(xp**2-dm1m2**2)/(2*xp*xnoe)
		print *,'	 alpha = ',alpha
		print *,'	 s1 = ',s1,' - 2alph1 = ',s1-2*alph1
		print *,'	 s2 = ',s2,' - 2alpha = ',s2-2*alpha
	    endif
*--#]	    first try:
	    if ( abs(xx) .lt. xloss**2*max(abs(s1),abs(s2)) ) then
*--#[		second try:
*		Again two times xloss as we'll accept that in the next
*		step as well.
*
		xtel = dm1m2**2 - xp**2
		alpha = -xlam/(2*xp*xnoe)
		alph1 = xtel/(2*xp*xnoe)
*
*		try a taylor expansion on the terms.  First s1:
*
		s1p = s1 - 2*alph1
		if ( abs(s1p) .lt. xloss*abs(s1) ) then
* -#[		    bounds:
*		    determine the boundaries for 1,5,10,15 terms
		    if ( xprcn3 .ne. precx ) then
			xprcn3 = precx
			bdn301 = ffbnd(3,1,xinfac)
			bdn305 = ffbnd(3,5,xinfac)
			bdn310 = ffbnd(3,10,xinfac)
			bdn315 = ffbnd(3,15,xinfac)
		    endif
* -#]		    bounds:
		    x = 2*xtel/(dm1m2*xnoe)
		    ax = abs(x)
		    if ( ax .gt. bdn315 ) then
*			do not do the Taylor expansion
			if ( lwarn ) call ffwarn(21,ier,s1p,s1)
			goto 590
		    endif
		    if ( ax .gt. bdn310 ) then
			s1a = x*(xinfac(13) + x*(xinfac(14) + x*(
     +				 xinfac(15) + x*(xinfac(16) + x*(
     +				 xinfac(17))))))
		    else
			s1a = 0
		    endif
		    if ( ax .gt. bdn305 ) then
			s1a = x*(xinfac(8) + x*(xinfac(9) + x*(
     +				 xinfac(10) + x*(xinfac(11) + x*(
     +				 xinfac(12) + s1a)))))
		    endif
		    if ( ax .gt. bdn301 ) then
			s1a = x*(xinfac(4) + x*(xinfac(5) + x*(
     +				 xinfac(6) + x*(xinfac(7) + s1a))))
		    endif
		    s1a = x**3 *(xinfac(3) + s1a) *xm2/xm1
		    s1b = (dm1m2**3*(dm1m2**2-2*xp*xm1) + xp**2*(4*
     +			dm1m2*xm1**2-dm1m2**2*(dm1m2+2*xm1))-2*xm2*
     +			xp**3*(dm1m2+xp))/(xm1*dm1m2**2*xnoe**2)
		    s1p = s1b - s1a
		    if ( lwarn .and. abs(s1p) .lt. xloss*abs(s1a) )
     +			call ffwarn(22,ier,s1p,s1a)
		    s1p = -dm1m2*dfflo1(s1p,ier)/(2*xp)
		    if (lwrite) then
			print *,'ffxb0q: Taylor expansion of s1-2(1-a)'
			print *,'	 in x = ',x
			print *,'	 gives s1p = ',s1p
		    endif
		endif
*
*		next s2:
*
  590		continue
		s2p = s2 - 2*alpha
		if ( abs(s2p) .lt. xloss*abs(s2) ) then
* -#[		    bounds:
*		    determine the boundaries for 1,5,10,15 terms
		    if ( xprcn3 .ne. precx ) then
			xprcn3 = precx
			bdn301 = ffbnd(3,1,xinfac)
			bdn305 = ffbnd(3,5,xinfac)
			bdn310 = ffbnd(3,10,xinfac)
			bdn315 = ffbnd(3,15,xinfac)
		    endif
* -#]		    bounds:
		    cx = DCMPLX(DBLE(x0),DBLE(-slam/xnoe))
		    ax = absc(cx)
		    if ( ax .gt. bdn315 ) then
			if ( lwarn ) call ffwarn(23,ier,s2p,s2)
			goto 600
		    endif
		    if ( ax .gt. bdn310 ) then
			cs2a = cx*(DBLE(xinfac(13)) + cx*(DBLE(xinfac(14
     +			  )) + cx*(DBLE(xinfac(15)) + cx*(DBLE(xinfac(16
     +			  )) + cx*(DBLE(xinfac(17)))))))
		    else
			cs2a = 0
		    endif
		    if ( ax .gt. bdn305 ) then
			cs2a = cx*(DBLE(xinfac(8)) + cx*(DBLE(xinfac(9))
     +			   + cx*(DBLE(xinfac(10)) + cx*(DBLE(xinfac(11))
     +			   + cx*(DBLE(xinfac(12)) + cs2a)))))
		    endif
		    if ( ax .gt. bdn301 ) then
			cs2a = cx*(DBLE(xinfac(4)) + cx*(DBLE(xinfac(5))
     +			     + cx*(DBLE(xinfac(6)) + cx*(DBLE(xinfac(7))
     +			     + cs2a))))
		    endif
		    cs2a = cx**3*(DBLE(xinfac(3))+cs2a)*
     +				DCMPLX(DBLE(xnoe),DBLE(slam))
		    cs2b = DCMPLX(DBLE(xnoe-xlam/xnoe/2),
     +				 -DBLE(slam**3/xnoe**2/2))
		    cs2p = cs2b + cs2a
		    if ( lwarn .and. absc(cs2p) .lt. xloss*absc(cs2a) )
     +			call ffwarn(24,ier,absc(cs2p),absc(cs2b))
		    s2p = slam*atan2(DIMAG(cs2p),DBLE(cs2p))/xp
		    if (lwrite) then
			print *,'ffxb0q: Taylor expansion of s2-2a'
			print *,'	 in x = ',cx
			print *,'	 gives s2p = ',s2p
		    endif
		endif
  600		continue
		xx = s1p + s2p
		if ( lwarn .and. abs(xx) .lt. xloss*abs(s1p) ) then
		    call ffwarn(25,ier,xx,s1p)
		endif
*--#]		second try:
	    endif
	    y = 0
	endif
	cb0p = DCMPLX(DBLE(xx),DBLE(y))
	goto 990
* -#]	normal case:
*  #] unequal nonzero masses:
*  #[ debug:
  990	continue
	if (lwrite) then
	    print *,'cb0p  = ',cb0p,ier
	endif
*  #] debug:
*###] ffxb0p:
	end
*###[ ffxlmb:
	subroutine ffxlmb(xlambd,a1,a2,a3,a12,a13,a23,ier)
***#[*comment:***********************************************************
*	calculate in a numerically stable way				*
*	 lambda(a1,a2,a3) =						*
*		a1**2 + a2**2 + a3**2 - 2*a2*a3 - 2*a3*a1 - 2*a1*a2	*
*	aij = ai - aj are required for greater accuracy at times	*
*	ier is the usual error flag.					*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xlambd,a1,a2,a3,a12,a13,a23
*
*	local variables
*
	DOUBLE PRECISION aa1,aa2,aa3,aa12,aa13,aa23,
     +		xcheck,a,aff,asq
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ calculations:
	aa1 = abs(a1)
	aa2 = abs(a2)
	aa3 = abs(a3)
	aa12 = abs(a12)
	aa13 = abs(a13)
	aa23 = abs(a23)
	if (ltest) then
*	    xcheck input
	    xcheck = a1 - a2 - a12
	    if ( xloss*abs(xcheck) .gt. precx*max(aa1,aa2,aa12) )
     +		print *,'ffxlmb: input not OK, a12 /= a1 - a2',a12,a1,
     +		a2,xcheck
	    xcheck = a1 - a3 - a13
	    if ( xloss*abs(xcheck) .gt. precx*max(aa1,aa3,aa13) )
     +		print *,'ffxlmb: input not OK, a13 /= a1 - a3',a13,a3,
     +		a3,xcheck
	    xcheck = a2 - a3 - a23
	    if ( xloss*abs(xcheck) .gt. precx*max(aa2,aa3,aa23) )
     +		print *,'ffxlmb: input not OK, a23 /= a2 - a3',a23,a2,
     +		a3,xcheck
	endif
*
*	first see if there are input parameters with opposite sign:
*
	if ( a1 .lt. 0 .and. a2 .gt. 0 .or.
     +	     a1 .gt. 0 .and. a2 .lt. 0 ) then
	    goto 12
	elseif ( a1 .lt. 0 .and. a3 .gt. 0 .or.
     +		 a1 .gt. 0 .and. a3 .lt. 0 ) then
	    goto 13
*
*	all have the same sign, choose the smallest 4*ai*aj term
*
	elseif ( aa1 .gt. aa2 .and. aa1 .gt. aa3 ) then
	    goto 23
	elseif ( aa2 .gt. aa3 ) then
	    goto 13
	else
	    goto 12
	endif
   12	continue
	if ( aa1 .gt. aa2 ) then
	    a = a13 + a2
	else
	    a = a1 + a23
	endif
	aff = 4*a1*a2
	goto 100
   13	continue
	if ( aa1 .gt. aa3 ) then
	    a = a12 + a3
	else
	    a = a1 - a23
	endif
	aff = 4*a1*a3
	goto 100
   23	continue
	if ( aa2 .gt. aa3 ) then
	    a = a12 - a3
	else
	    a = a13 - a2
	endif
	aff = 4*a2*a3
  100	continue
	asq = a**2
	xlambd = asq - aff
	if ( lwarn .and. abs(xlambd) .lt. xloss*asq )
     +		call ffwarn(69,ier,xlambd,asq)
*  #] calculations:
*###] ffxlmb:
	end
*###[ ffclmb:
	subroutine ffclmb(clambd,cc1,cc2,cc3,cc12,cc13,cc23,ier)
***#[*comment:***********************************************************
*	calculate in cc numerically stable way				*
*	 lambda(cc1,cc2,cc3) =						*
*	cc1**2 + cc2**2 + cc3**2 - 2*cc2*cc3 - 2*cc3*cc1 - 2*cc1*cc2	*
*	cij = ci - cj are required for greater accuracy at times	*
*	ier is the usual error flag.					*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX clambd,cc1,cc2,cc3,cc12,cc13,cc23
*
*	local variables
*
	DOUBLE PRECISION aa1,aa2,aa3,aa12,aa13,aa23,absc
	DOUBLE COMPLEX check,cc,cff,csq,c
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ calculations (rather old style ...):
	aa1 = absc(cc1)
	aa2 = absc(cc2)
	aa3 = absc(cc3)
	aa12 = absc(cc12)
	aa13 = absc(cc13)
	aa23 = absc(cc23)
	if (ltest) then
*	    check input
	    check = cc1 - cc2 - cc12
	    if ( xloss*absc(check) .gt. precc*max(aa1,aa2,aa12) ) then
		print *,'ffclmb: input not OK, cc12 /= cc1 - cc2',check
	    endif
	    check = cc1 - cc3 - cc13
	    if ( xloss*absc(check) .gt. precc*max(aa1,aa3,aa13) ) then
		print *,'ffclmb: input not OK, cc13 /= cc1 - cc3',check
	    endif
	    check = cc2 - cc3 - cc23
	    if ( xloss*absc(check) .gt. precc*max(aa2,aa3,aa23) ) then
		print *,'ffclmb: input not OK, cc23 /= cc2 - cc3',check
	    endif
	endif
*
*	first see if there are input parameters with opposite sign:
*
	if ( DBLE(cc1) .lt. 0 .and. DBLE(cc2) .gt. 0 .or.
     +	     DBLE(cc1) .gt. 0 .and. DBLE(cc2) .lt. 0 ) then
	    goto 12
	elseif ( DBLE(cc1) .lt. 0 .and. DBLE(cc3) .gt. 0 .or.
     +		 DBLE(cc1) .gt. 0 .and. DBLE(cc3) .lt. 0 ) then
	    goto 13
*
*	all have the same sign, choose the smallest 4*ci*cj term
*
	elseif ( aa1 .gt. aa2 .and. aa1 .gt. aa3 ) then
	    goto 23
	elseif ( aa2 .gt. aa3 ) then
	    goto 13
	else
	    goto 12
	endif
   12	continue
	if ( aa1 .gt. aa2 ) then
	    cc = cc13 + cc2
	else
	    cc = cc1 + cc23
	endif
	cff = 4*cc1*cc2
	goto 100
   13	continue
	if ( aa1 .gt. aa3 ) then
	    cc = cc12 + cc3
	else
	    cc = cc1 - cc23
	endif
	cff = 4*cc1*cc3
	goto 100
   23	continue
	if ( aa2 .gt. aa3 ) then
	    cc = cc12 - cc3
	else
	    cc = cc13 - cc2
	endif
	cff = 4*cc2*cc3
  100	continue
	csq = cc**2
	clambd = csq - cff
	if ( lwarn .and. absc(clambd) .lt. xloss*absc(csq) )
     +		call ffwarn(68,ier,absc(clambd),absc(csq))
*  #] calculations (rather old style ...):
*###] ffclmb:
	end
*###[ ffdot2:
	subroutine ffdot2(piDpj,xp,xma,xmb,dmap,dmbp,dmamb,ier)
***#[*comment:***********************************************************
*									*
*	Store the 3 dotproducts in the common block ffdot.		*
*									*
*	Input:	see ffxb0p						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION piDpj(3,3),xp,xma,xmb,dmap,dmbp,dmamb
*
*	local variables
*
	integer ier0,ier1
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
*	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ work:
	ier1 = ier
	piDpj(1,1) = xma
	piDpj(2,2) = xmb
	piDpj(3,3) = xp
	if ( abs(dmap) .lt. abs(dmbp) ) then
		piDpj(1,2) = (dmap + xmb)/2
	else
		piDpj(1,2) = (dmbp + xma)/2
	endif
	piDpj(2,1) = piDpj(1,2)
	if ( lwarn .and. abs(piDpj(1,2)) .lt. xloss*min(xma,xmb)/2
     +			) then
		call ffwarn(24,ier1,piDpj(1,2),min(xma,xmb)/2)
	endif
	if ( abs(dmamb) .lt. abs(dmbp) ) then
		piDpj(1,3) = (-dmamb - xp)/2
	else
		piDpj(1,3) = (dmbp - xma)/2
	endif
	piDpj(3,1) = piDpj(1,3)
	if ( lwarn .and. abs(piDpj(1,3)) .lt. xloss*min(xma,
     +			abs(xp))/2) then
     		ier0 = ier
		call ffwarn(25,ier0,piDpj(1,3),min(xma,abs(xp))/2)
		ier1 = max(ier0,ier1)
	endif
	if ( abs(dmamb) .lt. abs(dmap) ) then
		piDpj(2,3) = (-dmamb + xp)/2
	else
		piDpj(2,3) = (-dmap + xmb)/2
	endif
	piDpj(3,2) = piDpj(2,3)
	if ( lwarn .and. abs(piDpj(2,3)) .lt. xloss*min(xmb,
     +			abs(xp))/2) then
     		ier0 = ier
		call ffwarn(25,ier0,piDpj(2,3),min(xmb,abs(xp))/2)
		ier1 = max(ier0,ier1)
	endif
	ier = ier1
*  #] work:
*###] ffdot2:
	end
*###[ ffxb1:
	subroutine ffxb1(cb1,cb0,ca0i,xp,xm1,xm2,piDpj,ier)
***#[*comment:***********************************************************
*									*
*	Calculate   1	/	   d^n Q Q(mu)				*
*		 ------	| ------------------------ = B1*p(mu)		*
*		 i pi^2	/ (Q^2-m1^2)((Q+p)^2-m2^2)			*
*									*
*	Input:	cb0	   complex	scalar twopoint function	*
*		ca0i(2)	   complex	scalar onepoint function with	*
*						m1,m2			*
*		xp	   real		p.p in B&D metric		*
*		xm1,2	   real		m_1^2,m_2^2			*
*		piDpj(3,3) real		dotproducts between s1,s2,p	*
*		ier	   integer	digits lost so far		*
*	Output:	cb1	   complex	B1				*
*		ier	   integer	digits lost			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xp,xm1,xm2,piDpj(3,3)
	DOUBLE COMPLEX cb1,cb0,ca0i(2)
*
*	local variables
*
	integer ier0
	DOUBLE PRECISION dm1p,dm2p,dm1m2
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ get differences:
	ier0 = 0
	dm1m2 = xm1 - xm2
	dm1p = xm1 - xp
	dm2p = xm2 - xp
	if ( lwarn ) then
	    if ( abs(dm1m2) .lt. xloss*abs(xm1) .and. xm1 .ne. xm2 )
     +		call ffwarn(97,ier0,dm1m2,xm1)
	    if ( abs(dm1p) .lt. xloss*abs(xp) .and. xp .ne. xm1 )
     +		call ffwarn(98,ier0,dm1p,xp)
	    if ( abs(dm2p) .lt. xloss*abs(xp) .and. xp .ne. xm2 )
     +		call ffwarn(99,ier0,dm2p,xp)
	endif
*  #] get differences:
*  #[ call ffxb1a:
	call ffxb1a(cb1,cb0,ca0i,xp,xm1,xm2,dm1p,dm2p,dm1m2,piDpj,ier)
*  #] call ffxb1a:
*###] ffxb1:
	end
*###[ ffxb1a:
	subroutine ffxb1a(cb1,cb0,ca0i,xp,xm1,xm2,dm1p,dm2p,dm1m2,piDpj,
     +		ier)
***#[*comment:***********************************************************
*									*
*	Calculate   1	/	   d^n Q Q(mu)				*
*		 ------	| ------------------------ = B1*p(mu)		*
*		 i pi^2	/ (Q^2-m1^2)((Q+p)^2-m2^2)			*
*									*
*	Input:	cb0	   complex	scalar twopoint function	*
*		ca0i(2)	   complex	scalar onepoint function with	*
*						m1,m2			*
*		xp	   real		p.p in B&D metric		*
*		xm1,2	   real		m_1^2,m_2^2			*
*		piDpj(3,3) real		dotproducts between s1,s2,p	*
*		ier	   integer	digits lost so far		*
*	Output:	cb1	   complex	B1				*
*		ier	   integer	digits lost			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xp,xm1,xm2,dm1p,dm2p,dm1m2,piDpj(3,3)
	DOUBLE COMPLEX cb1,cb0,ca0i(2)
*
*	local variables
*
	integer i,ier0
	logical lneg
	DOUBLE PRECISION xmax,absc,s,s1,h,slam,bnd101,bnd105,bnd110,
     +		bnd115,xma,xmb,x,ax,xlogm,small,dmbma,xprec,xlam,ts2Dp,
     +		xnul,rloss,xmxp,xlo3,dfflo3
	DOUBLE COMPLEX cs(5),cc,csom
	DOUBLE PRECISION ffbnd,dfflo1
	save xprec,bnd101,bnd105,bnd110,bnd115
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*	data
*
	data xprec /0./
*
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    rloss = xloss**2*DBLE(10)**(-mod(ier,50))
	    xmax = max(xm1,xm2,abs(xp))
	    xnul = 2*piDpj(1,2) - xm1 - xm2 + xp
	    if ( rloss*abs(xnul) .gt. precx*xmax ) print *,
     +		'ffxb1a: error: s1.s2 wrong: ',2*piDpj(1,2),xm1+xm2-xp,
     +		xnul,ier
	    xnul = 2*piDpj(1,3) + xm1 - xm2 + xp
	    if ( rloss*abs(xnul) .gt. precx*xmax ) print *,
     +		'ffxb1a: error: s1.p wrong: ',2*piDpj(1,3),-xm1+xm2-xp,
     +		xnul,ier
	    xnul = 2*piDpj(2,3) + xm1 - xm2 - xp
	    if ( rloss*abs(xnul) .gt. precx*xmax ) print *,
     +		'ffxb1a: error: s2.p wrong: ',2*piDpj(2,3),-xm1+xm2+xp,
     +		xnul,ier
	endif
*  #] check input:
*  #[ p^2 != 0:
	if ( xp .ne. 0 ) then
* 	#[ normal case:
	    if ( dm1m2 .ne. 0 ) then
		cs(1) = -ca0i(2)
		cs(2) = +ca0i(1)
	    else
		cs(1) = 0
		cs(2) = 0
	    endif
	    cs(3) = +DBLE(2*piDpj(1,3))*cb0
	    cb1 = cs(1) + cs(2) + cs(3)
	    xmax = max(absc(cs(2)),absc(cs(3)))
	    if ( absc(cb1) .ge. xloss*xmax ) goto 110
* 	#] normal case:
* 	#[ almost equal masses:
	    if ( abs(dm1m2) .le. xloss*xm1 ) then
		if ( lwrite ) print *,'Using algorithms for dm1m2 small'
		cs(2) = DBLE(dm1m2/xm1)*cs(2)
		cs(1) = -xm2*dfflo1(-dm1m2/xm2,ier)
		if ( lwrite ) print *,'cb1 was',cb1,xmax
		cb1 = cs(1) + cs(2) + cs(3)
		xmax = max(absc(cs(2)),absc(cs(3)))
		if ( lwrite ) print *,'cb1 is ',cb1,xmax
		if ( absc(cb1) .ge. xloss*xmax ) goto 110
*		for the perfectionist (not me (today)):
*		if d0=0 and mu~m1(~m2), then the terms of order
*		(m1^2-m2^2) also cancel.  To patch this I need d0 and mu
	    endif
* 	#] almost equal masses:
* 	#[ p2 -> 0:
	    if ( xloss*max(xm1,xm2) .gt. abs(xp) ) then
		if ( xm2.gt.xm1 ) then
		    xma = xm1
		    xmb = xm2
		    ts2Dp = +2*piDpj(2,3)
		    lneg = .FALSE.
		else
		    xma = xm2
		    xmb = xm1
		    ts2Dp = -2*piDpj(1,3)
		    lneg = .TRUE.
		endif
	    else
		goto 100
	    endif
*
*	    We found a situation in which p2 is much smaller than
*	    the masses.
*
	    if ( lwrite ) print *,'Using algorithms for p2 small'
	    dmbma = abs(dm1m2)
	    if ( xma.eq.0 ) then
		xlogm = 1
	    elseif ( dmbma .gt. xloss*xmb ) then
		xlogm = log(xmb/xma)
	    else
		xlogm = dfflo1(-dmbma/xma,ier)
	    endif
	    xlam =  (dmbma-xp)**2 - 4*xma*xp
	    if ( xlam.gt.0 ) then
*		#[ real roots:
		slam = sqrt(xlam)
		small = xp*(-2*(xma+xmb) + xp)/(slam+dmbma)
		if ( lwrite ) then
		    print *,'small = ',small
		    print *,'vgl     ',slam-dmbma,slam
		endif
		h = slam+2*piDpj(1,2)
		cs(1) = xlogm*xma*(4*xmb*(small-xp) + (small-xp)**2)/(2*
     +			(slam+dmbma)*h)
		if ( lwrite ) then
		    print *,'cs(1) = ',cs(1)
		    print *,'vgl     ',
     +			+xma*xlogm*(x05+(xma+xmb-xp/2)/(slam-xma+xmb))
     +			+xmb*xlogm*(x05-(xma+xmb-xp/2)/(slam-xma+xmb))
		endif
		if ( xprec.ne.precx ) then
		    xprec = precx
		    bnd101 = ffbnd(2,1,xinfac)
		    bnd105 = ffbnd(2,5,xinfac)
		    bnd110 = ffbnd(2,10,xinfac)
		    bnd115 = ffbnd(2,15,xinfac)
		endif
		x = xp/slam
		if ( lwrite ) print *,'Taylor expansion in ',x
		ax = abs(x)
		if ( lwarn .and. ax.gt.bnd115 )
     +		    call ffwarn(220,ier,precx,xinfac(16)*ax**14)
		if ( ax.gt.bnd110 ) then
		    s = x*(xinfac(12) + x*(xinfac(13) + x*(xinfac(14) +
     +			x*(xinfac(15) + x*xinfac(16) ))))
		else
		    s = 0
		endif
		if ( ax.gt.bnd105 ) then
		    s = x*(xinfac(7) + x*(xinfac(8) + x*(xinfac(9) +
     +			x*(xinfac(10) + x*(xinfac(11) + s )))))
		endif
		if ( ax.gt.bnd101) then
		    s = x*(xinfac(3) + x*(xinfac(4) + x*(xinfac(5) +
     +			x*(xinfac(6) + s ))))
		endif
		s = x**2*(x05 + s)
		h = ts2Dp + slam
		s1 = 2*xp/h*(s + x)
		h = -4*xp**2*xmb/(slam*h**2) - s + s1
		if ( lwarn .and. abs(h) .lt. xloss*max(abs(s),abs(s1)) )
     +			then
		    call ffwarn(221,ier,h,max(abs(s),abs(s1)))
		endif
		if ( lwrite ) then
		    print *,'arg ',h
		    print *,'vgl ',1-(1-2*xp/(xp+dmbma+slam))*exp(xp/
     +			slam)
		endif
		if ( abs(h) .lt. .1 ) then
		    cs(2) = dmbma*slam/xp*dfflo1(h,ier)
		else
		    print *,'ffxb1: error: I thought this was small: ',h
		    goto 100
		endif
		if ( lneg ) then
		    cs(1) = -cs(1)
		    cs(2) = -cs(2)
		endif
		cs(3) = -DBLE(xp)*cb0
		if ( lwrite ) print *,'cb1 was',cb1,xmax
		cb1 = cs(1) + cs(2) + cs(3)
		xmax = max(absc(cs(2)),absc(cs(3)))
		if ( lwrite ) then
		    print *,'cb1 is ',cb1,xmax
		    print *,'cs = ',cs
		endif
		if ( absc(cb1) .gt. xloss*xmax) goto 110
*
*		this still occurs in the case xp << dmamb << xma,
*		with a cancellation of order dmamb/xma between cs1 and
*		cs2; as the standard model does not contain these kind
*		of doublets I leave this as an exercise for the
*		reader...
*
*		#] real roots:
	    else
*		#[ imaginary roots:
		if ( lwrite ) print *,'Cannot handle p^2 small, ',
     +			'with imaginary roots yet'
*		#] imaginary roots:
	    endif
* 	#] p2 -> 0:
* 	#[ give up:
*
*	    give up...
*
  100	    continue
	    if ( lwarn ) then
		call ffwarn(167,ier,absc(cb1),xmax)
		if ( lwrite ) then
		    print *,'cs(i)      = ',cs
		    print *,'xp,xm1,xm2 = ',xp,xm1,xm2
		endif
	    endif
  110	    continue
* 	#] give up:
	    cb1 = cb1*(1/DBLE(2*xp))
*  #] p^2 != 0:
*  #[ p^2=0, m1 != m2:
	elseif ( dm1m2 .ne. 0 ) then
	    cs(1) = +DBLE(xm2/(2*dm1m2**2))*(ca0i(2)+DBLE(xm2)/2)
	    cs(2) = -DBLE(xm1/(2*dm1m2**2))*(ca0i(1)+DBLE(xm1)/2)
	    cs(3) = +ca0i(2)*(1/DBLE(dm1m2))
	    cb1 = cs(1) + cs(2) + cs(3)
	    xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)))
	    if ( absc(cb1).ge.xloss**2*xmax ) goto 120
	    if ( lwrite ) then
		print *,'cb1 = ',cb1,xmax
		print *,'with cs '
		print '(i3,2e30.16)',(i,cs(i),i=1,3)
	    endif
*
*	    m1 ~ m2, see b21.frm
*
	    if ( abs(dm1m2).lt.xloss*xm1 ) then
		xlogm = dfflo1(dm1m2/xm1,ier)
	    else
		xlogm = log(xm2/xm1)
	    endif
	    cs(1) = -(xm1/dm1m2)/2
	    cs(2) = -xlogm/2*(xm1/dm1m2)**2
	    cs(3) = +1/DBLE(4) - ca0i(1)*DBLE(1/(2*xm1))
	    cs(4) = xlogm/2
	    csom = cs(1) + cs(2) + cs(3) + cs(4)
	    xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)))
	    if ( lwrite ) then
		print *,'cb1+= ',csom,xmxp
		print *,'with cs '
		print '(i3,2e30.16)',(i,cs(i),i=1,4)
	    endif
	    if ( xmxp.lt.xmax ) then
		xmax = xmxp
		cb1 = csom
		if ( absc(cb1).gt.xloss**2*xmax ) goto 120
	    endif
*
*	    better
*
	    xlo3 = dfflo3(dm1m2/xm1,ier)
	    cs(1) = -(dm1m2/xm1)**2/4
	    cs(2) = -(dm1m2/xm1)/2
	    cs(3) = -xlo3/(dm1m2/xm1)**2/2
	    cs(4) = xlo3/2
	    cs(5) = 1/DBLE(2) - ca0i(1)*DBLE(1/(2*xm1))
	    csom = cs(1) + cs(2) + cs(3) + cs(4) + cs(5)
	    xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),absc(cs(5)))
	    if ( lwrite ) then
		print *,'cb1+= ',csom,xmxp
		print *,'with cs '
		print '(i3,2e30.16)',(i,cs(i),i=1,5)
	    endif
	    if ( xmxp.lt.xmax ) then
		xmax = xmxp
		cb1 = csom
		if ( absc(cb1).gt.xloss**2*xmax ) goto 120
	    endif
*
*	    give up
*
	    if ( lwarn ) then
		if ( absc(cb1) .lt. xloss*xmax )
     +			call ffwarn(167,ier,absc(cb1),xmax)
	    endif
  120	    continue
*  #] p^2=0, m1 != m2:
*  #[ p^2=0, m1 == m2:
	else
	    cb1 = -cb0/2
	endif
*  #] p^2=0, m1 == m2:
*###] ffxb1a:
	end
*###[ ffxb2p:
	subroutine ffxb2p(cb2i,cb1,cb0,ca0i,xp,xm1,xm2,piDpj,ier)
***#[*comment:***********************************************************
*									*
*	Compute the PV B2, the coefficients of p(mu)p(nu) and g(mu,nu)	*
*	of 1/(ipi^2)\int d^nQ Q(mu)Q(nu)/(Q^2-m_1^2)/((Q+p)^2-m_2^2)	*
*	originally based on aaxbx by Andre Aeppli.			*
*									*
*	Input:	cb1	   complex	vector two point function	*
*		cb0	   complex	scalar two point function	*
*		ca0i(2)	   complex	scalar onepoint function with	*
*						m1,m2			*
*		xp	   real		p.p in B&D metric		*
*		xm1,2	   real		m_1^2,m_2^2			*
*		piDpj(3,3) real		dotproducts between s1,s2,p	*
*		ier	   integer	digits lost so far		*
*									*
*	Output:	cb2i(2)	   complex	B21,B22: coeffs of p*p, g in B2	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xp,xm1,xm2,piDpj(3,3)
	DOUBLE COMPLEX cb2i(2),cb1,cb0,ca0i(2)
*
*	local variables
*
	DOUBLE PRECISION dm1p,dm2p,dm1m2
*
*  #] declarations:
*  #[ work:
*
	dm1p = xm1 - xp
	dm2p = xm2 - xp
	dm1m2= xm1 - xm2
	call ffxb2q(cb2i,cb1,cb0,ca0i,xp,xm1,xm2,dm1p,dm2p,dm1m2,
     +		piDpj,ier)
*
*  #] work:
*###] ffxb2p:
	end
*###[ ffxb2q:
	subroutine ffxb2q(cb2i,cb1,cb0,ca0i,xp,xm1,xm2,dm1p,dm2p,dm1m2,
     +		piDpj,ier)
***#[*comment:***********************************************************
*									*
*	Compute the PV B2, the coefficients of p(mu)p(nu) and g(mu,nu)	*
*	of 1/(ipi^2)\int d^nQ Q(mu)Q(nu)/(Q^2-m_1^2)/((Q+p)^2-m_2^2)	*
*	originally based on aaxbx by Andre Aeppli.			*
*									*
*	Input:	cb1	   complex	vector two point function	*
*		cb0	   complex	scalar two point function	*
*		ca0i(2)	   complex	scalar onepoint function with	*
*						m1,m2			*
*		xp	   real		p.p in B&D metric		*
*		xm1,2	   real		m_1^2,m_2^2			*
*		piDpj(3,3) real		dotproducts between s1,s2,p	*
*		ier	   integer	digits lost so far		*
*									*
*	Output:	cb2i(2)	   complex	B21,B22: coeffs of p*p, g in B2	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xp,xm1,xm2,dm1p,dm2p,dm1m2,piDpj(3,3)
	DOUBLE COMPLEX cb2i(2),cb1,cb0,ca0i(2)
*
*	local variables
*
	integer i,j,ier0,ier1
	logical llogmm
	DOUBLE PRECISION xmax,absc,xlam,slam,alp,bet,xmxp,dfflo3,xlo3,
     +		xmxsav,xnoe,xnoe2,xlogmm,dfflo1,rloss,
     +		qiDqj(3,3)
	DOUBLE COMPLEX cs(16),cc,csom,clo2,clo3,zfflo2,zfflo3
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations:
*  #[ test input:
	if ( ltest ) then
	    ier0 = ier
	    call ffdot2(qiDqj,xp,xm1,xm2,dm1p,dm2p,dm1m2,ier0)
	    rloss = xloss*DBLE(10)**(-mod(ier0,50))
	    do 20 j=1,3
		do 10 i=1,3
		    if ( rloss*abs(piDpj(i,j)-qiDqj(i,j)).gt.precx*
     +			abs(piDpj(i,j))) print *,'ffxb2q: error: piDpj('
     +			,i,j,') wrong: ',piDpj(i,j),qiDqj(i,j),
     +			piDpj(i,j)-qiDqj(i,j),ier0
   10		continue
   20	    continue
	endif
*  #] test input:
*  #[ normal case:
	ier0 = ier
	ier1 = ier
*
*	with thanks to Andre Aeppli, off whom I stole the original
*
	if ( xp .ne. 0) then
	    cs(1) = ca0i(2)
	    cs(2) = DBLE(xm1)*cb0
	    cs(3) = DBLE(2*piDpj(1,3))*cb1
	    cs(4) = (xm1+xm2)/2
	    cs(5) = -xp/6
	    cb2i(1) = cs(1) - cs(2) + 2*cs(3) - cs(4) - cs(5)
	    cb2i(2) = cs(1) + 2*cs(2) - cs(3) + 2*cs(4) + 2*cs(5)
	    xmax = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),absc(cs(5)))
	    xmxsav = xmax
	    if ( absc(cb2i(1)) .ge. xloss*xmax ) goto 100
	    if ( lwrite ) then
		print *,'cb2i(1) = ',cb2i(1),xmax
		print *,'with cs '
		print '(i3,2e30.16)',1,cs(1),2,-cs(2),3,2*cs(3),4,
     +			-cs(4),5,-cs(5)
	    endif
*  #] normal case:
*  #[   improve: m1=m2:
*
*	    a relatively simple case: dm1m2 = 0 (bi0.frm)
*
	    if ( dm1m2.eq.0 ) then
		if ( xp.lt.0 ) then
		    slam = sqrt(xp**2-4*xm1*xp)
		    xlo3 = dfflo3((xp-slam)/(2*xm1),ier)
		    cs(1) = xp*(-1/DBLE(3) + slam/(4*xm1))
		    cs(2) = xp**2*(-slam/(4*xm1**2) - 3/(4*xm1))
		    cs(3) = xp**3/(4*xm1**2)
		    cs(4) = DBLE(xp/xm1)*ca0i(1)
		    cs(5) = xlo3/xp*(-xm1*slam)
		    cs(6) = xlo3*slam
		else
		    slam = isgnal*sqrt(-xp**2+4*xm1*xp)
		    clo3 = zfflo3(DCMPLX(DBLE(xp/(2*xm1)),
     +			DBLE(-slam/(2*xm1))),ier)
		    cs(1) = DBLE(xp)*DCMPLX(-1/DBLE(3),
     +			DBLE(slam/(4*xm1)))
		    cs(2) = DBLE(xp**2)*DCMPLX(DBLE(-3/(4*xm1)),
     +			DBLE(-slam/(4*xm1**2)))
		    cs(3) = DBLE(xp**3/(4*xm1**2))
		    cs(4) = DBLE(xp/xm1)*ca0i(1)
		    cs(5) = clo3*DCMPLX(DBLE(0),DBLE(-xm1*slam/xp))
		    cs(6) = clo3*DCMPLX(DBLE(0),DBLE(slam))
		endif
		csom = cs(1) + cs(2) + cs(3) + cs(4) + cs(5) + cs(6)
		xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),
     +			absc(cs(5)),absc(cs(6)))
*		
*		get rid of noise in the imaginary part
*	
		if ( xloss*abs(DIMAG(csom)).lt.precc*abs(DBLE(csom)) ) 
     +			csom = DCMPLX(DBLE(csom),DBLE(0))
		if ( lwrite ) then
		    print *,'cb2i(1)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,6)
		endif
		if ( xmxp.lt.xmax ) then
		    cb2i(1) = csom
		    xmax = xmxp
		endif
		if ( absc(cb2i(1)).ge.xloss**2*xmax ) goto 100
	    endif
*  #]   improve: m1=m2: 
*  #[   improve: |xp| < xm1 < xm2:
*
*	    try again (see bi.frm)
*
	    xlam =  4*(piDpj(1,3)**2 - xm1*xp)
	    if ( xm1.eq.0 .or. xm2.eq.0 ) then
	    	xlogmm = 0
	    elseif ( abs(dm1m2).lt.xloss*xm1 ) then
	    	xlogmm = dfflo1(dm1m2/xm1,ier)
	    else
	    	xlogmm = log(xm2/xm1)
	    endif
	    if ( xlam.gt.0 .and. abs(xp).lt.xloss*xm2 .and.
     +			xm1.lt.xm2 ) then
		slam = sqrt(xlam)
		alp = (2*xm1*xm2/(2*piDpj(1,2)+slam) + xm1)/(slam-dm1m2)
*		bet = [xm2-xm1-xp-slam]
		bet = 4*xm1*xp/(2*piDpj(1,3)+slam)
		cs(1) = DBLE(xp/xm2)*ca0i(2)
		cs(2) = xlogmm*bet*(-2*xm1**2*xm2 - 2*xm1**3)
     +		/((-dm1m2+slam)*(2*piDpj(1,2)+slam)*(2*piDpj(1,3)+slam))
		cs(3) = xlogmm*(-4*xp*xm1**3)
     +		/((-dm1m2+slam)*(2*piDpj(1,2)+slam)*(2*piDpj(1,3)+slam))
		xnoe = 1/(2*piDpj(2,3)+slam)
		xnoe2 = xnoe**2
		cs(4) = xnoe2*xm1*bet*(xp-4*xm2)
		cs(5) = xnoe2*xm1*2*xp*xm2
		cs(6) = xnoe2*xm1**2*bet
		cs(7) = xnoe2*xm1**2*4*xp
		cs(8) = xnoe2*bet*(xp*xm2+3*xm2**2)
		cs(9) = xnoe2*(-6*xp*xm2**2)
		cs(10)= xp*(7/6.d0 - 2*xm1*slam*xnoe2 +
     +			4*xm2*slam*xnoe2 - 2*slam*xnoe)
		cs(11)= xp**2*( -2*slam*xnoe2 )
		xlo3 = dfflo3(2*xp*xnoe,ier)
		cs(12) = xlo3*dm1m2**2*slam/xp**2
		cs(13) = xlo3*(xm1 - 2*xm2)*slam/xp
		cs(14) = xlo3*slam
		csom = 0
		xmxp = 0
		do 50 i=1,14
		    csom = csom + cs(i)
		    xmxp = max(xmxp,absc(cs(i)))
   50		continue
		if ( lwrite ) then
		    print *,'cb2i(1)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,14)
		endif
		if ( xmxp.lt.xmax ) then
		    cb2i(1) = csom
		    xmax = xmxp
		endif
		if ( absc(cb2i(1)).ge.xloss**2*xmax ) goto 100
	    endif
*  #]   improve: |xp| < xm1 < xm2:
*  #[   improve: |xp| < xm2 < xm1:
	    if ( xlam.gt.0 .and. abs(xp).lt.xloss*xm1 .and.
     +			xm2.lt.xm1 ) then
		slam = sqrt(xlam)
		alp = (2*xm2*xm1/(2*piDpj(1,2)+slam) + xm2)/(slam+dm1m2)
*		bet = [xm1-xm2-xp-slam]
		bet = 4*xm2*xp/(-2*piDpj(2,3)+slam)
		xnoe = 1/(-2*piDpj(1,3)+slam)
		xnoe2 = xnoe**2
		cs(1) = DBLE(xp/xm1)*ca0i(1)
		cs(2) = -xlogmm*bet*(12*xp*xm1*xm2+6*xp*xm2**2-
     +		6*xp**2*xm2-2*xm1*xm2**2-2*xm2**3)
     +		/((dm1m2+slam)*(2*piDpj(1,2)+slam)*(-2*piDpj(2,3)+slam))
		cs(3) = -xlogmm*(-24*xp*xm1**2*xm2-4*xp*xm2**3+36*
     +		xp**2*xm1*xm2+12*xp**2*xm2**2-12*xp**3*xm2)
     +		/((dm1m2+slam)*(2*piDpj(1,2)+slam)*(-2*piDpj(2,3)+slam))
		cs(4) = xnoe2*xm2*bet*(xp-4*xm1)
		cs(5) = xnoe2*xm2*(-10*xp*xm1)
		cs(6) = xnoe2*xm2**2*bet
		cs(7) = xnoe2*xm2**2*4*xp
		cs(8) = xnoe2*bet*(xp*xm1+3*xm1**2)
		cs(9) = xnoe2*6*xp*xm1**2
		cs(10)= xp*(7/6.d0 - 2*xm1*slam*xnoe2 +
     +			4*xm2*slam*xnoe2 - 2*slam*xnoe)
		cs(11)= xp**2*( -2*slam*xnoe2 )
		xlo3 = dfflo3(2*xp*xnoe,ier)
		cs(12) = xlo3*dm1m2**2*slam/xp**2
		cs(13) = xlo3*(xm1 - 2*xm2)*slam/xp
		cs(14) = xlo3*slam
		csom = 0
		xmxp = 0
		do 60 i=1,14
		    csom = csom + cs(i)
		    xmxp = max(xmxp,absc(cs(i)))
   60		continue
		if ( lwrite ) then
		    print *,'cb2i(1)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,14)
		endif
		if ( xmxp.lt.xmax ) then
		    cb2i(1) = csom
		    xmax = xmxp
		endif
		if ( absc(cb2i(1)).ge.xloss**2*xmax ) goto 100
	    endif
*  #]   improve: |xp| < xm2 < xm1:
*  #[   wrap up:
	    if ( lwarn ) then
		call ffwarn(225,ier0,absc(cb2i(1)),xmax)
		if ( lwrite ) then
		    print *,'xp,xm1,xm2 = ',xp,xm1,xm2
		endif
	    endif
  100	    continue
	    xmax = xmxsav
	    if ( absc(cb2i(2)) .lt. xloss**2*xmax ) then
		if ( lwrite ) then
		    print *,'cb2i(2) = ',cb2i(2),xmax
		    print *,'with cs '
		    print '(i3,2e30.16)',1,cs(1),2,2*cs(2),3,-cs(3),
     +			4,2*cs(4)
		endif
*
		if ( lwarn ) then
		    call ffwarn(226,ier1,absc(cb2i(2)),xmax)
		endif
  110		continue
		if ( lwrite ) print *,'cb2i(2)+= ',cb2i(2)
	    endif
	    cb2i(1) = DBLE(1/(3*xp)) * cb2i(1)
	    cb2i(2) = DBLE(1/6.d0)   * cb2i(2)
*  #]   wrap up:
*  #[ xp=0, m1!=m2:
	elseif (dm1m2 .ne. 0) then
*		#[ old code:
*		first calculate B21
*	    cs(1) = +DBLE(xm1*xm1/dm1m2) * ca0i(1)
*	    cs(2) = -     xm1*xm1/dm1m2  * xm1
*	    cs(3) = -DBLE((3*xm1**2-3*xm1*xm2+xm2**2)/dm1m2) * ca0i(2)
*	    cs(4) = +     (3*xm1**2-3*xm1*xm2+xm2**2)/dm1m2  * xm2
*	    cs(5) = (11*xm1**2-7*xm1*xm2+2*xm2**2)/6
**
*	    cb2i(2) = cs(1)+cs(2)+cs(3)+cs(4)+cs(5)
*	    if ( lwarn  ) then
*		xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)),
*     +			absc(cs(4)),absc(cs(5)))
*		if ( absc(cb2i(2)) .lt. xloss*xmax )
*     +			call ffwarn(298,ier0,absc(cb2i(2)),xmax)
*	    endif
*	    cb2i(1)=1/(3*dm1m2**2) * cb2i(2)
*		 B22 in the same way as with xp diff from zero
*		 18-nov-1993 fixed sign error in cs(2) GJ
*	    cs(1) = ca0i(2)
*	    cs(2) =+DBLE(2*xm1)*cb0
*	    cs(3) = DBLE(dm1m2)*cb1
*	    cs(4) = xm1+xm2
*	    cb2i(2) = cs(1) + cs(2) + cs(3) + cs(4)
*	    if ( lwarn ) then
*		xmax = max(absc(cs(1)),absc(cs(3)),absc(cs(4)))
*		if ( absc(cb2i(2)) .lt. xloss*xmax )
*     +			call ffwarn(298,ier1,absc(cb2i(2)),xmax)
*	    endif
*	    cb2i(2) = cb2i(2)/6
*		#] old code:
*		#[ B21:
		llogmm = .FALSE.
*
*		B21 (see thesis, b21.frm)
*
		cs(1) = DBLE(xm1**2/3/dm1m2**3)*ca0i(1)
		cs(2) = DBLE((-xm1**2 + xm1*xm2 - xm2**2/3)/dm1m2**3)*
     +			ca0i(2)
		cs(3) = (5*xm1**3/18 - xm1*xm2**2/2 + 2*xm2**3/9)
     +			/dm1m2**3
		cb2i(1) = cs(1)+cs(2)+cs(3)
		xmax = max(absc(cs(2)),absc(cs(3)))
		if ( absc(cb2i(1)).gt.xloss**2*xmax ) goto 160
		if ( lwrite ) then
		    print *,'cb2i(1) = ',cb2i(1),xmax
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,3)
		endif
*
*		ma ~ mb
*
		if ( abs(dm1m2).lt.xloss*xm1 ) then
		    xlogmm = dfflo1(dm1m2/xm1,ier)
		else
		    xlogmm = log(xm2/xm1)
		endif
		llogmm = .TRUE.
		cs(1) = (xm1/dm1m2)/6
		cs(2) = (xm1/dm1m2)**2/3
		cs(3) = (xm1/dm1m2)**3*xlogmm/3
		cs(4) = -2/DBLE(9) + ca0i(1)*DBLE(1/(3*xm1))
		cs(5) = -xlogmm/3
		csom = cs(1)+cs(2)+cs(3)+cs(4)+cs(5)
		xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),
     +			absc(cs(5)))
		if ( lwrite ) then
		    print *,'cb2i(1)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,5)
		endif
		if ( xmxp.lt.xmax ) then
		    xmax = xmxp
		    cb2i(1) = csom
		    if ( absc(cb2i(1)).gt.xloss**2*xmax ) goto 160
		endif
*
*		and last try
*
		xlo3 = dfflo3(dm1m2/xm1,ier)
		cs(1) = (dm1m2/xm1)**2/6
		cs(2) = (dm1m2/xm1)/3
		cs(3) = xlo3/(3*(dm1m2/xm1)**3)
*same		cs(4) = -2/DBLE(9) + ca0i(1)*DBLE(1/(3*xm1))
		cs(5) = -xlo3/3
		csom = cs(1)+cs(2)+cs(3)+cs(4)+cs(5)
		xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),
     +			absc(cs(5)))
		if ( lwrite ) then
		    print *,'cb2i(1)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,5)
		endif
		if ( xmxp.lt.xmax ) then
		    xmax = xmxp
		    cb2i(1) = csom
		    if ( absc(cb2i(1)).gt.xloss**2*xmax ) goto 160
		endif
*
*		give up
*
		if ( lwarn ) then
		    call ffwarn(225,ier,absc(cb2i(1)),xmax)
		    if ( lwrite ) then
			print *,'xp,xm1,xm2 = ',xp,xm1,xm2
		    endif
		endif
  160		continue
*		#] B21:
*		#[ B22:
*
*		B22
*
		cs(1) = +DBLE(xm1/(4*dm1m2))*ca0i(1)
		cs(2) = -DBLE(xm2/(4*dm1m2))*ca0i(2)
		cs(3) = (xm1+xm2)/8
		cb2i(2) = cs(1) + cs(2) + cs(3)
		xmax = max(absc(cs(2)),absc(cs(3)))
		if ( absc(cb2i(2)).gt.xloss*xmax ) goto 210
		if ( lwrite ) then
		    print *,'cb2i(2) = ',cb2i(2),xmax
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,3)
		endif
*
*		second try, close together
*
		if ( .not.llogmm ) then
		    if ( abs(dm1m2).lt.xloss*xm1 ) then
		    	xlogmm = dfflo1(dm1m2/xm1,ier)
		    else
		    	xlogmm = log(xm2/xm1)
		    endif
		endif
		cs(1) = dm1m2*( -1/DBLE(8) - ca0i(1)*DBLE(1/(4*xm1)) )
		cs(2) = dm1m2*xlogmm/4
		cs(3) = xm1*(xm1/dm1m2)/4*xlogmm
		cs(4) = xm1*( 1/DBLE(4) + ca0i(1)*DBLE(1/(2*xm1)) )
		cs(5) = -xm1*xlogmm/2
		csom = cs(1) + cs(2) + cs(3) + cs(4) + cs(5)
		xmxp = max(absc(cs(2)),absc(cs(3)),absc(cs(4)),
     +			absc(cs(5))) 
		if ( lwrite ) then
		    print *,'cb2i(2)+= ',csom,xmxp
		    print *,'with cs '
		    print '(i3,2e30.16)',(i,cs(i),i=1,2)
		endif
		if ( xmxp.lt.xmax ) then
		    xmax = xmxp
		    cb2i(2) = csom
		endif
		if ( absc(cb2i(2)).gt.xloss*xmax ) goto 210
*
*		give up
*
		if ( lwarn ) then
		    call ffwarn(226,ier,absc(cb2i(2)),xmax)
		    if ( lwrite ) then
			print *,'xp,xm1,xm2 = ',xp,xm1,xm2
		    endif
		endif
  210		continue
*		#] B22:
*  #] xp=0, m1!=m2:
*  #[ xp=0, m1==m2:
	else
*
*	    taken over from ffxb2a, which in turns stem from my thesis GJ
*
	    cb2i(1) = cb0/3
	    cb2i(2) = DBLE(xm1/2)*(cb0 + 1)
	endif
*  #] xp=0, m1==m2:
*  #[ finish up:
	ier = max(ier0,ier1)
*  #] finish up:
*###] ffxb2q:
	end
*###[ ffxc0:
	subroutine ffxc0(cc0,xpi,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the threepoint function closely following		*
*	recipe in 't Hooft & Veltman, NP B(183) 1979.			*
*	Bjorken and Drell metric is used nowadays!			*
*									*
*	    p2	^ |							*
*		| |							*
*		 / \							*
*	      m2/   \m3 						*
*	p1     /     \	p3						*
*	<-    /  m1   \ ->						*
*	------------------------					*
*									*
*		1   /			     1				*
*	    = ----- \d^4Q----------------------------------------	*
*	      ipi^2 /	 [Q^2-m1^2][(Q+p1)^2-m2^2][(Q-p3)^2-m3^2]	*
*									*
*	If the function is infra-red divergent (p1=m2,p3=m3,m1=0 or	*
*	cyclic) the function is calculated with a user-supplied cutoff	*
*	delta in the common block /ffcut/.				*
*									*
*	Input:	xpi	(real)		i=1,3: mass^2, i=4,6: pi.pi	*
*	Output: cc0	(complex)	C0, the threepoint function.	*
*		ier	(integer)	0=ok, 1=inaccurate, 2=error	*
*	Calls:	ffxc0p,ffxb0p						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cc0
	DOUBLE PRECISION xpi(6)
	integer ier
*
*	local variables:
*
	integer i,j,ier0
	DOUBLE PRECISION dpipj(6,6)
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ convert input:
	if ( lwrite ) then
	    print *,'ffxc0: input = ',xpi
	endif
	if ( lwarn ) then
	    do 30 i=1,6
		dpipj(i,i) = 0
		do 29 j = i+1,6
		    dpipj(j,i) = xpi(j) - xpi(i)
		    dpipj(i,j) = - dpipj(j,i)
		    if ( abs(dpipj(j,i)) .lt. xloss*abs(xpi(i)) .and.
     +			xpi(i) .ne. xpi(j) ) then
			ier0 = 0
			call ffwarn(87,ier0,dpipj(j,i),xpi(i))
			if ( lwrite ) print *,'between xpi(',i,
     +				') and xpi(',j,')'
		    endif
   29		continue
   30	    continue
	else
	    do 40 i=1,6
		do 39 j = 1,6
		    dpipj(j,i) = xpi(j) - xpi(i)
   39		continue
   40	    continue
	endif
*  #] convert input:
*  #[ call ffxc0a:
	call ffxc0a(cc0,xpi,dpipj,ier)
*  #] call ffxc0a:
*###] ffxc0:
	end
*###[ ffxc0a:
	subroutine ffxc0a(cc0,xpi,dpipj,ier)
***#[*comment:***********************************************************
*									*
*	See ffxc0.							*
*									*
*	Input:	xpi	(real)		i=1,3: mass^2, i=4,6: pi.pi	*
*		dpipj	(real)		= xpi(i) - xpi(j)		*
*	Output: cc0	(complex)	C0, the threepoint function.	*
*		ier	(integer)	0=ok, 1=inaccurate, 2=error	*
*	Calls:	ffxc0p,ffxb0p						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cc0
	DOUBLE PRECISION xpi(6),dpipj(6,6)
	integer ier
*
*	local variables:
*
	logical ljust
	integer i,j,inew(6,6),idotsa,ier0
*	DOUBLE COMPLEX cs,cs1,cs2
	DOUBLE COMPLEX c
	DOUBLE PRECISION xqi(6),dqiqj(6,6),qiDqj(6,6),absc,delta0,
     +		dum66(6,6),rloss,xnul,xmax
	save inew,delta0
*
*	common blocks:
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	memory
*
	integer iermem(memory),ialmem(memory),memind,ierini
	DOUBLE PRECISION xpimem(6,memory),dl2mem(memory)
	DOUBLE COMPLEX cc0mem(memory)
	save memind,iermem,ialmem,xpimem,dl2mem,cc0mem
	data memind /0/
*
*	statement function:
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data delta0 /0./
	data inew /1,2,3,4,5,6,
     +		   2,3,1,5,6,4,
     +		   3,1,2,6,4,5,
     +		   1,3,2,6,5,4,
     +		   3,2,1,5,4,6,
     +		   2,1,3,4,6,5/
*  #] declarations:
*  #[ initialisations:
	if ( lmem .and. memind .eq. 0 ) then
	    do 2 i=1,memory
		do 1 j=1,6
		    xpimem(j,i) = 0
    1		continue
		ialmem(i) = 0
    2	    continue
	endif
	idsub = 0
	ljust = .FALSE.
*  #] initialisations:
*  #[ check input:
	if ( ltest ) then
*	    I have had too many problems here ...
	    if ( abs(isgnal) .ne. 1 ) then
		print *,'ffxc0: error: ab(isgnal) /= 1!',isgnal
		if ( isgnal .eq. 0 ) then
		    isgnal = 1
		else
		    isgnal = sign(1,isgnal)
		endif
	    endif
*	    check input dot products if present
	    if ( idot.gt.0 ) then
	    	ier0 = ier
	    	idotsa = idot
	    	idot = 0
	    	call ffdot3(qiDqj,xpi,dpipj,6,ier0)
	    	idot = idotsa
	    	rloss = xloss**2*DBLE(10)**(-mod(ier0,50))
	    	if ( idot.le.2 ) then
		    do 20 i=4,6
		        do 10 j=4,6
			    xnul = abs(fpij3(j,i)-qiDqj(j,i))
			    xmax = abs(qiDqj(j,i))
			    if ( rloss*xnul .gt. precx*xmax ) print *,
     +			    'ffxc0a: error: input dotproduct piDpj(',j,
     +			    i,') wrong:',fpij3(j,i),qiDqj(j,i),xnul,ier0
   10		    	continue
   20		    continue
	       	else
		    do 40 i=1,6
		    	do 30 j=1,6
			    xnul = abs(fpij3(j,i)-qiDqj(j,i))
			    xmax = abs(qiDqj(j,i))
			    if ( rloss*xnul .gt. precx*xmax ) print *,
     +			    'ffxc0a: error: input dotproduct piDpj(',j,
     +			    i,') wrong:',fpij3(j,i),qiDqj(j,i),xnul,ier0
   30		    	continue
   40		    continue
	    	endif
	    endif
	endif
*  #] check input:
*  #[ handel special cases:
*
*	The infrared divergent diagrams are calculated in ffxc0i:
*
	if ( dpipj(2,4).eq.0 .and. dpipj(3,6).eq.0 .and. xpi(1).eq.0
     +	.or. dpipj(3,5).eq.0 .and. dpipj(1,4).eq.0 .and. xpi(2).eq.0
     +	.or. dpipj(1,6).eq.0 .and. dpipj(2,5).eq.0 .and. xpi(3).eq.0 )
     +	then
	    call ffxc0i(cc0,xpi,dpipj,ier)
	    return
	endif
**
*	The general case cannot handle xpi=0, pj=pk. These are simple
*	though.
**
*	goto 50
*	if ( xpi(4) .eq. 0 .and. dpipj(5,6) .eq. 0 .and.
*     +		dpipj(1,2) .ne. 0 ) then
*	    call ffxb0p(cs1,-xpi(5),xpi(1),xpi(3),dpipj(1,6),dpipj(3,5),
*     +			dpipj(1,3),ier)
*	    call ffxb0p(cs2,-xpi(5),xpi(2),xpi(3),dpipj(2,5),dpipj(3,5),
*     +			dpipj(2,3),ier)
*	    cs = cs1 - cs2
*	    cc0 = cs/dpipj(1,2)
*	elseif ( xpi(6) .eq. 0 .and. dpipj(4,5) .eq. 0 .and.
*     +		dpipj(3,1) .ne. 0 ) then
*	    call ffxb0p(cs1,-xpi(4),xpi(3),xpi(2),dpipj(3,5),dpipj(2,4),
*     +			dpipj(3,2),ier)
*	    call ffxb0p(cs2,-xpi(4),xpi(1),xpi(2),dpipj(1,4),dpipj(2,4),
*     +			dpipj(1,2),ier)
*	    cs = cs1 - cs2
*	    cc0 = cs/dpipj(3,1)
*	elseif ( xpi(5) .eq. 0 .and. dpipj(6,4) .eq. 0 .and.
*     +		dpipj(2,3) .ne. 0 ) then
*	    call ffxb0p(cs1,-xpi(6),xpi(2),xpi(1),dpipj(2,4),dpipj(1,6),
*     +			dpipj(2,1),ier)
*	    call ffxb0p(cs2,-xpi(6),xpi(3),xpi(1),dpipj(3,6),dpipj(1,6),
*     +			dpipj(3,1),ier)
*	    cs = cs1 - cs2
*	    cc0 = cs/dpipj(2,3)
*	else
*	    goto 50
*	endif
**
*	common piece - excuse my style
**
*	print *,'ffcc0: WARNING: this algorithm has not yet been tested'
*	if ( lwarn .and. absc(cs) .lt. xloss*absc(cs1) )
*     +		call ffwarn(28,ier,absc(cs),absc(cs1))
**
*	debug output
**
*	if (lwrite) then
*	    print *,'simple case xpi=0,xpj=xpk, two twopoint functions:'
*	    print *,cs1,cs2
*	    print *,'result: cc0=',cc0,ier
*	endif
*	return
*   50	continue
*  #] handel special cases:
*  #[ rotate to alpha in (0,1):
	call ffrot3(irota3,xqi,dqiqj,qiDqj,xpi,dpipj,dum66,6,2,3,ier)
*  #] rotate to alpha in (0,1):
*  #[ look in memory:
	ierini = ier+ner
	if ( lmem .and. delta .eq. delta0 ) then
	    do 70 i=1,memory
		do 60 j=1,6
		    if ( xqi(j) .ne. xpimem(j,i) ) goto 70
   60		continue
		if ( ialmem(i) .ne. isgnal ) goto 70
*		we found an already calculated masscombination ..
*		(maybe check differences as well)
		if ( lwrite ) print *,'ffxc0: using previous result'
		cc0 = cc0mem(i)
		ier = ier+iermem(i)
		if ( ldot ) then
		    fdel2 = dl2mem(i)
*		    we forgot to recalculate the stored quantities
		    ljust = .TRUE.
		    goto 71
		endif
		return
   70	    continue
*	    if ( lwrite ) print *,'ffxc0: not found in memory'
	elseif ( lmem ) then
	    delta0 = delta
	endif
   71	continue
*  #] look in memory:
*  #[ dot products:
	call ffdot3(qiDqj,xqi,dqiqj,6,ier)
*
*	save dotproducts for tensor functions if requested
*
	if ( ldot ) then
	    do 75 i=1,6
		do 74 j=1,6
		    fpij3(j,i) = qiDqj(inew(i,irota3),inew(j,irota3))
   74		continue
   75	    continue
	    if ( irota3 .gt. 3 ) then
*
*		the sign of the s's has been changed!
*
		do 77 i=1,3
		    do 76 j=4,6
			fpij3(j,i) = -fpij3(j,i)
			fpij3(i,j) = -fpij3(i,j)
   76		    continue
   77		continue
	    endif
	endif
	if ( ljust ) return
*  #] dot products:
*  #[ call ffxc0b:
	call ffxc0b(cc0,xqi,dqiqj,qiDqj,ier)
*  #] call ffxc0b:
*  #[ add to memory:
	if ( lmem ) then
	    memind = memind + 1
	    if ( memind .gt. memory ) memind = 1
	    do 200 j=1,6
		xpimem(j,memind) = xqi(j)
  200	    continue
	    cc0mem(memind) = cc0
	    iermem(memind) = ier+ner-ierini
	    ialmem(memind) = isgnal
	    dl2mem(memind) = fdel2
	endif
*  #] add to memory:
*###] ffxc0a:
	end
*###[ ffxc0b:
	subroutine ffxc0b(cc0,xqi,dqiqj,qiDqj,ier)
***#[*comment:***********************************************************
*									*
*	See ffxc0.							*
*									*
*	Input:	xpi	(real)		i=1,3: mass^2, i=4,6: pi.pi	*
*		dpipj	(real)		= xpi(i) - xpi(j)		*
*	Output: cc0	(complex)	C0, the threepoint function.	*
*		ier	(integer)	0=ok, 1=inaccurate, 2=error	*
*	Calls:	ffxc0p,ffxb0p						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cc0
	DOUBLE PRECISION xqi(6),dqiqj(6,6),qiDqj(6,6)
	integer ier
*
*	local variables:
*
	integer nerr
	parameter(nerr=6)
	integer isoort(8),ipi12(8),i,j,k,ipi12t,ilogi(3),ier0,ieri(nerr)
	DOUBLE COMPLEX cs3(80),cs,cs1,cs2,c,clogi(3),cslam,cetalm,
     +		cetami(6),cel2s(3),clamp,calph(3),cblph(3),csdel2,
     +		cqi(6),cdqiqj(6,6),cqiDqj(6,6),celpsi(3),cdum(3),
     +		cdum2(3,3)
	DOUBLE PRECISION del2,del2s(3),del3,delpsi(3),
     +		del3mi(3)
	DOUBLE PRECISION xmax,absc,alph(3),etalam,etami(6),sdel2,
     +		xlamp,eta,blph(3)
*
*	common blocks:
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	statement function:
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'input: xqi,dqiqj'
	    do 1 i=1,6
	    	print *,xqi(i),(dqiqj(i,j),j=1,6)
    1	    continue
	endif
*  #] check input:
*  #[ calculations:
*
*	some determinants
*
	if ( lwrite ) print '(a)','  ##[ determinants:'
	do 98 i = 1,nerr
	    ieri(i) = 0
   98	continue
	call ffdel2(del2,qiDqj, 6, 4,5,6, 1,ier)
	if ( lwrite ) print *,'ffxc0: del2 = ',del2
	if ( ldot ) fdel2 = del2
	if ( del2 .gt. 0 ) then
*	    shouldn't occur ...
*	    12-10-1993 three spacelike momenta are OK
	    if ( .not.(xqi(4).lt.0 .and. xqi(5).lt.0 .and. xqi(6).lt.0)
     +	    		) then
     		call fferr(41,ier)
     	    	print *,'xpi = ',xqi
     	    endif
	elseif ( del2 .eq. 0 ) then
	    call fferr(42,ier)
	    return
	endif
	call ffdel3(del3,xqi,qiDqj,6,ier)
	call ffdl3m(del3mi,.TRUE.,del3,del2,xqi,dqiqj,qiDqj,6, 4,5,6,
     +							1,3,ier)
	do 101 i=1,3
	    j = i+1
	    if ( j .eq. 4 ) j = 1
	    call ffdel2(del2s(i),qiDqj,6, i+3,i,j, 1,ieri(i))
	    k = i-1
	    if ( k .eq. 0 ) k = 3
	    call ffdl2p(delpsi(i),xqi,dqiqj,qiDqj,i+3,j+3,k+3,i,j,k,6,
     +							ieri(i+3))
  101	continue
	ier0 = 0
	do 99 i=1,nerr
	    ier0 = max(ier0,ieri(i))
   99	continue
	ier = ier + ier0
*
*	initialize cs3:
*
	do 80 i=1,80
	    cs3(i) = 0
   80	continue
	do 90 i=1,8
	    ipi12(i) = 0
   90	continue
	do 100 i=1,3
	    clogi(i) = 0
	    ilogi(i) = 0
  100	continue
*  #[ complex case:
*	in case of three spacelike momenta or unphysical real ones
	if ( del2 .gt. 0 ) then
	    do 102 i=1,3
		cel2s(i) = del2s(i)
		celpsi(i) = delpsi(i)
		cetami(i) = del3mi(i)/del2
  102	    continue
	    do 104 i=1,6
		cqi(i) = xqi(i)
		do 103 j=1,6
		    cdqiqj(j,i) = dqiqj(j,i)
		    cqiDqj(j,i) = qiDqj(j,i)
  103		continue
  104	    continue
	    cetalm = del3/del2
	    csdel2 = isgnal*DCMPLX(x0,sqrt(del2))
*
*	    get alpha,1-alpha
*
	    call ffcoot(cblph(1),calph(1),cqi(5),-cqiDqj(5,6),cqi(6),
     +							csdel2,ier)
	    call ffcoot(calph(3),cblph(3),cqi(5),-cqiDqj(5,4),cqi(4),
     +							csdel2,ier)
	    cslam = 2*csdel2
	    if (lwrite) then
		print '(a)','  ##[ get roots: (ffxc0)'
		print *,'cslam   =',2*csdel2
		ier0 = ier
*		call ffclmb(clamp,cqi(4),cqi(5),cqi(6),cdqiqj(4,5),
*     +					cdqiqj(4,6),cdqiqj(5,6),ier0)
*		print *,'cslamp  =',sqrt(clamp)
		print *,'ceta    =',-4*del3
*		call ffeta(eta,xpi,dpipj,6,ier0)
*		print *,'cetap   =',eta
		print *,'cetalam =',cetalm
		print *,'calpha  = ',calph(1),calph(3)
	    endif
	    if ( lwrite ) print '(a)','  ##] determinants:'
	    call ffcc0p(cs3,ipi12,isoort,clogi,ilogi,cqi,cdqiqj,cqiDqj,
     +		csdel2,cel2s,cetalm,cetami,celpsi,calph,3,ier)
	    goto 109
	endif
*  #] complex case:
	etalam = del3/del2
	do 106 i=1,3
	    etami(i) = del3mi(i)/del2
  106	continue
	sdel2 = isgnal*sqrt(-del2)
*
*	get alpha,1-alpha
*
	call ffroot(blph(1),alph(1),xqi(5),-qiDqj(5,6),xqi(6),sdel2,ier)
	call ffroot(alph(3),blph(3),xqi(5),-qiDqj(5,4),xqi(4),sdel2,ier)
	if ( l4also .and. ( alph(1) .gt. 1 .or. alph(1) .lt. 0 ) .and.
     +		abs(blph(1)-x05) .lt. abs(alph(1)-x05) ) then
	    alph(1) = blph(1)
	    alph(3) = blph(3)
	    sdel2 = -sdel2
	    isgnal = -isgnal
	endif
	cslam = 2*sdel2
	if (lwrite) then
	    print '(a)','  ##[ get roots:'
	    print *,'slam   =',2*sdel2
*	    ier0 = ier
*	    call ffxlmb(xlamp,xqi(4),xqi(5),xqi(6),dqiqj(4,5),
*     +					dqiqj(4,6),dqiqj(5,6),ier0)
*	    print *,'slamp  =',sqrt(xlamp)
	    print *,'eta    =',-4*del3
*	    call ffeta(eta,xpi,dpipj,6,ier0)
*	    print *,'etap   =',eta
	    print *,'etalam =',etalam
	    print *,'alpha = ',alph(1),alph(3)
	endif
	if ( lwrite ) print '(a)','  ##] determinants:'
*
*	and the calculations
*
	call ffxc0p(cs3,ipi12,isoort,clogi,ilogi,xqi,dqiqj,qiDqj,
     +			sdel2,del2s,etalam,etami,delpsi,alph,3,ier)
*
*	sum'em up:
*
  109	continue
	cs = 0
	xmax = 0
	do 110 i=1,80
*	    if ( cs3(i) .ne. 0 ) then
		cs = cs + cs3(i)
		xmax = max(xmax,absc(cs))
*	    endif
  110	continue
	ipi12t = ipi12(1)
	do 120 i=2,8
	    ipi12t = ipi12t + ipi12(i)
  120	continue
	cs = cs + ipi12t*DBLE(pi12)
*
*	Check for cancellations in the final adding up (give a fctor 2)
*
	if ( lwarn .and. 2*absc(cs) .lt. xloss*xmax )
     +		call ffwarn(29,ier,absc(cs),xmax)
*
*	Check for a sum close to the minimum of the range (underflow
*	problems)
*
	if ( lwarn .and. absc(cs) .lt. xalogm/precc )
     +		call ffwarn(120,ier,absc(cs),xalogm/precc)
*
*	A imaginary component less than precc times the real part is
*	zero (may be removed)
*
	if ( abs(DIMAG(cs)) .lt. precc*abs(DBLE(cs)) )
     +	    cs = DCMPLX(DBLE(cs))
*
*	Finally ...
*
	cc0 = - cs/cslam
*  #] calculations:
*  #[ debug:
	if(lwrite)then
*	    print '(a)','  ##[ all terms: '
*	    print *,'s3''s :'
* 1000	    format(g12.6,1x,g12.6,1x,g12.6,1x,g12.6,1x,g12.6,1x,
*     +		g12.6,1x,g12.6,1x,g12.6)
*	    print 1000,(cs3(i),cs3(i+20),cs3(i+40),cs3(i+60),i=1,20)
	    print *,'ipi12: ',ipi12
	    print *,'isoort:' ,isoort
*	    print '(a)','  ##] all terms: '
	    print *,'som  :',cs,ipi12t,ier
	    print *,'cc0  :',cc0
	endif
*  #] debug:
*###] ffxc0b:
	end
*###[ ffrot3:
	subroutine ffrot3(irota,xqi,dqiqj,qiDqj,xpi,dpipj,piDpj,ns,
     +		iflag,npoin,ier)
***#[*comment:***********************************************************
*									*
*	rotates the arrays xpi, dpipj into xqi,dqiqj so that		*
*	xpi(6),xpi(4) suffer the strongest outside cancellations and	*
*	xpi(6) > xpi(4) if iflag = 1, so that xpi(5) largest and xpi(5)	*
*	and xpi(6) suffer cancellations if iflag = 2.			*
*	if iflag = 3 make xqi(3)=0.					*
*	If npoin=4, rotate piDpj into qiDqj as well.			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer irota,ns,iflag,ier,npoin
	DOUBLE PRECISION xpi(6),dpipj(6,6),piDpj(6,6),xqi(6),dqiqj(6,6),
     +		qiDqj(6,6)
*
*	local variables
*
	DOUBLE PRECISION a1,a2,a3,xpimax
	DOUBLE COMPLEX chulp(3,3)
	integer i,j,inew(6,6)
	save inew
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data inew /1,2,3,4,5,6,
     +		   2,3,1,5,6,4,
     +		   3,1,2,6,4,5,
     +		   1,3,2,6,5,4,
     +		   3,2,1,5,4,6,
     +		   2,1,3,4,6,5/
*  #] declarations:
*  #[ check input:
	if ( ltest .and. ns .ne. 6 ) print *,'ffrot3: error: ns /= 6'
*  #] check input:
*  #[ get largest cancellation:
	if ( iflag .eq. 1 ) then
	    a1 = abs(dpipj(6,4))/max(abs(xpi(6)+xpi(4)),xalogm)
	    a2 = abs(dpipj(5,4))/max(abs(xpi(5)+xpi(4)),xalogm)
	    a3 = abs(dpipj(5,6))/max(abs(xpi(6)+xpi(5)),xalogm)
	    if ( a1 .le. a2 .and. a1 .le. a3 ) then
		irota = 1
		if ( abs(xpi(6)) .lt. abs(xpi(4)) ) then
		    irota = 4
		endif
	    elseif ( a2 .le. a3 ) then
		irota = 3
		if ( abs(xpi(4)) .lt. abs(xpi(5)) ) then
		    irota = 6
		endif
	    else
		irota = 2
		if ( abs(xpi(5)) .lt. abs(xpi(6)) ) then
		    irota = 5
		endif
	    endif
	elseif ( iflag .eq. 2 ) then
	    xpimax = max(xpi(4),xpi(5),xpi(6))
	    if ( xpimax .eq. 0 ) then
		if ( xpi(5) .ne. 0 ) then
		    irota = 1
		elseif ( xpi(4) .ne. 0 ) then
		    irota = 2
		elseif ( xpi(6) .ne. 0 ) then
		    irota = 3
		else
		    call fferr(40,ier)
		    irota = 1
		endif
	    elseif ( xpi(5) .eq. xpimax ) then
		if ( xpi(4) .le. xpi(6) ) then
		    irota = 1
		else
		    irota = 4
		endif
	    elseif ( xpi(4) .eq. xpimax ) then
		if ( xpi(5) .ge. xpi(6) ) then
		    irota = 2
		else
		    irota = 5
		endif
	    else
		if ( xpi(4) .ge. xpi(6) ) then
		    irota = 3
		else
		    irota = 6
		endif
	    endif
	elseif ( iflag .eq. 3 ) then
	    if ( dpipj(2,4).eq.0 .and. dpipj(3,6).eq.0 .and.
     +			xpi(1).eq.0 ) then
		irota = 3
	    elseif ( dpipj(1,6).eq.0 .and. dpipj(2,5).eq.0 .and.
     +			xpi(3).eq.0 ) then
		irota = 1
	    elseif ( dpipj(3,5).eq.0 .and. dpipj(1,4).eq.0 .and.
     +			xpi(2).eq.0 ) then
		irota = 2
	    else
		call fferr(35,ier)
	    	irota = 1
	    endif
	else
	    call fferr(35,ier)
	    irota = 1
	endif
	if ( lwrite ) print *,'ffrot3: rotated over ',irota,' positions'
*  #] get largest cancellation:
*  #[ rotate:
	do 20 i=1,6
	    xqi(inew(i,irota)) = xpi(i)
	    do 10 j=1,6
		dqiqj(inew(i,irota),inew(j,irota)) = dpipj(i,j)
   10	    continue
   20	continue
*
*	when called in a 4pointfunction we already have the dotproducts
*
	if ( npoin .eq. 4 ) then
	    do 80 j=1,6
	    	do 70 i=1,6
	    	    qiDqj(inew(i,irota),inew(j,irota)) = piDpj(i,j)
   70	    	continue
   80	    continue
	endif
*DEBUG	if ( iflag .eq. 3 .and. lsmug ) then
	if ( lsmug ) then
*	    
*	    do not forget to rotate the smuggled differences
*	    
	    do 40 j=1,3
	    	do 30 i=1,3
	    	    chulp(i,j) = cmipj(i,j)
   30	    	continue
   40	    continue
	    do 60 j=1,3
	    	do 50 i=1,3
	    	    cmipj(inew(i,irota),inew(j+3,irota)-3) = chulp(i,j)
   50	    	continue
   60	    continue
	endif
*  #] rotate:
*  #[ test output:
	if ( ltest ) then
	    call ffxhck(xqi,dqiqj,6,ier)
	    if ( iflag .eq. 3 .and. xqi(3) .ne. 0 ) print *,
     +		'ffrot3: IR divergent C0 rotated wrongly!',xqi
	endif
*  #] test output:
*###] ffrot3:
	end
*###[ ffdot3:
	subroutine ffdot3(piDpj,xpi,dpipj,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate the dotproducts pi.pj with				*
*									*
*		pi = si		i1=1,3					*
*		pi = p(i-3)	i1=4,6					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ns,ier
	DOUBLE PRECISION xpi(6),dpipj(6,6),piDpj(6,6)
*
*	locals
*
	integer is1,is2,is3,ip1,ip2,ip3,i,j,ier0,ier1,inew(6,6)
	DOUBLE PRECISION xheck
	save inew
*
*	rest
*
	include 'ff.h'
*
*	data
*
	data inew /1,2,3,4,5,6,
     +		   2,3,1,5,6,4,
     +		   3,1,2,6,4,5,
     +		   1,3,2,6,5,4,
     +		   3,2,1,5,4,6,
     +		   2,1,3,4,6,5/
*
*  #] declarations:
*  #[ check input:
	if ( ns .ne. 6 ) print *,'ffdot3: error: ns /= 6 '
	if ( ltest ) call ffxhck(xpi,dpipj,6,ier)
*  #] check input:
*  #[ copy if known:
*
	if ( idot.ge.3 ) then
	    do 2 i=1,6
	    	do 1 j=1,6
	    	    piDpj(inew(j,irota3),inew(i,irota3)) = fpij3(j,i)
    1	    	continue
    2	    continue
	    if ( irota3 .gt. 3 ) then
*
*		the sign of the s's has been changed!
*
		do 4 i=1,3
		    do 3 j=4,6
			piDpj(j,i) = -piDpj(j,i)
			piDpj(i,j) = -piDpj(i,j)
    3		    continue
    4		continue
	    endif
	    return
	endif
*
*  #] copy if known:
*  #[ calculations:
	ier1 = ier
	do 10 is1=1,3
	    is2 = is1 + 1
	    if ( is2 .eq. 4 ) is2 = 1
	    is3 = is2 + 1
	    if ( is3 .eq. 4 ) is3 = 1
	    ip1 = is1 + 3
	    ip2 = is2 + 3
	    ip3 = is3 + 3
*
*	    pi.pj, si.sj
*
	    piDpj(is1,is1) = xpi(is1)
	    piDpj(ip1,ip1) = xpi(ip1)
*
*	    si.s(i+1)
*
	    if ( xpi(is2) .le. xpi(is1) ) then
		piDpj(is1,is2) = (dpipj(is1,ip1) + xpi(is2))/2
	    else
		piDpj(is1,is2) = (dpipj(is2,ip1) + xpi(is1))/2
	    endif
	    if ( lwarn ) then
		ier0 = ier
		if ( abs(piDpj(is1,is2)) .lt. xloss*min(xpi(is1),
     +			xpi(is2))/2 ) call ffwarn(100,ier0,piDpj(is1,
     +			is2),min(xpi(is1),xpi(is2))/2)
		ier1 = max(ier1,ier0)
	    endif
	    piDpj(is2,is1) = piDpj(is1,is2)
*
*	    pi.si
*
	    if ( abs(xpi(ip1)) .le. xpi(is1) ) then
		piDpj(ip1,is1) = (dpipj(is2,is1) - xpi(ip1))/2
	    else
		piDpj(ip1,is1) = (dpipj(is2,ip1) - xpi(is1))/2
	    endif
	    piDpj(is1,ip1) = piDpj(ip1,is1)
	    if ( lwarn ) then
		ier0 = ier
		if ( abs(piDpj(ip1,is1)) .lt. xloss*min(abs(xpi(ip1)),
     +			xpi(is1))/2) call ffwarn(101,ier0,
     +			piDpj(ip1,is1),min(abs(xpi(ip1)),xpi(is1))/2)
		ier1 = max(ier1,ier0)
	    endif
*
*	    pi.s(i+1)
*
	    if ( abs(xpi(ip1)) .le. xpi(is2) ) then
		piDpj(ip1,is2) = (dpipj(is2,is1) + xpi(ip1))/2
	    else
		piDpj(ip1,is2) = (dpipj(ip1,is1) + xpi(is2))/2
	    endif
	    piDpj(is2,ip1) = piDpj(ip1,is2)
	    if ( lwarn ) then
		ier0 = ier
		if ( abs(piDpj(ip1,is2)) .lt. xloss*min(abs(xpi(ip1)),
     +			xpi(is2))/2) call ffwarn(102,ier0,
     +			piDpj(ip1,is2),min(abs(xpi(ip1)),xpi(is2))/2)
		ier1 = max(ier1,ier0)
	    endif
*
*	    pi.s(i+2)
*
	    if ( min(abs(dpipj(is2,is1)),abs(dpipj(ip3,ip2))) .le.
     +		 min(abs(dpipj(ip3,is1)),abs(dpipj(is2,ip2))) ) then
		piDpj(ip1,is3) = (dpipj(ip3,ip2) + dpipj(is2,is1))/2
	    else
		piDpj(ip1,is3) = (dpipj(ip3,is1) + dpipj(is2,ip2))/2
	    endif
	    piDpj(is3,ip1) = piDpj(ip1,is3)
	    if ( lwarn ) then
		ier0 = ier
		if ( abs(piDpj(ip1,is3)) .lt. xloss*min(abs(dpipj(ip3,
     +			ip2)),abs(dpipj(ip3,is1)))/2 ) call ffwarn(103,
     +			ier0,piDpj(ip1,is3),min(abs(dpipj(ip3,ip2)),
     +			abs(dpipj(ip3,is1)))/2)
		ier1 = max(ier1,ier0)
	    endif
*
*	    pi.p(i+1)
*
	    if ( idot.le.0 ) then
	    	if ( abs(xpi(ip2)) .le. abs(xpi(ip1)) ) then
		    piDpj(ip1,ip2) = (dpipj(ip3,ip1) - xpi(ip2))/2
	    	else
		    piDpj(ip1,ip2) = (dpipj(ip3,ip2) - xpi(ip1))/2
	    	endif
	    	piDpj(ip2,ip1) = piDpj(ip1,ip2)
	    	if ( lwarn ) then
		    ier0 = ier
		    if ( abs(piDpj(ip1,ip2)) .lt.
     +			xloss*min(abs(xpi(ip1)),abs(xpi(ip2)))/2 ) call
     +			ffwarn(104,ier0,piDpj(ip1,ip2),
     +			min(abs(xpi(ip1)),abs(xpi(ip2)))/2)
		    ier1 = max(ier1,ier0)
	    	endif
	    else
	    	piDpj(inew(ip2,irota3),inew(ip1,irota3)) = 
     +	    		fpij3(ip1,ip2)
     		piDpj(inew(ip1,irota3),inew(ip2,irota3)) = 
     +     		piDpj(inew(ip2,irota3),inew(ip1,irota3))
	    endif
   10	continue
	ier = ier1
*
*  #] calculations:
*  #[ check:
	if ( ltest ) then
	    do 20 i = 1,6
		xheck = piDpj(i,4) + piDpj(i,5) + piDpj(i,6)
		if ( xloss*abs(xheck) .gt. precx*max(abs(piDpj(i,4)),
     +			abs(piDpj(i,5)),abs(piDpj(i,6))) ) print *,
     +			'ffdot3: error: dotproducts with p(',i,
     +			') wrong: ',xheck,(piDpj(i,j),j=4,6)
   20	    continue
	endif
*  #] check:
*###] ffdot3:
	end
*###[ ffxc0r:
	subroutine ffxc0r(cc0,xpi,ier)
***#[*comment:***********************************************************
*									*
*	Tries all 2 permutations of the 3pointfunction			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE PRECISION xpi(6),xqi(6)
	DOUBLE COMPLEX cc0,cc0p
	integer inew(6,2),irota,ier1,i,j,icon,ialsav,init
	logical lcon
	parameter (icon=3)
	save inew,init,lcon
	include 'ff.h'
	data inew /1,2,3,4,5,6,
     +		   1,3,2,6,5,4/
	data init /0/
*  #] declarations:
*  #[ open console for some activity on screen:
	if ( init .eq. 0 ) then
	    init = 1
	    if ( lwrite ) then
		open(icon,file='CON:',status='old',err=11)
		lcon = .TRUE.
		goto 13
	    endif
   11	    continue
	    lcon = .FALSE.
   13	    continue
	endif
*  #] open console for some activity on screen:
*  #[ calculations:
	cc0 = 0
	ier = 999
	ialsav = isgnal
	do 30 j = -1,1,2
	    do 20 irota=1,2
		do 10 i=1,6
		    xqi(inew(i,irota)) = xpi(i)
   10		continue
		print '(a,i1,a,i2)','---#[ rotation ',irota,': isgnal ',
     +			isgnal
		if (lcon) write(icon,'(a,i1,a,i2)')'rotation ',irota,',
     +			isgnal ',isgnal
		ier1 = 0
		ner = 0
		id = id + 1
		isgnal = ialsav
		call ffxc0(cc0p,xqi,ier1)
		ier1 = ier1 + ner
		print '(a,i1,a,i2)','---#] rotation ',irota,': isgnal ',
     +			isgnal
		print '(a,2g28.16,i3)','c0 = ',cc0p,ier1
		if (lcon) write(icon,'(a,2g28.16,i3)')'d0 = ',cc0p,ier1
		if ( ier1 .lt. ier ) then
		    cc0 = cc0p
		    ier = ier1
		endif
   20	    continue
	    ialsav = -ialsav
   30	continue
*  #] calculations:
*###] ffxc0r:
	end
*###[ ffxc0i:
	subroutine ffxc0i(cc0,xpi,dpipj,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the infrared finite part of a infrared divergent	*
*	threepoint function with the factor ipi^2.  The cutoff		*
*	parameter is assumed to be in a common block /ffcut/. (ugly)	*
*									*
*	Input:	xpi(6)		(real)	pi.pi (B&D)			*
*		dpipj(6,6)	(real)	xpi(i)-xpi(j)			*
*		/ffcut/delta	(real)	cutoff (either foton mass**2 or	*
*						radiation limit).	*
*	Output: cc0	(complex)	C0, the threepoint function.	*
*		ier	(integer)	usual error flag		*
*	Calls:								*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cc0
	DOUBLE PRECISION xpi(6),dpipj(6,6)
*
*	local variables
*
	integer init,ipi12,i,ilogi(3),irota,n
	integer j,inew(6,6)
	DOUBLE COMPLEX cs(15),csum,c,clogi(3)
	DOUBLE PRECISION xqi(6),dqiqj(6,6),qiDqj(6,6),sdel2,xmax,absc,
     +		dum66(6,6),del2
	save init,inew,ilogi
*
*	common blocks etc
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	data
*
	data init /0/
	data inew /1,2,3,4,5,6,
     +		   2,3,1,5,6,4,
     +		   3,1,2,6,4,5,
     +		   1,3,2,6,5,4,
     +		   3,2,1,5,4,6,
     +		   2,1,3,4,6,5/
	data ilogi /3*0/
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	initialisations
*
	do 1 i=1,15
	    cs(i) = 0
    1	continue
	ipi12 = 0
*  #] declarations:
*  #[ check input:
	if ( init .eq. 0 .and. .not.lsmug ) then
	    init = 1
	    print *,'ffxc0i: infra-red divergent threepoint function, ',
     +		'working with a cutoff ',delta
	endif
	if ( .not.lsmug .and. delta .eq. 0 ) then
	    call fferr(59,ier)
	    return
	endif
	if ( lwrite ) then
*	    print input
	    print *,'ffxc0i: infrared divergent threepoint function'
	    if ( .not.lsmug ) then
		print *,'  cutoff parameter:',delta
	    endif
	endif
*  #] check input:
*  #[ groundwork:
*
*	rotate to xpi(3)=0, xpi(1)=xpi(6), xpi(2)=xpi(5)
*
	call ffrot3(irota,xqi,dqiqj,qiDqj,xpi,dpipj,dum66,6,3,3,ier)
*
*	get some dotproducts
*
	if ( ldot ) then
	    call ffdot3(qiDqj,xqi,dqiqj,6,ier)
	    do 5 i=1,6
		do 4 j=1,6
		    fpij3(j,i) = qiDqj(inew(i,irota),inew(j,irota))
    4		continue
    5	    continue
	else
	if ( abs(xqi(4)) .lt. xqi(1) ) then
	    qiDqj(4,1) = dqiqj(2,1) - xqi(4)
	    xmax = abs(xqi(4))
	else
	    qiDqj(4,1) = dqiqj(2,4) - xqi(1)
	    xmax = xqi(1)
	endif
	if ( lwarn .and. abs(qiDqj(4,1)) .lt. xloss*xmax )
     +		call ffwarn(156,ier,qiDqj(4,1),xmax)
	qiDqj(4,1) = qiDqj(4,1)/2
	qiDqj(1,4) = qiDqj(4,1)

	if ( abs(xqi(4)) .lt. xqi(2) ) then
	    qiDqj(4,2) = dqiqj(2,1) + xqi(4)
	    xmax = abs(xqi(4))
	else
	    qiDqj(4,2) = xqi(2) - dqiqj(1,4)
	    xmax = xqi(2)
	endif
	if ( lwarn .and. abs(qiDqj(4,2)) .lt. xloss*xmax )
     +		call ffwarn(156,ier,qiDqj(4,2),xmax)
	qiDqj(4,2) = qiDqj(4,2)/2
	qiDqj(2,4) = qiDqj(4,2)

	if ( (xqi(1)) .lt. (xqi(2)) ) then
	    qiDqj(1,2) = xqi(1) + dqiqj(2,4)
	    xmax = xqi(1)
	else
	    qiDqj(1,2) = xqi(2) + dqiqj(1,4)
	    xmax = xqi(2)
	endif
	if ( lwarn .and. abs(qiDqj(1,2)) .lt. xloss*xmax )
     +		call ffwarn(156,ier,qiDqj(1,2),xmax)
	qiDqj(1,2) = qiDqj(1,2)/2
	qiDqj(2,1) = qiDqj(1,2)

	qiDqj(1,1) = xqi(1)
	qiDqj(2,2) = xqi(2)
	qiDqj(4,4) = xqi(4)
	endif
*  #] groundwork:
*  #[ calculations:
*
	call ffdel2(del2,qiDqj,6,1,2,4,1,ier)
	if ( ldot ) fdel2 = del2
*
*	the case del2=0 is hopeless - this is really a two-point function
*
	if ( del2 .eq. 0 ) then
	    call fferr(58,ier)
	    return
	endif
*
*	we cannot yet handle the complex case
*
	if ( del2 .gt. 0 ) then
	    call fferr(83,ier)
	    return
	endif
*
	sdel2 = isgnal*sqrt(-del2)
*
	call ffxc0j(cs,ipi12,sdel2,clogi,ilogi,xqi,dqiqj,qiDqj,
     +		delta,3,ier)
*  #] calculations:
*  #[ sum:
*
*	Sum
*
	xmax = 0
	csum = 0
	if ( .not.lsmug ) then
	    n = 10
	else
	    n = 15
	endif
	do 10 i=1,n
	    csum = csum + cs(i)
	    xmax = max(xmax,absc(csum))
   10	continue
	csum = csum + ipi12*DBLE(pi12)
	if ( lwarn .and. 2*absc(csum) .lt. xloss*xmax ) then
	    call ffwarn(157,ier,absc(csum),xmax)
	endif
	cc0 = -csum*DBLE(1/(2*sdel2))
*  #] sum:
*  #[ debug:
  900	continue
	if (lwrite) then
	    print '(a)','cs(i) = '
	    print '(i3,2g20.10,1x)',(i,cs(i),i=1,n)
	    print '(a3,2g20.10,1x)','pi ',ipi12*pi12
	    print '(a)','+-----------'
	    print '(a3,2g20.10,1x)','som  :',csum
	    print '(a)',' '
	    print *,'cc0  :',cc0,ier
	endif
*  #] debug:
*###] ffxc0i:
	end
*###[ ffxc0j:
	subroutine ffxc0j(cs,ipi12,sdel2i,clogi,ilogi,
     +					xpi,dpipj,piDpj,delta,npoin,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the infrared finite part of a infrared divergent	*
*	threepoint function with the factor ipi^2.			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12,ilogi(3),npoin,ier
	DOUBLE COMPLEX cs(15),clogi(3)
	DOUBLE PRECISION xpi(6),dpipj(6,6),piDpj(6,6),delta,sdel2i
*
*	local variables
*
	integer i,ieps,ieps1,n,ier0
	DOUBLE COMPLEX clog1,clog2,cdum(2),cel3,cdyzm,cdyzp,cli,chulp,
     +		carg1,carg2,chulp1
	DOUBLE COMPLEX zfflog,zxfflg,cc
	DOUBLE PRECISION del2,zm,zp,zm1,zp1,sdel2,hulp,xheck,dum(3),
     +		dfflo1,dyzp,dyzm,wm,wp,absc,arg1,arg2,del3
*
*	common blocks etc
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    call ffxhck(xpi,dpipj,6,ier)
	endif
	if ( lwrite ) then
	    print '(a)','  ##[ ffxc0j:'
	    print *,'ffxc0j: input: '
	    print *,'xpi   = ',xpi
	    if ( .not.lsmug ) then
		print *,'delta = ',delta
	    else
		print *,'cmipj(2,2) = ',cmipj(2,2)
		print *,'cmipj(1,3) = ',cmipj(1,3)
	    endif
	endif
*  #] check input:
*  #[ get determinants, roots, ieps:
*
	if ( lsmug ) then
	    del3 = (- DBLE(xpi(1))*DBLE(cmipj(2,2))**2
     +		    - DBLE(xpi(2))*DBLE(cmipj(1,3))**2
     +		    + 2*DBLE(piDpj(1,2))*DBLE(cmipj(2,2))*
     +				DBLE(cmipj(1,3)) )/4
	    if ( nschem .ge. 3 ) then
		cel3 = (- DBLE(xpi(1))*cmipj(2,2)**2
     +			- DBLE(xpi(2))*cmipj(1,3)**2
     +			+ 2*DBLE(piDpj(1,2))*cmipj(2,2)*cmipj(1,3) )/4
	    else
		cel3 = DBLE(del3)
	    endif
	    if ( lwrite ) print *,'cel3 = ',cel3
	endif
	del2 = -sdel2i**2
*
*	the routine as it stands can not handle sdel2<0.
*	the simplest solution seems to be to switch to sdel2>0 for
*	the time being - we calculate a complete 3point function so it
*	should not be a problem (just a sign).  Of course this spoils a
*	good check on the correctness.
*
	sdel2 = abs(sdel2i)
	if ( sdel2i .gt. 0 .and. lwrite ) print *,
     +		'ffxc0j: cannot handle sdel2>0, switched to sdel2<0'
*
	if ( xpi(4).eq.0 ) then
	    zm = xpi(2)/dpipj(2,1)
	    zm1 = -xpi(1)/dpipj(2,1)
	else
	    call ffroot(zm,zp,xpi(4),piDpj(4,2),xpi(2),sdel2,ier)
	    if ( dpipj(1,2) .ne. 0 ) then
		call ffroot(zp1,zm1,xpi(4),-piDpj(4,1),xpi(1),sdel2,ier)
	    else
		zm1 = zp
		zp1 = zm
	    endif
	endif
	if ( lwrite ) then
	    print *,'ffxc0j: found roots:'
	    print *,'  zm = ',zm,zm1
	    if ( xpi(4).ne.0 ) print *,'  zp = ',zp,zp1
	endif
	if ( ltest ) then
	    xheck = zm + zm1 - 1
	    if ( xloss*abs(xheck) .gt. precx*max(x1,abs(zm)) ) print *,
     +		'ffxc0j: zm + zm1 <> 1: ',zm,zm1,xheck
	    if ( xpi(4).ne.0 ) then
		xheck = zp + zp1 - 1
		if ( xloss*abs(xheck) .gt. precx*max(x1,abs(zp)) )
     +		    print *,'ffxc0j: zp + zp1 <> 1: ',zp,zp1,xheck
	    endif
	endif

*	imag sign ok 30-oct-1989
	ieps = -1
	if ( xpi(4).ne.0 ) dyzp = -2*sdel2/xpi(4)
*
*  #] get determinants, roots, ieps:
*  #[ the finite+divergent S1:
*
	if ( xpi(4).ne.0 ) then
	    call ffcxr(cs(1),ipi12,zm,zm1,zp,zp1,dyzp,
     +		.FALSE.,x0,x0,x0,.FALSE.,dum,ieps,ier)
	endif
*
*	Next the divergent piece
*
	if ( .not.lsmug ) then
*
*	    Here we dropped the term log(lam/delta)*log(-zm/zm1)
*
	    if ( abs(zm1) .gt. 1/xloss ) then
		clog1 = dfflo1(1/zm1,ier)
	    else
		clog1 = zxfflg(-zm/zm1,-2,x0,ier)
	    endif
	    hulp = zm*zm1*4*del2/delta**2
*	    
*	    14-jan-1994: do not count when this is small, this was 
*	    meant to be so by the user carefully adjusting delta
*	    
	    ier0 = ier
	    clog2 = zxfflg(hulp,2,x0,ier0)
	    cs(8) = -clog1*clog2/2
	    if ( lwrite ) then
*		print *,'arg1 = ',-zm/zm1,1/zm1
		print *,'log1 = ',clog1
*		print *,'arg2 = ',hulp
		print *,'log2 = ',clog2
		print *,'cs(8)= ',cs(8)
	    endif
	else
*
*	    checked 4-aug-1992, but found Yet Another Bug 30-sep-1992
*
	    cdyzm = cel3*DBLE(1/(-2*sdel2*del2))
	     dyzm = del3/(-2*sdel2*del2)
	    carg1 = +cdyzm*DBLE(1/zm)
	     arg1 = +dyzm/zm
	    clog1 = zfflog(-carg1,+ieps,DCMPLX(DBLE(zm),DBLE(0)),ier)
	    if (DIMAG(cdyzm) .lt. 0 .and. arg1 .gt. 0 ) then
		clog1 = clog1 - c2ipi
		if ( lwrite ) then
		    print *,'added -2*pi*i to log1 S1'
		    print *,' arg1,zm = ',arg1,zm
		    print *,'carg1    = ',carg1
		endif
*		ier = ier + 50
	    endif
	    cs(8) = -clog1**2/2
	    carg2 = -cdyzm*DBLE(1/zm1)
	     arg2 = -dyzm/zm1
	    clog2 = zfflog(-carg2,ieps,DCMPLX(DBLE(-zm1),DBLE(0)),ier)
	    if ( DIMAG(cdyzm) .lt. 0 .and. arg2 .gt. 0 ) then
		clog2 = clog2 + c2ipi
		if ( lwrite ) then
		    print *,'added +2*pi*i to log2 S1'
		    print *,' arg2,zm = ',arg2,zm
		    print *,'carg2    = ',carg2
		endif
	    endif
	    cs(9) = +clog2**2/2
	    if ( lwrite ) then
		print *,'y=zm = ',zm,zm1
		if ( xpi(4).ne.0 ) print *,'  zp = ',zp,zp1
		print *,'cdyzm= ',cdyzm
		print *,'arg1 = ',1/carg1
		print *,'log1 = ',clog1
		print *,'cs(8)= ',cs(8)
		print *,'arg2 = ',1/carg2
		print *,'log2 = ',clog2
		print *,'cs(9)= ',cs(9)
		print *,'ipi12= ',ipi12
		print *,'S1   = ',cs(1)+cs(2)+cs(3)+cs(4)+cs(5)+cs(6)+
     +			cs(7)+cs(8)+cs(9)+ipi12*DBLE(pi12)
		print *,' '
	    endif
	endif
*  #] the finite+divergent S1:
*  #[ log(1) for npoin=4:
	if ( npoin .eq. 4 ) then
	    if ( ilogi(1) .eq. -999 ) then
		if ( .not.lsmug ) then
		    hulp = xpi(4)*delta/(4*del2)
		    ier0 = ier
		    clogi(1) = -zxfflg(abs(hulp),0,x0,ier0)
		    if ( hulp .lt. 0 ) then
			if ( xpi(4) .gt. 0 ) then
			    ilogi(1) = -1
			else
			    ilogi(1) = +1
			endif
			if ( ltest ) then
			    print *,'ffxc0j: I am not 100% sure of the',
     +				' terms pi^2, please check against the',
     +				' limit lam->0 (id=',id,')'
			    ier = ier + 50
			endif
		    else
			ilogi(1) = 0
		    endif
		else
		    if ( xpi(4).eq.0 ) then
			print *,'ffxc0i: cannot handle t=0 yet, sorry'
			print *,'Please regularize with a small mass'
			stop
		    endif
		    chulp = -cdyzm*DBLE(1/dyzp)
		    chulp1 = 1+chulp
		    if ( absc(chulp1) .lt. xloss )
     +			call ffwarn(129,ier,absc(chulp1),x1)
		    call ffxclg(clogi(1),ilogi(1),chulp,chulp1,dyzp,
     +			ier)
		endif
	    endif
	endif
*  #] log(1) for npoin=4:
*  #[ the log(lam) Si:
	if ( .not.lsmug ) then
*
*	    Next the divergent S_i (easy).
*	    The term -2*log(lam/delta)*log(xpi(2)/xpi(1)) has been discarded
*	    with lam the photon mass (regulator).
*	    If delta = sqrt(xpi(1)*xpi(2)) the terms cancel as well
*
	    if ( dpipj(1,2).ne.0 .and. xloss*abs(xpi(1)*xpi(2)-delta**2)
     +	    		.gt.precx*delta**2 ) then
		if ( xpi(1) .ne. delta ) then
		    ier0 = ier
		    cs(9) = -zxfflg(xpi(1)/delta,0,x0,ier0)**2 /4
		endif
		if ( xpi(2) .ne. delta ) then
		    ier0 = ier
		    cs(10) = zxfflg(xpi(2)/delta,0,x0,ier0)**2 /4
		endif
	    endif
	    if ( lwrite ) then
		print *,'cs(9)= ',cs(9)
		print *,'cs(10)=',cs(10)
	    endif
*  #] the log(lam) Si:
*  #[ the logs for A_i<0:
	    if ( npoin.eq.4 ) then
		clogi(2) = 0
		ilogi(2) = 0
		clogi(3) = 0
		ilogi(3) = 0
	    endif
*  #] the logs for A_i<0:
*  #[ the off-shell S3:
	else
*
*	    the divergent terms in the offshell regulator scheme - not
*	    quite as easy
*	    wm = p3.p2/sqrtdel - 1 = -s1.s2/sqrtdel - 1
*	    wp = p3.p2/sqrtdel + 1 = -s1.s2/sqrtdel + 1
*	    Note that we took the choice sdel2<0 in S1 when
*	    \delta^{p1 s2}_{p1 p2} < 0 by using yp=zm
*
	    wm = -1 - piDpj(1,2)/sdel2
	    wp = wm + 2
	    if ( lwrite ) print *,'wm,wp = ',wm,wp
	    if ( abs(wm) .lt. abs(wp) ) then
		wm = -xpi(5)*xpi(6)/(del2*wp)
		if ( lwrite ) print *,'wm+   = ',wm
	    else
		wp = -xpi(5)*xpi(6)/(del2*wm)
		if ( lwrite ) print *,'wp+   = ',wp
	    endif
*
*	    the im sign
*
	    if ( -DBLE(cmipj(1,3)) .gt. 0 ) then
		ieps = -1
	    else
		ieps = +1
	    endif
*
	    if ( nschem .lt. 3 .or. DIMAG(cmipj(1,3)).eq.0 .and.
     +			DIMAG(cmipj(2,2)).eq.0 ) then
*  #[		real case:
		if ( lwrite ) print *,'ffxc0i: Real S3'
*
*		first z-,z+
*
		dyzp = -DBLE(cmipj(1,3))*DBLE(wm)/(2*DBLE(xpi(6))) -
     +			DBLE(cmipj(2,2))/(2*DBLE(sdel2))
		dyzm = -DBLE(cmipj(1,3))*DBLE(wp)/(2*DBLE(xpi(6))) -
     +			DBLE(cmipj(2,2))/(2*DBLE(sdel2))
*
*		the (di)logs
*
		clog1 = zxfflg(-dyzp,-ieps,x1,ier)
		cs(10) = -clog1**2/2
		ipi12 = ipi12 - 4
		clog2 = zxfflg(-dyzm,+ieps,x1,ier)
		cs(11) = -clog2**2/2
		ipi12 = ipi12 - 2
		hulp = dyzp/dyzm
		if ( dyzp .lt. 0 ) then
		    ieps1 = -ieps
		else
		    ieps1 = +ieps
		endif
		call ffzxdl(cli,i,cdum(1),hulp,+ieps1,ier)
		cs(12) = -cli
		ipi12 = ipi12 - i
*
*		the log for npoin=4
*
		if ( npoin.eq.4 ) then
		    if ( ilogi(3) .eq. -999 ) then
			if ( DBLE(cmipj(1,3)) .eq. 0 ) then
			    chulp = -1
			    chulp1 = 0
			elseif ( dyzp .lt. dyzm ) then
			    chulp = -dyzm/dyzp
			    chulp1 = +DBLE(cmipj(1,3))/DBLE(xpi(6)*dyzp)
			else
			    chulp = -dyzp/dyzm
			    chulp1 = -DBLE(cmipj(1,3))/DBLE(xpi(6)*dyzm)
			endif
			call ffxclg(clogi(3),ilogi(3),chulp,chulp1,dyzp,
     +				ier)
		    endif
		endif
*
*		and some debug output:
*
		if ( lwrite ) then
		    print *,'z      = 1,0'
		    print *,'y-zm   = ',dyzm
		    print *,'y-zp   = ',dyzp
		    print *,'+Li2(y/(y-zp))    = ',cs(10)
		    print *,'+Li2(y/(y-zm))    = ',cs(11)
		    print *,'-Li2((y-1)/(y-zm))= ',cs(12)
		    print *,'ipi12   = ',ipi12
		endif
*  #]		real case:
	    else
*  #[		complex case:
		if ( lwrite ) print *,'ffxc0i: Complex S3'
*
*		first z+
*
		cdyzp = -cmipj(1,3)*DBLE(wm)/(2*DBLE(xpi(6))) -
     +			cmipj(2,2)/(2*DBLE(sdel2))
		clog1 = zfflog(-cdyzp,-ieps,c1,ier)
		if ( ieps*DIMAG(cdyzp).lt.0.and.DBLE(cdyzp).gt.0 ) then
		    if ( lwrite ) then
			print *,'added ',-ieps,'*2*pi*i to log1 S3'
			print *,'carg1    = ',-cdyzp
			print *,'clog1 was  ',clog1
			print *,'clog1 is   ',clog1 - ieps*c2ipi
		    endif
		    clog1 = clog1 - ieps*c2ipi
		else
		    if ( lwrite ) then
			print *,'carg1    = ',-cdyzp
			print *,'clog1 is   ',clog2
		    endif
		endif
		cs(10) = -clog1**2/2
		ipi12 = ipi12 - 4
*
*		now z-
*
		cdyzm = -cmipj(1,3)*DBLE(wp)/(2*DBLE(xpi(6))) -
     +			cmipj(2,2)/(2*DBLE(sdel2))
		clog2 = zfflog(-cdyzm,+ieps,c1,ier)
		if ( ieps*DIMAG(cdyzm).gt.0.and.DBLE(cdyzm).gt.0 ) then
		    if ( lwrite ) then
			print *,'added ',ieps,'*2*pi*i to log2 S3'
			print *,'carg2    = ',-cdyzm
			print *,'clog2 was  ',clog2
			print *,'clog2 is   ',clog2 + ieps*c2ipi
		    endif
		    clog2 = clog2 + ieps*c2ipi
*		    ier = ier + 50
		else
		    if ( lwrite ) then
			print *,'carg2    = ',-cdyzm
			print *,'clog2 is   ',clog2
		    endif
		endif
		cs(11) = -clog2**2/2
		ipi12 = ipi12 - 2
*
*		the dilog
*
		chulp = cdyzp/cdyzm
		hulp = DBLE(cdyzp)/DBLE(cdyzm)
		if ( DBLE(cdyzp) .lt. 0 ) then
		    ieps1 = -ieps
		else
		    ieps1 = +ieps
		endif
		if ( DIMAG(chulp) .eq. 0 ) then
		    hulp = DBLE(chulp)
		    call ffzxdl(cli,i,cdum(1),hulp,+ieps1,ier)
		else
		    call ffzzdl(cli,i,cdum(1),chulp,ier)
		    if ( hulp.gt.1 .and. ieps1*DIMAG(chulp).lt.0 ) then
			if ( lwrite ) then
			    print *,'addded 2ipi*log(z) to Li'
			    print *,'chulp = ',chulp
			    print *,'cli was ',cli
			    print *,'cli is  ',cli +
     +				ieps1*c2ipi*zfflog(chulp,0,c0,ier)
			    call ffzxdl(cdum(2),i,cdum(1),hulp,+ieps1,
     +				ier)
			    print *,'vgl   ',cdum(2)
			endif
			cli = cli + ieps1*c2ipi*zfflog(chulp,0,c0,ier)
		    endif
		endif
		cs(12) = -cli
		ipi12 = ipi12 - i
*
*		the log for npoin=4
*
		if ( npoin.eq.4 ) then
		    if ( ilogi(3) .eq. -999 ) then
			if ( cmipj(1,3) .eq. 0 ) then
			    chulp = -1
			    chulp1 = 0
			elseif ( DBLE(cdyzp) .lt. DBLE(cdyzm) ) then
			    chulp = -cdyzm/cdyzp
			    chulp1 = +cmipj(1,3)/cdyzp*DBLE(1/xpi(6))
			else
			    chulp = -cdyzp/cdyzm
			    chulp1 = -cmipj(1,3)/cdyzm*DBLE(1/xpi(6))
			endif
			dyzp = DBLE(cdyzp)
			call ffxclg(clogi(3),ilogi(3),chulp,chulp1,dyzp,
     +				ier)
		    endif
		endif
*
*		and some debug output:
*
		if ( lwrite ) then
		    print *,'z      = 1,0'
		    print *,'y-zm   = ',cdyzm
		    print *,'y-zp   = ',cdyzp
		    print *,'+Li2(y/(y-zp))    = ',cs(10)
		    print *,'+Li2(y/(y-zm))    = ',cs(11)
		    print *,'-Li2((y-1)/(y-zm))= ',cs(12)
		    print *,'ipi12   = ',ipi12
		endif
*  #]		complex case:
	    endif
*  #] the off-shell S3:
*  #[ the off-shell S2:
*
*	    the im sign
*
	    if ( -DBLE(cmipj(2,2)) .gt. 0 ) then
		ieps = -1
	    else
		ieps = +1
	    endif
*
	    if ( nschem .lt. 3 ) then
*  #[		real case:
		if ( lwrite ) print *,'ffxc0i: Real S2'
*
*		first z-
*
		dyzm = -DBLE(cmipj(2,2))*DBLE(wp)/(2*DBLE(xpi(5))) -
     +			DBLE(cmipj(1,3))/(2*DBLE(sdel2))
		clog1 = zxfflg(+dyzm,-ieps,x1,ier)
		cs(13) = +clog1**2/2
		ipi12 = ipi12 + 4
*
*		now z+
*
		dyzp = -DBLE(cmipj(2,2))*DBLE(wm)/(2*DBLE(xpi(5))) -
     +			DBLE(cmipj(1,3))/(2*DBLE(sdel2))
		clog2 = zxfflg(+dyzp,+ieps,x1,ier)
		cs(14) = +clog2**2/2
		ipi12 = ipi12 + 2
		hulp = dyzm/dyzp
		if ( dyzm .lt. 0 ) then
		    ieps1 = -ieps
		else
		    ieps1 = +ieps
		endif
		call ffzxdl(cli,i,cdum(1),hulp,-ieps1,ier)
		cs(15) = +cli
		ipi12 = ipi12 + i
*
*		the log for npoin=4
*
		if ( npoin.eq.4 ) then
		    if ( ilogi(2) .eq. -999 ) then
			if ( DBLE(cmipj(2,2)) .eq. 0 ) then
			    chulp = -1
			    chulp1 = 0
			elseif ( dyzp .lt. dyzm ) then
			    chulp = -dyzm/dyzp
			    chulp1 = +DBLE(cmipj(2,2))/DBLE(xpi(5)*dyzp)
			elseif ( dyzp .gt. dyzm ) then
			    chulp = -dyzp/dyzm
			    chulp1 = -DBLE(cmipj(2,2))/DBLE(xpi(5)*dyzm)
			endif
			call ffxclg(clogi(2),ilogi(2),chulp,chulp1,dyzp,
     +				ier)
		    endif
		endif
*
*		and some debug output:
*
		if ( lwrite ) then
		    print *,'z      = 0,1'
		    print *,'y-zm   = ',dyzm
		    print *,'y-zp   = ',dyzp
		    print *,'-Li2((y-1)/(y-zm))= ',cs(13)
		    print *,'-Li2((y-1)/(y-zp))= ',cs(14)
		    print *,'+Li2(y/(y-zp))    = ',cs(15)
		    print *,'ipi12   = ',ipi12
		endif
*  #]		real case:
	    else
*  #[		complex case:
		if ( lwrite ) print *,'ffxc0i: Complex S2'
*
*		first z-
*
		cdyzm = -cmipj(2,2)*DBLE(wp)/(2*DBLE(xpi(5))) -
     +			cmipj(1,3)/(2*DBLE(sdel2))
		clog1 = zfflog(+cdyzm,-ieps,c1,ier)
		if ( DBLE(cdyzm).lt.0.and.ieps*DIMAG(cdyzm).gt.0 ) then
		    if ( lwrite ) print *,'added 2*i*pi to log1'
		    clog1 = clog1 - ieps*c2ipi
		endif
		cs(13) = +clog1**2/2
		ipi12 = ipi12 + 4
*
*		now z+
*
		cdyzp = -cmipj(2,2)*DBLE(wm)/(2*DBLE(xpi(5))) -
     +			cmipj(1,3)/(2*DBLE(sdel2))
		clog2 = zfflog(+cdyzp,+ieps,c1,ier)
		if ( DBLE(cdyzp).lt.0.and.ieps*DIMAG(cdyzp).lt.0 ) then
		    if ( lwrite ) then
			print *,'added ',ieps,'*2*pi*i to log2 S2'
			print *,'carg1    = ',+cdyzp
		    endif
		    clog2 = clog2 + ieps*c2ipi
		endif
		cs(14) = +clog2**2/2
		ipi12 = ipi12 + 2
*		
*		and ghe dilog
*		
		chulp = cdyzm/cdyzp
		hulp = DBLE(dyzm)/DBLE(dyzp)
		if ( DBLE(cdyzm) .lt. 0 ) then
		    ieps1 = -ieps
		else
		    ieps1 = +ieps
		endif
		if ( DIMAG(chulp ) .eq. 0 ) then
		    hulp = DBLE(chulp)
		    call ffzxdl(cli,i,cdum(1),hulp,-ieps1,ier)
		else
		    call ffzzdl(cli,i,cdum(1),chulp,ier)
		    if ( hulp.gt.1 .and. ieps1*DIMAG(chulp).gt.0 ) then
			if ( lwrite ) then
			    print *,'addded 2ipi*log(z) to Li'
			    print *,'chulp = ',chulp
			    print *,'cli was ',cli
			    print *,'cli is  ',cli -
     +				ieps1*c2ipi*zfflog(chulp,0,c0,ier)
			    call ffzxdl(cdum(2),i,cdum(1),hulp,-ieps1,
     +				ier)
			    print *,'vgl   ',cdum(2)
			endif
			cli = cli - ieps1*c2ipi*zfflog(chulp,0,c0,ier)
		    endif
		endif
		cs(15) = +cli
		ipi12 = ipi12 + i
*
*		the log for npoin=4
*
		if ( npoin.eq.4 ) then
		    if ( ilogi(2) .eq. -999 ) then
			if ( cmipj(2,2) .eq. 0 ) then
			    chulp = -1
			    chulp1 = 0
			elseif ( DBLE(cdyzp) .lt. DBLE(cdyzm) ) then
			    chulp = -cdyzm/cdyzp
			    chulp1 = +cmipj(2,2)/cdyzp*DBLE(1/xpi(5))
			elseif ( DBLE(cdyzp) .gt. DBLE(cdyzm) ) then
			    chulp = -cdyzp/cdyzm
			    chulp1 = -cmipj(2,2)/cdyzm*DBLE(1/xpi(5))
			endif
			dyzp = DBLE(cdyzp)
			call ffxclg(clogi(2),ilogi(2),chulp,chulp1,dyzp,
     +				ier)
		    endif
		endif
*
*		and some debug output:
*
		if ( lwrite ) then
		    print *,'z      = 0,1'
		    print *,'y-zm   = ',cdyzm
		    print *,'y-zp   = ',cdyzp
		    print *,'-Li2((y-1)/(y-zm))= ',cs(13)
		    print *,'-Li2((y-1)/(y-zp))= ',cs(14)
		    print *,'+Li2(y/(y-zp))    = ',cs(15)
		    print *,'ipi12   = ',ipi12
		endif
*  #]		complex case:
	    endif
	endif
*  #] the off-shell S2:
*  #[ sdel2<0!:
	if ( sdel2i .gt. 0 ) then
	    if ( .not.lsmug ) then
		n = 10
	    else
		n = 15
	    endif
	    do 10 i=1,n
		cs(i) = -cs(i)
   10	    continue
	    ipi12 = -ipi12
	    do 20 i=1,3
		ilogi(i) = -ilogi(i)
		clogi(i) = -clogi(i)
   20	    continue
	endif
	if ( lwrite ) print '(a)','  ##] ffxc0j:'
*  #] sdel2<0!:
*###] ffxc0j:
	end
*###[ ffxclg:
	subroutine ffxclg(clg,ilg,chulp,chulp1,dyzp,ier)
***#[*comment:***********************************************************
*									*
*	compute the extra logs for npoin=4 given chulp=-cdyzm/cdyzp	*
*	all flagchecking has already been done.				*
*									*
*	Input:	chulp	(complex)	see above			*
*		chulp1	(complex)	1+chulp (in case chulp ~ -1)	*
*		dyzp	(real)		(real part of) y-z+ for im part	*
*	Output:	clg	(complex)	the log				*
*		ilg	(integer)	factor i*pi split off clg	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ilg,ier
	DOUBLE PRECISION dyzp
	DOUBLE COMPLEX clg,chulp,chulp1
*
*	local variables
*
	DOUBLE PRECISION hulp,hulp1,dfflo1
	DOUBLE COMPLEX zxfflg,zfflog,zfflo1,check
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ check:
	if ( ltest ) then
	    check = c1 + chulp - chulp1
	    if ( xloss*abs(check) .gt. precc*max(abs(c1),abs(chulp)) )
     +		print *,'ffxclg: error: chulp1 != 1+chulp: ',chulp1,
     +		c1+chulp,check
	endif
*  #] check:
*  #[ work:
*
	if ( DIMAG(chulp) .eq. 0 ) then
	    hulp = DBLE(chulp)
	    hulp1 = DBLE(chulp1)
	    if ( abs(hulp1) .lt. xloss ) then
		clg = DBLE(dfflo1(hulp1,ier))
	    else
		clg = zxfflg(abs(hulp),0,x0,ier)
	    endif
	    if ( hulp .lt. 0 ) then
		if ( dyzp.lt.0 ) then
		    ilg = +1
		else
		    ilg = -1
		endif
	    else
		ilg = 0
	    endif
	    if ( lwrite ) print *,'clg(real) = ',clg+c2ipi*ilg/2
	else
*
*	    may have to be improved
*
	    if ( abs(DBLE(chulp1))+abs(DIMAG(chulp1)) .lt. xloss ) then
		clg = zfflo1(chulp1,ier)
	    else
		clg = zfflog(chulp,0,c0,ier)
	    endif
	    ilg = 0
	    if ( DBLE(chulp) .lt. 0 ) then
		if ( dyzp.lt.0 .and. DIMAG(clg).lt.0 ) then
		    if ( lwrite ) print *,'ffxclg: added -2*pi to log'
		    ilg = +2
		elseif ( dyzp.gt.0 .and. DIMAG(clg).gt.0 ) then
		    if ( lwrite ) print *,'ffxclg: added +2*pi to log'
		    ilg = -2
		endif
	    endif
	    if ( lwrite ) print *,'clg(cmplx)= ',clg+c2ipi*ilg/2
	endif
*  #] work:
*###] ffxclg:
	end
*###[ ffxc0p:
	subroutine ffxc0p(cs3,ipi12,isoort,clogi,ilogi,xpi,dpipj,piDpj,
     +		sdel2,del2s,etalam,etami,delpsi,alph,npoin,ier)
***#[*comment:***********************************************************
*									*
*	DOUBLE PRECISIONLY calculates the threepoint function closely following	*
*	recipe in 't Hooft & Veltman, NP B(183) 1979.			*
*	Bjorken and Drell metric is used nowadays!			*
*									*
*	    p2	^ |							*
*		| |							*
*		 / \							*
*	      m2/   \m3							*
*	p1     /     \	p3						*
*	<-    /  m1   \ ->						*
*	------------------------					*
*									*
*	Input:	xpi(1-3)     (real)	pi squared			*
*		xpi(4-6)     (real)	internal mass squared		*
*		dpipj(6,6)   (real)	xpi(i)-xpi(j)			*
*		piDpj(6,6)   (real)	pi(i).pi(j)			*
*		sdel2	     (real)	sqrt(delta_{p_1 p_2}^{p_1 p_2})	*
*		del2s(3)     (real)	delta_{p_i s_i}^{p_i s_i}	*
*		etalam	     (real)	delta_{s_1 s_2 s_3}^{s_1 s_2 s_3}
*					  /delta_{p_1 p_2}^{p_1 p_2}	*
*		etami(6)     (real)	m_i^2 - etalam			*
*		alph(3)	     (real)	alph(1)=alpha, alph(3)=1-alpha	*
*									*
*	Output: cs3(80)	     (complex)	C0, not yet summed.		*
*		ipi12(3)     (integer)	factors pi^2/12, not yet summed	*
*		slam	     (complex)	lambda(p1,p2,p3).		*
*		isoort(8)    (integer)	indication of he method used	*
*		clogi(3)     (complex)	log(-dyz(2,1,i)/dyz(2,2,i))	*
*		ilogi(3)     (integer)	factors i*pi in this		*
*		ier	     (integer)	number of digits inaccurate in	*
*					answer				*
*									*
*	Calls:	ffdel3,ffdel3m,ffroot,ffxxyz,ffcxyz,ffdwz,ffcdwz,	*
*		ffcxs3,ffcs3,ffcxs4,ffcs4				*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ipi12(8),isoort(8),ilogi(3),npoin,ier
	DOUBLE COMPLEX cs3(80),clogi(3)
	DOUBLE PRECISION xpi(6),dpipj(6,6),piDpj(6,6),sdel2,del2s(3),
     +		etalam,etami(6),delpsi(3),alph(3)
*
*	local variables:
*
	integer i,j,k,m,ip,jsoort(8),ierw,iw,ier0,ier1,irota,
     +		ilogip(3)
	logical l4,lcompl,lcpi,l4pos
	DOUBLE COMPLEX c,cs,calph(3),csdl2i(3),csdel2
	DOUBLE COMPLEX cy(4,3),cz(4,3),cw(4,3),cdyz(2,2,3),cdwy(2,2,3),
     +		cdwz(2,2,3),cd2yzz(3),cd2yww(3)
	DOUBLE COMPLEX cpi(6),cdpipj(6,6),cpiDpj(6,6),cetami(6),
     +		clogip(3)
	DOUBLE PRECISION y(4,3),z(4,3),w(4,3),dyz(2,2,3),dwy(2,2,3),
     +		dwz(2,2,3),d2yzz(3),d2yww(3),dy2z(4,3)
	DOUBLE PRECISION sdel2i(3),s1,s2
	DOUBLE PRECISION absc,s,xqi(6),dqiqj(6,6),qiDqj(6,6)
	DOUBLE PRECISION dfflo1
	DOUBLE COMPLEX zxfflg,zfflog
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    call ffxhck(xpi,dpipj,6,ier)
	endif
*  #] check input:
*  #[ IR case:
*
*	but only the off-shell regulator case - the log(lam) has been
*	caught before
*
	if ( lsmug ) then
	    do 5 i=1,3
		if ( xpi(i) .eq. 0 ) then
		    j = mod(i,3)+1
		    k = mod(j,3)+1
		    if ( piDpj(i,j).eq.0 .and. piDpj(i,k).eq.0 ) then
			call ffrot3(irota,xqi,dqiqj,qiDqj,
     +				xpi,dpipj,piDpj,6,3,4,ier)
			if ( lwrite ) print *,'ffxc0p: rotated over ',
     +				irota
			if ( npoin.eq.4 ) call ffrt3p(clogip,ilogip,
     +				irota,clogi,ilogi,+1)
			call ffxc0j(cs3(1),ipi12(1),sdel2,clogip,ilogip,
     +				xqi,dqiqj,qiDqj,x0,4,ier)
			if ( npoin.eq.4 ) call ffrt3p(clogi,ilogi,irota,
     +				clogip,ilogip,-1)
			return
		    endif
		endif
    5	    continue
	endif
*  #] IR case:
*  #[ get roots etc:
*  #[   get z-roots:
*	if ( npoin .eq. 3 ) then
	    l4pos = l4also
*	else
*	    l4pos = .FALSE.
*	endif
	lcompl = .FALSE.
	if ( lwrite ) print '(a)','  ##[ get roots:'
	ier1 = ier
	do 10 i=1,3
*
*	get roots (y,z,w) and flag what to do: 0=nothing, 1=normal,
*	-1=complex
*
	    ip = i+3
*	    first get the roots
	    ier0 = ier
	    if ( del2s(i) .le. 0 ) then
*		real case
		sdel2i(i) = sqrt(-del2s(i))
		csdl2i(i) = sdel2i(i)
*		then handle the special case Si = 0
		if ( xpi(ip) .eq. 0 ) then
		    if ( i .eq. 1 .and. alph(3) .eq. 0 .or.
     +			 i .eq. 3 .and. alph(1) .eq. 0 ) then
			isoort(2*i-1) = 0
			isoort(2*i) = 0
			l4pos = .FALSE.
			goto 10
		    endif
		endif
		call ffxxyz(y(1,i),z(1,i),dyz(1,1,i),d2yzz(i),dy2z(1,i),
     +			i,sdel2,sdel2i(i),etalam,etami,delpsi(i),xpi,
     +			dpipj,piDpj,isoort(2*i-1),.FALSE.,6,ier0)
	    else
*		complex case
		sdel2i(i) = sqrt(del2s(i))
		csdl2i(i) = DCMPLX(x0,sdel2i(i))
		lcompl = .TRUE.
		call ffcxyz(cy(1,i),cz(1,i),cdyz(1,1,i),cd2yzz(i),i,
     +			sdel2,sdel2i(i),etalam,etami,delpsi(i),xpi,
     +			piDpj,isoort(2*i-1),.FALSE.,6,ier0)
	    endif
	    ier1 = max(ier1,ier0)
   10	continue
	ier = ier1
*  #]   get z-roots:
*  #[   get w-roots:
*
*	get w's:
*
	ierw = ier
	l4 = .FALSE.
	lcpi = .FALSE.
	if ( isoort(4) .eq. 0 ) then
*	    no error message; just bail out
	    ierw = ierw + 100
	    goto 90
	endif
	do 70 iw = 1,3,2
	if ( .not. l4pos .or. alph(4-iw) .eq. 0 ) then
	    jsoort(2*iw-1) = 0
	    jsoort(2*iw) = 0
	    l4pos = .FALSE.
	else
	if ( isoort(4) .gt. 0 .and. isoort(2*iw) .ge. 0 ) then
	    jsoort(2*iw-1) = 1
	    jsoort(2*iw) = 1
	    d2yww(iw) = -d2yzz(2)/alph(4-iw)
	    do 20 j=1,2
		w(j+iw-1,iw) = z(j+3-iw,2)/alph(4-iw)
		w(j+3-iw,iw) = 1 - w(j+iw-1,iw)
		if ( abs(w(j+3-iw,iw)) .lt. xloss ) then
		    if ( lwrite ) print *,'   w(',j+3-iw,iw,')  = ',
     +			w(j+3-iw,iw),x1
		    s = z(j+iw-1,2) - alph(iw)
		    if ( abs(s) .lt. xloss*alph(iw) ) then
			ierw = ierw + 15
			goto 70
		    endif
		    w(j+3-iw,iw) = s/alph(4-iw)
		    if ( lwrite ) print *,'   w(',j+3-iw,iw,')+ = ',
     +			w(j+3-iw,iw),abs(alph(iw)/alph(4-iw))
		endif
		dwy(j,2,iw) = dyz(2,j,2)/alph(4-iw)
		do 15 i=1,2
		    dwz(j,i,iw) = w(j,iw) - z(i,iw)
		    if ( abs(dwz(j,i,iw)) .ge. xloss*abs(w(j,iw)) )
     +								goto 14
		    if ( lwrite ) print *,'  dwz(',j,i,iw,')  = ',
     +			dwz(j,i,iw),abs(w(j,iw))
		    dwz(j,i,iw) = z(i+2,iw) - w(j+2,iw)
		    if ( lwrite ) print *,'  dwz(',j,i,iw,')+ = ',
     +			dwz(j,i,iw),abs(w(j+2,iw))
		    if ( abs(dwz(j,i,iw)) .ge. xloss*abs(w(j+2,iw)) )
     +								goto 14
		    dwz(j,i,iw) = dwy(j,2,iw) + dyz(2,i,iw)
		    if ( lwrite ) print *,'  dwz(',j,i,iw,')++= ',
     +			dwz(j,i,iw),abs(dwy(j,2,iw))
		    if ( abs(dwz(j,i,iw)) .ge. xloss*abs(dwy(j,2,iw)) )
     +								goto 14
		    l4 = .TRUE.
		    call ffdwz(dwz(1,1,iw),w(1,iw),z(1,iw),j,i,iw,
     +			alph(1),alph(3),xpi,dpipj,piDpj,sdel2i,6,ierw)
   14		    continue
   15		continue
   20	    continue
	else
*	    convert to complex ...
	    jsoort(2*iw-1) = -10
	    jsoort(2*iw) = -10
	    if ( isoort(4).ge.0 .and. (iw.eq.1 .or. isoort(2).ge.0) )
     +								then
		cd2yzz(2) = d2yzz(2)
		do 21 i=1,4
		    cy(i,2) = y(i,2)
		    cz(i,2) = z(i,2)
   21		continue
		do 23 i=1,2
		    do 22 j=1,2
			cdyz(j,i,2) = dyz(j,i,2)
   22		    continue
   23		continue
	    endif
	    if ( isoort(2*iw) .ge. 0 ) then
		cd2yzz(iw) = d2yzz(iw)
		do 24 i=1,4
		    cy(i,iw) = y(i,iw)
		    cz(i,iw) = z(i,iw)
   24		continue
		do 26 i=1,2
		    do 25 j=1,2
			cdyz(j,i,iw) = dyz(j,i,iw)
   25		    continue
   26		continue
	    endif
	    cd2yww(iw) = -cd2yzz(2)/DBLE(alph(4-iw))
	    do 30 j=1,2
		cw(j+iw-1,iw) = cz(j+3-iw,2)/DBLE(alph(4-iw))
		cw(j+3-iw,iw) = 1 - cw(j+iw-1,iw)
		if ( absc(cw(j+3-iw,iw)) .lt. xloss ) then
		    if (lwrite) print *,'   cw(',j+3-iw,iw,')  = ',
     +			cw(j+3-iw,iw),x1
		    cs = cz(j+iw-1,2) - DBLE(alph(iw))
		    if ( absc(cs) .lt. xloss*alph(iw) ) ierw = ierw + 15
		    cw(j+3-iw,iw) = cs/DBLE(alph(4-iw))
		    if (lwrite) print *,'   cw(',j+3-iw,iw,')+ = ',
     +			cw(j+3-iw,iw),abs(alph(iw)/alph(4-iw))
		endif
		cdwy(j,2,iw) = cdyz(2,j,2)/DBLE(alph(4-iw))
		do 29 i=1,2
		    cdwz(j,i,iw) = cw(j,iw) - cz(i,iw)
		    if ( absc(cdwz(j,i,iw)) .ge. xloss*absc(cw(j,iw)) )
     +								goto 31
		    if ( lwrite ) print *,'  cdwz(',j,i,iw,')  = ',
     +			cdwz(j,i,iw),absc(cw(j,iw))
		    cdwz(j,i,iw) = cz(i+2,iw) - cw(j+2,iw)
		    if ( lwrite ) print *,'  cdwz(',j,i,iw,')+ = ',
     +			cdwz(j,i,iw),absc(cw(j+2,iw))
		    if ( absc(cdwz(j,i,iw)) .ge. xloss*absc(cw(j+2,iw)))
     +								goto 31
		    cdwz(j,i,iw) = cdwy(j,2,iw) + cdyz(2,i,iw)
		    if ( lwrite ) print *,'  cdwz(',j,i,iw,')++= ',
     +			cdwz(j,i,iw),absc(cdwy(j,2,iw))
		    if ( absc(cdwz(j,i,iw)).ge.xloss*absc(cdwy(j,2,iw)))
     +								goto 31
		    l4 = .TRUE.
		    if ( .not. lcpi ) then
			lcpi = .TRUE.
			calph(1) = alph(1)
			calph(3) = alph(3)
			csdel2 = sdel2
			cetami(1) = etami(1)
			cetami(3) = etami(3)
			do 28 k=1,6
			    cpi(k) = xpi(k)
			    do 27 m=1,6
				cdpipj(m,k) = dpipj(m,k)
				cpiDpj(m,k) = piDpj(m,k)
   27			    continue
   28			continue
		    endif
		    call ffcdwz(cdwz(1,1,iw),cw(1,iw),cz(1,iw),j,i,iw,
     +			calph(1),calph(3),cpi,cdpipj,cpiDpj,csdl2i,
     +			csdel2,6,ierw)
   31		    continue
   29		continue
   30	    continue
	endif
	endif
   70	continue
   90	continue
	ierw = ierw-ier
*  #]   get w-roots:
*  #[   write output:
	if ( lwrite ) then
	    print *,'ffxc0p: found roots:'
	    do 85 i=1,3
		print *,'  k = ',i
		if ( isoort(2*i) .gt. 0 ) then
		    print *,'  ym,ym1 = ',y(1,i),y(3,i),' (not used)'
		    print *,'  yp,yp1 = ',y(2,i),y(4,i)
		    print *,'  zm,zm1 = ',z(1,i),z(3,i)
		    print *,'  zp,zp1 = ',z(2,i),z(4,i)
		    if ( i .ne. 2 .and. jsoort(2*i-1) .ne. 0 ) then
			if ( isoort(4) .gt. 0 ) then
			    print *,'  wm,wm1 = ',w(1,i),w(3,i)
			    print *,'  wp,wp1 = ',w(2,i),w(4,i)
			else
			    print *,'  cwm,cwm1 = ',cw(1,i),cw(3,i)
			    print *,'  cwp,cwp1 = ',cw(2,i),cw(4,i)
			endif
		    endif
		elseif ( isoort(2*i) .eq. 0 ) then
		    if ( isoort(2*i-1) .eq. 0 ) then
			print *,'  no roots, all is zero'
		    else
			print *,'  yp,yp1 = ',y(2,i),y(4,i)
			print *,'  zp,zp1 = ',z(2,i),z(4,i)
			if ( i .ne. 2 .and. jsoort(2*i-1) .ne. 0 ) then
			    if ( isoort(4) .gt. 0 ) then
				print *,'  wm,wm1 = ',w(1,i),w(3,i)
				print *,'  wp,wp1 = ',w(2,i),w(4,i)
			    else
				print *,'  cwm,cwm1 = ',cw(1,i),cw(3,i)
				print *,'  cwp,cwp1 = ',cw(2,i),cw(4,i)
			    endif
			endif
		    endif
		else
		    print *,'  cym,cym1 = ',cy(1,i),cy(3,i),'(not used)'
		    print *,'  cyp,cyp1 = ',cy(2,i),cy(4,i)
		    print *,'  czm,czm1 = ',cz(1,i),cz(3,i)
		    print *,'  czp,czp1 = ',cz(2,i),cz(4,i)
		    if ( i .ne. 2 .and. isoort(2*i-1) .ne. 0 ) then
			print *,'  cwm,cwm1 = ',cw(1,i),cw(3,i)
			print *,'  cwp,cwp1 = ',cw(2,i),cw(4,i)
		    endif
		endif
   85	    continue
	endif
	if ( lwrite ) print '(a)','  ##] get roots:'
*  #]   write output:
*  #[   which case:
	if ( l4 ) then
	    if ( ierw .ge. 1 ) then
		l4pos = .FALSE.
	    else
		ier = ier + ierw
	    endif
	endif
*  #]   which case:
*  #] get roots etc:
*  #[ logarithms for 4point function:
	if ( npoin .eq. 4 ) then
	if ( lwrite ) print '(a)','  ##[ logarithms for Ai<0:'
	do 95 i = 1,3
	    if ( ilogi(i) .ne. -999 ) goto 95
	    if ( isoort(2*i) .gt. 0 .and.
     +				isoort(2*i-1) .ge. 0 ) then
		s1 = -dyz(2,1,i)/dyz(2,2,i)
		if ( lwrite ) then
*		    fantasize imag part, but suppress error message
		    ier0 = 0
		    clogi(i) = zxfflg(s1,1,x1,ier0)
		    print *,'clogi  = ',clogi(i)
		endif
		if ( abs(s1-1) .lt. xloss ) then
		    clogi(i) = dfflo1(d2yzz(i)/dyz(2,2,i),ier)
		    ilogi(i) = 0
		else
		    if ( abs(s1+1) .lt. xloss ) then
			clogi(i) = dfflo1(-2*sdel2i(i)/(xpi(i+3)*
     +				dyz(2,2,i)),ier)
		    else
			clogi(i) = zxfflg(abs(s1),0,x0,ier)
		    endif
		    if ( dyz(2,2,i).gt.0 .and. dyz(2,1,i).gt.0 ) then
			ilogi(i) = -1
		    elseif ( dyz(2,1,i).lt.0 .and. dyz(2,2,i).lt.0) then
			ilogi(i) = +1
		    else
			ilogi(i) = 0
		    endif
		endif
		if ( lwrite ) print *,'clogi+ = ',clogi(i)+
     +			DCMPLX(x0,pi)*ilogi(i)
	    elseif ( isoort(2*i-1) .lt. 0 ) then
*		for stability split the unit circle up in 4*pi/2
*		(this may have to be improved to 8*pi/4...)
		ier0 = 0
		if ( lwrite ) then
		    if ( abs(DBLE(cdyz(2,1,i))) .lt. xalog2 .or.
     +			abs(DIMAG(cdyz(2,2,i))) .lt. xalog2 ) then
			cs = -DCMPLX(DBLE(cdyz(2,1,i))/xalog2,DIMAG(cdyz
     +				(2,1,i))/xalog2) / DCMPLX(DBLE(cdyz(2,2,
     +				i))/xalog2,DIMAG(cdyz(2,2,i))/xalog2)
		    else
			cs = -cdyz(2,1,i)/cdyz(2,2,i)
		    endif
		    clogi(i)=zfflog(cs,0,c0,ier0)
		    print *,'clogi = ',clogi(i)
		endif
		if ( DBLE(cdyz(2,1,i)) .gt. DIMAG(cdyz(2,1,i)) ) then
		    s = 2*atan2(DIMAG(cdyz(2,1,i)),DBLE(cdyz(2,1,i)))
		    clogi(i) = DCMPLX(x0,s)
		    ilogi(i) = -1
		elseif ( DBLE(cdyz(2,1,i)) .lt. -DIMAG(cdyz(2,1,i)))
     +								then
		    if ( DIMAG(cdyz(2,1,i)) .eq. 0 ) then
			call fferr(84,ier)
		    endif
		    s = 2*atan2(-DIMAG(cdyz(2,1,i)),-DBLE(cdyz(2,1,i)))
		    clogi(i) = DCMPLX(x0,s)
		    ilogi(i) = 1
		else
		    s1 = -DBLE(cdyz(2,1,i))
		    s2 = DIMAG(cdyz(2,1,i))
		    s = 2*atan2(s1,s2)
		    clogi(i) = DCMPLX(x0,s)
		    ilogi(i) = 0
		endif
		if ( lwrite ) print *,'clogi+= ',clogi(i)+
     +			DCMPLX(x0,pi)*ilogi(i)
	    endif
	    if ( lwrite ) print *,i,': ',clogi(i),' + ',ilogi(i),'*i*pi'
   95	continue
*	An algorithm to obtain the sum of two small logarithms more
*	accurately has been put in ffcc0p, not yet here
	if ( lwrite ) print '(a)','  ##] logarithms for Ai<0:'
	endif
*  #] logarithms for 4point function:
*  #[ real case integrals:
	ier1 = ier
	if ( .not. lcompl ) then
	    if ( .not. l4 .or. .not. l4pos ) then
*		normal case
		do 100 i=1,3
		    if ( lwrite ) print '(a,i1,a)','  ##[ xs3 nr ',i,':'
		    j = 2*i-1
		    if ( isoort(j) .eq. 0 ) then
			if ( lwrite ) then
			    print *,'ffxc0p: xk=0, ma=mb/Si-0 -> S3 = 0'
			    print *,'isoort:',isoort(j),isoort(j+1)
			endif
		    else
		    	ier0 = ier
			call ffcxs3(cs3(20*i-19),ipi12(j),y(1,i),z(1,i),
     +				dyz(1,1,i),d2yzz(i),dy2z(1,i),xpi,piDpj,
     +				i,6,isoort(j),ier0)
			ier1 = max(ier1,ier0)
		    endif
		    if ( lwrite ) print '(a,i1,a)','  ##] xs3 nr ',i,':'
  100		continue
		isoort(7) = 0
		isoort(8) = 0
	    else
		do 110 i=1,3,2
		    j = 2*i-1
		    isoort(j+2) = jsoort(j)
		    isoort(j+3) = jsoort(j+1)
		    if ( lwrite ) print '(a,i1,a)','  ##[ xs4 nr ',i,':'
		    ier0 = ier
		    call ffcxs4(cs3(20*i-19),ipi12(j),w(1,i),y(1,i),
     +			z(1,i),dwy(1,1,i),dwz(1,1,i),dyz(1,1,i),
     +			d2yww(i),d2yzz(i),xpi,piDpj,i,6,isoort(j),ier0)
		    ier1 = max(ier1,ier0)
		    if ( lwrite ) print '(a,i1,a)','  ##] xs4 nr ',i,':'
  110		continue
	    endif
*  #] real case integrals:
*  #[ complex case integrals:
	else
*	    convert xpi
	    if ( .not.lcpi ) then
		cetami(1) = etami(1)
		cetami(3) = etami(3)
		do 190 i=1,6
		    cpi(i) = xpi(i)
  190		continue
	    endif
	    if ( .not. l4 .or. .not. l4pos ) then
*		normal case
		do 200 i=1,3
		    if ( lwrite ) print '(a,i1,a)','  ##[ xs3 nr ',i,':'
		    j = 2*i-1
		    ier0 = ier
		    if ( isoort(j) .eq. 0 ) then
			if ( lwrite ) then
			    print *,'ffxc0p: xk=0, ma=mb/Si-0 -> S3 = 0'
			    print *,'isoort:',isoort(j),isoort(j+1)
			endif
		    elseif ( isoort(j) .gt. 0 ) then
			call ffcxs3(cs3(20*i-19),ipi12(2*i-1),y(1,i),
     +				z(1,i),dyz(1,1,i),d2yzz(i),dy2z(1,i),
     +				xpi,piDpj,i,6,isoort(j),ier0)
		    else
			call ffcs3(cs3(20*i-19),ipi12(2*i-1),cy(1,i),
     +				cz(1,i),cdyz(1,1,i),cd2yzz(i),cpi,
     +				cpiDpj,i,6,isoort(j),ier0)
		    endif
		    ier1 = max(ier1,ier0)
		    if ( lwrite ) print '(a,i1,a)','  ##] xs3 nr ',i,':'
  200		continue
		isoort(7) = 0
		isoort(8) = 0
	    else
		isoort(3) = jsoort(1)
		isoort(4) = jsoort(2)
		if ( lwrite ) print '(a)','  ##[ xs4 nr 1:'
		ier0 = ier
		if ( isoort(1) .gt. 0 .and. isoort(3) .gt. 0 ) then
		    call ffcxs4(cs3(1),ipi12(1),w(1,1),y(1,1),
     +			z(1,1),dwy(1,1,1),dwz(1,1,1),dyz(1,1,1),
     +			d2yww(1),d2yzz(1),xpi,piDpj,1,6,isoort(1),ier0)
		else
		    call ffcs4(cs3(1),ipi12(1),cw(1,1),cy(1,1),
     +			cz(1,1),cdwy(1,1,1),cdwz(1,1,1),cdyz(1,1,1),
     +			cd2yww(1),cd2yzz(1),cpi,cpiDpj,
     +			DCMPLX(xpi(5)*alph(3)**2),cetami,1,6,isoort(1),
     +			ier0)
		endif
		ier1 = max(ier1,ier0)
		if ( lwrite ) print '(a)','  ##] xs4 nr 1:'
		if ( lwrite ) print '(a)','  ##[ xs4 nr 2:'
		isoort(7) = jsoort(5)
		isoort(8) = jsoort(6)
		ier0 = ier
		if ( isoort(5) .gt. 0 .and. isoort(7) .gt. 0 ) then
		    call ffcxs4(cs3(41),ipi12(5),w(1,3),y(1,3),
     +			z(1,3),dwy(1,1,3),dwz(1,1,3),dyz(1,1,3),
     +			d2yww(3),d2yzz(3),xpi,piDpj,3,6,isoort(5),ier0)
		else
		    call ffcs4(cs3(41),ipi12(1),cw(1,3),cy(1,3),
     +			cz(1,3),cdwy(1,1,3),cdwz(1,1,3),cdyz(1,1,3),
     +			cd2yww(3),cd2yzz(3),cpi,cpiDpj,
     +			DCMPLX(xpi(5)*alph(1)**2),cetami,3,6,isoort(5),
     +			ier0)
		endif
		ier1 = max(ier1,ier0)
		if ( lwrite ) print '(a)','  ##] xs4 nr 2:'
	    endif
	endif
	ier = ier1
*  #] complex case integrals:
*###] ffxc0p:
	end
*###[ ffrt3p:
	subroutine ffrt3p(clogip,ilogip,irota,clogi,ilogi,idir)
***#[*comment:***********************************************************
*									*
*	rotates the arrays clogi,ilogi also over irota (idir=+1) or	*
*	back (-1)							*
*									*
*	Input:	irota	  (integer)	index in rotation array		*
*		clogi(3)  (complex)	only if idir=-1			*
*		ilogi(3)  (integer)	indicates which clogi are needed*
*					(idir=+1), i*pi terms (idir=-1)	*
*		idir	  (integer)	direction: forward (+1) or	*
*					backward (-1)			*
*	Output:	clogip(3)  (integer)	clogi rotated			*
*		ilogip(3)  (integer)	ilogi rotated			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer irota,idir,ilogi(3),ilogip(3)
	DOUBLE COMPLEX clogi(3),clogip(3)
*
*	local variables
*
	integer i,inew(6,6)
	save inew
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data inew /1,2,3,4,5,6,
     +		   2,3,1,5,6,4,
     +		   3,1,2,6,4,5,
     +		   1,3,2,6,5,4,
     +		   3,2,1,5,4,6,
     +		   2,1,3,4,6,5/
*  #] declarations:
*  #[ rotate:
*
*	the clogi, ilogi are numbered according to the p_i
*
	if ( idir .eq. +1 ) then
	    do 10 i=1,3
		ilogip(inew(i+3,irota)-3) = ilogi(i)
		clogip(inew(i+3,irota)-3) = clogi(i)
   10	    continue
	else
	    do 20 i=1,3
		ilogip(i) = ilogi(inew(i+3,irota)-3)
		clogip(i) = clogi(inew(i+3,irota)-3)
   20	    continue
	endif
*
*  #] rotate:
*###] ffrt3p:
	end

*###[ ffxc1:
	subroutine ffxc1(cc1i,cc0,cb0i,xpi,piDpj,del2,ier)
***#[*comment:***********************************************************
*									*
*	calculate the C1(mu) = C11*p1(mu) + C12*p2(mu) numerically	*
*									*
*	Input:	cc0	   complex	scalar threepoint function	*
*		cb0i(3)	   complex	scalar twopoint functions	*
*						without m1,m2,m3	*
*						(=with p2,p3,p1)	*
*		xpi(6)	   real		masses (1-3), momenta^2 (4-6)	*
*		piDpj(6,6) real		dotproducts as in C0		*
*		del2	   real		overall determinant		*
*		ier	   integer	digits lost so far		*
*	Output:	cc1i(2)	   complex	C11,C12				*
*		ier	   integer	number of dgits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xpi(6),piDpj(6,6),del2
	DOUBLE COMPLEX cc1i(2),cc0,cb0i(3)
*
*	local variables
*
	integer i,j,ier0
	DOUBLE PRECISION xmax,absc,xnul,xlosn,mc1i(2),mc0,mb0i(3)
	DOUBLE PRECISION dpipj(6,6),piDpjp(6,6)
	DOUBLE COMPLEX cc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffxc1: input:'
	    print *,'xpi  = ',xpi
	    print *,'del2 = ',del2
	endif
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-1-mod(ier,50))
	    do 1 i=1,6
		if ( xpi(i) .ne. piDpj(i,i) ) then
		    print *,'ffxc1: error: xpi and piDpj do not agree'
		endif
    1	    continue
	    do 4 i=1,6
		do 3 j=1,6
		    dpipj(j,i) = xpi(j) - xpi(i)
    3		continue
    4	    continue
	    ier0 = 0
	    call ffdot3(piDpjp,xpi,dpipj,6,ier0)
	    do 7 i=1,6
		do 6 j=1,6
		    xnul = piDpj(j,i) - piDpjp(j,i)
		    if ( xlosn*abs(xnul) .gt. precx*abs(piDpjp(j,i)) )
     +			print *,'piDpj(',j,i,') not correct, cmp:',
     +			piDpj(j,i),piDpjp(j,i),xnul
    6		continue
    7	    continue
	    xnul = del2 - xpi(4)*xpi(5) + piDpj(4,5)**2
	    xmax = max(abs(del2),abs(xpi(4)*xpi(5)))
	    if ( xlosn*abs(xnul) .gt. precx*xmax ) then
		print *,'ffxc1: error: del2 != pi(4)*pi(5)-pi.pj(4,5)^2'
     +			,del2,xpi(4)*xpi(5),piDpj(4,5)**2,xnul
	    endif
	    i = 0
	    ltest = .FALSE.
	    call ffxb0(cc,x0,x1,xpi(4),xpi(1),xpi(2),i)
	    if ( xlosn*absc(cc-cb0i(3)) .gt. precc*absc(cc) ) print *,
     +		'cb0i(3) not right: ',cb0i(3),cc,cb0i(3)-cc
	    call ffxb0(cc,x0,x1,xpi(5),xpi(2),xpi(3),i)
	    if ( xlosn*absc(cc-cb0i(1)) .gt. precc*absc(cc) ) print *,
     +		'cb0i(1) not right: ',cb0i(1),cc,cb0i(1)-cc
	    call ffxb0(cc,x0,x1,xpi(6),xpi(3),xpi(1),i)
	    if ( xlosn*absc(cc-cb0i(2)) .gt. precc*absc(cc) ) print *,
     +		'cb0i(2) not right: ',cb0i(2),cc,cb0i(2)-cc
	    call ffxc0(cc,xpi,ier0)
	    if ( xlosn*absc(cc-cc0) .gt. precc*absc(cc) ) print *,
     +		'cc0 not right: ',cc0,cc,cc0-cc
	    ltest = .TRUE.
	endif
*  #] check input:
*  #[ call ffxc1a:
*
	mc0 = absc(cc0)*DBLE(10)**mod(ier,50)
	mb0i(1) = absc(cb0i(1))*DBLE(10)**mod(ier,50)
	mb0i(2) = absc(cb0i(2))*DBLE(10)**mod(ier,50)
	mb0i(3) = absc(cb0i(3))*DBLE(10)**mod(ier,50)
	call ffxc1a(cc1i,mc1i,cc0,mc0,cb0i,mb0i,xpi,piDpj,del2,ier)
*
*  #] call ffxc1a:
*###] ffxc1:
	end
*###[ ffxc1a:
	subroutine ffxc1a(cc1i,mc1i,cc0,mc0,cb0i,mb0i,xpi,piDpj,del2,
     +		ier)
***#[*comment:***********************************************************
*									*
*	calculate the C1(mu) = C11*p1(mu) + C12*p2(mu) numerically	*
*									*
*	Input:	cc0	   complex	scalar threepoint function	*
*		mc0	   real		maximal partial sum in C0	*
*		cb0i(3)	   complex	scalar twopoint functions	*
*						without m1,m2,m3	*
*						(=with p2,p3,p1)	*
*		mb0i(3)	   real		maxoimal partial sum in B0i	*
*		xpi(6)	   real		masses (1-3), momenta^2 (4-6)	*
*		piDpj(6,6) real		dotproducts as in C0		*
*		del2	   real		overall determinant		*
*		ier	   integer	digits lost so far		*
*	Output:	cc1i(2)	   complex	C11,C12				*
*		mc1i(2)	   real		maximal partial sum in C11,C12	*
*		ier	   integer	number of dgits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION mc1i(2),mc0,mb0i(3),xpi(6),piDpj(6,6),del2
	DOUBLE COMPLEX cc1i(2),cc0,cb0i(3)
*
*	local variables
*
	integer i,ier0,ier1
	DOUBLE PRECISION xmax,absc,del2s2,dpipj(6,6),ms(5)
	DOUBLE COMPLEX cs(5),cc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations:
*  #[ debug input:
	if ( lwrite ) then
	    print *,'ffxc1: input, ier = ',ier
	    print *,'cc0     = ',cc0,mc0
	    print *,'cb0i(1) = ',cb0i(1),mb0i(1)
	    print *,'cb0i(2) = ',cb0i(2),mb0i(2)
	    print *,'cb0i(3) = ',cb0i(3),mb0i(3)
	    print *,'xpi = ',xpi
	    print *,'del2= ',del2
	endif
*  #] debug input:
*  #[ calculations:
*   C1 =
*       + p1(mu)*Del2^-1 * (  - 1/2*B(p1)*p1.p2 - 1/2*B(p2)*p2.p2 - 1/2*B(p3)*
*         p2.p3 - C*p1.p2*p2.s1 + C*p1.s1*p2.p2 )
*
*       + p2(mu)*Del2^-1 * ( 1/2*B(p1)*p1.p1 + 1/2*B(p2)*p1.p2 + 1/2*B(p3)*
*         p1.p3 + C*p1.p1*p2.s1 - C*p1.p2*p1.s1 );
*
	cs(1) = - cb0i(1)*DBLE(piDpj(5,5))
	cs(2) = - cb0i(2)*DBLE(piDpj(6,5))
	cs(3) = - cb0i(3)*DBLE(piDpj(4,5))
	cs(4) = - 2*cc0*DBLE(piDpj(1,5)*piDpj(4,5))
	cs(5) = + 2*cc0*DBLE(piDpj(1,4)*piDpj(5,5))
	ms(1) = mb0i(1)*abs(piDpj(5,5))
	ms(2) = mb0i(2)*abs(piDpj(6,5))
	ms(3) = mb0i(3)*abs(piDpj(4,5))
	ms(4) = 2*mc0*abs(piDpj(1,5)*piDpj(4,5))
	ms(5) = 2*mc0*abs(piDpj(1,4)*piDpj(5,5))
*	exceptions
	if ( xpi(1).eq.xpi(3) .and. xpi(5).eq.xpi(6) ) then
	    if ( lwrite ) print *,'special case m1=m3,p5=p6'
	    cs(2) = + cb0i(2)*DBLE(xpi(5))
	    cs(3) = 0
	    ms(2) = + mb0i(2)*xpi(5)
	    ms(3) = 0
	endif
*	more to come?
*
	cc1i(1) = 0
	mc1i(1) = 0
	xmax = 0
	do 10 i=1,5
	    cc1i(1) = cc1i(1) + cs(i)
	    xmax = max(xmax,absc(cs(i)))
	    mc1i(1) = max(mc1i(1),ms(i))
   10	continue
	ier0 = ier
	if ( lwarn .and. absc(cc1i(1)) .lt. xloss*xmax ) then
	    call ffwarn(163,ier0,absc(cc1i(1)),xmax)
	    if ( lwrite ) then
		print *,'cs(i),ms(i) = '
		print '(i2,3g16.8)',(i,cs(i),ms(i),i=1,5)
		print '(a2,3g16.8)','+ ',cc1i(1),mc1i(1)
	    endif
	endif
	cc1i(1) = cc1i(1)*DBLE(1/(2*del2))
	mc1i(1) = mc1i(1)*abs(1/(2*del2))
*
	cs(1) = + cb0i(1)*DBLE(piDpj(5,4))
	cs(2) = + cb0i(2)*DBLE(piDpj(6,4))
	cs(3) = + cb0i(3)*DBLE(piDpj(4,4))
*	invalidate dpipj
	dpipj(1,1) = 1
	ier1 = ier
	call ffdl2p(del2s2,xpi,dpipj,piDpj, 4,5,6, 1,2,3, 6,ier1)
	cs(4) = + 2*cc0*DBLE(del2s2)
	ms(1) = mb0i(1)*abs(piDpj(5,4))
	ms(2) = mb0i(2)*abs(piDpj(6,4))
	ms(3) = mb0i(3)*abs(piDpj(4,4))
	ms(4) = 2*mc0*abs(del2s2)*DBLE(10)**mod(ier1-ier,50)
*
	cc1i(2) = 0
	mc1i(2) = 0
	xmax = 0
	do 20 i=1,4
	    cc1i(2) = cc1i(2) + cs(i)
	    xmax = max(xmax,absc(cs(i)))
	    mc1i(2) = max(mc1i(2),ms(i))
   20	continue
	if ( lwarn .and. absc(cc1i(2)) .lt. xloss*xmax ) then
	    call ffwarn(163,ier0,absc(cc1i(2)),xmax)
	    if ( lwrite ) then
		print *,'cs(i),ms(i) = '
		print '(i2,3g16.8)',(i,cs(i),ms(i),i=1,4)
		print '(a2,3g16.8)','+ ',cc1i(2),mc1i(2)
	    endif
	endif
	cc1i(2) = cc1i(2)*DBLE(1/(2*del2))
	mc1i(2) = mc1i(2)*abs(1/(2*del2))
	ier = max(ier0,ier1)
*
*  #] calculations:
*  #[ print output:
	if ( lwrite ) then
	    print *,'ffxc1: results:'
	    print *,'C11 = ',cc1i(1),mc1i(1),ier
	    print *,'C12 = ',cc1i(2),mc1i(2),ier
	endif
*  #] print output:
*###] ffxc1a:
	end
*###[ ffxd0:
	subroutine ffxd0(cd0,xpi,ier)
***#[*comment:***********************************************************
*									*
*			  1   /						*
*	calculate cd0 =	----- \dq [(q^2 + 2*s_1.q)*(q^2 + 2*s2.q)	*
*			ipi^2 /      *(q^2 + 2*s3.q)*(q^2 + 2*s4.q)]^-1	*
*									*
*	      |p9							*
*	\p8   V	   p7/							*
*	 \	    /							*
*	  \________/							*
*	  |   m4   |							*
*    =	  |	   |	/____						*
*	m1|	   |m3	\ p10						*
*	  |	   |		all momenta are incoming		*
*	  |________|							*
*	  /  m2	   \							*
*	 /	    \							*
*	/p5	   p6\							*
*									*
*									*
*	following the two-three-point-function method in 't hooft &	*
*	veltman. this is only valid if there is a lambda(pij,mi,mj)>0	*
*									*
*	Input:	xpi = mi^2	   (real)  i=1,4			*
*		xpi = pi.pi	   (real)  i=5,8 (note: B&D metric)	*
*		xpi(9)=s	   (real)  (=p13)			*
*		xpi(10)=t	   (real)  (=p24)			*
*		xpi(11)=u	   (real)  u=p5.p5+..-p9.p9-p10.10 or 0	*
*		xpi(12)=v	   (real)  v=-p5.p5+p6.p6-p7.p7+.. or 0	*
*		xpi(13)=w	   (real)  w=p5.p5-p6.p6+p7.p7-p8.p8+.. *
*	output:	cd0		  (complex)				*
*		ier		  (integer) <50:lost # digits 100=error	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE PRECISION xpi(13)
	DOUBLE COMPLEX cd0
	integer ier
*
*	local variables
*
	integer i,j,ier0,ier1
	logical luvw(3)
	DOUBLE PRECISION xmax,dpipj(10,13)
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ call ffdif4, ffxd0a:
*
	call ffdif4(dpipj,luvw,xpi,ier)
	call ffxd0a(cd0,xpi,dpipj,ier)
*
*	restore the zeros for u,v,w as we have calculated them
*	ourselves and the user is unlikely to do this...
*
	if ( luvw(1) ) xpi(11) = 0
	if ( luvw(2) ) xpi(12) = 0
	if ( luvw(3) ) xpi(13) = 0
*
*  #] call ffdif4,ffxd0a:
*###] ffxd0:
	end
*###[ ffxd0a:
	subroutine ffxd0a(cd0,xpi,dpipj,ier)
*
*	glue routine which calls ffxd0b with ndiv=0
*
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xpi(13),dpipj(10,13)
	DOUBLE COMPLEX cd0
*
*	common
*
	include 'ff.h'
*
*	and go!
*
	call ffxd0b(cd0,xpi,dpipj,0,ier)
*
*###] ffxd0a:
	end
*###[ ffxd0b:
	subroutine ffxd0b(cd0,xpi,dpipj,ndiv,ier)
***#[*comment:***********************************************************
*									*
*			  1   /						*
*	calculate cd0 =	----- \dq [(q^2 + 2*s_1.q)*(q^2 + 2*s2.q)	*
*			ipi^2 /      *(q^2 + 2*s3.q)*(q^2 + 2*s4.q)]^-1	*
*									*
*	      |p9							*
*	\p8   V	   p7/							*
*	 \	    /							*
*	  \________/							*
*	  |   m4   |							*
*    =	  |	   |	/____						*
*	m1|	   |m3	\ p10						*
*	  |	   |		all momenta are incoming		*
*	  |________|							*
*	  /  m2	   \							*
*	 /	    \							*
*	/p5	   p6\							*
*									*
*									*
*	following the two-three-point-function method in 't hooft &	*
*	veltman. this is only valid if there is a lambda(pij,mi,mj)>0	*
*									*
*	Input:	xpi = mi^2	   (real)  i=1,4			*
*		xpi = pi.pi	   (real)  i=5,8 (note: B&D metric)	*
*		xpi(9)=s	   (real)  (=p13)			*
*		xpi(10)=t	   (real)  (=p24)			*
*		xpi(11)=u	   (real)  u=p5.p5+..-p9.p9-p10.10	*
*		xpi(12)=v	   (real)  v=-p5.p5+p6.p6-p7.p7+..	*
*		xpi(13)=w	   (real)  w=p5.p5-p6.p6+p7.p7-p8.p8+.. *
*		dpipj(10,13)	   (real)  = pi(i) - pi(j)		*
*	output:	cd0		  (complex)				*
*		ier		  (integr) 0=ok 1=inaccurate 2=error	*
*	calls:	ffcxs3,ffcxr,ffcrr,...					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ndiv,ier
	DOUBLE PRECISION xpi(13),dpipj(10,13)
	DOUBLE COMPLEX cd0
*
*	local variables
*
	integer i,j,itype,ini2ir,ier2,idone,ier0,ii(6),idotsa
	logical ldel2s
	DOUBLE COMPLEX c,cs1,cs2,cs,cfac
	DOUBLE PRECISION absc,xmax,xpip(13),dpipjp(10,13),piDpjp(10,10),
     +		qiDqj(10,10),del2s,delta0,xnul,rloss,vgl
	save ini2ir,delta0
*
*	common blocks:
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	memory
*
	integer iermem(memory),ialmem(memory),memind,ierini,nscsav,
     +		isgnsa
	logical onssav
	DOUBLE PRECISION xpimem(10,memory),dl4mem(memory)
	DOUBLE COMPLEX cd0mem(memory)
	save memind,iermem,ialmem,xpimem,cd0mem,nscsav,onssav
*
*	statement function:
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data memind /0/
	data ini2ir /0/
	data delta0 /0./
*
*  #] declarations:
*  #[ initialisations:
	cd0 = 0
	idsub = 0
	idone = 0
*  #] initialisations:
*  #[ check input if dotproducts are input:
*
	if ( ltest .and. idot.gt.0 ) then
	    ier0 = ier
	    idotsa = idot
	    idot = 0
	    call ffdot4(qiDqj,xpi,dpipj,10,ier0)
	    idot = idotsa
	    rloss = xloss*DBLE(10)**(-2-mod(ier0,50))
	    if ( idot.le.2 ) then
		do 20 i=5,10
		    do 10 j=5,10
			xnul = abs(fpij4(j,i)-qiDqj(j,i))
			xmax = abs(qiDqj(j,i))
			if ( rloss*xnul .gt. precx*xmax ) print *,
     +			    'ffxd0b: error: input dotproduct piDpj(',j,
     +			    i,') wrong: ',fpij4(j,i),qiDqj(j,i),xnul,
     +			    ier0
   10		    continue
   20		continue
	    else
		do 40 i=1,10
		    do 30 j=1,10
			xnul = abs(fpij4(j,i)-qiDqj(j,i))
			xmax = abs(qiDqj(j,i))
			if ( rloss*xnul .gt. precx*xmax ) print *,
     +			    'ffxd0b: error: input dotproduct piDpj(',j,
     +			    i,') wrong:',fpij4(j,i),qiDqj(j,i),xnul,ier0
   30		    continue
   40		continue
	    endif
	    if ( idot.ge.2 ) then
		ii(1) =  5
		ii(2) =  6
		ii(3) =  7
		ii(4) =  8
		ii(5) =  9
		ii(6) = 10
		call ffdl3p(vgl,qiDqj,10,ii,ii,ier0)
		rloss = xloss**2*DBLE(10)**(-mod(ier0,50))
		xnul = fdel3 - vgl
		xmax = abs(vgl)
		if ( rloss*xnul.gt.precx*xmax ) print *,'ffxd0b: error',
     +			': input del3p wrong: ',fdel3,vgl,xnul,ier0
	    endif
	    if ( idot.ge.4 ) then
		call ffdel4(vgl,xpi,qiDqj,10,ier0)
		xnul = fdel4s - vgl
		xmax = abs(vgl)
		if ( rloss*xnul.gt.precx*xmax ) print *,'ffxd0b: error',
     +			': input del4s wrong: ',fdel4s,vgl,xnul,ier0
	    endif
	endif
*
*  #] check input if dotproducts are input:
*  #[ check for IR 4point function:
*
	call ffxdir(cs,cfac,idone,xpi,dpipj,4,ndiv,ier)
	if ( idone .le. 0 .and. ndiv .gt. 0 ) then
	    if ( lwrite ) print *,'ffxd0b: at most log divergence'
	    cd0 = 0
	    ier = 0
	    return
	endif
	if ( idone .gt. 0 ) then
	    cd0 = cs*cfac
	    return
	endif
*
*  #] check for IR 4point function:
*  #[ rotate to calculable position:
	call ffrot4(irota4,del2s,xpip,dpipjp,piDpjp,xpi,dpipj,qiDqj,4,
     +		itype,ier)
	if ( itype .lt. 0 ) then
	    print *,'ffxd0b:  error:  Cannot handle this ',
     +		' masscombination yet:'
	    print *,(xpi(i),i=1,13)
	    return
	endif
	if ( itype .eq. 1 ) then
	    ldel2s = .TRUE.
	    isgnal = +1
	else
	    ldel2s = .FALSE.
	endif
*  #] rotate to calculable position:
*  #[ treat doubly IR divergent case:
	if ( itype .eq. 2 ) then
*
*	    double IR divergent diagram, i.e. xpi(3)=xpi(4)=xpi(7)=0
*
	    if ( ini2ir .eq. 0 ) then
		ini2ir = 1
		print *,'ffxd0b: using the log(lam) prescription to'
		print *,'        regulate the 2 infrared poles to match'
		print *,'        with soft gluon massive, lam^2 =',delta
	    endif
	    if ( ltest .and. idone .ne. 2 ) then
		print *,'ffxd0: error: itype=2 but idone != 2'
	    endif
	    ier2 = 0
	    call ffx2ir(cs1,cs2,xpip,dpipjp,ier2)
	    del2s = -delta**2/4
*
*	    correct for the wrongly treated IR pole
*
	    cd0 = cd0 + cs1 + cs2
	    ier = max(ier,ier2)
	    xmax = max(absc(cs1),absc(cs2))
	    if ( absc(cd0) .lt. xloss*xmax )
     +		call ffwarn(172,ier,absc(cd0),xmax)
	    if ( .not.ldot ) return
	endif
*
*  #] treat doubly IR divergent case:
*  #[ look in memory:
	ierini = ier
	isgnsa = isgnal
*
*	initialise memory
*
	if ( lmem .and. idone .eq. 0 .and. (memind .eq. 0 .or. nschem
     +		.ne. nscsav .or. (onshel .neqv. onssav) ) ) then
	    memind = 0
	    nscsav = nschem
	    onssav = onshel
	    do 2 i=1,memory
		do 1 j=1,10
		    xpimem(j,i) = 0
    1		continue
		ialmem(i) = 0
    2	    continue
	endif
*
	if ( lmem .and. idone .eq. 0 .and. delta .eq. delta0 ) then
	    do 150 i=1,memory
		do 130 j=1,10
		    if ( xpip(j) .ne. xpimem(j,i) ) goto 150
  130		continue
*		we use ialmem(i)==0 to signal that both are covered as
*		the sign was flipped during the computation
		if ( ialmem(i).ne.isgnal .and. ialmem(i).ne.0 ) goto 150
*		we found an already calculated masscombination ..
*		(maybe check differences as well)
		if ( lwrite ) print *,'ffxd0b: using previous result'
		cd0 = cd0mem(i)
		ier = ier+iermem(i)
		if ( ldot ) then
		    fdel4s = dl4mem(i)
*		    we forgot to calculate the dotproducts
		    idone = 1
		    goto 51
		endif
		return
  150	    continue
*	    if ( lwrite ) print *,'ffxd0b: not found in memory'
	elseif ( lmem ) then
	    delta0 = delta
	endif
   51	continue
*  #] look in memory:
*  #[ get dotproducts:
*
*	Calculate the dotproducts (in case it comes out of memory the
*	error is already included in ier)
*
	ier0 = ier
	call ffgdt4(piDpjp,xpip,dpipjp,xpi,dpipj,itype,ier0)
	if ( idone .gt. 0 ) return
	ier = ier0
	if ( ier.ge.100 ) then
	    cd0 = 0
	    return
	endif
*
*  #] get dotproducts:
*  #[ calculations:
*
	call ffxd0e(cs,cfac,xmax, .FALSE.,ndiv,xpip,dpipjp,piDpjp,del2s,
     +		ldel2s,ier)
*
*	Finally ...
*
	cd0 = cs*cfac
	xmax = xmax*absc(cfac)
*
*	Check for cancellations in the final adding up
*
	if ( lwarn .and. 2*absc(cd0) .lt. xloss*xmax )
     +		call ffwarn(84,ier,absc(cd0),xmax)
*
*  #] calculations:
*  #[ add to memory:
*
*	memory management :-)
*
	if ( lmem ) then
	    memind = memind + 1
	    if ( memind .gt. memory ) memind = 1
	    do 200 j=1,10
		xpimem(j,memind) = xpip(j)
  200	    continue
	    cd0mem(memind) = cd0
	    iermem(memind) = ier-ierini
	    ialmem(memind) = isgnal
	    dl4mem(memind) = fdel4s
	    if ( isgnal.ne.isgnsa ) then
		ialmem(memind) = 0
	    endif
	endif
*  #] add to memory:
*###] ffxd0b:
	end
*###[ ffxd0e:
	subroutine ffxd0e(cs,cfac,xmax,lir,ndiv,xpip,dpipjp,piDpjp,
     +		del2s,ldel2s,ier)
***#[*comment:***********************************************************
*									*
*	Break in the calculation of D0 to allow the E0 to tie in in a	*
*	logical position.  This part gets untransformed momenta but	*
*	rotated momenta in and gives the D0 (in two pieces) and the	*
*	maximum term back.						*
*									*
*	Input	xpip	real(13)					*
*		dpipjp	real(10,13)					*
*		piDpjp	real(10,10)					*
*		del2s	real						*
*		ldel2s	logical						*
*		lir	logical		if TRUE it can still be IR-div	*
*		ndiv	integer		number of required divergences	*
*									*
*	Output:	cs	complex		the fourpoint function without	*
*					overall factor (sum of dilogs)	*
*		cfac	complex		this overall factor		*
*		xmax	real		largest term in summation	*
*		ier	integer		usual error flag		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ndiv,ier
	logical lir,ldel2s
	DOUBLE PRECISION xpip(13),dpipjp(10,13),piDpjp(10,10),xmax,del2s
	DOUBLE COMPLEX cs,cfac
*
*	local variables
*
	DOUBLE COMPLEX c,cs4(175),cs3(2)
	logical laai
	integer i,j,ier0,itime,maxlos,init,isoort(16),ipi12(26),
     +		ipi123(2),ipi12t,idone
	DOUBLE PRECISION absc,sdel2s,ai(4),daiaj(4,4),aai(4),
     +		dt3t4,xqi(10),dqiqj(10,10),qiDqj(10,10),xfac
	save maxlos
*
*	common blocks:
*
	include 'ff.h'
*
*	statement function:
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data init /0/
*  #] declarations:
*  #[ check for IR 4point function:
	if ( lir ) then
*
	    call ffxdir(cs,cfac,idone,xpip,dpipjp,4,0,ier)
	    if ( idone .le. 0 .and. ndiv .gt. 0 ) then
		if ( lwrite ) print *,'ffxd0e: at most log divergence'
		cs = 0
		cfac = 1
		xmax = 0
		ier = 0
		return
	    endif
	    if ( idone .gt. 0 ) return
	endif
*
*  #] check for IR 4point function:
*  #[ init:
*
*	initialize cs4:
*
	do 80 i=1,175
	    cs4(i) = 0
   80	continue
	do 90 i=1,26
	    ipi12(i) = 0
   90	continue
	cs = 0
*  #] init:
*  #[ transform the masses and momenta:
	itime = 1
   25	continue
*
*	Transform with the A's of gerard 't hooft's transformation:
*
	if ( lwrite ) print '(a)','  ##[ transform momenta:'
*
*	NOTE: for some odd reason I cannot vary isgnal,isgn34
*	independently!
*
	isgn34 = isgnal
	sdel2s = isgn34*sqrt(-del2s)
	ier0 = ier
	call ffai(ai,daiaj,aai,laai,del2s,sdel2s,xpip,dpipjp,piDpjp,
     +		ier0)
	if ( ier0 .ge. 100 ) goto 70
	call fftran(ai,daiaj,aai,laai,xqi,dqiqj,qiDqj,del2s,sdel2s,
     +		xpip,dpipjp,piDpjp,ier0)
	if ( ier0 .ge. 100 ) goto 70
	if ( .not.ldel2s ) then
	    dt3t4 = -2*ai(3)*ai(4)*sdel2s
	    if ( ltest ) then
		if ( xloss*abs(dt3t4-xqi(3)+xqi(4)) .gt. precx*max(
     +			abs(dt3t4),abs(xqi(3)),abs(xqi(4))) ) then
		    print *,'ffxd0a:  error:  dt3t4 <> t3 - t4',dt3t4,
     +			xqi(3),xqi(4),dt3t4-xqi(3)+xqi(4)
		endif
	    endif
	    if ( dt3t4 .eq. 0 ) then
*		don't know what to do...
		call fferr(85,ier)
		return
	    endif
	else
*	    this value is modulo the delta of xpip(4)=xpip(3)(1+2delta)
	    dt3t4 = -2*ai(4)**2*xpip(3)
	endif

   70	continue
	if ( lwrite ) print '(a)','  ##] transform momenta:'
*
*	If we lost too much accuracy try the other root...
*	(to do: build in a mechanism for remembering this later)
*
	if ( init .eq. 0 ) then
	    init = 1
*	    go ahead if we have half the digits left
	    maxlos = -int(log10(precx))/2
	    if ( lwrite ) print *,'ffxd0a: redo trans if loss > ',maxlos
	endif
	if ( ier0-ier .gt. maxlos ) then
	    if ( itime .eq. 1 ) then
		itime = 2
		if ( ier0-ier .ge. 100 ) itime = 100
		isgnal = -isgnal
		if ( lwrite ) print *,'ffxd0a: trying other root, ier=',
     +			ier0
		goto 25
	    else
		if ( ier0-ier .lt. 100 ) then
*		    it does not make any sense to go on, but do it anyway
		    if ( lwrite ) print *,'ffxd0a:  both roots rotten ',
     +			'going on'
		elseif ( itime.eq.100 ) then
		    if ( lwrite ) print *,'ffxd0a:  both roots rotten ',
     +			'giving up'
		    call fferr(72,ier)
		    cfac = 1
		    return
		elseif ( itime.le.2 ) then
*		    the first try was better
		    itime = 3
		    goto 25
		endif
	    endif
	endif
	ier = ier0
*  #] transform the masses and momenta:
*  #[ calculations:
	call ffxd0p(cs4,ipi12,isoort,cfac,xpip,dpipjp,piDpjp,
     +		xqi,dqiqj,qiDqj,ai,daiaj,ldel2s,ier)
	xfac = -ai(1)*ai(2)*ai(3)*ai(4)/dt3t4
*
*	see the note at the end of this section about the sign
*
	if ( DIMAG(cfac) .eq. 0 ) then
	    cfac = xfac/DBLE(cfac)
	else
	    cfac = DBLE(xfac)/cfac
	endif
*
*	sum'em up:
*
	cs3(1) = 0
	cs3(2) = 0
	xmax = 0
	do 110 i=1,80
	    cs3(1) = cs3(1) + cs4(i)
	    xmax = max(xmax,absc(cs3(1)))
  110	continue
	do 111 i=81,160
	    cs3(2) = cs3(2) + cs4(i)
	    xmax = max(xmax,absc(cs3(2)))
  111	continue
	cs = cs3(1) - cs3(2)
	do 112 i=161,175
	    cs = cs + cs4(i)
	    xmax = max(xmax,absc(cs))
  112	continue
	ipi123(1) = 0
	ipi123(2) = 0
	do 113 i=1,8
	    ipi123(1) = ipi123(1) + ipi12(i)
  113	continue
	do 114 i=9,16
	    ipi123(2) = ipi123(2) + ipi12(i)
  114	continue
	ipi12t = ipi123(1) - ipi123(2)
	do 120 i=17,26
	    ipi12t = ipi12t + ipi12(i)
  120	continue
	cs = cs + ipi12t*DBLE(pi12)
*
*	Check for a sum close to the minimum of the range (underflow
*	problems)
*
	if ( lwarn .and. absc(cs) .lt. xalogm/precc .and. cs .ne. 0 )
     +		call ffwarn(119,ier,absc(cs),xalogm/precc)
*
*	If the imaginary part is very small it most likely is zero
*	(can be removed, just esthetically more pleasing)
*
	if ( abs(DIMAG(cs)) .lt. precc*abs(DBLE(cs)) )
     +		cs = DCMPLX(DBLE(cs))
*
*	it is much nicer to have the sign of cfac fixed, say positive
*
	if ( DBLE(cfac) .lt. 0 .or. (DBLE(cfac) .eq. 0 .and. DIMAG(cfac)
     +		.lt. 0 ) ) then
	    cfac = -cfac
	    cs = -cs
	endif
*  #] calculations:
*  #[ debug:
	if(lwrite)then
*	    print *,'s3''s :'
*	    print *,' '
*	    print 1004,(cs4(i),cs4(i+20),cs4(i+40),cs4(i+60),i=1,20)
*	    print *,' '
*	    print 1004,(cs4(i+80),cs4(i+100),cs4(i+120),cs4(i+140),i=
*     +		1,20)
*	    print *,' '
	    print *,'Threepoint functions:'
	    print '(a,2g24.14,i3)','C3  = ',cs3(1),ipi123(1)
	    print '(a,2g24.14,i3)','C4  = ',cs3(2),ipi123(2)
	    print '(a,2g24.14,i3)','sum = ',cs3(1)-cs3(2),
     +		ipi123(1)-ipi123(2)
	    if ( ipi123(1) .ne. ipi123(2) ) print '(a,2g24.14)',
     +		'    = ',cs3(1)-cs3(2)+(ipi123(1)-ipi123(2))*DBLE(pi12)
	    print *,'Correction terms for Ai negative'
	    print 1003,(cs4(160+i),cs4(161+i),cs4(162+i),i=1,4,3)
	    c = 0
	    j = 0
	    do 803 i=1,6
		j = j + ipi12(16+i)
		c = c + cs4(160+i)
  803	    continue
	    print '(a,2g24.14,i3)','sum = ',c,j
	    if ( j .ne. 0 ) print '(a,2g24.14)','    = ',
     +		c+j*DBLE(pi12)
	    print *,'S of ''t Hooft and Veltman'
	    print 1002,(cs4(166+i),cs4(167+i),i=1,3,2)
	    c = 0
	    j = ipi12(23)+ipi12(24)+ipi12(25)+ipi12(26)
	    do 804 i=1,6
		c = c + cs4(166+i)
  804	    continue
	    print '(a,2g24.14,i3)','sum = ',c,j
	    if ( j .ne. 0 ) print '(a,2g24.14)','    = ',
     +		c+j*DBLE(pi12)
*	    print *,' '
*	    print *,'ipi12: ',ipi12
*	    print *,'isoort:',isoort
	    print '(a,2g24.14,2i6)','som  : ',cs,ipi12t,ier
	    print *,'fac  :',cfac
	    print *,'cd0  :',cs*cfac
 1002	    format(g12.6,1x,g12.6,2x,g12.6,1x,g12.6)
 1003	    format(g12.6,1x,g12.6,2x,g12.6,1x,g12.6,2x,g12.6,1x,g12.6)
 1004	    format(g12.6,1x,g12.6,2x,g12.6,1x,g12.6,2x,g12.6,1x,g12.6,
     +		2x,g12.6,1x,g12.6)
	endif
*  #] debug:
*###] ffxd0e:
	end
*###[ ffxd0r:
	subroutine ffxd0r(cd0,xpi,ier)
***#[*comment:***********************************************************
*									*
*	Tries all 12 permutations of the 4pointfunction			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE PRECISION xpi(13),xqi(13)
	DOUBLE COMPLEX cd0,cd0p
	integer inew(13,6),irota,ier1,i,j,icon,ialsav,init
	logical lcon
	parameter (icon=3)
	save inew,init,lcon
	include 'ff.h'
	data inew /1,2,3,4,5,6,7,8,9,10,11,12,13,
     +		   4,1,2,3,8,5,6,7,10,9,11,13,12,
     +		   3,4,1,2,7,8,5,6,9,10,11,12,13,
     +		   2,3,4,1,6,7,8,5,10,9,11,13,12,
     +		   4,2,3,1,10,6,9,8,7,5,12,11,13,
     +		   1,3,2,4,9,6,10,8,5,7,12,11,13/
	data init /0/
*  #] declarations:
*  #[ open console for some activity on screen:
	if ( init .eq. 0 ) then
	    init = 1
	    if ( lwrite ) then
		open(icon,file='CON:',status='old',err=11)
		lcon = .TRUE.
		goto 13
	    endif
   11	    continue
	    lcon = .FALSE.
   13	    continue
	endif
*  #] open console for some activity on screen:
*  #[ calculations:
	cd0 = 0
	ier = 999
	ialsav = isgnal
	do 30 j = -1,1,2
	    do 20 irota=1,6
		do 10 i=1,13
		    xqi(inew(i,irota)) = xpi(i)
   10		continue
		ier1 = 0
		ner = 0
		id = id + 1
		isgnal = ialsav
		print '(a,i1,a,i2)','---#[ rotation ',irota,': isgnal ',
     +			isgnal
		if (lcon) write(icon,'(a,i1,a,i2)')'rotation ',irota,',
     +			isgnal ',isgnal
		call ffxd0(cd0p,xqi,ier1)
		ier1 = ier1 + ner
		print '(a,i1,a,i2,a)','---#] rotation ',irota,
     +			': isgnal ',isgnal,' '
		print '(a,2g28.16,i3)','d0 = ',cd0p,ier1
		if (lcon) write(icon,'(a,2g28.16,i3)')'d0 = ',cd0p,ier1
		if ( ier1 .lt. ier ) then
		    cd0 = cd0p
		    ier = ier1
		endif
   20	    continue
	    ialsav = -ialsav
   30	continue
*  #] calculations:
*###] ffxd0r:
	end
*###[ ffxd0d:
	subroutine ffxd0d(cd0,xpi,piDpj,del3p,del4s,info,ier)
***#[*comment:***********************************************************
*									*
*	Entry point to the four point function with dotproducts given.	*
*	Necessary to avoid cancellations near the borders of phase	*
*	space.								*
*									*
*	Input:	xpi(13)	      real	1-4: mi^2, 5-10: pi^2,s,t	*
*					optional: 11:u, 12:v, 13:w	*
*		info	      integer	0: no extra info		*
*					1: piDpj(i,j), i,j>4 is defined	*
*					2: del3p is also defined	*
*					3: all piDpj are given		*
*					4: del4s is also given		*
*		piDpj(10,10)  real	pi.pj in B&D metric;		*
*					1-4:si.sj=(m_i^2+m_j^2-p_ij^2)/2*
*					cross: si.pjk=si.pj-si.pk	*
*					5-10: pi.pj			*
*		del3p	      real	det(pi.pj)			*
*		del4s	      real	det(si.sj) (~square overall fac)*
*		ier	      integer	#digits accuracy lost in input	*
*	Output:	cd0	      complex	D0				*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer info,ier
	DOUBLE PRECISION xpi(13),piDpj(10,10),del3p,del4s
	DOUBLE COMPLEX cd0
*
*	local vars
*
	integer i,j
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ hide information in common blocks:
*
	idot = info
	if ( idot.gt.0 ) then
	    if ( idot.le.2 ) then
		do 20 i=5,10
		    do 10 j=5,10
			fpij4(j,i) = piDpj(j,i)
   10		    continue
   20		continue
	    else
		do 40 i=1,10
		    do 30 j=1,10
			fpij4(j,i) = piDpj(j,i)
   30		    continue
   40		continue
	    endif
	    if ( idot.ge.2 ) then
		fdel3 = del3p
	    endif
	    if ( idot.ge.4 ) then
		fdel4s = del4s
	    endif
	endif
*
*  #] hide information in common blocks:
*  #[ call ffxd0:
*
	call ffxd0(cd0,xpi,ier)
*
*	invalidate all the common blocks for the next call
*
	idot = 0
*
*  #] call ffxd0:
*###] ffxd0d:
	end
*###[ ffdif4:
	subroutine ffdif4(dpipj,luvw,xpi,ier)
***#[*comment:***********************************************************
*									*
*	Compute the elements 11-13 in xpi and the differences dpipj	*
*	Note that the digits lost in dpipj are not counted towards	*
*	the total.							*
*									*
*	Input:	xpi(1:10)	real		masses, momenta^2	*
*									*
*	Output:	xpi(11:13)	real		u and similar vars v,w	*
*		luvw(3)		logical		TRUE if xpi(10+i) has	*
*						been computed here	*
*		dpipj(10,13)	real		xpi(i) - xpi(j)		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	logical luvw(3)
	DOUBLE PRECISION xpi(13),dpipj(10,13)
*
*	local variables
*
	integer i,j,ier1,ier0
	DOUBLE PRECISION xmax
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ get differences:
*	simulate the differences in the masses etc..
	if ( lwrite ) print *,'ffxd0: input xpi: ',xpi
	ier1 = ier
	if ( xpi(11)  .eq. 0 ) then
	    xpi(11) = xpi(5)+xpi(6)+xpi(7)+xpi(8)-xpi(9)-xpi(10)
	    if ( lwarn ) then
		xmax = max(abs(xpi(5)),abs(xpi(6)),abs(xpi(7)),
     +		       abs(xpi(8)),abs(xpi(9)),abs(xpi(10)))
		if ( abs(xpi(11)) .lt. xloss*xmax )
     +		    call ffwarn(153,ier1,xpi(11),xmax)
	    endif
	    luvw(1) = .TRUE.
	else
	    luvw(1) = .FALSE.
	endif
	if ( xpi(12)  .eq. 0 ) then
	    xpi(12) = -xpi(5)+xpi(6)-xpi(7)+xpi(8)+xpi(9)+xpi(10)
	    if ( lwarn ) then
		ier0 = ier
		xmax = max(abs(xpi(5)),abs(xpi(6)),abs(xpi(7)),
     +		       abs(xpi(8)),abs(xpi(9)),abs(xpi(10)))
		if ( abs(xpi(12)) .lt. xloss*xmax )
     +		    call ffwarn(154,ier0,xpi(12),xmax)
		ier1 = max(ier1,ier0)
	    endif
	    luvw(2) = .TRUE.
	else
	    luvw(2) = .FALSE.
	endif
	if ( xpi(13)  .eq. 0 ) then
	    if ( max(abs(xpi(5)),abs(xpi(7))) .gt.
     +		 max(abs(xpi(9)),abs(xpi(10))) ) then
		xpi(13) = -xpi(12) + 2*(xpi(9)+xpi(10))
	    else
		xpi(13) = -xpi(11) + 2*(xpi(5)+xpi(7))
	    endif
*	    xpi(13) = xpi(5)-xpi(6)+xpi(7)-xpi(8)+xpi(9)+xpi(10)
	    if ( lwarn ) then
		ier0 = ier
		xmax = 2*min(max(abs(xpi(5)),abs(xpi(7))),
     +			     max(abs(xpi(9)),abs(xpi(10))))
		if ( abs(xpi(13)) .lt. xloss*xmax )
     +		    call ffwarn(155,ier0,xpi(13),xmax)
		ier1 = max(ier1,ier0)
	    endif
	    luvw(3) = .TRUE.
	else
	    luvw(3) = .FALSE.
	endif
	if ( lwarn ) then
	    do 10 i=1,13
		if ( i .le. 10 ) dpipj(i,i) = 0
		do 9 j=1,min(i-1,10)
		    dpipj(j,i) = xpi(j) - xpi(i)
		    if ( i .le. 10 ) then
			dpipj(i,j) = -dpipj(j,i)
		    endif
*		    we do not need the differences of s,t,u,v,w accurately
		    if ( i .gt. 8 .and. j .gt. 8 ) goto 9
		    if ( abs(dpipj(j,i)) .lt. xloss*abs(xpi(i))
     +					.and. xpi(i) .ne. xpi(j) ) then
			ier0 = ier
			call ffwarn(121,ier0,dpipj(j,i),xpi(i))
			if ( lwrite ) print *,'between xpi(',i,
     +				') and xpi(',j,')'
		    endif
    9		continue
   10	    continue
	    ier = ier1
	else
	    do 20 i=1,13
		do 19 j=1,10
		    dpipj(j,i) = xpi(j) - xpi(i)
   19		continue
   20	    continue
	endif
*  #] get differences:
*###] ffdif4:
	end
*###[ ffrot4:
	subroutine ffrot4(irota,del2,xqi,dqiqj,qiDqj,xpi,dpipj,piDpj,ii,
     +		itype,ier)
***#[*comment:***********************************************************
*									*
*	rotates the arrays xpi, dpipj into xqi,dqiqj over irota places	*
*	such that del2(s3,s4)<=0. itype=0 unless del2(s3,s4)=0 (itype=1)*
*	itype=2 if the 4pointfunction is doubly IR-divergent		*
*	((0,0,0)vertex)							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer irota,ier,ii,itype
	DOUBLE PRECISION del2,xpi(13),dpipj(10,13),piDpj(10,10),
     +		xqi(13),dqiqj(10,13),qiDqj(10,10),qiDqjp(10,10)
*
*	local variables
*
	integer i,j,izero,istart,ier0
	DOUBLE PRECISION del2p
	DOUBLE COMPLEX chulp(4,4)
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
	    ier0 = ier
	    if ( ii .eq. 5 ) then
	    do 890 i=1,10
		if ( xpi(i) .ne. piDpj(i,i) ) then
		    print *,'ffrot4: error: xpi(',i,')!=piDpj(',i,i,
     +			'):',xpi(i),piDpj(i,i),xpi(i)-piDpj(i,i)
		endif
  890	    continue
	    endif
	    call ffxhck(xpi,dpipj,10,ier0)
	    call ffxuvw(xpi,dpipj,ier0)
	    if ( ier0 .gt. ier ) print *,'ffrot4: input wrong!'
	endif
*  #] check input:
*  #[ find out which del2 is negative: (or zero)
	izero = 0
	do 40 irota = 1,12
*
*	    first check if we have a doubly IR divergent diagram
*
	    if ( xpi(iold(3,irota)) .eq. 0 .and.
     +		 xpi(iold(4,irota)) .eq. 0 .and.
     +		 xpi(iold(7,irota)) .eq. 0 .and.
     +		 dpipj(iold(1,irota),iold(8,irota)) .eq. 0 .and.
     +		 dpipj(iold(2,irota),iold(6,irota)) .eq. 0 ) then
		del2 = 0
		goto 41
	    endif
*
*	    We can at this moment only handle s3^2 = 0
*	    (Hope to include two masses 0 later)
*	    I hope nothing goes wrong if we leave out:
*		>xpi(iold(1,irota)) .eq. 0 .or.
*     +		 xpi(iold(2,irota)) .eq. 0 .or.
*     +		 <
*	    'cause I can't see why it was included in the first place..
*
	    if (  xpi(iold(4,irota)) .eq. 0 ) then
		if ( lwrite ) print *,'no good, s4^2 = 0'
		goto 40
	    endif
*
*	    Well, the combination s2=0, p6=s3, p10=s4 gives 1/A2=0 twice
*
	    if ( xpi(iold(2,irota)) .eq. 0 .and.
     +			dpipj(iold( 6,irota),iold(3,irota)) .eq. 0 .and.
     +			dpipj(iold(10,irota),iold(4,irota)) .eq. 0) then
		if ( lwrite ) print *,'no good, s2^2, s3^2=p6^2 and ',
     +			's4^2=p10^2'
		goto 40
	    endif
*
*	    phenomenologically this combo also gives an infinite result
*
	    if ( xpi(iold(1,irota)) .eq. 0 .and.
     +		 xpi(iold(2,irota)) .eq. 0 .and.
     +			dpipj(iold( 8,irota),iold(4,irota)) .eq. 0 .and.
     +			dpipj(iold( 9,irota),iold(3,irota)) .eq. 0) then
		if ( lwrite ) print *,'no good, s1^2=s2^2=0, s4^2=p8^2',
     +			' and s3^2 = p9^2'
		goto 40
	    endif
*
*	    I just found out that this gives two times 1/A1 = 0
*
	    if ( xpi(iold(7,irota)) .eq. 0 .and.
     +		 dpipj(iold(9,irota),iold(3,irota))+
     +		 dpipj(iold(4,irota),iold(8,irota)) .eq. 0 ) then
		if ( lwrite ) print *,'no good, p7^2=0 and ',
     +			'p9^2-s3^2+s4^2-p8^2 = 0'
		goto 40
	    endif
	    if ( xpi(iold(1,irota)) .eq. 0 .and.
     +		 dpipj(iold(9,irota),iold(3,irota)) .eq. 0 .and.
     +		 dpipj(iold(4,irota),iold(8,irota)) .eq. 0 .and.
     +		 .not.lnasty ) then
		if ( lwrite ) print *,'no good, s1^2=0 and ',
     +			's1.s3 = 0 and s1.s4 = 0'
		goto 40
	    endif
*
*	    the nasty case wants xpi(1)=0, xpi(2) real:
*
	    if ( lnasty ) then
		if ( xpi(iold(1,irota)).ne.0 .or. DIMAG(
     +			c2sisj(iold(1,irota),iold(2,irota))).ne.0 ) then
		    print *,'no good: nasty but s1!=0 or s2 not real'
		    goto 40
		endif
	    endif
*
	    ier0 = 0
	    call ffxlam(del2,xpi,dpipj,10,
     +		iold(3,irota),iold(4,irota),iold(7,irota) ,ier0)
*
*	    we can only handle del2=0 if p_i^2 = 0 (and thus m_i=m_{i+1})
*
	    if ( del2 .lt. 0 ) then
		if ( lwrite ) print *,'irota = ',irota,' seems OK'
		itype = 0
		goto 50
	    endif
	    if ( del2 .eq. 0 .and. izero .eq. 0 .and. xpi(iold(7,irota))
     +							.eq. 0 ) then
		izero = irota
		if ( lwrite ) print *,'del2=0, but we can try it'
	    else
		if ( lwrite ) print *,'no good, del2>=0: ',del2
	    endif
   40	continue
	    ier = ier + ier0
	    if ( izero .eq. 0 ) then
		call fferr(54,ier)
		itype = -1
		irota = 1
	    else
		irota = izero
		del2 = 0
		itype = 1
	    endif
	    goto 50
   41	continue
	    itype = 2
   50	continue
	if ( lwrite ) then
	    print *,'ffrot4: chose permutation no ',irota
	endif
*  #] find out which del2 is negative:
*  #[ rotate:
	do 20 i=1,13
	    xqi(i) = xpi(iold(i,irota))
	    do 10 j=1,10
		dqiqj(j,i) = dpipj(iold(j,irota),iold(i,irota))
   10	    continue
   20	continue
	if ( ii .eq. 5 ) then
	    do 120 i=1,10
		do 110 j=1,10
		    qiDqj(j,i) = isgrot(iold(j,irota),irota)*
     +				 isgrot(iold(i,irota),irota)*
     +			piDpj(iold(j,irota),iold(i,irota))
  110		continue
  120	    continue
	endif
	if ( lsmug .or. lnasty ) then
	    do 220 j=1,4
		do 210 i=1,4
		    chulp(i,j) = c2sisj(i,j)
  210		continue
  220	    continue
	    do 240 j=1,4
		do 230 i=1,4
		   c2sisj(i,j) = chulp(iold(i,irota),iold(j,irota))
  230		continue
  240	    continue
	endif
*  #] rotate:
*  #[ test output:
	if ( ltest ) then
	    ier0 = ier
	    call ffxhck(xqi,dqiqj,10,ier0)
	    call ffxuvw(xqi,dqiqj,ier0)
	    call ffxlam(del2p,xqi,dqiqj,10,3,4,7,ier0)
	    if ( del2p .ne. del2 .or. del2 .gt. 0 ) then
		print *,'ffrot4: error: rotated wrongly!!'
		print *,'del2  = ',del2
		print *,'del2p = ',del2p
	    endif
	    if ( ii .eq. 5 ) then
		call ffdot4(qiDqjp,xqi,dqiqj,10,ier0)
		do 990 i=1,10
		    do 980 j=1,10
			if ( xloss*abs(qiDqjp(j,i)-qiDqj(j,i)).gt.precx*
     +			     abs(qiDqjp(j,i)) ) print*,'ffrot4: error ',
     +			     'qiDqj(',j,i,') wrong: ',qiDqjp(j,i),
     +			     qiDqj(j,i),qiDqjp(j,i)-qiDqj(j,i)
  980		    continue
  990		continue
	    endif
	endif
*  #] test output:
*###] ffrot4:
	end
*###[ ffxlam:
	subroutine ffxlam(xlam,xpi,dpipj,ns,i1,i2,i3,ier)
*************************************************************************
*									*
*	calculate in a numerically stable way				*
*	xlam(xpi(i1),xpi(i2),xpi(i3)) =					*
*		= -((xpi(i1)+xpi(i2)-xpi(i3))/2)^2 + xpi(i1)*xpi(i2)	*
*	or a permutation						*
*	ier is the usual error flag.					*
*									*
*************************************************************************
	implicit none
*
*	arguments:
*
	integer ns,i1,i2,i3,ier
	DOUBLE PRECISION xlam,xpi(ns),dpipj(ns,ns)
*
*	local variables
*
	DOUBLE PRECISION s1,s2
*
*	common blocks
*
	include 'ff.h'
*
*	calculations
*
	if ( abs(xpi(i1)) .gt. max(abs(xpi(i2)),abs(xpi(i3))) ) then
	    s1 = xpi(i2)*xpi(i3)
	    if ( abs(dpipj(i1,i2)) .lt. abs(dpipj(i1,i3)) ) then
		s2 = ((dpipj(i1,i2) - xpi(i3))/2)**2
	    else
		s2 = ((dpipj(i1,i3) - xpi(i2))/2)**2
	    endif
	elseif ( abs(xpi(i2)) .gt. abs(xpi(i3)) ) then
	    s1 = xpi(i1)*xpi(i3)
	    if ( abs(dpipj(i1,i2)) .lt. abs(dpipj(i2,i3)) ) then
		s2 = ((dpipj(i1,i2) + xpi(i3))/2)**2
	    else
		s2 = ((dpipj(i2,i3) - xpi(i1))/2)**2
	    endif
	else
	    s1 = xpi(i1)*xpi(i2)
	    if ( abs(dpipj(i1,i3)) .lt. abs(dpipj(i2,i3)) ) then
		s2 = ((dpipj(i1,i3) + xpi(i2))/2)**2
	    else
		s2 = ((dpipj(i2,i3) + xpi(i1))/2)**2
	    endif
	endif
	xlam = s1 - s2
	if ( lwarn .and. abs(xlam) .lt. xloss*s2 )
     +		call ffwarn(71,ier,xlam,s2)
*###] ffxlam:
	end
*###[ ffdot4:
	subroutine ffdot4(piDpj,xpi,dpipj,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate the dotproducts pi.pj with				*
*									*
*		pi = si		i1=1,4					*
*		pi = p(i-3)	i1=5,10					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
	integer ns,ier
	DOUBLE PRECISION xpi(13),dpipj(10,13),piDpj(10,10)
	integer is1,is2,is3,ip1,ip2,ip3,i,j,ier0,ier1
	DOUBLE PRECISION xheck,xmax,xlosn,som,xmxp
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( ns .ne. 10 ) print *,'ffdot4: error: ns <> 10 '
	if ( ltest ) then
	    call ffxhck(xpi,dpipj,10,ier)
	    call ffxuvw(xpi,dpipj,ier)
	endif
*  #] check input:
*  #[ special case: already known:
	if ( idot.ge.3 ) then
	    do 2 i=1,10
		do 1 j=1,10
		    piDpj(j,i) = isgrot(iold(j,irota4),irota4)*
     +				 isgrot(iold(i,irota4),irota4)*
     +				fpij4(iold(j,irota4),iold(i,irota4))
    1		continue
    2	    continue
	    return
	endif
*  #] special case: already known:
*  #[ indices:
	ier1 = ier
	do 10 is1=1,4
	    is2 = is1 + 1
	    if ( is2 .eq. 5 ) is2 = 1
	    is3 = is2 + 1
	    if ( is3 .eq. 5 ) is3 = 1
	    ip1 = is1 + 4
	    ip2 = is2 + 4
	    if ( mod(is1,2) .eq. 1 ) then
		ip3 = 9
	    else
		ip3 = 10
	    endif
*  #] indices:
*  #[ all in one vertex:
*
*	    pi.pj, si.sj
*
	    piDpj(is1,is1) = xpi(is1)
	    piDpj(ip1,ip1) = xpi(ip1)
*
*	    si.s(i+1)
*
	    if ( xpi(is2) .le. xpi(is1) ) then
		piDpj(is1,is2) = (dpipj(is1,ip1) + xpi(is2))/2
	    else
		piDpj(is1,is2) = (dpipj(is2,ip1) + xpi(is1))/2
	    endif
	    piDpj(is2,is1) = piDpj(is1,is2)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(is1,is2)) .lt.
     +		xloss*min(xpi(is1),xpi(is2)) )call ffwarn(105,ier0,
     +		piDpj(is1,is2),min(xpi(is1),xpi(is2)))
	    ier1 = max(ier1,ier0)
*
*	    si.s(i+2)
*
	    if ( is1 .le. 2 ) then
		if ( xpi(is1) .le. xpi(is3) ) then
		    piDpj(is3,is1) = (dpipj(is3,ip3) + xpi(is1))/2
		else
		    piDpj(is3,is1) = (dpipj(is1,ip3) + xpi(is3))/2
		endif
		piDpj(is1,is3) = piDpj(is3,is1)
		ier0 = ier
		if ( lwarn .and. abs(piDpj(is1,is3)) .lt.
     +			xloss*min(xpi(is1),xpi(is3)) ) call ffwarn(106,
     +			ier0,piDpj(is1,is3),min(xpi(is1),xpi(is3)))
		ier1 = max(ier1,ier0)
	    endif
*
*	    pi.si
*
	    if ( abs(xpi(ip1)) .le. xpi(is1) ) then
		piDpj(ip1,is1) = (dpipj(is2,is1) - xpi(ip1))/2
	    else
		piDpj(ip1,is1) = (dpipj(is2,ip1) - xpi(is1))/2
	    endif
	    piDpj(is1,ip1) = piDpj(ip1,is1)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip1,is1)) .lt.
     +		xloss*min(abs(xpi(ip1)),xpi(is1))) call ffwarn(107,ier0,
     +		piDpj(ip1,is1),min(abs(xpi(ip1)),xpi(is1)))
	    ier1 = max(ier1,ier0)
*
*	    pi.s(i+1)
*
	    if ( abs(xpi(ip1)) .le. xpi(is2) ) then
		piDpj(ip1,is2) = (dpipj(is2,is1) + xpi(ip1))/2
	    else
		piDpj(ip1,is2) = (dpipj(ip1,is1) + xpi(is2))/2
	    endif
	    piDpj(is2,ip1) = piDpj(ip1,is2)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip1,is2)) .lt.
     +		xloss*min(abs(xpi(ip1)),xpi(is2))) call ffwarn(108,ier0,
     +		piDpj(ip1,is2),min(abs(xpi(ip1)),xpi(is2)))
	    ier1 = max(ier1,ier0)
*
*	    p(i+2).s(i)
*
	    if ( abs(xpi(ip3)) .le. xpi(is1) ) then
		piDpj(ip3,is1) = (dpipj(is1,is3) + xpi(ip3))/2
	    else
		piDpj(ip3,is1) = (dpipj(ip3,is3) + xpi(is1))/2
	    endif
	    if ( is1 .eq. 2 .or. is1 .eq. 3 )
     +			piDpj(ip3,is1) = -piDpj(ip3,is1)
	    piDpj(is1,ip3) = piDpj(ip3,is1)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip3,is1)) .lt.
     +		xloss*min(abs(xpi(ip3)),xpi(is1))) call ffwarn(109,ier0,
     +		piDpj(ip3,is1),min(abs(xpi(ip3)),xpi(is1)))
	    ier1 = max(ier1,ier0)
*
*  #] all in one vertex:
*  #[ all in one 3point:
*
*	    pi.s(i+2)
*
	    if ( min(abs(dpipj(is2,is1)),abs(dpipj(ip3,ip2))) .le.
     +		 min(abs(dpipj(ip3,is1)),abs(dpipj(is2,ip2))) ) then
		piDpj(ip1,is3) = (dpipj(ip3,ip2) + dpipj(is2,is1))/2
	    else
		piDpj(ip1,is3) = (dpipj(ip3,is1) + dpipj(is2,ip2))/2
	    endif
	    piDpj(is3,ip1) = piDpj(ip1,is3)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip1,is3)) .lt.
     +		xloss*min(abs(dpipj(ip3,ip2)),abs(dpipj(ip3,is1))) )
     +		call ffwarn(110,ier0,piDpj(ip1,is3),
     +		min(abs(dpipj(ip3,ip2)),abs(dpipj(ip3,is1))))
	    ier1 = max(ier1,ier0)
*
*	    p(i+1).s(i)
*
	    if ( min(abs(dpipj(is3,is2)),abs(dpipj(ip1,ip3))) .le.
     +		 min(abs(dpipj(ip1,is2)),abs(dpipj(is3,ip3))) ) then
		piDpj(ip2,is1) = (dpipj(ip1,ip3) + dpipj(is3,is2))/2
	    else
		piDpj(ip2,is1) = (dpipj(ip1,is2) + dpipj(is3,ip3))/2
	    endif
	    piDpj(is1,ip2) = piDpj(ip2,is1)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip2,is1)) .lt.
     +		xloss*min(abs(dpipj(ip1,ip3)),abs(dpipj(ip1,is2))) )
     +		call ffwarn(111,ier0,piDpj(ip2,is1),
     +		min(abs(dpipj(ip1,ip3)),abs(dpipj(ip1,is2))))
	    ier1 = max(ier1,ier0)
*
*	    p(i+2).s(i+1)
*
	    if ( min(abs(dpipj(is1,is3)),abs(dpipj(ip2,ip1))) .le.
     +		 min(abs(dpipj(ip2,is3)),abs(dpipj(is1,ip1))) ) then
		piDpj(ip3,is2) = (dpipj(ip2,ip1) + dpipj(is1,is3))/2
	    else
		piDpj(ip3,is2) = (dpipj(ip2,is3) + dpipj(is1,ip1))/2
	    endif
	    if ( is1 .eq. 2 .or. is1 .eq. 3 )
     +			piDpj(ip3,is2) = -piDpj(ip3,is2)
	    piDpj(is2,ip3) = piDpj(ip3,is2)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip3,is2)) .lt.
     +		xloss*min(abs(dpipj(ip2,ip1)),abs(dpipj(ip2,is3))) )
     +		call ffwarn(112,ier0,piDpj(ip3,is2),
     +		min(abs(dpipj(ip2,ip1)),abs(dpipj(ip2,is3))))
	    ier1 = max(ier1,ier0)
*
*  #] all in one 3point:
*  #[ all external 3point:
	    if ( idot.le.0 ) then
*
*	    pi.p(i+1)
*
	    if ( abs(xpi(ip2)) .le. abs(xpi(ip1)) ) then
		piDpj(ip1,ip2) = (dpipj(ip3,ip1) - xpi(ip2))/2
	    else
		piDpj(ip1,ip2) = (dpipj(ip3,ip2) - xpi(ip1))/2
	    endif
	    piDpj(ip2,ip1) = piDpj(ip1,ip2)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip1,ip2)) .lt.
     +		xloss*min(abs(xpi(ip1)),abs(xpi(ip2))) ) call
     +		ffwarn(113,ier0,piDpj(ip1,ip2),
     +		min(abs(xpi(ip1)),abs(xpi(ip2))))
	    ier1 = max(ier1,ier0)
*
*	    p(i+1).p(i+2)
*
	    if ( abs(xpi(ip3)) .le. abs(xpi(ip2)) ) then
		piDpj(ip2,ip3) = (dpipj(ip1,ip2) - xpi(ip3))/2
	    else
		piDpj(ip2,ip3) = (dpipj(ip1,ip3) - xpi(ip2))/2
	    endif
	    if ( is1 .eq. 2 .or. is1 .eq. 3 )
     +			piDpj(ip2,ip3) = -piDpj(ip2,ip3)
	    piDpj(ip3,ip2) = piDpj(ip2,ip3)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip2,ip3)) .lt.
     +		xloss*min(abs(xpi(ip2)),abs(xpi(ip3))) ) call
     +		ffwarn(114,ier0,piDpj(ip2,ip3),
     +		min(abs(xpi(ip2)),abs(xpi(ip3))))
	    ier1 = max(ier1,ier0)
*
*	    p(i+2).p(i)
*
	    if ( abs(xpi(ip1)) .le. abs(xpi(ip3)) ) then
		piDpj(ip3,ip1) = (dpipj(ip2,ip3) - xpi(ip1))/2
	    else
		piDpj(ip3,ip1) = (dpipj(ip2,ip1) - xpi(ip3))/2
	    endif
	    if ( is1 .eq. 2 .or. is1 .eq. 3 )
     +			piDpj(ip3,ip1) = -piDpj(ip3,ip1)
	    piDpj(ip1,ip3) = piDpj(ip3,ip1)
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(ip3,ip1)) .lt.
     +		xloss*min(abs(xpi(ip3)),abs(xpi(ip1))) ) call
     +		ffwarn(115,ier0,piDpj(ip3,ip1),
     +		min(abs(xpi(ip3)),abs(xpi(ip1))))
	    ier1 = max(ier1,ier0)
*
	    else
*
*		idot > 0: copy the dotproducts from fpij4
*
		piDpj(ip1,ip2) = isgrot(iold(ip1,irota4),irota4)*
     +				 isgrot(iold(ip2,irota4),irota4)*
     +				fpij4(iold(ip1,irota4),iold(ip2,irota4))
		piDpj(ip2,ip1) = piDpj(ip1,ip2)
		piDpj(ip1,ip3) = isgrot(iold(ip1,irota4),irota4)*
     +				 isgrot(iold(ip3,irota4),irota4)*
     +				fpij4(iold(ip1,irota4),iold(ip3,irota4))
		piDpj(ip3,ip1) = piDpj(ip1,ip3)
		piDpj(ip2,ip3) = isgrot(iold(ip2,irota4),irota4)*
     +				 isgrot(iold(ip3,irota4),irota4)*
     +				fpij4(iold(ip2,irota4),iold(ip3,irota4))
		piDpj(ip3,ip2) = piDpj(ip2,ip3)
	    endif
   10	continue
*  #] all external 3point:
*  #[ real 4point:
*
*	the awkward 4point dotproducts:
*
	piDpj(9,9) = xpi(9)
	piDpj(10,10) = xpi(10)
	if ( idot.le.0 ) then
*--#[ p5.p7:
	if ( abs(xpi(7)) .lt. abs(xpi(5)) ) then
	    piDpj(5,7) = (-xpi(7) - dpipj(5,11))/2
	else
	    piDpj(5,7) = (-xpi(5) - dpipj(7,11))/2
	endif
	xmax = min(abs(xpi(5)),abs(xpi(7)))
	if ( abs(piDpj(5,7)) .lt. xloss*xmax ) then
*
*	    second try (old algorithm)
*
	    if ( lwrite ) print *,'piDpj(5,7) = ',piDpj(5,7),xmax
	    if ( min(abs(dpipj(6,9)),abs(dpipj(8,10))) .le.
     +		 min(abs(dpipj(8,9)),abs(dpipj(6,10))) ) then
		som = (dpipj(6,9) + dpipj(8,10))/2
	    else
		som = (dpipj(8,9) + dpipj(6,10))/2
	    endif
	    xmxp = min(abs(dpipj(6,9)),abs(dpipj(8,9)))
	    if ( lwrite ) print *,'piDpj(5,7)+= ',som,xmxp
	    if ( xmxp.lt.xmax ) then
		piDpj(5,7) = som
		xmax = xmxp
	    endif
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(5,7)) .lt.
     +		xloss*min(abs(dpipj(6,9)),abs(dpipj(8,9))) ) call
     +		ffwarn(116,ier0,piDpj(5,7),xmax)
	    ier1 = max(ier1,ier0)
	endif
	piDpj(7,5) = piDpj(5,7)
*--#] p5.p7:
*--#[ p6.p8:
	if ( abs(xpi(6)) .lt. abs(xpi(8)) ) then
	    piDpj(6,8) = (-xpi(6) - dpipj(8,11))/2
	else
	    piDpj(6,8) = (-xpi(8) - dpipj(6,11))/2
	endif
	xmax = min(abs(xpi(6)),abs(xpi(8)))
	if ( abs(piDpj(6,8)) .lt. xloss*xmax ) then
*
*	    second try (old algorithm)
*
	    if ( lwrite ) print *,'piDpj(6,8) = ',piDpj(6,8),xmax
	    if ( min(abs(dpipj(5,9)),abs(dpipj(7,10))) .le.
     +		 min(abs(dpipj(7,9)),abs(dpipj(5,10))) ) then
		som = (dpipj(5,9) + dpipj(7,10))/2
	    else
		som = (dpipj(7,9) + dpipj(5,10))/2
	    endif
	    xmxp = min(abs(dpipj(5,9)),abs(dpipj(7,9)))
	    if ( lwrite ) print *,'piDpj(6,8)+= ',som,xmxp
	    if ( xmxp.lt.xmax ) then
		piDpj(6,8) = som
		xmax = xmxp
	    endif
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(6,8)) .lt.
     +		xloss*min(abs(dpipj(5,9)), abs(dpipj(7,9))) ) call
     +		ffwarn(117,ier0,piDpj(6,8),xmax)
	    ier1 = max(ier1,ier0)
	endif
	piDpj(8,6) = piDpj(6,8)
*--#] p6.p8:
*--#[ p9.p10:
	if ( abs(xpi(9)) .lt. abs(xpi(10)) ) then
	    piDpj(9,10) = (-xpi(9) - dpipj(10,13))/2
	else
	    piDpj(9,10) = (-xpi(10) - dpipj(9,13))/2
	endif
	xmax = min(abs(xpi(9)),abs(xpi(10)))
	if ( abs(piDpj(9,10)) .lt. xloss*xmax ) then
*
*	  second try (old algorithm)
*
	    if ( lwrite ) print *,'piDpj(9,10) = ',piDpj(9,10),xmax
	    if ( min(abs(dpipj(5,6)),abs(dpipj(7,8))) .le.
     +		 min(abs(dpipj(7,6)),abs(dpipj(5,8))) ) then
		som = (dpipj(5,6) + dpipj(7,8))/2
	    else
		som = (dpipj(7,6) + dpipj(5,8))/2
	    endif
	    xmxp = min(abs(dpipj(5,6)),abs(dpipj(7,6)))
	    if ( lwrite ) print *,'piDpj(9,10)+= ',som,xmxp
	    if ( xmxp.lt.xmax ) then
		piDpj(9,10) = som
		xmax = xmxp
	    endif
	    ier0 = ier
	    if ( lwarn .and. abs(piDpj(9,10)) .lt.
     +		xloss*min(abs(dpipj(5,6)),abs(dpipj(7,6))) ) call
     +		ffwarn(118,ier0,piDpj(9,10),xmax)
	    ier1 = max(ier1,ier0)
	endif
	piDpj(10,9) = piDpj(9,10)
*--#] p9.p10:
	else
*--#[ copy:
*
*	    idot > 1: just copy from fpij4...
*
	    piDpj(5,7) = isgrot(iold(5,irota4),irota4)*
     +			 isgrot(iold(7,irota4),irota4)*
     +			fpij4(iold(5,irota4),iold(7,irota4))
	    piDpj(7,5) = piDpj(5,7)
	    piDpj(6,8) = isgrot(iold(6,irota4),irota4)*
     +			 isgrot(iold(8,irota4),irota4)*
     +			fpij4(iold(6,irota4),iold(8,irota4))
	    piDpj(8,6) = piDpj(6,8)
	    piDpj(9,10)= isgrot(iold(9,irota4),irota4)*
     +			 isgrot(iold(10,irota4),irota4)*
     +			fpij4(iold(9,irota4),iold(10,irota4))
	    piDpj(10,9) = piDpj(9,10)
*--#] copy:
	endif
	ier = ier1
*  #] real 4point:
*  #[ check:
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-2-mod(ier,50))
	    do 40 i = 1,10
		xheck = piDpj(i,5)
		xmax = abs(piDpj(i,5))
		do 20 j=6,8
		    xheck = xheck + piDpj(j,i)
		    xmax = max(abs(piDpj(j,i)),xmax)
   20		continue
		if ( xlosn*abs(xheck) .gt. precx*xmax ) print *,
     +			'ffdot4: error: dotproducts with p(',i,
     +			') wrong: ',(j,piDpj(i,j),j=5,8),xheck,ier
		xheck = piDpj(i,5) + piDpj(i,6) + piDpj(i,9)
		xmax = max(abs(piDpj(i,5)),abs(piDpj(i,6)),abs(
     +				piDpj(i,9)))
		if ( xlosn*abs(xheck) .gt. precx*xmax ) print *,
     +			'ffdot4: error: dotproducts with p(',i,
     +			') wrong: ',5,piDpj(i,5),6,piDpj(i,6),
     +			9,piDpj(i,9),xheck,ier
		xheck = piDpj(i,5) + piDpj(i,8) + piDpj(i,10)
		xmax = max(abs(piDpj(i,5)),abs(piDpj(i,8)),abs(
     +				piDpj(i,10)))
		if ( xlosn*abs(xheck) .gt. precx*xmax ) print *,
     +			'ffdot4: error: dotproducts with p(',i,
     +			') wrong: ',5,piDpj(i,5),8,piDpj(i,8),
     +			10,piDpj(i,10),xheck,ier
		do 30 j=1,10
		    if ( piDpj(i,j) .ne. piDpj(j,i) ) print *,
     +			'ffdot4: error: piDpj(',i,j,') <> piDpj',j,i,')'
   30		continue
   40	    continue
	endif
*  #] check:
*###] ffdot4:
	end
*###[ ffxuvw:
	subroutine ffxuvw(xpi,dpipj,ier)
***#[*comment:***********************************************************
*									*
*	check the consistency of the s,t-like variables u,v,w and their	*
*	differences.							*
*									*
*	Input:	xpi	real(13)	the invariants			*
*		dpipj	real(10,13)	their differences		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xpi(13),dpipj(10,13)
*
*	local variables
*
	integer i,j
	DOUBLE PRECISION xheck,xmax
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check!:
	xmax = max(abs(xpi(5)),abs(xpi(6)),abs(xpi(7)),
     +		       abs(xpi(8)),abs(xpi(9)),abs(xpi(10)))
	xheck = -xpi(11)+xpi(5)+xpi(6)+xpi(7)+xpi(8)-xpi(9)-xpi(10)
	if ( xloss*abs(xheck) .gt. precx*xmax ) print *,'u wrong!',
     +		xpi(11),+xpi(5)+xpi(6)+xpi(7)+xpi(8)-xpi(9)-xpi(10),
     +		xheck,xmax
	xheck = -xpi(12)-xpi(5)+xpi(6)-xpi(7)+xpi(8)+xpi(9)+xpi(10)
	if ( xloss*abs(xheck) .gt. precx*xmax ) print *,'v wrong!',
     +		xpi(12),-xpi(5)+xpi(6)-xpi(7)+xpi(8)+xpi(9)+xpi(10),
     +		xheck,xmax
	xheck = -xpi(13)+xpi(5)-xpi(6)+xpi(7)-xpi(8)+xpi(9)+xpi(10)
	if ( xloss*abs(xheck) .gt. precx*xmax ) print *,'w wrong!',
     +		xpi(13),xpi(5)-xpi(6)+xpi(7)-xpi(8)+xpi(9)+xpi(10),
     +		xheck,xmax
	do 20 i=10,13
	    do 10 j=1,10
		xheck = dpipj(j,i) - xpi(j) + xpi(i)
		xmax = max(abs(xpi(i)),abs(xpi(j)))
		if ( xloss*abs(xheck) .gt. precx*xmax ) print *,
     +		    'ffxuvw: dpipj(',j,i,') != xpi(',j,')-xpi(',i,')',
     +		    dpipj(j,i),xpi(j),xpi(i),xheck
   10	    continue
   20	continue
*  #] check!:
*###] ffxuvw:
	end
*###[ ffgdt4:
	subroutine ffgdt4(piDpj,xpip,dpipjp,xpi,dpipj,itype,ier)
***#[*comment:***********************************************************
*									*
*	calculate the dotproducts pi.pj with				*
*	and store results in common when asked for			*
*									*
*		pi = si		i1=1,4					*
*		pi = p(i-3)	i1=5,10					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE PRECISION piDpj(10,10),xpip(13),dpipjp(10,13),xpi(13),
     +		dpipj(10,13)
	integer itype,ier
*
*	local variables
*
	integer i,j,iperm(3,4),ier0,ii(6)
	DOUBLE PRECISION del2,dl3p,qiDqj(10,10)
	save iperm
*
*	common blocks:
*
	include 'ff.h'
*
*	data
*
*	the external threepoint vertices on which we have enough information
*
	data iperm/5,6,9, 6,7,10, 7,8,9, 8,5,10/
*
*  #] declarations:
*  #[ get dotproducts:
*
*	Calculate the dotproducts
*
	call ffdot4(piDpj,xpip,dpipjp,10,ier)
	if ( ldot .and. idot.lt.3 ) then
	    do 65 i=1,10
		do 64 j=1,10
		    fpij4(iold(j,irota4),iold(i,irota4)) =
     +			isgrot(iold(j,irota4),irota4)*
     +			isgrot(iold(i,irota4),irota4)*piDpj(j,i)
   64		continue
   65	    continue
	    if ( ltest .and. itype .ne. 2 .and. idot.eq.0 ) then
*		(we messed around with the xpi if itype=2)
		ier0 = 0
		call ffdot4(qiDqj,xpi,dpipj,10,ier0)
		do 72 i=1,10
		    do 71 j=1,10
			if ( xloss*abs(qiDqj(j,i)-fpij4(j,i)) .gt.
     +				precx*abs(fpij4(j,i)) ) then
			    print *,
     +			    'ffxd0: error: fpij4(',j,i,') not correct!',
     +			    fpij4(j,i),qiDqj(j,i),fpij4(j,i)-qiDqj(j,i),
     +			    ' irota4 = ',irota4
			endif
   71		    continue
   72		continue
	    endif
	endif
	if ( ltest ) then
*	    check whether the diagram is physical
	    ier0 = ier
	    do 60 i=1,4
*		if all spacelike everything is OK!
		if ( xpi(iperm(1,i)).lt.0 .and. xpi(iperm(2,i)).lt.0
     +			.and. xpi(iperm(3,i)).lt.0 ) goto 60
		call ffdel2(del2,piDpj,10,iperm(1,i),iperm(2,i),
     +						iperm(3,i), 1,ier0)
		if ( del2 .gt. 0 ) then
		    call fferr(44,ier)
*		    if ( lwrite )
		    print *,'vertex ',iperm(1,i),
     +			iperm(2,i),iperm(3,i),' has del2 ',del2
		    print *,'xpi = ',xpi
		endif
   60	    continue
	endif
	if ( ldot .or. ltest ) then
	    if ( idot.lt.2 ) then
		ii(1)= 5
		ii(2)= 6
		ii(3)= 7
		ii(4)= 8
		ii(5)= 9
		ii(6)= 10
		fidel3 = ier
		call ffdl3p(dl3p,piDpj,10,ii,ii,fidel3)
		fdel3 = dl3p
	    else
		dl3p = fdel3
	    endif
	    if ( dl3p .lt. 0 ) then
		call fferr(44,ier)
*		if ( lwrite )
		print *,'overall vertex has del3 ',dl3p
		print *,'xpi = ',xpi
	    endif
	endif
*  #] get dotproducts:
*###] ffgdt4:
	end
*###[ ffx2ir:
	subroutine ffx2ir(cs1,cs2,xpip,dpipjp,ier)
***#[*comment:***********************************************************
*									*
*	Get the terms to correct for the second IR pole which is	*
*	treated incorrectly if the first one is regulated with a small	*
*	mass lam and they are adjacent.  It is assumed that xpi(3)=	*
*	xpi(4)=xpi(7)=0, xpi(1)=xpi(8), xpi(2)=xpi(6).  The correction	*
*	terms are							*
*									*
*	cs1 = -C0(m2^2,0,lam^2;m2^2,0,p10^2)/(s-m1^2)			*
*	cs2 = +C0(m2^2,lam^2,0;m2^2,0,p10^2)/(s-m1^2)			*
*									*
*	when xpi(4)=lam^2=delta is taken in the D0,			*
*									*
*	cs1 = -C0(lam^2,0,m1^2;0,m1^2,p9^2)/(t-m2^2)			*
*	cs2 = +C0(0,lam^2,m1^2;0,m1^2,p9^2)/(t-m2^2)			*
*									*
*	when xpi(3)=lam^2.  Not yet tested.				*
*									*
*				10-oct-1991 Geert Jan van Oldenborgh	*
*									*
*	Input:	xpip(13)	(real)	usual 4point pi.pi		*
*		dpipjp(10,13)	(real)	xpip(i) - xpip(j)		*
*	output:	xpip(13)	(real)	usual 4point pi.pi modified	*
*		dpipjp(10,13)	(real)	xpip(i) - xpip(j)  modified	*
*		cs1,cs2		(complex)				*
*		ier		(integer)				*
*	calls:	ffxc0							*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cs1,cs2
	DOUBLE PRECISION xpip(13),dpipjp(10,13)
*
*	local vars
*
	integer itest,ier0,ier1,i,j,iinx(6,4)
	DOUBLE COMPLEX cc0
	DOUBLE PRECISION xpi3(6),dpipj3(6,6)
	save itest,iinx
*
*	common
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	data
*
*	3=put mass on xpi(3)
*	4=put mass on xpi(4)
	data itest /4/
	data iinx /2,3,4,6,7,10,
     +		   1,3,4,9,7,8,
     +		   1,2,4,5,10,8,
     +		   1,2,3,5,6,9/
*
*  #] declarations: 
*  #[ check input:
	if ( ltest ) then
	    if ( xpip(3).ne.0 .or. xpip(4).ne.0 .or. xpip(7).ne.0 )
     +		print *,'ffx2ir: wrong input: vertex (3,4,7) not all 0',
     +		xpip(3),xpip(4),xpip(7)
	    ier0 = 0
	    call ffxhck(xpip,dpipjp,10,ier0)
	    if ( ier0 .ne. 0 ) print *,'ffx2ir: error: input wrong'
	endif
*  #] check input: 
*  #[ work 3:
	if ( itest .eq. 3 ) then
	if ( lwrite ) then
	    print *,'ffx2ir: giving xpi(3) a mass ',delta
	endif
*
*	modify xpip,dpipjp
*
	xpip(3) = delta
	do 10 i=1,10
	    dpipjp(i,3) = dpipjp(i,3) - delta
   10	continue
	do 20 i=1,13
	    dpipjp(3,i) = dpipjp(3,i) + delta
   20	continue
*
*	call first C0
*
	do 120 i=1,6
	    xpi3(i) = xpip(iinx(i,2))
	    do 110 j=1,6
		dpipj3(j,i) = dpipjp(iinx(j,2),iinx(i,2))
  110	    continue
  120	continue
	idsub = idsub + 1
	ier1 = 0
	if ( lwrite ) print *,'ffx2ir: calling first C0'
	call ffxc0a(cc0,xpi3,dpipj3,ier1)
	cs1 = -cc0/DBLE(dpipjp(9,2))
*
*	call second C0
*
	xpi3(2) = 0
	xpi3(3) = delta
	do 130 i=1,6
	    dpipj3(i,2) = dpipj3(i,2) + delta
	    dpipj3(i,3) = dpipj3(i,3) - delta
  130	continue
	do 140 i=1,6
	    dpipj3(2,i) = dpipj3(2,i) - delta
	    dpipj3(3,i) = dpipj3(3,i) + delta
  140	continue
	idsub = idsub + 1
	ier0 = 0
	if ( lwrite ) print *,'ffx2ir: calling second C0'
	call ffxc0a(cc0,xpi3,dpipj3,ier0)
	cs2 = +cc0/DBLE(dpipjp(9,2))
	ier1 = max(ier1,ier0)
	ier = ier + ier1
*  #] work 3: 
*  #[ work 4:
	elseif ( itest .eq. 4 ) then
	if ( lwrite ) then
	    print *,'ffx2ir: giving xpi(4) a mass ',delta
	endif
*
*	modify xpip,dpipjp
*
	xpip(4) = delta
	do 210 i=1,10
	    dpipjp(i,4) = dpipjp(i,4) - delta
  210	continue
	do 220 i=1,13
	    dpipjp(4,i) = dpipjp(4,i) + delta
  220	continue
*
*	call first C0
*
	do 320 i=1,6
	    xpi3(i) = xpip(iinx(i,1))
	    do 310 j=1,6
		dpipj3(j,i) = dpipjp(iinx(j,1),iinx(i,1))
  310	    continue
  320	continue
	idsub = idsub + 1
	ier1 = 0
	if ( lwrite ) print *,'ffx2ir: calling first C0'
	call ffxc0a(cc0,xpi3,dpipj3,ier1)
	cs1 = -cc0/DBLE(dpipjp(10,1))
*
*	call second C0
*
	xpi3(3) = 0
	xpi3(2) = delta
	do 330 i=1,6
	    dpipj3(i,3) = dpipj3(i,3) + delta
	    dpipj3(i,2) = dpipj3(i,2) - delta
  330	continue
	do 340 i=1,6
	    dpipj3(3,i) = dpipj3(3,i) - delta
	    dpipj3(2,i) = dpipj3(2,i) + delta
  340	continue
	idsub = idsub + 1
	ier0 = 0
	if ( lwrite ) print *,'ffx2ir: calling second C0'
	call ffxc0a(cc0,xpi3,dpipj3,ier0)
	cs2 = +cc0/DBLE(dpipjp(10,1))
	ier1 = max(ier1,ier0)
	ier = ier + ier1
*  #] work 4: 
*  #[ error:
	else
	print *,'ffx2ir: error: itest should be either 3 or 4!',itest
	endif
*  #] error: 
*  #[ print:
	if ( lwrite ) then
	    print *,'   cs1 = ',cs1
	    print *,'   cs2 = ',cs2
	endif
*  #] print: 
*###] ffx2ir: 
	end
*(##[ ffxd0p:
	subroutine ffxd0p(cs4,ipi12,isoort,cfac,xpi,dpipj,piDpj,
     +		xqi,dqiqj,qiDqj,ai,daiaj,ldel2s,ier)
***#[*comment:***********************************************************
*									*
*	calculate D0/pi^2/(A1*A2*A3*A4/dt3t4)				*
*									*
*		     = C0(t1,t2,t3) - C0(t1,t2,t4)			*
*									*
*	The transformed momenta of the fourpoint functions are		*
*	input.								*
*									*
*	Input:	xpi(10)		untransformed fourpoint momenta		*
*		dpipj(10,10)	differences of xpi			*
*		piDpj(10,10)	dotproducts of xpi			*
*		xqi(10)		transformed fourpoint momenta		*
*		dqiqj(10,10)	differences of xqi			*
*		qiDqj(10,10)	dotproducts of xqi			*
*		ai(4)		the transformation parameters		*
*		daiaj(4,4)	their deifferences			*
*		ldel2s		if .TRUE. we took out factors delta	*
*									*
*	Output:	cs4(170)	not added (assumed 0 on input)		*
*		cfac		the factor of cs4 from C0 (ie lam(pi))	*
*		ier		0=ok 1=inaccurate 2=error		*
*									*
*	Calls:	ffxc0p,ffpi34,ffxhck,ffdl3m,ffdel2,ffdel3,...		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX cs4(175),cfac
	integer ipi12(26),isoort(16),ier
	logical ldel2s
	DOUBLE PRECISION xpi(10),dpipj(10,10),piDpj(10,10),
     +		xqi(10),dqiqj(10,10),qiDqj(10,10),ai(4),daiaj(4,4)
*
*	local variables
*
	integer i,j,k,ip,jp,m,ilogi(6),ii(6,2),jj(6,2),ier0,ier1,
     +		is1,is2
	DOUBLE COMPLEX c,clogi(6),cipi
	DOUBLE PRECISION xpi3(6,3:4),dpipj3(6,6,3:4),piDpj3(6,6,3:4),
     +		absc,del2,del2s(3,3:4),del3(3:4),del3mi(6,3:4),
     +		del4,etalam(3:4),etami(6,3:4),ddel2s(2:3),delpsi(3,3:4),
     +		alph(3),blph(3),sdel2,hulp,som,s(4),smax,xmax
	DOUBLE COMPLEX cpi(6,3:4),cpiDpj(6,6,3:4),cdpipj(6,6,3:4),
     +		cetalm(3:4),cetami(6,3:4),calph(3),csdel2,
     +		cel2s(3,3:4),celpsi(3,3:4),zqi(10),zqiDqj(10,10),
     +		zdqiqj(10,10),cddl2s(2:3),cqi3(6,3:4),cqiqj3(6,6,3:4),
     +		cqiDqj3(6,6,3:4)
	logical lcroot,lb
	save ii,jj
*
*	common blocks:
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	statement function:
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data ii/1,2,3,5,6,9,1,2,3,5,6,9/
	data jj/1,2,4,5,10,8,1,2,4,5,10,8/
*
*  #] declarations:
*  #[ check input:
	if ( ltest ) then
*	    call ffxhck(xpi,dpipj,10,ier)
*	    call ffxhck(xqi,dqiqj,10,ier)
*	    if ( ier .ne. 0 ) print *,'(input tested by ffxd0p)'
	endif
*  #] check input:
*  #[ preparation:
*	Note that the piDpj3(,,3) contain now the threepoint function
*	with s3, (,,4) with s4 (and NOT *without* as before)
	call ffpi43(xpi3(1,3),dpipj3(1,1,3),piDpj3(1,1,3),
     +		xqi,dqiqj,qiDqj,7-3,ier)
	call ffpi43(xpi3(1,4),dpipj3(1,1,4),piDpj3(1,1,4),
     +		xqi,dqiqj,qiDqj,7-4,ier)
*
*	set the logarithms to be calculated to -999
*
	do 40 i=1,6
	    clogi(i) = 0
	    ilogi(i) = 0
   40	continue
	if ( ai(1) .lt. 0 .neqv. ai(2) .lt. 0 ) then
	    ilogi(1) = -999
	    ilogi(4) = -999
	endif
	if ( ai(2) .lt. 0 .neqv. ai(3) .lt. 0 ) then
	    ilogi(2) = -999
	endif
	if ( ai(3) .lt. 0 .neqv. ai(1) .lt. 0 ) then
	    ilogi(3) = -999
	endif
	if ( ai(2) .lt. 0 .neqv. ai(4) .lt. 0 ) then
	    ilogi(5) = -999
	endif
	if ( ai(4) .lt. 0 .neqv. ai(1) .lt. 0 ) then
	    ilogi(6) = -999
	endif
*
*  #] preparation:
*  #[ determinants:
*
*	some determinants
*
	if ( lwrite ) print '(a)','  ##[ determinants:'
*
*	note that not all errors are additive, only when a previous
*	result is used as input do we need to add ther ier's, otherwise
*	we can take the maximum value to get a decent estimate of the
*	number of digits lost.
*
	ier1 = ier
	if ( .not.ldel2s ) then
	    ier0 = ier
	    call ffdel2(del2,qiDqj,10, 5,6,9, 0,ier0)
	    ier1 = max(ier1,ier0)
	else
	    s(1) = xqi(5)*xqi(3)
	    s(2) = qiDqj(5,3)**2
	    del2 = s(1) - s(2)
	    if ( abs(del2) .lt. xloss*s(2) ) ier1 = 100
	endif
	if ( ier1 .ne. ier ) then
	    ier0 = ier
	    call ffdel4(del4,xpi,piDpj,10,ier0)
	    if ( ldel2s ) then
		hulp = -(ai(1)*ai(2)*ai(3)*ai(4)/xqi(3))**2 * del4
	    else
		hulp = -(2*ai(1)*ai(2)*ai(3)*ai(4)/dqiqj(3,4))**2 * del4
	    endif
	    if ( lwrite ) then
		print *,'del2 was :',del2
		print *,'  and is :',hulp
	    endif
	    del2 = hulp
	    ier1 = ier0
	    fdel4s = del4
	else
	    if ( ldel2s ) then
		fdel4s = -del2*(xqi(3)/ai(1)*ai(2)*ai(3)*ai(4))**2
	    else
		fdel4s=-del2*(dqiqj(3,4)/(2*ai(1)*ai(2)*ai(3)*ai(4)))**2
	    endif
	endif
	if ( del2 .gt. 0 ) then
*	    use complex routines
*	    call fferr(44,ier)
	    lcroot = .TRUE.
	    sdel2 = isgnal*sqrt(del2)
	    csdel2 = DCMPLX(x0,sdel2)
	elseif ( del2 .eq. 0 ) then
	    call fferr(45,ier)
	    return
	else
	    lcroot = .FALSE.
	    sdel2 = isgnal*sqrt(-del2)
	endif
	ier0 = ier
	call ffdl3s(del3(3),xpi,piDpj,ii,10,ier0)
	ier1 = max(ier0,ier1)
	if ( lwrite ) print *,'del3s(untransformed) 3 = ',del3(3)
	ier0 = ier
	call ffdl3s(del3(4),xpi,piDpj,jj,10,ier0)
	ier1 = max(ier1,ier0)
	if ( lwrite ) print *,'del3s(untransformed) 4 = ',del3(4)
	del3(3) = ai(1)**2*ai(2)**2*ai(3)**2*del3(3)
	del3(4) = ai(1)**2*ai(2)**2*ai(4)**2*del3(4)
	do 108 m=3,4
	    ier0 = ier
	    if ( .not.ldel2s ) then
		call ffdl3m(del3mi(1,m),.TRUE.,del3(m),del2,xpi3(1,m)
     +			,dpipj3(1,1,m),piDpj3(1,1,m), 6, 4,5,6,1,3,ier0)
	    else
*
*		the special case del2s = 0.  Note that del3mi(i) and
*		del3mi(i+3) are used in S_{i-1}.
*
		call ffdl3m(del3mi(1,m),.FALSE.,x0,x0,xpi3(1,m),
     +		   dpipj3(1,1,m),piDpj3(1,1,m), 6, 4,3,0, 1,2,ier0)
		ier1= max(ier1,ier0)
		ier0 = ier
		call ffdl3m(del3mi(5,m),.FALSE.,x0,x0,xpi3(1,m),
     +		   dpipj3(1,1,m),piDpj3(1,1,m), 6, 4,3,0, 5,2,ier0)
		del3mi(3,m) = 0
		del3mi(4,m) = 0
	    endif
	    ier1 = max(ier1,ier0)
	    do 105 i=1,3
		j = i+1
		if ( j .eq. 4 ) j = 1
		ip = i
		jp = j
		if ( m .eq. 4 ) then
		    if ( jp .eq. 3 ) jp = 4
		    if ( ip .eq. 3 ) ip = 4
		endif
		if ( i.eq.1 .and. m.eq.4 ) then
		    del2s(1,4) = del2s(1,3)
		else
		    ier0 = ier
		    call ffdel2(del2s(i,m),piDpj,10,inx(ip,jp),ip,
     +				jp,1,ier0)
		    del2s(i,m) = ai(ip)**2*ai(jp)**2*del2s(i,m)
		    ier1 = max(ier1,ier0)
		endif
		k = i-1
		if ( k .eq. 0 ) k = 3
		ier0 = ier
		if ( .not.ldel2s ) then
		    call ffdl2p(delpsi(i,m),xpi3(1,m),dpipj3(1,1,m),
     +		    	piDpj3(1,1,m),i+3,j+3,k+3,i,j,k,6,ier0)
		else
		    call ffdl2t(delpsi(i,m),qiDqj, m,5, ip,jp,inx(ip,jp)
     +			,+1,+1, 10,ier0)
		endif
		ier1 = max(ier1,ier0)
		etami(i,m) = del3mi(i,m)/del2
		if ( ldel2s .and. i.gt.1 )
     +			etami(i+3,m) = del3mi(i+3,m)/del2
  105	    continue
	    etalam(m) = del3(m)/del2
  108	continue
*
*	the error analysis
*
	ier = ier1
*
*	get alpha,1-alpha
*
	if ( .not. lcroot ) then
	    if ( .not.ldel2s ) then
		if ( xpi3(5,3).eq.0 .and. (piDpj3(5,6,3).gt.0 .eqv.
     +			sdel2.gt.0) ) then
		    alph(1) = -xpi3(6,3)/(piDpj3(5,6,3)+sdel2)
		    alph(3) = -xpi3(4,3)/(piDpj3(5,4,3)-sdel2)
		    lb = .FALSE.
		else
		    lb = .TRUE.
		    call ffroot(blph(1),alph(1),xpi3(5,3),
     +			-piDpj3(5,6,3),xpi3(6,3),sdel2,ier)
		    call ffroot(alph(3),blph(3),xpi3(5,3),
     +			-piDpj3(5,4,3),xpi3(4,3),sdel2,ier)
		endif
*		We cannot change the sign as it is fixed by the choice
*		of sign in fftrans (sqrt(delta(s3,s4))) WRONG
*		if ( l4also .and. ( alph(1) .gt. 1 .or. alph(1) .lt. 0
*     +		   ) .and. abs(blph(1)-x05) .lt. abs(alph(1)-x05) ) then
*		    alph(1) = blph(1)
*		    alph(3) = blph(3)
*		    sdel2 = -sdel2
*		    isgnal = -isgnal
*		endif
	    else
		alph(1) = 1
		alph(3) = 0
	    endif
	    cfac = 2*sdel2
	    if (lwrite) then
		print *,'slam   = ',2*sdel2
		print *,'del2s3 = ',(del2s(i,3),i=1,3)
		print *,'del2s4 = ',(del2s(i,4),i=1,3)
		print *,'del2ps3= ',(delpsi(i,3),i=1,3)
		print *,'del2ps4= ',(delpsi(i,4),i=1,3)
		print *,'del3mi3= ',(del3mi(i,3),i=1,3)
		print *,'del3mi4= ',(del3mi(i,4),i=1,3)
		print *,'etami3 = ',(etami(i,3),i=1,3)
		print *,'etami4 = ',(etami(i,4),i=1,3)
		print *,'eta3   = ',-4*del3(3)
		print *,'eta4   = ',-4*del3(4)
		print *,'alpha  = ',alph(1),alph(3)
		print *,'ier    = ',ier
	    endif
	else
	    do 4 k=3,4
		do 3 i=1,6
		    cpi(i,k) = xpi3(i,k)
		    do 2 j=1,6
			cdpipj(j,i,k) = dpipj3(j,i,k)
			cpiDpj(j,i,k) = piDpj3(j,i,k)
    2		    continue
    3		continue
    4	    continue
	    if ( .not.ldel2s ) then
		call ffcoot(c,calph(1),cpi(5,3),-cpiDpj(5,6,3),
     +			cpi(6,3),csdel2,ier)
		call ffcoot(calph(3),c,cpi(5,3),-cpiDpj(5,4,3),
     +			cpi(4,3),csdel2,ier)
	    else
		calph(1) = 1
		calph(3) = 0
	    endif
	    cfac = 2*csdel2
	    if (lwrite) then
		print *,'slam   =',cfac
		print *,'eta3   =',-4*del3(3)
		print *,'eta4   =',-4*del3(4)
		print *,'alpha  =',calph(1),calph(3)
		print *,'ier    = ',ier
	    endif
	endif
	if ( lwrite ) print '(a)','  ##] determinants:'
*  #] determinants:
*  #[ convert to complex:
	if ( lcroot ) then
	    do 110 k=3,4
		cetalm(k) = etalam(k)
		do 109 i=1,3
		    cel2s(i,k) = del2s(i,k)
		    celpsi(i,k) = delpsi(i,k)
		    cetami(i,k) = etami(i,k)
  109		continue
  110	    continue
	endif
*  #] convert to complex:
*  #[ simple case:
	if ( ldel2s .or. abs(dqiqj(3,4)) .lt. xloss*abs(xqi(3)) ) then
	    if ( .not.lsmug .and. (ldel2s .or. ldc3c4) ) goto 500
	    if ( lwrite ) print *,'Expect cancellations of ',
     +		abs(dqiqj(3,4)/xqi(3))
	endif
*
*	and the calculations
*
	ier0 = ier
	ier1 = ier
	if ( lcroot ) then
	    call ffcc0p(cs4( 1),ipi12(1),isoort(1),clogi(1),ilogi(1),
     +		cpi(1,3),cdpipj(1,1,3),cpiDpj(1,1,3),csdel2,cel2s(1,3),
     +		cetalm(3),cetami(1,3),celpsi(1,3),calph,4,ier0)
	    call ffcc0p(cs4(81),ipi12(9),isoort(9),clogi(4),ilogi(4),
     +		cpi(1,4),cdpipj(1,1,4),cpiDpj(1,1,4),csdel2,cel2s(1,4),
     +		cetalm(4),cetami(1,4),celpsi(1,4),calph,4,ier1)
	else
	    if ( lsmug ) call ffsm43(xpi3(1,3),7-3)
	    call ffxc0p(cs4( 1),ipi12(1),isoort(1),clogi(1),ilogi(1),
     +		xpi3(1,3),dpipj3(1,1,3),piDpj3(1,1,3),sdel2,del2s(1,3),
     +		etalam(3),etami(1,3),delpsi(1,3),alph,4,ier0)
	    if ( lsmug ) call ffsm43(xpi3(1,4),7-4)
	    call ffxc0p(cs4(81),ipi12(9),isoort(9),clogi(4),ilogi(4),
     +		xpi3(1,4),dpipj3(1,1,4),piDpj3(1,1,4),sdel2,del2s(1,4),
     +		etalam(4),etami(1,4),delpsi(1,4),alph,4,ier1)
	endif
	ier = max(ier0,ier1)
	goto 600
*  #] simple case:
*  #[ cancellations:
  500	continue
*
*	There are cancellations between the dilogarithms or the vertex
*	is on threshold.
*	we need the differences ddel2s(i) = del2s(i,3)-del2s(i,4)
*
	do 510 i=2,3
	    if ( i .eq. 2 ) then
		j = 2
	    else
		j = 1
	    endif
	    ddel2s(i) = del2s(i,3) - del2s(i,4)
	    xmax = abs(del2s(i,3))
	    if ( abs(ddel2s(i)) .ge. xloss*xmax ) goto 510
	    if ( lwrite ) print *,'ddel2s(',i,')  = ',ddel2s(i),
     +		abs(del2s(i,3))
*
*	    Very first try with transformation
*
	    s(1) = (ai(3)+ai(4))*daiaj(3,4)*del2s(i,3)/ai(3)**2
	    s(2) = ai(j)**2*ai(4)**2*xpi(j)*dpipj(3,4)
	    s(3) = ai(j)**2*ai(4)**2*piDpj(j,7)*piDpj(j,3)
	    s(4) = ai(j)**2*ai(4)**2*piDpj(j,7)*piDpj(j,4)
	    som = s(1) + s(2) + s(3) + s(4)
	    smax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)))
	    if ( lwrite ) print *,'ddel2s(',i,')+ = ',som,
     +						s(1),s(2),s(3),s(4)
	    if ( abs(som) .ge. xloss*smax ) goto 510
	    if ( smax .lt. xmax ) then
		ddel2s(i) = som
		xmax = smax
	    endif
**
*	    first try (tested, but not needed)
**
*	    s(1) = xqi(j)*dqiqj(3,4)
*	    s(2) = qiDqj(7,j)*qiDqj(j,3)
*	    s(3) = qiDqj(7,j)*qiDqj(j,4)
*	    som = s(1) + s(2) + s(3)
*	    smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	    if ( abs(som) .ge. xloss*smax ) goto 510
*	    if ( lwrite ) print *,' ddel2s(i)  = ',som,s(1),s(2),s(3)
*	    if ( smax .lt. xmax ) then
*		ddel2s(i) = som
*		xmax = smax
*	    endif
**
*	    second try (tested, but not needed)
**
*	    s(1) = xqi(inx(j,3))*dqiqj(3,4)
*	    s(2) = -isgn(j,3)*qiDqj(7,4)*qiDqj(inx(j,3),3)
*	    s(3) = -isgn(j,4)*qiDqj(7,4)*qiDqj(inx(j,4),4)
*	    som = s(1) + s(2) + s(3)
*	    smax = max(abs(s(1)),abs(s(2)),abs(s(3)))
*	    if ( lwrite ) print *,' ddel2s(i)+ = ',som,s(1),s(2),s(3)
*	    if ( abs(som) .ge. xloss*smax ) goto 510
*	    if ( smax .lt. xmax ) then
*		ddel2s(i) = som
*		xmax = smax
*	    endif
*
*	    maybe insert something intelligent later ...
*
	    if ( lwarn ) call ffwarn(139,ier,ddel2s(i),xmax)
  510	continue
	if ( .not. lcroot ) then
	    call ffdxc0(cs4,ipi12,isoort,clogi,ilogi,xpi3,dpipj3,piDpj3,
     +		xqi,dqiqj,qiDqj,sdel2,del2s,etalam,etami,delpsi,alph,
     +		ddel2s,ldel2s,4,ier)
	else
	    cddl2s(2) = ddel2s(2)
	    cddl2s(3) = ddel2s(3)
	    do 530 i=1,10
		zqi(i) = xqi(i)
		do 520 j=1,10
		    zdqiqj(j,i) = dqiqj(j,i)
		    zqiDqj(j,i) = qiDqj(j,i)
  520		continue
  530	    continue
	    call ffdcc0(cs4,ipi12,isoort,clogi,ilogi,cpi,cdpipj,cpiDpj,
     +		zqi,zdqiqj,zqiDqj,csdel2,cel2s,cetalm,cetami,celpsi,
     +		calph,cddl2s,ldel2s,4,ier)
	endif
  600	continue
*  #] cancellations:
*  #[ Ai<0 terms:
	cipi = DCMPLX(x0,pi)
	if ( ai(3) .lt. 0 .neqv. ai(4) .lt. 0 ) then
*	    we need the S term
	    if ( ai(1) .lt. 0 .eqv. ai(2) .lt. 0 ) then
		if ( lcroot ) then
		   call ffcxra(cs4(167),ipi12(23),xqi,qiDqj,sdel2,1,ier)
		else
*		   call ffxtro(cs4(167),ipi12(23),xqi,qiDqj,sdel2,1,ier)
		   call ffxtra(cs4(167),ipi12(23),xqi,qiDqj,sdel2,1,ier)
		endif
	    else
		if ( lcroot ) then
		   call ffcxra(cs4(167),ipi12(23),xqi,qiDqj,sdel2,2,ier)
		   call ffcxra(cs4(169),ipi12(25),xqi,qiDqj,sdel2,3,ier)
		else
		   call ffxtra(cs4(167),ipi12(23),xqi,qiDqj,sdel2,2,ier)
		   call ffxtra(cs4(169),ipi12(25),xqi,qiDqj,sdel2,3,ier)
*		   call ffxtro(cs4(167),ipi12(23),xqi,qiDqj,sdel2,2,ier)
*		   call ffxtro(cs4(169),ipi12(25),xqi,qiDqj,sdel2,3,ier)
		endif
	    endif
	endif
*
*	The normal correction terms
*
	if ( ai(1) .lt. 0 .neqv. ai(2) .lt. 0 ) then
	    cs4(161) = -cipi*clogi(1)
	    ipi12(17) = 12*ilogi(1)
	    if ( ilogi(1) .eq. -999 ) call fferr(46,ier)
	    cs4(164) = cipi*clogi(4)
	    ipi12(20) = -12*ilogi(4)
	    if ( ilogi(4) .eq. -999 ) call fferr(46,ier)
	endif
	if ( ai(2) .lt. 0 .neqv. ai(3) .lt. 0 ) then
	    cs4(162) = -cipi*clogi(2)
	    ipi12(18) = 12*ilogi(2)
	    if ( ilogi(2) .eq. -999 ) call fferr(46,ier)
	endif
	if ( ai(3) .lt. 0 .neqv. ai(1) .lt. 0 ) then
	    cs4(163) = -cipi*clogi(3)
	    ipi12(19) = 12*ilogi(3)
	    if ( ilogi(3) .eq. -999 ) call fferr(46,ier)
	endif
	if ( ai(2) .lt. 0 .neqv. ai(4) .lt. 0 ) then
	    cs4(165) = cipi*clogi(5)
	    ipi12(21) = -12*ilogi(5)
	    if ( ilogi(5) .eq. -999 ) call fferr(46,ier)
	endif
	if ( ai(4) .lt. 0 .neqv. ai(1) .lt. 0 ) then
	    cs4(166) = cipi*clogi(6)
	    ipi12(22) = -12*ilogi(6)
	    if ( ilogi(6) .eq. -999 ) call fferr(46,ier)
	endif
	if ( lwrite ) print *,'signs Ai: ',(nint(sign(x1,ai(i))),i=1,4)
*  #] Ai<0 terms:
*###] ffxd0p:
	end
*###[ ffpi43:
	subroutine ffpi43(xpi3,dpipj3,piDpj3,xpi,dpipj,piDpj,imiss,ier)
***#[*comment:***********************************************************
*									*
*	Fill the threepoint arrays xpi3 and dpipj3 with masses from the	*
*	the fourpoint array xpi with leg imiss cut out.			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE PRECISION xpi3(6),dpipj3(6,6),piDpj3(6,6)
	DOUBLE PRECISION xpi(10),dpipj(10,10),piDpj(10,10)
	integer imiss,ier
*
*	local variables
*
	integer i,j
	integer iinx(6,4)
	DOUBLE PRECISION xmin,xmax,a
	save iinx
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data iinx /2,3,4,6,7,10,
     +		   1,3,4,9,7,8,
     +		   1,2,4,5,10,8,
     +		   1,2,3,5,6,9/
*  #] declarations:
*  #[ calculations:
*	if ( lscale ) then
*	    xmax = abs(xpi(iinx(1,imiss)))
*	    xmin = xmax
*	    do 5 i=2,6
*		a = abs(xpi(iinx(i,imiss)))
*		xmax = max(xmax,a)
*		xmin = min(xmin,a)
*    5	    continue
*	    scale = (xmax*sqrt(xmin))**(-2/3.)
*	else
*	    scale = 1
*	endif
	do 20 i=1,6
	    xpi3(i) = xpi(iinx(i,imiss))
	    do 10 j=1,6
		dpipj3(j,i) = dpipj(iinx(j,imiss),iinx(i,imiss))
		piDpj3(j,i) = piDpj(iinx(j,imiss),iinx(i,imiss))
   10	    continue
   20	continue
*	call ffxhck(xpi3,dpipj3,6,ier)
*	if ( lscale .and. lwrite ) then
*	    print *,'ffpi43: scaled momenta:'
*	    print *,xpi3
*	endif
*  #] calculations:
*###] ffpi43:
	end
*###[ ffxtra:
	subroutine ffxtra(cs4,ipi12,xqi,qiDqj,sdel2,ii,ier)
***#[*comment:***********************************************************
*									*
*	calculate the extra terms S_ii^{\infty\prime}, put them in	*
*	cs4 and ipi12.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12(3),ii,ier
	DOUBLE COMPLEX cs4(3)
	DOUBLE PRECISION xqi(10),qiDqj(10,10),sdel2
*
*	local variables
*
	integer i,ip(5)
	DOUBLE PRECISION x(2,3),dfflo1,s,s1
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data ip/5,6,8,5,6/
*  #] declarations:
*  #[ calculations:
	if ( ii .eq. 3 ) return
	do 10 i=1,3
	    if ( ii .eq. 1 .and. i .eq. 2 ) goto 10
	    call ffroot(x(1,i),x(2,i),xqi(ip(i)),-qiDqj(ip(i),
     +		ip(i+1)),xqi(ip(i+1)),sdel2,ier)
	    s = -x(2,i)/x(1,i)
	    if ( lwrite ) then
		print *,'s = ',s
	    endif
	    if ( abs(s-1) .lt. xloss ) then
		if ( lwrite ) then
		print *,'s''=',1+2*qiDqj(ip(i),ip(i+1))/(xqi(ip(i))*
     +				x(1,i))
		endif
		s1 = dfflo1(-2*qiDqj(ip(i),ip(i+1))/(xqi(ip(i))*x(1,i)),
     +				ier)
	    elseif ( s .gt. 0 ) then
		s1 = log(s)
	    else
		if ( abs(s+1) .lt. xloss ) then
		    if ( lwrite ) then
			print *,'s''=',-1-2*sdel2/(xqi(ip(i))*x(1,i))
		    endif
		    s1 = dfflo1(-2*sdel2/(xqi(ip(i))*x(1,i)),ier)
		else
		    s1 = log(-s)
		endif
*		also here an minus sign (-i*pi*log(-(p.p-sqrt)/(p.p+sqrt)))
		if ( qiDqj(ip(i),ip(i+1))*xqi(ip(i))*sdel2 .gt. 0 ) then
		    ipi12(i) = +12
		else
		    ipi12(i) = -12
		endif
*		ier = ier + 50
*		print *,'ffxtra: imaginary part may well be wrong -> ',
*     +			'n*pi^2 fout'
*		print *,'        ipi12(i) = ',ipi12(i)
*		print *,'        qiDqj    = ',qiDqj(ip(i),ip(i+1))
*		print *,'        qi^2     = ',xqi(ip(i))
	    endif
*	    there is an overall minus compared with Veltman
	    cs4(i) = DCMPLX(x0,-pi*s1)
	    if ( sdel2 .lt. 0 ) then
		cs4(i) = -cs4(i)
		ipi12(i) = -ipi12(i)
	    endif
	    if ( ii .ne. 1 ) then
		cs4(i) = -cs4(i)
		ipi12(i) = -ipi12(i)
	    endif
	    if ( i .eq. 2 ) then
		cs4(i) = 2*cs4(i)
		ipi12(i) = 2*ipi12(i)
	    endif
   10	continue
*  #] calculations:
*  #[ debug:
	if ( lwrite ) then
	    print *,'ffxtra: ii    = ',ii
	    print *,'        sdel2 = ',sdel2
	    print *,'        x     = ',x
	    print *,'        cs4   = ',cs4
	    print *,'        ipi12 = ',ipi12
	endif
*  #] debug:
*###] ffxtra:
	end
*###[ ffcxra:
	subroutine ffcxra(cs4,ipi12,xqi,qiDqj,sdel2,ii,ier)
***#[*comment:***********************************************************
*									*
*	calculate the extra terms S_ii^{\infty\prime}, put them in	*
*	cs4 and ipi12 for qi real but sdel2 complex.			*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12(3),ii,ier
	DOUBLE COMPLEX cs4(3)
	DOUBLE PRECISION xqi(10),qiDqj(10,10),sdel2
*
*	local variables
*
	integer i,ip(5)
	DOUBLE COMPLEX x(2,3),zfflo1,s,s1,c
	DOUBLE PRECISION absc
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data ip/5,6,8,5,6/
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*  #] declarations:
*  #[ calculations:
	if ( ii .eq. 3 ) return
	do 10 i=1,3
	    if ( ii .eq. 1 .and. i .eq. 2 ) goto 10
	    x(1,i) = DCMPLX(-qiDqj(ip(i),ip(i+1))/xqi(ip(i)),
     +			-sdel2/xqi(ip(i)))
	    x(2,i) = DCMPLX(-qiDqj(ip(i),ip(i+1))/xqi(ip(i)),
     +			+sdel2/xqi(ip(i)))
	    s = -x(2,i)/x(1,i)
	    if ( lwrite ) then
		print *,'s = ',s
	    endif
	    c = s-1
	    if ( absc(c) .lt. xloss ) then
		if ( lwrite ) then
		print *,'s''=',1+DBLE(2*qiDqj(ip(i),ip(i+1))/xqi(ip(i)))
     +				/x(1,i)
		endif
		s1 = zfflo1(DBLE(-2*qiDqj(ip(i),ip(i+1))/xqi(ip(i)))/
     +				x(1,i),ier)
	    elseif ( abs(s+1) .lt. xloss ) then
		if ( lwrite ) then
		    print *,'s''=',-1-DCMPLX(x0,-2*sdel2/xqi(ip(i)))/
     +			x(1,i)
		endif
		s1 = zfflo1(DCMPLX(x0,-2*sdel2/xqi(ip(i)))/x(1,i),ier)
	    else
		s1 = log(s)
	    endif
*	    there is an overall minus compared with Veltman
	    cs4(i) = DCMPLX(pi*DIMAG(s1),-pi*DBLE(s1))
	    if ( ii .ne. 1 ) then
		cs4(i) = -cs4(i)
		ipi12(i) = -ipi12(i)
	    endif
	    if ( sdel2 .lt. 0 ) then
		cs4(i) = -cs4(i)
		ipi12(i) = -ipi12(i)
	    endif
	    if ( i .eq. 2 ) then
		cs4(i) = 2*cs4(i)
		ipi12(i) = 2*ipi12(i)
	    endif
   10	continue
*  #] calculations:
*  #[ debug:
	if ( lwrite ) then
	    print *,'ffcxra: ii    = ',ii
	    print *,'        sdel2 = ',sdel2
	    print *,'        x     = ',x
	    print *,'        cs4   = ',cs4
	    print *,'        ipi12 = ',ipi12
	endif
*  #] debug:
*###] ffcxra:
	end
*###[ ffsm43:
	subroutine ffsm43(xpi3,imiss)
***#[*comment:***********************************************************
*									*
*	Distribute the smuggled 4point momenta to the 3point smuggled	*
*	momenta.  Note that because of the common block smuggling this	*
*	cannot be included in ffpi43.					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer imiss
	DOUBLE PRECISION xpi3(6)
*
*	local variables
*
	integer i,j,iinx(6,4)
	save iinx
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data iinx /2,3,4,6,7,10,
     +		   1,3,4,9,7,8,
     +		   1,2,4,5,10,8,
     +		   1,2,3,5,6,9/
*
*  #] declarations:
*  #[ parcel out:
	if ( lsmug ) then
*
*	    parcel out the smuggled diffs
*
	    do 30 i=1,3
		j = mod(i,3)+1
		if ( xpi3(j) .eq. 0 ) then
		    cmipj(i,i) = c2sisj(iinx(i,imiss),iinx(j,imiss))
		elseif ( xpi3(i) .eq. 0 ) then
		    cmipj(j,i) = c2sisj(iinx(i,imiss),iinx(j,imiss))
		endif
   30	    continue
	endif
*  #] parcel out:
*)##] ffsm43:
	end
*###[ ffxd1:
	subroutine ffxd1(cd1i,cd0,cc0i,xpi,piDpj,del3,del2i,ier)
***#[*comment:***********************************************************
*									*
*	calculate the D1(mu) = D11*p1(mu) + D12*p2(mu) + D13*p3(mu)	*
*	numerically							*
*									*
*	Input:	cd0	     complex	scalar fourpoint function	*
*		cc0i(4)	     complex	scalar threepoint functions	*
*						without s1,s2,s3,s4	*
*		xpi(13)	     real	masses (1-4), momenta^2 (5-10)	*
*		piDpj(10,10) real	dotproducts as in D0		*
*		del3	     real	overall determinant		*
*		del2i(4)     real	minors as in cc0i		*
*		ier	     integer	digits lost so far		*
*	Output:	cd1i(3)	     complex	D11,D12,D13			*
*		ier	     integer	number of dgits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xpi(13),piDpj(10,10),del3,del2i(4)
	DOUBLE COMPLEX cd1i(3),cd0,cc0i(4)
*
*	local variables
*
	DOUBLE PRECISION md1i(3),md0,mc0i(4)
	integer i,j,ier0
	logical wasnul(3)
	DOUBLE PRECISION xmax,absc,xnul,xlosn
	DOUBLE PRECISION dpipj(10,13),piDpjp(10,10),s(6),som
	DOUBLE COMPLEX cc
*
*	common blocks
*
	include 'ff.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffxd1: input:'
	    print *,'xpi  = ',xpi
	    print *,'del3 = ',del3
	endif
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-mod(ier,50))
	    do 1 i=1,6
		if ( xpi(i) .ne. piDpj(i,i) ) then
		    print *,'ffxd1: error: xpi and piDpj do not agree'
		endif
    1	    continue
	    if ( xpi(11).eq.0 ) then
		xpi(11) = xpi(5)+xpi(6)+xpi(7)+xpi(8)-xpi(9)-xpi(10)
		wasnul(1) = .TRUE.
	    else
		wasnul(1) = .FALSE.
	    endif
	    if ( xpi(12).eq.0 ) then
		xpi(12) = -xpi(5)+xpi(6)-xpi(7)+xpi(8)+xpi(9)+xpi(10)
		wasnul(2) = .TRUE.
	    else
		wasnul(2) = .FALSE.
	    endif
	    if ( xpi(13).eq.0 ) then
		xpi(13) = xpi(5)-xpi(6)+xpi(7)-xpi(8)+xpi(9)+xpi(10)
		wasnul(3) = .TRUE.
	    else
		wasnul(3) = .FALSE.
	    endif
	    do 4 i=1,13
		do 3 j=1,10
		    dpipj(j,i) = xpi(j) - xpi(i)
    3		continue
    4	    continue
	    ier0 = ier
	    call ffdot4(piDpjp,xpi,dpipj,10,ier0)
	    if ( wasnul(1) ) xpi(11) = 0
	    if ( wasnul(2) ) xpi(12) = 0
	    if ( wasnul(3) ) xpi(13) = 0
	    do 7 i=1,10
		do 6 j=1,10
		    xnul = piDpj(j,i) - piDpjp(j,i)
		    if ( xlosn*abs(xnul) .gt. precx*abs(piDpjp(j,i)) )
     +			print *,'piDpj(',j,i,') not correct, cmp:',
     +			piDpj(j,i),piDpjp(j,i),xnul
    6		continue
    7	    continue
	    s(1) = + piDpj(5,5)*piDpj(6,6)*piDpj(7,7)
	    s(2) = - piDpj(5,5)*piDpj(6,7)*piDpj(7,6)
	    s(3) = - piDpj(5,6)*piDpj(6,5)*piDpj(7,7)
	    s(4) = + piDpj(5,6)*piDpj(6,7)*piDpj(7,5)
	    s(5) = + piDpj(5,7)*piDpj(6,5)*piDpj(7,6)
	    s(6) = - piDpj(5,7)*piDpj(6,6)*piDpj(7,5)
	    som = s(1) + s(2) + s(3) + s(4) + s(5) + s(6)
	    xmax = max(abs(s(1)),abs(s(2)),abs(s(3)),abs(s(4)),
     +		abs(s(5)),abs(s(6)))
	    xnul = del3-som
	    if ( xloss*abs(xnul) .gt. precx*xmax ) print *,
     +		'ffxd1: error: del3 is not correct',del3,som,xmax
	endif
*  #] check input:
*  #[ call ffxd1a:
*
	md0 = absc(cd0)*DBLE(10)**mod(ier,50)
	mc0i(1) = absc(cc0i(1))*DBLE(10)**mod(ier,50)
	mc0i(2) = absc(cc0i(2))*DBLE(10)**mod(ier,50)
	mc0i(3) = absc(cc0i(3))*DBLE(10)**mod(ier,50)
	mc0i(4) = absc(cc0i(4))*DBLE(10)**mod(ier,50)
	call ffxd1a(cd1i,md1i,cd0,md0,cc0i,mc0i,xpi,piDpj,del3,del2i,
     +		ier)
*
*  #] call ffxd1a:
*###] ffxd1:
	end
*###[ ffxd1a:
	subroutine ffxd1a(cd1i,md1i,cd0,md0,cc0i,mc0i,xpi,piDpj,del3,
     +		del2i,ier)
***#[*comment:***********************************************************
*									*
*	calculate the D1(mu) = D11*p1(mu) + D12*p2(mu) + D13*p3(mu)	*
*	numerically							*
*									*
*	Input:	cd0	     complex	scalar fourpoint function	*
*		md0	     real	maximum partial sum in D0	*
*		cc0i(4)	     complex	scalar threepoint functions	*
*						without s1,s2,s3,s4	*
*		mc0i(4)	     real	maximum partial sum in C0i	*
*		xpi(13)	     real	masses (1-4), momenta^2 (5-10)	*
*		piDpj(10,10) real	dotproducts as in D0		*
*		del3	     real	overall determinant		*
*		del2i(4)     real	minors as in cc0i		*
*		ier	     integer	digits lost so far		*
*	Output:	cd1i(3)	     complex	D11,D12,D13			*
*		md1i(3)	     real	maximum partial sum in D1i	*
*		ier	     integer	number of dgits lost		*
*									*
***#]*comment:*********************************************************** 
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xpi(13),piDpj(10,10),del3,del2i(4)
	DOUBLE PRECISION md1i(3),md0,mc0i(4)
	DOUBLE COMPLEX cd1i(3),cd0,cc0i(4)
*
*	local variables
*
	integer i,ier0,ier1,ier2
	DOUBLE PRECISION xmax,absc,del2,del2sa,dl3q,ms(5),mdelsa
	DOUBLE COMPLEX cs(5),cc
*
*	common blocks
*
	include 'ff.h'
	include 'aa.h'
*
*	statement function
*
	absc(cc) = abs(DBLE(cc)) + abs(DIMAG(cc))
*  #] declarations: 
*  #[ Form-ula:
*	see the Form job D1.frm
*   D1 =
*       + p1(mu)*Del3^-1 * (  - 1/2*C(s1)*p2.p2*p3.p3 + 1/2*C(s1)*p2.p3^2 + 1/2
*         *C(s2)*p2.p3*p3.p4 - 1/2*C(s2)*p2.p4*p3.p3 + 1/2*C(s3)*p1.p2*p3.p4 -
*         1/2*C(s3)*p1.p3*p2.p4 + 1/2*C(s4)*p1.p2*p2.p3 - 1/2*C(s4)*p1.p3*p2.p2
*          + D*delta(s1,p2,p3,p1,p2,p3) - D*delta(s1,p3,p2,p1,p2,p3) )
*
*       + p2(mu)*Del3^-1 * ( 1/2*C(s1)*p1.p2*p3.p3 - 1/2*C(s1)*p1.p3*p2.p3 - 1/
*         2*C(s2)*p1.p3*p3.p4 + 1/2*C(s2)*p1.p4*p3.p3 - 1/2*C(s3)*p1.p1*p3.p4
*          + 1/2*C(s3)*p1.p3*p1.p4 - 1/2*C(s4)*p1.p1*p2.p3 + 1/2*C(s4)*p1.p2*
*         p1.p3 - D*delta(s1,p1,p3,p1,p2,p3) + D*delta(s1,p3,p1,p1,p2,p3) )
*
*       + p3(mu)*Del3^-1 * (  - 1/2*C(s1)*p1.p2*p2.p3 + 1/2*C(s1)*p1.p3*p2.p2
*          + 1/2*C(s2)*p1.p3*p2.p4 - 1/2*C(s2)*p1.p4*p2.p3 + 1/2*C(s3)*p1.p1*
*         p2.p4 - 1/2*C(s3)*p1.p2*p1.p4 + 1/2*C(s4)*p1.p1*p2.p2 - 1/2*C(s4)*
*         p1.p2^2 + D*delta(s1,p1,p2,p1,p2,p3) - D*delta(s1,p2,p1,p1,p2,p3) );
*
*  #] Form-ula:
*  #[ D11:
	if ( lwrite ) print *,'ffxd1: D11'
	cs(1) = - cc0i(1)*DBLE(del2i(1))
	ms(1) = mc0i(1)*abs(del2i(1))
	if ( lwrite ) print *,'ffdl2i 1'
	ier1 = ier
	call ffdl2i(del2,piDpj,10, 6,7,10,+1,7,8,9,+1,ier1)
	cs(2) = + cc0i(2)*DBLE(del2)
	ms(2) = mc0i(2)*abs(del2)*DBLE(10)**mod(ier1-ier,50)
	if ( lwrite ) print *,'ffdl2i 2'
	ier0 = ier
	call ffdl2i(del2,piDpj,10, 6,7,10,+1,8,5,10,-1,ier0)
	ier1 = max(ier1,ier0)
	cs(3) = - cc0i(3)*DBLE(del2)
	ms(3) = mc0i(3)*abs(del2)*DBLE(10)**mod(ier0-ier,50)
	if ( lwrite ) print *,'ffdl2i 3'
	ier0 = ier
	call ffdl2i(del2sa,piDpj,10, 6,7,10,+1,5,6,9,-1,ier0)
	ier1 = max(ier1,ier0)
	cs(4) = + cc0i(4)*DBLE(del2sa)
	mdelsa = abs(del2sa)*DBLE(10)**mod(ier0-ier,50)
	ms(4) = mc0i(4)*mdelsa
	ier0 = ier
	call ffdl3q(dl3q,piDpj, 1,6,7, 0,10,0, 0,-1,0, 0,+1,0, ier0)
	ier1 = max(ier1,ier0)
	cs(5) = + 2*cd0*DBLE(dl3q)
	ms(5) = 2*md0*abs(dl3q)*DBLE(10)**mod(ier0-ier,50)

	cd1i(1) = 0
	xmax = 0
	md1i(1) = 0
	do 10 i=1,5
	    cd1i(1) = cd1i(1) + cs(i)
	    xmax = max(xmax,absc(cs(i)))
	    md1i(1) = max(md1i(1),ms(i))
   10	continue
	if ( lwarn .and. absc(cd1i(1)) .lt. xloss*xmax ) then
	    call ffwarn(164,ier1,absc(cd1i(1)),xmax)
	    if ( awrite .or. lwrite ) then
		print *,'cs  = ',cs
		print *,'D11 = ',cd1i(1),xmax
		print *,'ms  = ',ms
	    endif
	endif
	cd1i(1) = cd1i(1)*DBLE(1/(2*del3))
	md1i(1) = md1i(1)*abs(1/(2*del3))
	ier2 = ier1
*
*  #] D11:
*  #[ D12:
*
	if ( lwrite ) print *,'ffxd1: D12'
	ier1 = ier
	call ffdl2t(del2,piDpj,7,5, 6,7,10,-1,-1, 10,ier1)
	cs(1) = - cc0i(1)*DBLE(del2)
	ms(1) = mc0i(1)*abs(del2)*DBLE(10)**mod(ier-ier1,50)
	ier0 = ier
	call ffdl2t(del2,piDpj,7,5, 7,8,9,-1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	cs(2) = + cc0i(2)*DBLE(del2)
	ms(2) = mc0i(2)*abs(del2)*DBLE(10)**mod(ier-ier0,50)
	ier0 = ier
	call ffdl2t(del2,piDpj,7,5, 8,5,10,+1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	cs(3) = - cc0i(3)*DBLE(del2)
	ms(3) = mc0i(3)*abs(del2)*DBLE(10)**mod(ier-ier0,50)
	ier0 = ier
	call ffdl2t(del2,piDpj,7,5, 5,6,9,+1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	cs(4) = + cc0i(4)*DBLE(del2)
	ms(4) = mc0i(4)*abs(del2)*DBLE(10)**mod(ier-ier0,50)
	ier0 = ier
	call ffdl3q(dl3q,piDpj, 1,7,5, 0,0,2, 0,0,-1, 0,0,+1, ier0)
	ier1 = max(ier1,ier0)
	cs(5) = + 2*cd0*DBLE(dl3q)
	ms(5) = 2*md0*abs(dl3q)*DBLE(10)**mod(ier-ier0,50)

	cd1i(2) = 0
	xmax = 0
	md1i(2) = 0
	do 20 i=1,5
	    cd1i(2) = cd1i(2) + cs(i)
	    xmax = max(xmax,absc(cs(i)))
	    md1i(2) = max(md1i(2),ms(i))
   20	continue
	if ( lwarn .and. absc(cd1i(2)) .lt. xloss*xmax ) then
	    call ffwarn(164,ier1,absc(cd1i(2)),xmax)
	    if ( lwrite .or. awrite ) then
		print *,'cs  = ',cs
		print *,'D12 = ',cd1i(2),xmax
		print *,'ms  = ',ms
	    endif
	endif
	cd1i(2) = cd1i(2)*DBLE(1/(2*del3))
	md1i(2) = md1i(2)*abs(1/(2*del3))
	ier2 = max(ier2,ier1)
*
*  #] D12:
*  #[ D13:
*
	if ( lwrite ) print *,'ffxd1: D13'
	cs(1) = - cc0i(1)*DBLE(del2sa)
	ms(1) = mc0i(1)*mdelsa
	if ( lwrite ) print *,'ffdl2i 1'
	ier1 = ier
	call ffdl2i(del2,piDpj,10, 5,6,9,-1,7,8,9,+1,ier1)
	cs(2) = + cc0i(2)*DBLE(del2)
	ms(2) = mc0i(2)*abs(del2)*DBLE(10)**mod(ier-ier1,50)
	if ( lwrite ) print *,'ffdl2i 2'
	ier0 = ier
	call ffdl2i(del2,piDpj,10, 5,6,9,-1,8,5,10,-1,ier0)
	ier1 = max(ier1,ier0)
	cs(3) = - cc0i(3)*DBLE(del2)
	ms(3) = mc0i(3)*abs(del2)*DBLE(10)**mod(ier-ier0,50)
	cs(4) = + cc0i(4)*DBLE(del2i(4))
	ms(4) = mc0i(4)*abs(del2i(4))
	ier0 = ier
	call ffdl3q(dl3q,piDpj, 1,5,6, 2,9,0, -1,-1,0, +1,-1,0, ier0)
	ier1 = max(ier1,ier0)
	cs(5) = + 2*cd0*DBLE(dl3q)
	ms(5) = 2*md0*abs(dl3q)*DBLE(10)**mod(ier-ier0,50)

	cd1i(3) = 0
	xmax = 0
	md1i(3) = 0
	do 30 i=1,5
	    cd1i(3) = cd1i(3) + cs(i)
	    xmax = max(xmax,absc(cs(i)))
	    md1i(3) = max(md1i(3),ms(i))
   30	continue
	if ( lwarn .and. absc(cd1i(3)) .lt. xloss*xmax ) then
	    call ffwarn(164,ier1,absc(cd1i(3)),xmax)
	    if ( lwrite .or. awrite ) then
		print *,'cs  = ',cs
		print *,'D13 = ',cd1i(3),xmax
		print *,'ms  = ',ms
	    endif
	endif
	cd1i(3) = cd1i(3)*DBLE(1/(2*del3))
	md1i(3) = md1i(3)*abs(1/(2*del3))
	ier2 = max(ier2,ier1)
*
*	fidel3 is the error on del3, but only when del3=fdel3
*
	if ( fdel3.eq.del3 ) then
	    ier2 = max(ier2,fidel3)
	    do 40 i=1,3
	    	md1i(i) = md1i(i)*DBLE(10**mod(fidel3,50))
   40	    continue
	endif
	ier = ier2
*
*  #] D13:
*  #[ print output:
	if ( lwrite ) then
	    print *,'ffxd1: results:'
	    print *,'D11 = ',cd1i(1),md1i(1),ier
	    print *,'D12 = ',cd1i(2),md1i(2),ier
	    print *,'D13 = ',cd1i(3),md1i(3),ier
	endif
*  #] print output:
*###] ffxd1:
	end
*###[ ffxdb0:
	subroutine ffxdb0(cdb0,cdb0p,xp,xma,xmb,ier)
***#[*comment:***********************************************************
*									*
*	Calculates the the derivative of the two-point function with	*
*	respect to p2 and the same times p2 (one is always well-defined)*
*									*
*	Input:	xp	(real)	  k2, in B&D metric			*
*		xma	(real)	  mass2					*
*		xmb	(real)	  mass2					*
*									*
*	Output:	cdb0	(complex) dB0/dxp				*
*		cdb0p	(complex) xp*dB0/dxp				*
*		ier	(integer) # of digits lost, if >=100: error	*
*									*
*	Calls:	ffxdba							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cdb0,cdb0p
	DOUBLE PRECISION xp,xma,xmb
*
*	local variables
*
	integer ier0
	DOUBLE PRECISION dmamb,dmap,dmbp
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffxdb0: input:'
	    print *,'xma,xmb,xp,ier = ',xma,xmb,xp,ier
	endif
	if ( ltest ) then
	    if ( xma .lt. 0 .or. xmb .lt. 0 ) then
		print *,'ffxdb0: error: xma,b < 0: ',xma,xmb
		stop
	    endif
	endif
*  #] check input:
*  #[ get differences:
	ier0 = 0
	dmamb = xma - xmb
	dmap = xma - xp
	dmbp = xmb - xp
	if ( lwarn ) then
	    if ( abs(dmamb) .lt. xloss*abs(xma) .and. xma .ne. xmb )
     +		call ffwarn(97,ier0,dmamb,xma)
	    if ( abs(dmap) .lt. xloss*abs(xp) .and. xp .ne. xma )
     +		call ffwarn(98,ier0,dmap,xp)
	    if ( abs(dmbp) .lt. xloss*abs(xp) .and. xp .ne. xmb )
     +		call ffwarn(99,ier0,dmbp,xp)
	endif
*  #] get differences:
*  #[ calculations:
	call ffxdbp(cdb0,cdb0p,xp,xma,xmb,dmap,dmbp,dmamb,ier)
	if ( lwrite ) print *,'B0'' = ',cdb0,cdb0p,ier
*  #] calculations:
*###] ffxdb0:
	end
*###[ ffxdbp:
	subroutine ffxdbp(cdb0,cdb0p,xp,xma,xmb,dmap,dmbp,dmamb,ier)
***#[*comment:***********************************************************
*									*
*	calculates the derivatives of the two-point function		*
*	Veltman) for all possible cases: masses equal, unequal,		*
*	equal to zero.							*
*									*
*	Input:	xp	(real) p.p, in B&D metric			*
*		xma	(real) mass2,					*
*		xmb	(real) mass2,					*
*		dm[ab]p	(real) xm[ab] - xp				*
*		dmamb	(real) xma - xmb				*
*									*
*	Output:	cdb0	(complex) B0' = dB0/dxp				*
*		cdb0p	(complex) xp*dB0/dxp				*
*		ier	(integer) 0=ok,>0=numerical problems,>100=error	*
*									*
*	Calls:	ffxdbp.							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE COMPLEX cdb0,cdb0p
	DOUBLE PRECISION xp,xma,xmb,dmap,dmbp,dmamb
*
*	local variables
*
	integer i,initeq,jsign,initir
	DOUBLE PRECISION ax,ffbnd,
     +		xprceq,bdeq01,bdeq05,bdeq11,bdeq17,bdeq25,
     +		xprcn3,bdn301,bdn305,bdn310,bdn315,
     +		xprcn5,bdn501,bdn505,bdn510,bdn515,
     +		xprec0,bdn001,bdn005,bdn010,bdn015,bdn020
	DOUBLE PRECISION xcheck,xm,dmp,xm1,xm2,dm1m2,dm1p,
     +		dm2p,s,s1,s1a,s1b,s1p,s2,s2a,s2b,s2p,x,y,som,
     +		xlam,slam,xlogmm,alpha,alph1,xnoe,xpneq(30),
     +		xx,dfflo1,dfflo3,d1,d2,diff,h,a,b,c,d,beta,
     +		betm2n,xmax,s1c,s1d,s1e,s1f,s3
	DOUBLE COMPLEX cc
	save initeq,xpneq,initir,
     +		xprceq,bdeq01,bdeq05,bdeq11,bdeq17,bdeq25,
     +		xprcn3,bdn301,bdn305,bdn310,bdn315,
     +		xprcn5,bdn501,bdn505,bdn510,bdn515,
     +		xprec0,bdn001,bdn005,bdn010,bdn015,bdn020
*
*	common blocks
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	data
*
	data xprceq /-1./
	data xprec0 /-1./
	data xprcn3 /-1./
	data xprcn5 /-1./
	data initeq /0/
*
*  #] declarations:
*  #[ check input:
	if (ltest) then
	    xcheck = xma - xmb - dmamb
	    if ( abs(xcheck) .gt. precx*max(abs(xma),abs(xmb),abs(
     +			dmamb))/xloss ) then
		print *,'ffxdbp: input not OK, dmamb <> xma-xmb',xcheck
	    endif
	    xcheck = -xp + xma - dmap
	    if ( abs(xcheck) .gt. precx*max(abs(xp),abs(xma),abs(
     +			dmap))/xloss ) then
		print *,'ffxdbp: input not OK, dmap <> xma - xp',xcheck
	    endif
	    xcheck = -xp + xmb - dmbp
	    if ( abs(xcheck) .gt. precx*max(abs(xp),abs(xmb),abs(
     +			dmbp))/xloss ) then
		print *,'ffxdbp: input not OK, dmbp <> xmb - xp',xcheck
	    endif
	endif
*  #] check input:
*  #[ which case:
*
*	sort according to the type of masscombination encountered:
*	100: both masses zero, 200: one equal to zero, 300: both equal
*	400: rest.
*
	if ( xma .eq. 0 ) then
		if ( xmb .eq. 0 ) then
			goto 100
		endif
		xm = xmb
		dmp = dmbp
		goto 200
	endif
	if ( xmb .eq. 0 ) then
		xm = xma
		dmp = dmap
		goto 200
	elseif ( dmamb .eq. 0 ) then
		xm = xma
		dmp = dmap
		goto 300
	elseif ( xma .gt. xmb ) then
		xm2 = xma
		xm1 = xmb
		dm1m2 = -dmamb
		dm1p = dmbp
		dm2p = dmap
	else
		xm1 = xma
		xm2 = xmb
		dm1m2 = dmamb
		dm1p = dmap
		dm2p = dmbp
	endif
	goto 400
*  #] which case:
*  #[ both masses equal to zero:
  100	continue
	if ( xp.ne.0 ) cdb0 = -1/xp
	cdb0p = -1
	return
*  #] both masses equal to zero:
*  #[ one mass equal to zero:
  200	continue
*
*	special case xp = 0
*
	if ( xp .eq. 0 ) then
	    cdb0p = 0
	    cdb0 = 1/(2*xm)
	    goto 990
*
*	special case xp = xm
*
	elseif ( dmp.eq.0 ) then
	    if ( lsmug ) then
		if ( DBLE(cmipj(1,3)).lt.DBLE(cmipj(2,3)) ) then
		    cdb0p = -1 - log(cmipj(1,3)*DBLE(1/xm))
		else
		    cdb0p = -1 - log(cmipj(2,3)*DBLE(1/xm))
		endif
	    else
		if ( initir.eq.0 ) then
		    initir = 1
		    print *,'ffxdbd: IR divergent B0'', using cutoff ',
     +		    	delta 
		endif
		if ( delta.eq.0 ) then
		    call fferr(74,ier)
		    cdb0p = 0
		else
		    cdb0p = -1 + log(xm/delta)/2
		endif
	    endif
	    cdb0 = cdb0p*(1/DBLE(xp))
	    goto 990
	endif
*
*	Normal case:
*
	x = xp/xm
	ax = abs(x)
	if ( ax .lt. xloss ) then
* 	#[ Taylor expansion:
	    if ( xprec0 .ne. precx ) then
		xprec0 = precx
		bdn001 = ffbnd(2,1,xninv)
		bdn005 = ffbnd(2,5,xninv)
		bdn010 = ffbnd(2,10,xninv)
		bdn015 = ffbnd(2,15,xninv)
		bdn020 = ffbnd(2,20,xninv)
	    endif
	    if ( lwarn .and. ax .gt. bdn020 ) then
	    	call ffwarn(15,ier,precx,xninv(21)*ax**20)
	    endif
	    if ( ax .gt. bdn015 ) then
		som = x*(xninv(17) + x*(xninv(18) + x*(xninv(19) +
     +		      x*(xninv(20) + x*(xninv(21) )))))
	    else
		som = 0
	    endif
	    if ( ax .gt. bdn010 ) then
		som = x*(xninv(12) + x*(xninv(13) + x*(xninv(14) +
     +		      x*(xninv(15) + x*(xninv(16) + som )))))
	    endif
	    if ( ax .gt. bdn005 ) then
		som = x*(xninv(7) + x*(xninv(8) + x*(xninv(9) +
     +		      x*(xninv(10) + x*(xninv(11) + som )))))
	    endif
	    if ( ax .gt. bdn001 ) then
		som = x*(xninv(3) + x*(xninv(4) + x*(xninv(5) +
     +		      x*(xninv(6) + som ))))
	    endif
	    cdb0p = x*(xninv(2) + som)
	    if ( lwrite ) then
		print *,'cdb0p = ',cdb0p
		print *,'verg   ',-1 - xm/xp*dfflo1(x,ier),1
	    endif
* 	#] Taylor expansion:
	else
* 	#[ short formula:
	    s = log(abs(dmp/xm))
	    cdb0p = -(1 + s*xm/xp)
	    if ( xp.gt.xm ) cdb0p = cdb0p+DCMPLX(DBLE(0),DBLE(xm/xp*pi))
* 	#] short formula:
	endif
	cdb0 = cdb0p*(1/DBLE(xp))
	goto 990
*  #] one mass equal to zero:
*  #[ both masses equal:
  300	continue
*
*	Both masses are equal.	Not only this speeds up things, some
*	cancellations have to be avoided as well.
*
*	first a special case
*
	if ( abs(xp) .lt. 8*xloss*xm ) then
* -#[	    taylor expansion:
*
*	    a Taylor expansion seems appropriate as the result will go
*	    as k^2 but seems to go as 1/k !!
*
*--#[	    data and bounds:
	    if ( initeq .eq. 0 ) then
		initeq = 1
		xpneq(1) = x1/6
		do 1 i=2,30
		    xpneq(i) = - xpneq(i-1)*DBLE(i)/DBLE(2*(2*i+1))
    1		continue
	    endif
	    if (xprceq .ne. precx ) then
*
*		calculate the boundaries for the number of terms to be
*		included in the taylorexpansion
*
		xprceq = precx
		bdeq01 = ffbnd(1,1,xpneq)
		bdeq05 = ffbnd(1,5,xpneq)
		bdeq11 = ffbnd(1,11,xpneq)
		bdeq17 = ffbnd(1,17,xpneq)
		bdeq25 = ffbnd(1,25,xpneq)
	    endif
*--#]	    data and bounds:
	    x = -xp/xm
	    ax = abs(x)
	    if ( lwarn .and. ax .gt. bdeq25 ) then
		call ffwarn(15,ier,precx,abs(xpneq(25))*ax**25)
	    endif
	    if ( ax .gt. bdeq17 ) then
		som = x*(xpneq(18) + x*(xpneq(19) + x*(xpneq(20) +
     +		x*(xpneq(21) + x*(xpneq(22) + x*(xpneq(23) +
     +		x*(xpneq(24) + x*(xpneq(25) ))))))))
	    else
		som = 0
	    endif
	    if ( ax .gt. bdeq11 ) then
		som = x*(xpneq(12) + x*(xpneq(13) + x*(xpneq(14) +
     +		x*(xpneq(15) + x*(xpneq(16) + x*(xpneq(17) + som ))))
     +		))
	    endif
	    if ( ax .gt. bdeq05 ) then
		som = x*(xpneq(6) + x*(xpneq(7) + x*(xpneq(8) + x*(
     +		xpneq(9) + x*(xpneq(10) + x*(xpneq(11) + som ))))))
	    endif
	    if ( ax .gt. bdeq01 ) then
		som = x*(xpneq(2) + x*(xpneq(3) + x*(xpneq(4) + x*(
     +		xpneq(5) + som ))))
	    endif
	    cdb0p = -x*(xpneq(1)+som)
	    if (lwrite) then
		print *,'ffxdbp: m1 = m2, Taylor expansion in ',x
		print *,'cdb0p = ',cdb0p
	    endif
	    if ( xp.ne.0 ) then
		cdb0 = cdb0p*(1/DBLE(xp))
	    else
		cdb0 = xpneq(1)/xm
	    endif
	    goto 990
* -#]	    taylor expansion:
	endif
* -#[	normal case:
*
*	normal case
*
	call ffxlmb(xlam,-xp,-xm,-xm,dmp,dmp,x0,ier)
	if ( xlam .eq. 0 ) then
	    call fferr(86,ier)
	    return
	elseif ( xlam .gt. 0 ) then
*	    cases 1,2 and 4
	    slam = sqrt(xlam)
	    s2a = dmp + xm
	    s2 = s2a + slam
	    if ( abs(s2) .gt. xloss*slam ) then
*		looks fine
		jsign = 1
	    else
		s2 = s2a - slam
		jsign = -1
	    endif
	    ax = abs(s2/(2*xm))
	    if ( ax .lt. xalogm ) then
		if ( lwarn ) call ffwarn(16,ier,ax,xalogm)
		s = 0
	    elseif( ax-1 .lt. .1 .and. s2 .gt. 0 ) then
*		In this case a quicker and more accurate way is to
*		calculate log(1-x).
		s2 = (xp - slam)
*		the following line is superfluous.
		if ( lwarn .and. abs(s2) .lt. xloss*slam )
     +			call ffwarn(17,ier,s2,slam)
		s = 2*xm/slam*dfflo1(s2/(2*xm),ier)
	    else
*		finally the normal case
		s = 2*xm/slam*log(ax)
		if ( jsign .eq. -1 ) s = -s
	    endif
	    if ( xp .gt. 2*xm ) then
*		in this case ( xlam>0, so xp>(2*m)^2) ) there also
*		is an imaginary part
		y = pi*2*xm/slam
	    else
		y = 0
	    endif
	else
*	    the root is complex (k^2 between 0 and (2*m1)^2)
	    slam = sqrt(-xlam)
	    s = 4*xm/slam*atan2(xp,slam)
	    y = 0
	endif
	if (lwrite) print *,'s =   ',s
	xx = s - 1
	if ( lwarn .and. abs(xx).lt.xloss ) call ffwarn(18,ier,xx,x1)
	cdb0p = DCMPLX(DBLE(xx),DBLE(y))
	cdb0 = cdb0p*(1/DBLE(xp))
	goto 990
* -#]	normal case:
*
*  #] both masses equal:
*  #[ unequal nonzero masses:
* -#[	get log(xm2/xm1):
  400	continue
	x = xm2/xm1
	if ( 1 .lt. xalogm*x ) then
	    call fferr(8,ier)
	    xlogmm = 0
	elseif ( abs(x-1) .lt. xloss ) then
	    xlogmm = dfflo1(dm1m2/xm1,ier)
	else
	    xlogmm = log(x)
	endif
* -#]	get log(xm2/xm1):
* -#[	xp = 0:
*
*	first a special case
*
	if ( xp .eq. 0 ) then
*
*	    repaired 19-nov-1993, see b2.frm
*
	    s1 = xm1*xm2*xlogmm/dm1m2**3
	    s2 = (xm1+xm2)/(2*dm1m2**2)
	    s = s1 + s2
	    if ( abs(s) .lt. xloss**2*s2 ) then
*
*		second try
*
		h = dfflo3(dm1m2/xm1,ier)
		s1 = -xm1*h/dm1m2**2
		s2 = 1/(2*xm1)
		s3 = xm1**2*h/dm1m2**3
		s = s1 + s2 + s3
		if ( abs(s) .lt. xloss*max(abs(s2),abs(s3)) ) then
		    call ffwarn(228,ier,s,s2)
		endif
	    endif
	    cdb0 = s
	    cdb0p = 0
	    goto 990
	endif
* -#]	xp = 0:
* -#[	normal case:
*
*	proceeding with the normal case
*
	call ffxlmb(xlam,-xp,-xm2,-xm1,dm2p,dm1p,dm1m2,ier)
	diff = xlam + xp*(dm2p+xm1)
	if ( lwrite ) print *,'diff = ',diff
	if ( abs(diff) .lt. xloss*xlam ) then
	    h = dm1m2**2 - xp*(xm1+xm2)
	    if ( lwrite ) print *,'diff+= ',h
	    if ( abs(h) .lt. xloss*dm1m2**2 ) then
		if ( dm1m2**2 .lt. abs(xlam) ) diff = h
		if ( lwarn ) then
		    call ffwarn(221,ier,diff,min(dm1m2**2,abs(xlam)))
		endif
	    endif
	endif
	if ( xlam .eq. 0 ) then
	    call fferr(86,ier)
	    return
	elseif ( xlam .gt. 0 ) then
*	    cases k^2 < -(m2+m1)^2 or k^2 > -(m2-m1)^2:
*--#[	    first try:
*	    first try the normal way
	    slam = sqrt(xlam)
	    s2a = dm2p + xm1
	    s2 = s2a + slam
	    if ( abs(s2) .gt. xloss*slam ) then
*		looks fine
		jsign = 1
	    else
		s2 = s2a - slam
		jsign = -1
	    endif
	    s2 = s2**2/(4*xm1*xm2)
	    if ( abs(s2) .lt. xalogm ) then
		call fferr(9,ier)
		s2 = 0
	    elseif ( abs(s2-1) .lt. xloss ) then
		if ( jsign.eq.1 ) then
		    if (lwrite) print *,'s2 ',-diff/(2*slam*xp)*log(s2)
		    s2 = -slam*(s2a+slam)/(2*xm1*xm2)
		    s2 = -diff/(2*slam*xp)*dfflo1(s2,ier)
		else
		    ier = ier + 50
		    print *,'ffxdb0: untested: s2 better in first try'
		    if (lwrite) print *,'s2 ',+diff/(2*slam*xp)*log(s2)
		    s2 = +slam*(s2a-slam)/(2*xm1*xm2)
		    s2 = +diff/(2*slam*xp)*dfflo1(s2,ier)
		endif
		if ( lwrite ) print *,'s2+ ',s2,jsign
	    else
		s2 = -diff/(2*slam*xp)*log(s2)
		if ( jsign .eq. -1 ) s2 = -s2
	    endif
	    s1 = -dm1m2*xlogmm/(2*xp)
	    xx = s1+s2-1
	    if (lwrite) then
		print *,'ffxdbp: lam>0, first try, xx  = ',xx,s1,s2,-1
	    endif
*--#]	    first try:
	    if ( abs(xx) .lt. xloss**2*max(abs(s1),abs(s2)) ) then
*--#[		second try:
*		this is unacceptable, try a better solution
		s1a = diff + slam*dm1m2
		if (lwrite) print *,'s1 = ',-s1a/(2*xp*slam),diff/
     +			(2*xp*slam)
		if ( abs(s1a) .gt. xloss*diff ) then
*		    this works
		    s1 = -s1a/(2*xp*slam)
		else
*		    by division a more accurate form can be found
		    s1 = -2*xm1*xm2*xp/(slam*(diff - slam*dm1m2))
		    if (lwrite) print *,'s1+= ',s1
		endif
		s = s1
		s1 = s1*xlogmm
		if ( abs(xp) .lt. xm2 ) then
		    s2a = xp - dm1m2
		else
		    s2a = xm2 - dm1p
		endif
		s2 = s2a - slam
		if (lwrite) print *,'s2 = ',s2/(2*xm2),slam/(2*xm2)
		if ( abs(s2) .gt. xloss*slam ) then
*		    at least reasonable
		    s2 = s2 / (2*xm2)
		else
*		    division again
		    s2 = (2*xp) / (s2a+slam)
		    if (lwrite) print *,'s2+= ',s2
		endif
		if ( abs(s2) .lt. .1 ) then
*		    choose a quick way to get the logarithm
		    s2 = dfflo1(s2,ier)
		else
		    h = abs(1-s2)
		    s2 = log(h)
		endif
		s2 = -diff/(slam*xp)*s2
		xx = s1 + s2 - 1
		if (lwrite) then
		    print *,'ffxdbp: lam>0, 2nd try, xx  = ',xx,s1,s2,-1
		endif
*--#]		second try:
		if ( abs(xx) .lt. xloss**2*max(abs(s1),abs(s2)) ) then
*--#[		    third try:
*		    (we accept two times xloss because that's the same
*		    as in this try)
*		    A Taylor expansion might work.  We expand
*		    inside the logs. Only do the necessary work.
*
*		#[ split up 1:
		    xnoe = s2a+slam
		    a = 1
		    b = 2/xnoe-1/xp
		    c = -4/(xp*xnoe)
		    d = sqrt((2/xnoe)**2 + 1/xp**2)
		    call ffroot(d1,d2,a,b,c,d,ier)
		    if ( xp.gt.0 ) then
			beta = d2
		    else
			beta = d1
		    endif
		    alpha = beta*diff/slam
		    alph1 = 1-alpha
		    if ( alph1 .lt. xloss ) then
			s1a = 4*xp**2*xm1*xm2/(slam*dm1m2*(diff-slam*
     +				dm1m2))
			s1b = -diff/slam*4*xm1*xp/(dm1m2*xnoe*(2*xp-
     +				xnoe))
			b = -1/xp
			c = -(2/xnoe)**2
			call ffroot(d1,d2,a,b,c,d,ier)
			if ( xp.gt.0 ) then
			    betm2n = d2
			else
			    betm2n = d1
			endif
			d1 = s1a + s1b - diff/slam*betm2n
			if ( lwrite ) then
			    print *,'alph1    = ',d1,s1a,s1b,-diff/slam*
     +				betm2n
			    print *,'verg       ',1-alpha
			endif
			xmax = max(abs(s1a),abs(s1b))
			if ( xmax .lt. 1 ) then
			    alph1 = d1
			else
			    xmax = 1
			endif
			if ( lwarn .and. abs(alph1).lt.xloss*xmax ) then
			    call ffwarn(222,ier,alph1,xmax)
			    if ( lwrite ) print *,'d1,s1a,s2b,... = ',
     +				d1,s1a,s1b,diff/slam*betm2n
			endif
		    else
			betm2n = beta - 2/xnoe
		    endif
		    if ( lwrite ) then
			print *,'     s1 - alph1 = ',s1-alph1
			print *,'     s2 - alpha = ',s2-alpha
		    endif
*		#] split up 1:
*		#[ s2:
*
*		    first s2:
*
  490		    continue
		    s2p = s2 - alpha
		    if ( abs(s2p) .lt. xloss*abs(s2) ) then
* -#[			bounds:
*			determine the boundaries for 1,5,10,15 terms
			if ( xprcn5 .ne. precx ) then
			    xprcn5 = precx
			    bdn501 = ffbnd(3,1,xinfac)
			    bdn505 = ffbnd(3,5,xinfac)
			    bdn510 = ffbnd(3,10,xinfac)
			    bdn515 = ffbnd(3,15,xinfac)
			endif
* -#]			bounds:
			x = beta*xp
			ax = abs(x)
			if ( lwarn .and. ax .gt. bdn515 ) then
*			    do not do the Taylor expansion
			    call ffwarn(23,ier,s2p,s2)
			    goto 495
			endif
			if ( ax .gt. bdn510 ) then
			    s2a = x*(xinfac(13) + x*(xinfac(14) + x*(
     +				     xinfac(15) + x*(xinfac(16) + x*(
     +				     xinfac(17))))))
			else
			    s2a = 0
			endif
			if ( ax .gt. bdn505 ) then
			    s2a = x*(xinfac(8) + x*(xinfac(9) + x*(
     +				    xinfac(10) + x*(xinfac(11) + x*(
     +				    xinfac(12) + s2a)))))
			endif
			if ( ax .gt. bdn501 ) then
			    s2a = x*(xinfac(4) + x*(xinfac(5) + x*(
     +				     xinfac(6) + x*(xinfac(7) + s2a))))
			endif
			s2a = x**3*(xinfac(3)+s2a)
			s2b = 2*xp/xnoe*(s2a + x**2/2)
			s2p = s2b - s2a
			if ( lwarn .and. abs(s2p).lt.xloss*abs(s2a) )
     +				call ffwarn(24,ier,s2p,s2a)
			s2p = -diff/(xp*slam)*dfflo1(s2p,ier)
			if (lwrite) then
			    print *,'ffxdbp: Taylor expansion of s2-a'
			    print *,'	     in x = ',x
			    print *,'	     gives s2p = ',s2p
			endif
		    endif
*		#] s2:
*		#[ s1:
*
*		    next s1:
*
  495		    continue
		    s1p = s1 - alph1
		    if ( abs(s1p) .lt. xloss*abs(s1) ) then
* -#[			bounds:
*			determine the boundaries for 1,5,10,15 terms
			if ( xprcn3 .ne. precx ) then
			    xprcn3 = precx
			    bdn301 = ffbnd(3,1,xinfac)
			    bdn305 = ffbnd(3,5,xinfac)
			    bdn310 = ffbnd(3,10,xinfac)
			    bdn315 = ffbnd(3,15,xinfac)
			endif
* -#]			bounds:
*
			x = slam*(diff-slam*dm1m2)*alph1/(2*xp*xm1*xm2)
			h = (2*xp*(xm1+xm2) - xp**2)/(slam-dm1m2)
			ax = abs(x)
			if ( lwarn .and. ax .gt. bdn315 ) then
*			    do not do the Taylor expansion
			    call ffwarn(21,ier,s1p,s1)
			    goto 500
			endif
*
*			see form job gets1.frm
*
			s1b = diff*(diff-slam*dm1m2)*betm2n/(2*xp*xm1*
     +				xm2)
			s1c = 1/(xm1*xnoe*(2*xp-xnoe))*(
     +				xp*( 4*xp*xm2 + 2*dm1m2**2/xm2*(xp-h) +
     +				2*dm1m2*(3*xp-h) - 8*dm1m2**2 )
     +				- 2*dm1m2**3/xm2*(3*xp-h)
     +				+ 4*dm1m2**4/xm2
     +				)
			if ( lwrite ) then
			    print *,'s1c was ',-2*xp/dm1m2 + 2*diff*
     +				(diff-slam*dm1m2)/(xm2*dm1m2*xnoe*(2*xp-
     +				xnoe)) + dm1m2/xm1
			    print *,'  en is ',s1c
			    print *,'s1b+s1c was ',dm1m2/xm1-x
			    print *,'      en is ',s1b+s1c
			endif
			s1d = x*dm1m2/xm1
			s1e = -x**2/2
			if ( ax .gt. bdn310 ) then
			    s1a = x*(xinfac(13) + x*(xinfac(14) + x*(
     +				     xinfac(15) + x*(xinfac(16) + x*(
     +				     xinfac(17))))))
			else
			    s1a = 0
			endif
			if ( ax .gt. bdn305 ) then
			    s1a = x*(xinfac(8) + x*(xinfac(9) + x*(
     +				   xinfac(10) + x*(xinfac(11) + x*(
     +				   xinfac(12) + s1a)))))
			endif
			if ( ax .gt. bdn301 ) then
			    s1a = x*(xinfac(4) + x*(xinfac(5) + x*(
     +				     xinfac(6) + x*(xinfac(7) + s1a))))
			endif
			s1a = -x**3 *(xinfac(3) + s1a)
			s1f = dm1m2/xm1*(x**2/2 - s1a)
			s1p = s1e + s1d + s1c + s1b + s1a + s1f
			xmax = max(abs(s1a),abs(s1b),abs(s1c),abs(s1d),
     +				abs(s1e))
			if ( lwarn .and. abs(s1p).lt.xloss*xmax ) then
			    call ffwarn(223,ier,s1p,xmax)
			    if ( lwrite )
     +				print *,'s1p,s1e,s1d,s1c,s1b,s1a,s1f = '
     +				,s1p,s1e,s1d,s1c,s1b,s1a,s1f
			endif
			s1p = s*dfflo1(s1p,ier)
			if (lwrite) then
			    print *,'s1a = ',s1a
			    print *,'s1b = ',s1b
			    print *,'s1c = ',s1c
			    print *,'s1d = ',s1d
			    print *,'s1e = ',s1e
			    print *,'s1f = ',s1f
			    print *,'s   = ',s
			    print *,'ffxdbp: Taylor exp. of s1-(1-a)'
			    print *,'        in x = ',x
			    print *,'        gives s1p = ',s1p
			    print *,'        verg        ',s*log(xm2/xm1
     +				*exp(x))
			endif
		    endif
*		#] s1:
*
*		    finally ...
*
  500		    continue
		    xx = s1p + s2p
		    if ( lwarn .and. abs(xx) .lt. xloss*abs(s1p) ) then
			call ffwarn(25,ier,xx,s1p)
		    endif
*--#]		    third try:
		endif
	    endif
	    if ( xp .gt. xm1+xm2 ) then
*--#[		imaginary part:
*		in this case ( xlam>0, so xp>(m1+m2)^2) ) there also
*		is an imaginary part
		y = -pi*diff/(slam*xp)
	    else
		y = 0
*--#]		imaginary part:
	    endif
	 else
*	    the root is complex (k^2 between -(m1+m2)^2 and -(m2-m1)^2)
*--#[	    first try:
	    slam = sqrt(-xlam)
	    xnoe = dm2p + xm1
	    s1 = -(dm1m2/(2*xp))*xlogmm
	    s2 = -diff/(slam*xp)*atan2(slam,xnoe)
	    xx = s1 + s2 - 1
	    if (lwrite) then
		print *,'ffxdbp: lam<0, first try, xx  = ',xx,s1,s2,-1
*		alpha = -xlam/(2*xp*xnoe)
*		alph1 = -(xp**2-dm1m2**2)/(2*xp*xnoe)
*		print *,'	 alpha = ',alpha
*		print *,'	 s1 = ',s1,' - 2alph1 = ',s1-2*alph1
*		print *,'	 s2 = ',s2,' - 2alpha = ',s2-2*alpha
	    endif
*--#]	    first try:
	    if ( lwarn .and. abs(xx).lt.xloss**2*max(abs(s1),abs(s2)) )
     +			then
		call ffwarn(224,ier,xx,max(abs(s1),abs(s2)))
	    endif
	    y = 0
	endif
  590	continue
	cdb0p = DCMPLX(DBLE(xx),DBLE(y))
	cdb0 = cdb0p*(1/DBLE(xp))
	goto 990
* -#]	normal case:
*  #] unequal nonzero masses:
*  #[ debug:
  990	continue
	if (lwrite) then
	    print *,'cdb0  = ',cdb0,cdb0p
	endif
*  #] debug:
*###] ffxdbp:
	end
*###[ ffxdir:
	subroutine ffxdir(cs,cfac,idone,xpi,dpipj,ipoin,ndiv,ier)
***#[*comment:***********************************************************
*									*
*	Check if this 4point function is IRdivergent and if so, get it	*
*	using ffxdbd and set idone to 1 (or 2 if 2 IR poles)		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipoin,idone,ndiv,ier
	DOUBLE COMPLEX cs,cfac
	DOUBLE PRECISION xpi(13),dpipj(10,13)
*
*	local variables
*
	integer i,j,k,l,ier0,ii(6),notijk(4,4,4)
	DOUBLE PRECISION del4s,rloss
	save notijk
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data notijk/
     +	0,0,0,0,0,0,4,3,0,4,0,2,0,3,2,0,0,0,4,3,0,0,0,0,4,0,0,1,3,0,1,0,
     +	0,4,0,2,4,0,0,1,0,0,0,0,2,1,0,0,0,3,2,0,3,0,1,0,2,1,0,0,0,0,0,0/
*
*  #] declarations:
*  #[ work:
*
	idone = 0
	do 25 i=1,4
	    if ( xpi(i) .ne. 0 ) goto 25
	    do 24 j=1,3
		if ( j .eq. i ) goto 24
		if ( dpipj(j,inx(j,i)) .ne. 0 ) goto 24
		do 23 k=j+1,4
		    if ( k .eq. i ) goto 23
		    if ( dpipj(k,inx(k,i)) .ne. 0 ) goto 23
*
*		    we found an IR divergent function;
*		    first check whether it is linearly divergent
*
		    l = notijk(k,j,i)
		    if ( ltest ) then
			if ( l.eq.0 .or. l.eq.i .or. l.eq.j .or. l.eq.k
     +				) print *,'ffxkbd: error, l wrong: ',l
		    endif
*
*		    do we have a linear divergence on our hands?
*
		    if ( dpipj(l,inx(l,i)) .eq. 0 ) then
			if ( lwrite ) print *,'ffxdir: found ',
     +				'linearly divergent combo'
		    elseif ( ndiv.gt.0 ) then
			if ( lwrite ) print *,'Not enough singularities'
			cs = 0
			cfac = 1
			idone = 1
			return
		    endif
*
*		    the complex case
*
		    if ( lsmug ) then
*
*			use Wim & Ansgard's formulae whenever possible
*
			if ( c2sisj(i,j).eq.0 .and. c2sisj(i,k).eq.0 )
     +				then
			    call ffxdbd(cs,cfac,xpi,dpipj,i,j,k,l,ier)
			    goto 98
			endif
			if ( c2sisj(i,j).eq.0 .and. dpipj(i,inx(i,l))
     +				.eq.0 .and. c2sisj(i,l).eq.0 ) then
			    call ffxdbd(cs,cfac,xpi,dpipj,i,j,l,k,ier)
			    goto 98
			endif
			if ( c2sisj(i,k).eq.0 .and. dpipj(i,inx(i,l))
     +				.eq.0 .and. c2sisj(i,l).eq.0 ) then
			    call ffxdbd(cs,cfac,xpi,dpipj,i,k,l,j,ier)
			    goto 98
			endif
*
*			is it nasty?
*
			if ( dpipj(i,inx(i,l)).eq.0 ) then
			    if ( c2sisj(j,i).eq.0 ) then
				goto 99
			    elseif ( c2sisj(k,i).eq.0 ) then
				goto 99
			    elseif ( c2sisj(l,i).eq.0 ) then
				goto 99
			    else
				call fferr(71,ier)
				print *,'xpi = ',xpi
				print *,'id,idsub = ',id,idsub
				return
			    endif
			endif
*
*			then it just is logarithmiocally divergent
*			let the ffxc0i handle this
*
		    else
*
*			the real case
*
			if ( dpipj(i,inx(i,l)).eq.0 ) then
			    call fferr(73,ier)
			    print *,'xpi = ',xpi
			    return
			endif
			call ffxdbd(cs,cfac,xpi,dpipj,i,j,k,l,ier)
			goto 98
		    endif
   23		continue
   24	    continue
   25	continue
	idone = 0
	lnasty = .FALSE.
	return
*
*	clean up
*
   98	continue
	if ( ldot .and. ipoin .eq. 4 ) then
	    ier0 = 0
	    if ( idot.lt.1 ) then
	    	call ffdot4(fpij4,xpi,dpipj,10,ier0)
	    endif
	    ii(1)= 5
	    ii(2)= 6
	    ii(3)= 7
	    ii(4)= 8
	    ii(5)= 9
	    ii(6)= 10
	    if ( idot.lt.2 ) then
		fidel3 = ier0
		call ffdl3p(fdel3,fpij4,10,ii,ii,fidel3)
	    endif
	    if ( ltest ) then
		call ffdel4(del4s,xpi,fpij4,10,ier0)
		rloss = xloss*DBLE(10)**(-mod(ier0,50))
		if ( rloss*abs(del4s-fdel4s) .gt. precx*abs(del4s) )
     +			print *,'ffxdir: error: del4s wrong: ',fdel4s,
     +			del4s,fdel4s-del4s,ier0
	    endif
	endif
*
*	and finito
*
	idone = 1
	if ( xpi(j) .eq. 0 .or. xpi(k) .eq. 0 ) idone = 2
	if ( xpi(j) .eq. 0 .and. xpi(k) .eq. 0 ) idone = 3
	return
*
*	nasty - set some flags
*
   99	continue
	if ( lwrite ) print *,'ffxdir: nasty D0'
	lnasty = .TRUE.
	return
*
*  #] work:
*###] ffxdir:
	end
*###[ ffxdbd:
	subroutine ffxdbd(csom,cfac,xpi,dpipj,ilam,i1,i4,ic,ier)
***#[*comment:***********************************************************
*									*
*	The IR divergent fourpoint function with real masses		*
*	according to Beenakker & Denner, Nucl.Phys.B338(1990)349.	*
*									*
*	Input:	xpi(13)	      real	momenta^2			*
*		dpipj(10,13)  real	xpi(i)-xpi(j)			*
*		ilam	      integer	position of m=0			*
*		i1,i4	      integer	position of other 2 IR masses	*
*		ic	      integer	position of complex mass	*
*	/ffcut/	delta	      real	cutoff to use instead of lam^2	*
*									*
*	Output:	csom,cfac	      complex	D0  = csom*cfac		*
*		ier	      integer	number of digits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ilam,i1,i4,ic,ier
	DOUBLE COMPLEX csom,cfac
	DOUBLE PRECISION xpi(13),dpipj(10,13)
*
*	local variables
*
	integer ier0,ier1,ipi12,ip,init,is,i2,i3,i,iepst,iepss,ieps2,
     +		ieps3
	DOUBLE PRECISION absc,xmax
	DOUBLE PRECISION xxs(3),xxt(1),xx2(3),xx3(3),xm0,xm1,xm4,xlam,
     +		d,dfflo1,fac
	DOUBLE COMPLEX c,cs(21),z,zlg,som,cxt
	DOUBLE COMPLEX zxfflg,zfflog
	save init
*
*	common blocks
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data init /0/
*
*  #] declarations:
*  #[ check input:
*
	if ( init .eq. 0 ) then
	    init = 1
	    print *,'ffxdbd: using IR cutoff delta = lam^2 = ',delta
	endif
	if ( lwrite ) then
	    print *,'ffxdbd: input: ilam,i1,i4,ic = ',ilam,i1,i4,ic
	endif
	if ( ltest ) then
	    if ( delta .eq. 0 ) print *,'ffxdbd: error: (IR)delta = 0!'
	    if ( xpi(ilam) .ne. 0 ) print *,'ffxdbd: error: lam != 0 ',
     +		ilam,xpi(ilam)
	    if ( dpipj(i1,inx(ilam,i1)) .ne. 0 ) print *,
     +		'ffxdbd: error: m1^2 != p1^2 ',i1,inx(ilam,i1),xpi(i1),
     +		xpi(inx(ilam,i1)),dpipj(i1,inx(ilam,i1))
	    if ( dpipj(i4,inx(ilam,i4)) .ne. 0 ) print *,
     +		'ffxdbd: error: m4^2 != p4^2 ',i4,inx(ilam,i4),xpi(i4),
     +		xpi(inx(ilam,i4)),dpipj(i4,inx(ilam,i4))
	    if ( lsmug ) then
	    if ( c2sisj(i1,ilam).ne.0 ) print *,'ffxdbd: error: m(',i1,
     +		') not onshell, c2sisj(',i1,ilam,') = ',c2sisj(i1,ilam)
	    if ( c2sisj(i4,ilam).ne.0 ) print *,'ffxdbd: error: m(',i4,
     +		') not onshell, c2sisj(',i4,ilam,') = ',c2sisj(i4,ilam)
	    endif
	endif
*
*  #] check input:
*  #[ preliminaries:
*
	csom = 0
	cfac = 1
	xm0 = sqrt(xpi(ic))
	xm1 = sqrt(xpi(i1))
	xm4 = sqrt(xpi(i4))
	xlam = sqrt(delta)
*
*  #] preliminaries:
*  #[ special case m0=0, m1=m2, m3=m4:
	if ( xpi(ic) .eq. 0 ) then
*
*	    even more special case: 2 points of IR divergence:
*
	    if ( dpipj(i1,inx(ic,i1)).eq.0 .and.
     +		 dpipj(i4,inx(ic,i4)).eq.0 ) then
		if ( lwrite ) print *,'ffxdbd: doubly IR case'
		ier0 = 0
		call ffxkfn(xxs,iepss,xpi(inx(i1,i4)),xm1,xm4,ier0)
		if ( ier0.ge.100 ) then
		    call fferr(44,ier)
		    return
		endif
		ier = ier + ier0
		if ( abs(xxs(2)).gt.xloss ) then
		    zlg = zxfflg(xxs(1),iepss,x0,ier)
		else
		    zlg = DBLE(dfflo1(xxs(2),ier))
		endif
		csom = -2*zlg*zxfflg(-delta/xpi(inx(ilam,ic)),-2,x0,ier)
		fac = xxs(1)/(xm1*xm4*xpi(inx(ilam,ic))*xxs(2)*xxs(3))
		cfac = fac
		if ( ldot .and. idot.lt.4 ) then
		    fdel4s = 1/(16*fac**2)
		    if ( lwrite ) print *,'del4s = ',fdel4s
		endif
		return
	    endif
*  #] special case m0=0, m1=m2, m3=m4:
*  #[ special case m0=0, m1=m2, m3!=m4:
	    if ( dpipj(i1,inx(ic,i1)).eq.0 .or.
     +		 dpipj(i4,inx(ic,i4)).eq.0 ) then
		if ( dpipj(i1,inx(ic,i1)).ne.0 ) then
		    i = i4
		    i4 = i1
		    i1 = i
		endif
		if ( lwrite ) print *,'ffxdbd: special case m0=0, ',
     +			'm1=m2 but m3!=m4'
*
*		From Wim Beenakker, Priv.Comm.
*
		ier0 = 0
		call ffxkfn(xxs,iepss,xpi(inx(i1,i4)),xm1,xm4,ier0)
		if ( ier0.ge.100 ) then
		    call fferr(44,ier)
		    return
		endif
		ier = ier + ier0
		ier0 = ier
		ier1 = ier
		if ( abs(xxs(2)).gt.xloss ) then
		    zlg = zxfflg(xxs(1),iepss,x0,ier0)
		else
		    zlg = DBLE(dfflo1(xxs(2),ier0))
		endif
		cs(1) = zlg**2
		ier1 = max(ier0,ier1)
		ier0 = ier
		if ( xxs(1)**2.lt.xloss ) then
		    cs(2) = -2*DBLE(dfflo1(xxs(1)**2,ier0))*zlg
		else
		    cs(2) = -2*zxfflg(xxs(2)*xxs(3),0,x0,ier0)*zlg
		endif
		ier1 = max(ier0,ier1)
		ier0 = ier
		cs(3) = zxfflg(delta/xpi(i4),0,x0,ier0)*zlg
		ier1 = max(ier0,ier1)
		ier0 = ier
		cs(4) = 2*zxfflg(dpipj(inx(ic,i4),i4)/xpi(inx(ilam,ic)),
     +			-1,dpipj(inx(ic,i4),i4),ier0)*zlg
		ier1 = max(ier0,ier1)
		ier0 = ier
		call ffzxdl(cs(5),ip,zlg,xxs(1)**2,iepss,ier0)
		cs(5) = -cs(5)
		ipi12 = -ip + 2
		ier1 = max(ier0,ier1)
		ier = ier1
		som = cs(1) + cs(2) + cs(3) + cs(4) + cs(5) +
     +			ipi12*DBLE(pi12)
		xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)),
     +			absc(cs(4)),absc(cs(5)))
		if ( lwarn .and. absc(som) .lt. xloss*xmax )
     +			call ffwarn(194,ier,absc(som),xmax)
*
		if ( lwrite ) then
		    print *,'cs  = '
		    print '(i5,2e16.8)',(i,cs(i),i=1,5),6,ipi12*pi12
		    print '(a,2e16.8,i4)','som = ',som,ier
		endif
		csom = som
		fac = -xxs(1)/(xm1*xm4*xpi(inx(ilam,ic))*xxs(2)*xxs(3))
		cfac = fac
		if ( ldot .and. idot.lt.4 ) then
		    fdel4s = 1/(16*fac**2)
		    if ( lwrite ) print *,'del4s = ',fdel4s
		endif
		return
	    endif
*  #] special case m0=0, m1=m2, m3!=m4:
*  #[ special case m0=0, m1!=m2, m3!=m4:
*
*	    This also crashes...
*
	    xm0 = precx*max(xm1,xm4)
	    if ( lwrite ) print *,'ffxdir: dirty hack, put m0 != 0',xm0
	endif
*  #] special case m0=0, m1!=m2, m3!=m4:
*  #[ get dimensionless vars:
*
*	we follow the notation of Wim & Ansgar closely
*	remember that for -pi we have ieps=+2 and v.v.
*
	if ( lsmug ) then
*	    all is not what it seems
	    if ( nschem .ge. 3 ) then
		cxt = DBLE(xm0*xlam)/c2sisj(ic,ilam)
	    else
		cxt = DBLE(xm0*xlam)/DBLE(c2sisj(ic,ilam))
	    endif
	else
	    if ( dpipj(ic,inx(ilam,ic)) .eq. 0 ) then
		call fferr(73,ier)
		print *,'xpi = ',xpi
		return
	    endif
	    xxt(1) = xm0*xlam/dpipj(ic,inx(ilam,ic))
	endif
	iepst = -2
	ier1 = 0
	ier0 = 0
	call ffxkfn(xxs,iepss,xpi(inx(i1,i4)),xm1,xm4,ier0)
	ier1 = max(ier0,ier1)
	ier0 = 0
	call ffxkfn(xx2,ieps2,xpi(inx(i1,ic)),xm1,xm0,ier0)
	ier1 = max(ier0,ier1)
	ier0 = 0
	call ffxkfn(xx3,ieps3,xpi(inx(i4,ic)),xm4,xm0,ier0)
	ier1 = max(ier0,ier1)
	if ( ier1 .ge. 100 ) then
	    call ffzdbd(csom,cfac,xpi,dpipj,ilam,i1,i4,ic,ier)
	    return
	endif
	ier = ier + ier1
*
	if ( lwrite ) then
	    print *,'IR divergent fourpoint function according to ',
     +		'Beenakker and Denner'
	    if ( lsmug ) then
		print *,'cxt = ',cxt
	    else
		print *,'xxt = ',xxt,iepst
	    endif
	    print *,'xxs = ',xxs,iepss
	    print *,'xx2 = ',xx2,ieps2
	    print *,'xx3 = ',xx3,ieps3
	endif
*  #] get dimensionless vars:
*  #[ fill array:
*
	ier1 = 0
	ier0 = 0
	zlg = zxfflg(xxs(1),iepss,x0,ier)
	d = xxs(1)**2
	if ( abs(d) .lt. xloss ) then
	    cs(1) = 2*zlg*DBLE(dfflo1(d,ier0))
	else
	    cs(1) = 2*zlg*zxfflg(xxs(2)*xxs(3),-iepss,x0,ier0)
	endif
	ier1 = max(ier0,ier1)
	ier0 = 0
	if ( lsmug ) then
	    cs(2) = -2*zlg*zfflog(cxt,iepst,c0,ier0)
	else
	    cs(2) = -2*zlg*zxfflg(xxt(1),iepst,x0,ier0)
	endif
	ier1 = max(ier0,ier1)
*
	ipi12 = 6
*
	ier0 = 0
	call ffzxdl(cs(3),ip,zlg,xxs(1)**2,iepss,ier0)
	ipi12 = ipi12 + ip
	ier1 = max(ier0,ier1)
	ier0 = 0
	if ( abs(xx2(2)) .gt. xloss ) then
	    z = zxfflg(xx2(1),ieps2,x0,ier0)
	else
	    z = dfflo1(xx2(2),ier0)
	endif
	cs(4) = z**2
	ier1 = max(ier0,ier1)
	ier0 = 0
	if ( abs(xx3(2)) .gt. xloss ) then
	    z = zxfflg(xx3(1),ieps3,x0,ier0)
	else
	    z = dfflo1(xx3(2),ier0)
	endif
	cs(5) = z**2
	ier1 = max(ier0,ier1)
*
	is = 6
	do 110 i2=-1,+1,2
	    do 100 i3=-1,+1,2
*
		ier0 = 0
		call ffzxdl(cs(is),ip,zlg,xxs(1)*xx2(1)**i2*xx3(1)**i3,
     +			0,ier0)
		cs(is) = -cs(is)
		ipi12 = ipi12 - ip
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		if ( abs(xxs(2)) .gt. xloss ) then
		     cs(is) = -zlg*zxfflg(xxs(1),iepss,x0,ier0)
		else
		     cs(is) = -zlg*DBLE(dfflo1(xxs(2),ier0))
		endif
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		if ( abs(xx2(2)) .gt. xloss ) then
		    cs(is) = -zlg*zxfflg(xx2(1)**i2,i2*ieps2,x0,ier0)
		elseif ( i2.eq.1 ) then
		    cs(is) = -zlg*DBLE(dfflo1(xx2(2),ier0))
		else
		    cs(is) = -zlg*DBLE(dfflo1(-xx2(2)/xx2(1),ier0))
		endif
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		if ( abs(xx3(2)) .gt. xloss ) then
		    cs(is) = -zlg*zxfflg(xx3(1)**i3,i3*ieps3,x0,ier0)
		elseif ( i3.eq.1 ) then
		    cs(is) = -zlg*DBLE(dfflo1(xx3(2),ier0))
		else
		    cs(is) = -zlg*DBLE(dfflo1(-xx3(2)/xx3(1),ier0))
		endif
		is = is + 1
		ier1 = max(ier0,ier1)
*
  100	    continue
  110	continue
	ier = ier + ier1
*
*  #] fill array:
*  #[ sum:
*
	som = 0
	xmax = 0
	is = is - 1
	do 200 i=1,is
	    som = som + cs(i)
	    xmax = max(xmax,absc(cs(i)))
  200	continue
	som = som + ipi12*DBLE(pi12)
	if ( lwarn .and. absc(som) .lt. xloss*xmax )
     +		call ffwarn(194,ier,absc(som),xmax)
*
*  #] sum:
*  #[ overall factors:
*
	csom = som
	if ( lsmug ) then
	    if ( nschem .ge. 2 ) then
		cfac = -DBLE(xxs(1)/((xm1*xm4*xxs(2)*xxs(3))))/
     +			c2sisj(ilam,ic)
	    else
		cfac = -DBLE(xxs(1))/(DBLE(xm1*xm4*xxs(2)*xxs(3))*
     +			DBLE(c2sisj(ilam,ic)))
	    endif
	    if ( ldot .and. idot.lt.4 ) then
		fdel4s = 16*(xm1*xm4*dpipj(inx(ilam,ic),ic)*xxs(2)*
     +			xxs(3)/xxs(1))**2
	    endif
	else
	    fac = xxs(1)/(xm1*xm4*dpipj(inx(ilam,ic),ic)*xxs(2)*xxs(3))
	    cfac = fac
	    if ( ldot .and. idot.lt.4 ) then
		fdel4s = 1/(16*fac**2)
		if ( lwrite ) print *,'del4s = ',fdel4s
	    endif
	endif
*
*  #] overall factors:
*  #[ print debug info:
	if ( lwrite ) then
	    print *,'cs = '
	    do 910 i=1,is
		print *,i,cs(i)
  910	    continue
	    print *,'som = ',som,ipi12
	    print *,'cd0 = ',csom*cfac
	endif
*  #] print debug info:
*###] ffxdbd:
	end
*###[ ffxkfn:
	subroutine ffxkfn(x,ieps,xpi,xm,xmp,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the K-function in this paper:				*
*									*
*			      1-sqrt(1-4*m*mp/(z-(m-mp)^2))		*
*		K(p^2,m,mp) = -----------------------------		*
*			      1+sqrt(1-4*m*mp/(z-(m-mp)^2))		*
*									*
*	and fill x(1) = -K, x(2) = 1+K, x(3) = 1-K			*
*	ieps gives the sign of the imaginary part: -2 -> +ieps and v.v. *
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ieps,ier
	DOUBLE PRECISION x(3),xpi,xm,xmp
*
*	local variables
*
	DOUBLE PRECISION wortel,xx1,xx2,xx3
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ work:
*
*	special case
*
	if ( xpi.eq.0 .and. xm.eq.xmp ) then
	    x(1) = 1
	    x(2) = 0
	    x(3) = 2
	    return
	endif
*
*	normal case
*
	xx1 = xpi - (xm-xmp)**2
	if ( lwarn .and. abs(xx1) .lt. xloss*max(abs(xpi),xm**2)
     +		) then
	    call ffwarn(178,ier,xx1,max(xpi,xm**2))
	    if ( lwrite ) print *,'need extra input'
	endif
	xx2 = 1 - 4*xm*xmp/xx1
	if ( lwarn .and. abs(xx2) .lt. xloss )
     +	    call ffwarn(179,ier,xx2,x1)
	if ( xx2 .lt. 0 ) then
	    if ( lwrite ) then
		print *,'ffxkfn: cannot handle s < 4*m*mp, to ffzdbd'
		print *,'  s,m,mp = ',xpi,xm,xmp
	    endif
	    ier = ier + 100
	    return
	endif
	wortel = sqrt(xx2)
	xx3 = 1/(1+wortel)
	x(1) = -4*xm*xmp*xx3**2/xx1
	x(2) = 2*xx3
	x(3) = 2*wortel*xx3
*
	ieps = -2
*
*  #] work:
*  #[ print output:
	if ( lwrite ) then
	    print *,'ffxkfn: input: xpi,xm,xmp = ',xpi,xm,xmp
	    print *,'        output: x,ier = ',x,ier
	endif
*  #] print output:
*###] ffxkfn:
	end
*###[ ffzdbd:
	subroutine ffzdbd(csom,cfac,xpi,dpipj,ilam,i1,i4,ic,ier)
***#[*comment:***********************************************************
*									*
*	The IR divergent fourpoint function with real masses		*
*	according to Beenakker & Denner, Nucl.Phys.B338(1990)349.	*
*	but in the case at least one of the roots is complex		*
*									*
*	Input:	xpi(13)	      real	momenta^2			*
*		dpipj(10,13)  real	xpi(i)-xpi(j)			*
*		ilam	      integer	position of m=0			*
*		i1,i4	      integer	position of other 2 IR masses	*
*		ic	      integer	position of complex mass	*
*	/ffcut/	delta	      real	cutoff to use instead of lam^2	*
*									*
*	Output:	csom,cfac	      complex	D0  = csom*cfac		*
*		ier	      integer	number of digits lost		*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ilam,i1,i4,ic,ier
	DOUBLE COMPLEX csom,cfac
	DOUBLE PRECISION xpi(13),dpipj(10,13)
*
*	local variables
*
	integer ier0,ier1,ipi12,ip,init,is,i2,i3,i,iepst,iepss,ieps2,
     +		ieps3
	DOUBLE PRECISION absc,xmax
	DOUBLE PRECISION xm0,xm1,xm4,xlam,xxt(1)
	DOUBLE COMPLEX c,cs(21),z,zlg,som,cxt,cxs(3),cx2(3),cx3(3)
	DOUBLE COMPLEX zxfflg,zfflog,zfflo1
	save init
*
*	common blocks
*
	include 'ff.h'
	DOUBLE PRECISION delta
	common /ffcut/ delta
*
*	statement function
*
	absc(c) = abs(DBLE(c)) + abs(DIMAG(c))
*
*	data
*
	data init /0/
*
*  #] declarations:
*  #[ check input:
*
	if ( init .eq. 0 ) then
	    init = 1
	    print *,'ffzdbd: using IR cutoff delta = lam^2 = ',delta
	endif
	if ( lwrite ) then
	    print *,'ffzdbd: input: ilam,i1,i4,ic = ',ilam,i1,i4,ic
	endif
	if ( ltest ) then
	    if ( delta .eq. 0 ) print *,'ffzdbd: error: (IR)delta = 0!'
	    if ( xpi(ilam) .ne. 0 ) print *,'ffzdbd: error: lam != 0 ',
     +		ilam,xpi(ilam)
	    if ( dpipj(i1,inx(ilam,i1)) .ne. 0 ) print *,
     +		'ffzdbd: error: m1^2 != p1^2 ',i1,inx(ilam,i1),xpi(i1),
     +		xpi(inx(ilam,i1)),dpipj(i1,inx(ilam,i1))
	    if ( dpipj(i4,inx(ilam,i4)) .ne. 0 ) print *,
     +		'ffzdbd: error: m4^2 != p4^2 ',i4,inx(ilam,i4),xpi(i4),
     +		xpi(inx(ilam,i4)),dpipj(i4,inx(ilam,i4))
	endif
*
*  #] check input:
*  #[ preliminaries:
*
	xm0 = sqrt(xpi(ic))
	xm1 = sqrt(xpi(i1))
	xm4 = sqrt(xpi(i4))
	xlam = sqrt(delta)
*
*  #] preliminaries:
*  #[ special case m0=0, m1=m2, m3!=m4:
*	UNPHYSICAL!
*	if ( xpi(ic) .eq. 0 ) then
*	    if ( dpipj(i1,inx(ic,i1)).eq.0 .or.
*     +		 dpipj(i4,inx(ic,i4)).eq.0 ) then
*		if ( dpipj(i1,inx(ic,i1)).ne.0 ) then
*		    i = i4
*		    i4 = i1
*		    i1 = i
*		endif
*		if ( lwrite ) print *,'ffzdbd: special case m0=0, ',
*     +			'm1=m2 but m3!=m4'
**
*		From Wim Beenakker, Priv.Comm.
**
*		call ffzkfn(cxs,iepss,xpi(inx(i1,i4)),xm1,xm4,ier)
*		ier0 = ier
*		ier1 = ier
*		if ( absc(cxs(2)).gt.xloss ) then
*		    zlg = zfflog(cxs(1),iepss,c0,ier0)
*		else
*		    zlg = zfflo1(cxs(2),ier0)
*		endif
*		cs(1) = zlg**2
*		ier1 = max(ier0,ier1)
*		ier0 = ier
*		if ( absc(cxs(1))**2.lt.xloss ) then
*		    cs(2) = -2*zfflo1(cxs(1)**2,ier0)*zlg
*		else
*		    cs(2) = -2*zfflog(cxs(2)*cxs(3),0,c0,ier0)*zlg
*		endif
*		ier1 = max(ier0,ier1)
*		ier0 = ier
*		cs(3) = zxfflg(delta/xpi(i4),0,x0,ier0)*zlg
*		ier1 = max(ier0,ier1)
*		ier0 = ier
*		cs(4) = 2*zxfflg(dpipj(inx(ic,i4),i4)/xpi(inx(ilam,ic)),
*     +			-1,dpipj(inx(ic,i4),i4),ier0)*zlg
*		ier1 = max(ier0,ier1)
*		ier0 = ier
*		call ffzzdl(cs(5),ip,zlg,cxs(1)**2,ier0)
*		cs(5) = -cs(5)
*		ipi12 = -ip + 2
*		ier1 = max(ier0,ier1)
*		ier = ier1
*		som = cs(1) + cs(2) + cs(3) + cs(4) + cs(5) +
*     +			ipi12*DBLE(pi12)
*		xmax = max(absc(cs(1)),absc(cs(2)),absc(cs(3)),
*     +			absc(cs(4)),absc(cs(5)))
*		if ( lwarn .and. absc(som) .lt. xloss*xmax )
*     +			call ffwarn(194,ier,absc(som),xmax)
**
*		if ( lwrite ) then
*		    print *,'cs  = '
*		    print '(i5,2e16.8)',(i,cs(i),i=1,5),6,ipi12*pi12
*		    print '(a,2e16.8,i4)','som = ',som,ier
*		endif
*		csom = som
*		cfac = -cxs(1)/(xm1*xm4*xpi(inx(ilam,ic))*cxs(2)*cxs(3))
*		if ( ldot .and. idot.lt.4 ) then
*		    fdel4s = 1/(16*DBLE(cfac)**2)
*		    if ( xloss*abs(DIMAG(cfac)) .gt. precc*abs(DBLE(cfac
*     +			)) ) then
*			print *,'ffzdbd: error: fac is not real: ',cfac
*		    endif
*		    if ( lwrite ) print *,'del4s = ',fdel4s
*		endif
*		return
*	    endif
**
*	    otherwise the normal case is OK
**
*	endif
*  #] special case m0=0, m1=m2, m3!=m4:
*  #[ get dimensionless vars:
*
*	we follow the notation of Wim & Ansgar closely
*	remember that for -pi we have ieps=+2 and v.v.
*
	if ( lsmug ) then
*	    all is not what it seems
	    if ( nschem .ge. 3 ) then
		cxt = DBLE(xm0*xlam)/c2sisj(ic,ilam)
	    else
		cxt = DBLE(xm0*xlam)/DBLE(c2sisj(ic,ilam))
	    endif
	else
	    xxt(1) = xm0*xlam/dpipj(ic,inx(ilam,ic))
	endif
	iepst = -2
	ier1 = 0
	ier0 = 0
	call ffzkfn(cxs,iepss,xpi(inx(i1,i4)),xm1,xm4,ier0)
	ier1 = max(ier0,ier1)
	ier0 = 0
	call ffzkfn(cx2,ieps2,xpi(inx(i1,ic)),xm1,xm0,ier0)
	ier1 = max(ier0,ier1)
	ier0 = 0
	call ffzkfn(cx3,ieps3,xpi(inx(i4,ic)),xm4,xm0,ier0)
	ier1 = max(ier0,ier1)
	ier = ier + ier1
*
	if ( lwrite ) then
	    print *,'IR divergent fourpoint function according to ',
     +		'Beenakker and Denner'
	    if ( lsmug ) then
		print *,'cxt = ',cxt
	    else
		print *,'xxt = ',xxt,iepst
	    endif
	    print *,'cxs = ',cxs,iepss
	    print *,'cx2 = ',cx2,ieps2
	    print *,'cx3 = ',cx3,ieps3
	endif
*  #] get dimensionless vars:
*  #[ fill array:
*
	ier1 = 0
	ier0 = 0
	zlg = zfflog(cxs(1),iepss,c0,ier)
	c = cxs(1)**2
	if ( absc(c) .lt. xloss ) then
	    cs(1) = 2*zlg*zfflo1(c,ier0)
	else
	    cs(1) = 2*zlg*zfflog(cxs(2)*cxs(3),-iepss,c0,ier0)
	endif
	ier1 = max(ier0,ier1)
	ier0 = 0
	if ( lsmug ) then
	    cs(2) = -2*zlg*zfflog(cxt,iepst,c0,ier0)
	else
	    cs(2) = -2*zlg*zxfflg(xxt(1),iepst,x0,ier0)
	endif
	ier1 = max(ier0,ier1)
*
	ipi12 = 6
*
	ier0 = 0
	call ffzzdl(cs(3),ip,zlg,cxs(1)**2,ier0)
	ipi12 = ipi12 + ip
	ier1 = max(ier0,ier1)
	ier0 = 0
	z = zfflog(cx2(1),ieps2,c0,ier0)
	cs(4) = z**2
	ier1 = max(ier0,ier1)
	ier0 = 0
	z = zfflog(cx3(1),ieps3,c0,ier0)
	cs(5) = z**2
	ier1 = max(ier0,ier1)
*
	is = 6
	do 110 i2=-1,+1,2
	    do 100 i3=-1,+1,2
*
		ier0 = 0
		call ffzzdl(cs(is),ip,zlg,cxs(1)*cx2(1)**i2*cx3(1)**i3,
     +			ier0)
		cs(is) = -cs(is)
		ipi12 = ipi12 - ip
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		cs(is) = -zlg*zfflog(cxs(1),iepss,c0,ier0)
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		cs(is) = -zlg*zfflog(cx2(1)**i2,i2*ieps2,c0,ier0)
		is = is + 1
		ier1 = max(ier0,ier1)
*
		ier0 = 0
		cs(is) = -zlg*zfflog(cx3(1)**i3,i3*ieps3,c0,ier0)
		is = is + 1
		ier1 = max(ier0,ier1)
*
  100	    continue
  110	continue
	ier = ier + ier1
*
*  #] fill array:
*  #[ sum:
*
	som = 0
	xmax = 0
	is = is - 1
	do 200 i=1,is
	    som = som + cs(i)
	    xmax = max(xmax,absc(cs(i)))
  200	continue
	som = som + ipi12*DBLE(pi12)
	if ( lwarn .and. absc(som) .lt. xloss*xmax )
     +		call ffwarn(194,ier,absc(som),xmax)
*
*  #] sum:
*  #[ overall factors:
*
	csom = som
	if ( lsmug ) then
	    if ( nschem .ge. 2 ) then
		cfac = -cxs(1)/(DBLE(xm1*xm4)*cxs(2)*cxs(3)*
     +			c2sisj(ilam,ic))
	    else
		cfac = -cxs(1)/(DBLE(xm1*xm4)*cxs(2)*cxs(3)*
     +			DBLE(c2sisj(ilam,ic)))
	    endif
	    if ( ldot .and. idot.lt.4 ) then
		c = 16*(DBLE(xm1*xm4*dpipj(inx(ilam,ic),ic))*
     +			cxs(2)*cxs(3)/cxs(1))**2
		fdel4s = DBLE(c)
		if ( xloss*DIMAG(c) .gt. precc*DBLE(c) ) then
		    print *,'ffzdbd: error: Del4s is not real ',c
		endif
	    endif
	else
	    cfac = cxs(1)/(DBLE(xm1*xm4*dpipj(inx(ilam,ic),ic))*
     +		cxs(2)*cxs(3))
	    if ( ldot .and. idot.lt.4 ) then
		fdel4s = 1/(16*DBLE(cfac)**2)
		if ( xloss*abs(DIMAG(cfac)) .gt. precc*abs(DBLE(cfac)) )
     +			then
		    print *,'ffzdbd: error: fac is not real: ',cfac
		endif
		if ( lwrite ) print *,'del4s = ',fdel4s
	    endif
	endif
*
*  #] overall factors:
*  #[ print debug info:
	if ( lwrite ) then
	    print *,'cs = '
	    do 910 i=1,is
		print *,i,cs(i)
  910	    continue
	    print *,'som = ',som,ipi12
	    print *,'cd0 = ',csom*cfac
	endif
*  #] print debug info:
*###] ffzdbd:
	end
*###[ ffzkfn:
	subroutine ffzkfn(cx,ieps,xpi,xm,xmp,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the K-function in this paper:				*
*									*
*			      1-sqrt(1-4*m*mp/(z-(m-mp)^2))		*
*		K(p^2,m,mp) = -----------------------------		*
*			      1+sqrt(1-4*m*mp/(z-(m-mp)^2))		*
*									*
*	and fill x(1) = -K, x(2) = 1+K, x(3) = 1-K			*
*	the roots are allowed to be imaginary				*
*	ieps gives the sign of the imaginary part: -2 -> +ieps and v.v. *
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ieps,ier
	DOUBLE PRECISION xpi,xm,xmp
	DOUBLE COMPLEX cx(3)
*
*	local variables
*
	DOUBLE PRECISION xx1,xx2
	DOUBLE COMPLEX wortel,cx3
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ work:
*
	xx1 = xpi - (xm-xmp)**2
	if ( lwarn .and. abs(xx1) .lt. xloss*max(abs(xpi),xm**2)
     +		) then
	    call ffwarn(178,ier,xx1,max(xpi,xm**2))
	    if ( lwrite ) print *,'need extra input'
	endif
	xx2 = 1 - 4*xm*xmp/xx1
	if ( lwarn .and. abs(xx2) .lt. xloss )
     +	    call ffwarn(179,ier,xx2,x1)
	if ( xx2 .ge. 0 ) then
	    wortel = sqrt(xx2)
	else
	    wortel = DCMPLX(DBLE(0),DBLE(sqrt(-xx2)))
	endif
	cx3 = 1/(1+wortel)
	cx(1) = DBLE(-4*xm*xmp/xx1)*cx3**2
	cx(2) = 2*cx3
	cx(3) = 2*wortel*cx3
*
	ieps = -2
*
*  #] work:
*  #[ print output:
	if ( lwrite ) then
	    print *,'ffzkfn: input: xpi,xm,xmp = ',xpi,xm,xmp
	    print *,'        output: cx,ier = ',cx,ier
	endif
*  #] print output:
*###] ffzkfn:
	end
*###[ ffxdi:
	subroutine ffxdi(cd4pppp,cd4ppdel,cd4deldel, cd3ppp,cd3pdel,
     +		cd2pp,cd2del, cd1p, dl2pij, cd0,cc0i,cb0ij,ca0i,
     +		del4s,del3p,del2pi, xpi,piDpj, d0,xmu, degree, ier)
***#[*comment:***********************************************************
*									*
*	Compute the tensor functions D1-D(degree) in the determinant	*
*	scheme, i.e. with basis p1-p3 and (instead of d_(mu,nu))	*
*	\delta_{p1 p2 p3 mu}^{p1 p2 p3 nu}.				*
*									*
*	Input:	cd0	   (complex)	D0				*
*		cc0i(4)	   (complex)	C0 with Ni=(Q+..)^2-mi^2 missing*
*		cb0ij(4,4) (complex)	B0 _with_ Ni,Nj	(only for	*
*					degree>1)			*
*		ca0i(4)	   (complex)	A0 with Ni (only for degree>2)	*
*		del4s	   (real)	delta(s1,s2,s3,s4)(s1,s2,s3,s4)	*
*					(only needed when degree>1)	*
*		del3p	   (real)	delta(p1,p2,p3,p1,p2,p3)	*
*		del2pi(4)  (real)	delta(pipj)(pi,pj) belonging to	*
*					cc0i(i)				*
*		xpi(13)	   (real)	1-4: mi^2, 5-10: p(i-4)^2	*
*		piDpj(10,10) (re)	pi.pj				*
*		d0	   (real)	\ renormalization constants	*
*		xmu	   (real)       / used in B0, A0		*
*		degree	   (integer)	1-4				*
*		ier	   (integer)	number of unreliable digits in	*
*					input				*
*									*
*	Output:	ier			number of digits lost in the	*
*					least stable result		*
*		dl2pij(6,6)(real)	determinants delta(pi,pj,pk,pl)	*
*		cd1p(3)	   (complex)	coeffs of p1,p2,p3		*
*	   only when degree>1:						*
*		cd2pp(3,3) (complex)	coeffs of p1p1,(p1p2+p2p1),...	*
*		cd2del	   (complex)	coeff of delta(p1,p2,p3,mu,..)	*
*	   only when degree>2:						*
*		cd3ppp(3,3,3)(compl)	coeffs of p1p1p1,p1(p1p2+p2p1),	*
*					(p1p2p3+p1p3p2+p2p1p3+p2p3p1+..)*
*		cd3pdel(3) (complex)	coeffs of pidel (symmetrized)	*
*	   only when degree>3:						*
*		cd4pppp(3,3,3,3)(co)	you guessed it!			*
*		cd4ppdel(3,3)(compl)					*
*		cd4deldel  (complex)					*
*									*
*	Note: at this moment (28-feb-1993) only D1 and D2 are coded.	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer degree,ier
	DOUBLE PRECISION dl2pij(6,6),del4s,del3p,del2pi(4),xpi(13),
     +		piDpj(10,10),d0,xmu
	DOUBLE COMPLEX cd4pppp(3,3,3,3),cd4ppdel(3,3),cd4deldel,
     +		cd3ppp(3,3,3),cd3pdel(3),cd2pp(3,3),cd2del,
     +		cd1p(3),cd0,cc0i(4),cb0ij(4,4),ca0i(4)
*
*	local variables
*
	integer i,j,k,ier0,ier1,ier2,inx43(6,4),sgn43(6,4),i2p(5:8,5:8),
     +		isgnsa
	logical lsave1,lsave2
	DOUBLE PRECISION a,xpi3(6),xlosn,dl3qi(7),xmax
	DOUBLE COMPLEX cc,cs(25),cnul
	save inx43,sgn43,i2p
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data inx43 /2,3,4,6,7,10,
     +		   1,3,4,9,7,8,
     +		   1,2,4,5,10,8,
     +		   1,2,3,5,6,9/
     	data sgn43 /+1,+1,+1,+1,+1,-1,
     + 		    +1,+1,+1,-1,+1,+1,
     + 		    +1,+1,+1,+1,+1,+1,
     + 		    +1,+1,+1,+1,+1,+1/
	data i2p /0,0,0,0,
     +		  1,0,0,0,
     +		  2,4,0,0,
     +		  3,5,6,0/
*
*  #] declarations:
*  #[ check input:
	if ( lwrite ) then
	    print *,'ffxdi: input:'
	    print *,'  degree ',degree
	    print *,'  xpi  = ',xpi
	    print *,'  ier  = ',ier
	endif
	if ( degree .gt. 2 ) then
	    print *,'ffxdi: degree > 2 not yet supported: ',degree
	    stop
	endif
	if ( del2pi(1).eq.0 .or. del2pi(2).eq.0 .or. del2pi(3).eq.0
     +		.or. del2pi(4).eq.0 ) then
	    call fferr(87,ier)
	    return
	endif
	if ( ltest ) then
*
*	    the D0
*
	    ier0 = ier
	    lsave1 = ldot
	    lsave2 = lwrite
	    ldot = .TRUE.
	    lwrite = .FALSE.
	    isgnsa = isgnal
	    call ffxd0(cc,xpi,ier0)
	    isgnal = isgnsa
	    ldot = lsave1
	    lwrite = lsave2
	    xlosn = xloss*DBLE(10)**(-mod(ier0,50))
	    if ( xlosn*abs(cc-cd0) .gt. precc*abs(cd0) ) print *,
     +		'ffxdi: error: input D0 disagrees with recomputed: ',
     +		cd0,cc,cd0-cc,ier,ier0
	    if ( xlosn*abs(del3p-fdel3) .gt. precx*abs(del3p) ) print *,
     +		'ffxdi: error: input del3p disagrees with recomputed: ',
     +		del3p,fdel3,del3p-fdel3,ier,ier0
	    if ( xlosn*abs(del4s-fdel4s) .gt. precx*abs(del3p) ) print*,
     +		'ffxdi: error: input del4s disagrees with recomputed: ',
     +		del4s,fdel4s,del4s-fdel4s,ier,ier0
	    do 20 i=1,10
		do 10 j=1,10
		    if ( xlosn*abs(piDpj(j,i)-fpij4(j,i)) .gt. precx*
     +			abs(piDpj(j,i)) ) print *,'ffxdi: error: input '
     +			,'piDpj(',j,i,') disagrees with recomputed: ',
     +			piDpj(j,i),fpij4(j,i),piDpj(j,i)-fpij4(j,i)
   10		continue
   20	    continue
*
*	    the C0s
*
	    do 40 i=1,4
		do 30 j=1,6
		    xpi3(j) = xpi(inx43(j,i))
   30		continue
		if ( idot.gt.0 ) then
		    do 36 j=1,6
*			distribute dotproducts
			do 35 k=1,6
			    fpij3(k,j) = fpij4(inx43(k,i),inx43(j,i))*
     +				sgn43(k,i)*sgn43(j,i)
   35			continue
   36		    continue
		endif
		ier0 = ier
		lsave1 = ldot
		lsave2 = lwrite
		ldot = .TRUE.
		lwrite = .FALSE.
		call ffxc0(cc,xpi3,ier0)
		isgnal = isgnsa
		ldot = lsave1
		lwrite = lsave2
		xlosn = xloss*DBLE(10)**(-mod(ier0,50))
		if ( xlosn*abs(cc-cc0i(i)) .gt. precc*abs(cc0i(i)) )
     +		    print *,'ffxdi: error: input C0(',i,') disagrees ',
     +		    'with recomputed: ',cc0i(i),cc,cc0i(i)-cc,ier,ier0
		if ( xlosn*abs(del2pi(i)-fdel2) .gt. precx*abs(del2pi(i)
     +		    ) ) print *,'ffxdi: error: input del2pi(',i,
     +		    ') disagrees with recomputed: ',del2pi(i),fdel2,
     +		    del2pi(i)-fdel2
   40	    continue
*
*	    the B0s
*
	    if ( degree .lt. 2 ) goto 80
	    do 60 i=1,3
		do 50 j=i+1,4
		    ier0 = ier
		    lsave2 = lwrite
		    lwrite = .FALSE.
		    call ffxb0(cc,d0,xmu,xpi(inx(i,j)),xpi(i),xpi(j),
     +			ier0)
		    lwrite = lsave2
		    xlosn = xloss*DBLE(10)**(-mod(ier0,50))
		    if ( cb0ij(i,j) .ne. cb0ij(j,i) ) print *,
     +			'ffxdi: error: cb0ij(',i,j,') != cb0ij(',j,i,
     +			') : ',cb0ij(i,j),cb0ij(j,i)
		    if ( xlosn*abs(cc-cb0ij(i,j)) .gt. precc*abs(cb0ij(i
     +			,j)) ) print *,'ffxdi: error: input B0(',i,j,
     +			') disagrees with recomputed: ',cb0ij(i,j),cc,
     +			cb0ij(i,j)-cc,ier,ier0
   50		continue
   60	    continue
*
*	    the A0s
*
	    if ( degree .lt. 3 ) goto 80
	    do 70 i=1,4
		ier0 = ier
		lsave2 = lwrite
		lwrite = .FALSE.
		call ffxa0(cc,d0,xmu,xpi(i),ier0)
		lwrite = lsave2
		xlosn = xloss*DBLE(10)**(-mod(ier0,50))
		if ( xlosn*abs(cc-ca0i(i)) .gt. precc*abs(ca0i(i)) )
     +		    print *,'ffxdi: error: input A0(',i,') disagrees ',
     +		    'with recomputed: ',ca0i(i),cc,ca0i(i)-cc,ier,ier0
   70	    continue
   80	    continue
	endif
	if ( degree .le. 0 ) then
	    if ( ltest ) print *,'ffxdi: rather useless call to ffxdi'
	    return
	endif
*  #] check input:
*  #[ preliminaries:
*	not needed?  security first!
	if ( lwrite ) then
	    print *,'i2p(5,6) = ',i2p(5,6)
	    print *,'i2p(6,7) = ',i2p(6,7)
	    print *,'i2p(7,8) = ',i2p(7,8)
	    print *,'i2p(5,8) = ',i2p(5,8)
	endif
	dl2pij(i2p(5,6),i2p(5,6)) = del2pi(4)
	dl2pij(i2p(6,7),i2p(6,7)) = del2pi(1)
	dl2pij(i2p(7,8),i2p(7,8)) = del2pi(2)
	dl2pij(i2p(5,8),i2p(5,8)) = del2pi(3)
*  #] preliminaries:
*  #[ get determinants:
*
	ier1 = ier
	call ffdl2i(dl2pij(i2p(6,7),i2p(7,8)),piDpj,10,
     +		6,7,10,+1,7,8,9,+1,ier1)
	dl2pij(i2p(7,8),i2p(6,7)) = dl2pij(i2p(6,7),i2p(7,8))
*
	ier0 = ier
	call ffdl2i(dl2pij(i2p(5,8),i2p(6,7)),piDpj,10,
     +		6,7,10,+1,5,8,10,-1,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(6,7),i2p(5,8)) = dl2pij(i2p(5,8),i2p(6,7))
*
	ier0 = ier
	call ffdl2i(dl2pij(i2p(5,6),i2p(6,7)),piDpj,10,
     +		6,7,10,+1,5,6,9,-1,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(6,7),i2p(5,6)) = dl2pij(i2p(5,6),i2p(6,7))
*
	ier0 = ier
	call ffdl2t(dl2pij(i2p(5,7),i2p(6,7)),piDpj,5,7,
     +		6,7,10,-1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(6,7),i2p(5,7)) = dl2pij(i2p(5,7),i2p(6,7))
*
	ier0 = ier
	call ffdl2t(dl2pij(i2p(5,7),i2p(7,8)),piDpj,5,7,
     +		7,8,9,-1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(7,8),i2p(5,7)) = dl2pij(i2p(5,7),i2p(7,8))
*
	ier0 = ier
	call ffdl2t(dl2pij(i2p(5,7),i2p(5,8)),piDpj,5,7,
     +		5,8,10,+1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(5,8),i2p(5,7)) = dl2pij(i2p(5,7),i2p(5,8))
*
	ier0 = ier
	call ffdl2t(dl2pij(i2p(5,6),i2p(5,7)),piDpj,5,7,
     +		5,6,9,+1,-1, 10,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(5,7),i2p(5,6)) = dl2pij(i2p(5,6),i2p(5,7))
*
	ier0 = ier
	call ffdl2i(dl2pij(i2p(5,6),i2p(7,8)),piDpj,10,
     +		5,6,9,-1,7,8,9,+1,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(7,8),i2p(5,6)) = dl2pij(i2p(5,6),i2p(7,8))
*
	ier0 = ier
	call ffdl2i(dl2pij(i2p(5,6),i2p(5,8)),piDpj,10,
     +		5,6,9,-1,5,8,10,-1,ier0)
	ier1 = max(ier1,ier0)
	dl2pij(i2p(5,8),i2p(5,6)) = dl2pij(i2p(5,6),i2p(5,8))
*
	ier0 = ier
	call ffdl3q(dl3qi(i2p(6,7)),piDpj, 1,6,7, 0,10,0, 0,-1,0,
     +		0,+1,0, ier0)
	ier1 = max(ier1,ier0)
*
	ier0 = ier
	call ffdl3q(dl3qi(i2p(5,7)),piDpj, 1,5,7, 2,0,0, -1,0,0,
     +		+1,0,0, ier0)
	ier1 = max(ier1,ier0)
*
	ier0 = ier
	call ffdl3q(dl3qi(i2p(5,6)),piDpj, 1,5,6, 2,9,0, -1,-1,0,
     +		+1,-1,0, ier0)
	ier1 = max(ier1,ier0)
*
	if ( degree.gt.1 ) then
*
	ier0 = ier
	call ffdl3q(dl3qi(i2p(5,8)),piDpj, 1,5,8, 2,10,4, -1,-1,+1,
     +		+1,-1,+1, ier0)
	ier1 = max(ier1,ier0)
*
	ier0 = ier
	call ffdl3q(dl3qi(i2p(7,8)),piDpj, 1,7,8, 0,9,4, 0,-1,+1,
     +		0,+1,+1, ier0)
	ier1 = max(ier1,ier0)
*
	ier0 = ier
	call ffdl3q(dl3qi(7),piDpj, 2,3,4, 6,7,10, +1,+1,+1,
     +		-1,-1,+1, ier0)
	ier1 = max(ier1,ier0)
*
	endif
	ier = ier1
	if ( lwrite ) print *,'ier after determinants = ',ier
*
*  #] get determinants:
*  #[ D1:
*-	#[ D11:
*
*	see the Form job D1.frm
*
	if ( lwrite ) print *,'ffxdi: D11'
	cs(1) = - cc0i(1)*DBLE(del2pi(1))
	cs(2) = + cc0i(2)*DBLE(dl2pij(i2p(6,7),i2p(7,8)))
	cs(3) = + cc0i(3)*DBLE(dl2pij(i2p(5,8),i2p(6,7)))
	cs(4) = + cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(6,7)))
	cs(5) = + 2*cd0*DBLE(dl3qi(i2p(6,7)))
*
	cd1p(1) = 0
	xmax = 0
	do 110 i=1,5
	    cd1p(1) = cd1p(1) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  110	continue
	if ( lwarn .and. abs(cd1p(1)) .lt. xloss*xmax ) then
	    a = abs(cd1p(1))
	    call ffwarn(164,ier1,a,xmax)
	    if ( lwrite ) print *,'cs,cd1p(1) = ',(cs(i),i=1,5),cd1p(1)
	endif
	cd1p(1) = cd1p(1)*(1/DBLE(2*del3p))
*
*-	#] D11:
*-	#[ D12:
*
	if ( lwrite ) print *,'ffxdi: D12'
	cs(1) = + cc0i(1)*DBLE(dl2pij(i2p(5,7),i2p(6,7)))
	cs(2) = - cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8)))
	cs(3) = - cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8)))
	cs(4) = - cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(5,7)))
	cs(5) = - 2*cd0*DBLE(dl3qi(i2p(5,7)))
*
	cd1p(2) = 0
	xmax = 0
	do 120 i=1,5
	    cd1p(2) = cd1p(2) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  120	continue
	if ( lwarn .and. abs(cd1p(2)) .lt. xloss*xmax ) then
	    a = abs(cd1p(2))
	    ier0 = ier
	    call ffwarn(164,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd1p(2) = ',(cs(i),i=1,5),cd1p(2)
	endif
	cd1p(2) = cd1p(2)*(1/DBLE(2*del3p))
*
*-	#] D12:
*-	#[ D13:
*
	if ( lwrite ) print *,'ffxdi: D13'
	cs(1) = - cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7)))
	cs(2) = + cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8)))
	cs(3) = + cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8)))
	cs(4) = + cc0i(4)*DBLE(del2pi(4))
	cs(5) = + 2*cd0*DBLE(dl3qi(i2p(5,6)))
*
	cd1p(3) = 0
	xmax = 0
	do 130 i=1,5
	    cd1p(3) = cd1p(3) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  130	continue
	if ( lwarn .and. abs(cd1p(3)) .lt. xloss*xmax ) then
	    a = abs(cd1p(3))
	    ier0 = ier
	    call ffwarn(164,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd1p(3) = ',(cs(i),i=1,5),cd1p(3)
	endif
	cd1p(3) = cd1p(3)*(1/DBLE(2*del3p))
*
*-	#] D13:
*-	#[ print output:
	if ( lwrite ) then
	    print *,'ffxdi: D1:'
	    print *,'cd1p = '
	    print '(6e20.13)',cd1p
	    print *,'ier  = ',ier1
	endif
*-	#] print output:
	if ( degree .eq. 1 ) then
	    ier = ier1
	    return
	endif
*  #] D1:
*  #[ D2:
*
*	see the form job d2.frm
*
*-	#[ D2del:
*
	if ( lwrite ) print *,'ffxdi: D2del'
	cs(1) = -2*DBLE(del4s)*cd0
	cs(2) = +DBLE(dl3qi(i2p(5,6)))*cc0i(4)
	cs(3) = +DBLE(dl3qi(i2p(5,8)))*cc0i(3)
	cs(4) = +DBLE(dl3qi(i2p(7,8)))*cc0i(2)
	cs(5) = -DBLE(dl3qi(7))*cc0i(1)
*
	cd2del = 0
	xmax = 0
	do 210 i=1,5
	    cd2del = cd2del + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  210	continue
	if ( lwarn .and. abs(cd2del) .lt. xloss*xmax ) then
	    a = abs(cd2del)
	    ier0 = ier
	    call ffwarn(189,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2del = ',(cs(i),i=1,5),cd2del
	endif
	cd2del = cd2del*DBLE(1/(-2*Del3p**2))
*
*-	#] D2del:
*-	#[ D2pp(1,1):
*
	if ( lwrite ) print *,'D2pp(1,1)'
	cs(1) = -cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(5,6)*
     +		del3p/del2pi(4))
	cs(2) = -cb0ij(1,2)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*piDpj(5,10)*
     +		del3p/del2pi(3))
	cs(3) = -cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,9)*
     +		del3p/del2pi(4))
	cs(4) = +cb0ij(1,3)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*piDpj(7,9)*
     +		del3p/del2pi(2))
	cs(5) = -cb0ij(1,4)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*piDpj(8,10)*
     +		del3p/del2pi(3))
	cs(6) = -cb0ij(1,4)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*piDpj(7,8)*
     +		del3p/del2pi(2))
	cs(7) = -cb0ij(2,3)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,6)*
     +		del3p/del2pi(4))
	cs(8) = -cb0ij(2,4)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*piDpj(10,10)*
     +		del3p/del2pi(3))
	cs(9) = -cb0ij(3,4)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*piDpj(7,7)*
     +		del3p/del2pi(2))
	cs(10) = -4*cc0i(1)*DBLE(dl3qi(i2p(6,7))*del2pi(1))
	cs(11) = +2*cc0i(1)*DBLE(dl3qi(7)*del2pi(1))
	cs(12) = -2*cc0i(2)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*
     +		dl2pij(i2p(6,7),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(13) = +4*cc0i(2)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*
     +		dl3qi(i2p(6,7)))
	cs(14) = -2*cc0i(3)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*
     +		dl2pij(i2p(5,8),i2p(6,7))*dl3qi(i2p(5,8))/del2pi(3))
	cs(15) = +4*cc0i(3)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*
     +		dl3qi(i2p(6,7)))
	cs(16) = -2*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*
     +		dl2pij(i2p(5,6),i2p(6,7))*dl3qi(i2p(5,6))/del2pi(4))
	cs(17) = +4*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*
     +		dl3qi(i2p(6,7)))
	cs(18) = +4*cd0*DBLE(dl3qi(i2p(6,7))*dl3qi(i2p(6,7)))
*
	cd2pp(1,1) = 0
	xmax = 0
	do 220 i=1,18
	    cd2pp(1,1) = cd2pp(1,1) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  220	continue
	if ( lwarn .and. abs(cd2pp(1,1)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(1,1))
	    ier0 = ier
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(1,1) = ',(cs(i),i=1,18),
     +		cd2pp(1,1)
	endif
	cd2pp(1,1) = cd2pp(1,1)*DBLE(1/(4*Del3p**2))
*
*-	#] D2pp(1,1):
*-	#[ D2pp(1,2):
*
	if ( lwrite ) print *,'D2pp(1,2)'
	cs(1)=+cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(5,
     +	6)*del3p/del2pi(4))
	cs(2)=+cb0ij(1,2)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(3)=+cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(6,
     +	9)*del3p/del2pi(4))
	cs(4)=-cb0ij(1,3)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	9)*del3p/del2pi(2))
	cs(5)=+cb0ij(1,4)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*piDpj(8,
     +	10)*del3p/del2pi(3))
	cs(6)=+cb0ij(1,4)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	8)*del3p/del2pi(2))
	cs(7)=+cb0ij(2,3)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(6,
     +	6)*del3p/del2pi(4))
	cs(8)=+cb0ij(2,4)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(9)=-cb0ij(2,4)*DBLE(piDpj(7,10)*del3p)
	cs(10)=+cb0ij(3,4)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	7)*del3p/del2pi(2))
	cs(11)=-2*cc0i(1)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*del3p)
	cs(12)=+2*cc0i(1)*DBLE(dl3qi(i2p(5,7))*del2pi(1))
	cs(13)=+2*cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*dl2pij(i2p(6,
     +	7),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(14)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*dl3qi(i2p(6,
     +	7)))
	cs(15)=-2*cc0i(2)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*dl3qi(i2p(5,
     +	7)))
	cs(16)=+2*cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*dl2pij(i2p(5,
     +	8),i2p(6,7))*dl3qi(i2p(5,8))/del2pi(3))
	cs(17)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*dl3qi(i2p(6,
     +	7)))
	cs(18)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*dl3qi(i2p(5,
     +	7)))
	cs(19)=+2*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*dl2pij(i2p(5,
     +	6),i2p(6,7))*dl3qi(i2p(5,6))/del2pi(4))
	cs(20)=-2*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*dl3qi(i2p(6,
     +	7)))
	cs(21)=-2*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*dl3qi(i2p(5,
     +	7)))
	cs(22)=-4*cd0*DBLE(dl3qi(i2p(5,7))*dl3qi(i2p(6,7)))
*
	cd2pp(1,2) = 0
	xmax = 0
	do 230 i=1,22
	    cd2pp(1,2) = cd2pp(1,2) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  230	continue
	if ( lwarn .and. abs(cd2pp(1,2)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(1,2))
	    ier0 = ier
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(1,2) = ',(cs(i),i=1,22),
     +		cd2pp(1,2)
	endif
	cd2pp(1,2) = cd2pp(1,2)*DBLE(1/(4*Del3p**2))
	cd2pp(2,1) = cd2pp(1,2)
*
*-	#] D2pp(1,2):
*-	#[ D2pp(1,3):
*
	if ( lwrite ) print *,'D2pp(1,3)'
	cs(1)=-cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(2)=-cb0ij(1,2)*DBLE(piDpj(5,6)*del3p)
	cs(3)=+cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	9)*del3p/del2pi(2))
	cs(4)=-cb0ij(1,3)*DBLE(piDpj(6,9)*del3p)
	cs(5)=-cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(8,
     +	10)*del3p/del2pi(3))
	cs(6)=-cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	8)*del3p/del2pi(2))
	cs(7)=-cb0ij(2,3)*DBLE(piDpj(6,6)*del3p)
	cs(8)=-cb0ij(2,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(10,
     +	10)*del3p/del2pi(3))
	cs(9)=-cb0ij(3,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	7)*del3p/del2pi(2))
	cs(10)=+2*cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*del3p)
	cs(11)=-2*cc0i(1)*DBLE(dl3qi(i2p(5,6))*del2pi(1))
	cs(12)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl2pij(i2p(6,
     +	7),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(13)=+2*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl3qi(i2p(6,
     +	7)))
	cs(14)=+2*cc0i(2)*DBLE(dl2pij(i2p(6,7),i2p(7,8))*dl3qi(i2p(5,
     +	6)))
	cs(15)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl2pij(i2p(5,
     +	8),i2p(6,7))*dl3qi(i2p(5,8))/del2pi(3))
	cs(16)=+2*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl3qi(i2p(6,
     +	7)))
	cs(17)=+2*cc0i(3)*DBLE(dl2pij(i2p(5,8),i2p(6,7))*dl3qi(i2p(5,
     +	6)))
	cs(18)=+2*cc0i(4)*DBLE(dl3qi(i2p(6,7))*del2pi(4))
	cs(19)=+4*cd0*DBLE(dl3qi(i2p(5,6))*dl3qi(i2p(6,7)))
*
	cd2pp(1,3) = 0
	xmax = 0
	do 240 i=1,19
	    cd2pp(1,3) = cd2pp(1,3) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  240	continue
	if ( lwarn .and. abs(cd2pp(1,3)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(1,3))
	    ier0 = ier
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(1,3) = ',(cs(i),i=1,19),
     +		cd2pp(1,3)
	endif
	cd2pp(1,3) = cd2pp(1,3)*DBLE(1/(4*Del3p**2))
	cd2pp(3,1) = cd2pp(1,3)
*
*-	#] D2pp(1,3):
*-	#[ D2pp(2,2):
*
	if ( lwrite ) print *,'D2pp(2,2)'
	cs(1)=-cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(5,
     +	5)*del3p/del2pi(4))
	cs(2)=-cb0ij(1,2)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*piDpj(5,
     +	5)*del3p/del2pi(3))
	cs(3)=-cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(5,
     +	9)*del3p/del2pi(4))
	cs(4)=-cb0ij(1,3)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	9)*del3p/del2pi(2))
	cs(5)=-cb0ij(1,4)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*piDpj(5,
     +	8)*del3p/del2pi(3))
	cs(6)=+cb0ij(1,4)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	8)*del3p/del2pi(2))
	cs(7)=-cb0ij(2,3)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*piDpj(5,
     +	6)*del3p/del2pi(4))
	cs(8)=-cb0ij(2,3)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*piDpj(6,
     +	7)*del3p/del2pi(1))
	cs(9)=-cb0ij(2,4)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(10)=+cb0ij(2,4)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*piDpj(7,
     +	10)*del3p/del2pi(1))
	cs(11)=-cb0ij(3,4)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*piDpj(7,
     +	7)*del3p/del2pi(1))
	cs(12)=+cb0ij(3,4)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*piDpj(7,
     +	7)*del3p/del2pi(2))
	cs(13)=+2*cc0i(1)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*dl2pij(i2p(5,
     +	7),i2p(6,7))*dl3qi(7)/del2pi(1))
	cs(14)=-4*cc0i(1)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*dl3qi(i2p(5,
     +	7)))
	cs(15)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*dl2pij(i2p(5,
     +	7),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(16)=+4*cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*dl3qi(i2p(5,
     +	7)))
	cs(17)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*dl2pij(i2p(5,
     +	7),i2p(5,8))*dl3qi(i2p(5,8))/del2pi(3))
	cs(18)=+4*cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*dl3qi(i2p(5,
     +	7)))
	cs(19)=-2*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*dl2pij(i2p(5,
     +	6),i2p(5,7))*dl3qi(i2p(5,6))/del2pi(4))
	cs(20)=+4*cc0i(4)*DBLE(dl2pij(i2p(5,6),i2p(5,7))*dl3qi(i2p(5,
     +	7)))
	cs(21)=+4*cd0*DBLE(dl3qi(i2p(5,7))*dl3qi(i2p(5,7)))
*
	cd2pp(2,2) = 0
	xmax = 0
	do 250 i=1,21
	    cd2pp(2,2) = cd2pp(2,2) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  250	continue
	if ( lwarn .and. abs(cd2pp(2,2)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(2,2))
	    ier0 = ier
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(2,2) = ',(cs(i),i=1,21),
     +		cd2pp(2,2)
	endif
	cd2pp(2,2) = cd2pp(2,2)*DBLE(1/(4*Del3p**2))
*
*-	#] D2pp(2,2):
*-	#[ D2pp(2,3):
*
	if ( lwrite ) print *,'D2pp(2,3)'
*
	cs(1)=+cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	5)*del3p/del2pi(3))
	cs(2)=+cb0ij(1,2)*DBLE(piDpj(5,5)*del3p)
	cs(3)=+cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	9)*del3p/del2pi(2))
	cs(4)=+cb0ij(1,3)*DBLE(piDpj(5,9)*del3p)
	cs(5)=+cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	8)*del3p/del2pi(3))
	cs(6)=-cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	8)*del3p/del2pi(2))
	cs(7)=+cb0ij(2,3)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,
     +	7)*del3p/del2pi(1))
	cs(8)=+cb0ij(2,3)*DBLE(piDpj(5,6)*del3p)
	cs(9)=+cb0ij(2,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(10)=-cb0ij(2,4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(7,
     +	10)*del3p/del2pi(1))
	cs(11)=+cb0ij(3,4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(7,
     +	7)*del3p/del2pi(1))
	cs(12)=-cb0ij(3,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	7)*del3p/del2pi(2))
	cs(13)=-2*cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*dl2pij(i2p(5,
     +	7),i2p(6,7))*dl3qi(7)/del2pi(1))
	cs(14)=+2*cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*dl3qi(i2p(5,
     +	7)))
	cs(15)=+2*cc0i(1)*DBLE(dl2pij(i2p(5,7),i2p(6,7))*dl3qi(i2p(5,
     +	6)))
	cs(16)=+2*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl2pij(i2p(5,
     +	7),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(17)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl3qi(i2p(5,
     +	7)))
	cs(18)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,7),i2p(7,8))*dl3qi(i2p(5,
     +	6)))
	cs(19)=+2*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl2pij(i2p(5,
     +	7),i2p(5,8))*dl3qi(i2p(5,8))/del2pi(3))
	cs(20)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl3qi(i2p(5,
     +	7)))
	cs(21)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,7),i2p(5,8))*dl3qi(i2p(5,
     +	6)))
	cs(22)=-2*cc0i(4)*DBLE(dl3qi(i2p(5,7))*del2pi(4))
	cs(23)=-4*cd0*DBLE(dl3qi(i2p(5,6))*dl3qi(i2p(5,7)))
*
	cd2pp(2,3) = 0
	xmax = 0
	do 260 i=1,23
	    cd2pp(2,3) = cd2pp(2,3) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  260	continue
	if ( lwarn .and. abs(cd2pp(2,3)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(2,3))
	    ier = ier0
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(2,3) = ',(cs(i),i=1,23),
     +		cd2pp(2,3)
	endif
	cd2pp(2,3) = cd2pp(2,3)*DBLE(1/(4*Del3p**2))
	cd2pp(3,2) = cd2pp(2,3)
*
*-	#] D2pp(2,3):
*-	#[ D2pp(3,3):
*
	if ( lwrite ) print *,'D2pp(3,3)'
	cs(1)=+cb0ij(1,2)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	5)*del3p/del2pi(3))
	cs(2)=+cb0ij(1,3)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(9,
     +	9)*del3p/del2pi(2))
	cs(3)=+cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	8)*del3p/del2pi(3))
	cs(4)=-cb0ij(1,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(8,
     +	9)*del3p/del2pi(2))
	cs(5)=-cb0ij(2,3)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,
     +	6)*del3p/del2pi(1))
	cs(6)=+cb0ij(2,4)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*piDpj(5,
     +	10)*del3p/del2pi(3))
	cs(7)=+cb0ij(2,4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,
     +	10)*del3p/del2pi(1))
	cs(8)=-cb0ij(3,4)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*piDpj(6,
     +	7)*del3p/del2pi(1))
	cs(9)=-cb0ij(3,4)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*piDpj(7,
     +	9)*del3p/del2pi(2))
	cs(10)=+2*cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*dl2pij(i2p(5,
     +	6),i2p(6,7))*dl3qi(7)/del2pi(1))
	cs(11)=-4*cc0i(1)*DBLE(dl2pij(i2p(5,6),i2p(6,7))*dl3qi(i2p(5,
     +	6)))
	cs(12)=-2*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl2pij(i2p(5,
     +	6),i2p(7,8))*dl3qi(i2p(7,8))/del2pi(2))
	cs(13)=+4*cc0i(2)*DBLE(dl2pij(i2p(5,6),i2p(7,8))*dl3qi(i2p(5,
     +	6)))
	cs(14)=-2*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl2pij(i2p(5,
     +	6),i2p(5,8))*dl3qi(i2p(5,8))/del2pi(3))
	cs(15)=+4*cc0i(3)*DBLE(dl2pij(i2p(5,6),i2p(5,8))*dl3qi(i2p(5,
     +	6)))
	cs(16)=+2*cc0i(4)*DBLE(dl3qi(i2p(5,6))*del2pi(4))
	cs(17)=+4*cd0*DBLE(dl3qi(i2p(5,6))*dl3qi(i2p(5,6)))
*
	cd2pp(3,3) = 0
	xmax = 0
	do 270 i=1,17
	    cd2pp(3,3) = cd2pp(3,3) + cs(i)
	    a = abs(cs(i))
	    xmax = max(xmax,a)
  270	continue
	if ( lwarn .and. abs(cd2pp(3,3)) .lt. xloss*xmax ) then
	    a = abs(cd2pp(3,3))
	    ier0 = ier
	    call ffwarn(190,ier0,a,xmax)
	    ier1 = max(ier1,ier0)
	    if ( lwrite ) print *,'cs,cd2pp(3,3) = ',(cs(i),i=1,17),
     +		cd2pp(3,3)
	endif
	cd2pp(3,3) = cd2pp(3,3)*DBLE(1/(4*Del3p**2))
*
*-	#] D2pp(3,3):
*-	#[ print output:
	if ( lwrite ) then
	    print '(a,2e20.13)','cd2del = ',cd2del
	    print '(a)','cd2pp  = '
	    print '(6e20.13)',cd2pp
	    print *,'ier    = ',ier1
	endif
	if ( ltest ) then
	    xlosn = xloss*DBLE(10)**(-mod(ier1,50))
	    cs(1) =   DBLE(piDpj(5,5))*cd2pp(1,1)
	    cs(2) = 2*DBLE(piDpj(5,6))*cd2pp(1,2)
	    cs(3) = 2*DBLE(piDpj(5,7))*cd2pp(1,3)
	    cs(4) =   DBLE(piDpj(6,6))*cd2pp(2,2)
	    cs(5) = 2*DBLE(piDpj(6,7))*cd2pp(2,3)
	    cs(6) =   DBLE(piDpj(7,7))*cd2pp(3,3)
	    cs(7) =   DBLE(del3p)*cd2del
	    cs(8) = - cc0i(1)
	    cs(9) = - DBLE(piDpj(1,1))*cd0
	    cnul = 0
	    xmax = 0
	    do 910 i=1,9
		cnul = cnul + cs(i)
		a = abs(cs(i))
		xmax = max(xmax,a)
  910	    continue
	    if ( lwrite ) print *,'ffxdi: checking D2.gmumu= ',cnul,xmax
	    if ( xlosn*abs(cnul) .gt. precc*xmax ) print *,'ffxdi: ',
     +		'error: D2(mu,mu) not correct ',cnul,xmax,ier1
	    cs(1) = 4*DBLE(piDpj(5,5)*piDpj(7,5))*cd2pp(1,1)
	    cs(2) = 4*DBLE(piDpj(5,5)*piDpj(7,6))*cd2pp(1,2)
	    cs(3) = 4*DBLE(piDpj(5,6)*piDpj(7,5))*cd2pp(1,2)
	    cs(4) = 4*DBLE(piDpj(5,5)*piDpj(7,7))*cd2pp(1,3)
	    cs(5) = 4*DBLE(piDpj(5,7)*piDpj(7,5))*cd2pp(1,3)
	    cs(6) = 4*DBLE(piDpj(5,6)*piDpj(7,6))*cd2pp(2,2)
	    cs(7) = 4*DBLE(piDpj(5,6)*piDpj(7,7))*cd2pp(2,3)
	    cs(8) = 4*DBLE(piDpj(5,7)*piDpj(7,6))*cd2pp(2,3)
	    cs(9) = 4*DBLE(piDpj(5,7)*piDpj(7,7))*cd2pp(3,3)
	    cs(10)= - cb0ij(1,3)
	    cs(11)= + cb0ij(1,4)
	    cs(12)= + cb0ij(2,3)
	    cs(13)= - cb0ij(2,4)
	    cs(14)= - 2*DBLE(piDpj(1,7))*cc0i(2)
	    cs(15)= + 2*DBLE(piDpj(1,7))*cc0i(1)
	    cs(16)= - 2*DBLE(piDpj(1,5))*cc0i(4)
	    cs(17)= + 2*DBLE(piDpj(1,5))*cc0i(3)
	    cs(18)= - 4*DBLE(piDpj(1,5)*piDpj(1,7))*cd0
	    cnul = 0
	    xmax = 0
	    do 920 i=1,18
		cnul = cnul + cs(i)
		a = abs(cs(i))
		xmax = max(xmax,a)
  920	    continue
	    if ( lwrite ) print *,'ffxdi: checking D2.p1p3 = ',cnul,xmax
	    if ( xlosn*abs(cnul) .gt. precc*xmax ) print *,'ffxdi :',
     +		'error: D2(p1,p3) not correct ',cnul,xmax,ier1
	    cs(1) = 4*DBLE(piDpj(6,5)*piDpj(8,5))*cd2pp(1,1)
	    cs(2) = 4*DBLE(piDpj(6,5)*piDpj(8,6))*cd2pp(1,2)
	    cs(3) = 4*DBLE(piDpj(6,6)*piDpj(8,5))*cd2pp(1,2)
	    cs(4) = 4*DBLE(piDpj(6,5)*piDpj(8,7))*cd2pp(1,3)
	    cs(5) = 4*DBLE(piDpj(6,7)*piDpj(8,5))*cd2pp(1,3)
	    cs(6) = 4*DBLE(piDpj(6,6)*piDpj(8,6))*cd2pp(2,2)
	    cs(7) = 4*DBLE(piDpj(6,6)*piDpj(8,7))*cd2pp(2,3)
	    cs(8) = 4*DBLE(piDpj(6,7)*piDpj(8,6))*cd2pp(2,3)
	    cs(9) = 4*DBLE(piDpj(6,7)*piDpj(8,7))*cd2pp(3,3)
	    cs(10)= - cb0ij(2,4)
	    cs(11)= + cb0ij(1,2)
	    cs(12)= + cb0ij(3,4)
	    cs(13)= - cb0ij(1,3)
	    cs(14)= - 2*DBLE(piDpj(1,8))*cc0i(3)
	    cs(15)= + 2*DBLE(piDpj(1,8))*cc0i(2)
	    cs(16)= - 2*DBLE(piDpj(1,6))*cc0i(1)
	    cs(17)= + 2*DBLE(piDpj(1,6))*cc0i(4)
	    cs(18)= - 4*DBLE(piDpj(1,6)*piDpj(1,8))*cd0
	    cnul = 0
	    xmax = 0
	    do 930 i=1,18
		cnul = cnul + cs(i)
		a = abs(cs(i))
		xmax = max(xmax,a)
  930	    continue
	    if ( lwrite ) print *,'ffxdi: checking D2.p2p4 = ',cnul,xmax
	    if ( xlosn*abs(cnul) .gt. precc*xmax ) print *,'ffxdi :',
     +		'error: D2(p2,p4) not correct ',cnul,xmax,ier1
	endif
*-	#] print output:
	if ( degree .eq. 2 ) then
	    ier = ier1
	    return
	endif
*  #] D2:
	print *,'ffxdi: error: D3 not ready'
	stop
*###] ffxdi:
	end
*###[ ffxli2:
	subroutine ffxli2(xdilog,xlog,x,ier)
***#[*comment:***********************************************************
*									*
*	Computes the dilogarithm (Li2, Sp) for (real) x	to precision	*
*	precx. It is assumed that -1<=x<=1/2.  As it is available anyway*
*	log(1-x) = -Li1(x) is also passed.				*
*									*
*	Input:	x	(real)						*
*									*
*	Output: xdilog	(real)    Li2(x)				*
*		xlog	(real)    log(1-x) = -Li1(x)			*
*		ier	(integer) 0=OK, 1=num prob, 2=error		*
*									*
*	Calls:	log,dfflo1						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ier
	DOUBLE PRECISION xdilog,xlog,x
*
*	local variables
*
	integer ipi12
	DOUBLE PRECISION dfflo1,u,u2,a,ffbnd,
     +		xprec,bdn02,bdn05,bdn10,bdn15,bdn20
	DOUBLE COMPLEX zxdilo,zlog
	save xprec,bdn02,bdn05,bdn10,bdn15,bdn20
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ initialisations:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
	    bdn02 = ffbnd(1,2,bf)
	    bdn05 = ffbnd(1,5,bf)
	    bdn10 = ffbnd(1,10,bf)
	    bdn15 = ffbnd(1,15,bf)
	    bdn20 = ffbnd(1,19,bf)
	endif
*  #] initialisations:
*  #[ if the argument is too large...
	if ( x .lt. -1.5 .or. x .gt. .75 ) then
	    if ( ltest ) call fferr(29,ier)
	    call ffzxdl(zxdilo,ipi12,zlog,x,0,ier)
	    if ( DIMAG(zxdilo) .ne. 0 ) then
	    	call fferr(52,ier)
	    endif
	    xdilog = DBLE(zxdilo) + ipi12*pi12
	    xlog = DBLE(zlog)
	    return
	endif
*  #] if the argument is too large...
*  #[ exceptional cases:
	if ( x .eq. -1 ) then
	    xdilog = -pi12
	    xlog = log(x2)
	    return
	elseif ( x .eq. x05 ) then
	    xdilog = - xlg2**2/2 + pi12
	    xlog = - xlg2
	    return
	elseif ( abs(x) .lt. precx ) then
	    xdilog = x
	    xlog = -x
	    return
	endif
*  #] exceptional cases:
*  #[ calculate dilog:
	if ( abs(x) .lt. xloss ) then
	    xlog = dfflo1(x,ier)
	else
	    xlog = log(1-x)
	endif
	u = -xlog
	u2 = u*u
	a = abs(u2)
	if ( lwarn .and. a .gt. bdn20 ) then
	    call ffwarn(60,ier,precx,bf(20)*a**20)
	endif
	if ( a .gt. bdn15 ) then
	    xdilog = u2*(bf(16) + u2*(bf(17) + u2*(bf(18) +
     +		    u2*(bf(19) + u2*(bf(20))))))
	else
	    xdilog = 0
	endif
	if ( a .gt. bdn10 ) then
	    xdilog = u2*(bf(11) + u2*(bf(12) + u2*(bf(13) +
     +		    u2*(bf(14) + u2*(bf(15) + xdilog)))))
	endif
	if ( a .gt. bdn05 ) then
	    xdilog = u2*(bf(6) + u2*(bf(7) + u2*(bf(8) +
     +		    u2*(bf(9) + u2*(bf(10) + xdilog)))))
	endif
	if ( a .gt. bdn02 ) then
	    xdilog = u2*(bf(3) + u2*(bf(4) + u2*(bf(5) + xdilog)))
	endif
*	watch the powers of u.
	xdilog = u + u2*(bf(1) + u*(bf(2) + xdilog))
*  #] calculate dilog:
*###] ffxli2:
	end
*###[ ffzxdl:
	subroutine ffzxdl(zxdilo,ipi12,zlog,x,ieps,ier)
***#[*comment:***************************************************
*	Computes the dilogarithm (Li2, Sp) for any (real) x	*
*	to precision precx. If an error message is given add	*
*	more bf's. For x > 1 the imaginary part is		*
*	 -/+i*pi*log(x), corresponding to x+ieps.		*
*	The number of factors pi^2/12 is passed separately in	*
*	ipi12 for accuracy.  We also calculate log(1-x)		*
*	which is likely to be needed.				*
*								*
*	Input:	x	(real)					*
*		ieps	(integer,+/-1)				*
*								*
*	Output: zxdilo	(complex) the dilog mod factors pi2/12	*
*		ipi12	(integer) these factors			*
*		zlog	(complex) log(1-x)			*
*								*
*	Calls:	log,dfflo1					*
*								*
***#]*comment:***************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer ipi12,ieps,ier
	DOUBLE PRECISION x
	DOUBLE COMPLEX zxdilo,zlog
*
*	local variables
*
	integer jsgn
	DOUBLE PRECISION fact,u,u2,dfflo1,ffbnd,a,xdilo,
     +		xprec,bdn02,bdn05,bdn10,bdn15,bdn20
	DOUBLE COMPLEX cy,cfact
	save xprec,bdn02,bdn05,bdn10,bdn15,bdn20
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ initialisations:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
	    bdn02 = ffbnd(1,2,bf)
	    bdn05 = ffbnd(1,5,bf)
	    bdn10 = ffbnd(1,10,bf)
	    bdn15 = ffbnd(1,15,bf)
	    bdn20 = ffbnd(1,19,bf)
	endif
*  #] initialisations:
*  #[ exceptional cases:
	if ( x .eq. 1) then
	    zxdilo = 0
	    zlog = -99999
	    ipi12 = 2
	    return
	elseif (x .eq. -1) then
	    zxdilo = 0
	    zlog = xlg2
	    ipi12 = -1
	    return
	elseif (x .eq. x05) then
	    zxdilo = - xlg2**2/2
	    zlog = -xlg2
	    ipi12 = 1
	    return
	elseif ( abs(x) .lt. precx ) then
	    zxdilo = x
	    zlog = -x
	    ipi12 = 0
	    return
	endif
*  #] exceptional cases:
*  #[ transform to (-1,.5):
	if (x .lt. -1) then
	    fact = log(-x)
	    cy = - fact**2/2
	    ipi12 = -2
	    if ( -x*xloss .gt. 1 ) then
		u = -dfflo1(1/x,ier)
	    else
		u = -log(1-1/x)
	    endif
	    zlog = log(1-x)
	    jsgn = -1
	elseif ( x .lt. x05) then
	    cy = 0
	    ipi12 = 0
	    if ( abs(x) .lt. xloss ) then
		zlog = dfflo1(x,ier)
	    else
		zlog = log(1-x)
	    endif
	    u = -DBLE(zlog)
	    jsgn = 1
	elseif ( x .le. 2 ) then
	    u = -log(x)
	    if ( abs(1-x) .lt. xalogm ) then
		if ( lwarn ) call ffwarn(64,ier,1-x,xalogm)
		cy = 0
	    elseif ( x .lt. 1 ) then
		zlog = log(1-x)
		cy = DBLE(u)*zlog
	    elseif ( ieps .gt. 0 ) then
		zlog = DCMPLX(log(x-1),-pi)
		cy = DBLE(u)*zlog
	    else
		zlog = DCMPLX(log(x-1),+pi)
		cy = DBLE(u)*zlog
	    endif
	    ipi12 = 2
	    jsgn = -1
	else
	    if ( ieps .gt. 0 ) then
		cfact = DCMPLX(log(x),-pi)
		zlog = DCMPLX(log(x-1),-pi)
	    else
		cfact = DCMPLX(log(x),+pi)
		zlog = DCMPLX(log(x-1),+pi)
	    endif
	    cy = - cfact**2/2
	    ipi12 = -2
	    if ( x*xloss .gt. 1 ) then
		u = -dfflo1(1/x,ier)
	    else
		u = -log(1-1/x)
	    endif
	    jsgn = -1
	endif
*  #] transform to (-1,.5):
*  #[ calculate dilog:
	if ( abs(u) .lt. xalog2 ) then
	    xdilo = u
	else
	u2 = u**2
	a = abs(u2)
	if ( lwarn .and. a .gt. bdn20 ) then
	    call ffwarn(66,ier,precx,bf(20)*a**20)
	endif
	if ( a .gt. bdn15 ) then
	    xdilo = u2*(bf(16) + u2*(bf(17) + u2*(bf(18) +
     +		    u2*(bf(19) + u2*(bf(20))))))
	else
	    xdilo = 0
	endif
	if ( a .gt. bdn10 ) then
	    xdilo = u2*(bf(11) + u2*(bf(12) + u2*(bf(13) +
     +		    u2*(bf(14) + u2*(bf(15) + xdilo)))))
	endif
	if ( a .gt. bdn05 ) then
	    xdilo = u2*(bf(6) + u2*(bf(7) + u2*(bf(8) +
     +		    u2*(bf(9) + u2*(bf(10) + xdilo)))))
	endif
	if ( a .gt. bdn02 ) then
	    xdilo = u2*(bf(3) + u2*(bf(4) + u2*(bf(5) + xdilo)))
	endif
*	watch the powers of u.
	xdilo = u + u2*(bf(1) + u*(bf(2) + xdilo))
	endif
	if(jsgn.eq.1)then
	    zxdilo =  DBLE(xdilo) + cy
	else
	    zxdilo = -DBLE(xdilo) + cy
	endif
*  #] calculate dilog:
*###] ffzxdl:
	end
*###[ zxfflg:
	DOUBLE COMPLEX function zxfflg(x,ieps,y,ier)
***#[*comment:***********************************************************
*									*
*	Calculate the complex logarithm of x.  The following cases	*
*	are treted separately:						*
*		|x| too small:		give warning and return 0	*
*					(for Absoft, Apollo DN300)	*
*		|x| < 0:		take sign according to ieps	*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
*
*	arguments
*
	implicit none
	integer ieps,ier
	DOUBLE PRECISION x,y
*
*	local variables
*
	DOUBLE PRECISION xlog
*
*	common blocks
*
	include 'ff.h'
*  #] declarations:
*  #[ check input:
	if ( lwarn .and. abs(x-1) .lt. xloss ) then
	    call ffwarn(129,ier,abs(x-1),x1)
	endif
*  #] check input:
*  #[ calculations:
	if ( abs(x) .lt. xalogm ) then
	    if ( lwarn .and. x .ne. 0 ) call ffwarn(53,ier,x,xalogm)
	    zxfflg = 0
	elseif ( x .gt. 0 ) then
	    zxfflg = log(x)
	else
	    xlog = log(-x)
*	    checked imaginary parts 19-May-1988
	    if ( abs(ieps) .eq. 1 ) then
		if ( y*ieps .lt. 0 ) then
		    zxfflg = DCMPLX(xlog,-pi)
		else
		    zxfflg = DCMPLX(xlog,pi)
		endif
	    elseif ( ieps .eq. 2 ) then
		zxfflg = DCMPLX(xlog,-pi)
	    elseif ( ieps .eq. -2 ) then
		zxfflg = DCMPLX(xlog,+pi)
	    else
		call fferr(52,ier)
		zxfflg = DCMPLX(xlog,pi)
	    endif
	endif
*  #] calculations:
*###] zxfflg:
	end
*###[ dfflo1:
	DOUBLE PRECISION function dfflo1(x,ier)
***#[*comment:***************************************************
*	calculates log(1-x) for |x|<.14 in a faster way to ~15	*
*	significant figures.					*
***#]*comment:***************************************************
*  #[ declarations:
	implicit none
	integer ier
	DOUBLE PRECISION x,bdn01,bdn05,bdn10,bdn15,bdn19,xprec,
     +		xa,d1,xheck,ffbnd
	DOUBLE COMPLEX zxfflg
	save xprec,bdn01,bdn05,bdn10,bdn15,bdn19
	include 'ff.h'
*  #] declarations:
*  #[ initialisation:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv)
	    bdn05 = ffbnd(1,5,xninv)
	    bdn10 = ffbnd(1,10,xninv)
	    bdn15 = ffbnd(1,15,xninv)
	    bdn19 = ffbnd(1,19,xninv)
	endif
*  #] initialisation:
*  #[ calculations:
	xa = abs(x)
	if ( xa .gt. bdn19 ) then
	    if ( lwarn .and. xa .lt. xloss ) call ffwarn(62,ier,x,x1)
	    if ( lwarn .and. 1-x.lt. xloss ) call ffwarn(132,ier,1-x,x1)
	    dfflo1 = DBLE(zxfflg(1-x,0,x0,ier))
	    return
	endif
	if ( xa .gt. bdn15 ) then
	    dfflo1 = x*( xninv(16) + x*( xninv(17) + x*( xninv(18) +
     +		x*( xninv(19) + x*( xninv(20) )))))
	else
	    dfflo1 = 0
	endif
	if ( xa .gt. bdn10 ) then
	    dfflo1 = x*( xninv(11) + x*( xninv(12) + x*( xninv(13) +
     +		x*( xninv(14) + x*( xninv(15) + dfflo1 )))))
	endif
	if ( xa .gt. bdn05 ) then
	    dfflo1 = x*( xninv(6) + x*( xninv(7) + x*( xninv(8) +
     +		x*( xninv(9) + x*( xninv(10) + dfflo1 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    dfflo1 = x*( xninv(2) + x*( xninv(3) + x*( xninv(4) +
     +		x*( xninv(5) + dfflo1 ))))
	endif
	dfflo1 = - x*( xninv(1) + dfflo1 )
*  #] calculations:
*  #[ check output:
	if ( ltest ) then
	    d1 = log(1-x)
	    xheck = d1-dfflo1
	    if ( xloss*abs(xheck) .gt. precx ) print *,'dfflo1: error:',
     +		' answer is not OK',d1,dfflo1,xheck
	endif
*  #] check output:
*###] dfflo1:
	end
*###[ dfflo2:
	DOUBLE PRECISION function dfflo2(x,ier)
***#[*comment:***************************************************
*	calculates log(1-x)+x for |x|<.14 in a faster way to	*
*	~15 significant figures.				*
***#]*comment:***************************************************
*  #[ declarations:
	implicit none
	integer ier,ier0
	DOUBLE PRECISION x,bdn01,bdn05,bdn10,bdn15,bdn18,xprec,
     +		xa,d1,xheck,ffbnd,dfflo1
	save xprec,bdn01,bdn05,bdn10,bdn15,bdn18
	include 'ff.h'
*  #] declarations:
*  #[ initialisation:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv(2))
	    bdn05 = ffbnd(1,5,xninv(2))
	    bdn10 = ffbnd(1,10,xninv(2))
	    bdn15 = ffbnd(1,15,xninv(2))
	    bdn18 = ffbnd(1,18,xninv(2))
	endif
*  #] initialisation:
*  #[ calculations:
	xa = abs(x)
	if ( xa .gt. bdn18 ) then
	    dfflo2 = dfflo1(x,ier) + x
	    if ( lwarn .and. abs(dfflo2).lt.xloss*abs(x) ) then
	    	call ffwarn(231,ier,dfflo2,x)
	    	if ( lwrite ) print *,'dfflo2: not enough terms, x = ',x
	    endif
	    return
	endif
	if ( xa .gt. bdn15 ) then
	    dfflo2 = x*( xninv(17) + x*( xninv(18) + x*( xninv(19) +
     +		x*( xninv(20) ))))
	else
	    dfflo2 = 0
	endif
	if ( xa .gt. bdn10 ) then
	    dfflo2 = x*( xninv(12) + x*( xninv(13) + x*( xninv(14) +
     +		x*( xninv(15) + x*( xninv(16) + dfflo2 )))))
	endif
	if ( xa .gt. bdn05 ) then
	    dfflo2 = x*( xninv(7) + x*( xninv(8) + x*( xninv(9) +
     +		x*( xninv(10) + x*( xninv(11) + dfflo2 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    dfflo2 = x*( xninv(3) + x*( xninv(4) + x*( xninv(5) +
     +		x*( xninv(6) + dfflo2 ))))
	endif
	dfflo2 = - x**2*( xninv(2) + dfflo2 )
*  #] calculations:
*  #[ check output:
	if ( ltest ) then
	    ier0 = ier
	    d1 = dfflo1(x,ier0) + x
	    xheck = d1-dfflo2
	    if ( xloss*abs(xheck) .gt. precx ) print *,'dfflo2: error:',
     +		' answer is not OK',d1,dfflo2,xheck
	endif
*  #] check output:
*###] dfflo2:
	end
*###[ dfflo3:
	DOUBLE PRECISION function dfflo3(x,ier)
***#[*comment:***************************************************
*	calculates log(1-x)+x+x^2/2 for |x|<.14 in a faster 	*
*	way to ~15 significant figures.				*
***#]*comment:***************************************************
*  #[ declarations:
	implicit none
	integer ier,ier0
	DOUBLE PRECISION x,bdn01,bdn05,bdn10,bdn15,xprec,
     +		xa,d1,xheck,ffbnd,dfflo2
	save xprec,bdn01,bdn05,bdn10,bdn15
	include 'ff.h'
*  #] declarations:
*  #[ initialisation:
	data xprec /-1./
	if ( xprec .ne. precx ) then
	    xprec = precx
*	    determine the boundaries for 1,5,10,15 terms
	    bdn01 = ffbnd(1,1,xninv(3))
	    bdn05 = ffbnd(1,5,xninv(3))
	    bdn10 = ffbnd(1,10,xninv(3))
	    bdn15 = ffbnd(1,15,xninv(3))
	endif
*  #] initialisation:
*  #[ calculations:
	xa = abs(x)
	if ( xa .gt. bdn15 ) then
	    dfflo3 = dfflo2(x,ier) + x**2/2
	    if ( lwarn .and. abs(dfflo3).lt.xloss*x**2/2 ) then
	    	call ffwarn(232,ier,dfflo3,x**2/2)
	    	if ( lwrite ) print *,'dfflo3: not enough terms, x = ',x
	    endif
	    return
	endif
	if ( xa .gt. bdn10 ) then
	    dfflo3 = x*( xninv(13) + x*( xninv(14) + x*( xninv(15) +
     +		x*( xninv(16) + x*( xninv(17) )))))
	else
	    dfflo3 = 0
	endif
	if ( xa .gt. bdn05 ) then
	    dfflo3 = x*( xninv(8) + x*( xninv(9) + x*( xninv(10) +
     +		x*( xninv(11) + x*( xninv(12) + dfflo3 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    dfflo3 = x*( xninv(4) + x*( xninv(5) + x*( xninv(6) +
     +		x*( xninv(7) + dfflo3 ))))
	endif
	dfflo3 = - x**3*( xninv(3) + dfflo3 )
*  #] calculations:
*  #[ check output:
	if ( ltest ) then
	    ier0 = ier
	    d1 = dfflo2(x,ier0) + x**2/2
	    xheck = d1-dfflo3
	    if ( xloss*abs(xheck) .gt. precx ) print *,'dfflo3: error:',
     +		' answer is not OK',d1,dfflo3,xheck
	endif
*  #] check output:
*###] dfflo3:
	end
*###[ ffxl22:
	subroutine ffxl22(xl22,x,ier)
***#[*comment:***************************************************
*	calculates Li2(2-x) for |x|<.14 in a faster way to ~15	*
*	significant figures.					*
***#]*comment:***************************************************
*  #[ declarations:
	implicit none
	integer ier,ier0,ipi12p,init
	DOUBLE COMPLEX zli2,zdum
	DOUBLE PRECISION xl22,x,bdn01,bdn05,bdn10,bdn15,bdn20,bdn25,
     +		xprec,xa,xheck,ffbnd,dilog2(29)
	save xprec,bdn01,bdn05,bdn10,bdn15,bdn20,bdn25,init,dilog2
	include 'ff.h'
	data xprec /-1./
	data init /0/
	if ( init .eq. 0 ) then
	    init = 1
* taylor(dilog(x-1),x,30);
	    dilog2( 1) = 0.d0
	    dilog2( 2) = 1/4.d0
	    dilog2( 3) = 1/6.d0
	    dilog2( 4) = 5/48.d0
	    dilog2( 5) = 1/15.d0
	    dilog2( 6) = 2/45.d0
	    dilog2( 7) = 13/420.d0
	    dilog2( 8) = 151/6720.d0
	    dilog2( 9) = 16/945.d0
	    dilog2(10) = 83/6300.d0
	    dilog2(11) = 73/6930.d0
	    dilog2(12) = 1433/166320.d0
	    dilog2(13) = 647/90090.d0
	    dilog2(14) = 15341/2522520.d0
	    dilog2(15) = 28211/5405400.d0
	    dilog2(16) = 10447/2306304.d0
	    dilog2(17) = 608/153153.d0
	    dilog2(18) = 19345/5513508.d0
	    dilog2(19) = 18181/5819814.d0
	    dilog2(20) = 130349/46558512.d0
	    dilog2(21) = 771079/305540235.d0
	    dilog2(22) = 731957/320089770.d0
	    dilog2(23) = 2786599/1338557220.d0
	    dilog2(24) = 122289917/64250746560.d0
	    dilog2(25) = 14614772/8365982625.d0
	    dilog2(26) = 140001721/87006219300.d0
	    dilog2(27) = 134354573/90352612350.d0
	    dilog2(28) = 774885169/562194032400.d0
	    dilog2(29) = 745984697/582272390700.d0
	endif
*  #] declarations:
*  #[ initialisation:
	if ( xprec .ne. precx ) then
	    xprec = precx
*	    determine the boundaries for 1,5,10,15,20 terms
	    bdn01 = ffbnd(2,1,dilog2)
	    bdn05 = ffbnd(2,5,dilog2)
	    bdn10 = ffbnd(2,10,dilog2)
	    bdn15 = ffbnd(2,15,dilog2)
	    bdn20 = ffbnd(2,20,dilog2)
	    bdn25 = ffbnd(2,25,dilog2)
*	    print *,'bdn01 = ',bdn01
*	    print *,'bdn25 = ',bdn25
*	    print *,'dilog2 = ',dilog2
	endif
*  #] initialisation:
*  #[ calculations:
	xa = abs(x)
	if ( xa .gt. bdn25 ) then
	    call ffwarn(230,ier,precx,dilog2(27)*xa**25)
	endif
	if ( xa .gt. bdn20 ) then
	    xl22 = x*( dilog2(22) + x*( dilog2(23) + x*( dilog2(24) +
     +		x*( dilog2(25) + x*( dilog2(26) )))))
	else
	    xl22 = 0
	endif
	if ( xa .gt. bdn15 ) then
	    xl22 = x*( dilog2(17) + x*( dilog2(18) + x*( dilog2(19) +
     +		x*( dilog2(20) + x*( dilog2(21) )))))
	endif
	if ( xa .gt. bdn10 ) then
	    xl22 = x*( dilog2(12) + x*( dilog2(13) + x*( dilog2(14) +
     +		x*( dilog2(15) + x*( dilog2(16) )))))
	endif
	if ( xa .gt. bdn05 ) then
	    xl22 = x*( dilog2(7) + x*( dilog2(8) + x*( dilog2(9) +
     +		x*( dilog2(10) + x*( dilog2(11) + xl22 )))))
	endif
	if ( xa .gt. bdn01 ) then
	    xl22 = x*( dilog2(3) + x*( dilog2(4) + x*( dilog2(5) +
     +		x*( dilog2(6) + xl22 ))))
	endif
	xl22 = - x**2*( dilog2(2) + xl22 )
*  #] calculations:
*  #[ check output:
	if ( ltest ) then
	    ier0 = 0
	    ipi12p = 0
	    call ffzxdl(zli2,ipi12p,zdum,2-x,1,ier0)
	    xheck = DBLE(zli2)-xl22 + (ipi12p-3)*pi12
	    if ( xloss*abs(xheck) .gt. precc*2.5 ) then
		print *,'xl22: error: answer is not OK',
     +			DBLE(zli2)+ipi12p*pi12,xl22+3*pi12,xheck
	    endif
	endif
*  #] check output:
*###] ffxl22:
	end
*###[ ffxxyz:
	subroutine ffxxyz(y,z,dyz,d2yzz,dy2z,ivert,sdel2p,sdel2s,etalam,
     +		etami,delps,xpi,dpipj,piDpj,isoort,ldel2s,ns,ier)
***#[*comment:***********************************************************
*									*
*	calculate in a numerically stable way				*
*									*
*	z(1,2) = (-p(ip1).p(is2) +/- sdel2s)/xpi(ip1)			*
*	y(1,2) = (-p(ip1).p(is2) +/- sdisc)/xpi(ip1)			*
*			disc = del2s + etaslam*xpi(ip1)			*
*									*
*	y(3,4) = 1-y(1,2)						*
*	z(3,4) = 1-z(1,2)						*
*	dyz(i,j) = y(i) - z(j)						*
*	d2yzz = y(2) - z(1) - z(2)					*
*	dy2z(j) = y(2) - 2*z(j)						*
*									*
*	Input:	ivert		(integer)	defines the vertex	*
*		sdel2p		(real)		sqrt(lam(p1,p2,p3))/2	*
*		sdel2s		(real)		sqrt(lam(p,ma,mb))/2	*
*		etalam		(real)		det(si.sj)/det(pi.pj)	*
*		etami(6)	(real)		si.si - etalam		*
*		xpi(ns)		(real)		standard		*
*		piDpj(ns,ns)	(real)		standard		*
*		ns		(integer)	dim of xpi,piDpj	*
*									*
*	Output:	y(4),z(4),dyz(4,4)	(real)		see above	*
*									*
*	Calls:	fferr,ffroot						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer ivert,ns,ier,isoort(2)
	logical ldel2s
	DOUBLE PRECISION y(4),z(4),dyz(2,2),d2yzz,dy2z(4),
     +		sdel2p,sdel2s,etalam,etami(6),delps,xpi(ns),
     +		dpipj(ns,ns),piDpj(ns,ns)
*
*	local variables:
*
	integer i,j,n,ip1,ip2,ip3,is1,is2,is3,iwarn,ier0,ier1
	DOUBLE PRECISION delps1,disc,xheck,xlosn,hulp,s,smax,som(51),
     +		xmax
	DOUBLE PRECISION t1,t2,t4,t5,t8,t3,t7,t9,t12,t14,t21,t23,t24,
     +	t28,t6,t35,t44,t42,t36,t55,t41,t19,t59,t25,t69,t82,t75,t84,t92,
     +	t31,t98,t74,t101,t89,t106,t112,t113,t13,t117,t126,t127,t129,
     +	t130,t133,t128,t132,t134,t137,t139,t146,t148,t149,t153,t131,
     +	t160,t171,t169,t161,t182,t168,t144,t186,t150,t208,t201,t210,
     +	t219,t156,t225,t200,t228,t215,t233,t239,t240,t138,t244
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ set up pointers:
	if ( ldel2s .and. ivert .ne. 1 ) goto 100
	is1 = ivert
	is2 = ivert+1
	if ( is2 .eq. 4 ) is2 = 1
	is3 = ivert-1
	if ( is3 .eq. 0 ) is3 = 3
	ip1 = is1 + 3
	ip2 = is2 + 3
	ip3 = is3 + 3
*  #] set up pointers:
*  #[ xk = 0:
	if ( xpi(ip1) .eq. 0 ) then
	    isoort(2) = 0
	    if ( piDpj(is1,ip1) .eq. 0 ) then
		isoort(1) = 0
		if ( lwrite ) print *,'ffxxyz: xk=0, ma=mb -> S3 =0'
		return
	    endif
	    isoort(1) = 1
	    y(1) = etami(is2) / piDpj(is1,ip1) /2
	    y(2) = y(1)
	    y(3) = - etami(is1) / piDpj(is1,ip1) /2
	    y(4) = y(3)
	    z(1) = xpi(is2) / piDpj(is1,ip1) /2
	    z(2) = z(1)
	    z(3) = - xpi(is1) / piDpj(is1,ip1) /2
	    z(4) = z(3)
	    dyz(1,1) = - etalam / piDpj(is1,ip1) /2
	    dyz(1,2) = dyz(1,1)
	    dyz(2,1) = dyz(1,1)
	    dyz(2,2) = dyz(1,1)
	    if ( ltest ) then
*		check whether we have the correct root ...
		ier0 = ier
		call ffdl2p(delps1,xpi,dpipj,piDpj,
     +			ip1,ip2,ip3,is1,is2,is3,ns,ier0)
		disc = delps1/sdel2p
		xheck = piDpj(ip1,is2) + disc
		if ( xloss*abs(xheck) .gt. precx*max(abs(piDpj(ip1,
     +			is2)),abs(disc)) ) call fferr(37,ier)
	    endif
	    ier1 = ier
	    do 10 i=1,3,2
		dy2z(i) = y(i) - 2*z(i)
		smax = abs(y(i))
		if ( lwarn .and. abs(dy2z(i)) .lt. xloss*smax ) then
		    ier0 = ier
		    call ffwarn(152,ier0,dy2z(i),smax)
		    ier1 = max(ier1,ier0)
		    if ( lwrite ) print *,'special case xk = 0'
		endif
		dy2z(i+1) = dy2z(i)
   10	    continue
	    ier = ier1
	    return
	endif
*  #] xk = 0:
*  #[ get y(1,2),z(1,2):
	if ( sdel2s .eq. 0 ) then
	    isoort(1) = 2
	    isoort(2) = 2
	    z(1) = piDpj(ip1,is2)/xpi(ip1)
	    z(2) = z(1)
	else
	    isoort(1) = 1
	    isoort(2) = 1
	    call ffroot(z(1),z(2),xpi(ip1),piDpj(ip1,is2),xpi(is2),
     +							sdel2s,ier)
	endif
*	if ( ltest ) then
*	    call ffdl2p(delps1,xpi,dpipj,piDpj,
*     +		ip1,ip2,ip3,is1,is2,is3,ns,ier)
*	    if ( delps .ne. delps1 ) print *,'ffxxyz: error: delps != ',
*     +		'delps1: ',delps,delps1
*	endif
	disc = delps/sdel2p
	ier0 = ier
	call ffroot(y(1),y(2),xpi(ip1),piDpj(ip1,is2),etami(is2),disc,
     +								ier)
*  #] get y(1,2),z(1,2):
*  #[ get y(3,4),z(3,4):
*	if ( xpi(is1) .eq. xpi(is2) ) then
*	    y(4) = y(1)
*	    y(3) = y(2)
*	    z(4) = z(1)
*	    z(3) = z(2)
*	else
	    if ( isoort(1) .eq. 2 ) then
		z(3) = -piDpj(ip1,is1)/xpi(ip1)
		z(4) = z(3)
	    else
		z(3) = 1-z(1)
		z(4) = 1-z(2)
		if ( abs(z(3)) .lt. xloss .or. abs(z(4)) .lt. xloss )
     +		    call ffroot(z(4),z(3),xpi(ip1),-piDpj(ip1,is1),
     +						xpi(is1),sdel2s,ier)
	    endif
	    y(3) = 1-y(1)
	    y(4) = 1-y(2)
	    if ( abs(y(3)) .lt. xloss .or. abs(y(4)) .lt. xloss ) then
		call ffroot(y(4),y(3),xpi(ip1),-piDpj(ip1,is1),
     +						etami(is1),disc,ier)
	    endif
*	endif
*  #] get y(3,4),z(3,4):
*  #[ get dyz:
*	Note that dyz(i,j) only exists for i,j=1,2!
	if ( isoort(1) .eq. 2 ) then
	    dyz(2,1) = disc/xpi(ip1)
	    dyz(2,2) = dyz(2,1)
	elseif ( disc .gt. 0 .eqv. sdel2s .gt. 0 ) then
	    dyz(2,1) = ( disc + sdel2s )/xpi(ip1)
	    dyz(2,2) = etalam/(xpi(ip1)*dyz(2,1))
	else
	    dyz(2,2) = ( disc - sdel2s )/xpi(ip1)
	    dyz(2,1) = etalam/(xpi(ip1)*dyz(2,2))
	endif
	dyz(1,1) = -dyz(2,2)
	dyz(1,2) = -dyz(2,1)
	d2yzz = 2*disc/xpi(ip1)
*
*	these are very rarely needed, but ...
*
	iwarn = 0
	ier1 = ier
	do 20 i=1,4
	    j = 2*((i+1)/2)
	    dy2z(i) = y(j) - 2*z(i)
	    smax = abs(y(j))
	    if ( abs(dy2z(i)) .lt. xloss*smax ) then
		if ( lwrite ) print *,'  dy2z(',i,') = ',dy2z(i),smax
		if ( i/2 .eq. 1 ) then
		    s = -y(j-1) - 2*sdel2s/xpi(ip1)
		else
		    s = -y(j-1) + 2*sdel2s/xpi(ip1)
		endif
		if ( lwrite ) print *,'  dy2z(',i,')+= ',s,y(j-1)
		if ( abs(y(j-1)) .lt. smax ) then
		    dy2z(i) = s
		    smax = abs(y(j-1))
		endif
		if ( abs(dy2z(i)) .lt. xloss*smax ) then
		    if ( iwarn .ne. 0 ) then
			if ( lwarn ) then
			    ier0 = ier
			    call ffwarn(152,ier0,dy2z(i),smax)
			    ier1 = max(ier1,ier0)
			    if ( lwrite ) print *,'iwarn = ',i
			endif
		    else
			iwarn = i
			xmax = smax
		    endif
		endif
	    endif
   20	continue
	if ( iwarn .ne. 0 ) then
*
*	    we should import the differences, but later...
*
	    if ( abs(dpipj(is3,ip1)) .lt. xloss*xpi(is3)
     +		.and. abs(dpipj(is1,is2)) .lt. xloss*abs(xpi(ip1))) then
*
*		give it another try - multiply roots (see dy2z.frm)
*
		if ( iwarn.lt.3 ) then
*prod1=
*	som(1)=+160*xpi(ip1)*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2*
*     +	dpipj(is2,is1)**2
*	som(2)=-40*xpi(ip1)*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)**3
*	som(3)=-32*xpi(ip1)*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)**3
*	som(4)=+9*xpi(ip1)*xpi(ip2)**2*dpipj(is2,is1)**4
*	som(5)=-128*xpi(ip1)*xpi(is2)*piDpj(ip1,ip2)**3*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)
*	som(6)=-128*xpi(ip1)*xpi(is2)*piDpj(ip1,ip2)**4*dpipj(is2,
*     +	is1)
*	som(7)=+256*xpi(ip1)*xpi(is2)**2*piDpj(ip1,ip2)**4
*	som(8)=-16*xpi(ip1)*piDpj(ip1,ip2)**2*piDpj(ip2,is2)**2*
*     +	dpipj(is2,is1)**2
*	som(9)=+96*xpi(ip1)*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*dpipj(is2,
*     +	is1)**2
*	som(10)=+128*xpi(ip1)**2*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)*piDpj(
*     +	ip2,is2)*dpipj(is2,is1)
*	som(11)=+320*xpi(ip1)**2*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2*
*     +	dpipj(is2,is1)
*	som(12)=-512*xpi(ip1)**2*xpi(ip2)*xpi(is2)**2*piDpj(ip1,ip2)**2
*	som(13)=-120*xpi(ip1)**2*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)**2
*	som(14)=-48*xpi(ip1)**2*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)**2
*	som(15)=+40*xpi(ip1)**2*xpi(ip2)*piDpj(ip2,is2)**2*dpipj(is2,
*     +	is1)**2
*	som(16)=-96*xpi(ip1)**2*xpi(ip2)**2*xpi(is2)*dpipj(is2,is1)**2
*	som(17)=+36*xpi(ip1)**2*xpi(ip2)**2*dpipj(is2,is1)**3
*	som(18)=+128*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**2*piDpj(ip2,
*     +	is2)**2
*	som(19)=-128*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**3*piDpj(ip2,
*     +	is2)
*	som(20)=-64*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**4
*	som(21)=-32*xpi(ip1)**2*piDpj(ip1,ip2)*piDpj(ip2,is2)**3*
*     +	dpipj(is2,is1)
*	som(22)=-32*xpi(ip1)**2*piDpj(ip1,ip2)**2*piDpj(ip2,is2)**2*
*     +	dpipj(is2,is1)
*	som(23)=+96*xpi(ip1)**2*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*
*     +	dpipj(is2,is1)
*	som(24)=+128*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)*piDpj(
*     +	ip2,is2)
*	som(25)=+160*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2
*	som(26)=-128*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip2,is2)**2
*	som(27)=+32*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(28)=-120*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)
*	som(29)=-32*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)
*	som(30)=-16*xpi(ip1)**3*xpi(ip2)*piDpj(ip2,is1)*piDpj(ip2,
*     +	is2)**2
*	som(31)=+80*xpi(ip1)**3*xpi(ip2)*piDpj(ip2,is2)**2*dpipj(is2,
*     +	is1)
*	som(32)=-192*xpi(ip1)**3*xpi(ip2)**2*xpi(is2)*dpipj(is2,is1)
*	som(33)=+256*xpi(ip1)**3*xpi(ip2)**2*xpi(is2)**2
*	som(34)=+54*xpi(ip1)**3*xpi(ip2)**2*dpipj(is2,is1)**2
*	som(35)=-16*xpi(ip1)**3*xpi(ip3)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(36)=+8*xpi(ip1)**3*xpi(ip3)*piDpj(ip2,is1)*piDpj(ip2,is2)**2
*	som(37)=+16*xpi(ip1)**3*xpi(is2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(38)=-8*xpi(ip1)**3*xpi(is2)*piDpj(ip2,is1)*piDpj(ip2,is2)**2
*	som(39)=-16*xpi(ip1)**3*piDpj(ip1,ip2)*piDpj(ip2,is1)*piDpj(ip2,
*     +	is2)*dpipj(is3,ip1)
*	som(40)=+8*xpi(ip1)**3*piDpj(ip2,is1)*piDpj(ip2,is2)**2*
*     +	dpipj(is3,ip1)
*	som(41)=-40*xpi(ip1)**4*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,is2)
*	som(42)=-8*xpi(ip1)**4*xpi(ip2)*piDpj(ip1,ip2)**2
*	som(43)=+40*xpi(ip1)**4*xpi(ip2)*piDpj(ip2,is2)**2
*	som(44)=-96*xpi(ip1)**4*xpi(ip2)**2*xpi(is2)
*	som(45)=+36*xpi(ip1)**4*xpi(ip2)**2*dpipj(is2,is1)
*	som(46)=+9*xpi(ip1)**5*xpi(ip2)**2
*	som(47)=-8*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,is1)**4
*	som(48)=-64*xpi(is2)*piDpj(ip1,ip2)**4*dpipj(is2,is1)**2
*	som(49)=+32*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*dpipj(is2,is1)**3
*	print '(7g20.12)',(som(i),i=1,49)
*
*	optimized by Maple (see ffxxyz.map)
*
	t1 = xpi(ip1)
	t2 = xpi(ip2)
	t3 = t1*t2
	t4 = xpi(is2)
	t5 = piDpj(ip1,ip2)
	t6 = t5**2
	t7 = t4*t6
	t8 = dpipj(is2,is1)
	t9 = t8**2
	som(1) = 160*t3*t7*t9
	t12 = piDpj(ip2,is2)
	t13 = t5*t12
	t14 = t9*t8
	som(2) = -40*t3*t13*t14
	som(3) = -32*t3*t6*t14
	t19 = t2**2
	t21 = t9**2
	som(4) = 9*t1*t19*t21
	t23 = t1*t4
	t24 = t6*t5
	t25 = t24*t12
	som(5) = -128*t23*t25*t8
	t28 = t6**2
	som(6) = -128*t23*t28*t8
	t31 = t4**2
	som(7) = 256*t1*t31*t28
	t35 = t12**2
	t36 = t35*t9
	som(8) = -16*t1*t6*t36
	som(9) = 96*t1*t24*t12*t9
	t41 = t1**2
	t42 = t41*t2
	t44 = t13*t8
	som(10) = 128*t42*t4*t44
	som(11) = 320*t42*t7*t8
	som(12) = -512*t42*t31*t6
	som(13) = -120*t42*t13*t9
	som(14) = -48*t42*t6*t9
	som(15) = 40*t42*t36
	t55 = t41*t19
	som(16) = -96*t55*t4*t9
	som(17) = 36*t55*t14
	t59 = t41*t4
	som(18) = 128*t59*t6*t35
	som(19) = -128*t59*t25
	som(20) = -64*t59*t28
	som(21) = -32*t41*t5*t35*t12*t8
	t69 = t35*t8
	som(22) = -32*t41*t6*t69
	som(23) = 96*t41*t24*t12*t8
	t74 = t41*t1
	t75 = t74*t2
	som(24) = 128*t75*t4*t5*t12
	som(25) = 160*t75*t7
	som(26) = -128*t75*t4*t35
	t82 = piDpj(ip2,is1)
	t84 = t5*t82*t12
	som(27) = 32*t75*t84
	som(28) = -120*t75*t44
	som(29) = -32*t75*t6*t8
	t89 = t82*t35
	som(30) = -16*t75*t89
	som(31) = 80*t75*t69
	t92 = t74*t19
	som(32) = -192*t92*t4*t8
	som(33) = 256*t92*t31
	som(34) = 54*t92*t9
	t98 = t74*xpi(ip3)
	som(35) = -16*t98*t84
	som(36) = 8*t98*t89
	t101 = t74*t4
	som(37) = 16*t101*t84
	som(38) = -8*t101*t89
	t106 = dpipj(is3,ip1)
	som(39) = -16*t74*t5*t82*t12*t106
	som(40) = 8*t74*t82*t35*t106
	t112 = t41**2
	t113 = t112*t2
	som(41) = -40*t113*t13
	som(42) = -8*t113*t6
	som(43) = 40*t113*t35
	t117 = t112*t19
	som(44) = -96*t117*t4
	som(45) = 36*t117*t8
	som(46) = 9*t112*t1*t19
	som(47) = -8*t2*t6*t21
	som(48) = -64*t4*t28*t9
	som(49) = 32*t25*t14
*	print '(7g20.12)',(som(i),i=1,49)
	n=49
		else
*prod3=
*	som(1)=+160*xpi(ip1)*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2*
*     +	dpipj(is2,is1)**2
*	som(2)=-40*xpi(ip1)*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)**3
*	som(3)=-88*xpi(ip1)*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)**3
*	som(4)=+9*xpi(ip1)*xpi(ip2)**2*dpipj(is2,is1)**4
*	som(5)=-128*xpi(ip1)*xpi(is2)*piDpj(ip1,ip2)**3*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)
*	som(6)=-256*xpi(ip1)*xpi(is2)*piDpj(ip1,ip2)**4*dpipj(is2,is1)
*	som(7)=+256*xpi(ip1)*xpi(is2)**2*piDpj(ip1,ip2)**4
*	som(8)=-16*xpi(ip1)*piDpj(ip1,ip2)**2*piDpj(ip2,is2)**2*dpipj(
*     +	is2,is1)**2
*	som(9)=+64*xpi(ip1)*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*dpipj(is2,
*     +	is1)**2
*	som(10)=+80*xpi(ip1)*piDpj(ip1,ip2)**4*dpipj(is2,is1)**2
*	som(11)=+128*xpi(ip1)**2*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)*piDpj(
*     +	ip2,is2)*dpipj(is2,is1)
*	som(12)=+576*xpi(ip1)**2*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2*
*     +	dpipj(is2,is1)
*	som(13)=-512*xpi(ip1)**2*xpi(ip2)*xpi(is2)**2*piDpj(ip1,ip2)**2
*	som(14)=-88*xpi(ip1)**2*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)**2
*	som(15)=-192*xpi(ip1)**2*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)**2
*	som(16)=+40*xpi(ip1)**2*xpi(ip2)*piDpj(ip2,is2)**2*dpipj(is2,
*     +	is1)**2
*	som(17)=-96*xpi(ip1)**2*xpi(ip2)**2*xpi(is2)*dpipj(is2,is1)**2
*	som(18)=+60*xpi(ip1)**2*xpi(ip2)**2*dpipj(is2,is1)**3
*	som(19)=+128*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**2*piDpj(ip2,
*     +	is2)**2
*	som(20)=-128*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**3*piDpj(ip2,
*     +	is2)
*	som(21)=-64*xpi(ip1)**2*xpi(is2)*piDpj(ip1,ip2)**4
*	som(22)=-32*xpi(ip1)**2*piDpj(ip1,ip2)*piDpj(ip2,is2)**3*
*     +	dpipj(is2,is1)
*	som(23)=+64*xpi(ip1)**2*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*
*     +	dpipj(is2,is1)
*	som(24)=+32*xpi(ip1)**2*piDpj(ip1,ip2)**4*dpipj(is2,is1)
*	som(25)=+128*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)*piDpj(
*     +	ip2,is2)
*	som(26)=+160*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip1,ip2)**2
*	som(27)=-128*xpi(ip1)**3*xpi(ip2)*xpi(is2)*piDpj(ip2,is2)**2
*	som(28)=+32*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(29)=-88*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is2)*dpipj(is2,is1)
*	som(30)=-88*xpi(ip1)**3*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,
*     +	is1)
*	som(31)=-16*xpi(ip1)**3*xpi(ip2)*piDpj(ip2,is1)*piDpj(ip2,
*     +	is2)**2
*	som(32)=+48*xpi(ip1)**3*xpi(ip2)*piDpj(ip2,is2)**2*dpipj(is2,
*     +	is1)
*	som(33)=-320*xpi(ip1)**3*xpi(ip2)**2*xpi(is2)*dpipj(is2,is1)
*	som(34)=+256*xpi(ip1)**3*xpi(ip2)**2*xpi(is2)**2
*	som(35)=+118*xpi(ip1)**3*xpi(ip2)**2*dpipj(is2,is1)**2
*	som(36)=-16*xpi(ip1)**3*xpi(ip3)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(37)=+8*xpi(ip1)**3*xpi(ip3)*piDpj(ip2,is1)*piDpj(ip2,is2)**2
*	som(38)=+16*xpi(ip1)**3*xpi(is2)*piDpj(ip1,ip2)*piDpj(ip2,
*     +	is1)*piDpj(ip2,is2)
*	som(39)=-8*xpi(ip1)**3*xpi(is2)*piDpj(ip2,is1)*piDpj(ip2,is2)**2
*	som(40)=-16*xpi(ip1)**3*piDpj(ip1,ip2)*piDpj(ip2,is1)*piDpj(ip2,
*     +	is2)*dpipj(is3,ip1)
*	som(41)=+8*xpi(ip1)**3*piDpj(ip2,is1)*piDpj(ip2,is2)**2*
*     +	dpipj(is3,ip1)
*	som(42)=-40*xpi(ip1)**4*xpi(ip2)*piDpj(ip1,ip2)*piDpj(ip2,is2)
*	som(43)=-8*xpi(ip1)**4*xpi(ip2)*piDpj(ip1,ip2)**2
*	som(44)=+40*xpi(ip1)**4*xpi(ip2)*piDpj(ip2,is2)**2
*	som(45)=-96*xpi(ip1)**4*xpi(ip2)**2*xpi(is2)
*	som(46)=+60*xpi(ip1)**4*xpi(ip2)**2*dpipj(is2,is1)
*	som(47)=+9*xpi(ip1)**5*xpi(ip2)**2
*	som(48)=-8*xpi(ip2)*piDpj(ip1,ip2)**2*dpipj(is2,is1)**4
*	som(49)=-64*xpi(is2)*piDpj(ip1,ip2)**4*dpipj(is2,is1)**2
*	som(50)=+32*piDpj(ip1,ip2)**3*piDpj(ip2,is2)*dpipj(is2,is1)**3
*	som(51)=+32*piDpj(ip1,ip2)**4*dpipj(is2,is1)**3
*	print '(7g20.12)',(som(i),i=1,51)
*
*	optimized by Maple (see ffxxyz.map)
*
	t126 = xpi(ip1)
	t127 = xpi(ip2)
	t128 = t126*t127
	t129 = xpi(is2)
	t130 = piDpj(ip1,ip2)
	t131 = t130**2
	t132 = t129*t131
	t133 = dpipj(is2,is1)
	t134 = t133**2
	som(1) = 160*t128*t132*t134
	t137 = piDpj(ip2,is2)
	t138 = t130*t137
	t139 = t134*t133
	som(2) = -40*t128*t138*t139
	som(3) = -88*t128*t131*t139
	t144 = t127**2
	t146 = t134**2
	som(4) = 9*t126*t144*t146
	t148 = t126*t129
	t149 = t131*t130
	t150 = t149*t137
	som(5) = -128*t148*t150*t133
	t153 = t131**2
	som(6) = -256*t148*t153*t133
	t156 = t129**2
	som(7) = 256*t126*t156*t153
	t160 = t137**2
	t161 = t160*t134
	som(8) = -16*t126*t131*t161
	som(9) = 64*t126*t149*t137*t134
	som(10) = 80*t126*t153*t134
	t168 = t126**2
	t169 = t168*t127
	t171 = t138*t133
	som(11) = 128*t169*t129*t171
	som(12) = 576*t169*t132*t133
	som(13) = -512*t169*t156*t131
	som(14) = -88*t169*t138*t134
	som(15) = -192*t169*t131*t134
	som(16) = 40*t169*t161
	t182 = t168*t144
	som(17) = -96*t182*t129*t134
	som(18) = 60*t182*t139
	t186 = t168*t129
	som(19) = 128*t186*t131*t160
	som(20) = -128*t186*t150
	som(21) = -64*t186*t153
	som(22) = -32*t168*t130*t160*t137*t133
	som(23) = 64*t168*t149*t137*t133
	som(24) = 32*t168*t153*t133
	t200 = t168*t126
	t201 = t200*t127
	som(25) = 128*t201*t129*t130*t137
	som(26) = 160*t201*t132
	som(27) = -128*t201*t129*t160
	t208 = piDpj(ip2,is1)
	t210 = t130*t208*t137
	som(28) = 32*t201*t210
	som(29) = -88*t201*t171
	som(30) = -88*t201*t131*t133
	t215 = t208*t160
	som(31) = -16*t201*t215
	som(32) = 48*t201*t160*t133
	t219 = t200*t144
	som(33) = -320*t219*t129*t133
	som(34) = 256*t219*t156
	som(35) = 118*t219*t134
	t225 = t200*xpi(ip3)
	som(36) = -16*t225*t210
	som(37) = 8*t225*t215
	t228 = t200*t129
	som(38) = 16*t228*t210
	som(39) = -8*t228*t215
	t233 = dpipj(is3,ip1)
	som(40) = -16*t200*t130*t208*t137*t233
	som(41) = 8*t200*t208*t160*t233
	t239 = t168**2
	t240 = t239*t127
	som(42) = -40*t240*t138
	som(43) = -8*t240*t131
	som(44) = 40*t240*t160
	t244 = t239*t144
	som(45) = -96*t244*t129
	som(46) = 60*t244*t133
	som(47) = 9*t239*t126*t144
	som(48) = -8*t127*t131*t146
	som(49) = -64*t129*t153*t134
	som(50) = 32*t150*t139
	som(51) = 32*t153*t139
*	print '(7g20.12)',(som(i),i=1,51)
	n=51
		endif
*
		s = 0
		smax = 0
		do 30 j=1,n
		    s = s + som(j)
		    smax = max(smax,som(j))
   30		continue
		if ( iwarn .lt. 3 ) then
		    hulp = 1/(16*xpi(ip1)**3*sdel2p**4*dy2z(3-iwarn)*
     +			(y(1)-2*z(1))*(y(1)-2*z(2)))
		else
		    hulp = 1/(16*xpi(ip1)**3*sdel2p**4*dy2z(7-iwarn)*
     +			(y(3)-2*z(3))*(y(3)-2*z(4)))
		endif
		s = s*hulp
		smax = smax*hulp
		if ( lwrite ) print *,'  dy2z(',iwarn,')++=',s,smax
		if ( smax .lt. xmax ) then
		    dy2z(iwarn) = s
		    xmax = smax
		endif
	    else
		n=0
	    endif
	    if ( abs(dy2z(iwarn)) .lt. xloss*xmax ) then
		ier0 = ier
		call ffwarn(152,ier0,dy2z(iwarn),xmax)
		ier1 = max(ier1,ier0)
		if ( lwrite ) then
		    print *,'n = ',n
		    print *,'xpi = ',xpi
		    print *,'cs = '
		    print '(i3,g24.12)',(i,som(i),i=1,n)
		endif
	    endif
	endif
	ier = ier1
*
	goto 200
*  #] get dyz:
*  #[ special case, get indices:
  100	continue
	if ( ivert.eq.2 ) then
	    is1 = 2
	    ip1 = 5
	else
	    is1 = 1
	    ip1 = 6
	endif
*  #] special case, get indices:
*  #[ xk = 0:
	if ( xpi(ip1) .eq. 0 ) then
	    call fferr(88,ier)
	endif
*  #] xk = 0:
*  #[ get ypm,zpm:
*
*	special case del2s = 0, hence the roots are not the real roots
*	but z_2'' = (z_2'-1)/delta, z''_3 = -z'_3/delta
*
	hulp = sdel2s
	disc = delps/sdel2p
	if ( ivert .eq. 3 ) then
	    hulp = -hulp
	    disc = -disc
	endif
	if ( sdel2s .eq. 0 ) then
	    isoort(1) = 102
	    isoort(2) = 102
	    z(1) = piDpj(is1,3)/xpi(3)
	    z(2) = z(1)
	else
	    isoort(1) = 101
	    isoort(2) = 101
	    call ffroot(z(1),z(2),xpi(3),piDpj(is1,3),xpi(is1),hulp,ier)
	endif
	call ffroot(y(1),y(2),xpi(3),piDpj(is1,3),etami(is1),disc,ier)
*  #] get ypm,zpm:
*  #[ get ypm1,zpm1:
	z(3) = 1 - z(1)
	z(4) = 1 - z(2)
	if ( abs(z(3)).lt.xloss .or. abs(z(4)).lt.xloss ) then
	    if ( lwrite ) print *,'z(3,4) = ',z(3),z(4)
	    if ( ivert.eq.2 ) then
		call ffroot(z(4),z(3),xpi(3),piDpj(ip1,3),xpi(ip1),hulp,
     +								ier)
	    else
		call ffroot(z(4),z(3),xpi(3),-piDpj(ip1,3),xpi(ip1),hulp
     +								,ier)
	    endif
	    if ( lwrite ) print *,'z(3,4)+= ',z(3),z(4)
	endif
	y(3) = 1 - y(1)
	y(4) = 1 - y(2)
	if ( abs(y(3)) .lt. xloss .or. abs(y(4)) .lt. xloss ) then
	    if ( lwrite ) print *,'y(3,4) = ',y(3),y(4)
	    if ( ivert .eq. 2 ) then
		call ffroot(y(4),y(3),xpi(3),piDpj(ip1,3),etami(ip1),
     +							disc,ier)
	    else
		call ffroot(y(4),y(3),xpi(3),-piDpj(ip1,3),etami(ip1),
     +							disc,ier)
	    endif
	    if ( lwrite ) print *,'y(3,4)+= ',y(3),y(4)
	endif
*  #] get ypm1,zpm1:
*  #[ get dypzp, dypzm:
	if ( isoort(1) .eq. 2 ) then
	    dyz(2,1) = disc/xpi(3)
	    dyz(2,2) = dyz(2,1)
	elseif ( disc .gt. 0 .eqv. sdel2s .gt. 0 ) then
	    dyz(2,1) = ( disc + hulp )/xpi(3)
	    dyz(2,2) = etalam/(xpi(3)*dyz(2,1))
	else
	    dyz(2,2) = ( disc - hulp )/xpi(3)
	    dyz(2,1) = etalam/(xpi(3)*dyz(2,2))
	endif
	dyz(1,1) = -dyz(2,2)
	dyz(1,2) = -dyz(2,1)
	d2yzz = 2*disc/xpi(3)
*
*	these are very rarely needed, but ...
*
	do 220 i=1,4
	    j = 2*((i+1)/2)
	    dy2z(i) = y(j) - 2*z(i)
	    smax = abs(y(j))
*	    do not know whether this is correct! 29-mar-1990
*	    if ( abs(dy2z(i)) .lt. xloss*smax ) then
*		if ( lwrite ) print *,'  dy2z(',i,') = ',dy2z(i),smax
*		if ( i/2 .eq. 1 ) then
*		    s = -y(j-1) - 2*hulp/xpi(3)
*		else
*		    s = -y(j-1) + 2*hulp/xpi(3)
*		endif
*		if ( abs(y(j-1)) .lt. smax ) then
*		    dy2z(i) = s
*		    smax = abs(y(j-1))
*		endif
*		if ( lwrite ) print *,'  dy2z(',i,')+= ',s,y(j-1)
		if ( lwarn .and. abs(dy2z(i)) .lt. xloss*smax ) then
		    call ffwarn(152,ier,dy2z(i),abs(y(j-1)))
		endif
*	    endif
  220	continue
*  #] get dypzp, dypzm:
*  #[ test output:
  200	continue
	if ( ltest ) then
	    xlosn = xloss**2*DBLE(10)**(-mod(ier,50))
	    do 99 i=1,2
		xheck = y(i)+y(i+2)-1
		if ( xlosn*abs(xheck) .gt. precx*max(abs(y(i)),
     +		    abs(y(i+2)),x1) ) print *,'ffxxyz: error: ',
     +		    'y(',i+2,')<>1-y(',i,'):',y(i+2),y(i),xheck
		xheck = z(i)+z(i+2)-1
		if ( xlosn*abs(xheck) .gt. precx*max(abs(z(i)),
     +		    abs(z(i+2)),x1) ) print *,'ffxxyz: error: ',
     +		    'z(',i+2,')<>1-z(',i,'):',z(i+2),z(i),xheck
		xheck = dy2z(i)-y(2)+2*z(i)
		if ( xlosn*abs(xheck) .gt. precx*max(abs(y(2)),
     +		    abs(2*z(i))) ) print *,'ffxxyz: error: ',
     +		    'dy2z(',i,')<>y(2)-2*z(',i,'):',dy2z(i),y(2),2*z(i),
     +		    xheck
		xheck = dy2z(i+2)-y(4)+2*z(i+2)
		if ( xlosn*abs(xheck) .gt. precx*max(abs(y(4)),
     +		    abs(2*z(i+2)))) print *,'ffxxyz: error: ',
     +		    'dy2z(',i+2,')<>y(4)-2*z(',i+2,'):',dy2z(i+2),y(4),
     +		    2*z(i+2),xheck
		do 98 j=1,2
		    if ( xlosn*abs(dyz(i,j)-y(i)+z(j)) .gt. precx*max(
     +			abs(dyz(i,j)),abs(y(i)),abs(z(j))) ) print *,
     +			'ffxxyz: error: dyz(',i,j,') <> y(',i,')-z(',j,
     +			'):',dyz(i,j),y(i),z(j),dyz(i,j)-y(i)+z(j)
   98		continue
   99	    continue
	    if ( xlosn*abs(d2yzz-2*y(2)+z(1)+z(2)) .gt. precx*max(abs(
     +		d2yzz),2*abs(y(2)),abs(z(1)),abs(z(2))) ) print *,
     +		'ffxxyz: error: d2yzz <> 2*y(2)+z(1)+z(2):',d2yzz,2*
     +		y(2),z(1),z(2),d2yzz-2*y(2)+z(1)+z(2)
	endif
*  #] test output:
*###] ffxxyz:
	end
*###[ ffdwz:
	subroutine ffdwz(dwz,w,z,i1,j1,l,alpha,alph1,xpi,dpipj,piDpj,
     +							sdel2i,ns,ier)
***#[*comment:***********************************************************
*									*
*	Recalculate dwz(i1,j1) = w(i1) - z(j1)				*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments:
*
	integer i1,j1,l,ns,ier
	DOUBLE PRECISION dwz(2,2),w(4),z(4)
	DOUBLE PRECISION alpha,alph1,xpi(ns),dpipj(ns,ns),piDpj(ns,ns),
     +		sdel2i(3)
*
*	local variables:
*
	DOUBLE PRECISION s(8),sum,fac,xmax
	integer i
*
*	common blocks:
*
	include 'ff.h'
*  #] declarations:
*  #[ calculations:
	if ( l .eq. 1 ) then
	    if ( lwrite ) print *,'ffdwz:  warning: cannot handle',
     +			' this case dwz(',i1,j1,l,') yet'
	    ier = ier + 100
	elseif ( l .eq. 3 ) then
	    if ( (i1.eq.2 .and. j1.eq.1) .or. (i1.eq.1 .and. j1.eq.2) )
     +			then
		fac = x1/(sdel2i(2) + sdel2i(3))
		s(1) = dpipj(6,5)*z(j1)
		s(2) = -alph1*xpi(5)*z(j1+2)
		if ( max(abs(dpipj(2,1)),abs(dpipj(5,6))) .lt.
     +		     max(abs(dpipj(2,6)),abs(dpipj(5,1))) ) then
		    s(3) = x05*dpipj(2,1)
		    s(4) = x05*dpipj(5,6)
		else
		    s(3) = x05*dpipj(2,6)
		    s(4) = x05*dpipj(5,1)
		endif
		s(5) = piDpj(4,3)*piDpj(5,3)*fac
		s(6) = -piDpj(4,3)*piDpj(6,3)*fac
		s(7) = xpi(3)*dpipj(5,6)*fac
		if ( i1 .eq. 1 ) then
		    sum = s(1)+s(2)+s(3)+s(4) - (s(5)+s(6)+s(7))
		else
		    sum = s(1)+s(2)+s(3)+s(4) + s(5)+s(6)+s(7)
		endif
		xmax = abs(s(1))
		do 10 i=2,7
		    xmax = max(xmax,abs(s(i)))
   10		continue
		if ( abs(sum) .lt. xloss*xmax ) then
*		    this result is not used if it is not accurate (see
*		    ffxc0p)
		    if ( lwrite ) then
			call ffwarn(79,ier,sum,xmax)
		    else
			ier = ier + 1
		    endif
		    xmax = xmax/abs(alpha*xpi(5))
*		    if ( xmax .lt. min(abs(z(j1)),abs(z(j1+2))) ) then
			if (lwrite) print *,'  dwz(',i1,j1,l,')  = ',
     +				dwz(i1,j1),min(abs(z(j1)),abs(z(j1+2)))
			dwz(i1,j1) = sum/(alpha*xpi(5))
			if (lwrite) print *,'  dwz(',i1,j1,l,')+ = ',
     +					dwz(i1,j1),xmax/(alpha*xpi(5))
*		    endif
		else
		    if (lwrite) print *,'  dwz(',i1,j1,l,')  = ',
     +							dwz(i1,j1)
		    dwz(i1,j1) = sum/(alpha*xpi(5))
		    if (lwrite) print *,'  dwz(',i1,j1,l,')+ = ',
     +							dwz(i1,j1)
		endif
	    else
		if ( lwrite ) print *,'ffdwz:  warning: cannot handle',
     +			' this case dwz(',i1,j1,l,') yet'
		ier = ier + 100
	    endif
	endif
*  #] calculations:
*  #[ test output:
	if ( ltest .and. ier .eq. 0 ) then
	    if ( xloss*abs(dwz(i1,j1)-w(i1)+z(j1)) .gt. precx*max(
     +		abs(dwz(i1,j1)),abs(w(i1)),abs(z(j1))) ) print *,
     +		'ffdwz:  error: dwz(',i1,j1,l,') <> w - z :',
     +		dwz(i1,j1),w(i1),z(j1),dwz(i1,j1)-w(i1)+z(j1)
	    if ( xloss*abs(dwz(i1,j1)+w(i1+2)-z(j1+2)) .gt. precx*max(
     +		abs(dwz(i1,j1)),abs(w(i1+2)),abs(z(j1+2))) ) print *,
     +		'ffdwz:  error: dwz(',i1,j1,l,') <> z1 - w1 :',
     +		dwz(i1,j1),z(i1+2),w(j1+2),dwz(i1,j1)+w(i1+2)-z(j1+2)
	    endif
*  #] test output:
*###] ffdwz:
	end
*###[ NPOIN:
	subroutine NPOIN(npoint)
***#[*comment:***********************************************************
*									*
*	entry point to the AA and FF routines compatible with Veltman's	*
*	NPOIN for FormF.						*
*									*
*	Input:	npoin	integer		specifies which function	*
*		DEL	real		infinity			*
*		PX(1-6)	real		momenta squared (Pauli metric)	*
*		RM(2-4)	real		masses squared			*
*									*
*	Output:	B0,B0PM,B1,B1PM,B2	complex		if npoint=2	*
*		C0,C1,C2,C3		complex		if npoint=3	*
*		D0,D1,D2,D3,D4		complex		if npoint=4	*
*		(all in blank common)					*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	integer npoint
*
*	local variables
*
	integer init,i,l2,l3,l4,ier
	DOUBLE PRECISION xmu,xpc(6),xpd(13)
	DOUBLE COMPLEX cab(2),cbi(4),acbi(2),cac(3),cbc(12),cci(13),
     +		cbd(12),ccd(28),cdi(24)
	save init,l2,l3,l4
*
*	common blocks
*
	DOUBLE COMPLEX B0,B0PM,B1,B1PM,B2,CC0,CC1,CC2,CC3,D0,D1,D2,D3,D4
	DOUBLE PRECISION PX(6),RM(4),DEL
	common /blank/ 
     +          B0,B0PM,B1,B1PM,B2(2),CC0,CC1(2),CC2(4),CC3(6),
     +          D0,D1(3),D2(7),D3(13),D4(22),
     +          PX,RM,DEL
	include 'ff.h'
	include 'aa.h'
*
*	data
*
	data xmu /0.D0/
	data l2,l3,l4 /2,3,3/
	data init /0/
*  #] declarations:
*  #[ initialisations:
	if ( init.eq.0 ) then
	    init = 1
	    do 10 i=1,22
		D4(i) = 0
   10	    continue
	    print *,'NPOIN: warning: D4 is not yet supported'
	    print *,'NPOIN: warning: B1'' seems also not yet supported'
	    call ffinit
	endif
	ier = 0
	nevent = nevent + 1
*  #] initialisations:
*  #[ 2point:
	if ( npoint.eq.2 ) then
	    aderiv = .TRUE.
	    call aaxbx(cab,cbi,acbi,del,xmu,-PX(1),RM(1),RM(2),l2,ier)
      	    B0     = cipi2*cbi(1)
      	    B1     = cipi2*cbi(2)
      	    B2(1)  = cipi2*cbi(3)
      	    B2(2)  =-cipi2*cbi(4)
	    B0PM   = cipi2*acbi(1)
	    B1PM   = cipi2*acbi(2)
*  #] 2point:
*  #[ 3point:
	elseif ( npoint.eq.3 ) then
	    xpc(1) = RM(1)
	    xpc(2) = RM(2)
  	    xpc(3) = RM(3)
 	    xpc(4) =-PX(1)
  	    xpc(5) =-PX(2)
  	    xpc(6) =-PX(5)
  	    call aaxcx(cac,cbc,cci,del,xmu,xpc,l3,ier)
  	    CC0     =-cipi2*cci(1)
  	    CC1(1)  =-cipi2*cci(2)
  	    CC1(2)  =-cipi2*cci(3)
  	    CC2(1)  =-cipi2*cci(4)
  	    CC2(2)  =-cipi2*cci(5)
  	    CC2(3)  =-cipi2*cci(6)
  	    CC2(4)  =+cipi2*cci(7)
  	    CC3(1)  =-cipi2*cci(8)
  	    CC3(2)  =-cipi2*cci(9)
  	    CC3(3)  =-cipi2*cci(10)
  	    CC3(4)  =-cipi2*cci(11)
  	    CC3(5)  =+cipi2*cci(12)
  	    CC3(6)  =+cipi2*cci(13)
*  #] 3point:
*  #[ 4point:
	elseif ( npoint.eq.4 ) then
	    xpd(1) = RM(1)
	    xpd(2) = RM(2)
	    xpd(3) = RM(3)
	    xpd(4) = RM(4)
	    xpd(5) =-PX(1)
	    xpd(6) =-PX(2)
	    xpd(7) =-PX(3)
	    xpd(8) =-PX(4)
	    xpd(9) =-PX(5)
	    xpd(10)=-PX(6)
	    xpd(11)= 0.D0
	    xpd(12)= 0.D0
	    xpd(13)= 0.D0
	    call aaxdx(cbd,ccd,cdi,del,xmu,xpd,l4,ier)
	    D0     = cipi2*cdi(1)
	    D1(1)  = cipi2*cdi(2)
	    D1(2)  = cipi2*cdi(3)
	    D1(3)  = cipi2*cdi(4)
	    D2(1)  = cipi2*cdi(5)
	    D2(2)  = cipi2*cdi(6)
	    D2(3)  = cipi2*cdi(7)
	    D2(4)  = cipi2*cdi(8)
	    D2(5)  = cipi2*cdi(9)
	    D2(6)  = cipi2*cdi(10)
	    D2(7)  =-cipi2*cdi(11)
	    D3(1)  = cipi2*cdi(12)
	    D3(2)  = cipi2*cdi(13)
	    D3(3)  = cipi2*cdi(14)
	    D3(4)  = cipi2*cdi(15)
	    D3(5)  = cipi2*cdi(16)
	    D3(6)  = cipi2*cdi(17)
	    D3(7)  = cipi2*cdi(18)
	    D3(8)  = cipi2*cdi(19)
	    D3(9)  = cipi2*cdi(20)
	    D3(10) = cipi2*cdi(21)
	    D3(11) =-cipi2*cdi(22)
	    D3(12) =-cipi2*cdi(23)
	    D3(13) =-cipi2*cdi(24)
*  #] 4point:
*  #[ finish:
	else
	    print *,'NPOIN: error: npoint should be 2,3 or 4; not ',
     +	    	npoint
	    stop
	endif
	if ( ier .gt. 10 ) then
	    print *,'NPOIN: warning: more than 10 digits lost: ',ier
	    print *,'npoint = ',npoint
	    print *,'RM = ',RM
	    print *,'PX = ',PX
	    if ( ltest ) call ffwarn(998,ier,x0,x0)
	endif
*  #] finish:
*###] NPOIN:
      	end
*###[ AA0:
	DOUBLE COMPLEX function AA0(XM,DEL)
***#[*comment:***********************************************************
*									*
*	provides an interface to FF compatible with FormF by M. Veltman	*
*									*
*	Input:	XM	real		mass				*
*		DEL	real		infinity			*
*									*
*	Output:	A0	complex						*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE PRECISION XM,DEL
*
*	my variables
*
	DOUBLE COMPLEX ca0
	integer ier,init
	save init
*
*	common blocks
*
	include 'ff.h'
*
*	data
*
	data init /0/
*  #] declarations:
*  #[ initialisations:
	if ( init .eq. 0 ) then
	    init = 1
	    call ffinit
	endif
*  #] initialisations:
*  #[ calculations:
	nevent = nevent + 1
	ier = 0
	call ffxa0(ca0,DEL,x0,XM,ier)
	AA0 = -ca0*cipi2
*  #] calculations:
*###] AA0: 
	end
*###[ ALIJ:
	DOUBLE PRECISION function ALIJ(P22,P12,P1P2,P20,P10,DELE,PM2)
	DOUBLE PRECISION P22,P12,P1P2,P20,P10,DELE,PM2
	print *,'ALIJ: error: not implemented'
*	stupid fort!
	ALIJ = 0
	stop
*###] ALIJ: 
	end
*###[ SPENCE:
	DOUBLE COMPLEX function SPENCE(z)
***#[*comment:***********************************************************
*									*
*	Interface to the FF dilogarithms compatible with the FormF 	*
*	SPENCE function.  All error propagation is lost and the terms	*
*	pi^2/12 are added.						*
*									*
*	Input:	z	complex		cannot lie on the real axis for	*
*					Re(z)>1				*
*	Output:	SPENCE	complex		Sp(z) = Li2(z) = \sum z^n/n^2	*
*					= \int_0^z log(1-x)/x dx	*
*	Calls: 	ffzzdl							*
*									*
***#]*comment:***********************************************************
*  #[ declarations:
	implicit none
*
*	arguments
*
	DOUBLE COMPLEX z
*
*	local variables
*
	integer init,ipi12,ier
	DOUBLE COMPLEX zdilog,zdum
	save init
*
*	common blocks
*
	include 'ff.h'
*
*  #] declarations:
*  #[ initialisations:
	data init /0/
	if ( init .eq. 0 ) then
	    init = 1
	    call ffinit
	endif
*  #] initialisations:
*  #[ work:
	ier = 0
	call ffzzdl(zdilog,ipi12,zdum,z,ier)
	SPENCE = zdilog + ipi12*pi12
*  #] work:
*###] SPENCE: 
	end
      SUBROUTINE betar(alfinv,wtborn,svar,amel,nphot,sphot,wtset)
!     *****************************************************************
! This routine defines weights for ISR QED matrix element up to O(alf3)
! to be implemented on top of basic distribution from karlud    
!     ***************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z) 
      PARAMETER( pi=3.1415926535897932d0)
      DIMENSION sphot(100,4),wtset(100)
      SAVE 

      DIMENSION bt10(100),bt11(100)
      DIMENSION bt20(100,100),bt21(100,100)
! ------------------ Inline functions ------------------
! Elements of single bremss. distribution
      chi(x)= (1d0+(1d0-x)**2)/2d0
      xni(x)= x*(-1+x/2d0 )
!
      DO i = 1,100
        wtset(i) = 0d0
      ENDDO
      IF (wtborn.EQ.0d0) RETURN

      beta00=0d0
      beta01=0d0
      beta02=0d0
      beta03=0d0

      beta10=0d0
      beta11=0d0
      beta12=0d0

      beta20=0d0
      beta21=0d0

      beta30=0d0

      gami=  2d0/alfinv/pi*(dlog(svar/amel**2)-1) 
!-- beta0
      beta00 = 1d0
      beta01 = 1d0 + gami/2d0     
      beta02 = 1d0 + gami/2d0 + gami**2/8d0 
      beta03 = 1d0 + gami/2d0 + gami**2/8d0 +gami**3/48d0

!-- beta1
!-- Contributions from beta1 
      ene=sqrt(svar/4d0)
      DO  jph=1,nphot
      CALL d_isr1(ene,gami,sphot,jph,dis10,dis11,dis12)
         vv=sphot(jph,4)/ene
         zz=1-vv
*     O(alf1) tree
         bt10(jph) = dis10 -beta00
         beta10 = beta10 +bt10(jph)
*     O(alf2) one loop
         bt11(jph) = dis11 -beta01
         beta11 = beta11 +bt11(jph)
*     O(alf3) two loop
         bt12   = dis12 -beta02
         beta12 = beta12 +bt12
      ENDDO

!-- beta2
      DO j2=2,nphot
         DO j1=1,j2-1
            dis20 = 0d0         !initialization
            dis21 = 0d0         !initialization
            CALL d_isr2(ene,gami,sphot,j1,j2,dis20,dis21)
            CALL d_isr2(ene,gami,sphot,j2,j1,dis20,dis21)
* O(alf2) Tree level
            bt20(j1,j2)  = dis20 -bt10(j1) -bt10(j2) -beta00
            beta20 = beta20 +bt20(j1,j2)  
* O(alf3) One loop level
            bt21(j1,j2)  = dis21 -bt11(j1) -bt11(j2) -beta01
            beta21 = beta21 +bt21(j1,j2)  
         ENDDO
      ENDDO

!-- beta3
* O(alf3) Tree level
         DO j3 = 3,nphot
            DO j2 = 2,j3-1
               DO j1 = 1,j2-1
                  dis30 = 0d0   !initialization
*     Sum over 6 fragmentation trees
                  CALL d_isr3(ene,gami,sphot,j1,j2,j3,dis30)
                  CALL d_isr3(ene,gami,sphot,j2,j1,j3,dis30)
                  CALL d_isr3(ene,gami,sphot,j1,j3,j2,dis30)
                  CALL d_isr3(ene,gami,sphot,j2,j3,j1,dis30)
                  CALL d_isr3(ene,gami,sphot,j3,j1,j2,dis30)
                  CALL d_isr3(ene,gami,sphot,j3,j2,j1,dis30)
                  bt30 = dis30
     $                 -beta00
     $                 -bt10(j1) -bt10(j2) -bt10(j3)
     $                 -bt20(j1,j2) -bt20(j1,j3) -bt20(j2,j3)
                  beta30 = beta30+bt30
               ENDDO
         ENDDO
      ENDDO

      wtx0=beta00
      wtx1=beta01 +beta10
      wtx2=beta02 +beta11 + beta20
      wtx3=beta03 +beta12 + beta21+ beta30
* Totals
      wtset(1) =wtborn*wtx0
      wtset(2) =wtborn*wtx1
      wtset(3) =wtborn*wtx2
      wtset(4) =wtborn*wtx3
* Betas
      wtset(10)=wtborn*beta00 !   O(alf0)
      wtset(11)=wtborn*beta01 !   O(alf1)
      wtset(12)=wtborn*beta10 !   O(alf1)
      wtset(13)=wtborn*beta02 ! O(alf2)
      wtset(14)=wtborn*beta11 ! O(alf2)
      wtset(15)=wtborn*beta20 ! O(alf2)
      wtset(16)=wtborn*beta03 !   O(alf3)
      wtset(17)=wtborn*beta12 !   O(alf3)
      wtset(18)=wtborn*beta21 !   O(alf3)
      wtset(19)=wtborn*beta30 !   O(alf3)

      END

      SUBROUTINE d_isr1(ene,gami,sphot,j1,dis10,dis11,dis12)
*     ******************************************************
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION sphot(100,4)
* inline functions
      chi2(a,b)=  0.5d0*   ((1d0-a)**2+(1d0-b)**2)
*
      a1 = (sphot(j1,4)-sphot(j1,3))/ene/2d0
      b1 = (sphot(j1,4)+sphot(j1,3))/ene/2d0
      zz = (1d0-a1)*(1d0-b1)
      IF(zz  .LE. 0d0) WRITE(*,*) '!!!! zz=',zz
      dels1 =  gami/2d0 -gami/4d0*dlog(zz)
      dels2 =  gami**2/8d0
     $        -gami**2/8d0  *dlog(zz)
     $        +gami**2/24d0 *dlog(zz)**2
* Exact O(alf1) matrix element for the hardest photon jhard
      dis10  = chi2(a1,b1)
      dis11  = dis10*(1+dels1)
      dis12  = dis10*(1+dels1+dels2)
      END


      SUBROUTINE d_isr2(ene,gami,sphot,j1,j2,dis20,dis21)
*     **************************************************
* dis20,dis21 has to be initialized in the calling program
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION sphot(100,4)
* inline functions
      chi2(a,b)=  0.5d0* ((1d0-a)**2+(1d0-b)**2)
*
      ntree = 2                 ! for 2 ISR fragmentation trees
      y1 = (sphot(j1,4)-sphot(j1,3))/ene/2d0
      z1 = (sphot(j1,4)+sphot(j1,3))/ene/2d0
      y2 = (sphot(j2,4)-sphot(j2,3))/ene/2d0
      z2 = (sphot(j2,4)+sphot(j2,3))/ene/2d0
      a1 = y1
      b1 = z1
      a2 = y2/(1d0-y1)
      b2 = z2/(1d0-z1)
      d20 = chi2(a1,b1)*chi2(a2,b2)/ntree
      zz1 =  (1-y1)*(1-z1)
      z1z2= (1-y1-y2)*(1-z1-z2)
* soft limit to d_isr1 OK! for 2 trees we get 3 terms gami/6d0*dlog(zz)
      delvir1 = gami/2d0 -gami/6d0*dlog(zz1) -gami/6d0*dlog(z1z2)
      dis20 = dis20 +d20
      dis21 = dis21 +d20*(1+delvir1)

      IF(z1  .le.0d0) WRITE(*,*) '!!!! z1=',z1
      IF(z1z2.le.0d0) WRITE(*,*) '!!!! z1z2=',z1z2

      END


      SUBROUTINE d_isr3(ene,gami,sphot,j1,j2,j3,dis30)
*     ************************************************
*     dis30 has to be initialized in the calling program
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION sphot(100,4)
* inline functions
      chi2(a,b)=  0.5d0*   ((1d0-a)**2+(1d0-b)**2)
*
      ntree = 6                 ! for 6 ISR fragmentation trees
      y1 = (sphot(j1,4)-sphot(j1,3))/ene/2d0
      z1 = (sphot(j1,4)+sphot(j1,3))/ene/2d0
      y2 = (sphot(j2,4)-sphot(j2,3))/ene/2d0
      z2 = (sphot(j2,4)+sphot(j2,3))/ene/2d0
      y3 = (sphot(j3,4)-sphot(j3,3))/ene/2d0
      z3 = (sphot(j3,4)+sphot(j3,3))/ene/2d0
      a1 = y1
      b1 = z1
      a2 = y2/(1d0-y1)
      b2 = z2/(1d0-z1)
      a3 = y3/(1d0-y2-y1)
      b3 = z3/(1d0-z2-z1)

      d30= chi2(a1,b1) *chi2(a2,b2) *chi2(a3,b3)/ntree

      dis30= dis30 +d30

      IF(a2  .GT. 1d0) WRITE(*,*) '!!!! a2=',a2
      IF(b2  .GT. 1d0) WRITE(*,*) '!!!! b2=',b2
      IF(a3  .GT. 1d0) WRITE(*,*) '!!!! a3=',a3
      IF(b3  .GT. 1d0) WRITE(*,*) '!!!! b3=',b3

      END

**************************************************************
! !!!! OBSOLETE !!!!! !!!! OBSOLETE !!!!! !!!! OBSOLETE !!!!
! !!!! OBSOLETE !!!!! !!!! OBSOLETE !!!!! !!!! OBSOLETE !!!!
**************************************************************
      SUBROUTINE betax(alfinv,wtborn,svar,amel,nphot,sphot,wtset)
!     *****************************************************************
! O(alf2)LL weights for the beta0, beta1 and beta2,
! to be implemented on top of basic distribution from karlud    
!     ***************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      PARAMETER( pi=3.1415926535897932d0)
      DIMENSION sphot(100,4),wtset(100)
      SAVE 
! ------------------ Inline functions ------------------
! Elements of single bremss. distribution
      chi(x)= (1d0+(1d0-x)**2)/2d0
      xni(x)= x*(-1+x/2d0 )

      beta00=0d0
      beta01=0d0
      beta02=0d0
      beta10=0d0
      beta11=0d0
      beta20=0d0

      gami=  2d0/alfinv/pi*(dlog(svar/amel**2)-1) 
!-- beta0
      beta00 = 1d0
      beta01 = 1d0 + gami/2d0     
      beta02 = 1d0 + gami/2d0 + gami**2/8d0 

!-- beta1
!-- Contributions from beta1            
      ene=sqrt(svar/4d0)    
      DO  jph=1,nphot 
         vv=sphot(jph,4)/ene            
         b10 = xni(vv)
         b11 = xni(vv)*(1d0 +gami/2d0)
     $        -chi(vv)*(gami/4d0)*dlog(1d0-vv)
         beta10  =  beta10 +b10             
         beta11  =  beta11 +b11             
      ENDDO

!-- beta2
      DO i=1,nphot
         DO j=i+1,nphot
            v1=sphot(i,4)/ene
            v2=sphot(j,4)/ene
            v1st = v1/(1-v2)
            v2st = v2/(1-v1)
            IF ( sphot(i,3)*sphot(j,3) .LT. 0d0) THEN
!           OPPOSITE directions two photons
               dis2= chi(v1)*chi(v2)
            ELSE
!           SAME directions two photons
               dis2= 0.5d0*( chi(v1)*chi(v2st) + chi(v1st)*chi(v2) )
            ENDIF
            beta1i = xni(v1)
            beta1j = xni(v2)
            bt20  = dis2 -beta1i -beta1j -beta00
            beta20 = beta20 +bt20  
         ENDDO
      ENDDO

      wtx0=beta00
      wtx1=beta01 +beta10
      wtx2=beta02 +beta11 + beta20
* Totals OLD version
      wtset(5) =wtborn*wtx0
      wtset(6) =wtborn*wtx1
      wtset(7) =wtborn*wtx2

      END

*====================== BORN ==========================
      FUNCTION WWBoME(ep1,ep2,ep3,ep4)
*     ********************************
! ep-i are 4momenta of produced fermions in cms-eff
! this routine converts massive 4-vects into massless ones 
! and calls the massless WWBoml
! Taken from KoralW and adapted to YFSWW3 by W. Placzek
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DIMENSION ep1(4),ep2(4),ep3(4),ep4(4)
      DIMENSION boq1(4),boq2(4),bop1(4),bop2(4),bop3(4),bop4(4)
      DIMENSION amdec0(4)
      DIMENSION qeff1(4),qeff2(4)
      DIMENSION bq1(4),bq2(4)
!
      DO i=1,4
        bq1(i)=ep1(i)+ep2(i)
        bq2(i)=ep3(i)+ep4(i)
      ENDDO
!.. make decay products massless
!.. sophisticated fermion mass reduction to 0
!.. re-construct angles
      CALL ww_invkin(costhe,phi,cosde1,phi1,cosde2,phi2,
     $               amwmn,amwpn,  ep1,ep2,ep3,ep4)
!.. make sure it is OK
      qq = DSQRT(bq1(1)**2+bq1(2)**2+bq1(3)**2)
      ctn = bq1(3)/qq
      IF(abs(ctn/costhe-1) .GT. 1d-14) THEN
         WRITE(6,*)'cosinusy ',ctn/costhe
      ENDIF
      sprim = (bq1(4)+bq2(4))**2          
      DO i=1,4
         amdec0(i)=0d0
      ENDDO
!.. build again 4-vects with 0 masses
      CALL ww_kineww(sprim,costhe,phi,cosde1,phi1,cosde2,phi2,
     $        amwmn,amwpn,amdec0,boq1,boq2,bop1,bop2,bop3,bop4)

c      print*,' bop1=',bop1
c      print*,' bop2=',bop2

      WWBoME = WWBoml(bop1,bop2,bop3,bop4)
      END 

      FUNCTION WWBoml(bp1,bp2,bp3,bp4)
*     ********************************
! This function provides a value of a differential born cross section
! for W+W- pair production and decay in e+e- scattering. 
! Written by: Wieslaw Placzek            date: 20.07.1994
!
! MODIFIED by: Maciej Skrzypek           
! WWBoml is massless strictly speaking, but it works for massive 
! 4vects as well and the buffor routine wwborn_massive is in fact
! redundant, m.s. 
!
! ADAPTED to YFSWW3 by W. Placzek
! Last update: 29.09.1999                by: W.P.
!----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / INOUT  / NINP,NOUT   
      COMMON / matpar / pi,ceuler     
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf 
      COMMON / wekin2 / amaw,gammw,gmu,alphaw   
! This common can be everywhere, contains various switches
      COMMON / KeyKey/  KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
!  br - for normalization
      COMMON / decdat / amafin(20), br(20)
      COMMON / DeChan / IchaWm,IchaWp
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
      SAVE   / WWINVM /
! polarization amplitudes for WW production for left and right 
! handed electrons
      DOUBLE COMPLEX awwel(3,3),awwer(3,3)
! polarization amplitudes for W-decays
      DOUBLE COMPLEX adwm(3),adwp(3)
! auxilliary
      DOUBLE COMPLEX amwwr, amwwl,BWEXA1,BWEXA2
      DIMENSION bq1(4),bq2(4),bp1(4),bp2(4),bp3(4),bp4(4)
      SAVE   / weking /,/ wekin2 /,/ matpar /,/ INOUT  /
      SAVE   / decdat /,/ keykey /,/ DeChan /
      SAVE
!
      KeySpn = MOD(KeyPhy,10000)/1000
      KeyAcc = MOD(KeyMis,1000)/100
      KeyWu  = MOD(KeyPhy,1000000)/100000
      DO i=1,4
        bq1(i)=bp1(i)+bp2(i)
        bq2(i)=bp3(i)+bp4(i)
      ENDDO
!.. CMS-eff mass
      sprim=(bp1(4)+bp2(4)+bp3(4)+bp4(4))**2
!.. resonance masses
      sx1=dmas2(bq1)
      sx2=dmas2(bq2)
!.. cos(theta)
      qq=dsqrt(bq1(1)**2+bq1(2)**2+bq1(3)**2)
      costhe=bq1(3)/qq
!! here was a bug A. Vallasi 30.06.96
!ms      wlambd=abs(sprim**2+sx1**2+sx2**2-2*sprim*sx1-2*sprim*sx2-2*sx1*sx2)
      wlambd=max(0d0,abs((sprim-sx1-sx2)**2 -4*sx1*sx2))
!ms      tvar=-(sprim-sx1-sx2-dsqrt(wlambd)*costhe)/2
      tvar=-1d0/2d0*(dsqrt(wlambd)*(1d0-costhe)
     $              +4d0*sx1*sx2/(sprim-sx1-sx2+dsqrt(wlambd)) ) 
!... Amplitudes for WW production
      IF(KeyAcc.EQ.0) THEN 
        CALL WWprod(sprim,tvar,bq1,bq2,awwel,awwer) 
      ELSE
        CALL WWamgc(sprim,tvar,bq1,bq2,awwel,awwer) 
      ENDIF
!... Amplitudes for W-decays
      CALL Wdecay(bq1,bp1,bp2,adwm)  
      CALL Wdecay(bq2,bp3,bp4,adwp) 
!... Exact W-propagators:
      IF(KeyWu.EQ.0) THEN
        BWEXA1=1D0/dcmplx((S1-AMAW**2),(S1/AMAW*GAMMW))
        BWEXA2=1D0/dcmplx((S2-AMAW**2),(S2/AMAW*GAMMW))
      ELSEIF(KeyWu.EQ.1) THEN
        BWEXA1=1D0/dcmplx((S1-AMAW**2),(AMAW*GAMMW))
        BWEXA2=1D0/dcmplx((S2-AMAW**2),(AMAW*GAMMW))
      ELSEIF(KeyWu.EQ.2) THEN
        BWEXA1=1D0/dcmplx((S1-AMAW**2),0D0)
        BWEXA2=1D0/dcmplx((S2-AMAW**2),0D0)
      ELSE
        WRITE(6,*)'WWBORN==> Wrong KeyWu=',keywu
        STOP
      ENDIF
!... Polarization amplitudes for WW production and decay
      IF (KeySpn.EQ.0) THEN
        xmatr=0
        DO l2 = 1,3
           DO l1 = 1,3
              amwwl=awwel(l1,l2)*adwm(l1)*adwp(l2)*BWEXA1*BWEXA2 !ms,zw
              amwwr=awwer(l1,l2)*adwm(l1)*adwp(l2)*BWEXA1*BWEXA2 !ms,zw
              xmatr=xmatr + amwwl*dconjg(amwwl) !ms
              xmatr=xmatr + amwwr*dconjg(amwwr) !ms
           ENDDO
        ENDDO
      ELSEIF (KeySpn.EQ.1) THEN
        xmatr=0
        amwwl=(0,0)
        amwwr=(0,0)
        DO l2=1,3
           DO l1=1,3
              amwwl=amwwl+awwel(l1,l2)*adwm(l1)*adwp(l2)*BWEXA1*BWEXA2 !ms,zw
              amwwr=amwwr+awwer(l1,l2)*adwm(l1)*adwp(l2)*BWEXA1*BWEXA2 !ms,zw
           ENDDO
        ENDDO
        xmatr=xmatr + amwwl*dconjg(amwwl) !ms
        xmatr=xmatr + amwwr*dconjg(amwwr) !ms
      endif
      fkin = 1d0
! Universal "BR" used in matrix element calculation
      brel = alphaw*amaw/(12*sinw2*gammw)
! Normalization to branching ratios (various WW channels)
      dfwmwp = br(IchaWm)*br(IchaWp)/brel**2
! Normalized cross section
      WWBoml = fkin/4*dfwmwp*xmatr
      END

      SUBROUTINE WWprod(s,t,q1,q2,awwel,awwer)
*     ****************************************
!----------------------------------------------------------------------!
! This routine calculates polarization amplitudes for the process      !
! e+e- --> W+W-, for on-shell W's in Born approximation. Calculation   !
! is done in the CMS of e+e- with z-axis pointing along e- direction.  !
! It is based on the paper:                                            !
! K. Kolodziej and M. Zralek, Phys. Rev. D43 (1991) 43;                !
! INPUT: s   - center mass energy squared (in GeV**2)                  !
!        t   - transfer (in GeV**2)                                    !
!        q1(4) - four-momentum of W-                                   !
!        q2(4) - four-momentum of W+                                   !
! OUTPUT: awwel(3,3) - complex array containing polarization amplitudes!
!                     for left-handed electron                         !
!                     {M_0(-,+,l1,l2) in eq. (31)}                     !
!         awwer(3,3) - complex array containing polarization amplitudes!
!                     for right-handed electron                        !
!                     {M_0(+,-,l1,l2) in eq. (31)}                     !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek            date: 01.07.1994              !
! Last update: 16.08.1999                by: W.P.                      !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION q1(4),q2(4)
      DOUBLE COMPLEX awwel(3,3),awwer(3,3)
      COMMON / matpar / pi,ceuler     
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf 
      COMMON / wekin2 / amaw,gammw,gmu,alphaw   
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE   / matpar /,/ weking /,/ wekin2 /,/ KeyKey /
! polarization vectors of W-bosons, eq. (9)
      DOUBLE PRECISION eps1(4,3),eps2(4,3)
      DOUBLE PRECISION e1(4),e2(4),p1(4),pmq(4)
      DOUBLE COMPLEX f1e1,f1e2,f1q2,fKZ3,prinZ
      DATA init /0/
      SAVE init,zetl,etal,etar
!
! Initialization
!--------------------------------------------------------------------- 
      IF (init.EQ.0) THEN
        init = 1 
        KeyZet = MOD(KeyPhy,1000)/100
! Electroweak coefficient factors, eq. (30)
        zetl = 0.5d0/sinw2
        etal = 1-zetl
        etar = 1d0
      ENDIF  
! Calculation
!=====================================================================
! Z-propagator (inverse)
      IF (KeyZet.EQ.0) THEN
        prinZ = DCMPLX(s-amaz**2,s/amaz*gammz)
      ELSEIF (KeyZet.EQ.1) THEN
        prinZ = DCMPLX(s-amaz**2,amaz*gammz)
      ELSE
        prinZ = DCMPLX(s-amaz**2,0d0)
      ENDIF
! Four-momentum of the incoming electron in CMS 
! (+z axis along the electron beam)
      ecm = DSQRT(s)   
      p1(1) = 0d0
      p1(2) = 0d0
      p1(3) = ecm/2d0
      p1(4) = p1(3)
! Calculation of polarization vectors of W-bosons, eq. (9)
      CALL VecPol(q1,eps1)
      CALL VecPol(q2,eps2)
! Calculation of the polarization amplitudes, eq. (31)
! {note: we use different normalization!}
      wsp =-4*pi*alphaw*ecm
      DO k = 1,4
        pmq(k) = p1(k) - q1(k)
      ENDDO
      DO l2 = 1,3
        DO l1 = 1,3
          DO k = 1,4
            e1(k) = eps1(k,l1)
            e2(k) = eps2(k,l2)
          ENDDO
          f1e1 = DCMPLX(e1(1),-e1(2))
          f1e2 = DCMPLX(e2(1),-e2(2))
          f1q2 = DCMPLX(q2(1),-q2(2))
          e1e2 = ProdM(e1,e2)
          e1q2 = ProdM(e1,q2)
          e2q1 = ProdM(e2,q1) 
          awwel(l1,l2) = ( 2*(1/s - etal/prinZ)
     &                      *(e1q2*f1e2 - e1e2*f1q2 - e2q1*f1e1)  
     &                   + zetl/t*fKZ3(e2,pmq,e1) ) *wsp   
          awwer(l1,l2) = -2*( 1/s - etar/prinZ )
     &                     *( e1q2*CONJG(f1e2) - e1e2*CONJG(f1q2) 
     &                      - e2q1*CONJG(f1e1) ) *wsp
        ENDDO
      ENDDO
      END  

      FUNCTION ProdM(p,q)
*     *******************
!----------------------------------------------------------------------!
! Scalar product of the four-vectors p and q in Minkowski space.       !
! Note: p(4)=p^0, q(4)=q^0                                             !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek              June 1994                   !
! Last update: 31.07.1996                by: W.P.                      !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION p(4),q(4)
      ProdM = p(4)*q(4) - p(3)*q(3) - p(2)*q(2) - p(1)*q(1)
      END

      FUNCTION fKZ3(a,b,c)
*     ********************
!----------------------------------------------------------------------!
! Function F_3 of four-vectors contracted with Dirac matrices;         !
! see eq. (19)                                                         !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek            date: 01.07.1994              !
! Last update: 31.07.1996                by: W.P.                      !
!----------------------------------------------------------------------!
      DOUBLE PRECISION a(4),b(4),c(4)
      DOUBLE COMPLEX fKZ3
      fKZ3 =  (a(4) + a(3)) * ( (b(4) - b(3))*DCMPLX(c(1),-c(2)) 
     &                        - DCMPLX(b(1),-b(2))*(c(4) - c(3)) ) 
     & + DCMPLX(a(1),-a(2)) * ( (b(4) + b(3))*(c(4) - c(3)) 
     &                        - DCMPLX(b(1), b(2))*DCMPLX(c(1),-c(2)) )
      END        

      SUBROUTINE Wdecay(q,p1,p2,adw)
*     ******************************
!----------------------------------------------------------------------!
! This routine calculates polarization amplitudes for W decays         !
! into massless fermions. It is based on the paper:                    !
! K. Hagiwara et al., Nucl. Phys. B282 (1987) 253; see Appendix C.     !
! No CKM-mixing matrix elements incuded here.                          !
! INPUT: q(4)        - four-momentum of W                              !
!        p1(4),p2(4) - four-momenta of decay products                  !
! OUTPUT: adw(3) - complex array containing W decay amplitudes         !
!                   {M(lambda,sigma_1,sigma_2) in eq. (C.16)}          !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek            date: 20.07.1994              !
! Last update: 31.07.1996                by: W.P.                      !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION q(4),p1(4),p2(4)
      DOUBLE COMPLEX adw(3)
      COMMON / matpar / pi,ceuler     
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf 
      COMMON / wekin2 / amaw,gammw,gmu,alphaw   
      SAVE   / matpar /,/ weking /,/ wekin2 /
      DOUBLE PRECISION eps(4,3),e(4)
      DOUBLE COMPLEX SfunHZ
!
! Calculation of polarization vectors of W in rectangular basis
      CALL VecPol(q,eps)
! Calculation of the W-decay amplitudes
      wsp = SQRT(4*pi*alphaw/(2*sinw2) )
      DO l = 1,3
        DO k = 1,4
          e(k) = eps(k,l)
        ENDDO
        adw(l)= wsp * 2*SQRT(p1(4)*p2(4)) *SfunHZ(p1,e,p2)
      ENDDO   
      END

      FUNCTION SfunHZ(p1,a,p2)
*     ************************
!----------------------------------------------------------------------!
! Spinorial string S(pi,a,pf) for massless spinors chi(pi), chi(pf);   !
! a(4) - given four-vector,                                            !
! see K. Hagiwara et al., Nucl. Phys. B282 (1987) 253; Appendix C.     !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek            date: 20.07.1994              !
! Last update: 31.07.1996                by: W.P.                      !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION a(4),p1(4),p2(4)
      DOUBLE COMPLEX z1p,z2m,zam,zap
      DOUBLE COMPLEX SfunHZ
!
      x1p = p1(3) + p1(4)
      x2p = p2(3) + p2(4)
      z1p = DCMPLX(p1(1), p1(2))
      z2m = DCMPLX(p2(1),-p2(2))
      xam = a(4) - a(3)
      xap = a(4) + a(3)
      zam = DCMPLX(a(1),-a(2))
      zap = DCMPLX(a(1), a(2))
      IF (x1p.GT.1d-15 .and. x2p.gt.1d-15) THEN
        fac = 0.5/sqrt(p1(4)*p2(4)*x1p*x2p)
        SfunHZ = fac*( x1p*(x2p*xam-z2m*zap) + z1p*(z2m*xap-x2p*zam) )
      ELSEIF (x1p.GT.1d-15) THEN
        SfunHZ = (x1p*zap - z1p*xap)/sqrt(2*p1(4)*x1p)
      ELSEIF (x2p.GT.1d-15) THEN
        SfunHZ = (z2m*xap - x2p*zam)/sqrt(2*p2(4)*x2p)
      ELSE
        SfunHZ = xap
      ENDIF
      END

      SUBROUTINE VecPol(q,eps)
*     **************************
!----------------------------------------------------------------------!
! Calculation of polarization vectors of a vector boson in the         !
! rectangular basis, see K. Hagiwara and D. Zeppenfeld,                !
! Nucl. Phys. B274 (1986) 1, eq. (3.47).                               !
!     INPUT:  q(4)   - 4-momentum of the vector boson                  !
!     OUTPUT: eps(4,3) - three polarization 4-vector                   !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                      date: 01.07.1994    !
! Last update: 12.08.1999                          by: W.P.            !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION q(4),eps(4,3)   
!
      qt2 = q(1)**2 + q(2)**2
      qt  = SQRT(qt2)
      aq2 = qt2 + q(3)**2
      aq  = SQRT(aq2)
      am  = SQRT(ABS(q(4)**2 - aq2)) 
      DO l = 1,3
        DO k = 1,4
          eps(k,l) = 0d0
        ENDDO
      ENDDO
      IF (aq.LT.1d-10) THEN
        eps(1,1) = 1d0
        eps(2,2) = 1d0
        IF (am.GT.1d-10) eps(3,3) = 1d0
      ELSEIF (qt/aq.LT.1d-10) THEN
        eps(1,1) = q(3)/aq
        eps(2,2) = q(3)/aq
        IF (am.GT.1d-10) THEN
          eps(3,3) = q(4)/am/aq*q(3)
          eps(4,3) = aq/am
        ENDIF
      ELSE
        ws1 = 1/aq/qt
        eps(1,1) = ws1*q(1)*q(3)
        eps(2,1) = ws1*q(2)*q(3)
        eps(3,1) =-ws1*qt2
        eps(4,1) = 0d0
        ws2 = 1/qt 
        eps(1,2) =-ws2*q(2)
        eps(2,2) = ws2*q(1)
        eps(3,2) = 0
        eps(4,2) = 0
        IF (am.GT.1d-10) THEN
          ws3 = q(4)/am/aq 
          eps(1,3) = ws3*q(1)
          eps(2,3) = ws3*q(2)
          eps(3,3) = ws3*q(3)
          eps(4,3) = ws3*aq2/q(4)
        ENDIF
      ENDIF  
      END

!======================================================================
!============= Born Version with Anomalous Couplings ==================
!======================================================================

      SUBROUTINE WWamgc(s,t,q1,q2,awwel,awwer)
*     ****************************************
!----------------------------------------------------------------------!
! This routine calculates polarization amplitudes for the process:     !
!              e-(p1) e+(p2) ---> W-(q1) W+(q2)                        !
! Calculation  is done in the CMS of e+e- with z-axis pointing along   !
! the e- direction. These amplitudes include general type three boson  !
! coupling constant as given in the paper:                             !
!     K. Hagiwara, R.D. Peccei, D. Zeppenfeld and K. Hikasa,           !
!                 Nucl. Phys. B282 (1987) 253.                         !
! The same formalism as in the subroutine wwprod (where only the SM    !
! coupling constant are included) is used here.                        !
! INPUT: s   - center mass energy squared (in GeV**2)                  !
!        t   - transfer momentum squared (in GeV**2)                   !
!        q1(4) - four-momentum of W-                                   !
!        q2(4) - four-momentum of W+                                   !
! OUTPUT: awwel(3,3) - complex array containing polarization           !
!                      amplitudes for left-handed electron,            !
!                      M_0(-,+,l1,l2);                                 !
!         awwel(3,3) - complex array containing polarization           ! 
!                      amplitudes for right-handed electron,           ! 
!                      M_0(+,-,l1,l2).                                 !
! Note: Before first use of this routine general type coupling         !
!       constant have to be set up in the routine setacc.              !
!----------------------------------------------------------------------! 
! Written by: Wieslaw Placzek                 Knoxville, November 1995 !
! Last update: 12.08.1999            by: W.P.                          !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE COMPLEX zi
      PARAMETER ( zi = (0d0,1d0) )
      DOUBLE PRECISION q1(4),q2(4)
      DOUBLE COMPLEX awwel(3,3),awwer(3,3)
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf 
      COMMON / wekin2 / amaw,gammw,gmu,alphaw 
      common / matpar / pi,ceuler  
! This common can be everywhere, contains various switches
      COMMON / KeyKey /  KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE / weking /, / wekin2 /, / KeyKey /, / matpar /
! Polarization vectors of W-bosons          
      DOUBLE PRECISION eps1(4,3),eps2(4,3)
      DOUBLE PRECISION e1(4),e2(4),p1(4),pmq(4)
! General type 3-boson coupling constants
      DOUBLE COMPLEX GamV(4,2)
      DOUBLE COMPLEX dZ,Gagm,Gagp,GaZm,GaZp,fkz3
      DATA init /0/
      SAVE init,KeyZet,zetl,etal,etar
!--------------------------------------------------------------------- 
! Initialization ...
      IF (init.eq.0) THEN
        init=1 
        KeyZet = MOD(KeyPhy,1000)/100
! Electroweak coefficient factors
        zetl=0.5/sinw2
        etal=1-zetl
        etar=1
      ENDIF  
!--------------------------------------------------------------------- 
! Calculation ...
! Options for Z-boson width
! a) running Z-width
      IF (KeyZet.eq.0) THEN
        dZ = DCMPLX(s-amaz**2,s/amaz*gammz)
! b) constant Z-width
      ELSEIF (KeyZet.eq.1) THEN
        dZ = DCMPLX(s-amaz**2,amaz*gammz)
! c) zero Z-width
      ELSEIF (KeyZet.eq.2) THEN
        dZ = s-amaz**2
      ELSE
         WRITE(6,*)'>>> Wrong KeyZet:',KeyZet
      ENDIF
! Four-momentum of the incoming electron in CMS (+z axis along e-)
      p1(1) = 0
      p1(2) = 0
      p1(3) = SQRT(s)/2
      p1(4) = p1(3)
! Calculation of W polarization vectors
      CALL VecPol(q1,eps1)
      CALL VecPol(q2,eps2)
      DO k = 1,4
        pmq(k) = p1(k) - q1(k)
      ENDDO
      wsp =-4*pi*alphaw*SQRT(s)
! Calculation of the polarization amplitudes
      DO l2 = 1,3
        DO l1 = 1,3
          DO k = 1,4
            e1(k)=eps1(k,l1)
            e2(k)=eps2(k,l2)
          ENDDO
! Calculation of the 3-boson couplings
          CALL WWVgcc(s,amaw,q1,e1,q2,e2,GamV)
! WWgamma vertex
          Gagm = GamV(1,1) - zi*GamV(2,1)
          Gagp = GamV(1,1) + zi*GamV(2,1)          
! WWZ vertex
          GaZm = GamV(1,2) - zi*GamV(2,2)
          GaZp = GamV(1,2) + zi*GamV(2,2) 
! Polarization amplitudes         
          awwel(l1,l2) = wsp*( Gagm/s - GaZm*etal/dZ 
     &                       + zetl/t *fkz3(e2,pmq,e1) )
          awwer(l1,l2) = wsp*( Gagp/s - GaZp*etar/dZ )
        ENDDO
      ENDDO
      END

      SUBROUTINE WWVgcc(s,amW,q1,eps1,q2,eps2,GamV)
*     *********************************************
!----------------------------------------------------------------------!
! This routine calculates four-vector Gamma_V^mu including general     !
! type 3-boson WWV couplings (V=gamma,Z) as defined in the paper:      !
!     K. Hagiwara, R.D. Peccei, D. Zeppenfeld and K. Hikasa,           !
!                 Nucl. Phys. B282 (1987) 253.                         !
! INPUT: s       - center mass energy squared (in GeV**2)              !
!        amW     - W-boson mass                                        !
!        q1(4)   - four-momentum of W-                                 !
!        eps1(4) - polarizarion vector of W-                           !
!        q2(4)   - four-momentum of W+                                 !
!        eps1(4) - polarizarion vector of W+                           !
! OUTPUT: GamV(4,2) - 2 complex number four-vectors Gamma_V^mu:        !
!                     GamV(4,1) for WWgamma vertex,                    !
!                     GamV(4,2) for WWZ vertex.                        !
!----------------------------------------------------------------------! 
! Written by: Wieslaw Placzek                 Knoxville, November 1995 !
! Last update: 15.11.1995            by: W.P.                          !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE COMPLEX zi
      PARAMETER ( zi = (0d0,1d0) )
      DOUBLE PRECISION q1(4),eps1(4),q2(4),eps2(4)
      DOUBLE COMPLEX GamV(4,2)
      COMMON / ancoco / g1(2),kap(2),lam(2),g4(2),g5(2),kapt(2),lamt(2)
      DOUBLE COMPLEX g1,kap,lam,g4,g5,kapt,lamt
      SAVE  / ancoco /
! 7 form factors f_i^V
      DOUBLE COMPLEX f1(2),f2(2),f3(2),f4(2),f5(2),f6(2),f7(2)
      DOUBLE PRECISION P(4),Q(4),Peps(4),Qeps(4)
!
      amW2 = amW**2
! Set up form factors
      DO i = 1,2
         f1(i) = g1(i) + s/(2*amW2) *lam(i)
         f2(i) = lam(i)
         f3(i) = g1(i) + kap(i) + lam(i)
         f4(i) = g4(i)
         f5(i) = g5(i)
         f6(i) = kapt(i) - lamt(i)
         f7(i) = -0.5*lamt(i)
      ENDDO
! Sum and difference of W's 4-momenta
      DO k = 1,4
         P(k) = q1(k) + q2(k)
         Q(k) = q1(k) - q2(k)
      ENDDO
! Scalar products of various 4-vectors
      e1e2 = prodm(eps1,eps2)
      Pe1  = prodm(P,eps1)
      Pe2  = prodm(P,eps2)
! Coefficients for f5 and f6 
      CALL epsabc(P,eps1,eps2,Peps)
      CALL epsabc(Q,eps1,eps2,Qeps)
! Coefficient for f7
      PQeps = prodm(P,Qeps)
! Calculate Gamma_V^mu
      DO i = 1,2
        DO k = 1,4
          GamV(k,i) = ( f1(i)*e1e2 - f2(i)/amW2*Pe1*Pe2 
     &                - f7(i)/amW2*PQeps )*Q(k)
     &              + (-f3(i) + zi*f4(i) )*Pe2*eps1(k)   
     &              + ( f3(i) + zi*f4(i) )*Pe1*eps2(k)   
     &              + zi*f5(i)*Qeps(k) - f6(i)*Peps(k)
        ENDDO
      ENDDO
      END

      SUBROUTINE epsabc(a,b,c,q)
*     **************************
!----------------------------------------------------------------------!
! This routine calculates four-vector q according to the formula:      !
!                                                                      !
!  q^mu = epsilon^{mu,alpha,beta,gamma} a_alpha b_beta c_gamma,        !
!                                                                      !
! where epsilon is a totally antisymmetric tensor in Bjorken & Drell   !
! convention, and a, b, c are four-vectors.                            !
!----------------------------------------------------------------------! 
! Written by: Wieslaw Placzek                 Knoxville, November 1995 !
! Last update: 16.11.1995            by: W.P.                          !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DOUBLE PRECISION a(4),b(4),c(4),q(4)
!
      b1c2 = b(1)*c(2) - b(2)*c(1)
      b1c4 = b(1)*c(4) - b(4)*c(1)
      b2c3 = b(2)*c(3) - b(3)*c(2)
      b2c4 = b(2)*c(4) - b(4)*c(2)
      b3c1 = b(3)*c(1) - b(1)*c(3)
      b3c4 = b(3)*c(4) - b(4)*c(3)
! 4-vector q^mu
      q(1) = a(2)*b3c4 - a(3)*b2c4 + a(4)*b2c3
      q(2) =-a(1)*b3c4 + a(3)*b1c4 + a(4)*b3c1
      q(3) = a(1)*b2c4 - a(2)*b1c4 + a(4)*b1c2  
      q(4) = a(1)*b2c3 + a(2)*b3c1 + a(3)*b1c2
      END



      FUNCTION WTCoul(s,s1,s2,amaW,GammW)
!     ***********************************
! Coulomb effect from Fadin, Khoze, Martin, Stirling, PLB363 (1995) 112.
! first order, eq. (9).
!----------------------------------------------------------------------------
! It comes from KORALW - modified by Wieslaw Placzek.
! * 8.11.99: Added "Screened-Coulomb" ansatz for non-factorizable corrections
!            of A.P. Chapovsky & V.A. Khoze, hep-ph/9902343
! Last corr.  08.11.1999    by: WP
!----------------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      PARAMETER ( pi = 3.1415926535897932D0)
! This common can be everywhere, contains various switches
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      COMMON / Coutra / KeyCou
      COMMON / PHYPAR / ALFINV,GPICOB  
      SAVE   / KeyKey /,/ KeyOth /,/ Coutra /,/ PHYPAR /
!
      pp = 1/(4*s) *( s**2 -2*s*(s1+s2) +(s1-s2)**2 )
      p  = SQRT(pp)
      en = (s-4*amaw**2)/(4*amaw)
      ddee = SQRT(en**2+gammw**2)
      p1 = SQRT( amaw/2d0 *( ddee -en ) )
      p2 = SQRT( amaw/2d0 *( ddee +en ) )
      dabskap2 = amaw *ddee
      drekap  =  p1
      dimkap  = -p2
      KeyCul = MOD(KeyRad,10000)/1000
      IF (KeyCul.EQ.1) THEN
! Normal Coulomb correctios
         ff = 1 + SQRT(s)/(4*p*alfinv) 
     $           *( pi -2*DATAN( (dabskap2 -pp)/(2*p*drekap) ) )   
      ELSE
! "Screened-Coulomb" ansatz for non-factorizable corrections
         beta = 2*p/SQRT(s)
         ScrFac = (1 - beta)**2
         ff = 1 + SQRT(s)/(4*p*alfinv) 
     $        *( pi - 2*DATAN( (dabskap2 -pp)/(2*p*drekap) )*ScrFac )   
      ENDIF
      IF (KeyCor.GE.3 .AND. KeyCou.EQ.0) THEN
        gg = SQRT(s)/(4*p*alfinv)*pi
        ff  = ff - gg 
      ENDIF
      WTCoul = ff
      END

      FUNCTION DnlFast(KeyEWs,amW,amZ,gaZ,amf,amH,sprim,s1,s2,epsCMS,
     &                 q1,q2)
!     ***************************************************************
!----------------------------------------------------------------------!
! This function provides a value of electroweak virtual + soft-photon  !
! corrections to a cross section of the process:                       !
!                       e+e- ---> W+W-                                 !
! as given in ref:                                                     !
! J. Fleischer, F. Jegerlehner, M. Zralek, Z. Phys. C42 (1989) 409.    !     
! INPUT: KeyEWs -- scale choice for EW correction                      !
!        amW -- W mass                                                 !
!        amZ -- Z mass                                                 !
!        gaZ -- Z widths                                               !
!        amf -- array of fermion masses                                !
!        amH -- Higgs mass                                             !
!        sprim -- energy squared of final W-W+ in their CMS            !
!        s1,s2 -- squared invariant masses of W- and W+, resp.         !
!        epsCMS -- soft photon cut-off in CMS of the incoming beams    !
!        q1,q2 -- W-, W+ 4-momenta, resp.                              !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                        CERN, Aug. 2000  !
! Last update: 21.08.2000           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER( pix = 3.1415926535897932d0, alfinv = 137.03599976D0)
      PARAMETER( alfpi=  1/pix/alfinv, alfax= 1d0/alfinv)
      REAL*8 q1(4),q2(4),amf(20)
! Commons with parameters for virtual+soft correction calculations
!======================================================================
	double precision W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	COMMON/BEZNAZ/ W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	double precision COEF1,COEF2,COEF3,COEF4,COEF5,COEF8
	COMMON/COEFF1/COEF1,COEF2,COEF3,COEF4,COEF5,COEF8
	double precision COEF0A,DPI
	COMMON/COEFFA/COEF0A,DPI
	CHARACTER*4 SCHEME
	COMMON/SCHEM/SCHEME
	double precision COEF0,SCHCON,RALFA
	COMMON/COEFF0/COEF0,SCHCON,RALFA
	double precision GAMAZ
	COMMON/ZBR/GAMAZ
	double precision XR,XNOT,KMIN,KMAX
	COMMON/SOFCUT/XR,XNOT,KMIN,KMAX
	double precision XR0
	integer IOM
	COMMON/CUTOPT/XR0,IOM
	double precision PM(4),PP(4),P(4)
	COMMON/MOMENT/PM,PP,P
	integer iopt
	COMMON/OPT/IOPT
	double precision MTOP,MH
	COMMON/TOPHIG/MTOP,MH
	double precision GF
	COMMON/FERMIC/GF
	double precision MUP(8),MDOWN(8),QUP(8),QDOWN(8),FN,QCDF
	integer IFERM
	COMMON/FMANDQ/MUP,MDOWN,QUP,QDOWN,FN,QCDF,IFERM
 	double precision GAMA0,GAMA,GAMA1,GAMA2,FCP
	COMMON/NORMA1/GAMA0,GAMA,GAMA1,GAMA2,FCP
	double precision PI,PI2
	COMMON/PIATAN/PI,PI2
	double precision CONVC
	COMMON/CONVCO/CONVC
	integer iexp,inicol
	double precision cone,xmu2
	COMMON/EXPON/IEXP,inicol,cone,xmu2
	double precision delta
	common /ffcut/delta
	integer IAPP,IDEN,IDTM,IBFC,IDTMZ
	COMMON/APPROX/IAPP,IDEN,IDTM,IBFC,IDTMZ
	CHARACTER*11 POLE
	COMMON/POLINI/POLE
	CHARACTER*12 POLWM,POLWP,polwms,polwps
	COMMON/POLFIN/POLWM,POLWP,polwms,polwps
	double precision PLM,PLP,PTM,PTP,fim,fip
	COMMON/POLVEC/PLM,PLP,PTM,PTP,fim,fip
	integer LS1,LS2,IAVER
	COMMON/POLELE/LS1,LS2,IAVER
	integer LM1,LM2,LMSTEP
	COMMON/POLWMI/LM1,LM2,LMSTEP
	integer LP1,LP2,LPSTEP
	COMMON/POLWPL/LP1,LP2,LPSTEP
	REAL*8 S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
	COMMON /AMPT/S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
	REAL*8 DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,X7M0,X7P0
	COMMON/FORMFA/ DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,
     &		X7M0,X7P0
	REAL*8 FIW,CFIW,SFIW,dfi
	COMMON/AZIMUT/FIW,CFIW,SFIW,dfi
	double precision EPSM(3,4),EPSP(3,4),P1(4),QM4(4),QP4(4)
	COMMON/VECT/EPSM,EPSP,P1,QM4,QP4
	REAL*8 ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
	COMMON /ANO/ ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
	integer iorder
	common /order/iorder
	double precision d1z,dkapg,dkapz,lamg,lamz,xig,xiz
	logical lanoma
	common /anomal/d1z,dkapg,dkapz,lamg,lamz,xig,xiz,lanoma
	double precision px(0:3,7),eps(0:3,7)
	integer iparti(7)
	common /partic/px,eps,iparti
!======================================================================
        DIMENSION Q1W(4),Q2W(4)
! Arrays for storing EW corrections         
        DIMENSION CTarr(1001),VSarr(1001)
! Number of points for EWC calculation
        DATA Npts /501/
! Switch OFF/ON (0/1) QCD correction to fermion loops (default: ON)  
        DATA KeyQCD /1/
! KeyAlW=1: calculate all O(alpha) correction at alpha_W (RECOMMENDED)
!       =0: original solution of FJKZ 
        DATA KeyAlW /1/
        DATA Init /0/
        SAVE
!
! Set up parameters for virtual+soft corrections
      IF (Init.EQ.0) THEN
        iorder = 1
        inicol = 0
        IOM    = 0
        SCHEME = 'GMU'
        POLE   = 'UNPOLARIZED'
        POLWM  = 'UNPOLARIZED'
        POLWP  = 'UNPOLARIZED'
        polwms = 'UNPOLARIZED'
        polwps = 'UNPOLARIZED'
        PLM   = 0
        PLP   = 0
        PTM   = 0
        PTP   = 0
        fim   = 0
        fip   = 0
        PI    = pix
        ALFA  = alfax
	GF    = 1.16639D-5
	CONVC = 0.3893857D9
	DPI = PI
	PI2 = PI**2
! photon mass^2 (cutoff)
	delta = 1.d-24
! Electroweak parameters
        MZ = amZ
        GAMAZ = gaZ
        MW = amW
! top and Higgs masses
        MTOP = amf(6)
        MH   = amH
! electron mass
        ME   = amf(11)
! Number of fermion flavours
        IFERM = 6
! QCD-correction factor
        IF (KeyQCD.NE.0) THEN
           QCDF = 1D0 +0.133D0/PI 
! No QCD-correction factor 
        ELSE
           QCDF = 1d0
        ENDIF
! Fermion masses and charges (leptons)
! * electron - neutrino
        FN = 1d-10
	MDOWN(1) = ME
	MUP(1)   = FN*MDOWN(1)
	QDOWN(1) =-1.D0
	QUP(1)   = 0.D0
! * muon - neutrino
	MDOWN(2) = amf(13)
	MUP(2)   = FN*MDOWN(2)
	QDOWN(2) =-1.D0
	QUP(2)   = 0.D0
! * tau - neutrino
	MDOWN(3) = amf(15)
	MUP(3)   = FN*MDOWN(3)
	QDOWN(3) =-1.D0
	QUP(3)   = 0.D0
! Fermion masses and charges (quarks)
! * up - down
        MDOWN(4) = amf(1)
        MUP(4)   = amf(2)
	QDOWN(4) =-1.D0/3.D0
	QUP(4)   = 2.D0/3.D0
! * strange - charm
        MDOWN(5) = amf(3)
        MUP(5)   = amf(4)
	QDOWN(5) =-1.D0/3.D0
	QUP(5)   = 2.D0/3.D0
! * top - bottom
        MDOWN(6) = amf(5)
        MUP(6)   = MTOP
	QDOWN(6) =-1.D0/3.D0
	QUP(6)   = 2.D0/3.D0
! Extra family:
	MDOWN(7) = 751.D0
	MUP(7)   = 749.D0
	QDOWN(7) =-1.D0
	QUP(7)   = 0.D0
!
	MDOWN(8) = 749.D0
	MUP(8)   = 751.D0
	QDOWN(8) =-1.D0/3.D0
	QUP(8)   = 2.D0/3.D0
! Masses squared
        MW2 = MW**2
        MZ2 = MZ**2
        ME2 = ME**2
! Functions of the weak mixing angle
        CW  = MW/MZ
        CW2 = CW**2
        SW  = DSQRT(1D0 - CW2)
        SW2 = SW**2
! Vector and axial-vector couplings of Z to the electron
	A0 =-(1D0 - 4D0*SW2)/4D0/SW/CW
	C0 =-1D0/4D0/SW/CW
! The effective alpha
	ALFAW = DSQRT(2D0)*GF*MW2*SW2/PI
        IF (KeyAlW.EQ.1) THEN
! Calculate all O(alpha) corrections in G_mu scheme at alpha_W
           ALFA = ALFAW
        ENDIF
! Scheme conversion constant 
	SCHCON = 1D0
	RALFA  = ALFAW/ALFA
	IF (SCHEME.EQ.'GMU') SCHCON = RALFA**2
! Some switches
	IAPP  = 0
	IDEN  = 0
	IDTM  = 0
	IBFC  = 0
	IDTMZ = 0
! Anomalous couplings (set to zero)
        lanoma = .FALSE.
        d1z   = 0
        dkapg = 0
        dkapz = 0
        lamg  = 0
        lamz  = 0
        xig   = 0
        xiz   = 0
! Some other parameters
        iexp = 0
        cone = 0
	cfd = 1
	cfc = 1
	cfr = 1
	ctb = 1
	ctf = 1
	cff = 1
	csf = 1
! Initialize the ff package
        CALL OffIni
	delta = 1.d-24
! Initialize momenta and polarizations to 0
	DO i = 1,7
           DO j = 0,3
              px(j,i)  = 0
              eps(j,i) = 0
           ENDDO
           iparti(i) = 0
	ENDDO
! W-boson velocity
cc      BETAW = SQRT(1 - 2*(s1+s2)/sprim + ((s1-s2)/sprim)**2) 
cc      S = 4*MW2/(1 - BETAW**2)
        S = sprim
        BETAW = SQRT(1 - 4*MW2/S)
        W = SQRT(S)
! 4-momenta of e-/e+
        PM(1) = W/2D0
        PM(2) = 0D0
        PM(3) = 0D0
        PM(4) = PM(1)
        PP(1) = PM(1)
        PP(2) = 0D0
        PP(3) = 0D0
        PP(4) =-PM(4)
! Sum of the electrons 4-momenta
        DO I1 = 1,4
           P(I1) = PM(I1)+PP(I1)
        ENDDO
! Coefficients needed 
        COEF0  = SCHCON*ALFA**2/4D0/S*BETAW*CONVC*2D0*PI
        COEF0A = SCHCON*ALFA**2/4D0*CONVC*2D0*PI
        COEF1  = 1D0/S - CW/SW/(S-MZ2)*(A0+C0)
        COEF2  = 1D0/S + SW/CW/(S-MZ2)*(A0+C0)
        COEF3  = 1D0/S - CW/SW/(S-MZ2)*(A0-C0)
        COEF4  = 1D0/S + SW/CW/(S-MZ2)*(A0-C0)
        COEF5  = SCHCON*ALFA**3/4D0/PI/S/2D0/PI*CONVC*2D0*PI
        COEF8  = MW2**2/2D0
! The soft photon cut-off
        KMIN = epsCMS*W/2 
        KMAX = W/2D0*(1D0-4D0*MW2/S) !W/2
        XR0  = 2*KMIN/W
        XR   = XR0
        XNOT = XR
!!!!!!
cc! VELTMAN'S CUTOFF:
cc      XR0 = 0.1 !DMIN1(1-2*MW/W,0.1d0)
cc      XR   = XR0
cc      XNOT = XR
cc      KMIN = W*( XR/( 1 + XR + SQRT((1-XR)**2 - 4*MW2/S) ) )
cc      KMAX = W/2D0*(1D0-4D0*MW2/S)
!!!!!
        xmu2 = S
! Factors necessary for smoothing CP distribution 
        GAMA0 = (1.D0 + BETAW**2)/2D0
        GAMA  = BETAW
        GAMA1 = GAMA0 + GAMA
        GAMA2 = GAMA0 - GAMA
        FCP = GAMA/DLOG(GAMA1/GAMA2)
! Calculate EW correction and store in array
        EM = W/2
	QM = EM*DSQRT(1-4*MW2/S)
        DO i = 1,Npts
! cos(theta) of W-
           COSTHT = -1d0 + (i-1)*2d0/(Npts-1)
           IF (i.EQ.1)    COSTHT = -1d0 + 1d-5
           IF (i.EQ.Npts) COSTHT =  1d0 - 1d-5
           CTarr(i) = COSTHT
! Azimuthal angle
           qtra = SQRT(q1(1)**2 + q2(2)**2)
           SFIW = q1(2)/qtra
           CFIW = q1(1)/qtra
           FIW  = DACOS(CFIW)
           IF (q1(2).LT.0d0) FIW = 2*PI - FIW
! Determine polarization
           CALL getpol
! Calculate Born cross section
           Born = COEF0*CSS0(COSTHT,0)
! Calculate electroweak corrections
           CALL ELWEAK(XNOT,COSTHT) 
! Get overcomplete amplitudes:
           IF(SCHEME.EQ.'ALFA') THEN
              E2 = 4.D0*PI*ALFA
           ELSE
              E2 = 4.D0*PI*ALFA*RALFA
           ENDIF
           T = MW2 - S/2.D0*(1.D0 - BETAW*COSTHT)
           U = MW2 - S/2.D0*(1.D0 + BETAW*COSTHT)
           PROPG =-E2/S
           PROPZ = E2/(S-MZ2)
           PROPN =-E2/T
! Amplitudes coming from ELWEAK (overcomplete base)
           S01M = S01IT
           S02M = S03IT
           S03M = S*S02IT
           S04M = F5IT
           T01M = T01IT
           T02M = T02IT
           X07M = XL7T
           X08M = XL8T
!
           S01P = S01PIT
           S02P = S03PIT
           S03P = S*S02PIT
           S04P = F5PIT
           T01P = T01PIT
           T02P = T02PIT
           X07P = XR7T
           X08P = XR8T
! Soft photon correction
           Soft = Born*DSOFT0(COSTHT)
! Amplitudes forming a complete base:
           T1M = T01M+T02M
           S1M = S01M-T02M/2.D0
           S2M = S02M+T02M/2.D0-BETAW*COSTHT*X08M
           S3M = S03M
           S4M = S04M+(T02M/2.D0+X08M)
           X7M = X07M
!
           T1P = T01P+T02P
           S1P = S01P-T02P/2.D0
           S2P = S02P+T02P/2.D0-BETAW*COSTHT*X08P
           S3P = S03P
           S4P = S04P-(T02P/2.D0+X08P)
           X7P = X07P
! New form factors:
           AW = 1.D0/2.D0/SW/CW
           SMW = S/MW2
           DG0 = (S1P-2.D0*SW2*(S1P-S1M)+(S3P-2.D0*SW2*(S3P-S3M))/2.D0)
     &          /PROPG
           DZ0 = (S1P-S1M+(S3P-S3M)/2.D0)/AW/PROPZ
           XG0 = (S2P-2.D0*SW2*(S2P-S2M)
     &          -(1.D0-1.D0/SMW)*(S3P-2.D0*SW2*(S3P-S3M)))/PROPG
           XZ0 = (S2P-S2M-(1.D0-1.D0/SMW)*(S3P-S3M))/AW/PROPZ
           YG0 = (S3P-2.D0*SW2*(S3P-S3M))/PROPG/SMW
           YZ0 = (S3P-S3M)/AW/PROPZ/SMW
           ZG0 = (S4P-2.D0*SW2*(S4P-S4M))/PROPG/SMW
           ZZ0 = (S4P-S4M)/AW/PROPZ/SMW
           DT1M0 = T1M*2.D0*SW2/PROPN
           T1P0  = T1P*2.D0*SW2/PROPN
           X7M0  = X7M/E2
           X7P0  = X7P/E2
! Virtial corrections
           Virt = COEF0*CSS0(COSTHT,1)
! Total virtual+soft corrections
           fac = 1d0 
           delVS = fac*(Virt + Soft)/Born
! ISR LL
           delLL = alfpi*(LOG(S/ME2) - 1)
! YFS form-factor 
           CP = COSTHT
           SP = SQRT(1-CP**2)
C 4-MOMENTUM OF W MINUS:
           Q1W(4) = EM
           Q1W(1) = QM*SP*CFIW
           Q1W(2) = QM*SP*SFIW
           Q1W(3) = QM*CP
C 4-MOMENTUM OF W PLUS:
           Q2W(4) = EM
           Q2W(1) = -QM4(2)
           Q2W(2) = -QM4(3)
           Q2W(3) = -QM4(4)
           delFF = YIRfof(ME,MW,S,MW2,MW2,epsCMS,Q1W,Q2W)
! New solutions for GMU-scheme - multiplicative correction factor
           rcofa = ALFAW*ALFINV
! (A) according to RG improved YFS theory
           IF (KeyEWs.EQ.0) THEN
              delFF = rcofa*delFF
              delLL = rcofa*delLL
! (B) RacoonWW-style: alpha(0) as coefficient for all corrections
           ELSE
              delVS = delVS/rcofa
           ENDIF
! Non-IR contribution
           delnIR = delVS - delFF
! Match with LL ISR calculation
           delNL = delnIR - delLL 
! Save NL correction in array
           VSarr(i) = delNL
cc           print*,'costh,delNl=',costht,delNl
        ENDDO
        Init = 1
      ENDIF
      COSTHT = q1(3)/SQRT(q1(1)**2 + q1(2)**2 + q1(3)**2)
! Find a bin for COSTHT
      xc = COSTHT
      ib = NINT( (xc + 1d0)*(Npts-1)/2d0 + 0.99) 
      xa = CTarr(ib)
      xb = CTarr(ib+1)
      fa = VSarr(ib)
      fb = VSarr(ib+1)
      fc = fa + (fa - fb)/(xa - xb)*(xc - xa)
      DnlFast = fc
      END





























      subroutine eewwg(kz,mz,gz,mw,sw2,s,q,awwgel,awwger)
c----------------------------------------------------------------------c
c This routine calculates polarization amplitudes for the process      c
c e+e- --> W+W-gamma, for on-shell W's in the Born approximation.      c
c Calculation is done in the CMS of e+e- with z-axis pointing along    c
c e- direction. It is based on the paper:                              c
c K. Kolodziej, M. Zralek, Phys. Rev. D43 (1991) 43;                   c
c INPUT: kz = 0/1/2 - running/constant/zero Z boson width (W.P.)       c
c        mz - the Z boson mass                                         c
c        gz - the Z boson width (W.P.)                                 c
c        mw - the W boson mass  (W.P.)                                 c
c        sw2 - the electroweak mixing parameter                        c
c        s - the e+e- centre of mass energy squared (in GeV**2)        c
c        q(0:3,1) - the four-momentum of W-                            c
c        q(0:3,2) - the four-momentum of W+                            c
c        q(0:3,3) - the four-momentum of gamma                         c
c OUTPUT: awwgel(3,3,2) - a complex array of polarization amplitudes   c
c                         for the left-handed electron M(-,+,l1,l2,l)  c
c         awwger(3,3,2) - a complex array of polarization amplitudes   c
c                         for the right-handed electron M(+,-,l1,l2,l) c
c    (The amplitude normalization as in eq.(33) of the above paper)    c
c                                                                      c
c Written by: Karol Kolodziej(*)         date: October, 1989           c
c E-mail:     kolodzie@us.edu.pl                                       c
c Last update: 17.04.1996                by: K.K.                      c
c                                                                      c
c (*) Please do not distribute versions modified by yourself without   c
c     notifying the author!                                            c
c----------------------------------------------------------------------c
!======================================================================!
! This version has been translated to F77 from the original one in F90 !
! and some (minor) modifications have been made                         
! by: Wieslaw Placzek                            Knoxville, May 1996   !
! Last update: 29.07.1996                    by: W.P.                  !
!======================================================================!
      IMPLICIT NONE
      INTEGER kz,init,i,j,k,l1,l2,l
      REAL*8  mz,gz,sw2,s,q(0:3,3),
     &        epsm(0:3,3),epsp(0:3,3),eps(0:3,2),srr,sqrts,
     &        qq2,q1q3,q2q3,ppq2,ppq3,pmq1,pmq3,s01,s02,s03,s04,t1,t2,
     &        q2em(3),q3em(3),s5(3),s1(3),s6(3),
     &        q1ep(3),q3ep(3),s4(3),s3(3),s7(3),
     &        q1e(2),q2e(2),s2(2),s8(2),eme(3,2),epe(3,2),epem(3,3),
     &        mw,mw2,mz2,cw,sw,cw2,a0,c0,c6,c7,sprior
      COMPLEX*16 coef1,coef2,coef3,coef4,coef6,coef7
      REAL*8 pm(0:3),pp(0:3),p1(0:3),p2(0:3),p3(0:3),p4(0:3),p5(0:3),
     &       p8(0:3),p10(0:3),p11(0:3),p12(0:3),p13(0:3),
     &       v1(0:3),v2(0:3),v3(0:3)
      REAL*8 q1(0:3),q2(0:3),q3(0:3),
     &       epsg(0:3,3),xeps(0:3),xepsm(0:3),xepsp(0:3)
      COMPLEX*16 fepsp(3),fepsm(3),feps(2),f12,f13,f16,f17,FKK3,fKK5
      COMPLEX*16 awwgel(3,3,2),awwger(3,3,2)
      COMPLEX*16 m1(3,3,2),m2(3,3,2),m3(3,3,2)
      COMPLEX*16 prinz,prinz1,f3a,f3b,f3c,f3d,f5a,f5b
      real*8 am1,am2
cc      real*8 epsm1(0:3),epsm2(0:3),epsm3(0:3),
cc     &       epsp1(0:3),epsp2(0:3),epsp3(0:3),
cc     &       eps1(0:3),eps2(0:3),epsx(0:3,3),
cc     &       qq(3),ct(3),st(3),cf(3),sf(3),gamma(2)
      DATA init/0/
      SAVE init,mw2,mz2,sw,cw2,cw,a0,c0,c6,c7,
     &     coef1,coef2,coef3,coef4,sqrts,pm,pp,sprior
!
      IF (init.EQ.0) THEN
        sw  = SQRT(sw2)
        cw2 = 1.d0 - sw2
        cw  = SQRT(cw2)
!WP        mw  = mz*cw
        mw2 = mw**2
        mz2 = mz**2
        a0 =-(1.d0 - 4.d0*sw2)/4.d0/sw/cw
        c0 =-1.d0/4.d0/sw/cw
        c6 = cw/sw*(a0 + c0)
        c7 = cw/sw*(a0 - c0)
        init = 1
        sprior = s
      ENDIF
!
      IF (init.EQ.1 .OR. ABS(s-sprior).GT.1d-10) THEN
        sprior = s
! Z-propagator (inverse)
        IF (kz.EQ.0) THEN
          prinz = DCMPLX(s-mz2,s/mz*gz)
        ELSEIF (kz.EQ.1) THEN
          prinz = DCMPLX(s-mz2,mz*gz)
        ELSE
          prinz = DCMPLX(s-mz2,0d0)
        ENDIF 
! Necessary coefficients:
        coef1 = 1.d0/s - c6/prinz
        coef2 = 1.d0/s + sw/cw*(a0+c0)/prinz
        coef3 = 1.d0/s - c7/prinz
        coef4 = 1.d0/s + sw/cw*(a0-c0)/prinz
! Initial four-momenta:
        sqrts = SQRT(s)
        pm(0) = sqrts/2.d0
        pm(1) = 0.d0
        pm(2) = 0.d0
        pm(3) = sqrts/2.d0
        pp(0) = pm(0)
        pp(1) = 0.d0
        pp(2) = 0.d0
        pp(3) =-pm(0)
        init = 2
      ENDIF
! Auxiliary 4-vectors of particles 4-momenta
      DO k = 0,3
        q1(k) = q(k,1)
        q2(k) = q(k,2)
        q3(k) = q(k,3)
      ENDDO
!!!!
      am1 = sqrt(q1(0)**2 -q1(1)**2 -q1(2)**2 -q1(3)**2)
      am2 = sqrt(q2(0)**2 -q2(1)**2 -q2(2)**2 -q2(3)**2)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
cc! Spherical components:
cc
cc      do i = 1,3
cc         qq(i) = sqrt(q(1,i)**2+q(2,i)**2+q(3,i)**2)
cc         ct(i) = q(3,i)/qq(i)
cc         st(i) = sqrt(1.d0-ct(i)**2)
cc         cf(i) = q(1,i)/qq(i)/st(i)
cc         sf(i) = q(2,i)/qq(i)/st(i)
cc      end do
cc
cc! Polarization vectors in the ractangular basis of eq.(9):
cc
cc      gamma(1) = q1(0)/mw
cc      gamma(2) = q2(0)/mw
cc
cc      epsm1(0) = 0.d0
cc      epsm1(1) = ct(1)*cf(1)
cc      epsm1(2) = ct(1)*sf(1)
cc      epsm1(3) =-st(1)
cc      epsm2(0) = 0.d0
cc      epsm2(1) =-sf(1)
cc      epsm2(2) = cf(1)
cc      epsm2(3) = 0.d0
cc      epsm3(0) = qq(1)/mw
cc      epsm3(1) = gamma(1)*st(1)*cf(1)
cc      epsm3(2) = gamma(1)*st(1)*sf(1)
cc      epsm3(3) = gamma(1)*ct(1)
cc
cc      epsp1(0) = 0.d0
cc      epsp1(1) = ct(2)*cf(2)
cc      epsp1(2) = ct(2)*sf(2)
cc      epsp1(3) =-st(2)
cc      epsp2(0) = 0.d0
cc      epsp2(1) =-sf(2)
cc      epsp2(2) = cf(2)
cc      epsp2(3) = 0.d0
cc      epsp3(0) = qq(2)/mw
cc      epsp3(1) = gamma(2)*st(2)*cf(2)
cc      epsp3(2) = gamma(2)*st(2)*sf(2)
cc      epsp3(3) = gamma(2)*ct(2)
cc
cc      eps1(0) = 0.d0
cc      eps1(1) = ct(3)*cf(3)
cc      eps1(2) = ct(3)*sf(3)
cc      eps1(3) =-st(3)
cc      eps2(0) = 0.d0
cc      eps2(1) =-sf(3)
cc      eps2(2) = cf(3)
cc      eps2(3) = 0.d0
cc
cc
cc      do k = 0,3
cc         epsx(k,1) = epsm1(k)
cc         epsx(k,2) = epsm2(k)
cc         epsx(k,3) = epsm3(k)
cc         epsx(k,1) = epsp1(k)
cc         epsx(k,2) = epsp2(k)
cc         epsx(k,3) = epsp3(k)
cc         eps(k,1)  = eps1(k)
cc         eps(k,2)  = eps2(k)
cc      end do
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Polarization vectors in the ractangular basis
      CALL PolarV(q1,epsm)
      CALL PolarV(q2,epsp)
      CALL PolarV(q3,epsg)
      DO i = 1,2
        DO k = 0,3
          eps(k,i) = epsg(k,i)
        ENDDO
      ENDDO
      DO i = 1,3
        fepsm(i) = DCMPLX( epsm(1,i),-epsm(2,i) )
        fepsp(i) = DCMPLX( epsp(1,i),-epsp(2,i) )
        IF (i.LE.2) feps(i) = DCMPLX( eps(1,i),-eps(2,i) )
      ENDDO

! Necessary combinations of momenta:
      DO k = 0,3
        p1(k) = pm(k) - q3(k)
        p2(k) = q2(k) - q1(k)
        p3(k) = pp(k) - q3(k)
        p4(k) = q2(k) + pm(k) + pp(k)
        p5(k) = q1(k) - q3(k)
        p8(k) = q2(k) - q3(k)
        p10(k)= q1(k) + pm(k) + pp(k)
        p11(k)= pp(k) - q2(k)
        p12(k)= pm(k) - q1(k)
        p13(k)= q1(k) + q2(k)
      ENDDO         
! Scalar products independent of polarization:
      qq2  = srr(p13,p13)
      q1q3 = srr(q1,q3)
      q2q3 = srr(q2,q3)
      pmq1 = pm(0)*( q(0,1) - q(3,1) )
      ppq2 = pp(0)*( q(0,2) + q(3,2) )
      pmq3 = pm(0)*( q(0,3) - q(3,3) ) 
      ppq3 = pp(0)*( q(0,3) + q(3,3) ) 
!     s01=(q2+pm+pp).(q1-q3)
      s01 = srr(p4,p5)
!     s02=(q1+pm+pp).(q2-q3)
      s02 = srr(p10,p8)
!     s03=(q2+pm+pp).q3
      s03 = srr(p4,q3)
!     s04=(q1+pm+pp).q3
      s04 = srr(p10,q3)
!     t1=(pp-q2).2
      t1 = srr(p11,p11)
!     t2=(pm-q1).2
      t2 = srr(p12,p12)
! Values of f1 independent of polarization:
      f12 = DCMPLX( q(1,2),-q(2,2) )
      f13 = DCMPLX( p5(1),-p5(2) )
      f16 = DCMPLX( p8(1),-p8(2) )
      f17 = DCMPLX( q(1,1),-q(2,1) )
! Necessary coefficients:
      IF (kz.EQ.0) THEN
        prinz1 = DCMPLX(qq2-mz2,qq2/mz*gz)
      ELSEIF (kz.EQ.1) THEN
        prinz1 = DCMPLX(qq2-mz2,mz*gz)
      ELSE
        prinz1 = DCMPLX(qq2-mz2,0d0)
      ENDIF
      coef6 = 1/qq2 - c6/prinz1
      coef7 = 1/qq2 - c7/prinz1
! Scalar products dependent on polarization:
!     q2.epsm
!     q3.epsm
      DO i = 1,3
        DO k = 0,3
          xepsm(k) = epsm(k,i)
        ENDDO
        q2em(i) = srr(q2,xepsm)
        q3em(i) = srr(q3,xepsm)
      ENDDO
!     s5=(pm+pp).epsm
!     s1=(q2+pm+pp).epsm
!     s6=(q2-q3).epsm
      DO i = 1,3
        s5(i) = sqrts*epsm(0,i)
        s1(i) = q2em(i) + s5(i)
        s6(i) = q2em(i) - q3em(i)
      ENDDO
!     q1.epsp
!     q3.epsp
      DO i = 1,3
        DO k = 0,3
          xepsp(k) = epsp(k,i)
        ENDDO
        q1ep(i) = srr(q1,xepsp)
        q3ep(i) = srr(q3,xepsp)
      ENDDO
!     s4=(pm+pp).epsp
!     s3=(q1-q3).epsp
!     s7=(q1+pm+pp).epsp
      DO i = 1,3
        s4(i) = sqrts*epsp(0,i)
        s3(i) = q1ep(i) - q3ep(i)
        s7(i) = q1ep(i) + s4(i)
      ENDDO
!     q1.eps
!     q2.eps
      DO i = 1,2
        DO k = 0,3
          xeps(k) = eps(k,i)
        ENDDO
        q1e(i) = srr(q1,xeps)
        q2e(i) = srr(q2,xeps)
      ENDDO
!     s2=(q2+pm+pp).eps
!     s8=(q1+pm+pp).eps
      DO i = 1,2
        s2(i) = q2e(i) + sqrts*eps(0,i)
        s8(i) = q1e(i) + sqrts*eps(0,i)
      ENDDO
!
      DO i = 1,3
        DO j = 1,2
          eme(i,j) = epsm(0,i)*eps(0,j) - epsm(1,i)*eps(1,j)
     &             - epsm(2,i)*eps(2,j) - epsm(3,i)*eps(3,j)
          epe(i,j) = epsp(0,i)*eps(0,j) - epsp(1,i)*eps(1,j)
     &             - epsp(2,i)*eps(2,j) - epsp(3,i)*eps(3,j)
        ENDDO
        DO j = 1,3
          epem(i,j) = epsp(0,i)*epsm(0,j) - epsp(1,i)*epsm(1,j)
     &              - epsp(2,i)*epsm(2,j) - epsp(3,i)*epsm(3,j)
        ENDDO
      ENDDO
! Calculation of polarization amplitudes
      DO l1 = 1,3
      DO l2 = 1,3
        DO k = 0,3
          xepsm(k) = epsm(k,l1)
          xepsp(k) = epsp(k,l2)
          v1(k) = 2.d0*q2em(l1)*epsp(k,l2) - epem(l2,l1)*p2(k)
     &          - 2.d0*q1ep(l2)*epsm(k,l1)
        ENDDO
        DO l = 1,2      
          DO k = 0,3
            xeps(k)  = eps(k,l)
            v2(k) = eme(l1,l)*p5(k) - 2.d0*q1e(l)*epsm(k,l1)
     &            + 2.d0*q3em(l1)*eps(k,l)
            v3(k) = epe(l2,l)*p8(k) - 2.d0*q2e(l)*epsp(k,l2)
     &            + 2.d0*q3ep(l2)*eps(k,l)
          ENDDO
          f3a = FKK3(v1,p1,xeps)
          f3b = FKK3(xeps,p3,v1)
          f3c = FKK3(xepsp,p11,v2)
          f3d = FKK3(v3,p12,xepsm)
          f5a = FKK5(xepsp,p11,xepsm,p1,xeps)
          f5b = FKK5(xeps,p3,xepsp,p12,xepsm)
!
          m1(l1,l2,l) = (f3a/pmq3 - f3b/ppq3)/2.d0
          m2(l1,l2,l) = ( ((s01*eme(l1,l) - s1(l1)*2.d0*q1e(l)
     &                                  + 2.d0*q3em(l1)*s2(l))*fepsp(l2)
     & + (-s3(l2)*eme(l1,l) + 2.d0*q1e(l)*epem(l2,l1)
     & - 2.d0*q3em(l1)*epe(l2,l))*2.d0*f12 + 2.d0*s4(l2)*(-eme(l1,l)*f13
     & + 2.d0*q1e(l)*fepsm(l1) - 2.d0*q3em(l1)*feps(l)) )/q1q3
     &  - (2.d0*s5(l1)*(epe(l2,l)*f16 - 2.d0*q2e(l)*fepsp(l2)
     &                                + 2.d0*q3ep(l2)*feps(l))
     & - 2.d0*(-s6(l1)*epe(l2,l) + 2.d0*q2e(l)*epem(l2,l1)
     &    - 2.d0*q3ep(l2)*eme(l1,l))*f17 + (-s02*epe(l2,l)
     & + s7(l2)*2.d0*q2e(l) - s8(l)*2.d0*q3ep(l2))*fepsm(l1))/q2q3)/2.d0
     & - (eme(l1,l)*fepsp(l2) + epe(l2,l)*fepsm(l1)
     &                                      - 2.d0*epem(l2,l1)*feps(l))
          m3(l1,l2,l) = am1*am2*(eme(l1,l)*fepsp(l2)/q1q3
     &                     + epe(l2,l)*fepsm(l1)/q2q3)/2.d0 
!
          awwgel(l1,l2,l) = sqrts*(coef6*m1(l1,l2,l) + coef1*m2(l1,l2,l)
     &                    + coef2*m3(l1,l2,l)
     &                    + ( (f5a/pmq3 + f3c/q1q3)/(-t1)
     &                      + (f5b/ppq3 + f3d/q2q3)/(-t2) )/4.d0/sw2)
          awwger(l1,l2,l) = sqrts*( -DCONJG(coef7*m1(l1,l2,l)
     &                    + coef3*m2(l1,l2,l) + coef4*m3(l1,l2,l)) )
        ENDDO
      ENDDO
      ENDDO
      END 

      REAL*8 FUNCTION srr(p1,p2)
!     **************************
      REAL*8 p1(0:3),p2(0:3)
!
      srr=p1(0)*p2(0)-p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)
      END 

      COMPLEX*16 FUNCTION FKK3(A,B,C)
!     *****************************
      REAL*8 A(0:3),B(0:3),C(0:3),ABP,BBP,BBM,CBM
      COMPLEX*16 AM,BP,BM,CM
!
      ABP = A(0) + A(3)
      AM  = DCMPLX(A(1),-A(2))
      BBP = B(0) + B(3)
      BBM = B(0) - B(3)
      BP  = DCMPLX(B(1),B(2))
      BM  = DCONJG(BP)
      CBM = C(0) - C(3)
      CM  = DCMPLX(C(1),-C(2))
      FKK3 = ABP*(BBM*CM - BM*CBM) + AM*(-BP*CM + BBP*CBM)
      END

      COMPLEX*16 FUNCTION FKK5(A,B,C,D,E)
!     *********************************
      REAL*8 A(0:3),B(0:3),C(0:3),D(0:3),E(0:3),
     &       ABP,BBP,BBM,CBP,CBM,DBP,DBM,EBM
      COMPLEX*16 AM,BP,BM,CP,CM,DP,DM,EM
!
      ABP = A(0) + A(3)
      AM  = DCMPLX(A(1),-A(2))
      BBP = B(0) + B(3)
      BBM = B(0) - B(3)
      BP  = DCMPLX(B(1),B(2))
      BM  = DCONJG(BP)
      CBP = C(0) + C(3)
      CBM = C(0) - C(3)
      CP  = DCMPLX(C(1),C(2))
      CM  = DCONJG(CP)
      DBP = D(0) + D(3)
      DBM = D(0) - D(3)
      DP  = DCMPLX(D(1),D(2))
      DM  = DCONJG(DP)
      EBM = E(0) - E(3)
      EM  = DCMPLX(E(1),-E(2))
      FKK5 = ( ABP*(BBM*CBP - BM*CP) + AM*(-BP*CBP + BBP*CP) )
     &      *( DBM*EM - DM*EBM)
     &     + ( ABP*(BBM*CM-BM*CBM) + AM*(-BP*CM+BBP*CBM) )
     &      *(-DP*EM + DBP*EBM)
      END

      SUBROUTINE PolarV(q,eps)
!     ************************
!----------------------------------------------------------------------!
! Calculation of polarization vectors of a vector boson in the         !
! rectangular basis, see K. Hagiwara and D. Zeppenfeld,                !
! Nucl. Phys. B274 (1986) 1, eq. (3.47).                               !
!     INPUT:  q(0:3)   - 4-momentum of the vector boson                !
!     OUTPUT: eps(0:3,3) - three polarization 4-vector                 !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                      date: 01.07.1994    !
! Last update: 29.07.1996                          by: W.P.            !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      REAL*8 q(0:3),eps(0:3,3)   
!
      qt2 = q(1)**2 + q(2)**2
      qt  = SQRT(qt2)
      aq2 = qt2 + q(3)**2
      aq  = SQRT(aq2)
      am  = SQRT(ABS(q(0)**2 - aq2)) 
      DO l = 1,3
        DO k = 0,3
          eps(k,l) = 0d0
        ENDDO
      ENDDO
      IF (aq.LT.1d-10) THEN
        eps(1,1) = 1d0
        eps(2,2) = 1d0
        IF (am.GT.1d-10) eps(3,3) = 1d0
      ELSEIF (qt/aq.LT.1d-10) THEN
        eps(1,1) = q(3)/aq
        eps(2,2) = q(3)/aq
        IF (am.GT.1d-10) THEN
          eps(3,3) = q(0)/am/aq*q(3)
          eps(0,3) = aq/am
        ENDIF
      ELSE
        ws1 = 1/aq/qt
        eps(1,1) = ws1*q(1)*q(3)
        eps(2,1) = ws1*q(2)*q(3)
        eps(3,1) =-ws1*qt2
        eps(0,1) = 0d0
        ws2 = 1/qt 
        eps(1,2) =-ws2*q(2)
        eps(2,2) = ws2*q(1)
        eps(3,2) = 0
        eps(0,2) = 0
        IF (am.GT.1d-10) THEN
          ws3 = q(0)/am/aq 
          eps(1,3) = ws3*q(1)
          eps(2,3) = ws3*q(2)
          eps(3,3) = ws3*q(3)
          eps(0,3) = ws3*aq2/q(0)
        ENDIF
      ENDIF  
      END
      SUBROUTINE Model(MODE,PAR1,PAR2)    
*     ********************************    
!----------------------------------------------------------------------!
! Model weights for the process:                                       !
!           e+e- --> W+W- + n*gamma --> 4fermions + n*gamma            !
! 1. ISR LL up to O(alpha^3)                                           !
! 2. O(alpha)-Exact EWRC to the WW-production process                  !
! 3. O(alpha)-Aproximate virtual EWRC to the WW-production process     !
!             ("fast" version with pretabulation and interpolation)    ! 
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                         CERN, Aug. 1999  !
! Last update: 25.01.2001           by: W.P.                           !
!----------------------------------------------------------------------!
*     ********************************    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      PARAMETER(PI=3.1415926535897932D0)
! This common can be everywhere, contains various switches
      COMMON / KeyKey/  KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      COMMON / MOMSET / q1(4),q2(4),phsum(4),phot(100,4),nphot   
      COMMON / MOMINI / XF1(4),XF2(4),XPHUM(4),XPHOT(100,4),NPHOX 
      COMMON / MOMFIN / yf1(4),yf2(4),yphum(4),yphot(100,4),nphoy 
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW
      COMMON / PHYPAR / ALFINV,GPICOB  
      COMMON / Higtop / amH,amt
      COMMON / DECDAT / AMAFIN(20), BR(20)
      COMMON / DECCOD / ICOD(20)
      COMMON / UUREC  / UU,EPS,DELTA     
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)         
      COMMON / INOUT  / NINP,NOUT   
      DIMENSION p1(4),p2(4),ph(4),qq(4)
      DIMENSION pf1(4),pf2(4),pf3(4),pf4(4)
      DIMENSION p1r(4),p2r(4),q1r(4),q2r(4),phr(4)
      DIMENSION pf1r(4),pf2r(4),pf3r(4),pf4r(4)
      DIMENSION q1r0(4),q2r0(4),pf1r0(4),pf2r0(4),pf3r0(4),pf4r0(4)
      DATA ncoll /0/
      DATA nbadwt /0/
      DATA wtbmax /0d0/
! Switch for some diagnostic print-outs (0/1: OFF/ON) 
      DATA KeyDia /1/
! Choice of scale for O(alpha) EW NL corrections:
! =0: according renormalization group improved YFS theory (RECOMMENDED)  
! =1: alpha(0) as a coefficient for all corrections (RacoonWW-style)
      DATA KeyEWs /0/
      SAVE
!
      IF(MODE.EQ.-1) THEN                 
*     =================================================================
*     =====================INITIALIZATION==============================
*     =================================================================
         KeyWga = MOD(KeyPhy,1000000)/100000
         KeyZga = MOD(KeyPhy,1000)/100
         KeySpn = MOD(KeyPhy,10000)/1000
         alfpi=  1/pi/alfinv
         ame  = AMEL
         ame2 = ame**2
         amW  = amaW
         gaW  = GammW
         amZ  = AMAZ
         gaZ  = GAMMZ
         sW2  = SINW2
         CMSEne = 2*ENE     
         s      =  CMSEne**2 
         Idyfs  = NINT(PAR1)
         Xcrude = PAR2
         WtCruI = WTCRU1
         IF (KeyCor.GT.0)
     &      CALL beta_monit(MODE,Idyfs,Xcrude,WtCruI,wtset)
         IF (KeyCor.GE.5)
     &      CALL ewrc_monit(MODE,Idyfs,XCrude,WeCruI,WtCrud,wtset)
! Beam particles momenta
         p1(4) = ENE
         p1(3) = SQRT(ENE**2 - ame2)
         p1(2) = 0d0
         p1(1) = 0d0
         p2(4) = ENE
         p2(3) =-p1(3)
         p2(2) = 0d0
         p2(1) = 0d0
      ELSEIF(MODE.EQ.0) THEN              
*     =================================================================
*     ===================MODEL X-SECTION===============================
*     =================================================================
         DO i = 1,100
           wtset(i) = 0d0
         ENDDO
         WtCrud = PAR1
         WtCruI = WTCRU1
         IF (WtCrud.EQ.0d0) THEN
            IF (WtCruI.NE.0d0) THEN
               DO k = 1,4
                  qq(k) = XF1(k) + XF2(k)
               ENDDO
               sprim = qq(4)**2 - qq(3)**2 - qq(2)**2 - qq(1)**2
! Masses of W-resonances 
               s1 = XF1(4)**2 - XF1(3)**2 - XF1(2)**2 - XF1(1)**2
               s2 = XF2(4)**2 - XF2(3)**2 - XF2(2)**2 - XF2(1)**2
               amWm = SQRT(s1) 
               amWp = SQRT(s2) 
! Final state fermion (W-decay products) momenta (massless)
               CALL DecRed(amWm,amWp,XF1,XF2,pf1,pf2,pf3,pf4)
! Born-like reduction procedure
               CALL Redbe0(qq,XF1,XF2,pf1,pf2,pf3,pf4,
     &                     q1r0,q2r0,pf1r0,pf2r0,pf3r0,pf4r0)
! Born x-section
               WtBorn = WtBoWW(KeyCor,amW,GaW,sprim,s1,s2,
     &                         pf1r0,pf2r0,pf3r0,pf4r0)
! ISR LL betas up to 3rd order
               CALL betar(alfinv,WtBorn,s,amel,nphox,xphot,wtset)
            ENDIF
            IF (KeyCor.GT.0)
     &         CALL beta_monit(MODE,Idyfs,Xcrude,WtCruI,wtset)
            IF (KeyCor.GE.5)
     &         CALL ewrc_monit(MODE,Idyfs,XCrude,WtCruI,WtCrud,wtset)
            RETURN
         ENDIF
         DO k = 1,4
            qq(k) = XF1(k) + XF2(k)
         ENDDO
         sprim = qq(4)**2 - qq(3)**2 - qq(2)**2 - qq(1)**2
! Masses of W-resonances 
         s1 = q1(4)**2 - q1(3)**2 - q1(2)**2 - q1(1)**2
         s2 = q2(4)**2 - q2(3)**2 - q2(2)**2 - q2(1)**2
         amWm = SQRT(s1) 
         amWp = SQRT(s2) 
! Final state fermion (W-decay products) momenta (massless)
         CALL DecRed(amWm,amWp,q1,q2,pf1,pf2,pf3,pf4)
! Born-like reduction procedure
         CALL Redbe0(qq,q1,q2,pf1,pf2,pf3,pf4,
     &               q1r0,q2r0,pf1r0,pf2r0,pf3r0,pf4r0)
! Born x-section
         WtBorn = WtBoWW(KeyCor,amW,GaW,sprim,s1,s2,
     &                   pf1r0,pf2r0,pf3r0,pf4r0)
*---------------------------------------------------------------------
*------------------------- ISR LL ------------------------------------
*---------------------------------------------------------------------
! ISR LL betas up to 3rd order
         CALL betar(alfinv,WtBorn,s,amel,nphox,xphot,wtset)
         IF (KeyCor.GT.0)
     &      CALL beta_monit(MODE,Idyfs,Xcrude,WtCruI,wtset)
!... For backward compatibility
         wtset(71) = wtset(1)
         wtset(72) = wtset(2)
         wtset(73) = wtset(3)
         wtset(74) = wtset(4)
!... Model weight (the best)              
         IF (KeyCor.GT.0) THEN
            WTMDL = WTSET(4)             
         ELSE
            WTMDL = WTSET(1)             
         ENDIF
         PAR2  = WTMDL  
         IF (KeyCor.LT.5) RETURN
*---------------------------------------------------------------------
*------------------- O(alpha) EW CORRECTIONS--------------------------
*---------------------------------------------------------------------
! Virtual+soft corrections
         deli1 = alfpi*(LOG(s/ame2) - 1)
!WP: LL corrections for W+W- states
!WP         sfin = ( yf1(4) + yf2(4) )**2 - ( yf1(3) + yf2(3) )**2
!WP     &        - ( yf1(2) + yf2(2) )**2 - ( yf1(1) + yf2(1) )**2
!WP         betaW = SQRT(1 - 2*(s1+s2)/sfin + ((s1-s2)/sfin)**2)
!WP         xbeta = (1 + betaW)/(1 - betaW)  
!WP         delf1 = alfpi*( (1+betaW**2)/2/betaW*LOG(xbeta) - 1 )
!WP         ur0  = s2 - SQRT(sprim)*( q2r0(4) - q2r0(3) )
!WP         delif = alfpi*LOG( (s1 - tr0)*(s2 - tr0)/(s1 - ur0)/(s2 - ur0) )
! LL approximation
         dell1 =  deli1
! Fast version of O(alpha) NL correction (pretabulation)
         IF (ENE.GT.amW) THEN
            delnlf = DnlFast(KeyEWs,amW,amZ,gaZ,amafin,amH,s,s1,s2,eps,
     &                       q1r0,q2r0)
         ELSE
            delnlf = 0d0
         ENDIF
! Match with LL ISR calculation
         delap = delnlf + dell1
! LL correction for on-shell W's (for effective beta and s)
         betaW = SQRT(1 - 2*(s1+s2)/sprim + ((s1-s2)/sprim)**2) 
         sos = 4*amaW**2/(1 - betaW**2)
         dosl1 = alfpi*(LOG(sos/ame2) - 1)
! Exact calculation
         IF (KeyCor.EQ.5) THEN
           delvs = VirSof(amW,amZ,gaZ,amafin,amH,sprim,s1,s2,eps,
     &                    q1r0,q2r0)
           delff = YIRfof(ame,amW,sprim,s1,s2,eps,q1r0,q2r0)
! New solutions for GMU-scheme - multiplicative correction factor
           rcofa = ALPHAW*ALFINV
! (A) according to RG improved YFS theory
           IF (KeyEWs.EQ.0) THEN
              delff = rcofa*delff
              dosl1 = rcofa*dosl1
! (B) RacoonWW-style: alpha(0) as coefficient for all corrections
           ELSE
              delvs = delvs/rcofa
           ENDIF
! Non-IR contribution
           delt1 = delvs - delff
! Match with LL ISR calculation
           delt1 = delt1 - dosl1 + dell1
         ENDIF
!WP: Switched OFF
!WP! Improved Born Approximation for LEP2
!WP         delap = VSappr(ame,amW,amZ,amt,amH,sprim,s1,s2,eps,q1r0,q2r0)
!WP! Match with LL ISR calculation
!WP         delap = delap - dosl1 + dell1
         IF (KeyCor.EQ.6) delt1 = delap
! Normalization factor
         tr0  = s1 - SQRT(sprim)*( q1r0(4) - q1r0(3) )
         xmbo = TreMat(KeyWga,KeyZga,KeySpn,amW,gaW,amZ,gaZ,sW2,
     &               sprim,tr0,s1,s2,q1r0,q2r0,pf1r0,pf2r0,pf3r0,pf4r0)
         fnor = WtBorn/xmbo
!======================= BETA0 BETA0 BETA0 =============================
! beta0
         beta00 = WtBorn 
         beta01 = beta00*(1 + delt1)
         betl01 = beta00*(1 + dell1)
         beap01 = beta00*(1 + delap)
!======================= BETA1 BETA1 BETA1 =============================
! beta1
         beta10 = 0d0
         betl10 = 0d0
!===================== INITIAL STATE ===================================
! Initial state radiation
         DO i = 1,nphox
           DO k = 1,4
             ph(k) = xphot(i,k)
           ENDDO
           IF (nphot.EQ.1) THEN
              DO k =1,4
                 p1r(k)  = p1(k)
                 p2r(k)  = p2(k)
                 q1r(k)  = q1(k)
                 q2r(k)  = q2(k)
                 phr(k)  = ph(k)
                 pf1r(k) = pf1(k)
                 pf2r(k) = pf2(k)
                 pf3r(k) = pf3(k)
                 pf4r(k) = pf4(k)
              ENDDO
           ELSE 
! Reduction procedure
            CALL RedIn1(s,qq,p1,p2,ph,q1r0,q2r0,pf1r0,pf2r0,pf3r0,pf4r0,
     &                  p1r,p2r,phr,q1r,q2r,pf1r,pf2r,pf3r,pf4r)
         ENDIF
! Some dot products
           p1k = p1r(4)*phr(4) - p1r(3)*phr(3)
           p1k0= p1r(4)*( phr(4) - phr(3) )
           p2k = p2r(4)*phr(4) - p2r(3)*phr(3)
           p2k0= p2r(4)*( phr(4) + phr(3) )
! LL approximations
           z = phr(4)/p1r(4)
           betl1i = z*(z-2)/2 *beta00
!==> Check if ultra-collinear radiation
           colli1 = p1k0/p1r(4)/phr(4)
           colli2 = p2k0/p2r(4)/phr(4)
           colcut = 1d-14
           IF (colli1.LT.colcut .OR. colli2.LT.colcut) THEN
             beta1i = betl1i
           ELSE
! s-reduced
              sired = ( p1r(4) + p2r(4) )**2
! Matrix element for O(alpha) hard photon radiation (massless fermions)
              xmbr = RadMat(KeyWga,KeyZga,KeySpn,amW,gaW,amZ,gaZ,sW2,
     &                   sired,s1,s2,q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
! Mass terms
              xmmt =-(ame2/p1k**2 + ame2/p2k**2)*xmbo
! Total matrix element
              xmat = xmbr + xmmt
              dis1i = xmat *fnor
! Soft factor   
              sfr = SoftFa(sired,ame2,s1,s2,q1r,q2r,phr)
! beta1 O(alpha1)
              beta1i = sprim/sired*dis1i/sfr - beta00
           ENDIF
           beta10 = beta10 + beta1i
! LLA
           betl10 = betl10 + betl1i
         ENDDO
!===================== WW STATE =====================================
! Intermediate WW state radiation
         beta1f = 0
         DO i = 1,nphoy
           DO k = 1,4
             ph(k) = yphot(i,k)
           ENDDO
           IF (nphot.EQ.1) THEN
              DO k =1,4
                 q1r(k)  = q1(k)
                 q2r(k)  = q2(k)
                 phr(k)  = ph(k)
                 pf1r(k) = pf1(k)
                 pf2r(k) = pf2(k)
                 pf3r(k) = pf3(k)
                 pf4r(k) = pf4(k)
              ENDDO
           ELSE 
! Reduction procedure
              CALL RedFi1(s,qq,q1,q2,ph,pf1,pf2,pf3,pf4,
     &             q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
           ENDIF
! Some dot products
           Eel = SQRT(sprim)/2
           Pel = SQRT(Eel**2 - ame2)
           p1k = Eel*phr(4) - Pel*phr(3)
           p1k0= Eel*( phr(4) - phr(3) )
           p2k = Eel*phr(4) + Pel*phr(3)
           p2k0= Eel*( phr(4) + phr(3) )
!==> Check if ultra-collinear radiation
           colli1 = p1k0/Eel/phr(4)
           colli2 = p2k0/Eel/phr(4)
           colcut = 1d-14
           IF (colli1.LT.colcut .OR. colli2.LT.colcut) THEN
! LL approximations (ISR)
              z = phr(4)/Eel
              betl1i = z*(z-2)/2 *beta00
              beta1i = betl1i
           ELSE
! Matrix element for O(alpha) hard photon radiation
              xmbr = RadMat(KeyWga,KeyZga,KeySpn,amW,gaW,amZ,gaZ,sW2,
     &                   sprim,s1,s2,q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
! Mass terms
              xmmt =-(ame2/p1k**2 + ame2/p2k**2)*xmbo
! Total matrix element
              xmat = xmbr + xmmt 
              dis1f = xmat *fnor
! Soft factor   
              sfr = SoftFa(sprim,ame2,s1,s2,q1r,q2r,phr)
! beta1 O(alpha1)
              beta1i = dis1f/sfr - beta00
           ENDIF
           beta10 = beta10 + beta1i
           beta1f = beta1f + beta1i
         ENDDO
!========================================================================
!================ FIXED ORDER, NO EXPONENTIATION ========================
!========================================================================
         xs00 = 0d0
         xs0g = 0d0
         xs1g = 0d0
         xs1l = 0d0
         IF (nphot.EQ.0) THEN
            Fyfs = YFSfmf(p1,p2,q1,q2,ame,amWm,amWp,eps)
            Coul = WTCoul(sprim,s1,s2,amW,GaW)
! Born
            xs00 = beta00 /Fyfs /Coul
! Born + virtual + soft
            xs0g = beta00*( Coul + delt1 + LOG(Fyfs) ) /Fyfs /Coul
         ELSEIF (nphot.EQ.1) THEN
            Fyfs = YFSfmf(p1,p2,q1,q2,ame,amWm,amWp,eps)
            Coul = WTCoul(sprim,s1,s2,amW,GaW)
! 1 real hard photon
            xs1g = xmat/sfr *fnor /Fyfs/Coul *sprim/s
!WP            xs1l = (betl10 + beta00) /Fyfs/Coul *sprim/s   ! LLA
         ENDIF
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!++++++++++++++++++++ WEIGHTS, WEIGHTS, WEIGHTS ++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Principal weights ...
!----------------------------------------------------------------------
! ... O(alpha^1) exact
         WTSET(41) = beta01 + beta10   
! ... O(alpha^1) approximate (for EW virtual corrections)
         WTSET(51) = beap01 + beta10
! ... O(alpha^1) LL ISR
         WTSET(61) = betl01 + betl10
! Individual betas...
!----------------------------------------------------------------------
! ... O(alpha^1) beta01 exact
         WTSET(42) = beta01   
! ... beta10 exact - real photon radiation
         WTSET(43) = beta10 
! ... O(alpha^1) beta01 approx.
         WTSET(52) = beap01 
! ... O(alpha^1) LL ISR beta01 
         WTSET(62) = beta01   
! ... beta10 LL ISR
         WTSET(63) = beta10 
!========================================================================
!================ FIXED ORDER, NO EXPONENTIATION ========================
!========================================================================
! ... Born
         WTSET(65) = xs00
! ... O(alpha^1)
         WTSET(66) = xs0g + xs1g
! ... Born + virtual + soft photon corr.
         WTSET(67) = xs0g
! ... 1 real hard photon
         WTSET(68) = xs1g
!=======================================================================
!***********************************************************************
!* Model weight
         WtMdl = WTSET(41) + wtset(4) - wtset(2)
!***********************************************************************
![[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
!WP: Check for "wild" weights (e.g. due to numerical instabilities)
         wtbad_cut = 2000d0
         wtxx = WTCRU1*WTCRU2*WTSET(41)
         IF (wtxx.GT.wtbad_cut) THEN
            nbadwt = nbadwt + 1
            IF (wtxx.GT.wtbmax) wtbmax = wtxx 
            IF (KeyDia.EQ.1) THEN
              WRITE(*,*)'>>> Model: Bad Weight !!! <<<'
              WRITE(*,*)'nbadwt,wtbad_cut = ',nbadwt,wtbad_cut
              WRITE(*,*)'wtbad,wtbadmax=',wtxx,wtbmax
              WRITE(*,*)'beta00,beta10=',beta00,beta10
              WRITE(*,*)'betl01,beap01=',betl01,beap10
              WRITE(*,*)'beta10,betl10,beta1f=',beta10,betl10,beta1f
              WRITE(*,*)'MW-,MW+    =',amWm,amWp
              WRITE(*,*)'sprim,sos =',sprim,sos
              WRITE(*,*)'nphox,nhpoy =',nphox,nphoy
              CALL dumps(6)
              CALL dumpd(6)
              WRITE(*,*)'>>> Bad Weights Reset to Zero !!! <<<'              
            ENDIF
            WTSET(41) = 0d0
            WTSET(42) = 0d0
            WTSET(43) = 0d0
            WtMdl = wtset(4) 
         ENDIF
!]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
         CALL ewrc_monit(MODE,Idyfs,XCrude,WtCruI,WtCrud,wtset)
         PAR2  = WtMdl          
      ELSE               
*     =================================================================
*     =====================FINAL WEIGHT REPORT=========================
*     =================================================================
         IF (KeyCor.GT.0)
     &      CALL beta_monit(MODE,Idyfs,Xcrude,WtCruI,wtset)
         IF (KeyCor.GE.5)
     &      CALL ewrc_monit(MODE,Idyfs,XCrude,WtCruI,WtCrud,wtset)
      ENDIF              
!     =====              
      END 
  
      FUNCTION WtBoWW(KeyCor,amW,GaW,sp,s1,s2,pf1,pf2,pf3,pf4)
*     ********************************************************
!--------------------------------------------------------------
! Born-level CC03 matrix element 
! INPUT: KeyCor - Rad. Corr. switch
!        sp - effective CMS energy squared (after ISR)
!        amW, GaW - mass and width of W-boson
!        s1,s2 - squared invariant masses of W- and W+, resp.
!        pf1,pf2,pf3,pf4 - 4-momenta of final state fermions
!                          (should be massless here)
!--------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(PI=3.1415926535897932D0)
      COMMON / phypar / alfinv,gpicob
      SAVE   / phypar /
!WP: For tests only (needed only when routine WWBoMe is used) 
!WP      COMMON / cms_eff_momdec /
!WP     $      effbeam1(4),effbeam2(4),effp1(4),effp2(4),effp3(4),effp4(4)
!WP      SAVE / cms_eff_momdec /
      DIMENSION pf1(4),pf2(4),pf3(4),pf4(4)
      COMMON / BornTp / WtBorn 
      SAVE   / BornTp /
!
*-- Born level flux factor 1/2s'
      FluxF = 1d0/(2d0*sp)
*--- WW Born matrix element (for massless fermion 4-momenta)
      WtBorn = WWBoml(pf1,pf2,pf3,pf4)
!WP: Equivalent calculation with different reduction procedure 
!WP      WtBorn = WWBoME(effp1,effp2,effp3,effp4)
!WP: KoralW-like kinematics
!WP      CALL KineKW
      WtBoWW = gpicob *FluxF*WtBorn
      END

      SUBROUTINE beta_monit(mode,idyfs,xcrude,wtkarl,wtset)
!     *****************************************************
! beta functions related tests
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      COMMON / matpar / pi,ceuler
      COMMON / phypar / alfinv,gpicob
 
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g

      COMMON / inout  / ninp,nout

      DIMENSION wtset(*)

      IF(mode .EQ. -1) THEN
* Totals O(alf0-alf3)
         DO k=10,14
            CALL gmonit(-1,idyfs+k,0d0,1d0,1d0) ! 10-14
         ENDDO
* Betas O(alf0-alf3) and differences
         DO k=20,38
            CALL gmonit(-1,idyfs+k,0d0,1d0,1d0) ! 20-38
         ENDDO
      ELSEIF(mode .EQ. 0) THEN
*     Totals O(alf0-alf3)
         DO k=1,4
            CALL gmonit(0,idyfs+10+k,wtkarl*wtset(k),1d0,1d0)
         ENDDO
* Betas O(alf0-alf3)
         DO k=10,19
            CALL gmonit(0,idyfs+10+k,wtkarl*wtset(k),1d0,1d0)
         ENDDO
* Differences total O(alf0-alf3)
         CALL gmonit(0,idyfs+30,wtkarl*(wtset(2)-wtset(1)),1d0,1d0)
         CALL gmonit(0,idyfs+31,wtkarl*(wtset(3)-wtset(2)),1d0,1d0)
         CALL gmonit(0,idyfs+32,wtkarl*(wtset(4)-wtset(3)),1d0,1d0)
* bt01-bt00, bt10
         CALL gmonit(0,idyfs+33,wtkarl*(wtset(11)-wtset(10)),1d0,1d0)
* bt02-bt01, bt11-bt10, bt20
         CALL gmonit(0,idyfs+34,wtkarl*(wtset(13)-wtset(11)),1d0,1d0)
         CALL gmonit(0,idyfs+35,wtkarl*(wtset(14)-wtset(12)),1d0,1d0)
* bt03-bt02, bt12-bt11, bt21-bt20,bt30
         CALL gmonit(0,idyfs+36,wtkarl*(wtset(16)-wtset(13)),1d0,1d0)
         CALL gmonit(0,idyfs+37,wtkarl*(wtset(17)-wtset(14)),1d0,1d0)
         CALL gmonit(0,idyfs+38,wtkarl*(wtset(18)-wtset(15)),1d0,1d0)
      ELSE
        WRITE(nout,bxope)
        WRITE(nout,bxtxt) '         YFSWW3  final  report '
        WRITE(nout,bxtxt) '               Window B:       '
        WRITE(nout,bxtxt) '                  ISR          '
        WRITE(nout,bxtxt) '                               '
*****************************************************************
*****************************************************************
        CALL gmonit(1,idyfs+11,averwt,errela,evtot)
        xstot0   = xcrude*averwt
        ertot0   = xstot0*errela
        WRITE(nout,bxl2f) xstot0,ertot0,'xsec total    ','O(alf0)','B1'
*****************************************************************
        CALL gmonit(1,idyfs+12,averwt,errela,evtot)
        xstot1   = xcrude*averwt
        ertot1   = xstot1*errela
        WRITE(nout,bxl2f) xstot1,ertot1,'xsec total    ','O(alf1)','B2'
*****************************************************************
        CALL gmonit(1,idyfs+13,averwt,errela,evtot)
        xstot2   = xcrude*averwt
        ertot2   = xstot2*errela
        WRITE(nout,bxl2f) xstot2,ertot2,'xsec total    ','O(alf2)','B3'
*****************************************************************
        CALL gmonit(1,idyfs+14,averwt,errela,evtot)
        xstot3   = xcrude*averwt
        ertot3   = xstot3*errela
        WRITE(nout,bxl2f) xstot3,ertot3,'xsec total    ','O(alf3)','B4'
*****************************************************************
!WP        CALL gmonit(2,idyfs+11,evacc1,evneg1,evove1)
!WP        CALL gmonit(2,idyfs+12,evacc2,evneg2,evove2)
!WP        CALL gmonit(2,idyfs+13,evacc3,evneg3,evove3)
!WP        CALL gmonit(2,idyfs+14,evacc4,evneg4,evove4)
!WP        neg0=evneg1
!WP        neg1=evneg2
!WP        neg2=evneg3
!WP        neg3=evneg4
!WP        WRITE(nout,bxl1i) neg0,         'wt<0  events  ','O(alf0)',' '
!WP        WRITE(nout,bxl1i) neg1,         'wt<0  events  ','O(alf1)',' '
!WP        WRITE(nout,bxl1i) neg2,         'wt<0  events  ','O(alf2)',' '
!WP        WRITE(nout,bxl1i) neg2,         'wt<0  events  ','O(alf3)',' '
*****************************************************************
        CALL gmonit(1,idyfs+20,averwt,errela,evtot)
        xsbt00   = xcrude*averwt
        erbt00   = xsbt00*errela
        WRITE(nout,bxl2f) xsbt00,erbt00,'xsec(beta00)  ','O(alf0)','B5'
*****************************************************************
        CALL gmonit(1,idyfs+21,averwt,errela,evtot)
        xsbt01   = xcrude*averwt
        erbt01   = xsbt01*errela
        WRITE(nout,bxl2f) xsbt01,erbt01,'xsec(beta01)  ','O(alf1)','B6'
*****************************************************************
        CALL gmonit(1,idyfs+22,averwt,errela,evtot)
        xsbt10   = xcrude*averwt
        erbt10   = xsbt10*errela
        WRITE(nout,bxl2f) xsbt10,erbt10,'xsec(beta10)  ','O(alf1)','B7'
*****************************************************************
        CALL gmonit(1,idyfs+23,averwt,errela,evtot)
        xsbt02   = xcrude*averwt
        erbt02   = xsbt02*errela
        WRITE(nout,bxl2f) xsbt02,erbt02,'xsec(beta02)  ','O(alf2)','B8'
*****************************************************************
        CALL gmonit(1,idyfs+24,averwt,errela,evtot)
        xsbt11   = xcrude*averwt
        erbt11   = xsbt11*errela
        WRITE(nout,bxl2f) xsbt11,erbt11,'xsec(beta11)  ','O(alf2)','B9'
*****************************************************************
        CALL gmonit(1,idyfs+25,averwt,errela,evtot)
        xsbt20   = xcrude*averwt
        erbt20   = xsbt20*errela
        WRITE(nout,bxl2f) xsbt20,erbt20,'xsec(beta20)  ','O(alf2)','B10'
*****************************************************************
*****************************************************************
        CALL gmonit(1,idyfs+26,averwt,errela,evtot)
        xsbt03   = xcrude*averwt
        erbt03   = xsbt20*errela
        WRITE(nout,bxl2f) xsbt03,erbt03,'xsec(beta03)  ','O(alf3)','B11'
*****************************************************************
        CALL gmonit(1,idyfs+27,averwt,errela,evtot)
        xsbt12   = xcrude*averwt
        erbt12   = xsbt20*errela
        WRITE(nout,bxl2f) xsbt12,erbt12,'xsec(beta12)  ','O(alf3)','B12'
*****************************************************************
        CALL gmonit(1,idyfs+28,averwt,errela,evtot)
        xsbt21   = xcrude*averwt
        erbt21   = xsbt20*errela
        WRITE(nout,bxl2f) xsbt21,erbt21,'xsec(beta21)  ','O(alf3)','B13'
*****************************************************************
        CALL gmonit(1,idyfs+29,averwt,errela,evtot)
        xsbt30   = xcrude*averwt
        erbt30   = xsbt20*errela
        WRITE(nout,bxl2f) xsbt30,erbt30,'xsec(beta30)  ','O(alf3)','B14'
*****************************************************************
        WRITE(nout,bxtxt) ' xsec_tot differences '
*****************************************************************
        CALL gmonit(1,idyfs+30,averwt,errela,evtot)
        xsdel1   = xcrude*averwt
        erdel1   = xsdel1*errela
        CALL gmonit(1,idyfs+31,averwt,errela,evtot)
        xsdel2   = xcrude*averwt
        erdel2   = xsdel2*errela
        CALL gmonit(1,idyfs+32,averwt,errela,evtot)
        xsdel3   = xcrude*averwt
        erdel3   = xsdel3*errela
        WRITE(nout,bxl2f) xsdel1,erdel1,'xstot(alf1-0)','O(alf1)','B15'
        WRITE(nout,bxl2f) xsdel2,erdel2,'xstot(alf2-1)','O(alf2)','B16'
        WRITE(nout,bxl2f) xsdel3,erdel3,'xstot(alf3-2)','O(alf3)','B17'
*****************************************************************
        WRITE(nout,bxtxt) ' betas differences '
*****************************************************************
        CALL gmonit(1,idyfs+33,averwt,errela,evtot)
        xsdt01   = xcrude*averwt
        erdt01   = xsdt01*errela
        WRITE(nout,bxl2f) xsdt01,erdt01,'xs(beta01-00)','O(alf1)','B18'
        WRITE(nout,bxl2f) xsbt10,erbt10,'xs(beta10)   ','O(alf1)','B19'
*****************************************************************
        CALL gmonit(1,idyfs+34,averwt,errela,evtot)
        xsdt02   = xcrude*averwt
        erdt02   = xsdt02*errela
        CALL gmonit(1,idyfs+35,averwt,errela,evtot)
        xsdt11   = xcrude*averwt
        erdt11   = xsdt11*errela
        WRITE(nout,bxl2f) xsdt02,erdt02,'xs(beta02-01)','O(alf2)','B20'
        WRITE(nout,bxl2f) xsdt11,erdt11,'xs(beta11-10)','O(alf2)','B21'
        WRITE(nout,bxl2f) xsbt20,erbt20,'xs(beta20)   ','O(alf2)','B22'
*****************************************************************
        CALL gmonit(1,idyfs+36,averwt,errela,evtot)
        xsdt03   = xcrude*averwt
        erdt03   = xsdt03*errela
        CALL gmonit(1,idyfs+37,averwt,errela,evtot)
        xsdt12   = xcrude*averwt
        erdt12   = xsdt12*errela
        CALL gmonit(1,idyfs+38,averwt,errela,evtot)
        xsdt21   = xcrude*averwt
        erdt21   = xsdt21*errela
        WRITE(nout,bxl2f) xsdt03,erdt03,'xs(beta03-02)','O(alf3)','B23'
        WRITE(nout,bxl2f) xsdt12,erdt12,'xs(beta12-11)','O(alf3)','B24'
        WRITE(nout,bxl2f) xsdt21,erdt21,'xs(beta21-20)','O(alf3)','B25'
        WRITE(nout,bxl2f) xsbt30,erbt30,'xs(beta30)   ','O(alf3)','B26'
*****************************************************************
        WRITE(nout,bxclo)
      ENDIF
      END

      SUBROUTINE ewrc_monit(mode,idyfs,XCrude,WtCruI,WtCrud,wtset)
!     ************************************************************
! beta functions related tests
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g

      COMMON / inout  / ninp,nout

      DIMENSION wtset(*)

      IF(mode .EQ. -1) THEN
* Total x-sections O(alf1): EW-ex, EW-ap, LL
         DO k=111,113
            CALL gmonit(-1,idyfs+k,0d0,1d0,1d0) ! 10-14
         ENDDO
* Differences
         DO k=121,125
            CALL gmonit(-1,idyfs+k,0d0,1d0,1d0) ! 20-38
         ENDDO
      ELSEIF(mode .EQ. 0) THEN
* Total x-sections O(alf1): EW-ex, EW-ap, LL
         WtBest = WtCrud*wtset(41)
         WtAppr = WtCrud*wtset(51)
         WtISR1 = WtCruI*wtset( 2)
         CALL gmonit(0,idyfs+111,WtBest,1d0,1d0)
         CALL gmonit(0,idyfs+112,WtAppr,1d0,1d0)
         CALL gmonit(0,idyfs+113,WtISR1 ,1d0,1d0)
* Differences total O(alf1): EW-ex - EW-ap, EW-ex - LL
         CALL gmonit(0,idyfs+121,WtCrud*(wtset(41)-wtset(51)),1d0,1d0)
         CALL gmonit(0,idyfs+122,WtBest - WtISR1,1d0,1d0)
* Differences beta0 O(alf1): EW-ex - EW-ap, EW-ex - LL
         CALL gmonit(0,idyfs+123,WtCrud*(wtset(42)-wtset(52)),1d0,1d0)
         CALL gmonit(0,idyfs+124,WtCrud*(wtset(42)-wtset(11)),1d0,1d0)
* Differences beta1 O(alf1): EW-ex - LL
         CALL gmonit(0,idyfs+125,WtCrud*(wtset(43)-wtset(12)),1d0,1d0)
      ELSE
        WRITE(nout,bxope)
        WRITE(nout,bxtxt) '         YFSWW3  final  report '
        WRITE(nout,bxtxt) '               Window C:       '
        WRITE(nout,bxtxt) '       O(alf1) EWRC in WW-prod.'
        WRITE(nout,bxtxt) '                               '
*****************************************************************
*****************************************************************
        CALL gmonit(1,idyfs+111,averwt,errela,evtot)
        xstote   = xcrude*averwt
        ertote   = xstote*errela
        WRITE(nout,bxl2f) xstote,ertote,'xs_tot: EW-ex ','O(alf1)','C1'
*****************************************************************
        CALL gmonit(1,idyfs+112,averwt,errela,evtot)
        xstota   = xcrude*averwt
        ertota   = xstota*errela
        WRITE(nout,bxl2f) xstota,ertota,'xs_tot: EW-ap ','O(alf1)','C2'
*****************************************************************
        CALL gmonit(1,idyfs+113,averwt,errela,evtot)
        xstotl   = xcrude*averwt
        ertotl   = xstotl*errela
        WRITE(nout,bxl2f) xstotl,ertotl,'xs_tot: ISR-LL','O(alf1)','C3'
*****************************************************************
        WRITE(nout,bxtxt) ' xsec_tot differences '
*****************************************************************
        CALL gmonit(1,idyfs+121,averwt,errela,evtot)
        xsdela   = xcrude*averwt
        erdela   = xsdela*errela
        CALL gmonit(1,idyfs+122,averwt,errela,evtot)
        xsdell   = xcrude*averwt
        erdell   = xsdell*errela
        WRITE(nout,bxl2f) xsdela,erdela,'EW-ex - EW-ap ','O(alf1)','C4'
        WRITE(nout,bxl2f) xsdell,erdell,'EW-ex - ISR-LL','O(alf1)','C5'
*****************************************************************
        WRITE(nout,bxtxt) ' betas differences '
*****************************************************************
        CALL gmonit(1,idyfs+123,averwt,errela,evtot)
        xdt01a   = xcrude*averwt
        edt01a   = xdt01a*errela
        CALL gmonit(1,idyfs+124,averwt,errela,evtot)
        xdt01l   = xcrude*averwt
        edt01l   = xdt01l*errela
        CALL gmonit(1,idyfs+125,averwt,errela,evtot)
        xdt10l   = xcrude*averwt
        edt10l   = xdt10l*errela
        WRITE(nout,bxl2f) xdt01a,edt01a,'bet01(ex - ap)','O(alf1)','C6'
        WRITE(nout,bxl2f) xdt01l,edt01l,'bet01(ex - LL)','O(alf1)','C7'
        WRITE(nout,bxl2f) xdt10l,edt10l,'bet10(ex - LL)','O(alf1)','C8'
*****************************************************************
        WRITE(nout,bxclo)
      ENDIF
      END

      SUBROUTINE DecRed(xm1,xm2,q1,q2,pf1,pf2,pf3,pf4)
!     ************************************************
!----------------------------------------------------------------------!
! Kinematics of WW-decays, i.e. calculation of final state fermion     !
! MASSLESS 4-momenta (pf1,pf2) and (pf3,pf4) coming from W- of         !
! 4-momentum q1 and mass xm1, and W+ of 4-momentum q2 and mass xm2,    !
! resp., for matrix element calculations.                              !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, July 1996  !
! Last update: 23.08.1999           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER ( pi = 3.1415926535897932D0 )
      DIMENSION q1(4),q2(4),pf1(4),pf2(4),pf3(4),pf4(4)
      DIMENSION h(4)
! Angles from Born-level presampler
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWANGL /
!
! Angular variables
      f1 = fi1n
      f2 = fi2n
      c1 = ct1n
      c2 = ct2n
! Construct pf1 in rest frame of W-
      s1s = MAX(0d0,(1d0 - c1)*(1d0 + c1))
      s1 = SQRT(s1s)
      hv = 0.5*xm1
      h(4) = hv
      h(3) = hv*c1
      h(2) = hv*s1*COS(f1)
      h(1) = hv*s1*SIN(f1)
! Boost vector h to its LAB frame value pf1
      CALL bostdq(-1,q1,h,pf1)
! Construct pf2 from momentum conservation
      DO k = 1,4
        pf2(k) = q1(k) - pf1(k)
      ENDDO
! Construct pf3 in rest frame of W+ 
      s2s = MAX(0d0,(1d0 - c2)*(1d0 + c2))
      s2 = SQRT(s2s)
      hv = 0.5*xm2
      h(4) = hv
      h(3) = hv*c2
      h(2) = hv*s2*COS(f2)
      h(1) = hv*s2*SIN(f2)
! Boost vector h to its LAB frame value pf3
      CALL bostdq(-1,q2,h,pf3)
! Construct pf4 from momentum conservation
      DO k = 1,4
        pf4(k) = q2(k) - pf3(k)
      ENDDO
      END

      SUBROUTINE Redbe0(qq,q1,q2,pf1,pf2,pf3,pf4,
     &                  q1r,q2r,pf1r,pf2r,pf3r,pf4r)
!     **********************************************
!----------------------------------------------------------------------!
! Reduction procedure for beta0 (Born-like process).                   !
! INPUT: qq -- effective 4-momentum at the interaction point, i.e.     !
!              sum of effective beams 4-momenta (after initial state   !
!              photon radiation)                                       !
!        q1,q2 -- 4-momenta of W- and W+, resp.                        !
!        pf1,pf2,pf3,pf4 -- 4-momenta of W-, W+ decay products, resp.  !
! OUPUT: q1r,q2r,pf1r,pf2r,pf3r,pf4r - respective reduced 4-momenta    !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                    Knoxville, Aug. 1996  !
! Last update: 14.08.1996           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      PARAMETER (eps1 = 1d-15)
      REAL*8 qq(4),q1(4),q2(4),pf1(4),pf2(4),pf3(4),pf4(4)
      REAL*8 q1r(4),q2r(4),pf1r(4),pf2r(4),pf3r(4),pf4r(4)
      REAL*8 pp(4),ppx(4)
!
      DO k = 1,4
        pp(k) = q1(k) + q2(k)
      ENDDO
      rpp = (pp(1)**2 + pp(2)**2 + pp(3)**2)/pp(4)**2
      IF (rpp.GT.eps1) THEN
! Transform all momnenta to qq rest-frame
        CALL bostdq( 1,qq,q1,q1r)
        CALL bostdq( 1,qq,q2,q2r)      
        CALL bostdq( 1,qq,pf1,pf1r)
        CALL bostdq( 1,qq,pf2,pf2r)         
        CALL bostdq( 1,qq,pf3,pf3r)
        CALL bostdq( 1,qq,pf4,pf4r)
        CALL bostdq( 1,qq,pp,ppx)  
! Transform all momnenta to pp rest-frame
        rppx = (ppx(1)**2 + ppx(2)**2 + ppx(3)**2)/ppx(4)**2
        IF (rppx.GT.eps1) THEN
          CALL bostdq( 1,ppx,q1r,q1r)
          CALL bostdq( 1,ppx,q2r,q2r)         
          CALL bostdq( 1,ppx,pf1r,pf1r)
          CALL bostdq( 1,ppx,pf2r,pf2r)         
          CALL bostdq( 1,ppx,pf3r,pf3r)
          CALL bostdq( 1,ppx,pf4r,pf4r)
        ENDIF
      ELSE             
! Do nothing if already in pp rest-frame              
        DO k = 1,4   
          q1r(k)  = q1(k)                  
          q2r(k)  = q2(k)
          pf1r(k) = pf1(k)
          pf2r(k) = pf2(k)
          pf3r(k) = pf3(k)
          pf4r(k) = pf4(k)
        ENDDO
      ENDIF            
! Construct reduced momenta (they are understood to be in qq rest-frame)
      s1 = qq(4)**2 - qq(3)**2 - qq(2)**2 - qq(1)**2
      s2 = pp(4)**2 - pp(3)**2 - pp(2)**2 - pp(1)**2
      vv = 1d0 - s2/s1
      IF (ABS(vv).GT.eps1) THEN
! Boost decay products 4-momenta to their decay rest frames
        CALL bostdq( 1,q1r,pf1r,pf1r)
        CALL bostdq( 1,q1r,pf2r,pf2r)         
        CALL bostdq( 1,q2r,pf3r,pf3r)
        CALL bostdq( 1,q2r,pf4r,pf4r)
! Construct reduced momenta of W-,W+
        am1s  = q1(4)**2 - q1(3)**2 - q1(2)**2 - q1(1)**2
        am2s  = q2(4)**2 - q2(3)**2 - q2(2)**2 - q2(1)**2
        qxmod = SQRT(q1r(1)**2 + q1r(2)**2 + q1r(3)**2)
        qsm1  = SQRT(s1)
        q1r(4) = (s1 + am1s - am2s)/(2*qsm1)
        qrmod  = SQRT(q1r(4)**2 - am1s)
        q2r(4) = qsm1 - q1r(4)
        DO k = 1,3
          q1r(k) = q1r(k)/qxmod*qrmod
          q2r(k) = q2r(k)/qxmod*qrmod
        ENDDO
! Boost decay products 4-momenta to qq-rest frame 
        CALL bostdq(-1,q1r,pf1r,pf1r)
        CALL bostdq(-1,q1r,pf2r,pf2r)         
        CALL bostdq(-1,q2r,pf3r,pf3r)
        CALL bostdq(-1,q2r,pf4r,pf4r) 
      ENDIF
      END

      SUBROUTINE RedIn1(s,qq,p1,p2,ph,q1,q2,pf1,pf2,pf3,pf4,
     &                  p1r,p2r,phr,q1r,q2r,pf1r,pf2r,pf3r,pf4r)
!     **********************************************************
!----------------------------------------------------------------------!
! Reduction procedure for beta1 (2-->3 -like process) in a case of     !
! initial state radiation.                                             !
! INPUT: s  -- CMS energy squared                                      !
!        qq -- effective 4-momentum at the interaction point, i.e.     !
!              sum of effective beams 4-momenta (after initial state   !
!              photon radiation)                                       !
!        p1,p2,ph -- 4-momenta of e-, e+ and photon resp.              !
!        q1,q2 -- 4-momenta of W-,W+ from Redbe0                       !
!        pf1,pf2,pf3,pf4 -- 4-momenta of W-,W+ decay products          !
!                           from Redbe0                                !
! OUPUT: p1r,p2r,phr,q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r -- respective     !
!                                                    reduced 4-momenta !
! Note: Before using this routine the subroutine Redbe0 must be called.!
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                    Knoxville, Aug. 1996  !
! Last update: 21.03.1997           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      PARAMETER (eps1 = 1d-15)
      REAL*8 qq(4),p1(4),p2(4),ph(4),p1r(4),p2r(4),phr(4)
      REAL*8 q1(4),q2(4),pf1(4),pf2(4),pf3(4),pf4(4)
      REAL*8 q1r(4),q2r(4),pf1r(4),pf2r(4),pf3r(4),pf4r(4)
      REAL*8 pp(4)
!
! Reduce e-,e+ and photon 4-momenta
      CALL REDUZ1(qq,p1,p2,ph,p1r,p2r,phr)        
      DO k = 1,4
        pp(k)   = p1r(k) + p2r(k)
        q1r(k)  = q1(k)
        q2r(k)  = q2(k)
        pf1r(k) = pf1(k)
        pf2r(k) = pf2(k)
        pf3r(k) = pf3(k)
        pf4r(k) = pf4(k)
      ENDDO
      CALL boost9(pp,p1r,p2r,q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
      CALL rotat9(p1r,p2r,q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
      END

      SUBROUTINE RedFi1(s,qq,q1,q2,ph,pf1,pf2,pf3,pf4,
     &                  q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r)
!     **************************************************
!----------------------------------------------------------------------!
! Reduction procedure for beta1 (2-->3 -like process) in a case of     !
! final state radiation.                                               !
! INPUT: s  -- CMS energy squared                                      !
!        qq -- effective 4-momentum at the interaction point, i.e.     !
!              sum of effective beams 4-momenta (after initial state   !
!              photon radiation)                                       !
!        q1,q2,ph -- 4-momenta of W-, W+ and photon resp.              !
!        pf1,pf2,pf3,pf4 -- 4-momenta of W-, W+ decay products, resp.  !
! OUPUT: q1r,q2r,phr,pf1r,pf2r,pf3r,pf4r - respective reduced 4-momenta!
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                    Knoxville, Aug. 1996  !
! Last update: 14.08.1996           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      PARAMETER (eps1 = 1d-15)
      REAL*8 qq(4),q1(4),q2(4),ph(4),pf1(4),pf2(4),pf3(4),pf4(4)
      REAL*8 q1r(4),q2r(4),phr(4),pf1r(4),pf2r(4),pf3r(4),pf4r(4)
      REAL*8 pp(4),ppx(4),ppk(4),qqk(4)
!
      DO k = 1,4
        pp(k)  = q1(k) + q2(k)
        ppk(k) = pp(k) + ph(k)
        qqk(k) = qq(k) - ph(k) 
      ENDDO
      sv  = pp(4)**2 - pp(3)**2 - pp(2)**2 - pp(1)**2
      sv1 = qq(4)**2 - qq(3)**2 - qq(2)**2 - qq(1)**2
      ss1 = ppk(4)**2 - ppk(3)**2 - ppk(2)**2 - ppk(1)**2
      ss2 = qqk(4)**2 - qqk(3)**2 - qqk(2)**2 - qqk(1)**2
      rpp = (pp(1)**2 + pp(2)**2 + pp(3)**2)/pp(4)**2
      IF (rpp.GT.eps1) THEN
! Transform all momnenta to qq rest-frame
        CALL bostdq( 1,qq,q1,q1r)
        CALL bostdq( 1,qq,q2,q2r)     
        CALL bostdq( 1,qq,ph,phr)      
        CALL bostdq( 1,qq,pf1,pf1r)
        CALL bostdq( 1,qq,pf2,pf2r)         
        CALL bostdq( 1,qq,pf3,pf3r)
        CALL bostdq( 1,qq,pf4,pf4r)
        CALL bostdq( 1,qq,pp,ppx)      
! Transform all momnenta to pp rest-frame
        CALL bostdq( 1,ppx,q1r,q1r)
        CALL bostdq( 1,ppx,q2r,q2r)   
        CALL bostdq( 1,ppx,phr,phr)         
        CALL bostdq( 1,ppx,pf1r,pf1r)
        CALL bostdq( 1,ppx,pf2r,pf2r)         
        CALL bostdq( 1,ppx,pf3r,pf3r)
        CALL bostdq( 1,ppx,pf4r,pf4r)
      ELSE             
! Do nothing if already in pp rest-frame              
        DO k = 1,4 
          q1r(k)  = q1(k)                  
          q2r(k)  = q2(k)
          phr(k)  = ph(k)
          pf1r(k) = pf1(k)
          pf2r(k) = pf2(k)
          pf3r(k) = pf3(k)
          pf4r(k) = pf4(k)
        ENDDO
      ENDIF            
! Construct reduced momenta (they are understood to be in qq rest-frame)
      vv = 1d0 - sv/ss2
      IF (ABS(vv).GT.eps1) THEN
! Boost decay products 4-momenta to their decay rest frames
        CALL bostdq( 1,q1r,pf1r,pf1r)
        CALL bostdq( 1,q1r,pf2r,pf2r)         
        CALL bostdq( 1,q2r,pf3r,pf3r)
        CALL bostdq( 1,q2r,pf4r,pf4r)
! Construct reduced momenta of W-,W+,gamma
        xlam = SQRT(sv1/ss1)
        am1s  = q1(4)**2 - q1(3)**2 - q1(2)**2 - q1(1)**2
        am2s  = q2(4)**2 - q2(3)**2 - q2(2)**2 - q2(1)**2
        qxmod = SQRT(q1r(1)**2 + q1r(2)**2 + q1r(3)**2)        
        qsm1   = ( q1r(4) + q2r(4) )*xlam
        q1r(4) = (qsm1**2 + am1s - am2s)/(2*qsm1)
        qrmod  = SQRT(q1r(4)**2 - am1s)
        q2r(4) = qsm1 - q1r(4)
        phr(4) = phr(4)*xlam
        DO k = 1,3
          q1r(k) = q1r(k)/qxmod*qrmod
          q2r(k) = q2r(k)/qxmod*qrmod
          phr(k) = phr(k)*xlam
        ENDDO
! Boost decay products 4-momenta to pp-rest frame 
        CALL bostdq(-1,q1r,pf1r,pf1r)
        CALL bostdq(-1,q1r,pf2r,pf2r)         
        CALL bostdq(-1,q2r,pf3r,pf3r)
        CALL bostdq(-1,q2r,pf4r,pf4r) 
      ENDIF
! Then, boost away the three-vector part of q1+q2+ph,
! that is transform to qq rest frame
      DO k = 1,4
        pp(k) = q1r(k) + q2r(k) + phr(k)
      ENDDO
      CALL bostdq( 1,pp,q1r,q1r)
      CALL bostdq( 1,pp,q2r,q2r)   
      CALL bostdq( 1,pp,phr,phr)         
      CALL bostdq( 1,pp,pf1r,pf1r)
      CALL bostdq( 1,pp,pf2r,pf2r)         
      CALL bostdq( 1,pp,pf3r,pf3r)
      CALL bostdq( 1,pp,pf4r,pf4r)
      END

      SUBROUTINE boost9(qq,p1,p2,p3,p4,p5,p6,p7,p8,p9)
!     ************************************************
!---------------------------------------------------------------!
! Boost of the 4-vectors p1,p2,p3,p4,p5 to the rest frame of qq.!
!---------------------------------------------------------------!
! Written by: Wieslaw Placzek              Knoxville, May 1995  !
! Last update: 14.08.1996           by: W.P.                    !
!---------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      REAL*8 qq(4),p1(4),p2(4),p3(4),p4(4),p5(4)
      REAL*8 p6(4),p7(4),p8(4),p9(4)
      CALL bostdq( 1,qq,p1,p1)
      CALL bostdq( 1,qq,p2,p2)
      CALL bostdq( 1,qq,p3,p3)
      CALL bostdq( 1,qq,p4,p4)
      CALL bostdq( 1,qq,p5,p5)
      CALL bostdq( 1,qq,p6,p6)
      CALL bostdq( 1,qq,p7,p7)
      CALL bostdq( 1,qq,p8,p8)
      CALL bostdq( 1,qq,p9,p9)
      END

      SUBROUTINE rotat9(p1,q1,p2,q2,pk,pf1,pf2,pf3,pf4)
!     *************************************************
!---------------------------------------------------------------!
! Rotation of the 4-vectors p1,q1,p2,q2,pk given in the rest    ! 
! frame of p1+q1 such that the resulting vector p1 points along !
! the +z axis.                                                  !
!---------------------------------------------------------------!
! Written by: Wieslaw Placzek              Knoxville, May 1995  !
! Last update: 14.08.1996           by: W.P.                    !
!---------------------------------------------------------------! 
      IMPLICIT REAL*8 (a-h,o-z)
      PARAMETER ( pi = 3.1415926535897932d0 )
      REAL*8 p1(4),q1(4),p2(4),q2(4),pk(4)
      REAL*8 pf1(4),pf2(4),pf3(4),pf4(4)
!
      p1m = SQRT( p1(1)**2 + p1(2)**2 + p1(3)**2 )
      p1t = SQRT( p1(1)**2 + p1(2)**2 ) 
      IF (p1t/p1m.GT.1d-15) THEN
        phi = angfi(p1(1),p1(2))
        CALL rotod3(-phi,p2,p2)
        CALL rotod3(-phi,q2,q2)
        CALL rotod3(-phi,pk,pk)
        CALL rotod3(-phi,pf1,pf1)
        CALL rotod3(-phi,pf2,pf2)
        CALL rotod3(-phi,pf3,pf3)
        CALL rotod3(-phi,pf4,pf4)
      ENDIF
      the = ACOS(p1(3)/p1m) 
      CALL rotod2(-the,p2,p2)
      CALL rotod2(-the,q2,q2)
      CALL rotod2(-the,pk,pk)
      CALL rotod2(-the,pf1,pf1)
      CALL rotod2(-the,pf2,pf2)
      CALL rotod2(-the,pf3,pf3)
      CALL rotod2(-the,pf4,pf4)
      p1(3) = p1m
      p1(2) = 0
      p1(1) = 0
      q1(3) =-p1m
      q1(2) = 0
      q1(1) = 0
      END

      SUBROUTINE REDUZ1(QQ,P1,P2,PH,PR1,PR2,PHR)             
C     ******************************************             
C reduction of 4-momenta for beta1        
C           P1,P2,PH ==--> PR1,PR2,PHR    
C such that  PR1+PR2 = QQ+PHR             
C     *********************************** 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      PARAMETER( EPS1 =1D-15)                   
      COMMON / INOUT  / NINP,NOUT   
      SAVE   / INOUT  /
      DIMENSION QQ(4), P1(4), P2(4), PH(4), PR1(4),PR2(4),PHR(4)
      DIMENSION PP(4),QQK(4),PPX(4), PPK(4)                  
      DIMENSION PX1(4),PX2(4),PHX(4)      
C   
      DO 20 K=1,4      
      PP(K)   = P1(K)+P2(K)               
      PPK(K)  = P1(K)+P2(K)-PH(K)         
 20   QQK(K)  = QQ(K)+PH(K)               
      SVAR  =  PP(4)**2 -PP(3)**2 -PP(2)**2 -PP(1)**2        
      SVAR1 =  QQ(4)**2 -QQ(3)**2 -QQ(2)**2 -QQ(1)**2        
      SS1   = PPK(4)**2-PPK(3)**2-PPK(2)**2-PPK(1)**2        
      SS2   = QQK(4)**2-QQK(3)**2-QQK(2)**2-QQK(1)**2        
      IF((PP(1)**2+PP(2)**2+PP(3)**2)/PP(4)**2 .GT. EPS1) THEN
C transform all momenta to QQ rest-frame  
         CALL BOSTDQ( 1,QQ,P1 ,PX1)       
         CALL BOSTDQ( 1,QQ,P2 ,PX2)       
         CALL BOSTDQ( 1,QQ,PH ,PHX)       
         CALL BOSTDQ( 1,QQ,PP ,PPX)       
C transform all momenta to PP rest-frame  
         CALL BOSTDQ( 1,PPX,PX1,PX1)      
         CALL BOSTDQ( 1,PPX,PX2,PX2)      
         CALL BOSTDQ( 1,PPX,PHX,PHX)      
      ELSE             
C do nothing if we are already in PP rest-frame              
         DO 23 K=1,4   
            PHX(K)=PH(K)                  
            PX1(K)=P1(K)                  
   23       PX2(K)=P2(K)                  
      ENDIF            
C construct reduced beam momenta PR1,PR2  
C note: they are understood to be in QQ rest-frame           
      VV2   = 1D0 - SS2/SVAR              
      IF(ABS(VV2).GT. EPS1) THEN          
!WP         PK    =  (PX1(4)+PX2(4))*PHX(4)  
CCCCC    XLAM= SQRT(SVAR1/SVAR+(PK/SVAR)**2)+PK/SVAR         
         XLAM= SQRT(SVAR1/SS1)            
!WP         AMEL2=  P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2 
         am1s = P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2
         am2s = P2(4)**2-P2(3)**2-P2(2)**2-P2(1)**2                 
         PXMOD = SQRT(PX1(1)**2+PX1(2)**2+PX1(3)**2)         
         PX1(4)= PX1(4)*XLAM              
         PX2(4)= PX2(4)*XLAM              
CCC      PRMOD = SQRT(PX1(4)**2-AMEL2)    
!WP         PRMOD =      PX1(4)**2-AMEL2     
!WP         IF(PRMOD.LE.0D0) WRITE(NOUT,*) ' REDUZ1: PRMOD=', PRMOD
!WP         IF(PRMOD.LE.0D0) WRITE(   6,*) ' REDUZ1: PRMOD=', PRMOD
!WP         PRMOD = SQRT(ABS(PRMOD)) 
         qsm1 = PX1(4) + PX2(4)
         PX1(4) = (qsm1**2 + am1s - am2s)/2/qsm1
         PRMOD  = SQRT(PX1(4)**2 - am1s)
         PX2(4) = qsm1 - PX1(4) 
         DO 30 K=1,3   
         PX1(K)= PX1(K)/PXMOD*PRMOD       
 30      PX2(K)= PX2(K)/PXMOD*PRMOD       
         DO 31 K=1,4   
 31      PHX(K)= PHX(K)*XLAM              
      ENDIF            
C then, boost away the three-vector part of P1+P2-PH         
C that is transform to QQ rest frame      
      DO 35 K=1,4      
 35   PP(K)= PX1(K)+PX2(K)-PHX(K)         
      CALL BOSTDQ( 1,PP,PX1,PR1)          
      CALL BOSTDQ( 1,PP,PX2,PR2)          
      CALL BOSTDQ( 1,PP,PHX,PHR)          
      END              

      FUNCTION RadMat(KeyWga,KeyZga,KeySpn,amW,gaW,amZ,gaZ,sW2,
     &                s,sx1,sx2,q1,q2,ph,pf1,pf2,pf3,pf4)
!     *********************************************************
!----------------------------------------------------------------------!
! This function provides a value of matrix element squared for         !
! the process:                                                         !
!              e+e- --> W+W- + gamma --> 4-fermions + gamma            !
! i.e. photon radiation in W-pair production and W-decays.             !
! INPUT: KeyWga = 0/1/2 -- running/constant/zero W width               !
!        KeyZga = 0/1/2 -- running/constant/zero Z width               !
!        KeySpn = 0/1   -- spin effects in W-decays OFF/ON             !
!        amW -- W mass                                                 !
!        gaW -- W width                                                !
!        amZ -- Z mass                                                 !
!        gaZ -- Z widths                                               !
!        sW2 -- sin^2(theta_Weinberg)                                  !
!        s   -- CMS energy squared                                     !
!        sx1,sx2 -- squared invariant masses of W- and W+, resp.       !
!        q1,q2,ph        -- W-, W+ and photon 4-momenta, resp.         !
!        pf1,pf2,pf3,pf4 -- final state fermions 4-momenta             !
!                           (coming from W-decays)                     !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, July 1996  !
! Last update: 17.08.1999           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 q1(4),q2(4),ph(4),pf1(4),pf2(4),pf3(4),pf4(4)
      COMPLEX*16 awwgel(3,3,2),awwger(3,3,2)
      COMMON / matpar / pi,ceuler     
      COMMON / wekin2 / amaw,gammw,gmu,alphaw   
      SAVE   / matpar /,/ wekin2 /
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
      SAVE   / WWINVM /
      REAL*8 q(0:3,3)
      COMPLEX*16 adwm(3),adwp(3)
      COMPLEX*16 prinw1,prinw2,prinww,ampel,amper,amgel(2),amger(2)
!
      DO k = 1,4
        j = MOD(k,4)
        q(j,1) = q1(k)
        q(j,2) = q2(k)
        q(j,3) = ph(k)
      ENDDO
! Polarization amplitudes for a production
      CALL eewwg(KeyZga,amZ,gaZ,amW,sW2,s,q,awwgel,awwger)
! Polarization amplitudes for decays
      CALL Wdecay(q1,pf1,pf2,adwm)  
      CALL Wdecay(q2,pf3,pf4,adwp) 
! Exact W-propagators (inverse)
      IF (KeyWga.EQ.0) THEN
        prinw1 = DCMPLX(s1-amW**2,s1/amW*gaW)
        prinw2 = DCMPLX(s2-amW**2,s2/amW*gaW)
      ELSEIF (KeyWga.EQ.1) THEN
        prinw1 = DCMPLX(s1-amW**2,amW*gaW)
        prinw2 = DCMPLX(s2-amW**2,amW*gaW)
      ELSE
        prinw1 = DCMPLX(s1-amW**2,0d0)
        prinw2 = DCMPLX(s2-amW**2,0d0)
      ENDIF
      prinww = prinw1*prinw2 
! Matrix element squared
      xmatr = 0d0 
      IF (KeySpn.EQ.0) THEN
        DO lg = 1,2
          DO l2 = 1,3
          DO l1 = 1,3
            ampel = awwgel(l1,l2,lg)*adwm(l1)*adwp(l2)/prinww
            amper = awwger(l1,l2,lg)*adwm(l1)*adwp(l2)/prinww
            xmatr = xmatr + ampel*DCONJG(ampel) + amper*DCONJG(amper) 
          ENDDO
          ENDDO
        ENDDO
      ELSEIF (KeySpn.EQ.1) THEN
        DO lg = 1,2
          amgel(lg) = (0d0,0d0)
          amger(lg) = (0d0,0d0)
          DO l2 = 1,3
          DO l1 = 1,3
            amgel(lg) = amgel(lg) 
     &                + awwgel(l1,l2,lg)*adwm(l1)*adwp(l2)/prinww
            amger(lg) = amger(lg) 
     &                + awwger(l1,l2,lg)*adwm(l1)*adwp(l2)/prinww
          ENDDO   
          ENDDO
          xmatr = xmatr + amgel(lg)*DCONJG( amgel(lg) ) 
     &                  + amger(lg)*DCONJG( amger(lg) )
        ENDDO
      ELSE
        WRITE(6,*)' RadMat: Wrong KeySpn: ',KeySpn
        STOP
      ENDIF
      ew2 = 4*pi*alphaw
      fact = 0.25
      RadMat = ew2**2 *fact*xmatr  
      END

      FUNCTION TreMat(KeyWga,KeyZga,KeySpn,amW,gaW,amZ,gaZ,sW2,
     &                s,t,sx1,sx2,q1,q2,pf1,pf2,pf3,pf4)
!     *********************************************************
!----------------------------------------------------------------------!
! This function provides a value of matrix element squared for         !
! the process:                                                         !
!                 e+e- --> W+W- --> 4-fermions                         !
! i.e. tree level matrix element for W-pair production and decay.      !
! INPUT: KeyWga = 0/1/2 -- running/constant/zero W width               !
!        KeyZga = 0/1/2 -- running/constant/zero Z width               !
!        KeySpn = 0/1   -- spin effects in W-decays OFF/ON             !
!        amW -- W mass                                                 !
!        gaW -- W width                                                !
!        amZ -- Z mass                                                 !
!        gaZ -- Z widths                                               !
!        sW2 -- sin^2(theta_Weinberg)                                  !
!        s   -- CMS energy squared                                     !
!        t   -- t-channel transfer                                     !
!        sx1,sx2 -- squared invariant masses of W- and W+, resp.       !
!        q1,q2           -- W-, W+ 4-momenta, resp.                    !
!        pf1,pf2,pf3,pf4 -- final state fermions 4-momenta             !
!                           (coming from W-decays)                     !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, July 1996  !
! Last update: 28.09.1999           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 q1(4),q2(4),pf1(4),pf2(4),pf3(4),pf4(4)
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf 
      COMMON / wekin2 / amaw,gammw,gmu,alphaw   
      COMMON / KeyKey / KeyRad,KeyPhy,KeyTek,KeyMis,KeyDwm,KeyDwp
      SAVE   / weking /,/ wekin2 /,/ KeyKey /
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
      SAVE   / WWINVM /
      COMPLEX*16 awwel(3,3),awwer(3,3),adwm(3),adwp(3)
      COMPLEX*16 prinw1,prinw2,prinww,ampel,amper
!
      amaw  = amW
      gammw = gaW
      amaz  = amZ
      gammz = gaZ
      sinw2 = sW2
! Polarization amplitudes for a production
      CALL WWprod(s,t,q1,q2,awwel,awwer)
! Polarization amplitudes for decays
      CALL Wdecay(q1,pf1,pf2,adwm)  
      CALL Wdecay(q2,pf3,pf4,adwp) 
! Exact W-propagators (inverse)
      IF (KeyWga.EQ.0) THEN
        prinw1 = DCMPLX(s1-amW**2,s1/amW*gaW)
        prinw2 = DCMPLX(s2-amW**2,s2/amW*gaW)
      ELSEIF (KeyWga.EQ.1) THEN
        prinw1 = DCMPLX(s1-amW**2,amW*gaW)
        prinw2 = DCMPLX(s2-amW**2,amW*gaW)
      ELSE
        prinw1 = DCMPLX(s1-amW**2,0d0)
        prinw2 = DCMPLX(s2-amW**2,0d0)
      ENDIF
      prinww = prinw1*prinw2 
! Matrix element squared
      IF (KeySpn.EQ.0) THEN
        xmatr = 0d0
        DO l2 = 1,3
        DO l1 = 1,3
          ampel = awwel(l1,l2)*adwm(l1)*adwp(l2)/prinww
          amper = awwer(l1,l2)*adwm(l1)*adwp(l2)/prinww
          xmatr = xmatr + ampel*DCONJG(ampel) + amper*DCONJG(amper) 
        ENDDO
        ENDDO
      ELSEIF (KeySpn.EQ.1) THEN
        ampel = (0d0,0d0)
        amper = (0d0,0d0)
        DO l2 = 1,3
        DO l1 = 1,3
          ampel = ampel + awwel(l1,l2)*adwm(l1)*adwp(l2)/prinww
          amper = amper + awwer(l1,l2)*adwm(l1)*adwp(l2)/prinww
        ENDDO   
        ENDDO
        xmatr = ampel*DCONJG(ampel) + amper*DCONJG(amper)       
      ELSE
        WRITE(6,*)' TreMat: Wrong KeySpn: ',KeySpn
        STOP
      ENDIF
      fact = 0.25
      TreMat = fact*xmatr 
      END

      FUNCTION SoftFa(s,ame2,s1,s2,q1,q2,pk)
*     **************************************
!---------------------------------------------------------------!
! This function provides a value of the soft factor S-tilde     !
! for massless fermions (factor (alpha/4pi^2) omitted!).        !
! INPUT: s    - CMS energy squared                              !
!        ame2 - electron mass squared                           !
!        s1,s2 - W- and W+ invariant masses squared, resp.      !
!        q1,q2 - W- and W+ 4-momenta, resp.                     !
!        pk(4) - photon  4-momentum                             !
!---------------------------------------------------------------!
! Written by: Wieslaw Placzek             Knoxville, Aug. 1996  !
! Last update: 01.08.1996       by: W.P.                        !
!---------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      REAL*8 q1(4),q2(4),pk(4)
!
      Eel = SQRT(s)/2
      Pel = SQRT(Eel**2 - ame2)
! Scalar products of massive incoming leptons 4-momenta
      p1km = Eel*pk(4) - Pel*pk(3)
      p2km = Eel*pk(4) + Pel*pk(3)
! Scalar products of massless incoming leptons 4-momenta
      p1k  = Eel*( pk(4) - pk(3) )
      p2k  = Eel*( pk(4) + pk(3) )
      q1k  = q1(4)*pk(4) - q1(3)*pk(3) - q1(2)*pk(2) - q1(1)*pk(1)
      q2k  = q2(4)*pk(4) - q2(3)*pk(3) - q2(2)*pk(2) - q2(1)*pk(1)
      p1p2 = s/2
      p1q1 = Eel*( q1(4) - q1(3) )
      p1q2 = Eel*( q2(4) - q2(3) )
      p2q1 = Eel*( q1(4) + q1(3) )
      p2q2 = Eel*( q2(4) + q2(3) )
      q1q2 = q1(4)*q2(4) - q1(3)*q2(3) - q1(2)*q2(2) - q1(1)*q2(1)
! Massless terms 
      sfml = 2*( p1p2/(p1k*p2k) + p1q1/(p1k*q1k) - p1q2/(p1k*q2k)
     &         - p2q1/(p2k*q1k) + p2q2/(p2k*q2k) + q1q2/(q1k*q2k) )
     &     - s1/q1k**2 - s2/q2k**2
! Mass terms
      sfmt = ame2/p1km**2  + ame2/p2km**2 
      SoftFa = sfml - sfmt
      END

      FUNCTION YIRfof(ame,amW,sprim,s1,s2,epsCMS,q1,q2)
*     *************************************************
!---------------------------------------------------------------!
! This function provides a value of the IR YFS formfactor for   !
! on-shell WW-production.                                       !
! INPUT: ame   - electron mass squared                          !
!        amW   - W-boson mass                                   !
!        sprim - CMS energy squared of effective beams (after   !
!                initial state radiation)                       !
!        s1,s2 - W- and W+ invariant masses squared, resp.      !
!        epsCMS - soft photon cut-off in CMS                    !
!        q1,q2 - W- and W+ 4-momenta, resp.                     !
!---------------------------------------------------------------!
! Written by: Wieslaw Placzek             Knoxville, Sep. 1996  !
! Last update: 03.09.1996       by: W.P.                        !
!---------------------------------------------------------------!
      IMPLICIT REAL*8 (a-h,o-z)
      REAL*8 q1(4),q2(4),px1(4),px2(4),qx1(4),qx2(4)
!
      betaW = SQRT(1 - 2*(s1+s2)/sprim + ((s1-s2)/sprim)**2) 
      s  = 4*amW**2/(1 - betaW**2)
      En = SQRT(s)/2
! cos(theta) of W-
      costh = q1(3)/SQRT(q1(1)**2 + q1(2)**2 + q1(3)**2)
      sinth = SQRT(1d0 - costh**2)
! Azimuthal angle
      qtra  = SQRT(q1(1)**2 + q2(2)**2)
      sphi = q1(2)/qtra
      cphi = q1(1)/qtra
! 4-momenta of e-/e+
      px1(4) = En
      px1(3) = En
      px1(2) = 0d0
      px1(1) = 0d0
      px2(4) = px1(4)
      px2(3) =-px1(3)
      px2(2) = 0d0
      px2(1) = 0d0
! 4-momenta of W-/W+ (on-shell)
      qm = En*betaW
      qx1(4) = En
      qx1(3) = qm*costh
      qx1(2) = qm*sinth*sphi
      qx1(1) = qm*sinth*cphi
      qx2(4) = qx1(4)
      qx2(3) =-qx1(3)
      qx2(2) =-qx1(2)
      qx2(1) =-qx1(1)
! YFS formfactor
      fmfa = BtiReB(px1,px2,qx1,qx2,ame,amW,amW,epsCMS)
      YIRfof = fmfa
      END
      FUNCTION VirSof(amW,amZ,gaZ,amf,amH,sprim,s1,s2,epsCMS,q1,q2)
!     *************************************************************
!----------------------------------------------------------------------!
! This function provides a value of electroweak virtual + soft-photon  !
! corrections to a cross section of the process:                       !
!                       e+e- ---> W+W-                                 !
! as given in ref:                                                     !
! J. Fleischer, F. Jegerlehner, M. Zralek, Z. Phys. C42 (1989) 409.    !     
! INPUT: amW -- W mass                                                 !
!        amZ -- Z mass                                                 !
!        gaZ -- Z widths                                               !
!        amf -- array of fermion masses                                !
!        amH -- Higgs mass                                             !
!        sprim -- energy squared of final W-W+ in their CMS            !
!        s1,s2 -- squared invariant masses of W- and W+, resp.         !
!        epsCMS -- soft photon cut-off in CMS of the incoming beams    !
!        q1,q2 -- W-, W+ 4-momenta, resp.                              !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, Aug. 1996  !
! Last update: 26.01.2001           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER( pix = 3.1415926535897932d0, alfinv = 137.03599976D0)
      PARAMETER( alfpi=  1/pix/alfinv, alfax= 1d0/alfinv)
      REAL*8 q1(4),q2(4),amf(20)
! Commons with parameters for virtual+soft correction calculations
!======================================================================
	double precision W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	COMMON/BEZNAZ/ W,S,MW,MZ,MW2,MZ2,CW,SW,CW2,SW2,A0,C0,ALFA,
     &		ME,ME2,BETAW
	double precision COEF1,COEF2,COEF3,COEF4,COEF5,COEF8
	COMMON/COEFF1/COEF1,COEF2,COEF3,COEF4,COEF5,COEF8
	double precision COEF0A,DPI
	COMMON/COEFFA/COEF0A,DPI
	CHARACTER*4 SCHEME
	COMMON/SCHEM/SCHEME
	double precision COEF0,SCHCON,RALFA
	COMMON/COEFF0/COEF0,SCHCON,RALFA
	double precision GAMAZ
	COMMON/ZBR/GAMAZ
	double precision XR,XNOT,KMIN,KMAX
	COMMON/SOFCUT/XR,XNOT,KMIN,KMAX
	double precision XR0
	integer IOM
	COMMON/CUTOPT/XR0,IOM
	double precision PM(4),PP(4),P(4)
	COMMON/MOMENT/PM,PP,P
	integer iopt
	COMMON/OPT/IOPT
	double precision MTOP,MH
	COMMON/TOPHIG/MTOP,MH
	double precision GF
	COMMON/FERMIC/GF
	double precision MUP(8),MDOWN(8),QUP(8),QDOWN(8),FN,QCDF
	integer IFERM
	COMMON/FMANDQ/MUP,MDOWN,QUP,QDOWN,FN,QCDF,IFERM
 	double precision GAMA0,GAMA,GAMA1,GAMA2,FCP
	COMMON/NORMA1/GAMA0,GAMA,GAMA1,GAMA2,FCP
	double precision PI,PI2
	COMMON/PIATAN/PI,PI2
	double precision CONVC
	COMMON/CONVCO/CONVC
	integer iexp,inicol
	double precision cone,xmu2
	COMMON/EXPON/IEXP,inicol,cone,xmu2
	double precision delta
	common /ffcut/delta
	integer IAPP,IDEN,IDTM,IBFC,IDTMZ
	COMMON/APPROX/IAPP,IDEN,IDTM,IBFC,IDTMZ
	CHARACTER*11 POLE
	COMMON/POLINI/POLE
	CHARACTER*12 POLWM,POLWP,polwms,polwps
	COMMON/POLFIN/POLWM,POLWP,polwms,polwps
	double precision PLM,PLP,PTM,PTP,fim,fip
	COMMON/POLVEC/PLM,PLP,PTM,PTP,fim,fip
	integer LS1,LS2,IAVER
	COMMON/POLELE/LS1,LS2,IAVER
	integer LM1,LM2,LMSTEP
	COMMON/POLWMI/LM1,LM2,LMSTEP
	integer LP1,LP2,LPSTEP
	COMMON/POLWPL/LP1,LP2,LPSTEP
	REAL*8 S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
	COMMON /AMPT/S01IT,S02IT,S03IT,S01PIT,S02PIT,S03PIT,T01IT,T02IT,
     &		T01PIT,T02PIT,F5IT,F5PIT,XL7T,XL8T,XR7T,XR8T,CBRT
	REAL*8 DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,X7M0,X7P0
	COMMON/FORMFA/ DG0,DZ0,XG0,XZ0,YG0,YZ0,ZG0,ZZ0,DT1M0,T1P0,
     &		X7M0,X7P0
	REAL*8 FIW,CFIW,SFIW,dfi
	COMMON/AZIMUT/FIW,CFIW,SFIW,dfi
	double precision EPSM(3,4),EPSP(3,4),P1(4),QM4(4),QP4(4)
	COMMON/VECT/EPSM,EPSP,P1,QM4,QP4
	REAL*8 ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
	COMMON /ANO/ ANO,CFD,CFC,CFR,CTB,CTF,CFF,CSF
	integer iorder
	common /order/iorder
	double precision d1z,dkapg,dkapz,lamg,lamz,xig,xiz
	logical lanoma
	common /anomal/d1z,dkapg,dkapz,lamg,lamz,xig,xiz,lanoma
	double precision px(0:3,7),eps(0:3,7)
	integer iparti(7)
	common /partic/px,eps,iparti
!======================================================================
! Switch OFF/ON (0/1) QCD correction to fermion loops (default: ON)  
        DATA KeyQCD /1/
! KeyAlW=1: calculate all O(alpha) correction at alpha_W (RECOMMENDED)
!       =0: original solution of FJKZ 
        DATA KeyAlW /1/
        DATA Init /0/
! Warning switch (=0/1 Off/On)
        DATA KeyWarn /0/
        SAVE
!
! Set up parameters for virtual+soft corrections
      IF (Init.EQ.0) THEN
        iorder = 1
        inicol = 0
        IOM    = 0
        SCHEME = 'GMU'
        POLE   = 'UNPOLARIZED'
        POLWM  = 'UNPOLARIZED'
        POLWP  = 'UNPOLARIZED'
        polwms = 'UNPOLARIZED'
        polwps = 'UNPOLARIZED'
        PLM   = 0
        PLP   = 0
        PTM   = 0
        PTP   = 0
        fim   = 0
        fip   = 0
        PI    = pix
        ALFA  = alfax
	GF    = 1.16639D-5
	CONVC = 0.3893857D9
	DPI = PI
	PI2 = PI**2
! photon mass^2 (cutoff)
	delta = 1.d-24
! Electroweak parameters
        MZ = amZ
        GAMAZ = gaZ
        MW = amW
! top and Higgs masses
        MTOP = amf(6)
        MH   = amH
! electron mass
        ME   = amf(11)
! Number of fermion flavours
        IFERM = 6
! QCD-correction factor
        IF (KeyQCD.NE.0) THEN
           QCDF = 1D0 +0.133D0/PI 
! No QCD-correction factor 
        ELSE
           QCDF = 1d0
        ENDIF
! Fermion masses and charges (leptons)
! * electron - neutrino
        FN = 1d-10
	MDOWN(1) = ME
	MUP(1)   = FN*MDOWN(1)
	QDOWN(1) =-1.D0
	QUP(1)   = 0.D0
! * muon - neutrino
	MDOWN(2) = amf(13)
	MUP(2)   = FN*MDOWN(2)
	QDOWN(2) =-1.D0
	QUP(2)   = 0.D0
! * tau - neutrino
	MDOWN(3) = amf(15)
	MUP(3)   = FN*MDOWN(3)
	QDOWN(3) =-1.D0
	QUP(3)   = 0.D0
! Fermion masses and charges (quarks)
! * up - down
        MDOWN(4) = amf(1)
        MUP(4)   = amf(2)
	QDOWN(4) =-1.D0/3.D0
	QUP(4)   = 2.D0/3.D0
! * strange - charm
        MDOWN(5) = amf(3)
        MUP(5)   = amf(4)
	QDOWN(5) =-1.D0/3.D0
	QUP(5)   = 2.D0/3.D0
! * top - bottom
        MDOWN(6) = amf(5)
        MUP(6)   = MTOP
	QDOWN(6) =-1.D0/3.D0
	QUP(6)   = 2.D0/3.D0
! Extra family:
	MDOWN(7) = 751.D0
	MUP(7)   = 749.D0
	QDOWN(7) =-1.D0
	QUP(7)   = 0.D0
!
	MDOWN(8) = 749.D0
	MUP(8)   = 751.D0
	QDOWN(8) =-1.D0/3.D0
	QUP(8)   = 2.D0/3.D0
! Masses squared
        MW2 = MW**2
        MZ2 = MZ**2
        ME2 = ME**2
! Functions of the weak mixing angle
        CW  = MW/MZ
        CW2 = CW**2
        SW  = DSQRT(1D0 - CW2)
        SW2 = SW**2
! Vector and axial-vector couplings of Z to the electron
	A0 =-(1D0 - 4D0*SW2)/4D0/SW/CW
	C0 =-1D0/4D0/SW/CW
! The effective alpha
	ALFAW = DSQRT(2D0)*GF*MW2*SW2/PI
        IF (KeyAlW.EQ.1) THEN
! Calculate all O(alpha) corrections in G_mu scheme at alpha_W
           ALFA = ALFAW
        ENDIF
! Scheme conversion constant 
	SCHCON = 1D0
	RALFA  = ALFAW/ALFA
	IF (SCHEME.EQ.'GMU') SCHCON = RALFA**2
! Some switches
	IAPP  = 0
	IDEN  = 0
	IDTM  = 0
	IBFC  = 0
	IDTMZ = 0
! Anomalous couplings (set to zero)
        lanoma = .FALSE.
        d1z   = 0
        dkapg = 0
        dkapz = 0
        lamg  = 0
        lamz  = 0
        xig   = 0
        xiz   = 0
! Some other parameters
        iexp = 0
        cone = 0
	cfd = 1
	cfc = 1
	cfr = 1
	ctb = 1
	ctf = 1
	cff = 1
	csf = 1
! Initialize the ff package
        CALL OffIni
	delta = 1.d-24
! Initialize momenta and polarizations to 0
	DO i = 1,7
           DO j = 0,3
              px(j,i)  = 0
              eps(j,i) = 0
           ENDDO
           iparti(i) = 0
	ENDDO
!
        Init = 1
      ENDIF
! W-boson velocity
      BETAW = SQRT(1 - 2*(s1+s2)/sprim + ((s1-s2)/sprim)**2) 
      S = 4*MW2/(1 - BETAW**2)
      W = SQRT(S)
! 4-momenta of e-/e+
      PM(1) = W/2D0
      PM(2) = 0D0
      PM(3) = 0D0
      PM(4) = PM(1)
      PP(1) = PM(1)
      PP(2) = 0D0
      PP(3) = 0D0
      PP(4) =-PM(4)
! Sum of the electrons 4-momenta
      DO I1 = 1,4
        P(I1) = PM(I1)+PP(I1)
      ENDDO
! Coefficients needed 
      COEF0  = SCHCON*ALFA**2/4D0/S*BETAW*CONVC*2D0*PI
      COEF0A = SCHCON*ALFA**2/4D0*CONVC*2D0*PI
      COEF1  = 1D0/S - CW/SW/(S-MZ2)*(A0+C0)
      COEF2  = 1D0/S + SW/CW/(S-MZ2)*(A0+C0)
      COEF3  = 1D0/S - CW/SW/(S-MZ2)*(A0-C0)
      COEF4  = 1D0/S + SW/CW/(S-MZ2)*(A0-C0)
      COEF5  = SCHCON*ALFA**3/4D0/PI/S/2D0/PI*CONVC*2D0*PI
      COEF8  = MW2**2/2D0
! The soft photon cut-off
      KMIN = epsCMS*W/2 
      KMAX = W/2D0*(1D0-4D0*MW2/S) !W/2
      XR0  = 2*KMIN/W
      XR   = XR0
      XNOT = XR
!!!!!!
cc! VELTMAN'S CUTOFF:
cc      XR0 = 0.1 !DMIN1(1-2*MW/W,0.1d0)
cc      XR   = XR0
cc      XNOT = XR
cc      KMIN = W*( XR/( 1 + XR + SQRT((1-XR)**2 - 4*MW2/S) ) )
cc      KMAX = W/2D0*(1D0-4D0*MW2/S)
!!!!!
      xmu2 = S
! Factors necessary for smoothing CP distribution 
      GAMA0 = (1.D0 + BETAW**2)/2D0
      GAMA  = BETAW
      GAMA1 = GAMA0 + GAMA
      GAMA2 = GAMA0 - GAMA
      FCP = GAMA/DLOG(GAMA1/GAMA2)              
! cos(theta) of W-
      COSTHT = q1(3)/SQRT(q1(1)**2 + q1(2)**2 + q1(3)**2)
! Avoid collinear W's - numerical problems in FF package
      epsCos = 1d-6
      CosLow  = -1d0 + epsCos 
      CosHigh =  1d0 - epsCos
      IF (COSTHT.LT.CosLow) THEN
        IF (KeyWarn.EQ.1) THEN
          WRITE(*,*)'[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[['
          WRITE(*,*)'==========> FUNCTION VirSof <==============' 
          WRITE(*,*)'>>> WARNING: EW Library Unstable For:'
          WRITE(*,*)'>>> COSTHT = ',COSTHT
          WRITE(*,*)'>>> COSTHT reset to ',CosLow
          WRITE(*,*)'>>> Now EW Library is OK!'
          WRITE(*,*)'>>> Do not worry if you do not see this too often!' 
          WRITE(*,*)'>>> Otherwise, contact the authors!'
          WRITE(*,*)']]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'
        ENDIF
        COSTHT = CosLow
      ELSEIF (COSTHT.GT.CosHigh) THEN
        IF (KeyWarn.EQ.1) THEN
          WRITE(*,*)'[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[['
          WRITE(*,*)'==========> FUNCTION VirSof <==============' 
          WRITE(*,*)'>>> WARNING: EW Library Unstable For:'
          WRITE(*,*)'>>> COSTHT = ',COSTHT
          WRITE(*,*)'>>> COSTHT reset to ',CosHigh
          WRITE(*,*)'>>> Now EW Library is OK!'
          WRITE(*,*)'>>> Do not worry if you do not see this too often!' 
          WRITE(*,*)'>>> Otherwise, contact the authors!'
          WRITE(*,*)']]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'
        ENDIF
        COSTHT = CosHigh
      ENDIF
! Azimuthal angle
      qtra = SQRT(q1(1)**2 + q2(2)**2)
      SFIW = q1(2)/qtra
      CFIW = q1(1)/qtra
      FIW  = DACOS(CFIW)
      IF (q1(2).LT.0d0) FIW = 2*PI - FIW
! Determine polarization
      CALL getpol
! Calculate Born cross section
      Born = COEF0*CSS0(COSTHT,0)
! Calculate electroweak corrections
      CALL ELWEAK(XNOT,COSTHT) 
! Get overcomplete amplitudes:
      IF(SCHEME.EQ.'ALFA') THEN
        E2 = 4.D0*PI*ALFA
      ELSE
        E2 = 4.D0*PI*ALFA*RALFA
      ENDIF
      T = MW2 - S/2.D0*(1.D0 - BETAW*COSTHT)
      U = MW2 - S/2.D0*(1.D0 + BETAW*COSTHT)
      PROPG =-E2/S
      PROPZ = E2/(S-MZ2)
      PROPN =-E2/T
! Amplitudes coming from ELWEAK (overcomplete base)
      S01M = S01IT
      S02M = S03IT
      S03M = S*S02IT
      S04M = F5IT
      T01M = T01IT
      T02M = T02IT
      X07M = XL7T
      X08M = XL8T
!
      S01P = S01PIT
      S02P = S03PIT
      S03P = S*S02PIT
      S04P = F5PIT
      T01P = T01PIT
      T02P = T02PIT
      X07P = XR7T
      X08P = XR8T
! Soft photon correction
      Soft = Born*DSOFT0(COSTHT)
! Amplitudes forming a complete base:
      T1M = T01M+T02M
      S1M = S01M-T02M/2.D0
      S2M = S02M+T02M/2.D0-BETAW*COSTHT*X08M
      S3M = S03M
      S4M = S04M+(T02M/2.D0+X08M)
      X7M = X07M
!
      T1P = T01P+T02P
      S1P = S01P-T02P/2.D0
      S2P = S02P+T02P/2.D0-BETAW*COSTHT*X08P
      S3P = S03P
      S4P = S04P-(T02P/2.D0+X08P)
      X7P = X07P
! New form factors:
      AW = 1.D0/2.D0/SW/CW
      SMW = S/MW2
      DG0 = (S1P-2.D0*SW2*(S1P-S1M)+(S3P-2.D0*SW2*(S3P-S3M))/2.D0)
     &		  /PROPG
      DZ0 = (S1P-S1M+(S3P-S3M)/2.D0)/AW/PROPZ
      XG0 = (S2P-2.D0*SW2*(S2P-S2M)
     &		  -(1.D0-1.D0/SMW)*(S3P-2.D0*SW2*(S3P-S3M)))/PROPG
      XZ0 = (S2P-S2M-(1.D0-1.D0/SMW)*(S3P-S3M))/AW/PROPZ
      YG0 = (S3P-2.D0*SW2*(S3P-S3M))/PROPG/SMW
      YZ0 = (S3P-S3M)/AW/PROPZ/SMW
      ZG0 = (S4P-2.D0*SW2*(S4P-S4M))/PROPG/SMW
      ZZ0 = (S4P-S4M)/AW/PROPZ/SMW
      DT1M0 = T1M*2.D0*SW2/PROPN
      T1P0  = T1P*2.D0*SW2/PROPN
      X7M0  = X7M/E2
      X7P0  = X7P/E2
! Virtial corrections
      Virt = COEF0*CSS0(COSTHT,1)
! Total virtual+soft corrections
      fac = 1d0 
      VirSof = fac*(Virt + Soft)/Born
      END
      FUNCTION VSappr(ame,amW,amZ,amt,amH,sprim,s1,s2,eps,q1,q2)
!     **********************************************************
!----------------------------------------------------------------------!
! This function provides an approximation of the electroweak           !
! virtual+soft photon corrections to the YFS beta_O function for:      !
!                       e+e- ---> W+W-                                 !
! as given in ref:                                                     !
! S. Dittmaier, M. Boehm and A. Denner, Nucl. Phys. B376 (1992) 29.    !     
! INPUT: ame -- electron mass                                          !
!        amW,amZ -- W and Z masses, resp.                              !
!        amt,amH -- top and Higgs masses, resp.                        !
!        sprim -- energy squared of final W-W+ in their CMS            !
!        s1,s2 -- squared invariant masses of W- and W+, resp.         !
!        q1,q2 -- W-, W+ 4-momenta, resp.                              !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, Oct. 1996  !
! Last update: 15.10.1996           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 q1(4),q2(4)
      PARAMETER( pi = 3.1415926535897932d0, alfinv = 137.03599976D0)
      PARAMETER( alfpi =  1/pi/alfinv, alfa = 1d0/alfinv)
! Helicity matrix elements and form factors
      REAL*8 xm1(-1:1,-1:1,2),xm2(-1:1,-1:1,2),ff1(2),ff2(2)
      REAL*8 xmbo(-1:1,-1:1,2)
!
      ame2 = ame**2
      amW2 = amW**2
      amZ2 = amZ**2
! sin^2(theta_W), where theta_W - electroweak mixing angle
      sW2 = 1 - amW2/amZ2
! W-boson velocity
      betaW = SQRT(1 - 2*(s1+s2)/sprim + ((s1-s2)/sprim)**2) 
      s = 4*amW2/(1 - betaW**2)
! cos(theta) of W-
      costh = q1(3)/SQRT(q1(1)**2 + q1(2)**2 + q1(3)**2)
! Mandelstam invariants
      t = amW2 - s/2*(1 - betaW*costh)
      u = amW2 - s/2*(1 + betaW*costh)
! QED corrections (after subtracting the YFS form-factor part)
      delqed = alfpi*( LOG(s/ame2) -1  
     &               + (1+betaW**2)/2/betaW*LOG((1+betaW)/(1-betaW)) -1
     &               + 2*LOG((amW2-t)/(amW2-u)) )
!WP: Total QED corrections, i.e. virtual + soft (cut-off dependent)
!WP      delsof = 2*alfpi*( LOG(s/ame2)*(LOG(eps) + 0.75)
!WP     &                 + LOG(eps)*(2*LOG((amW2-t)/(amW2-u)) - 2
!WP     &                  + (1+betaW**2)/2/betaW*LOG((1+betaW)/(1-betaW)))
!WP     &                 - LOG(betaW) )
!WP      delcou = alfa*pi/2/betaW *(1 - betaW**2)**2
!WP      delqed = delsof + delcou
! Remaining corrections
      CALL FoFaMe(amW,amZ,amt,amH,sW2,s,t,u,betaW,xm1,xm2,ff1,ff2)
      xborn = 0
      xappr = 0
c      ff1(1) = 0
c      ff2(1) = 0
c      ff1(2) = 0
c      ff2(2) = 0
      DO k = 1,2
        DO lm = -1,1
        DO lp = -1,1
          xmbo(lp,lm,k) = (2-k)*xm1(lp,lm,k)/(2*sW2) + xm2(lp,lm,k)
          xborn = xborn + xmbo(lp,lm,k)**2
          xappr = xappr 
     &          + 2*( ff1(k)*xm1(lp,lm,k) + ff2(k)*xm2(lp,lm,k) )
     &             *xmbo(lp,lm,k)
        ENDDO
        ENDDO
      ENDDO
      delrem = xappr/xborn 
! Total correction
      VSappr = delqed + delrem
!!!
c      delisr = alfpi*( LOG(s/ame2) -1 )
c      print*,'delqed,delrem=',delqed,delrem
c      print*,'delisr,difqed=',delisr,delqed-delisr
c      print*,'ex-ll=',delqed + delrem -delisr

      END

      SUBROUTINE FoFaMe(amW,amZ,amt,amH,sW2,s,t,u,betaW,xm1,xm2,ff1,ff2)
!     ******************************************************************
!----------------------------------------------------------------------!
! This subroutine provides helicity matrix elements and form factors   !
! for improved Born approximation for the process:                     !
!                       e+e- ---> W+W-                                 !
! as given in ref:                                                     !
! S. Dittmaier, M. Boehm and A. Denner, Nucl. Phys. B376 (1992) 29.    !     
! INPUT: amW,amZ -- W and Z masses, resp.                              !
!        amt,amH -- top and Higgs masses, resp.                        !
!        sW2 -- sin^2(theta_W); theta_W - electroweak mixing angle     !
!        s,t,u -- Mandelstam invariants                                !
!        betaW -- velocity of W
! OUTPUT: xm1(3,3,2),xm2(3,3,2) -- helicity matrix elements            !
!         ff1(2),ff2(2)         -- form factors                        !
!----------------------------------------------------------------------!
! Written by:  Wieslaw Placzek                   Knoxville, Oct. 1996  !
! Last update: 15.10.1996           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 xm1(-1:1,-1:1,2),xm2(-1:1,-1:1,2),ff1(2),ff2(2)
      PARAMETER( pi = 3.1415926535897932d0, alfinv = 137.03599976D0)
      PARAMETER( alfpi =  1/pi/alfinv, alfa = 1d0/alfinv)
! Some fit constants used in form factors
      PARAMETER ( C1p =-0.0054, C1m =-0.016, C2p = 0.017, C2m = -0.007 )
! Inline function
      fsM(x,y,z) = 1/(1 + EXP( (x - y - 0.5*z)/(0.5*z) ) )
!
      amW2 = amW**2
      amW4 = amW2**2
      amZ2 = amZ**2
      amt2 = amt**2
      amH2 = amH**2
      cW2  = 1 - sW2
      Ecms = SQRT(s)
      betW2 = betaW**2
      Zpro = s - amZ2
      utmW = SQRT(u*t - amW4)
! Helicity matrix elements
      DO k = 1,2
        sig = k - 1.5
        xm1( 1, 1,k) = 2*utmW*( (t+amW2)/t/s/betW2 - 1/Zpro )
        xm2( 1, 1,k) = 2*utmW*amZ2/s/Zpro
        xm1( 1,-1,k) = utmW/t/s/betW2*(t - u - 2*sig*s*betaW)
        xm1(-1, 1,k) = utmW/t/s/betW2*(t - u + 2*sig*s*betaW)
        xm2( 1,-1,k) = 0
        xm2(-1, 1,k) = 0
        xm1( 1, 0,k) =-SQRT(2*s)/amW/s/betW2*( amW4/t + t + s/2 
     &                      - sig*betaW*(2*amW4/t - 2*amW2 + s) )
     &               + SQRT(s/2)/amW/Zpro*(t - u - 2*sig*s*betaW)
        xm1(-1, 0,k) =-SQRT(2*s)/amW/s/betW2*( amW4/t + t + s/2 
     &                      + sig*betaW*(2*amW4/t - 2*amW2 + s) )
     &               + SQRT(s/2)/amW/Zpro*(t - u + 2*sig*s*betaW)
        xm2( 1, 0,k) =-amZ2/SQRT(2*s)/amW/Zpro*(t - u - 2*sig*s*betaW)
        xm2(-1, 0,k) =-amZ2/SQRT(2*s)/amW/Zpro*(t - u + 2*sig*s*betaW)
        xm1( 0, 0,k) = utmW*(-(s*t + 4*amW4)/t/amW2/s/betW2 
     &                      + (s + 2*amW2)/amW2/Zpro )
        xm2( 0, 0,k) =-utmW* amZ2*(s + 2*amW2)/amW2/s/Zpro 
        xm1(-1,-1,k) = xm1( 1, 1,k)
        xm2(-1,-1,k) = xm2( 1, 1,k)
        xm1( 0,-1,k) = xm1( 1, 0,k)
        xm2( 0,-1,k) = xm2( 1, 0,k)
        xm1( 0, 1,k) = xm1(-1, 0,k)
        xm2( 0, 1,k) = xm2(-1, 0,k)
      ENDDO
! Form factors
      F1mlog = 0
      F1plog = 0
      teHi = 0.25*LOG(amH2/amW2)*fsM(Ecms,amH,amW) 
      teto = LOG(amt2/amW2)*fsM(Ecms,amt,amW)
      fact = alfpi/(24*sW2*cW2)*s/amZ2
      F2mlog = fact/2/sW2*(teHi + (3*cW2-sW2)*teto)
      F2plog = fact*(teHi - teto)
      IF (s.LT.4*amZ2) THEN
        beinZ = SQRT(1 - s/4/amZ2)
        Wprot = t - amW2
        F1pZZ = alfa/2*(sW2/cW2 + 5)*(4/s*Wprot + cW2)*ATAN(beinZ) 
        F2pZZ = alfa/2/cW2*(11 - 8*sW2*(3-2*sW2) + (2+8*sW2)/s*Wprot)
     &                    *ATAN(beinZ)
      ELSE
        F1pZZ = 0
        F2pZZ = 0
      ENDIF
      F1mfit = C1m
      F1pfit = C1p*t/amW2*(2*amZ/Ecms)**7
      F2mfit = C2m*2/s*(amW2 - t)*(4*amZ2/s)**2
      F2pfit = C2p*betW2
      ff1(1) = F1mlog + F1mfit
      ff2(1) = F2mlog + F2mfit
      ff1(2) = F1plog + F1pZZ + F1pfit
      ff2(2) = F2plog + F2pZZ + F2pfit
      END


      FUNCTION YFSWW_WtNL(Iflav,pf1,pf2,pf3,pf4,Phot,Nphot)    
*     *****************************************************    
!----------------------------------------------------------------------!
! Interface for re-weighting ISR-type events generated by KoralW in    !
! order to correct for O(alpha) NL EW effects and radiation from W's.  ! 
! In such a case flavours and 4-momenta of final fermions as well as   !
! 4-momenta of all photons, but WITHOUT modifications made by PHOTOS,  !
! should be provided from KoralW through input parameters (see below). ! 
!                                                                      !
! INPUT: Iflav - flavours of final state 4 fermions in PDG convention  !
!                Iflav(1) corresponds to pf1, etc.                     ! 
!        pf1,pf2 - 4-momenta of W- decay products (f1, f2~), resp.     !
!        pf3,pf4 - 4-momenta of W+ decay products (f3, f4~), resp.     !
!        Phot  - all photon 4-momenta (excluding ones from PHOTOS)     !
!        Nphot - number of photons (without ones from PHOTOS)          !
! OUTPUT: The ratio Wt_Best/Wt_ISR of the "Best" weight Wt_Best        ! 
!         (i.e. including EW NL corr. and radiation from W's) and      !
!         the "ISR" weight (i.e. including only universal corrections  ! 
!         - like in KoralW). This ratio can be use for re-weighting    !
!         KORALW events or for correcting KORALW weights (in the case  !
!         of weighted events).                                         !
! Note: The Coulomb correction is the same in both Wt_Best and Wt_ISR, !
!       so this re-weighting does not correct e.g. for screening the   !
!       Coulomb effect (this has to be done, if necessary, with KoralW)! 
! When using this function make the following declarations:            !
!      INTEGER Iflav(4),Nphot                                          !
!      DOUBLE PRECISION pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)        !  
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                         CERN, Nov. 2000  !
! Last update: 26.01.2001           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DIMENSION Iflav(4),pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)
! Physical parameters, etc.
      COMMON / WEKING / ENE,AMAZ,GAMMZ,AMEL,AMFIN,XK0,SINW2,IDE,IDF 
      COMMON / WEKIN2 / AMAW,GAMMW,GMU,ALPHAW
      COMMON / VVREC  / VVMIN,VVMAX,VV,BETI
! W-,W+ and photon 4-momenta after ISR
      COMMON / MOMINI / xw1(4),xw2(4),xphum(4),xphot(100,4),nphox 
! 4-momenta of final W-,W+ and of photons radiated from W's 
      COMMON / MOMFIN / yw1(4),yw2(4),yphum(4),yphot(100,4),nphoy 
! 4-momenta of final 4-fermions and photons
      COMMON / MOMDEC / pd1(4),pd2(4),pd3(4),pd4(4),pho(100,4),npho    
! 4-momenta of W's and photons
      COMMON / MOMWWP / qw1(4),qw2(4),sphum(4),sphot(100,4),nphos  
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
! Angles for fermion kinematics
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
! Weights ...
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)         
! Various switches
      COMMON / KeyOth / KeyCor,KeyDW1,KeyDW2,KeyAcc
      SAVE   / WEKING /, / WEKIN2 /, / VVREC  /, / MOMINI /, / MOMFIN /,
     &       / MOMDEC /, / MOMWWP /,
     &       / WWINVM /, / WWANGL /, / WGTALL /, / KeyOth /
      DIMENSION pfx(4),p1(4),p2(4)
      DATA Iwarn /0/
      SAVE Iwarn
!
! Construct 4-momenta of W's
      DO k = 1,4 
         xw1(k) = pf1(k) + pf2(k)
         xw2(k) = pf3(k) + pf4(k)
      ENDDO
      s1 = xw1(4)**2 - xw1(3)**2 - xw1(2)**2 - xw1(1)**2
      s2 = xw2(4)**2 - xw2(3)**2 - xw2(2)**2 - xw2(1)**2
!>> Check if W invariant masses not too small (problems with EW library)
      simin = 1d0
      IF (Iwarn.EQ.0) THEN
         WRITE(*,*)'============> FUNCTION YFSWW_WtNL <================' 
         WRITE(*,*)'>>> WARNING: If any of W invariant masses <',
     &             SQRT(simin),' GeV' 
         WRITE(*,*)'>>>          Reweighting weight: Wt_NL set to 1.0'
         WRITE(*,*)'>>>          Because of problems with EW Library'
         WRITE(*,*)'==================================================='
         Iwarn = 1
      ENDIF
      IF (s1.LT.simin .OR. s2.LT.simin) THEN
         Wt_NL = 1d0
         YFSWW_WtNL = Wt_NL
         RETURN
      ENDIF
!>> If W invariant masses not too small, start calculation ...
      WTCRU1 = 1d0
      WTCRU2 = 1d0
! Decode final state 
      CALL WdeCof(Iflav)
! Fill COMMON blocks
      DO k = 1,4 
         qw1(k) = xw1(k)
         qw2(k) = xw2(k)
         pd1(k) = pf1(k)
         pd2(k) = pf2(k)
         pd3(k) = pf3(k)
         pd4(k) = pf4(k)
      ENDDO
      nphox = Nphot
      nphoy = 0
      npho  = Nphot
      nphos = Nphot
      DO k = 1,4 
         xphum(k) = 0d0
         DO i = 1,nphox
            xphot(i,k) = Phot(i,k)
            xphum(k)   = xphum(k) + xphot(i,k)
            pho(i,k)   = Phot(i,k)
            sphot(i,k) = Phot(i,k)
         ENDDO
         sphum(k) = xphum(k)
         yw1(k) = xw1(k)
         yw2(k) = xw2(k)
         yphum(k) = 0d0
      ENDDO
! Merge momenta and transform to CMS      
      CALL MERGIF 
! Calculate W-,W+ invariant masses
      amWm = SQRT(s1) 
      amWp = SQRT(s2) 
! Find fermion angles in respective W rest-frames 
      ctn = 0d0
      fin = 0d0
      CALL bostdq( 1,xw1,pf1,pfx)
      ct1n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi1n = ANGFIX(pfx(2),pfx(1))
      CALL bostdq( 1,xw2,pf3,pfx)
      ct2n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi2n = ANGFIX(pfx(2),pfx(1))
! Effective CMS energy squared 
      sprim = ( xw1(4) + xw2(4) )**2 - ( xw1(3) + xw2(3) )**2
     &      - ( xw1(2) + xw2(2) )**2 - ( xw1(1) + xw2(1) )**2
! YFS Form-Factor weight (correcting for missing non-IR parts)
      CMSENE = 2*ENE
      CALL GIBEA(CMSENE,AMEL,p1,p2)        
      CALL GIFYFS(p1,p2,WtYIn)
! Weight of Coulomb effect for ISR-type result
      KeyTmp = KeyCor
      KeyCor = 2
      WtCisr = WTCoul(sprim,s1,s2,amaW,GammW)
! Weight correcting for I-F interferences in YFS formfactor and S-factors
      KeyCor = 3
      WtIFi = WtStYf(CMSENE,AMEL,amWm,amWp,VVMIN)
! Weight of Coulomb effect
      WtCbst = WTCoul(sprim,s1,s2,amaW,GammW)
! Calculate Model Weight ("Best")
      KeyCor = KeyTmp
      CALL MODEL(0,1d0,WtMbst)
      WtMisr = WtSet(4)
! Total weights
      Wt_ISR  = WtCisr*WtMisr
      Wt_Best = WtIFi*WtCbst*WtMbst
! NL correction weight for re-weighting
      IF (Wt_ISR.NE.0d0) THEN
         Wt_NL = Wt_Best/Wt_ISR
      ELSE
         Wt_NL = 1d0
      ENDIF
      YFSWW_WtNL = Wt_NL
      END           ! YFSWW_WtNL

      SUBROUTINE WdeCof(Ifl)   
*     **********************   
!----------------------------------------------------------------------!
! Auxiliary routine used by FUNCTION YFSWW_WtNL.                       !
! It tranlates final state 4f PDG codes into W-decay channel codes.    !
! INPUT: Ifl - flavours of 4f final state in PDG convention            !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek,                     CERN, Octber 2000   !
! Last update: 21.11.2000       by: WP                                 !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      DIMENSION Ifl(4)
      COMMON / DECDAT / AMAFIN(20), BR(20) 
      COMMON / DECCOD / ICOD(20)
      COMMON / DECAYS / Iflav(4),amdec(4)
      COMMON / DeChan / IchaWm,IchaWp
      SAVE   / DECDAT /, / DECCOD /, / DECAYS /, / DeChan /
!
! Flavours and masses of corresponding final state fermions
      DO i = 1,4
         IFLAV(i) = Ifl(i)
         ifa = IABS(iflav(i))
         amdec(i) = amafin(ifa)
      ENDDO
! Decode 4f final state into W-decay channels
      icfm = 100*Ifl(1) - Ifl(2)
      icfp =-100*Ifl(4) + Ifl(3)
      IchaWm = 0
      DO ic = 1,9
         IF (icfm.EQ.icod(ic)) THEN
            IchaWm = ic
            GOTO 10
         ENDIF
      ENDDO
 10   CONTINUE
      IF (IchaWm.EQ.0) THEN
         WRITE(6,*)'>> WdeCof: IchaWm = 0 !!!'
         WRITE(6,*)'>> SOMETHING WRONG WITH 4f FLAVOURS !!!'
        STOP
      ENDIF
      IchaWp = 0
      DO ic = 1,9
         IF (icfp.EQ.icod(ic)) THEN
            IchaWp = ic
            GOTO 20
         ENDIF
      ENDDO
 20   CONTINUE
      IF (IchaWp.EQ.0) THEN
         WRITE(6,*)'>> WdeCof: IchaWp = 0 !!!'
         WRITE(6,*)'>> SOMETHING WRONG WITH 4f FLAVOURS !!!'
        STOP
      ENDIF
      END      ! WdeCof


      SUBROUTINE YFSWW_WME(WtME)    
*     **************************    
!----------------------------------------------------------------------!
! Interface for re-weighting YFSWW generated events with YFSWW weights !
! for different input paramers values (RECOMMENDED version).           !
! For each event information of four common bloks: /MOMINI/, /MOMFIN/, !
! /MOMDEC/ and / DeChan / should be stored and then provided for       !
! re-weighting.                                                        !
! OUTPUT: WtME - a weight corresponding to the matrix element (in some !
!                arbitrary units)                                      !
! In a re-weighting method a ratio of two such weights for a given     !
! event corresponding to two different input paremeters set-ups should !
! be used.                                                             !
! NOTE: The user should add a respective code for reading events from  !
! a disk/tape and filling appropriate COMMON blocks (see below).       !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                        CERN, Sept. 2000  !
! Last update: 02.10.2000           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
! Value of transition velocity for Coulomb correction
      PARAMETER (betat = 0.382d0)
! 4-momenta of final fermions and photons
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4),Nphot 
! W-,W+ and photon 4-momenta after ISR
      COMMON / MOMINI / xw1(4),xw2(4),xphum(4),xphot(100,4),nphox 
! 4-momenta of final W-,W+ and of photons radiated from W's 
      COMMON / MOMFIN / yw1(4),yw2(4),yphum(4),yphot(100,4),nphoy 
! W-,W+ decay channel codes
      COMMON / DeChan / IchaWm,IchaWp
      SAVE   / MOMDEC /, / MOMINI /, / MOMFIN /, / DeChan /
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
! Angles for fermion kinematics
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
      SAVE   / WWINVM /, / WWANGL /
! Switch for matching Coulomb correction with YFS formfactor
      COMMON / Coutra / KeyCou
      SAVE   / Coutra /
      DIMENSION pfx(4)
!
! READ data from a disk/tape and fill COMMON blocks:
! / MOMDEC /, / MOMINI /, / MOMFIN /, / DeChan /
!===========================================================
! >>> Here should come the actual user code ...


!===========================================================
! Set final 4f flavours and masses
      CALL FsfCodes(IchaWm,IchaWp)
! Merge momenta and transform to CMS      
      CALL MERGIF 
! Calculate W-,W+ invariant masses
      s1 = yw1(4)**2 - yw1(3)**2 - yw1(2)**2 - yw1(1)**2
      s2 = yw2(4)**2 - yw2(3)**2 - yw2(2)**2 - yw2(1)**2
! Find fermion angles in respective W rest-frames 
      CALL bostdq( 1,yw1,pf1,pfx)
      ct1n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi1n = ANGFIX(pfx(2),pfx(1))
      CALL bostdq( 1,yw2,pf3,pfx)
      ct2n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi2n = ANGFIX(pfx(2),pfx(1))
! Interpolation to match Coulomb correction with YFS formfactor 
      s = ( yw1(4) + yw2(4) )**2 - ( yw1(3) + yw2(3) )**2
     &  - ( yw1(2) + yw2(2) )**2 - ( yw1(1) + yw2(1) )**2
      beta = SQRT( 1 - 2*(s1+s2)/s + ((s1-s2)/s)**2 )
      IF (beta.GT.betat) THEN
         KeyCou = 0
      ELSE
         KeyCou = 1
      ENDIF 
! Calculate Model Weight  
      CALL MODEL(0,1d0,WTMDL)
      WtME = WTMDL
      END

      FUNCTION YFSWW_WME_Smpl(Iflav,pf1,pf2,pf3,pf4,Phot,Nphot)    
*     *********************************************************    
!----------------------------------------------------------------------!
! Interface for re-weighting YFSWW generated events with YFSWW weights !
! (for different input parameters values) for the case when COMMON     !
! blocks / MOMINI /, / MOMFIN /, / DeChan / have not been saved.       !
! In such a case flavours and 4-momenta of final fermions as well as   !
! 4-momenta of all photons, but WITHOUT modifications made by PHOTOS,  !
! should be stored for each event and then provided through input      !
! parameters (see below). Such information is provided  by the COMMON  !
! blocks:                                                              !
!     COMMON / DECAYS / Iflav(4),amdec(4)                              !
!     COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4),Nphot  !
!                                                                      !
! INPUT: Iflav - flavours of final state fermions in PDG convention    !
!                Iflav(1) corresponds to pf1, etc.                     ! 
!        pf1,pf2 - 4-momenta of W- decay products (f1, f2~), resp.     !
!        pf3,pf4 - 4-momenta of W+ decay products (f3, f4~), resp.     !
!        Phot  - all photon 4-momenta (excluding ones from PHOTOS)     !
!        Nphot - number of photons (without ones from PHOTOS)          !
! OUTPUT: matrix element WEIGHT for a given input parameters set-up.   !
! In a re-weighting method a ratio of two such weights for a given     !
! event corresponding to two different input paremeters set-ups should !
! be used.                                                             !
! When using this function make the following declarations:            !
!      INTEGER Iflav(4),Nphot                                          !
!      DOUBLE PRECISION pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)        !  
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek                         CERN, Sep. 2000  !
! Last update: 28.11.2000           by: W.P.                           !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
! Value of transition velocity for Coulomb correction
      PARAMETER (betat = 0.382d0)
      DIMENSION Iflav(4),pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4)
! W-,W+ and photon 4-momenta after ISR
      COMMON / MOMINI / xw1(4),xw2(4),xphum(4),xphot(100,4),nphox 
! 4-momenta of final W-,W+ and of photons radiated from W's 
      COMMON / MOMFIN / yw1(4),yw2(4),yphum(4),yphot(100,4),nphoy 
! W-/W+ invariant masses squared
      COMMON / WWINVM / s1,s2
! Angles for fermion kinematics
      COMMON / WWANGL / ctn,fin,ct1n,fi1n,ct2n,fi2n
! Switch for matching Coulomb correction with YFS formfactor
      COMMON / Coutra / KeyCou
      SAVE   / MOMINI /, / MOMFIN /, / WWINVM /, / WWANGL /, / Coutra /
      DIMENSION pfx(4)
!
! Decode final state 
      CALL WdeCod(Iflav)
! Fill COMMON blocks
      nphox = nphot
      nphoy = 0
      DO k = 1,4 
         xw1(k) = pf1(k) + pf2(k)
         xw2(k) = pf3(k) + pf4(k)
         xphum(k) = 0d0
         DO i = 1,nphot
            xphot(i,k) = Phot(i,k)
            xphum(k) = xphum(k) + xphot(i,k)
         ENDDO
         yw1(k) = xw1(k)
         yw2(k) = xw2(k)
         yphum(k) = 0d0
      ENDDO
! Merge momenta and transform to CMS      
      CALL MERGIF 
! Calculate W-,W+ invariant masses
      s1 = xw1(4)**2 - xw1(3)**2 - xw1(2)**2 - xw1(1)**2
      s2 = xw2(4)**2 - xw2(3)**2 - xw2(2)**2 - xw2(1)**2
! Find fermion angles in respective W rest-frames 
      ctn = 0d0
      fin = 0d0
      CALL bostdq( 1,xw1,pf1,pfx)
      ct1n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi1n = ANGFIX(pfx(2),pfx(1))
      CALL bostdq( 1,xw2,pf3,pfx)
      ct2n = pfx(3)/SQRT( pfx(1)**2 + pfx(2)**2 + pfx(3)**2 )
      fi2n = ANGFIX(pfx(2),pfx(1))
! Interpolation to match Coulomb correction with YFS formfactor 
      s = ( yw1(4) + yw2(4) )**2 - ( yw1(3) + yw2(3) )**2
     &  - ( yw1(2) + yw2(2) )**2 - ( yw1(1) + yw2(1) )**2
      beta = SQRT( 1 - 2*(s1+s2)/s + ((s1-s2)/s)**2 )
      IF (beta.GT.betat) THEN
         KeyCou = 0
      ELSE
         KeyCou = 1
      ENDIF 
! Calculate Model Weight  
      CALL MODEL(0,1d0,WTMDL)
      YFSWW_WME_Smpl = WTMDL
      END

      SUBROUTINE WdeCod(Ifl)   
*     **********************   
!----------------------------------------------------------------------!
! Auxiliary routine used by FUNCTION YFSWW_WME_Smpl.                   !
! It tranlates final state 4f PDG codes into W-decay channel codes.    !
! INPUT: Ifl - flavours of 4f final state in PDG convention            !
!----------------------------------------------------------------------!
! Written by: Wieslaw Placzek,                     CERN, Octber 2000   !
! Last update: 01.10.2000       by: WP                                 !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION  (A-H,O-Z)  
      DIMENSION Ifl(4)
      COMMON / DECDAT / AMAFIN(20), BR(20) 
      COMMON / DECCOD / ICOD(20)
      COMMON / DECAYS / Iflav(4),amdec(4)
      COMMON / DeChan / IchaWm,IchaWp
      SAVE   / DECDAT /, / DECCOD /, / DECAYS /, / DeChan /
!
! Flavours and masses of corresponding final state fermions
      DO i = 1,4
         IFLAV(i) = Ifl(i)
         ifa = IABS(iflav(i))
         amdec(i) = amafin(ifa)
      ENDDO
! Decode 4f final state into W-decay channels
      icfm = 100*Ifl(1) - Ifl(2)
      icfp =-100*Ifl(4) + Ifl(3)
      IchaWm = 0
      DO ic = 1,9
         IF (icfm.EQ.icod(ic)) THEN
            IchaWm = ic
            GOTO 10
         ENDIF
      ENDDO
 10   CONTINUE
      IF (IchaWm.EQ.0) THEN
         WRITE(6,*)'>> WdeCod: IchaWm = 0 !!!'
         WRITE(6,*)'>> SOMETHING WRONG WITH 4f FLAVOURS !!!'
        STOP
      ENDIF
      IchaWp = 0
      DO ic = 1,9
         IF (icfp.EQ.icod(ic)) THEN
            IchaWp = ic
            GOTO 20
         ENDIF
      ENDDO
 20   CONTINUE
      IF (IchaWp.EQ.0) THEN
         WRITE(6,*)'>> WdeCod: IchaWp = 0 !!!'
         WRITE(6,*)'>> SOMETHING WRONG WITH 4f FLAVOURS !!!'
        STOP
      ENDIF
      END
************************************************************************
* Simple tests of re-weighting procedure: a check that the matrix      *
* element calculated from disk/tape stored events can reproduce the    *
* one calculated during a normal run of the program, i.e. MC event     *
* generation. The routine DumpEv is called during a normal run of the  *
* program (after CALL YFSWW_Make) in order to save an event (4-momenta *
* of fermions and photons and values of the matrix element) on a disk, *
* while the routine ReadEv is called in a non-standard run of the      *
* program, INSTEAD of YFSWW_Make, but AFTER YFSWW_Initialize(xpar),    *
* in order to read a single event from a disk file and calculate the   *
* matrix element weight (and compare with the stored values).          *
*----------------------------------------------------------------------*
* NOTE: Our experience on Linux shows that one needs to save 4-momenta *
* with a precision of at least 18 decimal digits (e.g. using the       *
* format E26.18) in order to reproduce the matrix element to a high    *
* accuracy (~1d-12). With the lower precision the accuracy of the      *
* results deteriorates considerably.                                   *
************************************************************************

      SUBROUTINE DumpEv(nufl)    
*     ***********************   
!----------------------------------------------------------------------!
! Dump event on the disk.                                              !
! INPUT: nufl - file unit number (to write an event)                   !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
! 4-momenta of final fermions and photons
      COMMON / MOMDEC / pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4),Nphot 
      COMMON / WGTALL / WTMOD,WTCRU1,WTCRU2,WTSET(100)      
      COMMON / DECAYS / Iflav(4),amdec(4)
      SAVE / MOMDEC /, / WGTALL /, / DECAYS /
!
      wtcr = wtcru1*wtcru2
      IF (wtcr.NE.0d0) THEN
         WRITE(nufl,'(4I4)')( Iflav(k),k=1,4 )
         WRITE(nufl,'(4E26.18)')( pf1(k),k=1,4 )      
         WRITE(nufl,'(4E26.18)')( pf2(k),k=1,4 )
         WRITE(nufl,'(4E26.18)')( pf3(k),k=1,4 )      
         WRITE(nufl,'(4E26.18)')( pf4(k),k=1,4 )
         WRITE(nufl,'(I4)') Nphot
         DO i = 1,Nphot
            WRITE(nufl,'(4E26.18)')( Phot(i,k),k=1,4 )
         ENDDO
         wtme = YFSWW_WME_Smpl(Iflav,pf1,pf2,pf3,pf4,Phot,Nphot)
         CALL MODEL(0,1d0,wtmdl)
         WRITE(nufl,'(2E26.18)') wtmdl,wtme
      ENDIF
      END

      SUBROUTINE ReadEv(nufl)    
*     ***********************
!----------------------------------------------------------------------!
! Read events from the disk.                                           !
! INPUT: nufl - file unit number (to read an event)                    !
!----------------------------------------------------------------------!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DIMENSION Iflav(4),pf1(4),pf2(4),pf3(4),pf4(4),Phot(100,4) 
!
      READ(nufl,'(4I4)',END=101) ( Iflav(k),k=1,4 )          
      READ(nufl,'(4E26.18)')( pf1(k),k=1,4 )      
      READ(nufl,'(4E26.18)')( pf2(k),k=1,4 )
      READ(nufl,'(4E26.18)')( pf3(k),k=1,4 )      
      READ(nufl,'(4E26.18)')( pf4(k),k=1,4 )
      READ(nufl,'(I4)') Nphot
      DO i = 1,Nphot
         READ(nufl,'(4E26.18)')( Phot(i,k),k=1,4 )
      ENDDO
      READ(nufl,'(2E26.18)') wtmdl,wtme
! Calculate matrix element weight from read-in 4-momenta 
! and compare with the stored ones
      wtmx = YFSWW_WME_Smpl(Iflav,pf1,pf2,pf3,pf4,Phot,Nphot)
      IF (ABS(wtmx/wtme-1d0).GT.1d-12) THEN
         CALL DUMPW(6)
         PRINT*,'Iflav = ',Iflav
         PRINT*,'wtmdl,wtme,wtmx     =',wtmdl,wtme,wtmx
         PRINT*,'wtmx/wtmdl,wtmx/wtme=',wtmx/wtmdl,wtmx/wtme
      ENDIF
      RETURN
! End of file ...
 101  CONTINUE
      PRINT*,'>>> END OF FILE REACHED !!!'
      STOP
      END
!======================================================================
!======================= G L I B K  ===================================
!==================General Library of utilities========================
!===========It is similar but not identical to HBOOK and HPLOT=========
!======================================================================
!   
!                      Version:    1.20
!              Last correction:    September 1996
!
!
!  Installation remarks: 
!  (1) printing backslash character depends on F77 compilator,
!      user may need to modify definition of BS variable in HPLCAP
!
!  Usage of the program:
!  (1) In most cases names and meanings of programs and their 
!      parameters is the same as in original CERN libraries HBOOK
!  (2) Unlike to original HBOOK and HPLOT, all floating parameters 
!      of the programs are in double precision!
!  (3) GLIBK stores histograms in double precision and always with
!      errors. REAL*8 storage is essential for 10**7 events statistics!
!  (4) Output from GLIBK is a picture recorded as regular a LaTeX file 
!      with frame and curves/histograms, it is easy to change fonts
!      add captions, merge plots, etc. by normal editing. Finally,
!      picture may be inserted in any place into LaTeX source of the
!      article.
!  (5) WARNING: two-dimensional histograms are not active!!!
!
!  ********************************************************************
!  *  History of the program:                                         *
!  *  MINI-HBOOK writen by S. Jadach, Rutherford Lab. 1976            *
!  *  Rewritten December 1989 (S.J.)                                  *
!  *  Version with DOUBLE PRECISION ARGUMENTS ONLY!  and SAVE         *
!  *  Subprogram names start with G instead of H letter!               *
!  *  Entries:   Obligatory:  GLIMIT                                  *
!  *             Optional: see table below                            *
!  *  non-user subprograms in brackets                                *
!  ********************************************************************
!    SUBR/FUNC  1 PAR. 2 PAR. 3 PAR. 4 PAR. 5 PAR. 6 PAR.       
!  ====================================================================
*     (G_INIT)  ----   ----    ----   ----   ----   ----        
*      GI       INT    INT     ----   ----   ----   ----        
*      GIE      INT    INT     ----   ----   ----   ----        
*      GF1      INT    DBL     DBL    ----   ----   ----        
*      GFILL    INT    DBL     DBL    DBL    ----   ----        
*      GBOOK1   INT    CHR*80  INT    DBL    DBL    ----  
*     (GOPTOU)  INT    INT     INT    INT    INT     INT
* (L.F. GEXIST) INT    -----  ------  ----   ----   ----        
*      GIDOPT   INT    CHR*4   -----  ----   ----   ----        
*      GBFUN1   INT    CHR*80   INT   DBL    DBL  DP-FUNC       
*      GIDOPT   INT    CHR*4   -----  ----   ----   ----        
*      GBOOK2   INT    CHR*80   INT   DBL    DBL     INT   DBL   DBL
*      GISTDO     ---   ----   ----   ----   ----   ----        
*      GOUTPU   INT     ----   ----   ----   ----   ----        
*      GPRINT   INT     ----   ----   ----   ----   ----        
*      GOPERA   INT    CHR*1   INT    INT    DBL    DBL         
*      GINBO1   INT    CHR*8   INT    DBL    DBL    ----        
*      GUNPAK   INT    DBL(*) CHR*(*) INT    ---    ----        
*      GPAK     INT    DBL(*)  ----   ----   ---    ----        
*      GPAKE    INT    DBL(*)  ----   ----   ---    ----       
*      GRANG1   INT    DBL     DBL    ----   ---    ----        
*      GINBO2   INT    INT     DBL    DBL    INT    DBL   DBL      
*      GMAXIM   INT    DBL     ----   ----   ---    ----        
*      GMINIM   INT    DBL     ----   ----   ---    ----        
*      GRESET   INT   CHR*(*)  ----   ----   ---    ----        
*      GDELET   INT     ----   ----   ----   ----   ----        
*      GLIMIT   INT     ----   ----   ----   ----   ----        
*     (COPCH)   CHR*80 CHR*80  ----   ----   ----   ----        
* (F. JADRES)   INT     ----   ----   ----   ----   ----        
*      GRFILE   INT   CHR*(*) CHR*(*) ----   ----   ----        
*      GROUT    INT    INT    CHR*8   ----   ----   ----        
*      GRIN     INT    INT     INT    ----   ----   ----        
*      GREND   CHR*(*) ----    ----   ----   ----   ----        
!  *******************  HPLOT entries ******************
*      GPLINT   INT    ----    ----   ----   ----   ----        
*      GPLCAP   INT    ----    ----   ----   ----   ----        
*      GPLEND   ----   ----    ----   ----   ----   ----        
*      GPLOT    INT    CHR*1   CHR*1   INT   ----   ----        
*     (LFRAM1)  INT      INT     INT  ----   ----   ----        
*     (SAXIX)   INT      DBL     DBL   INT    DBL   ----        
*     (SAXIY)   INT      DBL     DBL   INT    DBL   ----        
*     (PLHIST)  INT      INT     DBL   DBL    INT    INT        
*     (PLHIS2)  INT      INT     DBL   DBL    INT    INT        
*     (PLCIRC)  INT      INT     INT   DBL    DBL    DBL        
*     (APROF)   DBL      INT     DBL  ----   ----   ----        
*      GPLSET   INT      DBL    ----  ----   ----   ----        
*      GPLTIT   INT    CHR*80   ----  ----   ----   ----        
!  *******************  WMONIT entries ******************
*      GMONIT   INT ???
!  *******************************************************************
!                         END OF TABLE        
!  *******************************************************************
*          Map of memory for single histogram
*          ----------------------------------
*  (1-7) Header
*  ist +1   mark      9999999999999
*  ist +2   mark      9d12 + id*10 + 9
*  ist +3   iflag1    9d12 + iflag1*10 +9
*  ist +4   iflag2    9d12 + iflag2*10 +9
*  ist +5   scamin    minimum y-scale
*  ist +6   scamax    maximum y-scale
*  ist +7   jdlast    address of the next histogram 
*                     from previous history of calls (see jadres)
*          ----------------------------------
*              Binning size informations
*          ----------------------------------
*  One dimensional histogram            Two dimensional histog.
*  -------------------------            ----------------------
*  (8-11) Binning information           (8-15) Binning information
*  ist2 +1    NCHX                          ist2 +5   NCHY
*  ist2 +2      XL                          ist2 +6     YL
*  ist2 +3      XU                          ist2 +7     YU
*  ist2 +4   FACTX                          ist2 +8  FACTY
*
*          ----------------------------------
*           All kind of sums except of maxwt
*          ----------------------------------
*  (12-24) Under/over-flow average x    (16-24)
*  ist3 +1   Underflow                     All nine combinations
*  ist3 +2   Normal                        (U,N,O) x (U,N,O)
*  ist3 +3   Overerflow                    sum wt only (no errors)
*  ist3 +4   U  sum w**2
*  ist3 +5   N  sum w**2
*  ist3 +6   O  sum w**2
*  ist3 +7   Sum 1
*  ist3 +8   Sum wt*x
*  ist3 +9   Sum wt*x*x
*  ist3 +10  nevzer    (gmonit)
*  ist3 +11  nevove    (gmonit)
*  ist3 +12  nevacc    (gmonit)
*  ist3 +13  maxwt     (gmonit)
*          ----------------------------------
*           Content of bins including errors
*          ----------------------------------
*  (25 to 24+2*nchx)                     (25 to 24 +nchx*nchy)
*     sum wt and sum wt**2            sum wt only (no errors)
*  ----------------------------------------------------------------

      SUBROUTINE g_init
*     ****************
! First Initialization called from may routines
*     *************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      SAVE   / cglib /
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      DATA init /0/
      SAVE init
*
      IF(init .NE. 0) RETURN
      init=1
! this is version version number
      nvrs=111
! default output unit
      nout=16
      lenmax=0
      length=0
      DO i=1,idmx
         DO k=1,3
            index(i,k)=0
         ENDDO
         DO k=1,80
            titlc(i)(k:k)=' '
         ENDDO
      ENDDO
      DO k=1,50000
         b(k)=0d0
      ENDDO
      END

      SUBROUTINE gflush
*     ****************
! FLUSH memory, all histos erased!
*     *************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      SAVE   / cglib /
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/

      CALL g_init
      length=0
      DO i=1,idmx
         DO k=1,3
            index(i,k)=0
         ENDDO
         DO k=1,80
            titlc(i)(k:k)=' '
         ENDDO
      ENDDO
      DO k=1,50000
         b(k)=0d0
      ENDDO
      END

      LOGICAL FUNCTION gexist(id)
!     ***************************
! this function is true when id  exists !!!! 
!     ***************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      gexist = lact .NE. 0
!###  IF(gexist)      WRITE(6,*) 'gexist: does   ID,lact= ',id,lact
!###  IF(.not.gexist) write(6,*) 'gexist: doesnt ID,lact= ',id,lact
      END

      FUNCTION gi(id,ib)
!     ******************
! getting out bin content
! S.J. 18-Nov. 90
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      SAVE idmem,nch,lact,ist,ist2,ist3
      DATA idmem / -1256765/
!
      IF(id .EQ. idmem) goto 100
      idmem=id
! some checks, not repeated if id the same as previously
      lact=jadres(id)
      IF(lact .EQ. 0) THEN
        WRITE(nout,*) ' gi: nonexisting histo id=',id
        WRITE(   6,*) ' gi: nonexisting histo id=',id
        gi= 0d0
        STOP
      ENDIF
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
! checking if histo is of proper type
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) THEN
        WRITE(nout,*) ' gi: 1-dim histos only !!! id=',id
        WRITE(   6,*) ' gi: 1-dim histos only !!! id=',id
        gi= 0d0
        STOP
      ENDIF
  100 continue
      nch  = nint(b(ist2+1))
      IF(ib .EQ. 0) THEN
! underflow
         gi=   b(ist3 +1)
      ELSEIF(ib .GE. 1.and.ib .LE. nch) THEN
! normal bin
         gi=   b(ist +nbuf+ib)
      ELSEIF(ib .EQ. nch+1) THEN
! overflow
         gi=   b(ist3 +3)
      ELSE
! abnormal exit
         WRITE(nout,*) ' gi: wrong binning id,ib=',id,ib
         WRITE(   6,*) ' gi: wrong binning id,ib=',id,ib
         gi=0d0
         STOP
      ENDIF
      END

      FUNCTION  gie(id,ib)
!     ********************
! getting out error of the bin
! s.j. 18-nov. 90
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      SAVE idmem,nch,lact,ist,ist2,ist3
      DATA idmem / -1256765/
!
      IF(id .EQ. idmem) goto 100
      idmem=id
! some checks, not repeated if id the same as previously
      lact=jadres(id)
      IF(lact .EQ. 0) THEN
        WRITE(nout,*) ' gie: nonexisting histo id=',id
        WRITE(   6,*) ' gie: nonexisting histo id=',id
        gie= 0d0
        STOP
      ENDIF
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
! checking if histo is of proper type
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) THEN
        WRITE(nout,*) ' gie: 1-dim histos only !!! id=',id
        WRITE(   6,*) ' gie: 1-dim histos only !!! id=',id
        gie= 0d0
        STOP
      ENDIF
  100 continue
      nch  = b(ist2+1)
      IF(ib .EQ. 0) THEN
! underflow
         gie=   dsqrt( dabs(b(ist3 +4)))
      ELSEIF(ib .GE. 1.and.ib .LE. nch) THEN
!...normal bin, error content
         gie=   dsqrt( dabs(b(ist+nbuf+nch+ib)) )
      ELSEIF(ib .EQ. nch+1) THEN
! overflow
         gie=   dsqrt( dabs(b(ist3 +6)))
      ELSE
! abnormal exit
         WRITE(nout,*) ' gie: wrong binning id, ib=',id,ib
         WRITE(   6,*) ' gie: wrong binning id, ib=',id,ib
         gie=0d0
         STOP
      ENDIF
      END

      SUBROUTINE gf1(id,xx,wtx)
!     ************************
! recommended fast filling 1-dim. histogram s.j. 18 nov. 90
! overflow/underflow corrected by Maciek and Zbyszek
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE
!
      lact=jadres(id)
! exit for non-existig histo
      IF(lact .EQ. 0)  RETURN
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
! one-dim. histo only
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) RETURN
      x1= xx
      wt1= wtx
      index(lact,3)=index(lact,3)+1
! all entries
      b(ist3 +7)  =b(ist3 +7)   +1
! for average x
      b(ist3 +8)  =b(ist3 +8)  +wt1*x1
      b(ist3 +9)  =b(ist3 +9)  +wt1*x1*x1
! filling coordinates
      nchx  =b(ist2 +1)
      xl    =b(ist2 +2)
      xu    =b(ist2 +3)
      factx =b(ist2 +4)
      IF(x1 .LT. xl) THEN
! underflow
         iposx1 = ist3 +1
         ipose1 = ist3 +4
         kposx1 = 0
      ELSEIF(x1 .GT. xu) THEN
! or overflow
         iposx1 = ist3 +3
         ipose1 = ist3 +6
         kposx1 = 0
      ELSE
! or any normal bin
         iposx1 = ist3 +2
         ipose1 = ist3 +5
! or given normal bin
         kx = (x1-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kposx1 = ist +nbuf+kx
         kpose1 = ist +nbuf+nchx+kx
      ENDIF
      b(iposx1) = b(iposx1)  +wt1
      b(ipose1) = b(ipose1)  +wt1*wt1
      IF( kposx1 .NE. 0) b(kposx1) = b(kposx1)  +wt1
      IF( kposx1 .NE. 0) b(kpose1) = b(kpose1)  +wt1*wt1
      END   !gf1

      SUBROUTINE gf1diff(id,xx,wtx,yy,wty)
!     ************************************
! Special filling routine to fill the difference f(x)-g(y)
! in the case when f and g are very similar x and y are close for each event.
! In this case coherent filling is done if x and y fall into the same bin.
! Note that bin width starts to be important in this method.
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE
!
      lact=jadres(id)
! exit for non-existig histo
      IF(lact .EQ. 0)  RETURN
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
! one-dim. histo only
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) RETURN
      x1= xx
      x2= yy
      wt1= wtx
      wt2= wty
      index(lact,3)=index(lact,3)+1
! all entries
      b(ist3 +7)  =b(ist3 +7)   +1
! for average x or y not very well defined yet
      b(ist3 +8)  =b(ist3 +8)  +wt1*x1 - wt2*x2
      b(ist3 +9)  =b(ist3 +9)  +wt1*x1*x1 - wt2*x2*x2
! filling coordinates
      nchx  =b(ist2 +1)
      xl    =b(ist2 +2)
      xu    =b(ist2 +3)
      factx =b(ist2 +4)
* first variable
      IF(x1 .LT. xl) THEN       ! underflow
         ix1 = ist3 +1
         ie1 = ist3 +4
         kx1 = 0
      ELSEIF(x1 .GT. xu) THEN   ! or overflow
         ix1 = ist3 +3
         ie1 = ist3 +6
         kx1 = 0
      ELSE                      ! normal bin
         ix1 = ist3 +2
         ie1 = ist3 +5
         kx = (x1-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kx1 = ist +nbuf+kx
         ke1 = ist +nbuf+nchx+kx
      ENDIF
* second variable
      IF(x2 .LT. xl) THEN       ! underflow
         ix2 = ist3 +1
         ie2 = ist3 +4
         kx2 = 0
      ELSEIF(x2 .GT. xu) THEN   ! or overflow
         ix2 = ist3 +3
         ie2 = ist3 +6
         kx2 = 0
      ELSE                      ! normal bin
         ix2 = ist3 +2
         ie2 = ist3 +5
         kx = (x2-xl)*factx+1d0
         kx = MIN( MAX(kx,1) ,nchx)
         kx2 = ist +nbuf+kx
         ke2 = ist +nbuf+nchx+kx
      ENDIF
* coherent filling
      IF( ix1 .EQ. ix2 ) THEN
         b(ix1) = b(ix1)  +wt1-wt2
         b(ie1) = b(ie1)  +(wt1-wt2)**2
      ELSE
         b(ix1) = b(ix1)  +wt1
         b(ie1) = b(ie1)  +wt1*wt1
         b(ix2) = b(ix2)  -wt2
         b(ie2) = b(ie2)  +wt2*wt2
      ENDIF
      IF( kx1 .EQ. kx2 ) THEN
         IF( kx1 .NE. 0) THEN 
            b(kx1) = b(kx1)  +wt1-wt2
            b(ke1) = b(ke1)  +(wt1-wt2)**2
         ENDIF
      ELSE
         IF( kx1 .NE. 0) THEN 
            b(kx1) = b(kx1)  +wt1
            b(ke1) = b(ke1)  +wt1*wt1
         ENDIF
         IF( kx2 .NE. 0) THEN 
            b(kx2) = b(kx2)  -wt2
            b(ke2) = b(ke2)  +wt2*wt2
         ENDIF
      ENDIF
      END   !gf1diff

      SUBROUTINE gfill(id,x,y,wtw)
*     ****************************
! this routine not finished, 1-dim only!
*     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE
!
      lact=jadres(id)
      IF(lact .EQ. 0)  RETURN
      ist  = index(lact,2)
! one-dim. histo 
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
!...one-dim. histogram
        CALL gf1(id,x,wtw)
        RETURN
      ENDIF
!...two-dim. scattergram, no errors!
      ist2 = ist+7
      ist3 = ist+15
      xx= x
      yy= y
      wt= wtw
      index(lact,3)=index(lact,3)+1
! x-axis
      nchx  =b(ist2 +1)
      xl    =b(ist2 +2)
      factx =b(ist2 +4)
      kx=(xx-xl)*factx+1d0
      lx=2
      IF(kx .LT. 1)     lx=1
      IF(kx .GT. nchx)  lx=3
      l     = ist+34  +lx
      b(l)  = b(l)    +wt
      k     = ist+nbuf2  +kx
      IF(lx .EQ. 2) b(k)  =b(k)  +wt
      k2    = ist+nbuf2  +nchx+kx
      IF(lx .EQ. 2) b(k2) =b(k2) +wt**2
! y-axix
      nchy  =b(ist2 +5)
      yl    =b(ist2 +6)
      facty =b(ist2 +8)
      ky=(yy-yl)*facty+1d0
      ly=2
      IF(ky .LT. 1)    ly=1
      IF(ky .GT. nchy) ly=3
! under/over-flow
      l = ist3  +lx +3*(ly-1)
      b(l) =b(l)+wt
! regular bin
      k = ist+nbuf2 +kx +nchx*(ky-1)
      IF(lx .EQ. 2.and.ly .EQ. 2) b(k)=b(k)+wt
      END

      SUBROUTINE gbook1(id,title,nnchx,xxl,xxu)
*     *****************************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      CHARACTER*80 title
      LOGICAL gexist
!
      CALL g_init
      IF(gexist(id)) goto 900
      ist=length
      lact=jadres(0)
! the case of no free entry in the index
      IF(lact .EQ. 0) goto 901
      index(lact,1)=id
      index(lact,2)=length
      index(lact,3)=0
*----
!cc      WRITE(6,*) 'GBOOK1: ID= ',ID
! -------
      CALL copch(title,titlc(lact))
      nchx =nnchx
      xl   =xxl
      xu   =xxu
! ---------- title and bin content ----------
      lengt2 = length +2*nchx +nbuf+1
      IF(lengt2 .GE. lenmax) goto 902
      do 10 j=length+1,lengt2+1
  10  b(j) = 0d0
      length=lengt2
!... default flags
      ioplog   = 1
      iopsla   = 1
      ioperb   = 1
      iopsc1   = 1
      iopsc2   = 1
      iflag1   = 
     $ ioplog+10*iopsla+100*ioperb+1000*iopsc1+10000*iopsc2
      ityphi   = 1
      iflag2   = ityphi
! examples of decoding flags 
!      id       = nint(b(ist+2)-9d0-9d12)/10
!      iflag1   = nint(b(ist+3)-9d0-9d12)/10
!      ioplog = mod(iflag1,10)
!      iopsla = mod(iflag1,100)/10
!      ioperb = mod(iflag1,1000)/100
!      iopsc1 = mod(iflag1,10000)/1000
!      iopsc2 = mod(iflag1,100000)/10000
!      iflag2   = nint(b(ist+4)-9d0-9d12)/10
!      ityphi = mod(iflag2,10)
!--------- buffer -----------------
! header
      b(ist +1)  = 9999999999999d0
      b(ist +2)  = 9d12 +     id*10 +9d0
      b(ist +3)  = 9d12 + iflag1*10 +9d0
      b(ist +4)  = 9d12 + iflag2*10 +9d0
! dummy vertical scale
      b(ist +5)  =  -100d0
      b(ist +6)  =   100d0
! pointer used to speed up search of histogram address
      b(ist +7)  =   0d0
! information on binning
      ist2       = ist+7
      b(ist2 +1) = nchx
      b(ist2 +2) = xl
      b(ist2 +3) = xu
      ddx = xu-xl
      IF(ddx .EQ. 0d0) goto 903
      b(ist2 +4) = float(nchx)/ddx
! under/over-flow etc.
      ist3       = ist+11
      do 100  j=1,13
 100  b(ist3 +j)=0d0
!
      RETURN
 900  continue
      WRITE(6   ,*) ' WARNING gbook1: already exists id=  ', id
      WRITE(NOUT,*) ' WARNING gbook1: already exists id=  ', id
      RETURN      
 901  continue
      CALL gstop1(' gbook1: to many histos !!!!!,     id=  ',id)
 902  continue
      CALL gstop1(' gbook1: to litle storage!!!!,  lenmax= ',lenmax)
 903  continue
      CALL gstop1('  gbook1:    xl=xu,               id=   ',id)
      END

      SUBROUTINE gstop1(mesage,id)
*     *******************************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE   /gind/
      CHARACTER*40 mesage

      WRITE(nout,'(a)') 
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(nout,'(a,a,i10,a)')  
     $                          '+ ', mesage, id, ' +'
      WRITE(nout,'(a)') 
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a)') 
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      WRITE(6   ,'(a,a,i10,a)')  
     $                          '+ ', mesage, id, ' +'
      WRITE(6   ,'(a)') 
     $          '++++++++++++++++++++++++++++++++++++++++++++++++++++++'
      STOP
      END


      SUBROUTINE goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
!     ********************************************************
! decoding option flags
!     **********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/

      lact=jadres(id)
      IF(lact .EQ. 0) RETURN
      ist=index(lact,2)
! decoding flags 
      iflag1   = nint(b(ist+3)-9d0-9d12)/10
      ioplog = mod(iflag1,10)
      iopsla = mod(iflag1,100)/10
      ioperb = mod(iflag1,1000)/100
      iopsc1 = mod(iflag1,10000)/1000
      iopsc2 = mod(iflag1,100000)/10000
      END

      SUBROUTINE gidopt(id,ch)
!     ************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      CHARACTER*4 ch
!
      lact=jadres(id)
      IF(lact .EQ. 0) RETURN
      ist=index(lact,2)
! decoding flags 
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      IF(ch .EQ.       'LOGY'  ) THEN
! log scale for print
        ioplog = 2 
      ELSEIF(ch .EQ.   'ERRO'  ) THEN
! errors in printing/plotting
       ioperb  = 2
      ELSEIF(ch .EQ.   'SLAN'  ) THEN
! slanted line in plotting
       iopsla  = 2
      ELSEIF(ch .EQ.   'YMIN'  ) THEN
       iopsc1  = 2
      ELSEIF(ch .EQ.   'YMAX'  ) THEN
       iopsc2  = 2
      ENDIF
! encoding back
      iflag1   = 
     $ ioplog+10*iopsla+100*ioperb+1000*iopsc1+10000*iopsc2
      b(ist+3) = 9d12 + iflag1*10 +9d0
      END


      SUBROUTINE gbfun1(id,title,nchx,xmin,xmax,func)
!     ***********************************************
! ...fills histogram with function func(x)
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      DIMENSION yy(200)
      EXTERNAL func
      CHARACTER*80 title
      LOGICAL gexist
!
      CALL g_init
      IF(gexist(id)) GOTO 900
 15   xl=xmin
      xu=xmax
      CALL gbook1(id,title,nchx,xl,xu)
!...slanted line in plotting
      CALL gidopt(id,'SLAN')
      IF(nchx .GT. 200) goto 901
      DO 20 ib=1,nchx
      x= xmin +(xmax-xmin)/nchx*(ib-0.5d0)
      yy(ib) = func(x)
   20 CONTINUE
      CALL gpak(id,yy)
      RETURN
 900  WRITE(nout,*) ' +++gbfun1: already exists id=',id
      WRITE(6   ,*) ' +++gbfun1: already exists id=',id      
      CALL gdelet(id)
      GO to 15
 901  WRITE(nout,*) ' +++gbfun1: to many bins'
      END

      SUBROUTINE gbfun2(id,title,nchx,xmin,xmax,func)
!     ***********************************************
! ...fills histogram with function func(x)
!.. three point fit used
!     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      DIMENSION yy(200),yy1(0:200)
      EXTERNAL func
      CHARACTER*80 title
      LOGICAL gexist
!
      CALL g_init
      IF( gexist(id) ) GOTO 900
 15   xl=xmin
      xu=xmax
      CALL gbook1(id,title,nchx,xl,xu)

!...slanted line in plotting
      CALL gidopt(id,'SLAN')
      IF(nchx.gt.200) GOTO 901

      yy1(0) = func(xmin)
      dx=(xmax-xmin)/nchx

      DO ib=1,nchx
         x2= xmin +dx*(ib-0.5d0)
         x3= x2 +dx*0.5d0
         yy(ib)  = func(x2)
         yy1(ib) = func(x3)
!..  simpson 
         yy(ib) = ( yy1(ib-1) +4*yy (ib) +yy1(ib))/6d0
      ENDDO

      CALL gpak(id,yy)
      RETURN
 900  WRITE(nout,*) ' +++gbfun2: already exists id=',id
      WRITE(6   ,*) ' +++gbfun2: already exists id=',id      
      CALL gdelet(id)
      GO TO 15
 901  WRITE(nout,*) ' +++gbfun2: to many bins'
      END



      SUBROUTINE GBOOK2(ID,TITLE,NCHX,XL,XU,NCHY,YL,YU)
*     *************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER( IDMX=400,NBUF=24,NBUF2=24)
      COMMON / Cglib / B(50000)
      COMMON /GIND/ NVRS,NOUT,LENMAX,LENGTH,INDEX(IDMX,3),TITLC(IDMX)
      CHARACTER*80 TITLC
      SAVE /cglib/,/gind/
      CHARACTER*80 TITLE
      LOGICAL GEXIST
!
      CALL g_init
      IF(GEXIST(ID)) GOTO 900
      ist=length
      LACT=JADRES(0)
      IF(LACT .EQ. 0) GOTO 901
      index(LACT,1)=ID
      index(LACT,2)=length
      CALL COPCH(TITLE,TITLC(LACT))
      nnchx=NCHX
      nnchy=NCHY
      LENGT2 = LENGTH  +44+nnchx*nnchy
      IF(LENGT2 .GE. LENMAX) GOTO 902
      DO 10 J=LENGTH+1,LENGT2+1
   10 B(J) = 0D0
      LENGTH=LENGT2
      B(ist+1)=nnchx
      B(ist+2)=XL
      B(ist+3)=XU
      B(ist+4)=float(nnchx)/(b(ist+3)-b(ist+2))
      B(ist+5)=nnchy
      B(ist+6)=YL
      B(ist+7)=YU
      B(ist+8)=float(nnchy)/(b(ist+7)-b(ist+6))
      RETURN
  900 WRITE(NOUT,*) ' GBOOK2: HISTO ALREADY EXISTS!!!! ID=',ID
      RETURN
  901 WRITE(NOUT,*) ' GBOOK2: TO MANY HISTOS !!!!!',LACT
      STOP
  902 WRITE(NOUT,*) ' GBOOK2: TO LITLE STORAGE!!!!',LENMAX
      STOP
      END

      SUBROUTINE gistdo
*     *****************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      do 10 i=1,idmx
      id=index(i,1)
      IF(id .GT. 0) call gprint(id)
   10 continue
      END

      SUBROUTINE goutpu(ilun)
*     ***********************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      CALL g_init
      nout=ilun
      END


      SUBROUTINE gprint(id)
*     *********************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      CHARACTER*1 line(0:105),lchr(22),lb,lx,li,l0
      LOGICAL llg
      SAVE lb,lx,li,l0,lchr
      DATA lb,lx,li,l0 /' ','X','I','0'/
      DATA lchr/' ','1','2','3','4','5','6','7','8','9',
     $      'A','B','C','D','E','F','G','H','I','J','K','*'/

      lact=jadres(id)
      IF(lact .EQ. 0) goto 900
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
      idec    = nint(b(ist+2)-9d0-9d12)/10
      IF(idec .NE. id) write(6,*) '++++GPRINT: PANIC! ID,IDEC= ',ID,IDEC

      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker    =  ioperb-1
      lmx = 67
      IF(ker .EQ. 1) lmx=54
      nent=index(lact,3)
      IF(nent  .EQ.  0)                          GOTO 901
      WRITE(nout,1000) id,titlc(lact)
 1000 FORMAT('1',/,1X,I9,10X,A)
!
! one-dim. histo 
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .NE. 1) goto 200
      nchx =   b(ist2 +1)
      xl   =   b(ist2 +2)
      dx   =  (  b(ist2 +3)-b(ist2 +2)  )/float(nchx)
! fixing vertical scale
      istr=ist+nbuf+1
      bmin = b(istr)
      bmax = b(istr)+1d-5*abs(b(istr))  ! problems for single bin case
      do 15 ibn=istr,istr+nchx-1
      bmax = max(bmax,b(ibn))
      bmin = min(bmin,b(ibn))
  15  continue
      IF(bmin  .EQ.  bmax)                       GOTO 903
      IF(iopsc1 .EQ. 2) bmin=b(ist +5)
      IF(iopsc2 .EQ. 2) bmax=b(ist +6)
!
      llg=ioplog .EQ. 2
      IF(llg.and.bmin .LE. 0d0) bmin=bmax/10000.d0
!
      deltb = bmax-bmin
      IF(deltb  .EQ.  0d0)                       GOTO 902
      fact  = (lmx-1)/deltb
      kzer  = -bmin*fact+1.00001d0
      IF(llg) fact=(lmx-1)/(log(bmax)-log(bmin))
      IF(llg) kzer=-log(bmin)*fact+1.00001d0
!
      undf = b(ist3 +1)
      ovef = b(ist3 +3)
      avex = 0d0
      sum  = b(ist3 +8)
      IF(nent .NE. 0) avex = sum/nent
      WRITE(nout,'(4a15      )')  'nent','sum','bmin','bmax'
      WRITE(nout,'(i15,3e15.5)')   nent,  sum,  bmin,  bmax
      WRITE(nout,'(4a15  )')      'undf','ovef','avex'
      WRITE(nout,'(4e15.5)')       undf,  ovef,  avex
!
      IF(llg) write(nout,1105)
 1105 format(35x,17hlogarithmic scale)
!
      kzer=max0(kzer,0)
      kzer=min0(kzer,lmx)
      xlow=xl
      do 100 k=1,nchx
! first fill with blanks
      do  45 j=1,105
   45 line(j)  =lb
! THEN fill upper and lower boundry
      line(1)  =li
      line(lmx)=li
      ind=istr+k-1
      bind=b(ind)
      bind= max(bind,bmin)
      bind= min(bind,bmax)
      kros=(bind-bmin)*fact+1.0001d0
      IF(llg) kros=log(bind/bmin)*fact+1.0001d0
      k2=max0(kros,kzer)
      k2=min0(lmx,max0(1,k2))
      k1=min0(kros,kzer)
      k1=min0(lmx,max0(1,k1))
      do 50 j=k1,k2
   50 line(j)=lx
      line(kzer)=l0
      z=b(ind)
      IF(ker .NE. 1) THEN
        WRITE(nout,'(a, f7.4,  a, d14.6,  132a1)') 
     $             ' ', xlow,' ',     z,' ',(line(i),i=1,lmx)
      ELSE
        er=dsqrt(dabs(b(ind+nchx)))
        WRITE(nout,'(a,f7.4,  a,d14.6,  a,d14.6, 132a1 )') 
     $             ' ',xlow,' ',    z,' ',   er,' ',(line(i),i=1,lmx)
      ENDIF
      xlow=xlow+dx
  100 continue
      RETURN
!------------- two dimensional requires complete restoration!!!----------------
  200 continue
      nchx=B(ist+1)
      nchy=B(ist+5)
      WRITE(nout,2000) (lx,i=1,nchy)
 2000 format(1h ,10x,2hxx,100a1)
      do 300 kx=1,nchx
      do 250 ky=1,nchy
      k=ist +NBUF2 +kx+nchx*(ky-1)
      N=B(K)+1.99999D0
      n=max0(n,1)
      n=min0(n,22)
      IF(DABS(b(k)) .LT. 1D-20) n=1
      line(ky)=lchr(n)
  250 continue
      line(nchy+1)=lx
      i1=nchy+1
      WRITE(nout,2100) (line(i),i=1,i1)
 2100 format(1h ,10x,1hx,100a1)
  300 continue
      WRITE(nout,2000) (lx,i=1,nchy)
      RETURN
  900 WRITE(NOUT,*) ' +++GPRINT: NONEXISTING HISTO',ID
      WRITE(6   ,*) ' +++GPRINT: NONEXISTING HISTO',ID
      RETURN
 901  WRITE(NOUT,*) ' +++GPRINT: nent.eq.0',ID
      WRITE(   6,*) ' +++GPRINT: nent.eq.0',ID
      RETURN
 902  WRITE(NOUT,*) ' +++GPRINT: wrong plotting limits',ID,bmin,bmax
      WRITE(   6,*) ' +++GPRINT: wrong plotting limits',ID,bmin,bmax
      RETURN
 903  WRITE(NOUT,*) ' +++GPRINT: bmin.eq.bmax',ID,bmin
      WRITE(   6,*) ' +++GPRINT: bmin.eq.bmax',ID,bmin
      END

      SUBROUTINE gopera(ida,chr,idb,idc,coef1,coef2)
*     **********************************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      CHARACTER*80 title
      CHARACTER*1  chr
!
      lacta=jadres(ida)
      IF(lacta .EQ. 0) RETURN
      ista  = index(lacta,2)
      ista2 = ista+7
      ncha  = b(ista2+1)
!
      lactb =jadres(idb)
      IF(lactb .EQ. 0) RETURN
      istb  = index(lactb,2)
      istb2 = istb+7
      nchb  = b(istb2+1)
      IF(nchb .NE. ncha) goto 900
!
      lactc=jadres(idc)
      IF(lactc .EQ. 0) THEN
! ...if nonexistent, histo idc is here defined
        CALL ginbo1(ida,title,nchx,xl,xu)
        CALL gbook1(idc,title,nchx,xl,xu)
        lactc = jadres(idc)
        istc  = index(lactc,2)
!...option copied from ida
        b(istc+ 3)= b(ista +3)
      ENDIF
!...one nominal entry recorded
      index(lactc,3) = 1
!
      istc  =  index(lactc,2)
      istc2 =  istc+7
      nchc  =  b(istc2+1)
!
      IF(nchc .NE. ncha) goto 900
      IF(ncha .NE. nchb.or.nchb .NE. nchc) goto 900
      do 30 k=1,ncha
      i1 = ista+nbuf+k
      i2 = istb+nbuf+k
      i3 = istc+nbuf+k
      j1 = ista+nbuf+ncha+k
      j2 = istb+nbuf+ncha+k
      j3 = istc+nbuf+ncha+k
      if    (chr .EQ. '+')   THEN
        b(i3) =    coef1*b(i1) +    coef2*b(i2)
        b(j3) = coef1**2*b(j1) + coef2**2*b(j2)
      ELSEIF(chr .EQ. '-')   THEN
        b(i3) = coef1*b(i1) - coef2*b(i2)
        b(j3) = coef1**2*b(j1) + coef2**2*b(j2)
      ELSEIF(chr .EQ. '*')   THEN
        b(j3) = (coef1*coef2)**2
     $          *(b(j1)*b(i2)**2 + b(j2)*b(i1)**2)
        b(i3) = coef1*b(i1) * coef2*b(i2)
      ELSEIF(chr .EQ. '/')   THEN
        IF(b(i2) .EQ. 0d0) THEN
          b(i3) = 0d0
          b(j3) = 0d0
        ELSE
          b(j3) = (coef1/coef2)**2/b(i2)**4
     $          *(b(j1)*b(i2)**2 + b(j2)*b(i1)**2)
          b(i3) = (coef1*b(i1) )/( coef2*b(i2))
        ENDIF
      ELSE
        goto 901
      ENDIF
   30 continue
      RETURN
  900 write(nout,*) '+++++ gopera: non-equal no. bins ',ida,idb,idc
      WRITE(   6,*) '+++++ gopera: non-equal no. bins ',ida,idb,idc
      RETURN
  901 write(nout,*) '+++++ gopera: wrong chr=',chr
      END

      SUBROUTINE ginbo1(id,title,nchx,xl,xu)
!     **************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      CHARACTER*80 title
!
      lact=jadres(id)
      IF(lact .EQ. 0) THEN
         WRITE(6,*) '+++++ STOP in ginbo1: wrong id=',id
         STOP
      ENDIF
      ist=index(lact,2)
      ist2   = ist+7
      nchx   = b(ist2 +1)
      xl     = b(ist2 +2)
      xu     = b(ist2 +3)
      title  = titlc(lact)
      END

      SUBROUTINE gunpak(id,a,chd1,idum)
*     *********************************
! getting out histogram content (and error)
! chd1= 'ERRO' is nonstandard option (unpack errors)
*     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      CHARACTER*(*) chd1
      dimension a(*)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .EQ. 0) goto 900
      ist   = index(lact,2)
      ist2  = ist+7
      nch   = b(ist2 +1)
      local = ist +nbuf
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 2) THEN
        nchy  = b(ist2+5)
        nch   = nch*nchy
        local = ist+ nbuf2
      ENDIF
      do 10 ib=1,nch
      IF(chd1 .NE. 'ERRO') THEN
! normal bin
        a(ib) = b(local+ib)
      ELSE
! error content
        IF(ityphi .EQ. 2) goto 901
        a(ib) = dsqrt( dabs(b(local+nch+ib) ))
      ENDIF
   10 continue
      RETURN
 900  write(nout,*) '+++gunpak: nonexisting id=',id
      WRITE(6   ,*) '+++gunpak: nonexisting id=',id
      RETURN
 901  write(nout,*) '+++gunpak: no errors, two-dim, id=',id
      END

      SUBROUTINE gpak(id,a)
!     *********************
! Loading in histogram content
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      DIMENSION  a(*)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .EQ. 0) goto 900
      ist  = index(lact,2)
      ist2 = ist+7
      nch=b(ist2 +1)
      local = ist+nbuf
! 2-dimens histo alowed
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 2) THEN
        nchy  = b(ist2+5)
        nch   = nch*nchy
        local = ist+nbuf2
      ENDIF
      do 10 ib=1,nch
   10 b(local +ib) = a(ib)
! one nominal entry recorded
      index(lact,3)  = 1
      RETURN
  900 write(nout,*) '+++gpak: nonexisting id=',id
      WRITE(6   ,*) '+++gpak: nonexisting id=',id
      END

      SUBROUTINE gpake(id,a)
!     **********************
! Loading in error content
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      DIMENSION  a(*)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .EQ. 0) goto 901
      ist  = index(lact,2)
      ist2 = ist+7
      nch=b(ist2+1)
! 2-dimens histo NOT alowed
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 2) goto 900
      do 10 ib=1,nch
   10 b(ist+nbuf+nch+ib) = a(ib)**2
      RETURN
  900 write(nout,*) ' +++++ gpake: only for one-dim histos'
      RETURN
  901 write(nout,*) '+++ gpake: nonexisting id=',id
      WRITE(6   ,*) '+++ gpake: nonexisting id=',id
      END


      SUBROUTINE grang1(id,ylr,yur)
*     *****************************
! provides y-scale for 1-dim plots
*     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .EQ. 0) RETURN
      ist  = index(lact,2)
      ist2 = ist+7
      nch  = b(ist2 +1)
      yl   = b(ist+nbuf+1)
      yu   = b(ist+nbuf+1)
      do 10 ib=1,nch
      yl = min(yl,b(ist+nbuf+ib))
      yu = max(yu,b(ist+nbuf+ib))
   10 continue
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      IF(iopsc1 .EQ. 2) yl= b( ist +5)
      IF(iopsc2 .EQ. 2) yu= b( ist +6)
      ylr = yl
      yur = yu
      END


      SUBROUTINE ginbo2(id,nchx,xl,xu,nchy,yl,yu)
*     *******************************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .EQ. 0) goto 900
      ist  = index(lact,2)
      ist2 = ist+7
      nchx = b(ist2 +1)
      xl   = b(ist2 +2)
      xu   = b(ist2 +3)
      nchy = b(ist2 +5)
      yl   = b(ist2 +6)
      yu   = b(ist2 +7)
      RETURN
  900 write(nout,*) ' +++ginbo2: nonexisting histo id= ',id 
      WRITE(   6,*) ' +++ginbo2: nonexisting histo id= ',id
      END


      SUBROUTINE gmaxim(id,wmax)
*     **************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      IF(id .NE. 0) THEN
        lact=jadres(id)
        IF(lact .EQ. 0) RETURN
        ist= index(lact,2)
        b(ist+6) =wmax
        CALL gidopt(id,'YMAX')
      ELSE
        do 20 k=1,idmx
        IF(index(k,1) .EQ. 0) goto 20
        ist=index(k,2)
        jd =index(k,1)
        b(ist+6) =wmax
        CALL gidopt(jd,'YMAX')
   20   continue
      ENDIF
      END

      SUBROUTINE gminim(id,wmin)
*     **************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      IF(id .NE. 0) THEN
        lact=jadres(id)
        IF(lact .EQ. 0) RETURN
        ist =index(lact,2)
        b(ist+5) =wmin
        CALL gidopt(id,'YMIN')
      ELSE
        do 20 k=1,idmx
        IF(index(k,1) .EQ. 0) goto 20
        ist=index(k,2)
        jd =index(k,1)
        b(ist+5) =wmin
        CALL gidopt(jd,'YMIN')
   20   continue
      ENDIF
      END

      SUBROUTINE gmimax(id,wmin,wmax)
*     ******************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      CALL gminim(id,wmin)
      CALL gmaxim(id,wmax)
      END
    

      SUBROUTINE greset(id,chd1)
*     **************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      CHARACTER*(*) chd1
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
!
      lact=jadres(id)
      IF(lact .LE. 0) RETURN
      ist  =index(lact,2)
      ist2 = ist+7
! 
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
! one-dim.
        ist3  = ist+11
        nchx  = b(ist2 +1)
        nch   = 2*nchx
        local = ist + nbuf
      ELSEIF(ityphi .EQ. 2) THEN
! two-dim.
        ist3  = ist+15
        nchx  = b(ist2 +1)
        nchy  = b(ist2 +5)
        nch   = nchx*nchy
        local = ist +nbuf2
      ELSE
         WRITE(nout,*) '+++greset: wrong type id=',id
         WRITE(6   ,*) '+++greset: wrong type id=',id
        RETURN
      ENDIF
! reset miscaelaneous entries and bins
      do 10 j=ist3+1,local +nch
  10  b(j)    = 0d0
! and no. of entries in index
      index(lact,3) = 0
      END

      SUBROUTINE GDELET(ID1)
*     *********************
! Now it should work (stj Nov. 91) but watch out!
! should works for 2-dim histos, please check this!
*     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/
      LOGICAL gexist
!
      ID=ID1
      IF(id .EQ. 0) GOTO 300
      IF(.not.gexist(id)) GOTO 900
      lact = jadres(id)
      ist  = index(lact,2)
      ist2 = ist+7
*----
![[[      WRITE(6,*) 'GDELET-ing ID= ',ID
      idec    = nint(b(ist+2)-9d0-9d12)/10
      IF(idec .NE. id) WRITE(6,*) '++++GDELET: ALARM! ID,IDEC= ',ID,IDEC
*----
      nch  = b(ist2 +1)
      iflag2   = nint(b(ist+4)-9d0-9d12)/10
      ityphi   = mod(iflag2,10)
      IF(ityphi .EQ. 1) THEN
! one-dim.
        nchx  = b(ist2 +1)
        nch   = 2*nchx
! lenght of local histo to be removed
        local = nch+nbuf+1
      ELSEIF(ityphi .EQ. 2) THEN
! two-dim.
        nchx  = b(ist2 +1)
        nchy  = b(ist2 +5)
        nch   = nchx*nchy
! lenght of local histo to be removed
        local = nch+nbuf2+1
      ELSE
         WRITE(nout,*) '+++gdelet: wrong type id=',id
         WRITE(6   ,*) '+++gdelet: wrong type id=',id
        RETURN
      ENDIF
! starting position of next histo in storage b
      next = ist+1 +local
! move down all histos above this one 
      DO 15 k =next,length
      b(k-local)=b(k)
   15 CONTINUE  
! define new end of storage
      length=length-local
! clean free space at the end of storage b
      DO 20 k=length+1, length+local
   20 b(k)=0d0 
! shift adresses of all displaced histos 
      DO 25 l=lact+1,idmx
      IF(index(l,1) .NE. 0) index(l,2)=index(l,2)-local
   25 CONTINUE
! move entries in index down by one and remove id=lact entry
      DO 30 l=lact+1,idmx
      index(l-1,1)=index(l,1)
      index(l-1,2)=index(l,2)
      index(l-1,3)=index(l,3)
      titlc(l-1)=titlc(l)
   30 CONTINUE
! last entry should be always empty
      index(idmx,1)=0
      index(idmx,2)=0
      index(idmx,3)=0 
      do 50 k=1,80
   50 titlc(idmx)(k:k)=' '
      RETURN
! -----------------------------------
! Deleting all histos at once!!!
  300 length=0
      DO 400 i=1,idmx
      DO 340 k=1,3
  340 index(i,k)=0
      DO 350 k=1,80
  350 titlc(i)(k:k)=' '
 400  CONTINUE
      RETURN
! -----------------------------------
 900  CONTINUE
      WRITE(nout,*) ' +++GDELET: nonexisting histo id= ',id 
      WRITE(   6,*) ' +++GDELET: nonexisting histo id= ',id 
      END


      SUBROUTINE glimit(lenmx)
*     ************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      CALL g_init
      IF(lenmx .GE. lenmax) THEN
         lenmax=lenmx
      ELSE
         CALL gstop1('glimit: cant decrease storage lenmx  =',lenmx)
      ENDIF
      END

      SUBROUTINE copch(ch1,ch2)
*     *************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
* copies CHARACTER*80 ch1 into ch2 up to a first $ sign
      CHARACTER*80 ch1,ch2
      LOGICAL met
      met = .false.
      do 10 i=1,80
      IF( ch1(i:i) .EQ. '$' .or. met )   THEN
        ch2(i:i)=' '
        met=.true.
      ELSE
        ch2(i:i)=ch1(i:i)
      ENDIF
  10  continue
      END

      FUNCTION jadre2(id)
*     *********************
*------------------------------------------------
* Good old version -- but it is very very slow!!!
* In the case of 100 histograms or more.
*------------------------------------------------
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      jadre2=0
      DO 1 i=1,idmx
      IF(index(i,1) .EQ. id) goto 2
    1 CONTINUE
* Nothing found.
      RETURN
* Found: id=0 is also legitimate find!!!
    2 jadre2=i
      END

      FUNCTION jadres(id1)
*     *********************
*--------------------------------------------------------------------
* Educated guess based on past history is used to find quickly
* location of the histogram in the matrix index.
* This is based on observation that subsequent histogram calls 
* are linked into loops (so one can predict easily which histo will
* be called next time).
*--------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE /gind/
      DATA iguess,jdlast,idlast /-2141593,-3141593,-3141593/
      SAVE iguess,jdlast,idlast

      id=id1
! --- The case of ID=0 treated separately, it is used to find out
! --- last entry in the index (it is marked with zero)
      IF(id .EQ. 0) THEN
         DO i=1,idmx
            IF(index(i,1) .EQ. 0) goto 4
         ENDDO
         WRITE(6,*) '+++++jadres: STOP index to short'
         STOP
 4       CONTINUE
         jadres = i
         RETURN
      ENDIF

! --- Omit sophistications if lack of initialization
      IF(jdlast .EQ. -3141593) GOTO 10
      IF(iguess .EQ. -2141593) GOTO 10
      IF(iguess .EQ. 0) GOTO 10
      IF(jdlast .EQ. 0) GOTO 10

! --- Try first previous histo (for repeated calls)
      IF(jdlast .LT. 1 .OR. jdlast .GT. idmx) THEN
         WRITE(6,*) '+++++ jadres: jdlast=',jdlast
      ENDIF
      IF(index(jdlast,1) .EQ. id) THEN
         jadres = jdlast
!##   write(6,*) 
!##   $   'found, guess based on previous call to jadres ',jdlast
         GOTO 20
      ENDIF

! --- Try current guess based on previous call
      IF(iguess .LT. 1 .OR. iguess .GT. idmx)  THEN
         WRITE(6,*)'+++++ jadres: iguess=',iguess
      ENDIF
      IF(index(iguess,1) .EQ. id) THEN
         jadres = iguess
!##   write(6,*) 
!##   $   'found, guess on previous calls recorded in b(ist+7)',jdlast
         GOTO 20
      ENDIF

! ================================================
!    Do it HARD WAY, Search all matrix index
! ================================================
 10   CONTINUE
!##   write(6,*) 'trying HARD WAY'
      DO i=1,idmx
         jadres=i
         IF(index(i,1) .EQ. id) GOTO 20
      ENDDO
! -------------------------------------
!     Nothing found: jadres=0
! -------------------------------------
      jadres=0
      RETURN
! =====================================
!     Found: Set new guess for next call
! =====================================
 20   CONTINUE
! --- and store result as a new guess in previous histo 
! --- but only if it existed!!!!
      DO i=1,idmx
         IF(index(i,1) .EQ. 0) GOTO 40
         IF(index(i,1) .EQ. idlast) THEN
            ist=index(i,2)
            IF(ist .GT. 0 .AND. ist .LT. 50000) b(ist +7) = jadres
!##   write(6,*) 'STORED     id=',id
            GOTO 40
         ENDIF 
      ENDDO
 40   CONTINUE
!##   write(6,*)  'found, hard way searching all of index)', jdlast
      iguess = b( index(jadres,2) +7)
      jdlast = jadres
      idlast = id
      END


!--------------------------------------------------------------
! ----------- storing histograms in the disk file -------------
!--------------------------------------------------------------
      SUBROUTINE grfile(nhruni,dname,chd2)
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      CHARACTER*(*) chd2, dname
      COMMON / hruni / nhist
      SAVE /hruni/
      nhist=nhruni
      END

      SUBROUTINE grout(idum1,idum2,chdum)
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      CHARACTER*8 chdum
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      COMMON / hruni / nhist
      CHARACTER*80 titlc
      SAVE /cglib/,/gind/, /hruni/
!
      CALL g_init
      nouth=nhist
      WRITE(nouth,'(6i10)')   nvrs,nout,lenmax,length
      WRITE(nouth,'(6i10)')   ((index(i,k),k=1,3),i=1,idmx)
      WRITE(nouth,'(a80)')    titlc
      WRITE(nouth,'(3d24.16)') (b(i),i=1,length)
      END


      SUBROUTINE GRIN(IDUM1,IDUM2,IDUM3)
!     **********************************
! New version which has a possibility to 
!            MERGE histograms
! If given ID already exists then it is modified by adding 1000000 !!!!
! Mergigng is done simply by appending new histograms at the 
! very end of the index and bin matrices.
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      COMMON / hruni / nhist
      SAVE /cglib/,/gind/, /hruni/
! Copy of the new index from the disk
      DIMENSION lndex(idmx,3),titld(idmx)
      CHARACTER*80 titld
      LOGICAL gexist

      CALL g_init 
      nouth=nhist
! Read basic params
      READ(nouth,'(6i10)')   nvrs3,nout3,lenma3,lengt3
      IF(length+lengt3 .GE. lenmax) GOTO 900
! Check version
      IF(nvrs .NE. nvrs3) WRITE(nout,*)
     $ '  +++++ warning (grin): histos produced by older version',nvrs3
      IF(nvrs .NE. nvrs3) WRITE(6,*)
     $ '  +++++ warning (grin): histos produced by older version',nvrs3
! Read new index  from the disk
      READ(nouth,'(6i10)')  ((lndex(i,k),k=1,3),i=1,idmx)
      READ(nouth,'(a80)')    titld

      lenold=length
! Append content of new histos AT ONCE  at the end of storage b
      length=length+lengt3
      READ(nouth,'(3d24.16)') (b(i),i=lenold+1,length)

! Append index and titlc with new histos one by one
      lact = jadres(0)
      DO 100 l=1,idmx
      IF(lact .EQ. 0) GOTO 901
      idn= lndex(l,1)
      IF(idn .EQ. 0) GOTO 100
! Identical id's are changed by adding big number = 1000000
 10   CONTINUE
      IF( gexist(idn) ) THEN
         idn = idn +1000000*(idn/iabs(idn))
         GOTO 10 
      ENDIF
      index(lact,1)=idn
      index(lact,2)=lndex(l,2)+lenold
      index(lact,3)=lndex(l,3)
      titlc(lact)  =titld(l)
!
! Still one small correction in the newly appended histo
      istn  = index(lact,2)
      b(istn +2)  = 9d12 +     idn*10 +9d0
!
      lact=lact+1
  100 CONTINUE

!
      RETURN

 900  CONTINUE
      CALL gstop1('++++ grin: to litle space, lenmax=  ',lenmax)
 901  CONTINUE
      CALL gstop1('++++ grin: to many histos, idmx=    ',idmx)
      END




      SUBROUTINE GRIN2(IDUM1,IDUM2,IDUM3)
!     **********************************
! New version which has a possibility to 
!            ADD histograms
! If ID is not existing already then no action is taken
!     ***********************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      COMMON / hruni / nhist
      SAVE /cglib/,/gind/, /hruni/
! Copy of the histos from the disk
      DIMENSION bz(50000)
      DIMENSION indez(idmx,3),titlz(idmx)
      CHARACTER*80 titlz
      LOGICAL gexist

      CALL g_init 
      nouth=nhist
! Read basic params
      READ(nouth,'(6i10)')   nvrsz,noutz,lenmaz,lengtz
! Check version
      IF(nvrs .NE. nvrsz) WRITE(nout,*)
     $ '  +++++ warning (grin2): histos produced by older version',nvrsz
      IF(nvrs .NE. nvrsz) WRITE(6,*)
     $ '  +++++ warning (grin2): histos produced by older version',nvrsz
! Read new index, title and bins from the disk
      READ(nouth,'(6i10)')    ((indez(i,k),k=1,3),i=1,idmx)
      READ(nouth,'(a80)')     titlz
      READ(nouth,'(3d24.16)') (bz(i),i=1,lengtz)

! Add new histos from disk to existing ones one by one
      DO 100 lz=1,idmx
      id= indez(lz,1)
      IF(id .EQ. 0) GOTO 200
      IF(.not.gexist(id)) THEN
        WRITE(6,*) ' Grin2: unmached histo ID=', id, '  Skipped'
        goto 100
      ENDIF
! parameters of existing histo
      lact = jadres(id)
      ist  = index(lact,2)
      ist2 = ist+7
      ist3 = ist+11
      nchx = b(ist2 +1)
! parameters of the histo from the disk
      istz   = indez(lz,2)
      ist2z  = istz+7
      ist3z  = istz+11
      nchxz  = bz(ist2z +1)
      IF(nchx .NE. nchxz) THEN
        WRITE(6,*) ' Grin2: non-equal binning ID=', id, '  Skipped' 
        goto 100
      ENDIF
! Add/Merge all additive entries of the two histos
! No of entries in index
      index(lact,3) = index(lact,3)+indez(lact,3)
! Overflows, underflows etc.
      DO i=1,12
        b(ist3+i)=b(ist3+i) +bz(ist3z+i)
      ENDDO
! Except of this one non-additive entry 
      b(ist3+13)=max(b(ist3+13),b(ist3z+13))
! Regular bin content added now!
      DO i= 1, 2*nchx
        b(ist+nbuf+i)=b(ist+nbuf+i) +bz(istz+nbuf+i)
      ENDDO
  100 CONTINUE
  200 CONTINUE

      END

      SUBROUTINE grend(chdum)
!     ***********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / hruni / nhist
      SAVE   /hruni/
      CHARACTER*(*) chdum
      CLOSE(nhist)
!======================================================================
!======================end of gbook====================================
!======================================================================
      END

!======================================================================
!======================Mini-GPLOT======================================
!======================================================================
!... Plotting using LaTeX
      SUBROUTINE gplint(ICOD)
!     ***********************
      SAVE
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
!
      lint = icod
!
      END

      SUBROUTINE gplcap(IFILE)
!     ***********************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
!----------------------------------
! Titles and captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
!----------------
! Note that backslash definition is varying from one 
! instalation/compiler to another, you have to figure out by yourself 
! how to fill backslash code into BS
      COMMON / BSLASH / BS
      CHARACTER*1 BS,BBS
!     DATA BBS / 1H\ /
      DATA BBS / '\\' /
      BS = BBS
!c      BS = '\\'
!---------
      KEYTIT= 0
      DO i=1,50
         DO k=1,64
            titch(i)(k:k)=' '
         ENDDO
      ENDDO
!---------
      ILINE = 1
      NOUH1=IABS(IFILE)
      NOUH2=NOUH1+1
      IF( ABS(lint) .EQ. 0) THEN
! Normal mode
         WRITE(NOUH1,'(A,A)') BS,'documentstyle[12pt,html]{article}'
         WRITE(NOUH1,'(A,A)') BS,'textwidth  = 16cm'
         WRITE(NOUH1,'(A,A)') BS,'textheight = 18cm'
         WRITE(NOUH1,'(A,A)') BS,'begin{document}'
         WRITE(NOUH1,'(A)') '  '
      ELSEIF( ABS(lint) .EQ. 1) THEN
! For TeX file is used in \input 
         WRITE(NOUH1,'(A)') '  '
      ELSEIF( ABS(lint) .EQ. 2) THEN
! For one-page plot being input for postrscript
         WRITE(NOUH1,'(A,A)') BS,'documentclass[12pt]{article}'
!         WRITE(NOUH1,'(A,A)') BS,'usepackage{amstex}'
!         WRITE(NOUH1,'(A,A)') BS,'usepackage{amssymb}'
         WRITE(NOUH1,'(A,A)') BS,'usepackage{amsmath}'
         WRITE(NOUH1,'(A,A)') BS,'usepackage{html}'
         WRITE(NOUH1,'(A,A)') BS,'usepackage{epsfig}'
         WRITE(NOUH1,'(A,A)') BS,'usepackage{epic}'
         WRITE(NOUH1,'(A,A)') BS,'usepackage{eepic}'
!!!         WRITE(NOUH1,'(A,A)') BS,'hoffset    = -1in'
!!!         WRITE(NOUH1,'(A,A)') BS,'voffset    = -1in'
!!!         WRITE(NOUH1,'(A,A)') BS,'textwidth  = 16cm'
!!!         WRITE(NOUH1,'(A,A)') BS,'textheight = 16cm'
!!!         WRITE(NOUH1,'(A,A)') BS,'oddsidemargin = 0cm'
!!!         WRITE(NOUH1,'(A,A)') BS,'topmargin     = 0cm'
!!!         WRITE(NOUH1,'(A,A)') BS,'headheight    = 0cm'
!!!         WRITE(NOUH1,'(A,A)') BS,'headsep       = 0cm'
         WRITE(NOUH1,'(A,A)') BS,'begin{document}'
         WRITE(NOUH1,'(A,A)') BS,'pagestyle{empty}'
         WRITE(NOUH1,'(A)') '  '
      ELSE
         WRITE(6,*) ' +++++++ STOP in gplint, wrong lint=',lint
      ENDIF

      END

      SUBROUTINE gplend
!     *****************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS

! Note that TeX file is used in \input then you may not want
! to have header and \end{document}
      IF( ABS(lint) .NE. 1) THEN
         WRITE(NOUH1,'(2A)') BS,'end{document}'
      ENDIF

      CLOSE(NOUH1)
      END

      SUBROUTINE GPLOT(ID,CH1,CH2,KDUM)
!     *********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      DIMENSION YY(200),YER(200)
      CHARACTER CH1,CH2,CHR
      CHARACTER*80 TITLE
      LOGICAL GEXIST
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      DATA CHR /' '/
! RETURN if histo non-existing
      IF(.NOT.GEXIST(ID)) GOTO 900
! ...unpack histogram
      CALL GUNPAK(ID,YY ,'    ',IDUM)
      CALL GUNPAK(ID,YER,'ERRO',IDUM)
      CALL GINBO1(ID,TITLE,NCHX,DXL,DXU)
      XL = DXL
      XU = DXU
      CALL GRANG1(ID,YL,YU)
      KAX=1200
      KAY=1200
      IF(CH1 .EQ. 'S') THEN
! ...superimpose plot
        BACKSPACE(NOUH1)
        BACKSPACE(NOUH1)
      ELSE
! ...new frame only
        CHR=CH1
        CALL LFRAM1(ID,KAX,KAY)
      ENDIF
      WRITE(NOUH1,'(A)')    '%========== next plot (line) =========='
      WRITE(NOUH1,'(A,I10)') '%==== HISTOGRAM ID=',ID
      WRITE(NOUH1,'(A,A70 )') '% ',TITLE
!...cont. line for functions
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb-1
      IF (iopsla .EQ. 2)  CHR='C'
!...suppress GPLOT assignments
      IF (CH2 .EQ. 'B')   CHR=' '
      IF (CH2 .EQ. '*')   CHR='*'
      IF (CH2 .EQ. 'C')   CHR='C'
!...various types of lines
      IF     (CHR .EQ. ' ') THEN
!...contour line used for histogram
          CALL PLHIST(KAX,KAY,NCHX,YL,YU,YY,KER,YER)
      ELSE IF(CHR .EQ. '*') THEN
!...marks in the midle of the bin
          CALL PLHIS2(KAX,KAY,NCHX,YL,YU,YY,KER,YER)
      ELSE IF(CHR .EQ. 'C') THEN
!...slanted (dotted) line in plotting non-MC functions
          CALL PLCIRC(KAX,KAY,NCHX,YL,YU,YY)
      ENDIF
!------------------------------!
! Ending
!------------------------------!
      WRITE(NOUH1,'(2A)') BS,'end{picture} % close entire picture '
      WRITE(NOUH1,'(2A)') BS,'end{figure}'

      RETURN
  900 WRITE(*,*) ' ++++ GPLOT: NONEXISTIG HISTO ' ,ID
      END

      SUBROUTINE LFRAM1(ID,KAX,KAY)
!     *****************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
!----------------------------------
! Titles ans captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 TITCH
      CHARACTER*80 title
!----------------
      DIMENSION TIPSY(20),TIPSX(20)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      DOUBLE PRECISION DXL,DXU
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      DATA ICONT/0/

      ICONT=ICONT+1
      CALL GINBO1(ID,TITLE,NCHX,DXL,DXU)
      XL = DXL
      XU = DXU
      CALL GRANG1(ID,YL,YU)

      IF(ICONT .GT. 1) WRITE(NOUH1,'(2A)') BS,'newpage'
!------------------------------!
!           Header
!------------------------------!
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(NOUH1,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(NOUH1,'(2A)') BS,'begin{figure}[!ht]'
      WRITE(NOUH1,'(2A)') BS,'centering'
!------------------------------!
! General Caption
!------------------------------!
      WRITE(NOUH1,'(4A)') BS,'caption{',BS,'small'
      IF(KEYTIT.EQ.0) THEN
        WRITE(NOUH1,'(A)')     TITLE
      ELSE
        WRITE(NOUH1,'(A)')     TITCH(1)
      ENDIF
      WRITE(NOUH1,'(A)') '}'
!------------------------------!
! Frames and labels
!------------------------------!
      WRITE(NOUH1,'(A)') '% =========== big frame, title etc. ======='
      WRITE(NOUH1,'(4A)') BS,'setlength{',BS,'unitlength}{0.1mm}'
      WRITE(NOUH1,'(2A)') BS,'begin{picture}(1600,1500)'
      WRITE(NOUH1,'(4A)') BS,'put(0,0){',BS,'framebox(1600,1500){ }}'
      WRITE(NOUH1,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $    BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $    BS,'put(0,0){',BS,'framebox( ',KAX,',',KAY,'){ }}'
      WRITE(NOUH1,'(A)') '% =========== x and y axis ================'
      CALL SAXIX(KAX,XL,XU,NTIPX,TIPSX)
      CALL SAXIY(KAY,YL,YU,NTIPY,TIPSY)
      WRITE(NOUH1,'(3A)') BS,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE SAXIX(KAY,YL,YU,NLT,TIPSY)
!     ***************************************
! plotting x-axis with long and short tips
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION TIPSY(20)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/

      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.4999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)             DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)             DDYL = 10d0**LY*2.0d0
      WRITE(NOUH1,'(A)') '% .......SAXIX........ '
      WRITE(NOUH1,'(A,I4)') '%  JY= ',JY
!-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.5d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.4999999d0)*DDYS
      P0L = KAY*(YY0L-YL)/(YU-YL)
      PDL = KAY*DDYL/(YU-YL)
      P0S = KAY*(YY0S-YL)/(YU-YL)
      PDS = KAY*DDYS/(YU-YL)
      NLT = INT(ABS(YU-YY0L)/DDYL+0.0000001d0)+1
      NTS = INT(ABS(YU-YY0S)/DDYS+0.0000001d0)+1
      DO 41 N=1,NLT
      TIPSY(N) =YY0L+ DDYL*(N-1)
  41  CONTINUE
      WRITE(NOUH1,1000)
     $ BS,'multiput('  ,P0L,  ',0)('  ,PDL,  ',0){'  ,NLT,  '}{',
     $ BS,'line(0,1){25}}',
     $ BS,'multiput('  ,P0S,  ',0)('  ,PDS,  ',0){'  ,NTS,  '}{',
     $ BS,'line(0,1){10}}'
      WRITE(NOUH1,1001)
     $ BS,'multiput('  ,P0L,  ','  ,KAY,  ')('  ,PDL,  ',0){'  ,NLT,
     $ '}{'  ,BS,  'line(0,-1){25}}',
     $ BS,'multiput('  ,P0S,  ','  ,KAY,  ')('  ,PDS,  ',0){'  ,NTS,
     $ '}{'  ,BS,  'line(0,-1){10}}'
 1000 FORMAT(2A,F8.2,A,F8.2,A,I4,3A)
 1001 FORMAT(2A,F8.2,A,I4,A,F8.2,A,I4,3A)
! ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001)
      DO 45 N=1,NLT
      K = NINT(KAY*(TIPSY(N)-YL)/(YU-YL))
      IF(LEX .LT. 2.AND.LEX .GT. -1) THEN
! ...without exponent
      WRITE(NOUH1,'(2A,I4,5A,F8.3,A)')
     $ BS,'put(',K,',-25){',BS,'makebox(0,0)[t]{',BS,'large $ ',
     $ TIPSY(N), ' $}}'
      ELSE
! ...with exponent
      WRITE(NOUH1,'(2A,I4,5A,F8.3,2A,I4,A)')
     $ BS,'put('  ,K,  ',-25){',BS,'makebox(0,0)[t]{',BS,'large $ ',
     $ TIPSY(N)/(10d0**LEX),BS,'cdot 10^{',LEX,'} $}}'
      ENDIF
  45  CONTINUE
      END

      SUBROUTINE SAXIY(KAY,YL,YU,NLT,TIPSY)
!     ***************************************
! plotting y-axis with long and short tips
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION TIPSY(20)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/

      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.49999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)             DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)             DDYL = 10d0**LY*2.0d0
      WRITE(NOUH1,'(A)') '% .......SAXIY........ '
      WRITE(NOUH1,'(A,I4)') '%  JY= ',JY
!-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.4999999d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.5d0)*DDYS
      P0L = KAY*(YY0L-YL)/(YU-YL)
      PDL = KAY*DDYL/(YU-YL)
      P0S = KAY*(YY0S-YL)/(YU-YL)
      PDS = KAY*DDYS/(YU-YL)
      NLT= INT(ABS(YU-YY0L)/DDYL+0.0000001d0) +1
      NTS= INT(ABS(YU-YY0S)/DDYS+0.0000001d0) +1
      DO 41 N=1,NLT
      TIPSY(N) =YY0L+ DDYL*(N-1)
  41  CONTINUE
! plotting tics on vertical axis
      WRITE(NOUH1,1000)
     $ BS,'multiput(0,'  ,P0L,  ')(0,'  ,PDL  ,'){'  ,NLT,  '}{',
     $ BS,'line(1,0){25}}',
     $ BS,'multiput(0,'  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,  '}{',
     $ BS,'line(1,0){10}}'
      WRITE(NOUH1,1001)
     $ BS,'multiput('  ,KAY,  ','  ,P0L,  ')(0,'  ,PDL,  '){'  ,NLT,
     $ '}{',BS,'line(-1,0){25}}',
     $ BS,'multiput('  ,KAY,  ','  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,
     $ '}{',BS,'line(-1,0){10}}'
 1000 FORMAT(2A,F8.2,A,F8.2,A,I4,3A)
 1001 FORMAT(2A,I4,A,F8.2,A,F8.2,A,I4,3A)
! ...Zero line if necessary
      Z0L = KAY*(-YL)/(YU-YL)
      IF(Z0L .GT. 0D0.AND.Z0L .LT. FLOAT(KAY))
     $      WRITE(NOUH1,'(2A,F8.2,3A,I4,A)')
     $       BS,'put(0,'  ,Z0L,  '){',BS,'line(1,0){'  ,KAY,  '}}'
! ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001d0)
      DO 45 N=1,NLT
      K = NINT(KAY*(TIPSY(N)-YL)/(YU-YL))
      IF(LEX .LT. 2.AND.LEX .GT. -1) THEN
! ...without exponent
      WRITE(NOUH1,'(2A,I4,5A,F8.3,A)')
     $  BS,'put(-25,'  ,K,  '){',BS,'makebox(0,0)[r]{',
     $  BS,'large $ '  ,TIPSY(N),  ' $}}'
      ELSE
! ...with exponent
      WRITE(NOUH1,'(2A,I4,5A,F8.3,2A,I4,A)')
     $ BS,'put(-25,'  ,K,  '){',BS,'makebox(0,0)[r]{',
     $ BS,'large $ '
     $ ,TIPSY(N)/(10d0**LEX),  BS,'cdot 10^{'  ,LEX,  '} $}}'
      ENDIF
  45  CONTINUE
      END
      SUBROUTINE PLHIST(KAX,KAY,NCHX,YL,YU,YY,KER,YER)
!     ************************************************
! plotting contour line for histogram
!     ***********************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION YY(*),YER(*)
      CHARACTER*80 FMT1
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $  BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(A)') '% ========== plotting primitives =========='
!...various types of line
      IF(ILINE .EQ. 1) THEN
         WRITE(NOUH1,'(2A)') BS,'thicklines '
      ELSE
         WRITE(NOUH1,'(2A)') BS,'thinlines '
      ENDIF
!...short macros for vertical/horizontal straight lines
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'x}[3]{',BS,'put(#1,#2){',
     $ BS,'line(1,0){#3}}}'
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'y}[3]{',BS,'put(#1,#2){',
     $ BS,'line(0,1){#3}}}'
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'z}[3]{',BS,'put(#1,#2){',
     $ BS,'line(0,-1){#3}}}'
!   error bars
      WRITE(NOUH1,'(8A)')
     $   BS,'newcommand{',BS,'e}[3]{',
     $   BS,'put(#1,#2){',BS,'line(0,1){#3}}}'
      IX0=0
      IY0=0
      DO 100 IB=1,NCHX
      IX1 = NINT(KAX*(IB-0.00001)/NCHX)
      IY1 = NINT(KAY*(YY(IB)-YL)/(YU-YL))
      IDY = IY1-IY0
      IDX = IX1-IX0
      FMT1 = '(2(2A,I4,A,I4,A,I4,A))'
      IF( IDY .GE. 0) THEN  
         IF(IY1 .GE. 0.AND.IY1 .LE. KAY)
     $   WRITE(NOUH1,FMT1) BS,'y{',IX0,'}{',IY0,'}{',IDY,'}',
     $                     BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ELSE
         IF(IY1 .GE. 0.AND.IY1 .LE. KAY)
     $   WRITE(NOUH1,FMT1) BS,'z{',IX0,'}{',IY0,'}{',-IDY,'}',
     $                     BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ENDIF
      IX0=IX1
      IY0=IY1
      IF(KER .EQ. 1) THEN
        IX2  = NINT(KAX*(IB-0.5000d0)/NCHX)
        IERR = NINT(KAY*((YY(IB)-YER(IB))-YL)/(YU-YL))
        IE = NINT(KAY*YER(IB)/(YU-YL))
        IF(IY1 .GE. 0.AND.IY1 .LE. KAY.and.abs(ierr) .LE. 9999
     $     .and.2*ie .LE. 9999) WRITE(NOUH1,8000) BS,IX2,IERR,IE*2
      ENDIF
 100  CONTINUE
8000  FORMAT(4(A1,2He{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(NOUH1,'(3A)') BS,'end{picture}}',
     $       ' % end of plotting histogram'
! change line-style
      ILINE= ILINE+1
      IF(ILINE .GT. 2) ILINE=1
      END
      SUBROUTINE PLHIS2(KAX,KAY,NCHX,YL,YU,YY,KER,YER)
!     ************************************************
! marks in the midle of the bin
!     **********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION YY(*),YER(*)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/

      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $ BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(A)') '% ========== plotting primitives =========='
!...various types of mark
      IRAD1= 6
      IRAD2=10
      IF(ILINE .EQ. 1) THEN
!   small filled circle
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle*{',IRAD1,'}}}'
      ELSEIF(ILINE .EQ. 2) THEN
!   small open circle
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle{',IRAD1,'}}}'
      ELSEIF(ILINE .EQ. 3) THEN
!   big filled circle
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle*{',IRAD2,'}}}'
      ELSEIF(ILINE .EQ. 4) THEN
!   big open circle
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle{',IRAD2,'}}}'
! Other symbols
      ELSEIF(ILINE .EQ. 5) THEN
       WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'makebox(0,0){$',BS,'diamond$}}}'
      ELSE
       WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'makebox(0,0){$',BS,'star$}}}'
      ENDIF
!   error bars
      WRITE(NOUH1,'(8A)')
     $   BS,'newcommand{',BS,'E}[3]{',
     $   BS,'put(#1,#2){',BS,'line(0,1){#3}}}'
      DO 100 IB=1,NCHX
      IX1 = NINT(KAX*(IB-0.5000d0)/NCHX)
      IY1 = NINT(KAY*(YY(IB)-YL)/(YU-YL))
      IF(IY1 .GE. 0.AND.IY1 .LE. KAY) WRITE(NOUH1,7000) BS,IX1,IY1
      IF(KER .EQ. 1) THEN
        IERR = NINT(KAY*((YY(IB)-YER(IB))-YL)/(YU-YL))
        IE   = NINT(KAY*YER(IB)/(YU-YL))
        IF(IY1 .GE. 0.AND.IY1 .LE. KAY.and.abs(ierr) .LE. 9999
     $       .and.2*ie .LE. 9999) WRITE(NOUH1,8000) BS,IX1,IERR,IE*2
      ENDIF
 100  CONTINUE
7000  FORMAT(4(A1,2HR{,I4,2H}{,I4,1H}:1X ))
8000  FORMAT(4(A1,2HE{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(NOUH1,'(3A)') BS,'end{picture}}',
     $    ' % end of plotting histogram'
! change line-style
      ILINE= ILINE+1
      IF(ILINE .GT. 6) ILINE=1
      END
      SUBROUTINE PLCIRC(KAX,KAY,NCHX,YL,YU,YY)
!     ****************************************
! plots equidistant points, four-point interpolation,
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION YY(*),IX(3000),IY(3000)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/
      SAVE DS

! ...various types of line
! ...distance between points is DS, radius of a point is IRAD
      IRAD2=6
      IRAD1=3
! .............
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $  BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(A)') '% ========== plotting primitives =========='
      IF(ILINE .EQ. 1) THEN
!   small filled circle
       DS = 10
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle*{',IRAD1,'}}}'
      ELSEIF(ILINE .EQ. 2) THEN
!   small open circle
       DS = 10
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle{',IRAD1,'}}}'
      ELSEIF(ILINE .EQ. 3) THEN
!   big filled circle
       DS = 20
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle*{',IRAD2,'}}}'
      ELSEIF(ILINE .EQ. 4) THEN
!   big open circle
       DS = 20
       WRITE(NOUH1,'(8A,I3,A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'circle{',IRAD2,'}}}'
! Other symbols
      ELSEIF(ILINE .EQ. 5) THEN
       DS = 20
       WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'makebox(0,0){$',BS,'diamond$}}}'
      ELSE
       DS = 20
       WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,'R}[2]{',
     $   BS,'put(#1,#2){',BS,'makebox(0,0){$',BS,'star$}}}'
      ENDIF
      FACY = KAY/(YU-YL)
! plot first point
      AI  = 0.
      AJ  = (APROF( (AI/KAX)*NCHX+0.5d0, NCHX, YY) -YL)*FACY
      IPNT =1
      IX(IPNT) = INT(AI)
      IY(IPNT) = INT(AJ)
      DX =  DS
      AI0 = AI
      AJ0 = AJ
! plot next points
      DO 100 IPOIN=2,3000
! iteration to get (approximately) equal distance among ploted points
      DO  50 ITER=1,3
      AI  = AI0+DX
      AJ  = (APROF( (AI/KAX)*NCHX+0.5d0, NCHX, YY) -YL)*FACY
      DX  = DX *DS/SQRT(DX**2 + (AJ-AJ0)**2)
  50  CONTINUE
      IF(INT(AJ) .GE. 0.AND.INT(AJ) .LE. KAY.AND.INT(AI) .LE. KAX) THEN
         IPNT = IPNT+1
         IX(IPNT) = INT(AI)
         IY(IPNT) = INT(AJ)
      ENDIF
      AI0 = AI
      AJ0 = AJ
      IF(INT(AI) .GT. KAX) GOTO 101
 100  CONTINUE
 101  CONTINUE
      WRITE(NOUH1,7000) (BS,IX(I),IY(I), I=1,IPNT)
7000  FORMAT(4(A1,2HR{,I4,2H}{,I4,1H}:1X ))
      WRITE(NOUH1,'(2A)') BS,'end{picture}} % end of plotting line'
! change line-style
      ILINE= ILINE+1
      IF(ILINE .GT. 2) ILINE=1
      END
      FUNCTION APROF(PX,NCH,YY)
!     *************************
! PX is a continuous extension of the index in array YY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION YY(*)
      X=PX
      IF(X .LT. 0.0.OR.X .GT. FLOAT(NCH+1)) THEN
        APROF= -1E-20
        RETURN
      ENDIF
      IP=INT(X)
      IF(IP .LT. 2)     IP=2
      IF(IP .GT. NCH-2) IP=NCH-2
      P=X-IP
      APROF = -(1./6.)*P*(P-1)*(P-2)  *YY(IP-1)
     $        +(1./2.)*(P*P-1)*(P-2)  *YY(IP  )
     $        -(1./2.)*P*(P+1)*(P-2)  *YY(IP+1)
     $        +(1./6.)*P*(P*P-1)      *YY(IP+2)
      END
      SUBROUTINE GPLSET(CH,XX)
*     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      SAVE / LPLDAT /
      CHARACTER*4 CH
      KTY=NINT(XX)
      IF(CH .EQ. 'DMOD') THEN
        ILINE=KTY
      ENDIF
      END

      SUBROUTINE gpltit(title)
*     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      CHARACTER*64 title
!----------------------------------
! Titles ans captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
!----------------
      keytit=1
      CALL copch(title,titch(1))
      END

      SUBROUTINE gplcapt(lines)
!     ************************
! This routine defines caption and should be called
! before CALL gplot2, gpltab or bpltab2
! The matrix CHARACTER*64 lines containes text of the caption ended
! with the last line '% end-of-caption'
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      CHARACTER*64 lines(*)
!----------------------------------
! Titles ans captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
!----------------
      keytit=0
      DO i=1,50
         titch(i)=lines(i)
         keytit= keytit+1
         IF(lines(i) .EQ. '% end-of-caption' ) GOTO 100
      ENDDO
 100  CONTINUE
      END

      SUBROUTINE gplabel(lines)
*     ************************
! This should be envoked after "CALL gplot2" 
! to add lines of TeX to a given plot
*     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      CHARACTER*64 lines(*)
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
!----------------------------------
! Titles ans captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
!----------------
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 BS
!
      keytit=0
      DO i=1,50
         titch(i)=lines(i)
         keytit= keytit+1
         IF(lines(i) .EQ. '% end-of-label' ) GOTO 100
      ENDDO
 100  CONTINUE
!------------------------------!
!   erase Ending               !
!------------------------------!
      BACKSPACE(NOUH1)
      BACKSPACE(NOUH1)
!
      DO i=1,keytit
        WRITE(NOUH1,'(A)')     TITCH(i)
      ENDDO
!------------------------------!
!   restore Ending             !
!------------------------------!
      WRITE(NOUH1,'(2A)') BS,'end{picture} % close entire picture '
      IF(ABS(lint) .EQ. 2) THEN
         WRITE(NOUH1,'(A)') '%====== end of gplabel =========='
      ELSE
         WRITE(NOUH1,'(2A)') BS,'end{figure}'
      ENDIF
      END

 
      SUBROUTINE gplot2(id,ch1,ch2,chmark,chxfmt,chyfmt)
!     **************************************************
! New version, more user-friendly of gplot
! INPUT:
!    ID          histogram identifier
!    ch1 = ' '   normal new plot
!        = 'S'   impose new plot on previous one
!    ch2 = ' '   ploting line default, contour
!        = '*'   error bars in midle of the bin
!        = 'R'   error bars at Right edge of the bin
!        = 'L'   error bars at Left  edge of the bin
!        = 'C'   slanted continuous smooth line
!    chmark =    TeX symbol for ploting points
!    chxfmt =    format (string) for labeling x-axis
!    chyfmt =    format (string) for labeling y-axis
! Furthermore:
! Captions are defined by means of 
!    CALL gplcapt(capt) before CALL gplot2
!    where CHARACTER*64 capt(50) is content of 
!    caption, line by line, see also comments in gplcapt routine.
! Additional text as a TeX source text can be appended by means of
!    CALL gplabel(lines) after CALL gplot2
!    where CHARACTER*64 lines(50) is the TeX add-on.
!    this is used to decorate plot with
!    any kind marks, special labels and text on the plot.
!
!     ************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER ch1,ch2,chmark*(*)
!WP:      CHARACTER*8 chxfmt,chyfmt
      CHARACTER*4 chxfmt,chyfmt
      SAVE
      DIMENSION yy(200),yer(200)
      CHARACTER*80 title
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
      LOGICAL gexist
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 BS
      CHARACTER chr
! TeX Names of the error-bar command and of the point-mark command
      CHARACTER*1 chre, chrp1
      PARAMETER ( chre = 'E', chrp1= 'R' )
      CHARACTER*2 chrp
! TeX Name of the point-mark command
      CHARACTER*1 chrx(12)
      DATA  chrx /'a','b','c','d','f','g','h','i','j','k','l','m'/
      DATA CHR /' '/
!!
! RETURN if histo non-existing
      IF(.NOT.gexist(id)) GOTO 900
! ...unpack histogram
      CALL gunpak(id,yy ,'    ',idum)
      CALL gunpak(id,yer,'ERRO',idum)
      CALL ginbo1(id,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      CALL grang1(id,yl,yu)
      KAX=1200
      KAY=1200
      IF(CH1 .EQ. 'S') THEN
! ...superimpose plot
        incr=incr+1
        BACKSPACE(NOUH1)
        BACKSPACE(NOUH1)
      ELSE
! ...new frame only
        incr=1
        CHR=CH1
        CALL lframe(id,kax,kay,chxfmt,chyfmt)
      ENDIF
      chrp= chrp1//chrx(incr)
      WRITE(NOUH1,'(A)')    '%====gplot2:  next plot (line) =========='
      WRITE(NOUH1,'(A,I10)')'%====HISTOGRAM ID=',ID
      WRITE(NOUH1,'(A,A70 )') '% ',TITLE
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb-1
! Default line type
      IF (iopsla .EQ. 2) THEN 
         CHR='C'
      ELSE
         CHR=' '
      ENDIF
! User defined line-type
      IF (CH2 .EQ. 'B')   CHR=' '
!...marks in the midle of the bin
      IF (CH2 .EQ. '*')   CHR='*'
!...marks on the right edge of the bin
      IF (CH2 .EQ. 'R')   CHR='R'
!...marks on the left edge of the bin
      IF (CH2 .EQ. 'L')   CHR='L'
      IF (CH2 .EQ. 'C')   CHR='C'
!...various types of lines
      IF     (CHR .EQ. ' ') THEN
!...contour line used for histogram
          CALL plkont(kax,kay,nchx,yl,yu,yy,ker,yer)
      ELSE IF(CHR .EQ. '*' .OR. CHR .EQ. 'R'.OR. CHR .EQ. 'L') THEN
!...marks on the right/left/midle of the bin
         CALL plmark(kax,kay,nchx,yl,yu,yy,ker,yer,chmark,chr,chrp,chre)
      ELSE IF(CHR .EQ. 'C') THEN
!...slanted (dotted) line in plotting non-MC functions
          CALL plcirc(kax,kay,nchx,yl,yu,yy)
      ENDIF
!------------------------------!
!        ENDing                !
!------------------------------!
      WRITE(NOUH1,'(2A)') BS,'end{picture} % close entire picture '
      IF(ABS(lint) .EQ. 2) THEN
         WRITE(NOUH1,'(A)') '%======= gplot2:  end of plot  =========='
      ELSE
         WRITE(NOUH1,'(2A)') BS,'end{figure}'
      ENDIF
      RETURN
  900 WRITE(*,*) ' ++++ GPLOT: NONEXISTIG HISTO ' ,ID
      END

      SUBROUTINE lframe(id,kax,kay,chxfmt,chyfmt)
!     *******************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER chxfmt*(*),chyfmt*(*)
      SAVE
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
!----------------------------------
! Titles ans captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 TITCH
      CHARACTER*80 title
!----------------
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      DOUBLE PRECISION DXL,DXU
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      DATA ICONT/0/

      ICONT=ICONT+1
      CALL ginbo1(id,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      CALL grang1(id,yl,yu)

      IF(ICONT .GT. 1) WRITE(NOUH1,'(2A)') BS,'newpage'
!------------------------------!
!           Header
!------------------------------!
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') 
     $'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(NOUH1,'(A)') 
     $'%%%%%%%%%%%%%%%%%%%%%%%%%%lframe%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      IF(ABS(lint) .EQ. 2) THEN
         WRITE(NOUH1,'(2A)') BS,'noindent'
      ELSE
         WRITE(NOUH1,'(2A)') BS,'begin{figure}[!ht]'
         WRITE(NOUH1,'(2A)') BS,'centering'
         WRITE(NOUH1,'(2A)') BS,'htmlimage{scale=1.4}'
      ENDIF
!------------------------------!
! General Caption
!------------------------------!
      IF(ABS(lint) .NE. 2) THEN
         WRITE(NOUH1,'(6A)') BS,'caption{',BS,'footnotesize',BS,'sf'
         DO i=1,keytit
            WRITE(NOUH1,'(A)')     TITCH(i)
         ENDDO
         WRITE(NOUH1,'(A)') '}'
      ENDIF
!------------------------------!
! Frames and labels
!------------------------------!
      WRITE(NOUH1,'(A)') '% =========== big frame, title etc. ======='
      WRITE(NOUH1,'(4A)') BS,'setlength{',BS,'unitlength}{0.1mm}'
      WRITE(NOUH1,'(2A)') BS,'begin{picture}(1600,1500)'
      IF( lint .LT. 0) THEN
! Big frame usefull for debuging 
         WRITE(NOUH1,'(4A)') BS,'put(0,0){',BS,'framebox(1600,1500){ }}'
      ENDIF
      WRITE(NOUH1,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $    BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $    BS,'put(0,0){',BS,'framebox( ',KAX,',',KAY,'){ }}'
      WRITE(NOUH1,'(A)') '% =========== x and y axis ================'
      CALL axisx(kax,xl,xu,chxfmt)
      CALL axisy(kay,yl,yu,chyfmt)
      WRITE(NOUH1,'(3A)') BS,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE axisx(kay,yl,yu,chxfmt)
!     ***************************************
! plotting x-axis with long and short tips
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!WP: Problems on Linux
!WP      CHARACTER chxfmt*(*)
      CHARACTER*4 chxfmt
      DIMENSION tipsy(20)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      SAVE /lpldat/, /bslash/
!
      CHARACTER*64 fmt1,fmt2
      PARAMETER (fmt1 = '(2A,F8.2,A,F8.2,A,I4,3A)')
      PARAMETER (fmt2 = '(2A,F8.2,A,I4,A,F8.2,A,I4,3A)')

      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.4999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)               DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)               DDYL = 10d0**LY*2.0d0
      WRITE(NOUH1,'(A)') '% -------axisX---- '
      WRITE(NOUH1,'(A,I4)') '%  JY= ',JY
!-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.5d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.4999999d0)*DDYS
      P0L = KAY*(YY0L-YL)/(YU-YL)
      PDL = KAY*DDYL/(YU-YL)
      P0S = KAY*(YY0S-YL)/(YU-YL)
      PDS = KAY*DDYS/(YU-YL)
      NLT = INT(ABS(YU-YY0L)/DDYL+0.0000001d0)+1
      NTS = INT(ABS(YU-YY0S)/DDYS+0.0000001d0)+1
      DO n=1,nlt
         tipsy(n) =yy0l+ ddyl*(n-1)
      ENDDO
      WRITE(NOUH1,fmt1)
     $ BS,'multiput('  ,P0L,  ',0)('  ,PDL,  ',0){'  ,NLT,  '}{',
     $ BS,'line(0,1){25}}',
     $ BS,'multiput('  ,P0S,  ',0)('  ,PDS,  ',0){'  ,NTS,  '}{',
     $ BS,'line(0,1){10}}'
      WRITE(NOUH1,fmt2)
     $ BS,'multiput('  ,P0L,  ','  ,KAY,  ')('  ,PDL,  ',0){'  ,NLT,
     $ '}{'  ,BS,  'line(0,-1){25}}',
     $ BS,'multiput('  ,P0S,  ','  ,KAY,  ')('  ,PDS,  ',0){'  ,NTS,
     $ '}{'  ,BS,  'line(0,-1){10}}'
! ...labeling of axis
      scmx = DMAX1(DABS(yl),DABS(YU))
      lex  = NINT( LOG10(scmx) -0.50001)
      DO n=1,nlt
         k = nint(kay*(tipsy(n)-yl)/(yu-yl))
         IF(lex .LE. 3 .AND. lex .GE. -3) THEN
! ...without exponent
           WRITE(NOUH1,'(2A,I4,5A,'//chxfmt//',A)')
     $     BS,'put(',K,',-25){',BS,'makebox(0,0)[t]{',BS,'Large $ ',
     $     TIPSY(N), ' $}}'
         ELSE
! ...with exponent
           WRITE(NOUH1,'(2A,I4,5A,'//chxfmt//',2A,I4,A)')
     $     BS,'put('  ,K,  ',-25){',BS,'makebox(0,0)[t]{',BS,'Large $ ',
     $     TIPSY(N)/(10d0**LEX),BS,'cdot 10^{',LEX,'} $}}'
         ENDIF
      ENDDO
      END

      SUBROUTINE axisy(kay,yl,yu,chyfmt)
!     ***************************************
! plotting y-axis with long and short tips
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!WP: Problems on Linux
!WP      CHARACTER chyfmt*(*)
      CHARACTER*4 chyfmt
      DIMENSION tipsy(20)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / BS
      CHARACTER*1 bs
      SAVE /lpldat/, /bslash/
!
      CHARACTER*64 fmt1,fmt2
      PARAMETER (fmt1 = '(2A,F8.2,A,F8.2,A,I4,3A)')
      PARAMETER (fmt2 = '(2A,I4,A,F8.2,A,F8.2,A,I4,3A)')

      DY= ABS(YU-YL)
      LY = NINT( LOG10(DY) -0.49999999d0 )
      JY = NINT(DY/10d0**LY)
      DDYL = DY*10d0**(-LY)
      IF( JY .EQ. 1)               DDYL = 10d0**LY*0.25d0
      IF( JY .GE. 2.AND.JY .LE. 3) DDYL = 10d0**LY*0.5d0
      IF( JY .GE. 4.AND.JY .LE. 6) DDYL = 10d0**LY*1.0d0
      IF( JY .GE. 7)               DDYL = 10d0**LY*2.0d0
      WRITE(NOUH1,'(A)') '% --------saxiY------- '
      WRITE(NOUH1,'(A,I4)') '%  JY= ',JY
!-------
      NLT = INT(DY/DDYL)
      NLT = MAX0(MIN0(NLT,20),1)+1
      YY0L = NINT(YL/DDYL+0.4999999d0)*DDYL
      DDYS = DDYL/10d0
      YY0S = NINT(YL/DDYS+0.5d0)*DDYS
      P0L = KAY*(YY0L-YL)/(YU-YL)
      PDL = KAY*DDYL/(YU-YL)
      P0S = KAY*(YY0S-YL)/(YU-YL)
      PDS = KAY*DDYS/(YU-YL)
      NLT= INT(ABS(YU-YY0L)/DDYL+0.0000001d0) +1
      NTS= INT(ABS(YU-YY0S)/DDYS+0.0000001d0) +1
      DO N=1,NLT
         tipsy(n) =yy0l+ ddyl*(n-1)
      ENDDO
! plotting tics on vertical axis
      WRITE(NOUH1,fmt1)
     $ BS,'multiput(0,'  ,P0L,  ')(0,'  ,PDL  ,'){'  ,NLT,  '}{',
     $ BS,'line(1,0){25}}',
     $ BS,'multiput(0,'  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,  '}{',
     $ BS,'line(1,0){10}}'
      WRITE(NOUH1,fmt2)
     $ BS,'multiput('  ,KAY,  ','  ,P0L,  ')(0,'  ,PDL,  '){'  ,NLT,
     $ '}{',BS,'line(-1,0){25}}',
     $ BS,'multiput('  ,KAY,  ','  ,P0S,  ')(0,'  ,PDS,  '){'  ,NTS,
     $ '}{',BS,'line(-1,0){10}}'
! ...Zero line if necessary
      Z0L = KAY*(-YL)/(YU-YL)
      IF(Z0L .GT. 0D0.AND.Z0L .LT. FLOAT(KAY))
     $      WRITE(NOUH1,'(2A,F8.2,3A,I4,A)')
     $       BS,'put(0,'  ,Z0L,  '){',BS,'line(1,0){'  ,KAY,  '}}'
! ...labeling of axis
      SCMX = DMAX1(DABS(YL),DABS(YU))
      LEX  = NINT( LOG10(SCMX) -0.50001d0)
      DO n=1,nlt
         k = nint(kay*(tipsy(n)-yl)/(yu-yl))
         IF(lex .LE. 3 .AND. lex .GE. -3) THEN
! ...without exponent
            WRITE(NOUH1,'(2A,I4,5A,'//chyfmt//',A)')
     $           BS,'put(-25,'  ,K,  '){',BS,'makebox(0,0)[r]{',
     $           BS,'Large $ '  ,TIPSY(N),  ' $}}'
         ELSE
! ...with exponent
            WRITE(NOUH1,'(2A,I4,5A,'//chyfmt//',2A,I4,A)')
     $           BS,'put(-25,'  ,K,  '){',BS,'makebox(0,0)[r]{',
     $           BS,'Large $ '
     $           ,TIPSY(N)/(10d0**LEX),  BS,'cdot 10^{'  ,LEX,  '} $}}'
      ENDIF
      ENDDO
      END

      SUBROUTINE plkont(kax,kay,nchx,yl,yu,yy,ker,yer)
!     ************************************************
! For the moment unchanged
!     ************************************************
! plotting contour line for histogram
!     ***********************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION YY(*),YER(*)
      CHARACTER*80 FMT1
      COMMON / LPLDAT / NOUH1,NOUH2,ILINE
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/
      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $  BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(A)') '% ========== plotting primitives =========='
!...various types of line
      IF(ILINE .EQ. 1) THEN
         WRITE(NOUH1,'(2A)') BS,'thicklines '
      ELSE
         WRITE(NOUH1,'(2A)') BS,'thinlines '
      ENDIF
!...short macros for vertical/horizontal straight lines
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'x}[3]{',BS,'put(#1,#2){',
     $ BS,'line(1,0){#3}}}'
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'y}[3]{',BS,'put(#1,#2){',
     $ BS,'line(0,1){#3}}}'
      WRITE(NOUH1,'(8A)')
     $ BS,'newcommand{',BS,'z}[3]{',BS,'put(#1,#2){',
     $ BS,'line(0,-1){#3}}}'
!   error bars
      WRITE(NOUH1,'(8A)')
     $   BS,'newcommand{',BS,'e}[3]{',
     $   BS,'put(#1,#2){',BS,'line(0,1){#3}}}'
      IX0=0
      IY0=0
      DO 100 IB=1,NCHX
      IX1 = NINT(KAX*(IB-0.00001)/NCHX)
      IY1 = NINT(KAY*(YY(IB)-YL)/(YU-YL))
      IDY = IY1-IY0
      IDX = IX1-IX0
      FMT1 = '(2(2A,I4,A,I4,A,I4,A))'
      IF( IDY .GE. 0) THEN  
         IF(IY1 .GE. 0.AND.IY1 .LE. KAY)
     $   WRITE(NOUH1,FMT1) BS,'y{',IX0,'}{',IY0,'}{',IDY,'}',
     $                     BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ELSE
         IF(IY1 .GE. 0.AND.IY1 .LE. KAY)
     $   WRITE(NOUH1,FMT1) BS,'z{',IX0,'}{',IY0,'}{',-IDY,'}',
     $                     BS,'x{',IX0,'}{',IY1,'}{',IDX,'}'
      ENDIF
      IX0=IX1
      IY0=IY1
      IF(KER .EQ. 1) THEN
        IX2  = NINT(KAX*(IB-0.5000d0)/NCHX)
        IERR = NINT(KAY*((YY(IB)-YER(IB))-YL)/(YU-YL))
        IE = NINT(KAY*YER(IB)/(YU-YL))
        IF(IY1 .GE. 0.AND.IY1 .LE. KAY.and.abs(ierr) .LE. 9999
     $     .and.2*ie .LE. 9999) WRITE(NOUH1,8000) BS,IX2,IERR,IE*2
      ENDIF
 100  CONTINUE
8000  FORMAT(4(A1,2He{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(NOUH1,'(3A)') BS,'end{picture}}',
     $       ' % end of plotting histogram'
! change line-style
      ILINE= ILINE+1
      IF(ILINE .GT. 2) ILINE=1
      END

      SUBROUTINE 
     $     plmark(kax,kay,nchx,yl,yu,yy,ker,yer,chmark,chr,chr2,chr3)
!     ***************************************************************
! marks in the midle of the bin
!     **********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE 
      CHARACTER*1 chr
      DIMENSION yy(*),yer(*)
      CHARACTER chmark*(*),chr2*(*),chr3*(*)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs

      WRITE(NOUH1,'(4A,I4,A,I4,A)')
     $ BS,'put(300,250){',BS,'begin{picture}( ',KAX,',',KAY,')'
      WRITE(NOUH1,'(A)') '% ======= plmark: plotting primitives ======='

! Plotting symbol
      WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,chr2  , '}[2]{',
     $   BS,'put(#1,#2){',chmark,'}}'
! Error bar symbol
      WRITE(NOUH1,'(10A)')
     $   BS,'newcommand{',BS,chr3  , '}[3]{',
     $   BS,'put(#1,#2){',BS,'line(0,1){#3}}}'

      DO ib=1,nchx
         IF(chr .EQ. '*') THEN
            IX1 = NINT(KAX*(IB-0.5000d0)/NCHX) ! Midle of bin
         ELSEIF(chr .EQ. 'R') THEN
            IX1 = NINT(KAX*(IB*1d0)/NCHX)      ! Right edge of bin
         ELSEIF(chr .EQ. 'L') THEN
            IX1 = NINT(KAX*(IB-1D0)/NCHX)      ! Left edge of bin
         ELSE
            WRITE(6,*) '+++++ plamark: wrong line type:',chr
            RETURN
         ENDIF
         IY1 = NINT(KAY*(YY(IB)-YL)/(YU-YL))
         IF(IY1 .GE. 0.AND.IY1 .LE. KAY) 
     $   WRITE(NOUH1,'(A,A,A,I4,A,I4,A)') 
     $               BS,chr2, '{' ,IX1, '}{' ,IY1, '}'
         IF(KER .EQ. 1) THEN
            IERR = NINT(KAY*((YY(IB)-YER(IB))-YL)/(YU-YL))
            IE   = NINT(KAY*YER(IB)/(YU-YL))
            IF(iy1 .GE. 0 .AND. iy1 .LE. kay 
     $         .AND. ABS(ierr) .LE. 9999 .AND. 2*ie .LE. 9999) 
     $      WRITE(NOUH1,'(A,A,A,I4,A,I5,A,I4,A)') 
     $          BS, chr3,  '{'  ,IX1, '}{'  ,IERR, '}{'  ,IE*2,   '}'
         ENDIF
      ENDDO
      WRITE(NOUH1,'(3A)') BS,'end{picture}}',
     $    ' % end of plotting histogram'
      END


      SUBROUTINE gpltab(Npl,idl,capt,fmt,nch1,incr,npag)
!     ******************************************************
! Tables in TeX, up to 9 columns
! Npl           = numbers of columns/histograms
! idl(1:Npl)    = list of histo id's
! capt(1:Npl+1) = list of captions above each column
! fmt(1:1)      = format to print x(i) in first columb, 
!                 h(i) and error he(i) in further columns
! nch1,incr     = raws are printet in the sequence
!                 (h(i),he(i),i=nch1,nbin,incr), nbin is no. of bins.
! npag          = 0 no page eject, =1 with page eject
!     ******************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE 
!------- parameters
      DIMENSION    idl(*)
      CHARACTER*16 capt(*)
      CHARACTER*8  fmt(3)
!----------------------------------
! Titles and captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 TITCH
!----------------
      COMMON / LPLDAT / nouh1,nouh2,iline
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/
!-----------------
      LOGICAL gexist
      DIMENSION yyy(200),yer(200),bi(200,9),er(200,9)
      CHARACTER*80 title
      CHARACTER*1 Cn(9)
      DATA Cn /'1','2','3','4','5','6','7','8','9'/
!----------

! RETURN if histo non-existing or to many columns
      IF(.NOT.GEXIST(ID)) GOTO 900
      IF(Npl .GT. 9 )     GOTO 901
!
! npack histograms
      id1=idl(1)
      CALL ginbo1( id1,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      DO n=1,Npl
        CALL gunpak( idl(n),yyy ,'    ',idum)
        CALL gunpak( idl(n),yer ,'ERRO',idum)
        DO k=1,nchx
           bi(k,n)=yyy(k)
           er(k,n)=yer(k)
        ENDDO
      ENDDO
!------------------------------!
!           Header
!------------------------------!
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') '% ========================================='
      WRITE(NOUH1,'(A)') '% ============= begin table ==============='
      WRITE(NOUH1,'(2A)') BS,'begin{table}[!ht]'
      WRITE(NOUH1,'(2A)') BS,'centering'
!------------------------------!
! Central Caption
!------------------------------!
      WRITE(NOUH1,'(4A)') BS,'caption{',BS,'small'
      DO i=1,keytit
        WRITE(NOUH1,'(A)')     TITCH(i)
      ENDDO
      WRITE(NOUH1,'(A)') '}'
!------------------------------!
! Tabular header
!------------------------------!
      WRITE(NOUH1,'(20A)') BS,'begin{tabular}
     $ {|',  ('|c',j=1,Npl+1),  '||}'
!
      WRITE(NOUH1,'(4A)') BS,'hline',BS,'hline'
!------------------------------!
! Captions in columns
!------------------------------!
      WRITE(NOUH1,'(2A)') capt(1),('&',capt(j+1),j=1,Npl)
!
      WRITE(NOUH1,'(2A)') BS,BS
      WRITE(NOUH1,'(2A)') BS,'hline'
!----------------------------------------!
! Table content
! Note that by default RIGHT EDGE of bin is printed, as necessary for
! cumulative distributions, this can be changed with SLAN option
!----------------------------------------!
      CALL goptou(idl(1),ioplog,iopsla,ioperb,iopsc1,iopsc2)
      DO k=nch1,nchx,incr
        xi= dxl + (dxu-dxl)*k/(1d0*nchx)
        IF(iopsla.eq.2) xi= dxl + (dxu-dxl)*(k-0.5d0)/(1d0*nchx)
        IF(ioperb.eq.2) THEN
        WRITE(NOUH1,
     $  '(A,'//fmt(1)//'
     $     ,      '//Cn(Npl)//'(A,'//fmt(2)//',A,A,'//fmt(3)//'),  A)')
     $   '$', xi, ('$ & $', bi(k,j), BS, 'pm', er(k,j), j=1,Npl), '$'
        WRITE(NOUH1,'(2A)') BS,BS
        ELSE
        WRITE(NOUH1,
     $  '(A,'//fmt(1)//'
     $     ,      '//Cn(Npl)//'(A,'//fmt(2)//'),  A)')
     $   '$', xi, ('$ & $', bi(k,j), j=1,Npl), '$'
        WRITE(NOUH1,'(2A)') BS,BS
        ENDIF
      ENDDO
!------------------------------!
! Ending
!------------------------------!
      WRITE(NOUH1,'(4A)') BS,'hline',BS,'hline'
      WRITE(NOUH1,'(2A)') BS,'end{tabular}'
      WRITE(NOUH1,'(2A)') BS,'end{table}'
      WRITE(NOUH1,'(A)') '% ============= end   table ==============='
      WRITE(NOUH1,'(A)') '% ========================================='
      IF(npag .NE. 0) WRITE(NOUH1,'(2A)') BS,'newpage'

      RETURN
  900 WRITE(*,*) ' ++++ gpltab: NONEXISTIG HISTO ' ,ID
      RETURN
 901  WRITE(*,*) ' ++++ gpltab: TO MANY COLUMNS  ' ,Nplt
      END

      SUBROUTINE gpltab2(Npl,idl,ccapt,mcapt,fmt,chr1,chr2,chr3)
!     **********************************************************
! Tables in TeX, up to 9 columns
! Npl           = numbers of columns/histograms
! idl(1:Npl)    = list of histo id's
! ccapt(1:Npl+1)= list of column-captions above each column
! mcapt         = multicolumn header, none if mcapt=' ',
! fmt(1:1)      = format to print x(i) in first columb, 
!                 h(i) and error he(i) in further columns
! chr1          = ' ' normal default, ='S' the Same table continued
! chr2          = ' ' midle of the bin for x(i) in the first column
!               = 'R' right edge,     = 'L' left edge of the bin
! chr3          = ' ' no page eject,  ='E' with page eject at the end.
! Furthermore:
! Captions are defined by means of 
!    CALL gplcapt(capt) before CALL gpltab2
!    where CHARACTER*64 capt(50) is content of 
!    caption, line by line, see also comments in gplcapt routine.
!
!     ******************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE 
!------- parameters
      DIMENSION    idl(*)
      CHARACTER*16 ccapt(*)
      CHARACTER*8  fmt(3)
      CHARACTER*1  chr1,chr2,chr3
      CHARACTER*64 mcapt
!---------------------------------------------------
! This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
!----------------------------------
! Titles and captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 TITCH
!----------------
      COMMON / LPLDAT / nouh1,nouh2,iline
      COMMON / BSLASH / BS
      CHARACTER*1 BS
      SAVE /LPLDAT/, /BSLASH/
!-----------------
      LOGICAL gexist
      DIMENSION yyy(200),yer(200),bi(200,9),er(200,9)
      CHARACTER*80 title
      CHARACTER*1 Cn(9)
      DATA Cn /'1','2','3','4','5','6','7','8','9'/
!----------

! RETURN if histo non-existing or to many columns
      IF(.NOT.GEXIST(ID)) GOTO 900
      IF(Npl .GT. 9 )     GOTO 901
!
! npack histograms
      id1 = idl(1)
      CALL ginbo1( id1,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      DO n=1,Npl
        CALL gunpak( idl(n),yyy ,'    ',idum)
        CALL gunpak( idl(n),yer ,'ERRO',idum)
        DO k=1,nchx
           bi(k,n)=yyy(k)
           er(k,n)=yer(k)
        ENDDO
      ENDDO

      IF(chr1 .EQ. ' ' ) THEN
!------------------------------!
!           Header
!------------------------------!
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') ' '
      WRITE(NOUH1,'(A)') '% ========================================'
      WRITE(NOUH1,'(A)') '% ============ begin table ==============='
      IF(ABS(lint) .EQ. 2 ) THEN
         WRITE(NOUH1,'(2A)') BS,'noindent'
      ELSE
        WRITE(NOUH1,'(2A)') BS,'begin{table}[!ht]'
        WRITE(NOUH1,'(2A)') BS,'centering'
      ENDIF
!------------------------------!
! Central Caption
!------------------------------!
      IF(ABS(lint) .NE. 2 ) THEN
         WRITE(NOUH1,'(6A)') BS,'caption{',BS,'footnotesize',BS,'sf'
         DO i=1,keytit
            WRITE(NOUH1,'(A)')     TITCH(i)
         ENDDO
         WRITE(NOUH1,'(A)') '}'
      ENDIF
!------------------------------!
! Tabular header
!------------------------------!
      WRITE(NOUH1,'(20A)') BS,'begin{tabular}
     $ {|',  ('|c',j=1,Npl+1),  '||}'
!
      WRITE(NOUH1,'(4A)') BS,'hline',BS,'hline'
!------------------------------!
! Captions in columns
!------------------------------!
      WRITE(NOUH1,'(2A)') ccapt(1),('&',ccapt(j+1),j=1,Npl)
!
      ELSEIF(chr1 .EQ. 'S' ) THEN
         DO i=1,6
            BACKSPACE(NOUH1)
         ENDDO
      ELSE
         WRITE(*,*) ' ++++ gpltab2: WRONG chr1 ' ,chr1
      ENDIF

      WRITE(NOUH1,'(2A)') BS,BS
      WRITE(NOUH1,'(2A)') BS,'hline'

!------------------------------!
! Optional multicolumn caption
!------------------------------!
      IF(mcapt .NE. ' ') THEN
         WRITE(NOUH1,'(3A,I2,A)') '& ',BS,'multicolumn{',Npl,'}{c||}{'
         WRITE(NOUH1,'(3A)') '     ',mcapt, ' }'
         WRITE(NOUH1,'(2A)') BS,BS
         WRITE(NOUH1,'(2A)') BS,'hline'
      ENDIF

!----------------------------------------!
! Table content
! Note that by default RIGHT EDGE of bin is printed, as necessary for
! cumulative distributions, this can be changed with SLAN option
!----------------------------------------!
      CALL goptou(idl(1),ioplog,iopsla,ioperb,iopsc1,iopsc2)
      DO k=1,nchx
         IF(chr2 .EQ. 'R') THEN
! right
            xi= dxl + (dxu-dxl)*k/(1d0*nchx)
         ELSEIF(chr2 .EQ. 'L') THEN
! left
            xi= dxl + (dxu-dxl)*(k-1d0)/(1d0*nchx)
         ELSE
! midle
            xi= dxl + (dxu-dxl)*(k-0.5d0)/(1d0*nchx)
         ENDIF
         IF(ioperb.eq.2) THEN
          WRITE(NOUH1,
     $    '(A,'//fmt(1)//'
     $     ,      '//Cn(Npl)//'(A,'//fmt(2)//',A,A,'//fmt(3)//'),  A)')
     $    '$', xi, ('$ & $', bi(k,j), BS, 'pm', er(k,j), j=1,Npl), '$'
          WRITE(NOUH1,'(2A)') BS,BS
         ELSE
          WRITE(NOUH1,
     $    '(A,'//fmt(1)//'
     $     ,      '//Cn(Npl)//'(A,'//fmt(2)//'),  A)')
     $    '$', xi, ('$ & $', bi(k,j), j=1,Npl), '$'
          WRITE(NOUH1,'(2A)') BS,BS
         ENDIF
      ENDDO
!------------------------------!
! Ending
!------------------------------!
      WRITE(NOUH1,'(4A)') BS,'hline',BS,'hline'
      WRITE(NOUH1,'(2A)') BS,'end{tabular}'
      IF(ABS(lint) .EQ. 2 ) THEN
         WRITE(NOUH1,'(A)') '% ========================================'
      ELSE
         WRITE(NOUH1,'(2A)') BS,'end{table}'
      ENDIF
      WRITE(NOUH1,'(A)') '% ============= end   table =============='
      WRITE(NOUH1,'(A)') '% ========================================'
      IF(chr3 .EQ. 'E') WRITE(NOUH1,'(2A)') BS,'newpage'

      RETURN
  900 WRITE(*,*) ' ++++ gpltab2: NONEXISTIG HISTO ' ,ID
      RETURN
 901  WRITE(*,*) ' ++++ gpltab2: TO MANY COLUMNS  ' ,Nplt
      END


      SUBROUTINE gmonit(mode,id,par1,par2,par3)
!     *****************************************
! Utility program for monitoring m.c. rejection weights.
! ---------------------------------------------------------
! It is backward compatible with WMONIT except:
!  (1) for id=-1 one  should call as follows:
!      gmonit(-1,id,0d0,1d0,1d0) or skip initialisation completely!
!  (2) maximum absolute weight is looked for,
!  (3) gprint(-id) prints weight distribution, net profit!
!  (4) no restriction id<100 any more!
! ---------------------------------------------------------
! wt is weight, wtmax is maximum weight and rn is random number.
! IF(mode .EQ. -1) then
!          initalization if entry id, 
!        - wtmax is maximum weight used for couting overweighted
!          other arguments are ignored
! ELSEIF(mode .EQ. 0) then
!          summing up weights etc. for a given event for entry id
!        - wt is current weight.
!        - wtmax is maximum weight used for couting overweighted
!          events with wt>wtmax.
!        - rn is random number used in rejection, it is used to
!          count no. of accepted (rn < wt/wtmax) and rejected
!          (wt > wt/wtmax) events,
!          if ro rejection then put rn=0d0.
! ELSEIF(mode .EQ. 1) THEN
!          in this mode wmonit repports on accumulated statistics
!          and the information is stored in COMMON /cmonit/
!        - averwt= average weight wt counting all event
!        - errela= relative error of averwt
!        - nevtot= total number of accounted events
!        - nevacc= no. of accepted events (rn < wt/wtmax)
!        - nevneg= no. of events with negative weight (wt < 0)
!        - nevzer= no. of events with zero weight (wt = 0d0)
!        - nevove= no. of overweghted events (wt > wtmax)
!          and if you do not want to use cmonit then the value
!          the value of averwt is assigned to wt,
!          the value of errela is assigned to wtmax and
!          the value of wtmax  is assigned to rn in this mode.
! ELSEIF(mode .EQ. 2) THEN
!          all information defined for entry id defined above
!          for mode=2 is just printed of unit nout
! ENDIF
! note that output repport (mode=1,2) is done dynamically just for a
! given entry id only and it may be repeated many times for one id and
! for various id's as well.
!     ************************
      IMPLICIT double precision (a-h,o-z)
      PARAMETER( idmx=400,nbuf=24,nbuf2=24)
      COMMON / cglib / b(50000)
      COMMON /gind/ nvrs,nout,lenmax,length,index(idmx,3),titlc(idmx)
      CHARACTER*80 titlc
      SAVE
!
      idg = -id
      IF(id .LE. 0) THEN
           WRITE(nout,*) ' =====> Gmonit: wrong id= ',id
           WRITE(   6,*) ' =====> Gmonit: wrong id= ',id
           STOP
      ENDIF
      IF(mode .EQ. -1) THEN
!     *******************
           nbin = nint(dabs(par3))
           IF(nbin .GT. 100) nbin =100 
           IF(nbin .EQ. 0)   nbin =1
           xl   =  par1
           xu   =  par2
           IF(xu .LE. xl) THEN
             xl = 0d0
             xu = 1d0
           ENDIF
           lact=jadres(idg)
           IF(lact .EQ. 0) THEN
              CALL gbook1(idg,' gmonit $',nbin,xl,xu)
           ELSE
              WRITE(nout,*) ' WARNING gmonit: exists, id= ',id
              WRITE(   6,*) ' WARNING gmonit: exists, id= ',id
           ENDIF
      ELSEIF(mode .EQ. 0) THEN
!     **********************
           lact=jadres(idg)
           IF(lact .EQ. 0) THEN
              WRITE(nout,*) ' *****> Gmonit: uninitialized, id= ',id
              WRITE(   6,*) ' *****> Gmonit: uninitialized, id= ',id
              CALL gbook1(idg,' gmonit $',1,0d0,1d0)
              lact=jadres(idg)
           ENDIF
           wt   =par1
           wtmax=par2
           rn   =par3
!     standard entries
           CALL gf1(idg,wt,1d0)
!     additional goodies
           ist  = index(lact,2)
           ist2 = ist+7
           ist3 = ist+11
!    maximum weight -- maximum by absolute value but keeping sign
           b(ist3+13)    = max( dabs(b(ist3+13)) ,dabs(wt))
           IF(wt .NE. 0d0) b(ist3+13)=b(ist3+13) *wt/dabs(wt)
!    nevzer,nevove,nevacc
           IF(wt .EQ. 0d0)        b(ist3+10) =b(ist3+10) +1d0
           IF(wt .GT. wtmax)      b(ist3+11) =b(ist3+11) +1d0
           IF(rn*wtmax .LE. wt)   b(ist3+12) =b(ist3+12) +1d0
      ELSEIF(mode .GE. 1 .OR. mode .LE. 10) THEN
!     *************************************
           lact=jadres(idg)
           IF(lact .EQ. 0) THEN
              WRITE(nout,*) ' +++++++++ STOP in  wmonit ++++++++++++++'
              WRITE(   6,*) ' +++++++++ STOP in  wmonit ++++++++++++++'
              WRITE(nout,*) ' lack of initialization, id=',id
              WRITE(   6,*) ' lack of initialization, id=',id
              STOP
           ENDIF
           ist    = index(lact,2)
           ist2   = ist+7
           ist3   = ist+11
           ntot   = nint(b(ist3 +7))
           swt    =      b(ist3 +8)
           sswt   =      b(ist3 +9)
           IF(ntot .LE. 0 .or. swt  .EQ.  0d0 )  THEN
              averwt=0d0
              errela=0d0
           ELSE
              averwt=swt/float(ntot)
              errela=sqrt(abs(sswt/swt**2-1d0/float(ntot)))
           ENDIF
           nevacc = b(ist3 +12)
           nevneg = b(ist3  +1)
           nevove = b(ist3 +11)
           nevzer = b(ist3 +10)
           wwmax  = b(ist3 +13)
           nevtot = ntot
!  output through parameters
           par1   = averwt
           par2   = errela
           par3   = nevtot
           IF(mode .EQ. 2) THEN
              par1   = nevacc
              par2   = nevneg
              par3   = nevove
           ELSEIF(mode .EQ. 3) THEN
              par1   = nevneg
              par2   = nevzer
              par3   = wwmax
           ENDIF
!  no printout for mode > 1
!  ************************
           IF(mode .LE. 9) RETURN
           WRITE(nout,1003) id, averwt, errela, wwmax
           WRITE(nout,1004) nevtot,nevacc,nevneg,nevove,nevzer
           IF(mode .EQ. 2) RETURN
           CALL gprint(idg)
      ELSE
!     ****
           WRITE(nout,*) ' =====wmonit: wrong mode',mode
           WRITE(   6,*) ' =====wmonit: wrong mode',mode
           STOP
      ENDIF
!     *****
 1003 format(
     $  ' =======================gmonit========================'
     $/,'   id           averwt         errela            wwmax'
     $/,    i5,           e17.7,         f15.9,           e17.7)
 1004 format(
     $  ' -----------------------------------------------------------'
     $/,'      nevtot      nevacc      nevneg      nevove      nevzer'
     $/,   5i12)
      END
!==============================================================================
!==============================================================================
!= The package for plotting histograms in the logarithmic vertical scale      =
!= for histogramming/plotting library GLIBK version 1.20 of S. Jadach         =
!==============================================================================
!= Written by: Wieslaw Placzek                            CERN, November 1999 =
!= Last correction: 26.11.1999               by: WP                           =
!==============================================================================
!==============================================================================
!=          List of procedures,  non-user subprograms in brackets             =
!==============================================================================
!      SUBR/FUNC     1 PAR.  2 PAR.  3 PAR. 4 PAR. 5 PAR. 6 PAR. ...
!==============================================================================
!      GPlotLs         INT    CHR*1   CHR*1   INT   ----   ----
!     (LFram1Ls)       INT      INT     DBL   DBL    DBL    DBL
!     (sAxiYLs)        INT      INT     DBL   DBL   ----   ----
!     (PlHistLs)       INT      INT     INT   DBL    DBL    DBL  INT  DBL  DBL
!     (PlHis2Ls)       INT      INT     INT   DBL    DBL    DBL  INT  DBL  DBL
!      GPlot2Ls        INT    CHR*1   CHR*1 CHR*(*) CHR*4  CHR*4
!     (LFrameLs)       INT      INT     DBL   DBL    DBL    DBL CHR*1
!     (PlMarkLs)       INT      INT     INT   DBL    DBL    DBL  ...
!==============================================================================
!==============================================================================

      SUBROUTINE GPlotLs(id,ch1,ch2,kdum)
*     ***********************************
*======================================================================*
*= Plotting histograms in the logarithmic scale on the y-axis.        =*
*= Based on GPLOT from the glibk package by S. Jadach.                =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 23.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      DIMENSION yy(200),yer(200),yel(200),yeu(200)
      CHARACTER ch1,ch2,chr
      CHARACTER*80 title
      LOGICAL gexist
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      DATA chr /' '/
!*
!* Return if histo non-existing
      IF (.NOT.gexist(id)) GOTO 900
!* Unpack histogram
      CALL gunpak(id,yy ,'    ',idum)
      CALL gunpak(id,yer,'ERRO',idum)
      CALL ginbo1(id,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      CALL grang1(id,yl,yu)
!* Min and max values of y log scale
      IF (yu.GT.0d0) THEN
         yu = LOG10(yu)
      ELSE
         WRITE(6,*)' LOG scale impossible for negative values: ymax = ',
     &             yu
         STOP
      ENDIF
      IF (yl.GT.0d0) THEN
         yl = LOG10(yl)
      ELSE
         yl = yu - 10d0
      ENDIF
      dlty = yu - yl
      IF (dlty.LE.0d0) THEN
         WRITE(6,*)' Wrong values of: ymin, ymax = ',yl,yu
         STOP
      ELSEIF (dlty.GT.20d0) THEN
         yl = yu - 20d0
      ENDIF
!* Transform y values and their errors into log scale 
      DO i = 1,nchx
         yval = yy(i)
         IF (yval.GT.0d0) THEN
            yy(i) = MAX( LOG10(yval), yl )
            yerr = yer(i)
            yerl = yval - yerr 
            IF (yerl.GT.0d0) THEN
               yel(i) = MAX( LOG10(yerl), yl )
            ELSE
               yel(i) = yl
            ENDIF
            yerl = yval + yerr
            yeu(i) = MIN( MAX(LOG10(yerl),yl), yu )
         ELSE
            yy(i)  = yl 
            yel(i) = yl
            yeu(i) = yl
         ENDIF
      ENDDO
      kax = 1200
      kay = 1200
      IF (ch1 .EQ. 'S') THEN
!* Superimpose plot
        BACKSPACE(nouh1)
        BACKSPACE(nouh1)
      ELSE
!* New frame only
        chr = ch1
        CALL LFram1Ls(kax,kay,xl,xu,yl,yu)
      ENDIF
      WRITE(nouh1,'(A)')    '%========== next plot (line) =========='
      WRITE(nouh1,'(A,I10)') '%==== HISTOGRAM ID=',id
      WRITE(nouh1,'(A,A70 )') '% ',title
!* Continuous line for functions
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb - 1
      IF (iopsla .EQ. 2)  chr='C'
!* Suppress GPlotLs assignments
      IF (ch2 .EQ. 'B')   chr=' '
      IF (ch2 .EQ. '*')   chr='*'
      IF (ch2 .EQ. 'C')   chr='C'
!* Various types of lines
      IF     (chr .EQ. ' ') THEN
!* Contour line used for histogram
          CALL PlHistLs(kax,kay,nchx,yl,yu,yy,ker,yel,yeu)
      ELSE IF(chr .EQ. '*') THEN
!* Marks in the midle of the bin
          CALL PlHis2Ls(kax,kay,nchx,yl,yu,yy,ker,yel,yeu)
      ELSE IF(chr .EQ. 'C') THEN
!* Slanted (dotted) line in plotting non-MC functions
          CALL PlCirc(kax,kay,nchx,yl,yu,yy)
      ENDIF
!------------------------------------------------------------------
!* Ending ...
      WRITE(NOUH1,'(2A)') bs,'end{picture} % close entire picture '
      WRITE(NOUH1,'(2A)') bs,'end{figure}'
      RETURN

  900 WRITE(*,*) ' ++++ GPlotLs: NONEXISTIG HISTO ' ,id
      END

      SUBROUTINE LFram1Ls(kax,kay,xl,xu,yl,yu)
*     ****************************************
*======================================================================*
*= Frame for the logarithmic scale on the y-axis.                     =*
*= Based on LFRAM1 from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 23.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
!----------------------------------
!* Titles and captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
      CHARACTER*80 title
      DIMENSION tipsx(20)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      DATA icont /0/
!*
      icont = icont + 1
      IF (icont.GT.1) WRITE(nouh1,'(2A)') bs,'newpage'
!------------------------------!
!           Header
!------------------------------!
      WRITE(nouh1,'(A)') ' '
      WRITE(nouh1,'(A)') ' '
      WRITE(nouh1,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(nouh1,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     $%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(nouh1,'(2A)') bs,'begin{figure}[!ht]'
      WRITE(nouh1,'(2A)') bs,'centering'
!------------------------------!
! General Caption
!------------------------------!
      WRITE(nouh1,'(4A)') bs,'caption{',bs,'small'
      IF (keytit.EQ.0) THEN
        WRITE(nouh1,'(A)')     title
      ELSE
        WRITE(nouh1,'(A)')     titch(1)
      ENDIF
      WRITE(nouh1,'(A)') '}'
!------------------------------!
! Frames and labels
!------------------------------!
      WRITE(nouh1,'(A)') '% =========== big frame, title etc. ======='
      WRITE(nouh1,'(4A)') bs,'setlength{',bs,'unitlength}{0.1mm}'
      WRITE(nouh1,'(2A)') bs,'begin{picture}(1600,1500)'
      WRITE(nouh1,'(4A)') bs,'put(0,0){',bs,'framebox(1600,1500){ }}'
      WRITE(nouh1,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $    bs,'put(300,250){',bs,'begin{picture}( ',kax,',',kay,')'
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $    bs,'put(0,0){',bs,'framebox( ',kax,',',kay,'){ }}'
      WRITE(nouh1,'(A)') '% =========== x and y axis ================'
      CALL sAxiX(kax,xl,xu,ntipx,tipsx)
      CALL sAxiYLs(kax,kay,yl,yu)
      WRITE(nouh1,'(3A)') bs,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE sAxiYLs(kax,kay,yl,yu)
*     *********************************
*======================================================================*
*= Plotting the logarithmic scale on the y-axis.                      =*
*= Based on SAXIY from the glibk package by S. Jadach.                =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 23.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
!*
!* Find number of long ticks
      nll = NINT(yl + 0.49999999d0)
      nlu = NINT(yu - 0.49999999d0)
      nlt = nlu - nll + 1
      WRITE(nouh1,'(A)') '% .......sAxiYLs........ '
      WRITE(nouh1,'(A,I4)') '%  NLT= ',nlt
!* Positions of first and last long ticks
      pll = kay*(nll - yl)/(yu - yl)
      plu = kay*(nlu - yl)/(yu - yl)
!* Distance between two long ticks
      pdl = (plu - pll)/MAX(nlt-1,1)
!* Plotting long tics on vertical axis
      WRITE(nouh1,1000)
     $     bs,'multiput(0,'  ,pll,  ')(0,'  ,pdl  ,'){'  ,nlt,  '}{',
     $     bs,'line(1,0){25}}'
      WRITE(nouh1,1001)
     $     bs,'multiput('  ,kax,  ','  ,pll,  ')(0,'  ,pdl,  '){'  ,nlt,
     $     '}{',bs,'line(-1,0){25}}'
!* Plotting short tics on vertical axis (a bit more complicated)
      DO its = 2,9
         nst = nlt - 1
         psl = pll + pdl*LOG10(DBLE(its))
         pds = pdl
         psb = psl - pds
         IF (psb.GE.0) THEN
            psl = psb
            nst = nst + 1
         ENDIF
         pst = psl + nst*pds
         IF (pst.LE.kay) nst = nst + 1
         WRITE(nouh1,1000)
     $        bs,'multiput(0,'  ,psl,  ')(0,'  ,pds,  '){'  ,nst,  '}{',
     $        bs,'line(1,0){10}}'
         WRITE(nouh1,1001)
     $        bs,'multiput('  ,kax,  ','  ,psl,  ')(0,'  ,pds,  '){'  ,
     $        nst,'}{',bs,'line(-1,0){10}}'
      ENDDO
 1000 FORMAT(2A,F8.2,A,F8.2,A,I4,3A)
 1001 FORMAT(2A,I4,A,F8.2,A,F8.2,A,I4,3A)
!* Labeling of axis
      DO n = nll,nlu
         k = NINT(pll + (n-nll)*pdl)
         WRITE(nouh1,'(2A,I4,5A,I4,A)')
     $        bs,'put(-25,'  ,k,  '){',bs,'makebox(0,0)[r]{',
     $        bs,'large $ 10^{'  ,n,  '} $}}'
      ENDDO
      END

      SUBROUTINE PlHistLs(kax,kay,nchx,yl,yu,yy,ker,yel,yeu)
*     ******************************************************
*======================================================================*
*= Plotting contour line for histogram.                               =*
*= Based on PLHIST from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 23.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION yy(*),yel(*),yeu(*)
      CHARACTER*80 fmt1
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      SAVE
!*
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $     bs,'put(300,250){',bs,'begin{picture}( ',kax,',',kay,')'
      WRITE(nouh1,'(A)') '% ========== plotting primitives =========='
!* Various types of line
      IF(iline .EQ. 1) THEN
         WRITE(nouh1,'(2A)') bs,'thicklines '
      ELSE
         WRITE(nouh1,'(2A)') bs,'thinlines '
      ENDIF
!* Short macros for vertical/horizontal straight lines
      WRITE(nouh1,'(8A)')
     $     bs,'newcommand{',bs,'x}[3]{',bs,'put(#1,#2){',
     $     bs,'line(1,0){#3}}}'
      WRITE(nouh1,'(8A)')
     $     bs,'newcommand{',bs,'y}[3]{',bs,'put(#1,#2){',
     $     bs,'line(0,1){#3}}}'
      WRITE(nouh1,'(8A)')
     $     bs,'newcommand{',BS,'z}[3]{',bs,'put(#1,#2){',
     $     bs,'line(0,-1){#3}}}'
!* Error bars (slightly different for LOG scale)
      WRITE(nouh1,'(8A)')
     $     bs,'newcommand{',bs,'e}[3]{',
     $     bs,'put(#1,#2){',bs,'line(0,1){#3}}}'
      ix0 = 0
      iy0 = 0
      DO ib = 1,nchx
         ix1 = NINT( kax*(ib-0.00001d0)/nchx )
         iy1 = NINT( kay*(yy(ib)-yl)/(yu-yl) ) 
         idy = iy1-iy0
         idx = ix1-ix0
         fmt1 = '(2(2A,I4,A,I4,A,I4,A))'
         IF (idy .GE. 0) THEN  
            IF (iy1.GE.0 .AND. iy1.LE.kay)
     $           WRITE(nouh1,fmt1) bs,'y{',ix0,'}{',iy0,'}{',idy,'}',
     $           bs,'x{',ix0,'}{',iy1,'}{',idx,'}'
         ELSE
            IF (iy1.GE.0 .AND. iy1.LE.kay)
     $           WRITE(nouh1,fmt1) bs,'z{',ix0,'}{',iy0,'}{',-idy,'}',
     $           bs,'x{',ix0,'}{',iy1,'}{',idx,'}'
         ENDIF
         ix0 = ix1
         iy0 = iy1
         IF (ker.EQ.1) THEN
            ix2  = NINT(kax*(ib-0.5d0)/nchx)
            ierr = NINT( kay*(yel(ib) - yl)/(yu-yl) )
            ie   = NINT( kay*(yeu(ib) - yel(ib))/(yu-yl) )
            IF(iy1.GE.0 .AND. iy1.LE.kay .AND. ABS(ierr).LE.9999
     $           .AND. ie.LE.9999) WRITE(nouh1,8000) bs,ix2,ierr,ie  
         ENDIF
      ENDDO   
 8000 FORMAT(4(A1,2He{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(nouh1,'(3A)') bs,'end{picture}}',
     $       ' % end of plotting histogram'
!* Change line-style
      iline = iline + 1
      IF (iline.GT.2) iline = 1
      END

      SUBROUTINE PlHis2Ls(kax,kay,nchx,yl,yu,yy,ker,yel,yeu)
*     ******************************************************
*======================================================================*
*= Plotting marks in the midle if the bin for histogram.              =*
*= Based on PLHIS2 from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 23.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION yy(*),yel(*),yeu(*)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      SAVE 
!*
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $     bs,'put(300,250){',bs,'begin{picture}( ',kax,',',kay,')'
      WRITE(nouh1,'(A)') '% ========== plotting primitives =========='
!* Various types of mark
      irad1 = 6
      irad2 =10
      IF (iline.EQ.1) THEN
!*- Small filled circle
       WRITE(nouh1,'(8A,I3,A)')
     $        bs,'newcommand{',bs,'R}[2]{',
     $        bs,'put(#1,#2){',bs,'circle*{',irad1,'}}}'
      ELSEIF (iline.EQ.2) THEN
!*- Small open circle
       WRITE(NOUH1,'(8A,I3,A)')
     $        bs,'newcommand{',bs,'R}[2]{',
     $        bs,'put(#1,#2){',bs,'circle{',irad1,'}}}'
      ELSEIF (iline.EQ.3) THEN
!*- Big filled circle
       WRITE(nouh1,'(8A,I3,A)')
     $        bs,'newcommand{',bs,'R}[2]{',
     $        bs,'put(#1,#2){',bs,'circle*{',irad2,'}}}'
      ELSEIF (iline.EQ.4) THEN
!*- Big open circle
       WRITE(nouh1,'(8A,I3,A)')
     $        bs,'newcommand{',bs,'R}[2]{',
     $        bs,'put(#1,#2){',bs,'circle{',irad2,'}}}'
!*- Other symbols
      ELSEIF (iline.EQ.5) THEN
       WRITE(nouh1,'(10A)')
     $   bs,'newcommand{',bs,'R}[2]{',
     $   bs,'put(#1,#2){',bs,'makebox(0,0){$',bs,'diamond$}}}'
      ELSE
       WRITE(nouh1,'(10A)')
     $        bs,'newcommand{',bs,'R}[2]{',
     $        bs,'put(#1,#2){',bs,'makebox(0,0){$',bs,'star$}}}'
      ENDIF
!*- Error bars
      WRITE(nouh1,'(8A)')
     $   bs,'newcommand{',bs,'E}[3]{',
     $   bs,'put(#1,#2){',bs,'line(0,1){#3}}}'
      DO ib = 1,nchx
         ix1 = NINT(kax*(ib-0.5d0)/nchx)
         iy1 = NINT(kay*(yy(ib)-yl)/(yu-yl))
         IF(iy1.GT.0 .AND. iy1.LE.kay) WRITE(nouh1,7000) bs,ix1,iy1
         IF(ker.EQ.1) THEN
            ierr = NINT( kay*(yel(ib) - yl)/(yu-yl) )
            ie   = NINT( kay*(yeu(ib) - yel(ib))/(yu-yl) )
            IF(iy1.GT.0 .AND. iy1.LE.kay .AND. ABS(ierr).LE.9999
     $           .AND. ie.LE.9999) WRITE(nouh1,8000) bs,ix1,ierr,ie   
         ENDIF
      ENDDO
 7000 FORMAT(4(A1,2HR{,I4,2H}{,I4,1H}:1X ))
 8000 FORMAT(4(A1,2HE{,I4,2H}{,I5,2H}{,I4,1H}:1X ))
      WRITE(nouh1,'(3A)') BS,'end{picture}}',
     $    ' % end of plotting histogram'
!* Change line-style
      iline = iline+1
      IF(iline.GT.6) iline = 1
      END

      SUBROUTINE GPlot2Ls(id,ch1,ch2,chmark,chxfmt,chdumm)
*     ****************************************************
*======================================================================*
*= Plotting histograms in the logarithmic scale on the y-axis.        =*
*= Based on GPLOT2 from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 26.11.1999     by: WP                           =*  
*======================================================================*
!* New version, more user-friendly, of GPlotLs
!* INPUT:
!*    ID          histogram identifier
!*    ch1 = ' '   normal new plot
!*        = 'S'   impose new plot on previous one
!*    ch2 = ' '   ploting line default, contour
!*        = '*'   error bars in midle of the bin
!*        = 'R'   error bars at Right edge of the bin
!*        = 'L'   error bars at Left  edge of the bin
!*        = 'C'   slanted continuous smooth line
!*    chmark =    TeX symbol for ploting points
!*    chxfmt =    format (string) for labeling x-axis
!*    chdumm =    dummy character (string) parameter 
!*                (kept only for compatibility with GPLOT2) 
!*----------------------------------------------------------------------
!* NOTE: For LOG scale the format for y-axis label is generated       
!*       automatically and does not have to be specified by the user. 
!*        This is why the parameter CHYFMT of GPLOT2 is not needed here.  
!*----------------------------------------------------------------------
!* Furthermore:
!* Captions are defined by means of 
!*    CALL gplcapt(capt) before CALL gplot2
!*    where CHARACTER*64 capt(50) is content of 
!*    caption, line by line, see also comments in gplcapt routine.
!* Additional text as a TeX source text can be appended by means of
!*    CALL gplabel(lines) after CALL gplot2
!*    where CHARACTER*64 lines(50) is the TeX add-on.
!*    this is used to decorate plot with
!*    any kind marks, special labels and text on the plot.
!**********************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER ch1,ch2,chmark*(*)
      CHARACTER*(*) chxfmt,chdumm
      SAVE
      DIMENSION yy(200),yer(200),yel(200),yeu(200)
      CHARACTER*80 title
!---------------------------------------------------
!* This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
      LOGICAL gexist
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      CHARACTER chr
!* TeX Names of the error-bar command and of the point-mark command
      CHARACTER*1 chre, chrp1
      PARAMETER ( chre = 'E', chrp1= 'R' )
      CHARACTER*2 chrp
!* TeX Name of the point-mark command
      CHARACTER*1 chrx(12)
      DATA chrx /'a','b','c','d','f','g','h','i','j','k','l','m'/
      DATA chr /' '/
!*
!* Return if histo non-existing
      IF (.NOT.gexist(id)) GOTO 900
!* Unpack histogram
      CALL gunpak(id,yy ,'    ',idum)
      CALL gunpak(id,yer,'ERRO',idum)
      CALL ginbo1(id,title,nchx,dxl,dxu)
      xl = dxl
      xu = dxu
      CALL grang1(id,yl,yu)
!* Min and max values of y log scale
      IF (yu.GT.0d0) THEN
         yu = LOG10(yu)
      ELSE
         WRITE(6,*)' LOG scale impossible for negative values: ymax = ',
     &             yu
         STOP
      ENDIF
      IF (yl.GT.0d0) THEN
         yl = LOG10(yl)
      ELSE
         yl = yu - 10d0
      ENDIF
      dlty = yu - yl
      IF (dlty.LE.0d0) THEN
         WRITE(6,*)' Wrong values of: ymin, ymax = ',yl,yu
         STOP
      ELSEIF (dlty.GT.20d0) THEN
         yl = yu - 20d0
      ENDIF
!* Transform y values and their errors into log scale 
      DO i = 1,nchx
         yval = yy(i)
         IF (yval.GT.0d0) THEN
            yy(i) = MAX( LOG10(yval), yl )
            yerr = yer(i)
            yerl = yval - yerr 
            IF (yerl.GT.0d0) THEN
               yel(i) = MAX( LOG10(yerl), yl )
            ELSE
               yel(i) = yl
            ENDIF
            yerl = yval + yerr
            yeu(i) = MIN( MAX(LOG10(yerl),yl), yu )
         ELSE
            yy(i)  = yl 
            yel(i) = yl
            yeu(i) = yl
         ENDIF
      ENDDO
      kax = 1200
      kay = 1200
      IF (ch1 .EQ. 'S') THEN
!* Superimpose plot
        incr = incr + 1
        BACKSPACE(nouh1)
        BACKSPACE(nouh1)
      ELSE
!* New frame only
        incr = 1
        chr  = ch1
        CALL LFrameLs(kax,kay,xl,xu,yl,yu,chxfmt)
      ENDIF
      chrp= chrp1//chrx(incr)
      WRITE(nouh1,'(A)')    '%========== next plot (line) =========='
      WRITE(nouh1,'(A,I10)') '%==== HISTOGRAM ID=',id
      WRITE(nouh1,'(A,A70 )') '% ',title
!* Continuous line for functions
      CALL goptou(id,ioplog,iopsla,ioperb,iopsc1,iopsc2)
      ker = ioperb - 1
!* Default line type
      IF (iopsla .EQ. 2) THEN 
         chr = 'C'
      ELSE
         chr = ' '
      ENDIF
!* User defined line-type
      IF (ch2 .EQ. 'B')   chr=' '
!* Marks in the midle of the bin
      IF (ch2 .EQ. '*')   chr='*'
!* Marks on the right edge of the bin
      IF (ch2 .EQ. 'R')   chr='R'
!* Marks on the left edge of the bin
      IF (ch2 .EQ. 'L')   chr='L'
      IF (ch2 .EQ. 'C')   chr='C'
!* Various types of lines
      IF (chr.EQ.' ') THEN
!* Contour line used for histogram
          CALL PlHistLs(kax,kay,nchx,yl,yu,yy,ker,yel,yeu)
      ELSE IF(chr.EQ.'*' .OR. chr.EQ.'R' .OR. chr.EQ.'L') THEN
!* Marks on the right/left/midle of the bin
         CALL PlMarkLs(kax,kay,nchx,yl,yu,yy,ker,yel,yeu,
     &                 chmark,chr,chrp,chre)
      ELSE IF(chr .EQ. 'C') THEN
!* Slanted (dotted) line in plotting non-MC functions
          CALL PlCirc(kax,kay,nchx,yl,yu,yy)
       ELSE
          WRITE(6,*)' ++++ GPlot2Ls: Wrong mark position label: ',ch2
       ENDIF
!------------------------------------------------------------------
!* Ending ...
      WRITE(nouh1,'(2A)') bs,'end{picture} % close entire picture '
      IF(ABS(lint) .EQ. 2) THEN
         WRITE(nouh1,'(A)') '%======= GPlot2Ls:  end of plot =========='
      ELSE
         WRITE(nouh1,'(2A)') bs,'end{figure}'
      ENDIF
      RETURN
  900 WRITE(6,*) ' ++++ GPlot2Ls: NONEXISTIG HISTO ' ,id
      END

      SUBROUTINE LFrameLs(kax,kay,xl,xu,yl,yu,chxfmt)
*     ***********************************************
*======================================================================*
*= Frame for the logarithmic scale on the y-axis.                     =*
*= Based on LFRAME from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 24.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER chxfmt*(*)
      SAVE
!---------------------------------------------------
!* This COMMON connects gplint, gplcap and gplend
      COMMON / clint / lint
!---------------------------------------------------
!----------------------------------
!* Titles ang captions for plot
      COMMON / lpltit / titch(50),keytit
      CHARACTER*64 titch
      CHARACTER*80 title
      DIMENSION tipsx(20)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
      DATA icont /0/
!*
      icont = icont + 1
      IF (icont.GT.1) WRITE(nouh1,'(2A)') bs,'newpage'
!------------------------------!
!           Header
!------------------------------!
      WRITE(nouh1,'(A)') ' '
      WRITE(nouh1,'(A)') ' '
      WRITE(nouh1,'(A)') 
     $'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      WRITE(nouh1,'(A)') 
     $'%%%%%%%%%%%%%%%%%%%%%%%%%%LFrameLs%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
      IF (ABS(lint) .EQ. 2) THEN
         WRITE(nouh1,'(2A)') bs,'noindent'
      ELSE
         WRITE(nouh1,'(2A)') bs,'begin{figure}[!ht]'
         WRITE(nouh1,'(2A)') bs,'centering'
         WRITE(nouh1,'(2A)') bs,'htmlimage{scale=1.4}'
      ENDIF
!------------------------------!
! General Caption
!------------------------------!
      IF (ABS(lint) .NE. 2) THEN
         WRITE(nouh1,'(6A)') bs,'caption{',bs,'footnotesize',bs,'sf'
         DO i = 1,keytit
            WRITE(nouh1,'(A)')     titch(i)
         ENDDO
         WRITE(nouh1,'(A)') '}'
      ENDIF
!------------------------------!
! Frames and labels
!------------------------------!
      WRITE(nouh1,'(A)') '% =========== big frame, title etc. ======='
      WRITE(nouh1,'(4A)') bs,'setlength{',bs,'unitlength}{0.1mm}'
      WRITE(nouh1,'(2A)') bs,'begin{picture}(1600,1500)'
      IF( lint .LT. 0) THEN
! Big frame usefull for debuging 
         WRITE(nouh1,'(4A)') bs,'put(0,0){',bs,'framebox(1600,1500){ }}'
      ENDIF
      WRITE(nouh1,'(A)') '% =========== small frame, labeled axis ==='
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $    bs,'put(300,250){',bs,'begin{picture}( ',kax,',',kay,')'
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $    bs,'put(0,0){',bs,'framebox( ',kax,',',kay,'){ }}'
      WRITE(nouh1,'(A)') '% =========== x and y axis ================'
      CALL AxisX(kax,xl,xu,chxfmt)
      CALL sAxiYLs(kax,kay,yl,yu)
      WRITE(nouh1,'(3A)') bs,'end{picture}}'
     $                ,'% end of plotting labeled axis'
      END

      SUBROUTINE PlMarkLs(kax,kay,nchx,yl,yu,yy,ker,yel,yeu,
     &                    chmark,chr,chr2,chr3)
*     ******************************************************
*======================================================================*
*= Plotting marks in the midle if the bin for histogram.              =*
*= Based on PLHIS2 from the glibk package by S. Jadach.               =*
*----------------------------------------------------------------------*
*= Written by: Wieslaw Placzek                    CERN, November 1999 =*
*= Last modification: 24.11.1999     by: WP                           =*  
*======================================================================*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE 
      DIMENSION yy(*),yel(*),yeu(*)
      CHARACTER*1 chr
      CHARACTER chmark*(*),chr2*(*),chr3*(*)
      COMMON / lpldat / nouh1,nouh2,iline
      COMMON / bslash / bs
      CHARACTER*1 bs
!*
      WRITE(nouh1,'(4A,I4,A,I4,A)')
     $     bs,'put(300,250){',bs,'begin{picture}( ',kax,',',kay,')'
      WRITE(nouh1,'(A)') '% ========== plotting primitives =========='
!* Plotting symbol
      WRITE(nouh1,'(10A)')
     $   bs,'newcommand{',bs,chr2  , '}[2]{',
     $   bs,'put(#1,#2){',chmark,'}}'
!* Error bar symbol
      WRITE(nouh1,'(10A)')
     $   bs,'newcommand{',bs,chr3  , '}[3]{',
     $   bs,'put(#1,#2){',bs,'line(0,1){#3}}}'
!* Print marks and values
      DO ib = 1,nchx
         IF (chr .EQ. '*') THEN
            ix1 = NINT(kax*(ib-0.5d0)/nchx)    ! Midle of bin
         ELSEIF (chr .EQ. 'R') THEN
            ix1 = NINT(kax*(ib*1d0)/nchx)      ! Right edge of bin
         ELSEIF (chr .EQ. 'L') THEN
            ix1 = NINT(kax*(ib-1d0)/nchx)      ! Left edge of bin
         ELSE
            WRITE(6,*) '+++++ PlMarkLs: Wrong line type: ',chr
            RETURN
         ENDIF
         iy1 = NINT(kay*(yy(ib)-yl)/(yu-yl))
         IF(iy1.GT.0 .AND. iy1.LE.kay)
     $   WRITE(nouh1,'(A,A,A,I4,A,I4,A)') 
     $               bs,chr2, '{' ,ix1, '}{' ,iy1, '}'
         IF(ker.EQ.1) THEN
            ierr = NINT( kay*(yel(ib) - yl)/(yu-yl) )
            ie   = NINT( kay*(yeu(ib) - yel(ib))/(yu-yl) )
            IF(iy1.GT.0 .AND. iy1.LE.KAY .AND. ABS(ierr).LE.9999
     $         .AND. ie.LE.9999) WRITE(nouh1,'(A,A,A,I4,A,I5,A,I4,A)') 
     $           bs, chr3,  '{'  ,ix1, '}{'  ,ierr, '}{'  ,ie,   '}'
         ENDIF
      ENDDO
      WRITE(nouh1,'(3A)') BS,'end{picture}}',
     $    ' % end of plotting histogram'
      END
C  !!!! LOGBOOK of corrections since 24 Nov 91 !!!!!
C  
C * line in MARRAN to long ( in printout of ijkl)
C * CHBIN2 replaced by CHBIN1
C  !!!!!!!!!!!!!!

C Library of utilities for YFS and BHLUMI programs
C version 1.0 November 91
      SUBROUTINE CHBIN3(R,ALF,BET,X,XPRIM,DJAC)
C     *****************************************
C Written: Dec. 1991
C This routine mapps variable R into X, XPRIM=1-X.
C To be employed in the integration (either ordinary or Monte Carlo)
C of any distributions resambling the binomial distribution 
C             x**(alf-1)*(1-x)**(bet-1).
C with 1> alf,bet > 0. Variables R and X are  in (0,1) range.
C Djac is the Jacobian factor d(x)/d(r).
C Mapping is such that 1/djac is very close to
C binomial distribution x**(alf-1)*(1-x)**(bet-1).
C WARNING: 
C Mapping may fail very close to R=0 and R=1. User is recommended 
C to assure that: fleps**alf < R < 1-fleps**bet, 
C where fleps = 1.d-30.
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / INOUT  / NINP,NOUT
      SAVE   / INOUT  /
C
      IF( ALF.LE.1D-10 .OR. ALF .GT. 3D0 ) GOTO 900
      IF( BET.LE.1D-10 .OR. BET .GT. 3D0 ) GOTO 900
      X0=(1D0-ALF)/(2D0-ALF-BET)
      X0= MIN( MAX(X0, 0.001D0), 0.999D0)
      Q1=       X0**ALF            *BET*(1D0-X0)**(BET-1D0)
      Q2=       ALF*X0**(ALF-1D0)  *((1D0-X0)**BET)
      P1= Q1/(Q1+Q2)
      IF( R.LE.P1 ) THEN
         X    =  X0*(R/P1)**(1D0/ALF)
         XPRIM=  1D0-X
         DIST =  ALF* X**(ALF-1D0)  *BET*(1D0-X0)**(BET-1D0)
ccc      write(6,*) '3A:x,x1=',x,xprim
      ELSE
         XPRIM=  (1-X0)*((1D0-R)/(1D0-P1))**(1D0/BET)
         X    =  1D0- XPRIM
         DIST =  ALF*X0**(ALF-1D0)  *BET*XPRIM**(BET-1D0)
ccc      write(6,*) '3B:x,x1=',x,xprim
      ENDIF
      DJAC    =  (Q1+Q2)/DIST
      RETURN
  900 WRITE(NOUT,*) ' ++++ STOP IN CHBIN3: wrong parameters'
      WRITE(   6,*) ' ++++ STOP IN CHBIN3: wrong parameters'
      STOP
      END

      SUBROUTINE CHBIN1(R,ALF,BET,XMAX,X,DJAC)
C     ****************************************
C     last correction Dec. 91
c this mapps variable r into x.
c to be employed in the integration (either ordinary or monte carlo)
c of distributions resambling
c the binomial distribution x**(alf-1)*(1-x)**(bet-1)
c with alf > 0 and  bet arbitrary.
c variable r is in (0,1) range and x is within (0,xmax) range.
c djac is jacobian factor d(x)/d(r).
c mapping is such that 1/djac is very close to
c binomial distribution x**(alf-1)*(1-x)**(bet-1).
c WARNING: mapping may fail very close to R=0. Practically, one is
c recommended to obey: fleps**alf < r, where fleps = 1.d-30.
c Problems may also arise for very small xmax ( below 1.d-12 ).
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / INOUT  / NINP,NOUT
      save   / INOUT  / 
C
      IF( ALF.LE.0D0 ) GOTO 900
      X0=(ALF-1D0)/(ALF+BET-2D0)
      IF(X0.GT.XMAX) X0=XMAX
      X0= MAX(X0, 0D0)
      Q1= 1D0/ALF*X0**ALF  *(1D0-X0)**(BET-1D0)
      Q2= X0**(ALF-1D0) /BET*((1D0-X0)**BET-(1D0-XMAX)**BET)
      P1= Q1/(Q1+Q2)
      IF( R.LE.P1 ) THEN
         X=X0*(R/P1)**(1D0/ALF)
         DIST= X**(ALF-1D0)*(1D0-X0)**(BET-1D0)
      ELSE
         R1= (1D0-R)/(1D0-P1)
         X = (1D0-XMAX)**BET + ((1D0-X0)**BET-(1D0-XMAX)**BET)*R1
         X = 1D0 - X**(1D0/BET)
         DIST= X0**(ALF-1D0)*(1D0-X)**(BET-1D0)
      ENDIF
      DJAC=(Q1+Q2)/DIST
      RETURN
  900 WRITE(NOUT,*) ' ========= STOP IN CHBIN1: WRONG PARAMS'
      STOP
      END


      SUBROUTINE VESK1W(MMODE,FUNSKO,PAR1,PAR2,PAR3) 
C     **********************************************
C======================================================================
C======================================================================
C===================== V E S K 1 W ====================================
C==================S. JADACH  SEPTEMBER 1985=========================== 
C==================S. JADACH  November  1991=========================== 
C======================================================================
C ONE DIMENSIONAL MONTE CARLO  SAMPLER. 
C Vesrion with weighted events! 
C DOUBLE PRECISION  FUNCTION FUNSKO IS THE DISTRIBUTION TO BE GENERATED.
C JLIM1 IS THE NUMBER OF ENTRIES IN THE EQUIDISTANT LATICE WHICH
C IS FORMED IN THE FIRST STAGE AND JLIM2 IS THE TOTAL MAXIMUM 
C NUMBER OF ENTRIES IN THE LATICE, NOTE THAT DIMENSIONS OF
C MATRICES IN /CESK8A/ SHOULD BE AT LEAST JLIM2+1 . 
C FOR MILD FUNSKO JLIM2=128 IS ENOUGH.   
C TO CREATE AN INDEPENDENT VERSION REPLACE /ESK8A/=>/ESK8B/. 
C     ********************************** 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      save
      COMMON / CESK1W / XX(1025),YY(1025),ZINT(1025),ZSUM,JMAX 
      COMMON / INOUT  / NINP,NOUT  
      DIMENSION RNUM(1)
      EXTERNAL FUNSKO
      DATA JLIM1,JLIM2/16,257/           
      DATA IWARM/0/                      
C                                        
      MODE=MMODE                         
      IF(MODE.EQ.-1) THEN                
C     ===================                
C INITIALISATION PART, SEE VINSKO FOR MORE COMMENTS
      INIRAN=1                           
      IWARM=1                            
      WT=0.                              
      SWT=0.                             
      SSWT=0.                            
      NEVS=0                             
C INITIALISATION PART, SAMPLING DISTRIBUTION FUNSKO
C AND FILLING MATRICES XX,YY,ZINT ETC.   
      JMAX=1                             
      XX(1)=0.                           
      XX(2)=1.                           
      YY(1)=FUNSKO(XX(1))                
      YY(2)=FUNSKO(XX(2))                
      IF(YY(1).LT.0.0.OR.YY(2).LT.0.0) GO TO 999 
      ZINT(1)=.5D0*(YY(2)+YY(1))*(XX(2)-XX(1))  
C
      JDIV=1                             
      DO 200 K=1,JLIM2-1                 
      IF(JMAX.LT.JLIM1) THEN             
C...    NOTE THAT DESK1W INCREMENTS JMAX=JMAX+1 IN EVERY CALL 
        CALL DESK1W(FUNSKO,JDIV)                
        JDIV=JDIV+2                      
        IF(JDIV.GT.JMAX) JDIV=1          
      ELSE                               
        JDIV=1                           
        ZMX=ZINT(1)                      
        DO 180 J=1,JMAX                  
        IF(ZMX.LT.ZINT(J)) THEN          
          ZMX=ZINT(J)                    
          JDIV=J                         
        ENDIF                            
  180   CONTINUE                         
        CALL DESK1W(FUNSKO,JDIV)                
      ENDIF                              
  200 CONTINUE                           
C                                        
C...  FINAL ADMINISTRATION, NORMALIZING ZINT ETC. 
      ZSUM1=0.                           
      ZSUM =0.                           
      DO 220 J=1,JMAX                    
      ZSUM1=ZSUM1+ZINT(J)                
      YMAX= MAX( YY(J+1),YY(J))          
      ZINT(J)=YMAX*(XX(J+1)-XX(J))       
  220 ZSUM=ZSUM+ZINT(J)                  
      SUM=0.                             
      DO 240 J=1,JMAX                    
      SUM=SUM+ZINT(J)                    
  240 ZINT(J)=SUM/ZSUM                   
C====>>>
C Crude x-section estimate
ccc      CINTEG=ZSUM 
ccc      ERRINT=0D0 
      PAR1=  ZSUM                      
      PAR2=  ZSUM
      PAR3=  ZSUM                      
C===<<<                                 
      ELSE IF(MODE.EQ.0) THEN            
C     =======================            
C GENERATION PART                        
      IF(IWARM.EQ.0) GOTO 901            
ccc  222 CONTINUE                           
ccc      IF( (WT-1D0).GT.1D-10) THEN                  
ccc        WT=WT-1.D0                       
ccc      ELSE                               
        CALL VARRAN(RNUM,1)
        RNUMB=RNUM(1)
        DO 215 J=1,JMAX                  
        JSTOP=J                          
  215   IF(ZINT(J).GT.RNUMB) GOTO 216    
  216   CONTINUE                         
        IF(JSTOP.EQ.1) THEN              
          D=RNUMB/ZINT(1)                
        ELSE                             
          D =(RNUMB-ZINT(JSTOP-1))/(ZINT(JSTOP)-ZINT(JSTOP-1))
        ENDIF                            
        X=XX(JSTOP)*(1.D0 -D )+XX(JSTOP+1)*D   
        FN=FUNSKO(X)                     
        IF(FN.LT.0.D0) GOTO 999            
        YYMAX=MAX(YY(JSTOP+1),YY(JSTOP)) 
        WT=FN/YYMAX                      
        NEVS=NEVS+1                      
        SWT=SWT+WT                       
        SSWT=SSWT+WT*WT                  
ccc      ENDIF                              
ccc      CALL VARRAN(RNUMB,1)
ccc      IF(RNUMB.GT.WT) GOTO 222           
      PAR1=  X                           
      PAR2=  FN
      PAR3=  WT                          
C                                        
      ELSE IF(MODE.EQ.1) THEN            
C     =======================            
C FINAL STATISTICS                       
C STJ 24.OCT.89                          
      CINTEG=0D0                         
      ERRINT=0D0                         
      IF(NEVS.GT.0) CINTEG=ZSUM*SWT/FLOAT(NEVS) 
      IF(NEVS.GT.0) ERRINT=SQRT(SSWT/SWT**2-1.D0/FLOAT(NEVS)) 
      PAR1=  CINTEG                      
      PAR2=  ERRINT
      PAR3=  ZSUM                      
C--
      ELSE                               
C     ====                               
      GOTO  902                          
      ENDIF                              
C     =====                              
C                                        
      RETURN                             
 901  WRITE(NOUT,9010)                   
 9010 FORMAT(' **** STOP IN VESK8A, LACK OF INITIALISATION') 
      STOP                               
 902  WRITE(NOUT,9020)                   
 9020 FORMAT(' **** STOP IN VESK8A, WRONG MODE ') 
      STOP                               
 999  WRITE(NOUT,9990)                   
 9990 FORMAT(' **** STOP IN VESK8A, NEGATIVE VALUE OF FUNSKO ') 
      STOP                               
      END                                
      SUBROUTINE DESK1W(FUNSKO,JDIV)            
C     ******************************            
C THIS ROUTINE BELONGS TO VESK8A PACKAGE 
C IT SUDIVIDES INTO TWO EQUAL PARTS THE INTERVAL 
C (XX(JDIV),XX(JDIV+1))  IN THE LATICE   
C     ***********************            
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      save
      COMMON / CESK1W / XX(1025),YY(1025),ZINT(1025),ZSUM,JMAX 
      COMMON / INOUT  / NINP,NOUT  
      EXTERNAL FUNSKO
C                                        
      XNEW=.5D0*(XX(JDIV) +XX(JDIV+1))   
      DO 100 J=JMAX,JDIV,-1              
      XX(J+2)  =XX(J+1)                  
      YY(J+2)  =YY(J+1)                  
  100 ZINT(J+1)=ZINT(J)                  
      XX(JDIV+1)= XNEW                   
      YY(JDIV+1)= FUNSKO(XNEW)           
      IF(YY(JDIV+1).LT.0.) GOTO 999      
      ZINT(JDIV)  =.5D0*(YY(JDIV+1)+YY(JDIV)  )*(XX(JDIV+1)-XX(JDIV)  ) 
      ZINT(JDIV+1)=.5D0*(YY(JDIV+2)+YY(JDIV+1))*(XX(JDIV+2)-XX(JDIV+1)) 
      JMAX=JMAX+1                        
      RETURN                             
  999 WRITE(NOUT,9000)                   
 9000 FORMAT(' **** STOP IN DESK1W, NEGATIVE VALUE OF FUNSKO ')
      STOP                               
      END                                


      SUBROUTINE VESK2W(MODE,FUNSKO,X,Y,WT)
C     *************************************
C=======================================================================
C=======================================================================
C=======================================================================
C===============TWO DIMENSIONAL SAMPLER VESK2W==========================
C=======================================================================
C=======================================================================
C=======================================================================
C                         VESK2W                                       C
C  GENERAL PURPOSE ROUTINE TO GENERATE AN ARBITRARY TWO DIMENSIONAL    C
C  DISTRIBUTION SUPPLIED BY USER IN A FORM OF FUNCTION FUNSKO(X,Y)     C
C                 WRITTEN NOVEMBER 1985                                C
C                    BY S. JADACH                                      C
C                 LAST UPDATE:  07.NOV.1990                            C
C                 version with weighted event....                      C
C======================================================================C
C VESKO2 GENERATES TWO DIMENSIONAL DISTRIBUTION DEFINED BY ARBITRARY
C FUNCTION FUNSKO(X,Y) WHERE X,Y BELONG  TO (0,1) RANGE.
C THE METHOD CONSISTS IN DIVIDING UNIT PLAQUET INTO CELLS USING
C SORT OF 'LIFE-GAME' METHOD IN WHICH THE DIVISION OF A CELLS IS MADE
C (DURING INITIALISATION) ALWAYS FOR THIS CELL WHICH CONTAINS
C A MAXIMUM VALUE OF THE INTEGRAL OVER FUNSKO IN THE CELL.
C RESULTING CELLS CONTAIN (USUALLY UP TO FACTOR TWO) EQUAL INTERGRAL
C VALUE. THE GENERATION CONSISTS IN CHOOSING RANDOMLY  A CELL
C ACCORDING TO ITS CONTENT AND THEN IN GENERATING X,Y WITHIN THE CELL.
C REJECTION METHOD IS APPLIED AT THE END OF THE PROCEDURE IN ORDER TO
C ASSURE THAT X,Y ARE DISTRIBUTED PRECISELY ACCORDING TO FUNSKO(X,Y)
C                    PARAMETERS
C -/ MODE = -1 INITIALISATION, NO (X,Y) GENERATED, CALL VESKO2(-1,D1,D2)
C    HAS TO BE MADE PRIOR  TO GENERATING FIRST (X,Y) PAIR
C -/ MODE =  0 GENERATION OF (X,Y) PAIR BY CALL VESKO2(0,X,Y)
C -/ MODE =  1 CALL VESKO2(1,VALINT,ERRINT) MAY BE DONE AFTER LAST
C    (X,Y) WAS GENERATED IN ORDER TO OBTAIN THE VALUE OF THE INTEGRAL
C    VALINT AND ITS ERROR ERRINT, INTEGRAL IS CALCULATED USING AVERAGE
C    WEIGHTS ENCOUTERED DURING GENERATION PHASE
C -/ X,Y  IF MODE=-1 THE THEY ARE DUMMY
C         IF MODE= 0 THE RESULT OF RANDOM GENERATION ACCORDING TO
C                    FUNCTION FUNSKO, X AND Y BELONG TO (0,1)
C         IF MODE= 1 X= VALUE OF INTEGRAL AND Y=ERROR (RELATIVE)
C                    WT = crude x-section
C ------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      save
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      DOUBLE PRECISION DRVEC(100)
      EXTERNAL FUNSKO
      DATA IWARM/77/

      IF(MODE) 100,200,300
C...  INITIALISATION PART, SEE VINSKO FOR MORE COMMENTS
  100 CALL VINSKW(FUNSKO)
      IWARM=0
      WT=0D0
      WTMAX = 1D0
      WTMXX = WTMAX
      NEVOV=0
      SWT=0D0
      SSWT=0D0
      NEVS=0
C(((((((((((((
C     CALL HBOOK1(1, 16H WT-VESKO2     $,75,0.0D0,1.5D0)
C     CALL HMINIM(1,0)
C     CALL HBOOK2(2,16H X-Y VESKO2    $, 64,0,1, 32,0,1,0)
C     CALL HSCALE(2)
C))))))))))))
      RETURN
C...
  200 CONTINUE
C...  GENERATION PART
      IF(IWARM.EQ.77) GO TO 980
cc    IF(WT.GT.WTMAX) THEN
cc      write(6,*) ' vesko2: ev. overweighted, dont worry, wt=',wt
cc      WT=WT-WTMAX
cc      NEVOV=NEVOV+1
cc    ELSE
        CALL VARRAN(DRVEC,3)
        R = DRVEC(1)
        DO 215 J=1,JMAX
        JSTOP=J
  215   IF(ZINT(J).GT.R) GOTO 216
  216   CONTINUE
        XR=XX(JSTOP,1)+DX(JSTOP,1)*DRVEC(2)
        YR=XX(JSTOP,2)+DX(JSTOP,2)*DRVEC(3)
        FN=FUNSKO(XR,YR)
        IF(FN.LT.0.) GOTO 999
        YYMAX=YYMX(JSTOP)
        WT=FN/YYMAX
        WTMXX = MAX(WTMXX,WT)
cc      IF(NEVS.LE.(4*JLIM2).AND.WT.GT.WTMAX) THEN
cc         WTMAX=WT*1.1D0
cc         WRITE(6,*) ' VESKO2: NEVS, new WTMAX= ',NEVS,WTMAX
cc      ENDIF
        NEVS=NEVS+1
        SWT=SWT+WT
        SSWT=SSWT+WT*WT
C((((((((((
C       CALL HFILL(1,WT,0D0,1D0)
C))))))))))
ccc   ENDIF
CCC    CALL VARRAN(DRVEC,1)
ccc    RN=DRVEC(1)
ccc   IF(WTMAX*RN.GT.WT) GOTO 200
      X=XR
      Y=YR
C((((((((((
C     CALL HFILL(2,XR,YR)
C))))))))))
      RETURN
C...
  300 CONTINUE
C THIS IS THE VALUE OF THE INTEGRAL
      CINTEG=ZSUM*SWT/NEVS
C AND ITS ERROR
      ERRINT=SQRT(SSWT/SWT**2-1D0/NEVS)
      X=CINTEG
      Y=ERRINT
      WT=ZSUM
C((((((((((
C     CALL HPRINT(1)
C     CALL HDELET(1)
C     CALL HPRINT(2)
C     CALL HDELET(2)
      PRINT 7000,NEVS,NEVOV,WTMAX,WTMXX
 7000 FORMAT(' VESK2W: NEVS,NEVOV,WTMAX,WTMXX= ',2I7,2F7.3)
C))))))))))
      RETURN
  980 WRITE(NOUT,9002)
 9002 FORMAT(' **** STOP IN VESK2W, LACK OF INITIALISATION   ')
      STOP
  999 WRITE(NOUT,9004)
 9004 FORMAT(' **** STOP IN VESK2W, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END

      SUBROUTINE VINSKW(FUNSKO)
C     *************************
C THIS ROUTINE BELONGS TO VESKO2 PACKAGE
C JLIM1 IS THE NUMBER OF CELLS, DIVISION OF THE UNIT PLAQUE INTO CELLS
C IS MADE IN THE FIRST STAGE.    JLIM2 IS THE TOTAL MAXIMUM
C NUMBER OF CELLS, NOTE THAT DIMENSIONS OF
C MATRICES IN /VESKOA/ SHOULD BE AT LEAST JLIM2
C     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      save
C ------------------------------------------------------------
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      EXTERNAL FUNSKO

C...  INITIALISATION PART, SAMPLING DISTRIBUTION FUNSKO
C...  AND FILLING MATRICES XX,YY,ZINT ETC.
      JMAX=1
      XX(1,1)=0D0
      XX(1,2)=0D0
      DX(1,1)=1D0
      DX(1,2)=1D0
      LEV(1)=1
      SUM=0D0
      DO 150 I=1,2
      DO 150 K=1,2
C... THIS IS NOT ELEGANT BUT SIMPLE
      YY(1,I,K)=FUNSKO(XX(1,1)+(I-1.)*DX(1,1),XX(1,2)+(K-1.)*DX(1,2))
      IF(YY(1,I,K).LT.0.0) GO TO 999
  150 SUM=SUM+YY(1,I,K)
      ZINT(1)=SUM*DX(1,1)*DX(1,2)/4D0

      JDIV=1
      DO 200 KK=1,JLIM2-1
      IF(JMAX.LT.JLIM1) THEN
C...    NOTE THAT DIVSKW INCREMENTS JMAX=JMAX+1 IN EVERY CALL
        CALL DIVSKW(JDIV,FUNSKO)
C(((((((((((
c      IF(JMAX.EQ.JLIM1) THEN
c      PRINT 9900,JMAX,(LEV(I),I=1,JMAX)
c 9900 FORMAT(///,' JMAX...  LEV LEV LEV LEV LEV',I10,/(24I5))
c      PRINT 9901,((XX(JD,I),I=1,2),JD=1,JMAX)
c 9901 FORMAT('  XX XX XX XX XX XX XX  ',/(10E12.5))
c      PRINT 9902,((DX(JD,I),I=1,2),JD=1,JMAX)
c 9902 FORMAT('  DX  DX DX DX DX DX ',/(10E12.5))
c      PRINT 9903,(((YY(JD,I,K),I=1,2),K=1,2),JD=1,JMAX)
c 9903 FORMAT('  YY  YY YY YY YY YY ',/(8E15.5))
c      PRINT 9904,(ZINT(I),I=1,JMAX)
c 9904 FORMAT('   ZINT ZINT ZINT ZINT ',/(10E12.5))
c      ENDIF
C))))))))))))
        JDIV=JDIV+2
        IF(JDIV.GT.JMAX) JDIV=1
      ELSE
        JDIV=1
        ZMX=ZINT(1)
        DO 180 J=1,JMAX
        IF(ZMX.LT.ZINT(J)) THEN
          ZMX=ZINT(J)
          JDIV=J
        ENDIF
  180   CONTINUE
        CALL DIVSKW(JDIV,FUNSKO)
      ENDIF
  200 CONTINUE

C(((((((((((
c      JPRN=64
c      PRINT 9910,JMAX,(LEV(I),I=1,JMAX)
c 9910 FORMAT(/,' JMAX...  LEV LEV LEV LEV LEV',I10,/(24I5))
c      IF(JMAX.LE.JPRN) PRINT 9911,((XX(JD,I),I=1,2),JD=1,JMAX)
c 9911 FORMAT('  XX XX XX XX XX XX XX  ',/(10E12.5))
c      IF(JMAX.LE.JPRN) PRINT 9912,((DX(JD,I),I=1,2),JD=1,JMAX)
c 9912 FORMAT('  DX  DX DX DX DX DX ',/(10E12.5))
c      IF(JMAX.LE.JPRN) PRINT 9913,(((YY(JD,I,K),I=1,2),K=1,2),JD=1,JMAX)
c 9913 FORMAT('  YY  YY YY YY YY YY ',/(8E15.5))
c      IF(JMAX.LE.JPRN) PRINT 9914,(ZINT(I),I=1,JMAX)
c 9914 FORMAT('   ZINT ZINT ZINT ZINT ',/(10E12.5))
C     DO 902 J=1,JMAX
C     Z=1D0*J-.5D0
C 902 CALL HFILL(202,Z,ZINT(J))
C))))))))))))
C...  FINAL ADMINISTRATION, NORMALIZING ZINT ETC.
      ZSUM1=0D0
      ZSUM =0D0
      DO 260 J=1,JMAX
      ZSUM1=ZSUM1+ZINT(J)
      YMAX= 0D0
      DO 250 I=1,2
      DO 250 K=1,2
  250 YMAX= MAX(YMAX,YY(J,I,K))
      YYMX(J)=YMAX
      ZINT(J)=YMAX*DX(J,1)*DX(J,2)
  260 ZSUM=ZSUM+ZINT(J)
C((((((((
      ZR=ZSUM1/ZSUM
      PRINT 7000,ZR
 7000 FORMAT(' /////// ZSUM1/ZSUM= ',F20.8)
C)))))))))
      SUM=0D0
      DO 240 J=1,JMAX
      SUM=SUM+ZINT(J)
  240 ZINT(J)=SUM/ZSUM
C(((((((((((
c     JPRN=64
c     PRINT 9932,JMAX
c9932 FORMAT(/'=====JMAX ZINT ZINT ZINT  ',I10)
c     IF(JMAX.LE.JPRN) PRINT 9935,(ZINT(I),I=1,JMAX)
c9935            FORMAT(10E12.5)
C     DO 901 J=2,JMAX
C 901 CALL HFILL(201,(ZINT(J)-ZINT(J-1))*JMAX)
C     CALL HFILL(201,ZINT(1)*JMAX)
C))))))))))))
      RETURN
  999 WRITE(NOUT,9000)
 9000 FORMAT(' **** STOP IN VINSKW, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END

      SUBROUTINE DIVSKW(JD,FUNSKO)
C     ****************************
C THIS ROUTINE BELONGS TO VESKO2 PACKAGE
C IT SUBDIVIDES ONE CELL (NO. JD) INTO TWO EQUAL SIZE CELLS
C     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      save
C ------------------------------------------------------------
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      EXTERNAL FUNSKO

C...  MOOVE TO MAKE A HOLE FOR A NEW ENTRY (ONE ADDITIONAL CELL)
      DO 100 J=JMAX,JD,-1
      ZINT(J+1)=ZINT(J)
      LEV(J+1)=LEV(J)
      DO 100 I=1,2
      XX(J+1,I)  =XX(J,I)
      DX(J+1,I)  =DX(J,I)
      DO 100 K=1,2
  100 YY(J+1,I,K)  =YY(J,I,K)
C...  CREATE TWO NEW CELLS AND STORE THEM
      LL= MOD(LEV(JD),2)+1
      DX(JD,LL)=DX(JD,LL)/2D0
      DX(JD+1,LL)=DX(JD+1,LL)/2D0
      XX(JD+1,LL)=XX(JD,LL)+DX(JD,LL)
      IF(LL.EQ.1) THEN
        DO 150 I=1,2
C... THIS IS NOT ELEGANT, PROBABLY COULD BE DONE BETTER
        YY(JD,2,I)=FUNSKO(XX(JD,1)+DX(JD,1),XX(JD,2)+(I-1.)*DX(JD,2))
  150   YY(JD+1,1,I)=YY(JD,2,I)
      ELSE
        DO 152 I=1,2
        YY(JD,I,2)=FUNSKO(XX(JD,1)+(I-1.)*DX(JD,1),XX(JD,2)+DX(JD,2))
  152   YY(JD+1,I,1)=YY(JD,I,2)
      ENDIF
C...  ESTIMATE THE INTEGRALS OVER NEW CELLS RESULTING FROM DIVISION
      DO 220 JDV=JD,JD+1
      LEV(JDV)=LEV(JDV)+1
      SUM=0D0
      DO 210 I=1,2
      DO 210 K=1,2
      IF(YY(JDV,I,K).LT.0.D0) GO TO 999
  210 SUM=SUM+YY(JDV,I,K)
  220 ZINT(JDV) =SUM*DX(JDV,1)*DX(JDV,2)/4D0
      JMAX=JMAX+1
      RETURN
  999 WRITE(NOUT,9000)
 9000 FORMAT(' **** STOP IN DIVSKW, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END


      SUBROUTINE GAUSJD(FUN,AA,BB,EEPS,RESULT)
C     ****************************************
C Gauss integration by S. Jadach, Oct. 90.
C This is NON-ADAPTIVE (!!!!) UNOPTIMIZED (!!!) integration subprogram.
C     *************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WG(12),XX(12)
      COMMON / INOUT  / NINP,NOUT
      EXTERNAL FUN
      save /inout/,wg,xx,ITERMX 
      DATA WG
     $/0.101228536290376D0, 0.222381034453374D0, 0.313706645877887D0,
     $ 0.362683783378362D0, 0.027152459411754D0, 0.062253523938648D0,
     $ 0.095158511682493D0, 0.124628971255534D0, 0.149595988816577D0,
     $ 0.169156519395003D0, 0.182603415044924D0, 0.189450610455069D0/
      DATA XX
     $/0.960289856497536D0, 0.796666477413627D0, 0.525532409916329D0,
     $ 0.183434642495650D0, 0.989400934991650D0, 0.944575023073233D0,
     $ 0.865631202387832D0, 0.755404408355003D0, 0.617876244402644D0,
     $ 0.458016777657227D0, 0.281603550779259D0, 0.095012509837637D0/
      DATA ITERMX / 15/
      EPS=ABS(EEPS)
      A=AA
      B=BB
      NDIVI=1
C iteration over subdivisions terminated by precision requirement
      DO 400 ITER=1,ITERMX
      CALK8  =0D0
      CALK16 =0D0
C sum over DELTA subintegrals
      DO 200 K = 1,NDIVI
      DELTA = (B-A)/NDIVI
      X1    =  A + (K-1)*DELTA
      X2    =  X1+ DELTA
      XMIDLE= 0.5D0*(X2+X1)
      RANGE = 0.5D0*(X2-X1)
      SUM8 =0D0
      SUM16=0D0
C 8- and 12-point   Gauss integration over single DELTA subinterval
      DO 100 I=1,12
      XPLUS= XMIDLE+RANGE*XX(I)
      XMINU= XMIDLE-RANGE*XX(I)
      FPLUS=FUN(XPLUS)
      FMINU=FUN(XMINU)
      IF(I.LE.4) THEN
          SUM8 =SUM8  +(FPLUS+FMINU)*WG(I)/2D0
      ELSE
          SUM16=SUM16 +(FPLUS+FMINU)*WG(I)/2D0
      ENDIF
  100 CONTINUE
      CALK8 = CALK8 + SUM8 *(X2-X1)
      CALK16= CALK16+ SUM16*(X2-X1)
  200 CONTINUE
      ERABS = ABS(CALK16-CALK8)
      ERELA = 0D0
      IF(CALK16.NE.0D0) ERELA= ERABS/ABS(CALK16)
c     write(6,*) 'gausjd: CALK8,CALK16=',ITER,CALK8,CALK16,ERELA
C precision check to terminate integration
      IF(EEPS.GT.0D0) THEN
        IF(ERABS.LT. EPS) GOTO 800
      ELSE
        IF(ERELA.LT. EPS) GOTO 800
      ENDIF
  400 NDIVI=NDIVI*2
      WRITE(NOUT,*) ' +++++ GAUSJD:  REQUIRED PRECISION TO HIGH!'
      WRITE(NOUT,*) ' +++++ GAUSJD:  ITER,ERELA=',ITER,ERELA
  800 RESULT= CALK16
      END


      SUBROUTINE WMONIT(MODE,ID,WT,WTMAX,RN)
C     **************************************
C last correction 19 sept. 89
C Utility program for monitoring M.C. rejection weights.
C ID is weight idendifier, maximum IDMX (defined below).
C WT IS WEIGHT, WTMAX IS MAXIMUM WEIGHT AND RN IS RANDOM NUMBER.
C IF(MODE.EQ.-1) THEN
C          INITALIZATION IF ENTRY ID, OTHER ARGUMENTS ARE IGNORED
C ELSEIF(MODE.EQ.0) THEN
C          SUMMING UP WEIGHTS ETC. FOR A GIVEN EVENT FOR ENTRY ID
C        - WT IS CURRENT WEIGHT.
C        - WTMAX IS MAXIMUM WEIGHT USED FOR COUTING OVERWEIGHTED
C          EVENTS WITH WT>WTMAX.
C        - RN IS RANDOM NUMBER USED IN REJECTION, IT IS USED TO
C          COUNT NO. OF ACCEPTED (RN<WT/WTMAX) AND REJECTED
C          (WT>WT/WTMAX) EVENTS,
C          IF RO REJECTION THEN PUT RN=0D0.
C ELSEIF(MODE.EQ.1) THEN
C          IN THIS MODE WMONIT REPPORTS ON ACCUMULATED STATISTICS
C          AND THE INFORMATION IS STORED IN COMMON /CMONIT/
C        - AVERWT= AVERAGE WEIGHT WT COUNTING ALL EVENT
C        - ERRELA= RELATIVE ERROR OF AVERWT
C        - NEVTOT= TOTAL NIMBER OF ACCOUNTED EVENTS
C        - NEVACC= NO. OF ACCEPTED EVENTS (RN<WT\WTMAX)
C        - NEVNEG= NO. OF EVENTS WITH NEGATIVE WEIGHT (WT<0)
C        - NEVZER= NO. OF EVENTS WITH ZERO WEIGHT (WT.EQ.0D0)
C        - NEVOVE= NO. OF OVERWEGHTED EVENTS (WT>WTMAX)
C          AND IF YOU DO NOT WANT TO USE CMONIT THEN THE VALUE
C          The value of AVERWT is assigned to WT,
C          the value of ERRELA is assigned to WTMAX and
C          the value of WTMAX  is assigned to RN in this mode.
C ELSEIF(MODEE.EQ.2) THEN
C          ALL INFORMATION DEFINED FOR ENTRY ID DEFINED ABOVE
C          FOR MODE=2 IS JUST PRINTED OF UNIT NOUT
C ENDIF
C NOTE THAT OUTPUT REPPORT (MODE=1,2) IS DONE DYNAMICALLY JUST FOR A
C GIVEN ENTRY ID ONLY AND IT MAY BE REPEATED MANY TIMES FOR ONE ID AND
C FOR VARIOUS ID'S AS WELL.
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      save
      PARAMETER(IDMX=100)
      COMMON / CMONIT/ AVERWT,ERRELA,NEVTOT,NEVACC,NEVNEG,NEVOVE,NEVZER
      COMMON / INOUT  / NINP,NOUT
      INTEGER NTOT(IDMX),NACC(IDMX),NNEG(IDMX),NOVE(IDMX),NZER(IDMX)
      DIMENSION SWT(IDMX),SSWT(IDMX),WWMX(IDMX)
      DATA NTOT /IDMX* -1/  SWT /IDMX*   0D0/
      DATA SSWT /IDMX*0D0/ WWMX /IDMX*-1D-20/
C
      IF(ID.LE.0.OR.ID.GT.IDMX) THEN
           WRITE(NOUT,*) ' =====WMONIT: WRONG ID',ID
           STOP
      ENDIF
      IF(MODE.EQ.-1) THEN
           NTOT(ID)=0
           NACC(ID)=0
           NNEG(ID)=0
           NZER(ID)=0
           NOVE(ID)=0
           SWT(ID)   =0D0
           SSWT(ID)  =0D0
           WWMX(ID)  = -1D-20
      ELSEIF(MODE.EQ.0) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           NTOT(ID)=NTOT(ID)+1
           SWT(ID)=SWT(ID)+WT
           SSWT(ID)=SSWT(ID)+WT**2
           WWMX(ID)= MAX(WWMX(ID),WT)
           IF(WT.EQ.0D0)   NZER(ID)=NZER(ID)+1
           IF(WT.LT.0D0)   NNEG(ID)=NNEG(ID)+1
           IF(WT.GT.WTMAX)      NOVE(ID)=NOVE(ID)+1
           IF(RN*WTMAX.LE.WT)   NACC(ID)=NACC(ID)+1
      ELSEIF(MODE.EQ.1) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
           ENDIF
           NEVTOT=NTOT(ID)
           NEVACC=NACC(ID)
           NEVNEG=NNEG(ID)
           NEVZER=NZER(ID)
           NEVOVE=NOVE(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSEIF(MODE.EQ.2) THEN
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
              WWMAX=WWMX(ID)
           ENDIF
           WRITE(NOUT,1003) ID, AVERWT, ERRELA, WWMAX
           WRITE(NOUT,1004) NTOT(ID),NACC(ID),NNEG(ID),NOVE(ID),NZER(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSE
           WRITE(NOUT,*) ' =====WMONIT: WRONG MODE',MODE
           STOP
      ENDIF
 1003 FORMAT(
     $  ' =======================WMONIT========================'
     $/,'   ID           AVERWT         ERRELA            WWMAX'
     $/,    I5,           E17.7,         F15.9,           E17.7)
 1004 FORMAT(
     $  ' -----------------------------------------------------------'
     $/,'      NEVTOT      NEVACC      NEVNEG      NEVOVE      NEVZER'
     $/,   5I12)
      END

      SUBROUTINE WMONI2(MODE,ID,WT,WTMAX,RN)
C     **************************************
C -------------- SECOND COPY OF WMONIT ----------------
C last correction 19 sept. 89
C Utility program for monitoring M.C. rejection weights.
C ID is weight idendifier, maximum IDMX (defined below).
C WT IS WEIGHT, WTMAX IS MAXIMUM WEIGHT AND RN IS RANDOM NUMBER.
C IF(MODE.EQ.-1) THEN
C          INITALIZATION IF ENTRY ID, OTHER ARGUMENTS ARE IGNORED
C ELSEIF(MODE.EQ.0) THEN
C          SUMMING UP WEIGHTS ETC. FOR A GIVEN EVENT FOR ENTRY ID
C        - WT IS CURRENT WEIGHT.
C        - WTMAX IS MAXIMUM WEIGHT USED FOR COUTING OVERWEIGHTED
C          EVENTS WITH WT>WTMAX.
C        - RN IS RANDOM NUMBER USED IN REJECTION, IT IS USED TO
C          COUNT NO. OF ACCEPTED (RN<WT/WTMAX) AND REJECTED
C          (WT>WT/WTMAX) EVENTS,
C          IF RO REJECTION THEN PUT RN=0D0.
C ELSEIF(MODE.EQ.1) THEN
C          IN THIS MODE WMONIT REPPORTS ON ACCUMULATED STATISTICS
C          AND THE INFORMATION IS STORED IN COMMON /CMONIT/
C        - AVERWT= AVERAGE WEIGHT WT COUNTING ALL EVENT
C        - ERRELA= RELATIVE ERROR OF AVERWT
C        - NEVTOT= TOTAL NIMBER OF ACCOUNTED EVENTS
C        - NEVACC= NO. OF ACCEPTED EVENTS (RN<WT\WTMAX)
C        - NEVNEG= NO. OF EVENTS WITH NEGATIVE WEIGHT (WT<0)
C        - NEVZER= NO. OF EVENTS WITH ZERO WEIGHT (WT.EQ.0D0)
C        - NEVOVE= NO. OF OVERWEGHTED EVENTS (WT>WTMAX)
C          AND IF YOU DO NOT WANT TO USE CMONIT THEN THE VALUE
C          The value of AVERWT is assigned to WT,
C          the value of ERRELA is assigned to WTMAX and
C          the value of WTMAX  is assigned to RN in this mode.
C ELSEIF(MODEE.EQ.2) THEN
C          ALL INFORMATION DEFINED FOR ENTRY ID DEFINED ABOVE
C          FOR MODE=2 IS JUST PRINTED OF UNIT NOUT
C ENDIF
C NOTE THAT OUTPUT REPPORT (MODE=1,2) IS DONE DYNAMICALLY JUST FOR A
C GIVEN ENTRY ID ONLY AND IT MAY BE REPEATED MANY TIMES FOR ONE ID AND
C FOR VARIOUS ID'S AS WELL.
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      save
      PARAMETER(IDMX=100)
      COMMON / CMONI2/ AVERWT,ERRELA,NEVTOT,NEVACC,NEVNEG,NEVOVE,NEVZER
      COMMON / INOUT  / NINP,NOUT
      INTEGER NTOT(IDMX),NACC(IDMX),NNEG(IDMX),NOVE(IDMX),NZER(IDMX)
      DIMENSION SWT(IDMX),SSWT(IDMX),WWMX(IDMX)
      DATA NTOT /IDMX* -1/  SWT /IDMX*   0D0/
      DATA SSWT /IDMX*0D0/ WWMX /IDMX*-1D-20/
C
      IF(ID.LE.0.OR.ID.GT.IDMX) THEN
           WRITE(NOUT,*) ' =====WMONI2: WRONG ID',ID
           STOP
      ENDIF
      IF(MODE.EQ.-1) THEN
           NTOT(ID)=0
           NACC(ID)=0
           NNEG(ID)=0
           NZER(ID)=0
           NOVE(ID)=0
           SWT(ID)   =0D0
           SSWT(ID)  =0D0
           WWMX(ID)  = -1D-20
      ELSEIF(MODE.EQ.0) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           NTOT(ID)=NTOT(ID)+1
           SWT(ID)=SWT(ID)+WT
           SSWT(ID)=SSWT(ID)+WT**2
           WWMX(ID)= MAX(WWMX(ID),WT)
           IF(WT.EQ.0D0)   NZER(ID)=NZER(ID)+1
           IF(WT.LT.0D0)   NNEG(ID)=NNEG(ID)+1
           IF(WT.GT.WTMAX)      NOVE(ID)=NOVE(ID)+1
           IF(RN*WTMAX.LE.WT)   NACC(ID)=NACC(ID)+1
      ELSEIF(MODE.EQ.1) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONI2: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
           ENDIF
           NEVTOT=NTOT(ID)
           NEVACC=NACC(ID)
           NEVNEG=NNEG(ID)
           NEVZER=NZER(ID)
           NEVOVE=NOVE(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSEIF(MODE.EQ.2) THEN
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
              WWMAX=WWMX(ID)
           ENDIF
           WRITE(NOUT,1003) ID, AVERWT, ERRELA, WWMAX
           WRITE(NOUT,1004) NTOT(ID),NACC(ID),NNEG(ID),NOVE(ID),NZER(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSE
           WRITE(NOUT,*) ' =====WMONI2: WRONG MODE',MODE
           STOP
      ENDIF
 1003 FORMAT(
     $  ' =======================WMONI2========================'
     $/,'   ID           AVERWT         ERRELA            WWMAX'
     $/,    I5,           E17.7,         F15.9,           E17.7)
 1004 FORMAT(
     $  ' -----------------------------------------------------------'
     $/,'      NEVTOT      NEVACC      NEVNEG      NEVOVE      NEVZER'
     $/,   5I12)
      END

      FUNCTION GAUS(F,A,B,EEPS)  
C     *************************   
C THIS IS ITERATIVE INTEGRATION PROCEDURE                             
C ORIGINATES  PROBABLY FROM CERN LIBRARY                              
C IT SUBDIVIDES INEGRATION RANGE UNTIL REQUIRED PRECISION IS REACHED  
C PRECISION IS A DIFFERENCE FROM 8 AND 16 POINT GAUSS ITEGR. RESULT   
C EEPS POSITIVE TREATED AS ABSOLUTE PRECISION                         
C EEPS NEGATIVE TREATED AS RELATIVE PRECISION                         
C     *************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      DIMENSION W(12),X(12)        
      COMMON / INOUT  / NINP,NOUT      
      EXTERNAL F                             
      DATA CONST /1.0D-19/     
      save     / INOUT/, CONST, W, X
      DATA W                       
     1/0.10122 85362 90376d0, 0.22238 10344 53374d0, 
     1 0.31370 66458 77887d0, 
     2 0.36268 37833 78362d0, 0.02715 24594 11754d0, 
     2 0.06225 35239 38648d0, 
     3 0.09515 85116 82493d0, 0.12462 89712 55534d0, 
     3 0.14959 59888 16577d0, 
     4 0.16915 65193 95003d0, 0.18260 34150 44924d0, 
     4 0.18945 06104 55069d0/ 
      DATA X                       
     1/0.96028 98564 97536d0, 0.79666 64774 13627d0, 
     1 0.52553 24099 16329d0, 
     2 0.18343 46424 95650d0, 0.98940 09349 91650d0, 
     1 0.94457 50230 73233d0, 
     3 0.86563 12023 87832d0, 0.75540 44083 55003d0, 
     1 0.61787 62444 02644d0, 
     4 0.45801 67776 57227d0, 0.28160 35507 79259d0, 
     1 0.09501 25098 37637d0/ 
      EPS=ABS(EEPS)                
      DELTA=CONST*ABS(A-B)         
      GAUS=0D0                     
      AA=A                         
    5 Y=B-AA                       
      IF(ABS(Y) .LE. DELTA) RETURN 
    2 BB=AA+Y                      
      C1=0.5D0*(AA+BB)             
      C2=C1-AA                     
      S8=0D0                       
      S16=0D0                      
      DO 1 I=1,4                   
      U=X(I)*C2                    
    1 S8=S8+W(I)*(F(C1+U)+F(C1-U)) 
      DO 3 I=5,12                  
      U=X(I)*C2                    
    3 S16=S16+W(I)*(F(C1+U)+F(C1-U))                                  
      S8=S8*C2                     
      S16=S16*C2                   
      IF(EEPS.LT.0D0) THEN         
        IF(ABS(S16-S8) .GT. EPS*ABS(S16)) GO TO 4                     
      ELSE             
        IF(ABS(S16-S8) .GT. EPS) GO TO 4                  
      ENDIF            
      GAUS=GAUS+S16    
      AA=BB            
      GO TO 5          
    4 Y=0.5D0*Y        
      IF(ABS(Y) .GT. DELTA) GOTO 2                        
      WRITE(NOUT,7)                          
      GAUS=0D0                
      RETURN                  
    7 FORMAT(1X,36HGAUS  ... TOO HIGH ACCURACY REQUIRED)         
      END                     

      FUNCTION GAUS2(F,A,B,EEPS)  
C     *************************   
C THIS IS ITERATIVE INTEGRATION PROCEDURE                             
C ORIGINATES  PROBABLY FROM CERN LIBRARY                              
C IT SUBDIVIDES INEGRATION RANGE UNTIL REQUIRED PRECISION IS REACHED  
C PRECISION IS A DIFFERENCE FROM 8 AND 16 POINT GAUSS ITEGR. RESULT   
C EEPS POSITIVE TREATED AS ABSOLUTE PRECISION                         
C EEPS NEGATIVE TREATED AS RELATIVE PRECISION                         
C     *************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      DIMENSION W(12),X(12)        
      COMMON / INOUT  / NINP,NOUT      
      EXTERNAL F                             
      DATA CONST /1.0D-19/     
      save     / INOUT/, CONST, W, X
      DATA W                       
     1/0.10122 85362 90376d0, 0.22238 10344 53374d0, 
     1 0.31370 66458 77887d0, 
     2 0.36268 37833 78362d0, 0.02715 24594 11754d0, 
     2 0.06225 35239 38648d0, 
     3 0.09515 85116 82493d0, 0.12462 89712 55534d0, 
     3 0.14959 59888 16577d0, 
     4 0.16915 65193 95003d0, 0.18260 34150 44924d0, 
     4 0.18945 06104 55069d0/ 
      DATA X                       
     1/0.96028 98564 97536d0, 0.79666 64774 13627d0, 
     1 0.52553 24099 16329d0, 
     2 0.18343 46424 95650d0, 0.98940 09349 91650d0, 
     1 0.94457 50230 73233d0, 
     3 0.86563 12023 87832d0, 0.75540 44083 55003d0, 
     1 0.61787 62444 02644d0, 
     4 0.45801 67776 57227d0, 0.28160 35507 79259d0, 
     1 0.09501 25098 37637d0/ 
      EPS=ABS(EEPS)                
      DELTA=CONST*ABS(A-B)         
      GAUS2=0D0                     
      AA=A                         
    5 Y=B-AA                       
      IF(ABS(Y) .LE. DELTA) RETURN 
    2 BB=AA+Y                      
      C1=0.5D0*(AA+BB)             
      C2=C1-AA                     
      S8=0D0                       
      S16=0D0                      
      DO 1 I=1,4                   
      U=X(I)*C2                    
    1 S8=S8+W(I)*(F(C1+U)+F(C1-U)) 
      DO 3 I=5,12                  
      U=X(I)*C2                    
    3 S16=S16+W(I)*(F(C1+U)+F(C1-U))                                  
      S8=S8*C2                     
      S16=S16*C2                   
      IF(EEPS.LT.0D0) THEN         
        IF(ABS(S16-S8) .GT. EPS*ABS(S16)) GO TO 4                     
      ELSE             
        IF(ABS(S16-S8) .GT. EPS) GO TO 4                  
      ENDIF            
      GAUS2=GAUS2+S16    
      AA=BB            
      GO TO 5          
    4 Y=0.5D0*Y        
      IF(ABS(Y) .GT. DELTA) GOTO 2                        
      WRITE(NOUT,7)                          
      GAUS2=0D0                
      RETURN                  
    7 FORMAT(1X,36HGAUS2 ... TOO HIGH ACCURACY REQUIRED)         
      END                     

      FUNCTION GAUS3(F,A,B,EEPS)  
C     *************************   
C THIS IS ITERATIVE INTEGRATION PROCEDURE                             
C ORIGINATES  PROBABLY FROM CERN LIBRARY                              
C IT SUBDIVIDES INEGRATION RANGE UNTIL REQUIRED PRECISION IS REACHED  
C PRECISION IS A DIFFERENCE FROM 8 AND 16 POINT GAUSS ITEGR. RESULT   
C EEPS POSITIVE TREATED AS ABSOLUTE PRECISION                         
C EEPS NEGATIVE TREATED AS RELATIVE PRECISION                         
C     *************************              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      DIMENSION W(12),X(12)        
      COMMON / INOUT  / NINP,NOUT      
      EXTERNAL F                             
      DATA CONST /1.0D-19/     
      save     / INOUT/, CONST, W, X
      DATA W                       
     1/0.10122 85362 90376d0, 0.22238 10344 53374d0, 
     1 0.31370 66458 77887d0, 
     2 0.36268 37833 78362d0, 0.02715 24594 11754d0, 
     2 0.06225 35239 38648d0, 
     3 0.09515 85116 82493d0, 0.12462 89712 55534d0, 
     3 0.14959 59888 16577d0, 
     4 0.16915 65193 95003d0, 0.18260 34150 44924d0, 
     4 0.18945 06104 55069d0/ 
      DATA X                       
     1/0.96028 98564 97536d0, 0.79666 64774 13627d0, 
     1 0.52553 24099 16329d0, 
     2 0.18343 46424 95650d0, 0.98940 09349 91650d0, 
     1 0.94457 50230 73233d0, 
     3 0.86563 12023 87832d0, 0.75540 44083 55003d0, 
     1 0.61787 62444 02644d0, 
     4 0.45801 67776 57227d0, 0.28160 35507 79259d0, 
     1 0.09501 25098 37637d0/ 
      EPS=ABS(EEPS)                
      DELTA=CONST*ABS(A-B)         
      GAUS3=0D0                     
      AA=A                         
    5 Y=B-AA                       
      IF(ABS(Y) .LE. DELTA) RETURN 
    2 BB=AA+Y                      
      C1=0.5D0*(AA+BB)             
      C2=C1-AA                     
      S8=0D0                       
      S16=0D0                      
      DO 1 I=1,4                   
      U=X(I)*C2                    
    1 S8=S8+W(I)*(F(C1+U)+F(C1-U)) 
      DO 3 I=5,12                  
      U=X(I)*C2                    
    3 S16=S16+W(I)*(F(C1+U)+F(C1-U))                                  
      S8=S8*C2                     
      S16=S16*C2                   
      IF(EEPS.LT.0D0) THEN         
        IF(ABS(S16-S8) .GT. EPS*ABS(S16)) GO TO 4                     
      ELSE             
        IF(ABS(S16-S8) .GT. EPS) GO TO 4                  
      ENDIF            
      GAUS3=GAUS3+S16    
      AA=BB            
      GO TO 5          
    4 Y=0.5D0*Y        
      IF(ABS(Y) .GT. DELTA) GOTO 2                        
      WRITE(NOUT,7)                          
      GAUS3=0D0                
      RETURN                  
    7 FORMAT(1X,36HGAUS3 ... TOO HIGH ACCURACY REQUIRED)         
      END                     

C  CORRECTIONS ST. JADACH   (STJ)
C    DOUBLE PRECISION,
C    THIS PROGRAM IS NOT REALY ABLE TO FIND INTEGRAL
C    WITH RELATIVE PRECISION, EPS IS NOW ABSOLUTE ERROR (INPUT ONLY!!)
C.......................................................................
C
C   PURPOSE           - INTEGRATE A FUNCTION F(X)
C   METHOD            - ADAPTIVE GAUSSIAN
C   USAGE             - CALL GADAP(A0,B0,F,EPS,SUM)
C   PARAMETERS  A0    - LOWER LIMIT (INPUT,REAL)
C               B0    - UPPER LIMIT (INPUT,REAL)
C               F     - FUNCTION F(X) TO BE INTEGRATED. MUST BE
C                       SUPPLIED BY THE USER. (INPUT,REAL FUNCTION)
C               EPS   - DESIRED RELATIVE ACCURACY. IF SUM IS SMALL EPS
C                       WILL BE ABSOLUTE ACCURACY INSTEAD. (INPUT,REAL)
C               SUM   - CALCULATED VALUE FOR THE INTEGRAL (OUTPUT,REAL)
C   PRECISION         - DOUBLE
C   REQ'D PROG'S      - F
C   AUTHOR            - THOMAS JOHANSSON, LDC,1973
C   REFERENCE(S)      - THE AUSTRALIAN COMPUTER JOURNAL,3 P.126 AUG. -71
C
C.......................................................................
      SUBROUTINE DGADAP(A0,B0,F,EPS1,SUM)
*     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/GADAP1/ NUM,IFU
      EXTERNAL F
      DIMENSION A(300),B(300),F1(300),F2(300),F3(300),S(300),N(300)
    1 FORMAT(16H GADAP:I TOO BIG)
      DSUM(F1F,F2F,F3F,AA,BB)=5D0/18D0*(BB-AA)*(F1F+1.6D0*F2F+F3F)

      EPS=EPS1
      IF(EPS.LT.1D-15) EPS=1D-15
      RED=1.3D0
      L=1
      I=1
      SUM=0D0
      C=SQRT(15D0)/5D0
      A(1)=A0
      B(1)=B0
      F1(1)=F(0.5D0*(1D0+C)*A0+0.5D0*(1D0-C)*B0)
      F2(1)=F(0.5D0*(A0+B0))
      F3(1)=F(0.5D0*(1D0-C)*A0+0.5D0*(1D0+C)*B0)
      IFU=3
      S(1)=  DSUM(F1(1),F2(1),F3(1),A0,B0)
  100 CONTINUE
      L=L+1
      N(L)=3
      EPS=EPS*RED
      A(I+1)=A(I)+C*(B(I)-A(I))
      B(I+1)=B(I)
      A(I+2)=A(I)+B(I)-A(I+1)
      B(I+2)=A(I+1)
      A(I+3)=A(I)
      B(I+3)=A(I+2)
      W1=A(I)+(B(I)-A(I))/5D0
      U2=2D0*W1-(A(I)+A(I+2))/2D0
      F1(I+1)=F(A(I)+B(I)-W1)
      F2(I+1)=F3(I)
      F3(I+1)=F(B(I)-A(I+2)+W1)
      F1(I+2)=F(U2)
      F2(I+2)=F2(I)
      F3(I+2)=F(B(I+2)+A(I+2)-U2)
      F1(I+3)=F(A(I)+A(I+2)-W1)
      F2(I+3)=F1(I)
      F3(I+3)=F(W1)
      IFU=IFU+6
      IF(IFU.GT.5000) GOTO 130
      S(I+1)=  DSUM(F1(I+1),F2(I+1),F3(I+1),A(I+1),B(I+1))
      S(I+2)=  DSUM(F1(I+2),F2(I+2),F3(I+2),A(I+2),B(I+2))
      S(I+3)=  DSUM(F1(I+3),F2(I+3),F3(I+3),A(I+3),B(I+3))
      SS=S(I+1)+S(I+2)+S(I+3)
      I=I+3
      IF(I.GT.300)GOTO 120
      SOLD=S(I-3)
*STJ  IF(ABS(SOLD-SS).GT.EPS*(1D0+ABS(SS))/2D0) GOTO 100
      IF(ABS(SOLD-SS).GT.EPS/2D0) GOTO 100
      SUM=SUM+SS
      I=I-4
      N(L)=0
      L=L-1
  110 CONTINUE
      IF(L.EQ.1) GOTO 130
      N(L)=N(L)-1
      EPS=EPS/RED
      IF(N(L).NE.0) GOTO 100
      I=I-1
      L=L-1
      GOTO 110
  120 WRITE(6,1)
 130  CONTINUE
      END

C  CORRECTIONS ST. JADACH   (STJ)
C    DOUBLE PRECISION,
C    THIS PROGRAM IS NOT REALY ABLE TO FIND INTEGRAL
C    WITH RELATIVE PRECISION, EPS IS NOW ABSOLUTE ERROR (INPUT ONLY!!)
C.......................................................................
C
C   PURPOSE           - INTEGRATE A FUNCTION F(X)
C   METHOD            - ADAPTIVE GAUSSIAN
C   USAGE             - CALL GADAP(A0,B0,F,EPS,SUM)
C   PARAMETERS  A0    - LOWER LIMIT (INPUT,REAL)
C               B0    - UPPER LIMIT (INPUT,REAL)
C               F     - FUNCTION F(X) TO BE INTEGRATED. MUST BE
C                       SUPPLIED BY THE USER. (INPUT,REAL FUNCTION)
C               EPS   - DESIRED RELATIVE ACCURACY. IF SUM IS SMALL EPS
C                       WILL BE ABSOLUTE ACCURACY INSTEAD. (INPUT,REAL)
C               SUM   - CALCULATED VALUE FOR THE INTEGRAL (OUTPUT,REAL)
C   PRECISION         - DOUBLE
C   REQ'D PROG'S      - F
C   AUTHOR            - THOMAS JOHANSSON, LDC,1973
C   REFERENCE(S)      - THE AUSTRALIAN COMPUTER JOURNAL,3 P.126 AUG. -71
C
C.......................................................................
      SUBROUTINE DGADA2(A0,B0,F,EPS1,SUM)
*     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/GADAP1/ NUM,IFU
      EXTERNAL F
      DIMENSION A(300),B(300),F1(300),F2(300),F3(300),S(300),N(300)
    1 FORMAT(16H GADAP:I TOO BIG)
      DSUM(F1F,F2F,F3F,AA,BB)=5D0/18D0*(BB-AA)*(F1F+1.6D0*F2F+F3F)

      EPS=EPS1
      IF(EPS.LT.1D-15) EPS=1D-15
      RED=1.3D0
      L=1
      I=1
      SUM=0D0
      C=SQRT(15D0)/5D0
      A(1)=A0
      B(1)=B0
      F1(1)=F(0.5D0*(1D0+C)*A0+0.5D0*(1D0-C)*B0)
      F2(1)=F(0.5D0*(A0+B0))
      F3(1)=F(0.5D0*(1D0-C)*A0+0.5D0*(1D0+C)*B0)
      IFU=3
      S(1)=  DSUM(F1(1),F2(1),F3(1),A0,B0)
  100 CONTINUE
      L=L+1
      N(L)=3
      EPS=EPS*RED
      A(I+1)=A(I)+C*(B(I)-A(I))
      B(I+1)=B(I)
      A(I+2)=A(I)+B(I)-A(I+1)
      B(I+2)=A(I+1)
      A(I+3)=A(I)
      B(I+3)=A(I+2)
      W1=A(I)+(B(I)-A(I))/5D0
      U2=2D0*W1-(A(I)+A(I+2))/2D0
      F1(I+1)=F(A(I)+B(I)-W1)
      F2(I+1)=F3(I)
      F3(I+1)=F(B(I)-A(I+2)+W1)
      F1(I+2)=F(U2)
      F2(I+2)=F2(I)
      F3(I+2)=F(B(I+2)+A(I+2)-U2)
      F1(I+3)=F(A(I)+A(I+2)-W1)
      F2(I+3)=F1(I)
      F3(I+3)=F(W1)
      IFU=IFU+6
      IF(IFU.GT.5000) GOTO 130
      S(I+1)=  DSUM(F1(I+1),F2(I+1),F3(I+1),A(I+1),B(I+1))
      S(I+2)=  DSUM(F1(I+2),F2(I+2),F3(I+2),A(I+2),B(I+2))
      S(I+3)=  DSUM(F1(I+3),F2(I+3),F3(I+3),A(I+3),B(I+3))
      SS=S(I+1)+S(I+2)+S(I+3)
      I=I+3
      IF(I.GT.300)GOTO 120
      SOLD=S(I-3)
*STJ  IF(ABS(SOLD-SS).GT.EPS*(1D0+ABS(SS))/2D0) GOTO 100
      IF(ABS(SOLD-SS).GT.EPS/2D0) GOTO 100
      SUM=SUM+SS
      I=I-4
      N(L)=0
      L=L-1
  110 CONTINUE
      IF(L.EQ.1) GOTO 130
      N(L)=N(L)-1
      EPS=EPS/RED
      IF(N(L).NE.0) GOTO 100
      I=I-1
      L=L-1
      GOTO 110
  120 WRITE(6,1)
 130  CONTINUE
      END

C  CORRECTIONS ST. JADACH   (STJ)
C    DOUBLE PRECISION,
C    THIS PROGRAM IS NOT REALY ABLE TO FIND INTEGRAL
C    WITH RELATIVE PRECISION, EPS IS NOW ABSOLUTE ERROR (INPUT ONLY!!)
C.......................................................................
C
C   PURPOSE           - INTEGRATE A FUNCTION F(X)
C   METHOD            - ADAPTIVE GAUSSIAN
C   USAGE             - CALL GADAP(A0,B0,F,EPS,SUM)
C   PARAMETERS  A0    - LOWER LIMIT (INPUT,REAL)
C               B0    - UPPER LIMIT (INPUT,REAL)
C               F     - FUNCTION F(X) TO BE INTEGRATED. MUST BE
C                       SUPPLIED BY THE USER. (INPUT,REAL FUNCTION)
C               EPS   - DESIRED RELATIVE ACCURACY. IF SUM IS SMALL EPS
C                       WILL BE ABSOLUTE ACCURACY INSTEAD. (INPUT,REAL)
C               SUM   - CALCULATED VALUE FOR THE INTEGRAL (OUTPUT,REAL)
C   PRECISION         - DOUBLE
C   REQ'D PROG'S      - F
C   AUTHOR            - THOMAS JOHANSSON, LDC,1973
C   REFERENCE(S)      - THE AUSTRALIAN COMPUTER JOURNAL,3 P.126 AUG. -71
C
C.......................................................................
      SUBROUTINE DGADA3(A0,B0,F,EPS1,SUM)
*     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/GADAP1/ NUM,IFU
      EXTERNAL F
      DIMENSION A(300),B(300),F1(300),F2(300),F3(300),S(300),N(300)
    1 FORMAT(16H GADAP:I TOO BIG)
      DSUM(F1F,F2F,F3F,AA,BB)=5D0/18D0*(BB-AA)*(F1F+1.6D0*F2F+F3F)

      EPS=EPS1
      IF(EPS.LT.1D-15) EPS=1D-15
      RED=1.3D0
      L=1
      I=1
      SUM=0D0
      C=SQRT(15D0)/5D0
      A(1)=A0
      B(1)=B0
      F1(1)=F(0.5D0*(1D0+C)*A0+0.5D0*(1D0-C)*B0)
      F2(1)=F(0.5D0*(A0+B0))
      F3(1)=F(0.5D0*(1D0-C)*A0+0.5D0*(1D0+C)*B0)
      IFU=3
      S(1)=  DSUM(F1(1),F2(1),F3(1),A0,B0)
  100 CONTINUE
      L=L+1
      N(L)=3
      EPS=EPS*RED
      A(I+1)=A(I)+C*(B(I)-A(I))
      B(I+1)=B(I)
      A(I+2)=A(I)+B(I)-A(I+1)
      B(I+2)=A(I+1)
      A(I+3)=A(I)
      B(I+3)=A(I+2)
      W1=A(I)+(B(I)-A(I))/5D0
      U2=2D0*W1-(A(I)+A(I+2))/2D0
      F1(I+1)=F(A(I)+B(I)-W1)
      F2(I+1)=F3(I)
      F3(I+1)=F(B(I)-A(I+2)+W1)
      F1(I+2)=F(U2)
      F2(I+2)=F2(I)
      F3(I+2)=F(B(I+2)+A(I+2)-U2)
      F1(I+3)=F(A(I)+A(I+2)-W1)
      F2(I+3)=F1(I)
      F3(I+3)=F(W1)
      IFU=IFU+6
      IF(IFU.GT.5000) GOTO 130
      S(I+1)=  DSUM(F1(I+1),F2(I+1),F3(I+1),A(I+1),B(I+1))
      S(I+2)=  DSUM(F1(I+2),F2(I+2),F3(I+2),A(I+2),B(I+2))
      S(I+3)=  DSUM(F1(I+3),F2(I+3),F3(I+3),A(I+3),B(I+3))
      SS=S(I+1)+S(I+2)+S(I+3)
      I=I+3
      IF(I.GT.300)GOTO 120
      SOLD=S(I-3)
*STJ  IF(ABS(SOLD-SS).GT.EPS*(1D0+ABS(SS))/2D0) GOTO 100
      IF(ABS(SOLD-SS).GT.EPS/2D0) GOTO 100
      SUM=SUM+SS
      I=I-4
      N(L)=0
      L=L-1
  110 CONTINUE
      IF(L.EQ.1) GOTO 130
      N(L)=N(L)-1
      EPS=EPS/RED
      IF(N(L).NE.0) GOTO 100
      I=I-1
      L=L-1
      GOTO 110
  120 WRITE(6,1)
 130  CONTINUE
      END


      DOUBLE PRECISION FUNCTION DILOGX(X)
C-------------------------------------------- REMARKS ---------------
C DILOGARITHM FUNCTION: DILOG(X)=INT( -LN(1-Z)/Z ) , 0 < Z < X .
C THIS IS THE CERNLIB VERSION.
C--------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Z=-1.644934066848226D0
      IF(X .LT.-1.D0) GO TO 1
      IF(X .LE. 0.5D0) GO TO 2
      IF(X .EQ. 1.D0) GO TO 3
      IF(X .LE. 2.D0) GO TO 4
      Z=3.289868133696453D0
    1 T=1.D0/X
      S=-0.5D0
      Z=Z-0.5D0*DLOG(DABS(X))**2
      GO TO 5
    2 T=X
      S=0.5D0
      Z=0.D0
      GO TO 5
    3 DILOGX=1.644934066848226D0
      RETURN
    4 T=1.D0-X
      S=-0.5D0
      Z=1.644934066848226D0-DLOG(X)*DLOG(DABS(T))
    5 Y=2.666666666666667D0*T+0.666666666666667D0
      B=      0.000000000000001D0
      A=Y*B  +0.000000000000004D0
      B=Y*A-B+0.000000000000011D0
      A=Y*B-A+0.000000000000037D0
      B=Y*A-B+0.000000000000121D0
      A=Y*B-A+0.000000000000398D0
      B=Y*A-B+0.000000000001312D0
      A=Y*B-A+0.000000000004342D0
      B=Y*A-B+0.000000000014437D0
      A=Y*B-A+0.000000000048274D0
      B=Y*A-B+0.000000000162421D0
      A=Y*B-A+0.000000000550291D0
      B=Y*A-B+0.000000001879117D0
      A=Y*B-A+0.000000006474338D0
      B=Y*A-B+0.000000022536705D0
      A=Y*B-A+0.000000079387055D0
      B=Y*A-B+0.000000283575385D0
      A=Y*B-A+0.000001029904264D0
      B=Y*A-B+0.000003816329463D0
      A=Y*B-A+0.000014496300557D0
      B=Y*A-B+0.000056817822718D0
      A=Y*B-A+0.000232002196094D0
      B=Y*A-B+0.001001627496164D0
      A=Y*B-A+0.004686361959447D0
      B=Y*A-B+0.024879322924228D0
      A=Y*B-A+0.166073032927855D0
      A=Y*A-B+1.935064300869969D0
      DILOGX=S*T*(A-B)+Z
      END

      DOUBLE PRECISION FUNCTION DILOGY(X)
C-------------------------------------------- REMARKS ---------------
C DILOGARITHM FUNCTION: DILOG(X)=INT( -LN(1-Z)/Z ) , 0 < Z < X .
C THIS IS THE CERNLIB VERSION.
C--------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Z=-1.644934066848226D0
      IF(X .LT.-1.D0) GO TO 1
      IF(X .LE. 0.5D0) GO TO 2
      IF(X .EQ. 1.D0) GO TO 3
      IF(X .LE. 2.D0) GO TO 4
      Z=3.289868133696453D0
    1 T=1.D0/X
      S=-0.5D0
      Z=Z-0.5D0*DLOG(DABS(X))**2
      GO TO 5
    2 T=X
      S=0.5D0
      Z=0.D0
      GO TO 5
    3 DILOGY=1.644934066848226D0
      RETURN
    4 T=1.D0-X
      S=-0.5D0
      Z=1.644934066848226D0-DLOG(X)*DLOG(DABS(T))
    5 Y=2.666666666666667D0*T+0.666666666666667D0
      B=      0.000000000000001D0
      A=Y*B  +0.000000000000004D0
      B=Y*A-B+0.000000000000011D0
      A=Y*B-A+0.000000000000037D0
      B=Y*A-B+0.000000000000121D0
      A=Y*B-A+0.000000000000398D0
      B=Y*A-B+0.000000000001312D0
      A=Y*B-A+0.000000000004342D0
      B=Y*A-B+0.000000000014437D0
      A=Y*B-A+0.000000000048274D0
      B=Y*A-B+0.000000000162421D0
      A=Y*B-A+0.000000000550291D0
      B=Y*A-B+0.000000001879117D0
      A=Y*B-A+0.000000006474338D0
      B=Y*A-B+0.000000022536705D0
      A=Y*B-A+0.000000079387055D0
      B=Y*A-B+0.000000283575385D0
      A=Y*B-A+0.000001029904264D0
      B=Y*A-B+0.000003816329463D0
      A=Y*B-A+0.000014496300557D0
      B=Y*A-B+0.000056817822718D0
      A=Y*B-A+0.000232002196094D0
      B=Y*A-B+0.001001627496164D0
      A=Y*B-A+0.004686361959447D0
      B=Y*A-B+0.024879322924228D0
      A=Y*B-A+0.166073032927855D0
      A=Y*A-B+1.935064300869969D0
      DILOGY=S*T*(A-B)+Z
      END


      DOUBLE PRECISION FUNCTION DPGAMM(Z)
C     **********************************
C Double precision Gamma function
      DOUBLE PRECISION Z,Z1,X,X1,X2,D1,D2,S1,S2,S3,PI,C(20),CONST
      save C,PI,CONST
      DATA C( 1) / 8.3333333333333333333333333332D-02/
      DATA C( 2) /-2.7777777777777777777777777777D-03/
      DATA C( 3) / 7.9365079365079365079365079364D-04/
      DATA C( 4) /-5.9523809523809523809523809523D-04/
      DATA C( 5) / 8.4175084175084175084175084175D-04/
      DATA C( 6) /-1.9175269175269175269175269175D-03/
      DATA C( 7) / 6.4102564102564102564102564102D-03/
      DATA C( 8) /-2.9550653594771241830065359477D-02/
      DATA C( 9) / 1.7964437236883057316493849001D-01/
      DATA C(10) /-1.3924322169059011164274322169D+00/
      DATA C(11) / 1.3402864044168391994478951001D+01/
      DATA C(12) /-1.5684828462600201730636513245D+02/
      DATA C(13) / 2.1931033333333333333333333333D+03/
      DATA C(14) /-3.6108771253724989357173265219D+04/
      DATA C(15) / 6.9147226885131306710839525077D+05/
      DATA C(16) /-1.5238221539407416192283364959D+07/
      DATA C(17) / 3.8290075139141414141414141414D+08/
      DATA C(18) /-1.0882266035784391089015149165D+10/
      DATA C(19) / 3.4732028376500225225225225224D+11/
      DATA C(20) /-1.2369602142269274454251710349D+13/
      DATA PI    / 3.1415926535897932384626433832D+00/
      DATA CONST / 9.1893853320467274178032973641D-01/
      IF(Z.GT.5.75D 1)                                     GOTO  6666
      NN = Z
      IF (Z  -  DBLE(FLOAT(NN)))                 3,1,3
    1 IF (Z    .LE.    0.D 0)                    GOTO 6667
      DPGAMM = 1.D 0
      IF (Z    .LE.    2.D 0)                    RETURN
      Z1 = Z
    2 Z1 = Z1  -  1.D 0
      DPGAMM = DPGAMM * Z1
      IF (Z1  -  2.D 0)                          61,61,2
    3 IF (DABS(Z)    .LT.    1.D-29)             GOTO 60
      IF (Z    .LT.    0.D 0)                    GOTO 4
      X  = Z
      KK = 1
      GOTO 10
    4 X  = 1.D 0  -  Z
      KK = 2
   10 X1 = X
      IF (X    .GT.    19.D 0)                   GOTO 13
      D1 = X
   11 X1 = X1  +  1.D 0
      IF (X1    .GE.    19.D 0)                  GOTO 12
      D1 = D1 * X1
      GOTO 11
   12 S3 = -DLOG(D1)
      GOTO 14
   13 S3 = 0.D 0
   14 D1 = X1 * X1
      S1 = (X1  -  5.D-1) * DLOG(X1)  -  X1  +  CONST
      DO 20                  K=1,20
      S2 = S1  +  C(K)/X1
      IF (DABS(S2  -  S1)    .LT.    1.D-28)     GOTO 21
      X1 = X1 * D1
   20 S1 = S2
   21 S3 = S3  +  S2
      GOTO (50,22),    KK
   22 D2 = DABS(Z  -  NN)
      D1 = D2 * PI
      IF (D1    .LT.    1.D-15)                  GOTO 31
   30 X2 =  DLOG(PI/DSIN(D1))  -  S3
      GOTO 40
   31 X2 = -DLOG(D2)
   40 MM = DABS(Z)
      IF(X2      .GT.      1.74D2)                         GO TO 6666
      DPGAMM = DEXP(X2)
      IF (MM    .NE.    (MM/2) * 2)              RETURN
      DPGAMM = -DPGAMM
      RETURN
   50 IF(S3      .GT.      1.74D2)                         GO TO 6666
      DPGAMM = DEXP(S3)
      RETURN
 6666 PRINT *, 2000
      RETURN
 6667 PRINT *, 2001
      RETURN
   60 DPGAMM = 0.D 0
      IF(DABS(Z)   .LT.   1.D-77)   RETURN
      DPGAMM = 1.D 0/Z
   61 RETURN
 2000 FORMAT (/////, 2X, 32HDPGAMM ..... ARGUMENT TOO LARGE., /////)
 2001 FORMAT (/////, 2X, 32HDPGAMM ..... ARGUMENT IS A POLE., /////)
      END




C=======================================================================
C=======================================================================
C=======================================================================
C==Received: by dxmint.cern.ch (cernvax) (5.57/3.14)
C== id AA13405; Wed, 23 Jan 91 17:19:06 +0100
C==Message-Id: <9101231619.AA13405@dxmint.cern.ch>
C==Received: by cernapo; Wed, 23 Jan 91 17:23:40 +0100
C==Received: by apojames.cern.ch; Wed, 23 Jan 91 17:05:23 CET
C==Date: Wed, 23 Jan 91 17:05:23 CET
C==From: james@cernapo.cern.ch (Frederick James)
C==To: jadach@cernvm
C==Subject: Random generators
C==
C==      PROGRAM PSEUDORAN
C==C  CPC # ABTK                                           CPC # ABTK
C==C         Pseudorandom generator demonstration (test case)
C==      DIMENSION RVEC(1000)
C==      DIMENSION VERI(5), ISD25(25)
C==C
C==C
C==C   ................................................
C==      WRITE(6,'(20X,A)') 'DEMONSTRATION OF PSEUDORANDOM GENERATORS'
C==      WRITE(6,'(20X,A)') 'MACHINE/SYSTEM: date:'
C==      WRITE(6,'(/20X,A/)') 'INITIALIZATION AND TEST OF PORTABILITY'
C==C   ................................................
C==C
C==C                   initialization and verification  RANMAR
C==        DO 40 I9= 1, 20
C==   40   CALL RANMAR(RVEC,1000)
C==      CALL RANMAR(RVEC,5)
C==      DO 41 I= 1 ,5
C==   41 VERI(I) = (4096.*RVEC(I))*(4096.)
C==      WRITE(6,'(A,5F12.1/)') '  RANMAR 20001  ',VERI
C==C
C==C                   initialization and verification  RANECU
C==      CALL RANECU(RVEC,1000)
C==      CALL RANECU(VERI,5)
C==      DO 52 I= 1 ,5
C==   52 VERI(I) = 4096.*(4096.*VERI(I))
C==      WRITE(6,'(A,5F12.1/)') '  RANECU 1001   ',VERI
C==C
C==C                   initialization and verification  RCARRY
C==      CALL RCARRY(RVEC,1000)
C==      CALL RCARRY(VERI,5)
C==      DO 62 I= 1 ,5
C==   62 VERI(I) = 4096.*(4096.*VERI(I))
C==      WRITE(6,'(A,5F12.1/)') '  RCARRY 1001   ',VERI
C==C
C==      WRITE(6,'(//20X,A/)') 'TEST OF REPEATABILITY'
C==C  .................................................
C==C                  verify restarting      RANMAR
C==      WRITE(6,'(/A)') '   THE NEXT LINE SHOULD BE REPEATED:'
C==      CALL RMARUT(IMAR1,IMAR2,IMAR3)
C==      CALL RANMAR(RVEC,777)
C==      CALL RANMAR(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RANMAR 1 ',VERI
C==      CALL RMARIN(IMAR1,IMAR2,IMAR3)
C==      CALL RANMAR(RVEC,777)
C==      CALL RANMAR(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RANMAR 2 ',VERI
C==C
C==C                  verify restarting      RANECU
C==      WRITE(6,'(/A)') '   THE NEXT LINE SHOULD BE REPEATED:'
C==      CALL RECUUT(IS1,IS2)
C==      CALL RANECU(RVEC,777)
C==      CALL RANECU(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RANECU 1 ',VERI
C==      CALL RECUIN(IS1,IS2)
C==      CALL RANECU(RVEC,777)
C==      CALL RANECU(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RANECU 2 ',VERI
C==C
C==C                  verify restarting      RCARRY
C==      WRITE(6,'(/A)') '   THE NEXT LINE SHOULD BE REPEATED:'
C==      CALL RCARUT(ISD25)
C==      CALL RCARRY(RVEC,777)
C==      CALL RCARRY(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RCARRY 1 ',VERI
C==      CALL RCARIN(ISD25)
C==      CALL RCARRY(RVEC,777)
C==      CALL RCARRY(VERI,5)
C==      WRITE(6,'(A,5F12.9)') '       RCARRY 2 ',VERI
C==C
C==      STOP
C==      END
C=======================================================================
C=======================================================================
C=======================================================================
      SUBROUTINE MARRAN(RVEC,LENV)
C =======================S. JADACH===================================
C == This commes from F. James, The name of RANMAR is changed to   ==
C == MARRAN in order to avoid interference with the version        ==
C == already in use and the public library version (if present).   ==
C ==      THIS IS THE ONLY MODIFICATION !!!!                       ==
C ========================S. JADACH==================================
C Universal random number generator proposed by Marsaglia and Zaman
C in report FSU-SCRI-87-50
C        modified by F. James, 1988 and 1989, to generate a vector
C        of pseudorandom numbers RVEC of length LENV, and to put in
C        the COMMON block everything needed to specify currrent state,
C        and to add input and output entry points MARINI, MAROUT.
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for RANMAR:                                  ++
C!!!      CALL RANMAR (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL MARINI(I1,N1,N2)   initializes the generator from one ++
C!!!                   32-bit integer I1, and number counts N1,N2    ++
C!!!                  (for initializing, set N1=N2=0, but to restart ++
C!!!                    a previously generated sequence, use values  ++
C!!!                    output by MAROUT)                            ++
C!!!      CALL MAROUT(I1,N1,N2)   outputs the value of the original  ++
C!!!                  seed and the two number counts, to be used     ++
C!!!                  for restarting by initializing to I1 and       ++
C!!!                  skipping N2*100000000+N1 numbers.              ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(*)
      PARAMETER (MODCNS=1000000000)
C!!!  COMMON/RASET1/U(97),C,I97,J97
      DIMENSION     U(97)
      SAVE          U    ,C,I97,J97
      SAVE CD, CM, TWOM24, NTOT, NTOT2, IJKL
      DATA NTOT,NTOT2,IJKL/-1,0,0/
C
      IF (NTOT .GE. 0)  GO TO 50
C
C        Default initialization. User has called RANMAR without MARINI.
      IJKL = 54217137
      NTOT = 0
      NTOT2 = 0
      KALLED = 0
      GO TO 1
C
      ENTRY      MARINI(IJKLIN, NTOTIN,NTOT2N)
C         Initializing routine for RANMAR, may be called before
C         generating pseudorandom numbers with RANMAR. The input
C         values should be in the ranges:  0<=IJKLIN<=900 OOO OOO
C                                          0<=NTOTIN<=999 999 999
C                                          0<=NTOT2N<<999 999 999!
C To get the standard values in Marsaglia's paper, IJKLIN=54217137
C                                            NTOTIN,NTOT2N=0
      IJKL = IJKLIN
      NTOT = MAX(NTOTIN,0)
      NTOT2= MAX(NTOT2N,0)
      KALLED = 1
C          always come here to initialize
    1 CONTINUE
      IJ = IJKL/30082
      KL = IJKL - 30082*IJ
      I = MOD(IJ/177, 177) + 2
      J = MOD(IJ, 177)     + 2
      K = MOD(KL/169, 178) + 1
      L = MOD(KL, 169)
      WRITE(6,'(A,5I10)')
     $' MARran INITIALIZED: IJ,KL,IJKL,NTOT,NTOT2=',IJ,KL,IJKL,NTOT,NTOT2
      DO 2 II= 1, 97
      S = 0.
      T = .5
      DO 3 JJ= 1, 24
         M = MOD(MOD(I*J,179)*K, 179)
         I = J
         J = K
         K = M
         L = MOD(53*L+1, 169)
         IF (MOD(L*M,64) .GE. 32)  S = S+T
    3    T = 0.5*T
    2 U(II) = S
      TWOM24 = 1.0
      DO 4 I24= 1, 24
    4 TWOM24 = 0.5*TWOM24
      C  =   362436.*TWOM24
      CD =  7654321.*TWOM24
      CM = 16777213.*TWOM24
      I97 = 97
      J97 = 33
C       Complete initialization by skipping
C            (NTOT2*MODCNS + NTOT) random numbers
      DO 45 LOOP2= 1, NTOT2+1
      NOW = MODCNS
      IF (LOOP2 .EQ. NTOT2+1)  NOW=NTOT
      IF (NOW .GT. 0)  THEN
        WRITE(6,'(A,I15)') ' MARINI SKIPPING OVER ',NOW
       DO 40 IDUM = 1, NTOT
       UNI = U(I97)-U(J97)
       IF (UNI .LT. 0.)  UNI=UNI+1.
       U(I97) = UNI
       I97 = I97-1
       IF (I97 .EQ. 0)  I97=97
       J97 = J97-1
       IF (J97 .EQ. 0)  J97=97
       C = C - CD
       IF (C .LT. 0.)  C=C+CM
   40  CONTINUE
      ENDIF
   45 CONTINUE
      IF (KALLED .EQ. 1)  RETURN
C
C          Normal entry to generate LENV random numbers
   50 CONTINUE
      DO 100 IVEC= 1, LENV
      UNI = U(I97)-U(J97)
      IF (UNI .LT. 0.)  UNI=UNI+1.
      U(I97) = UNI
      I97 = I97-1
      IF (I97 .EQ. 0)  I97=97
      J97 = J97-1
      IF (J97 .EQ. 0)  J97=97
      C = C - CD
      IF (C .LT. 0.)  C=C+CM
      UNI = UNI-C
      IF (UNI .LT. 0.) UNI=UNI+1.
      RVEC(IVEC) = UNI
C             Replace exact zeros by uniform distr. *2**-24
         IF (UNI .EQ. 0.)  THEN
         ZUNI = TWOM24*U(2)
C             An exact zero here is very unlikely, but let's be safe.
         IF (ZUNI .EQ. 0.) ZUNI= TWOM24*TWOM24
         RVEC(IVEC) = ZUNI
         ENDIF
  100 CONTINUE
      NTOT = NTOT + LENV
         IF (NTOT .GE. MODCNS)  THEN
         NTOT2 = NTOT2 + 1
         NTOT = NTOT - MODCNS
         ENDIF
      RETURN
C           Entry to output current status
      ENTRY MAROUT(IJKLUT,NTOTUT,NTOT2T)
      IJKLUT = IJKL
      NTOTUT = NTOT
      NTOT2T = NTOT2
      RETURN
      END
      SUBROUTINE CARRAN(RVEC,LENV)
C         Add-and-carry random number generator proposed by
C         Marsaglia and Zaman in SIAM J. Scientific and Statistical
C             Computing, to appear probably 1990.
C         modified with enhanced initialization by F. James, 1990
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for CARRAN:                                  ++
C!!!      CALL CARRAN (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL CARINI(INT)     initializes the generator from one    ++
C!!!                   32-bit integer INT                            ++
C!!!      CALL CARRES(IVEC)    restarts the generator from vector    ++
C!!!                   IVEC of 25 32-bit integers (see CAROUT)       ++
C!!!      CALL CAROUT(IVEC)    outputs the current values of the 25  ++
C!!!                 32-bit integer seeds, to be used for restarting ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(LENV)
      DIMENSION SEEDS(24), ISEEDS(24), ISDEXT(25)
      PARAMETER (TWOP12=4096.)
      PARAMETER (ITWO24=2**24, ICONS=2147483563)
      SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24
      LOGICAL NOTYET
      DATA NOTYET/.TRUE./
      DATA I24,J24,CARRY/24,10,0./
C
C              Default Initialization by Multiplicative Congruential
      IF (NOTYET) THEN
         NOTYET = .FALSE.
         JSEED = 314159265
         WRITE(6,'(A,I12)') ' CARRAN DEFAULT INITIALIZATION: ',JSEED
            TWOM24 = 1.
         DO 25 I= 1, 24
            TWOM24 = TWOM24 * 0.5
         K = JSEED/53668
         JSEED = 40014*(JSEED-K*53668) -K*12211
         IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
         ISEEDS(I) = MOD(JSEED,ITWO24)
   25    CONTINUE
         DO 50 I= 1,24
         SEEDS(I) = REAL(ISEEDS(I))*TWOM24
   50    CONTINUE
         I24 = 24
         J24 = 10
         CARRY = 0.
         IF (SEEDS(24) .LT. SEEDS(14)) CARRY = TWOM24
      ENDIF
C
C          The Generator proper: "Subtract-with-borrow",
C          as proposed by Marsaglia and Zaman,
C          Florida State University, March, 1989
C
      DO 100 IVEC= 1, LENV
      UNI = SEEDS(I24) - SEEDS(J24) - CARRY
      IF (UNI .LT. 0.)  THEN
         UNI = UNI + 1.0
         CARRY = TWOM24
      ELSE
         CARRY = 0.
      ENDIF
      SEEDS(I24) = UNI
      I24 = I24 - 1
      IF (I24 .EQ. 0)  I24 = 24
      J24 = J24 - 1
      IF (J24 .EQ. 0)  J24 = 24
      RVEC(IVEC) = UNI
  100 CONTINUE
      RETURN
C           Entry to input and float integer seeds from previous run
      ENTRY CARRES(ISDEXT)
         TWOM24 = 1.
         DO 195 I= 1, 24
  195    TWOM24 = TWOM24 * 0.5
      WRITE(6,'(A)') ' FULL INITIALIZATION OF CARRAN WITH 25 INTEGERS:'
      WRITE(6,'(5X,5I12)') ISDEXT
      DO 200 I= 1, 24
      SEEDS(I) = REAL(ISDEXT(I))*TWOM24
  200 CONTINUE
      CARRY = REAL(MOD(ISDEXT(25),10))*TWOM24
      ISD = ISDEXT(25)/10
      I24 = MOD(ISD,100)
      ISD = ISD/100
      J24 = ISD
      RETURN
C                    Entry to ouput seeds as integers
      ENTRY CAROUT(ISDEXT)
      DO 300 I= 1, 24
         ISDEXT(I) = INT(SEEDS(I)*TWOP12*TWOP12)
  300 CONTINUE
      ICARRY = 0
      IF (CARRY .GT. 0.)  ICARRY = 1
      ISDEXT(25) = 1000*J24 + 10*I24 + ICARRY
      RETURN
C                    Entry to initialize from one integer
      ENTRY CARINI(INSEED)
      JSEED = INSEED
      WRITE(6,'(A,I12)') ' CARRAN INITIALIZED FROM SEED ',INSEED
C      TWOM24 = 1.
         DO 325 I= 1, 24
           TWOM24 = TWOM24 * 0.5
         K = JSEED/53668
         JSEED = 40014*(JSEED-K*53668) -K*12211
         IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
         ISEEDS(I) = MOD(JSEED,ITWO24)
  325    CONTINUE
         DO 350 I= 1,24
         SEEDS(I) = REAL(ISEEDS(I))*TWOM24
  350    CONTINUE
         I24 = 24
         J24 = 10
         CARRY = 0.
         IF (SEEDS(24) .LT. SEEDS(14)) CARRY = TWOM24
      RETURN
      END

      SUBROUTINE ECURAN(RVEC,LEN)
C         Random number generator given by L'Ecuyer in
C            Comm. ACM Vol 31, p.742, 1988
C            modified by F. James to return a vector of numbers
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for ECURAN:                                  ++
C!!!      CALL ECURAN (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL ECUINI(I1,I2)    initializes the generator from two   ++
C!!!                   32-bit integers I1 and I2                     ++
C!!!      CALL ECUOUT(I1,I2)    outputs the current values of the    ++
C!!!                   two integer seeds, to be used for restarting  ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(*)
      SAVE ISEED1,ISEED2
      DATA ISEED1,ISEED2 /12345,67890/
C
      DO 100 I= 1, LEN
      K = ISEED1/53668
      ISEED1 = 40014*(ISEED1 - K*53668) - K*12211
      IF (ISEED1 .LT. 0) ISEED1=ISEED1+2147483563
C
      K = ISEED2/52774
      ISEED2 = 40692*(ISEED2 - K*52774) - K* 3791
      IF (ISEED2 .LT. 0) ISEED2=ISEED2+2147483399
C
      IZ = ISEED1 - ISEED2
      IF (IZ .LT. 1)  IZ = IZ + 2147483562
C
      RVEC(I) = REAL(IZ) * 4.656613E-10
  100 CONTINUE
      RETURN
C
      ENTRY ECUINI(IS1,IS2)
      ISEED1 = IS1
      ISEED2 = IS2
      RETURN
C
      ENTRY ECUOUT(IS1,IS2)
      IS1 = ISEED1
      IS2 = ISEED2
      RETURN
      END

      SUBROUTINE VARRAN(DRVEC,LENGT)
C     ***************************
C Switchable random number generator
C Translation to double precision
C     ***************************
      COMMON / RANPAR / KEYRND
      save   / RANPAR /
      DOUBLE PRECISION DRVEC(*)
      DIMENSION RVEC(1000)
      IF(LENGT.LT.1.OR.LENGT.GT.1000) GOTO 901
   10 CONTINUE
      IF(KEYRND.EQ.1) THEN
         CALL MARRAN(RVEC,LENGT)
      ELSEIF(KEYRND.EQ.2) THEN
         CALL ECURAN(RVEC,LENGT)
      ELSEIF(KEYRND.EQ.3) THEN
         CALL CARRAN(RVEC,LENGT)
      ELSE
         GOTO 902
      ENDIF
C random numbers 0 and 1 not accepted
      DO 30 I=1,LENGT
      IF(RVEC(I).LE.0E0.OR.RVEC(I).GE.1E0) THEN
        WRITE(6,*) ' +++++ VARRAN: RVEC=',RVEC(I)
        GOTO 10
      ENDIF
      DRVEC(I)=RVEC(I)
   30 CONTINUE
      RETURN
  901 WRITE(6,*) ' +++++ STOP IN VARRAN: LENGT=',LENGT
      STOP
  902 WRITE(6,*) ' +++++ STOP IN VARRAN: WRONG KEYRND',KEYRND
      STOP
      END

      SUBROUTINE BOSTDQ(MODE,QQ,PP,R)        
C     *******************************        
C BOOST ALONG ARBITRARY AXIS (BY RONALD KLEISS).
C P BOOSTED INTO R  FROM ACTUAL FRAME TO REST FRAME OF Q  
C FORTH (MODE = 1) OR BACK (MODE = -1).      
C Q MUST BE A TIMELIKE, P MAY BE ARBITRARY.  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)    
      PARAMETER ( NOUT =6 )                         
      DIMENSION QQ(*),PP(*),R(*)             
      DIMENSION Q(4),P(4)                    

      DO 10 K=1,4                            
      P(K)=PP(K)                             
   10 Q(K)=QQ(K)                             
      AMQ =DSQRT(Q(4)**2-Q(1)**2-Q(2)**2-Q(3)**2) 
      IF    (MODE.EQ.-1) THEN                
         R(4) = (P(1)*Q(1)+P(2)*Q(2)+P(3)*Q(3)+P(4)*Q(4))/AMQ 
         FAC  = (R(4)+P(4))/(Q(4)+AMQ)       
      ELSEIF(MODE.EQ. 1) THEN                
         R(4) =(-P(1)*Q(1)-P(2)*Q(2)-P(3)*Q(3)+P(4)*Q(4))/AMQ  
         FAC  =-(R(4)+P(4))/(Q(4)+AMQ)       
      ELSE                                   
         WRITE(NOUT,*) ' ++++++++ WRONG MODE IN BOOST3 ' 
         STOP                                
      ENDIF                                  
      R(1)=P(1)+FAC*Q(1)                     
      R(2)=P(2)+FAC*Q(2)                     
      R(3)=P(3)+FAC*Q(3)                     
      END                                    


C BOOST ALONG X AXIS, EXE=EXP(ETA), ETA= HIPERBOLIC VELOCITY.
      SUBROUTINE BOSTD1(EXE,PVEC,QVEC)
C     ********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION PVEC(4),QVEC(4),RVEC(4)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      RPL=RVEC(4)+RVEC(1)
      RMI=RVEC(4)-RVEC(1)
      QPL=RPL*EXE
      QMI=RMI/EXE
      QVEC(2)=RVEC(2)
      QVEC(3)=RVEC(3)
      QVEC(1)=(QPL-QMI)/2
      QVEC(4)=(QPL+QMI)/2
      END

C BOOST ALONG Z AXIS, EXE=EXP(ETA), ETA= HIPERBOLIC VELOCITY.
      SUBROUTINE BXSTD3(EXE,PVEC,QVEC)
C     ********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION PVEC(4),QVEC(4),RVEC(4)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      RPL=RVEC(4)+RVEC(3)
      RMI=RVEC(4)-RVEC(3)
      QPL=RPL*EXE
      QMI=RMI/EXE
      QVEC(1)=RVEC(1)
      QVEC(2)=RVEC(2)
      QVEC(3)=(QPL-QMI)/2
      QVEC(4)=(QPL+QMI)/2
      END

      SUBROUTINE RXTOD1(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)=RVEC(1)
      QVEC(2)= CS*RVEC(2)-SN*RVEC(3)
      QVEC(3)= SN*RVEC(2)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      END

      SUBROUTINE RXTOD2(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)+SN*RVEC(3)
      QVEC(2)=RVEC(2)
      QVEC(3)=-SN*RVEC(1)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      END

      SUBROUTINE RXTOD3(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)-SN*RVEC(2)
      QVEC(2)= SN*RVEC(1)+CS*RVEC(2)
      QVEC(3)=RVEC(3)
      QVEC(4)=RVEC(4)
      END

      FUNCTION ANGFIX(X,Y)
C     *******************
* CALCULATES ANGLE IN (0,2*PI) RANGE OUT OF X-Y
*     ***********************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DATA PI /3.1415926535897932D0/

      IF(ABS(Y).LT.ABS(X)) THEN
        THE=ATAN(ABS(Y/X))
        IF(X.LE.0D0) THE=PI-THE
      ELSE
        THE=ACOS(X/SQRT(X**2+Y**2))
      ENDIF
      IF(Y.LT.0D0) THE=2D0*PI-THE
      ANGFIX=THE
      END

      SUBROUTINE DUMPT(NUNIT,WORD,PP)        
C     *******************************        
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)               
      CHARACTER*8 WORD                       
      DOUBLE PRECISION PP(4)                           
      AMS=PP(4)**2-PP(3)**2-PP(2)**2-PP(1)**2  
      IF(AMS.GT.0.0) AMS=SQRT(AMS)           
      WRITE(NUNIT,'(1X,A8,5(1X,F13.8))') WORD,(PP(I),I=1,4),AMS 
C====================================================================== 
C================END OF YFSLIB========================================= 
C====================================================================== 
      END 
      FUNCTION ANGFI(X,Y)
C ----------------------------------------------------------------------
* CALCULATES ANGLE IN (0,2*PI) RANGE OUT OF X-Y
C
C     USED BY : KORALZ RADKOR
C ----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DATA PI /3.141592653589793238462643D0/
C
      IF(ABS(Y).LT.ABS(X)) THEN
        THE=ATAN(ABS(Y/X))
        IF(X.LE.0D0) THE=PI-THE
      ELSE
        THE=ACOS(X/SQRT(X**2+Y**2))
      ENDIF
      IF(Y.LT.0D0) THE=2D0*PI-THE
      ANGFI=THE
      END
      SUBROUTINE ROTOD1(PH1,PVEC,QVEC)
C ----------------------------------------------------------------------
C
C     USED BY : KORALZ
C ----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PVEC(4),QVEC(4),RVEC(4)
C
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)=RVEC(1)
      QVEC(2)= CS*RVEC(2)-SN*RVEC(3)
      QVEC(3)= SN*RVEC(2)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      RETURN
      END
      SUBROUTINE ROTOD2(PH1,PVEC,QVEC)
C ----------------------------------------------------------------------
C
C     USED BY : KORALZ RADKOR
C ----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PVEC(4),QVEC(4),RVEC(4)
C
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)+SN*RVEC(3)
      QVEC(2)=RVEC(2)
      QVEC(3)=-SN*RVEC(1)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      RETURN
      END
      SUBROUTINE ROTOD3(PH1,PVEC,QVEC)
C ----------------------------------------------------------------------
C
C     USED BY : KORALZ RADKOR
C ----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)-SN*RVEC(2)
      QVEC(2)= SN*RVEC(1)+CS*RVEC(2)
      QVEC(3)=RVEC(3)
      QVEC(4)=RVEC(4)
      END
